begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C++ Parser.    Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.    Written by Mark Mitchell<mark@codesourcery.com>.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"dyn-string.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* The lexer.  */
end_comment

begin_comment
comment|/* Overview    --------     A cp_lexer represents a stream of cp_tokens.  It allows arbitrary    look-ahead.     Methodology    -----------     We use a circular buffer to store incoming tokens.     Some artifacts of the C++ language (such as the    expression/declaration ambiguity) require arbitrary look-ahead.    The strategy we adopt for dealing with these problems is to attempt    to parse one construct (e.g., the declaration) and fall back to the    other (e.g., the expression) if that attempt does not succeed.    Therefore, we must sometimes store an arbitrary number of tokens.     The parser routinely peeks at the next token, and then consumes it    later.  That also requires a buffer in which to store the tokens.          In order to easily permit adding tokens to the end of the buffer,    while removing them from the beginning of the buffer, we use a    circular buffer.  */
end_comment

begin_comment
comment|/* A C++ token.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cp_token
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The kind of token.  */
name|ENUM_BITFIELD
argument_list|(
argument|cpp_ttype
argument_list|)
name|type
label|:
literal|8
expr_stmt|;
comment|/* If this token is a keyword, this value indicates which keyword.      Otherwise, this value is RID_MAX.  */
name|ENUM_BITFIELD
argument_list|(
argument|rid
argument_list|)
name|keyword
label|:
literal|8
expr_stmt|;
comment|/* Token flags.  */
name|unsigned
name|char
name|flags
block|;
comment|/* The value associated with this token, if any.  */
name|tree
name|value
block|;
comment|/* The location at which this token was found.  */
name|location_t
name|location
block|; }
end_typedef

begin_expr_stmt
name|cp_token
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The number of tokens in a single token block.    Computed so that cp_token_block fits in a 512B allocation unit.  */
end_comment

begin_define
define|#
directive|define
name|CP_TOKEN_BLOCK_NUM_TOKENS
value|((512 - 3*sizeof (char*))/sizeof (cp_token))
end_define

begin_comment
comment|/* A group of tokens.  These groups are chained together to store    large numbers of tokens.  (For example, a token block is created    when the body of an inline member function is first encountered;    the tokens are processed later after the class definition is    complete.)       This somewhat ungainly data structure (as opposed to, say, a    variable-length array), is used due to constraints imposed by the    current garbage-collection methodology.  If it is made more    flexible, we could perhaps simplify the data structures involved.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cp_token_block
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The tokens.  */
name|cp_token
name|tokens
index|[
name|CP_TOKEN_BLOCK_NUM_TOKENS
index|]
block|;
comment|/* The number of tokens in this block.  */
name|size_t
name|num_tokens
block|;
comment|/* The next token block in the chain.  */
name|struct
name|cp_token_block
modifier|*
name|next
block|;
comment|/* The previous block in the chain.  */
name|struct
name|cp_token_block
modifier|*
name|prev
block|; }
end_typedef

begin_expr_stmt
name|cp_token_block
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|struct
name|cp_token_cache
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The first block in the cache.  NULL if there are no tokens in the      cache.  */
name|cp_token_block
modifier|*
name|first
block|;
comment|/* The last block in the cache.  NULL If there are no tokens in the      cache.  */
name|cp_token_block
modifier|*
name|last
block|; }
end_typedef

begin_expr_stmt
name|cp_token_cache
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Prototypes.  */
end_comment

begin_function_decl
specifier|static
name|cp_token_cache
modifier|*
name|cp_token_cache_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_token_cache_push_token
parameter_list|(
name|cp_token_cache
modifier|*
parameter_list|,
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Create a new cp_token_cache.  */
end_comment

begin_function
specifier|static
name|cp_token_cache
modifier|*
name|cp_token_cache_new
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
name|cp_token_cache
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add *TOKEN to *CACHE.  */
end_comment

begin_function
specifier|static
name|void
name|cp_token_cache_push_token
parameter_list|(
name|cp_token_cache
modifier|*
name|cache
parameter_list|,
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
name|cp_token_block
modifier|*
name|b
init|=
name|cache
operator|->
name|last
decl_stmt|;
comment|/* See if we need to allocate a new token block.  */
if|if
condition|(
operator|!
name|b
operator|||
name|b
operator|->
name|num_tokens
operator|==
name|CP_TOKEN_BLOCK_NUM_TOKENS
condition|)
block|{
name|b
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
name|cp_token_block
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|prev
operator|=
name|cache
operator|->
name|last
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|last
condition|)
block|{
name|cache
operator|->
name|last
operator|->
name|next
operator|=
name|b
expr_stmt|;
name|cache
operator|->
name|last
operator|=
name|b
expr_stmt|;
block|}
else|else
name|cache
operator|->
name|first
operator|=
name|cache
operator|->
name|last
operator|=
name|b
expr_stmt|;
block|}
comment|/* Add this token to the current token block.  */
name|b
operator|->
name|tokens
index|[
name|b
operator|->
name|num_tokens
operator|++
index|]
operator|=
operator|*
name|token
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The cp_lexer structure represents the C++ lexer.  It is responsible    for managing the token stream from the preprocessor and supplying    it to the parser.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cp_lexer
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The memory allocated for the buffer.  Never NULL.  */
name|cp_token
modifier|*
name|GTY
argument_list|(
operator|(
name|length
argument_list|(
literal|"(%h.buffer_end - %h.buffer)"
argument_list|)
operator|)
argument_list|)
name|buffer
block|;
comment|/* A pointer just past the end of the memory allocated for the buffer.  */
name|cp_token
modifier|*
name|GTY
argument_list|(
operator|(
name|skip
argument_list|(
literal|""
argument_list|)
operator|)
argument_list|)
name|buffer_end
block|;
comment|/* The first valid token in the buffer, or NULL if none.  */
name|cp_token
modifier|*
name|GTY
argument_list|(
operator|(
name|skip
argument_list|(
literal|""
argument_list|)
operator|)
argument_list|)
name|first_token
block|;
comment|/* The next available token.  If NEXT_TOKEN is NULL, then there are      no more available tokens.  */
name|cp_token
modifier|*
name|GTY
argument_list|(
operator|(
name|skip
argument_list|(
literal|""
argument_list|)
operator|)
argument_list|)
name|next_token
block|;
comment|/* A pointer just past the last available token.  If FIRST_TOKEN is      NULL, however, there are no available tokens, and then this      location is simply the place in which the next token read will be      placed.  If LAST_TOKEN == FIRST_TOKEN, then the buffer is full.      When the LAST_TOKEN == BUFFER, then the last token is at the      highest memory address in the BUFFER.  */
name|cp_token
modifier|*
name|GTY
argument_list|(
operator|(
name|skip
argument_list|(
literal|""
argument_list|)
operator|)
argument_list|)
name|last_token
block|;
comment|/* A stack indicating positions at which cp_lexer_save_tokens was      called.  The top entry is the most recent position at which we      began saving tokens.  The entries are differences in token      position between FIRST_TOKEN and the first saved token.       If the stack is non-empty, we are saving tokens.  When a token is      consumed, the NEXT_TOKEN pointer will move, but the FIRST_TOKEN      pointer will not.  The token stream will be preserved so that it      can be reexamined later.       If the stack is empty, then we are not saving tokens.  Whenever a      token is consumed, the FIRST_TOKEN pointer will be moved, and the      consumed token will be gone forever.  */
name|varray_type
name|saved_tokens
block|;
comment|/* The STRING_CST tokens encountered while processing the current      string literal.  */
name|varray_type
name|string_tokens
block|;
comment|/* True if we should obtain more tokens from the preprocessor; false      if we are processing a saved token cache.  */
name|bool
name|main_lexer_p
block|;
comment|/* True if we should output debugging information.  */
name|bool
name|debugging_p
block|;
comment|/* The next lexer in a linked list of lexers.  */
name|struct
name|cp_lexer
modifier|*
name|next
block|; }
end_typedef

begin_expr_stmt
name|cp_lexer
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Prototypes.  */
end_comment

begin_function_decl
specifier|static
name|cp_lexer
modifier|*
name|cp_lexer_new_main
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_lexer
modifier|*
name|cp_lexer_new_from_tokens
parameter_list|(
name|struct
name|cp_token_cache
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cp_lexer_saving_tokens
parameter_list|(
specifier|const
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_token
modifier|*
name|cp_lexer_next_token
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_token
modifier|*
name|cp_lexer_prev_token
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptrdiff_t
name|cp_lexer_token_difference
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|cp_token
modifier|*
parameter_list|,
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_token
modifier|*
name|cp_lexer_read_token
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_lexer_maybe_grow_buffer
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_lexer_get_preprocessor_token
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_token
modifier|*
name|cp_lexer_peek_token
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_token
modifier|*
name|cp_lexer_peek_nth_token
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|cp_lexer_next_token_is
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|enum
name|cpp_ttype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_lexer_next_token_is_not
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|enum
name|cpp_ttype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_lexer_next_token_is_keyword
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|enum
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_token
modifier|*
name|cp_lexer_consume_token
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_lexer_purge_token
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_lexer_purge_tokens_after
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_lexer_save_tokens
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_lexer_commit_tokens
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_lexer_rollback_tokens
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|cp_lexer_set_source_position_from_token
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
specifier|const
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_lexer_print_token
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|cp_lexer_debugging_p
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|cp_lexer_start_debugging
argument_list|(
name|cp_lexer
operator|*
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cp_lexer_stop_debugging
argument_list|(
name|cp_lexer
operator|*
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Manifest constants.  */
end_comment

begin_define
define|#
directive|define
name|CP_TOKEN_BUFFER_SIZE
value|5
end_define

begin_define
define|#
directive|define
name|CP_SAVED_TOKENS_SIZE
value|5
end_define

begin_comment
comment|/* A token type for keywords, as opposed to ordinary identifiers.  */
end_comment

begin_define
define|#
directive|define
name|CPP_KEYWORD
value|((enum cpp_ttype) (N_TTYPES + 1))
end_define

begin_comment
comment|/* A token type for template-ids.  If a template-id is processed while    parsing tentatively, it is replaced with a CPP_TEMPLATE_ID token;    the value of the CPP_TEMPLATE_ID is whatever was returned by    cp_parser_template_id.  */
end_comment

begin_define
define|#
directive|define
name|CPP_TEMPLATE_ID
value|((enum cpp_ttype) (CPP_KEYWORD + 1))
end_define

begin_comment
comment|/* A token type for nested-name-specifiers.  If a    nested-name-specifier is processed while parsing tentatively, it is    replaced with a CPP_NESTED_NAME_SPECIFIER token; the value of the    CPP_NESTED_NAME_SPECIFIER is whatever was returned by    cp_parser_nested_name_specifier_opt.  */
end_comment

begin_define
define|#
directive|define
name|CPP_NESTED_NAME_SPECIFIER
value|((enum cpp_ttype) (CPP_TEMPLATE_ID + 1))
end_define

begin_comment
comment|/* A token type for tokens that are not tokens at all; these are used    to mark the end of a token block.  */
end_comment

begin_define
define|#
directive|define
name|CPP_NONE
value|(CPP_NESTED_NAME_SPECIFIER + 1)
end_define

begin_comment
comment|/* Variables.  */
end_comment

begin_comment
comment|/* The stream to which debugging output should be written.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|cp_lexer_debug_stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new main C++ lexer, the lexer that gets tokens from the    preprocessor.  */
end_comment

begin_function
specifier|static
name|cp_lexer
modifier|*
name|cp_lexer_new_main
parameter_list|(
name|void
parameter_list|)
block|{
name|cp_lexer
modifier|*
name|lexer
decl_stmt|;
name|cp_token
name|first_token
decl_stmt|;
comment|/* It's possible that lexing the first token will load a PCH file,      which is a GC collection point.  So we have to grab the first      token before allocating any memory.  */
name|cp_lexer_get_preprocessor_token
argument_list|(
name|NULL
argument_list|,
operator|&
name|first_token
argument_list|)
expr_stmt|;
name|c_common_no_more_pch
argument_list|()
expr_stmt|;
comment|/* Allocate the memory.  */
name|lexer
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
name|cp_lexer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the circular buffer.  */
name|lexer
operator|->
name|buffer
operator|=
name|ggc_calloc
argument_list|(
name|CP_TOKEN_BUFFER_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|cp_token
argument_list|)
argument_list|)
expr_stmt|;
name|lexer
operator|->
name|buffer_end
operator|=
name|lexer
operator|->
name|buffer
operator|+
name|CP_TOKEN_BUFFER_SIZE
expr_stmt|;
comment|/* There is one token in the buffer.  */
name|lexer
operator|->
name|last_token
operator|=
name|lexer
operator|->
name|buffer
operator|+
literal|1
expr_stmt|;
name|lexer
operator|->
name|first_token
operator|=
name|lexer
operator|->
name|buffer
expr_stmt|;
name|lexer
operator|->
name|next_token
operator|=
name|lexer
operator|->
name|buffer
expr_stmt|;
name|memcpy
argument_list|(
name|lexer
operator|->
name|buffer
argument_list|,
operator|&
name|first_token
argument_list|,
sizeof|sizeof
argument_list|(
name|cp_token
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This lexer obtains more tokens by calling c_lex.  */
name|lexer
operator|->
name|main_lexer_p
operator|=
name|true
expr_stmt|;
comment|/* Create the SAVED_TOKENS stack.  */
name|VARRAY_INT_INIT
argument_list|(
name|lexer
operator|->
name|saved_tokens
argument_list|,
name|CP_SAVED_TOKENS_SIZE
argument_list|,
literal|"saved_tokens"
argument_list|)
expr_stmt|;
comment|/* Create the STRINGS array.  */
name|VARRAY_TREE_INIT
argument_list|(
name|lexer
operator|->
name|string_tokens
argument_list|,
literal|32
argument_list|,
literal|"strings"
argument_list|)
expr_stmt|;
comment|/* Assume we are not debugging.  */
name|lexer
operator|->
name|debugging_p
operator|=
name|false
expr_stmt|;
return|return
name|lexer
return|;
block|}
end_function

begin_comment
comment|/* Create a new lexer whose token stream is primed with the TOKENS.    When these tokens are exhausted, no new tokens will be read.  */
end_comment

begin_function
specifier|static
name|cp_lexer
modifier|*
name|cp_lexer_new_from_tokens
parameter_list|(
name|cp_token_cache
modifier|*
name|tokens
parameter_list|)
block|{
name|cp_lexer
modifier|*
name|lexer
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|cp_token_block
modifier|*
name|block
decl_stmt|;
name|ptrdiff_t
name|num_tokens
decl_stmt|;
comment|/* Allocate the memory.  */
name|lexer
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
name|cp_lexer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a new buffer, appropriately sized.  */
name|num_tokens
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|block
operator|=
name|tokens
operator|->
name|first
init|;
name|block
operator|!=
name|NULL
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
name|num_tokens
operator|+=
name|block
operator|->
name|num_tokens
expr_stmt|;
name|lexer
operator|->
name|buffer
operator|=
name|ggc_alloc
argument_list|(
name|num_tokens
operator|*
sizeof|sizeof
argument_list|(
name|cp_token
argument_list|)
argument_list|)
expr_stmt|;
name|lexer
operator|->
name|buffer_end
operator|=
name|lexer
operator|->
name|buffer
operator|+
name|num_tokens
expr_stmt|;
comment|/* Install the tokens.  */
name|token
operator|=
name|lexer
operator|->
name|buffer
expr_stmt|;
for|for
control|(
name|block
operator|=
name|tokens
operator|->
name|first
init|;
name|block
operator|!=
name|NULL
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
block|{
name|memcpy
argument_list|(
name|token
argument_list|,
name|block
operator|->
name|tokens
argument_list|,
name|block
operator|->
name|num_tokens
operator|*
sizeof|sizeof
argument_list|(
name|cp_token
argument_list|)
argument_list|)
expr_stmt|;
name|token
operator|+=
name|block
operator|->
name|num_tokens
expr_stmt|;
block|}
comment|/* The FIRST_TOKEN is the beginning of the buffer.  */
name|lexer
operator|->
name|first_token
operator|=
name|lexer
operator|->
name|buffer
expr_stmt|;
comment|/* The next available token is also at the beginning of the buffer.  */
name|lexer
operator|->
name|next_token
operator|=
name|lexer
operator|->
name|buffer
expr_stmt|;
comment|/* The buffer is full.  */
name|lexer
operator|->
name|last_token
operator|=
name|lexer
operator|->
name|first_token
expr_stmt|;
comment|/* This lexer doesn't obtain more tokens.  */
name|lexer
operator|->
name|main_lexer_p
operator|=
name|false
expr_stmt|;
comment|/* Create the SAVED_TOKENS stack.  */
name|VARRAY_INT_INIT
argument_list|(
name|lexer
operator|->
name|saved_tokens
argument_list|,
name|CP_SAVED_TOKENS_SIZE
argument_list|,
literal|"saved_tokens"
argument_list|)
expr_stmt|;
comment|/* Create the STRINGS array.  */
name|VARRAY_TREE_INIT
argument_list|(
name|lexer
operator|->
name|string_tokens
argument_list|,
literal|32
argument_list|,
literal|"strings"
argument_list|)
expr_stmt|;
comment|/* Assume we are not debugging.  */
name|lexer
operator|->
name|debugging_p
operator|=
name|false
expr_stmt|;
return|return
name|lexer
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if debugging information should be output.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|cp_lexer_debugging_p
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
return|return
name|lexer
operator|->
name|debugging_p
return|;
block|}
end_function

begin_comment
comment|/* Set the current source position from the information stored in    TOKEN.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|cp_lexer_set_source_position_from_token
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
comment|/* Ideally, the source position information would not be a global      variable, but it is.  */
comment|/* Update the line number.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
name|input_location
operator|=
name|token
operator|->
name|location
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TOKEN points into the circular token buffer.  Return a pointer to    the next token in the buffer.  */
end_comment

begin_function
specifier|static
specifier|inline
name|cp_token
modifier|*
name|cp_lexer_next_token
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|,
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
name|token
operator|++
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|lexer
operator|->
name|buffer_end
condition|)
name|token
operator|=
name|lexer
operator|->
name|buffer
expr_stmt|;
return|return
name|token
return|;
block|}
end_function

begin_comment
comment|/* TOKEN points into the circular token buffer.  Return a pointer to    the previous token in the buffer.  */
end_comment

begin_function
specifier|static
specifier|inline
name|cp_token
modifier|*
name|cp_lexer_prev_token
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|,
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
if|if
condition|(
name|token
operator|==
name|lexer
operator|->
name|buffer
condition|)
name|token
operator|=
name|lexer
operator|->
name|buffer_end
expr_stmt|;
return|return
name|token
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* nonzero if we are presently saving tokens.  */
end_comment

begin_function
specifier|static
name|int
name|cp_lexer_saving_tokens
parameter_list|(
specifier|const
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
return|return
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|lexer
operator|->
name|saved_tokens
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the token that is N tokens beyond TOKEN in the    buffer.  */
end_comment

begin_function
specifier|static
name|cp_token
modifier|*
name|cp_lexer_advance_token
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|,
name|cp_token
modifier|*
name|token
parameter_list|,
name|ptrdiff_t
name|n
parameter_list|)
block|{
name|token
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|token
operator|>=
name|lexer
operator|->
name|buffer_end
condition|)
name|token
operator|=
name|lexer
operator|->
name|buffer
operator|+
operator|(
name|token
operator|-
name|lexer
operator|->
name|buffer_end
operator|)
expr_stmt|;
return|return
name|token
return|;
block|}
end_function

begin_comment
comment|/* Returns the number of times that START would have to be incremented    to reach FINISH.  If START and FINISH are the same, returns zero.  */
end_comment

begin_function
specifier|static
name|ptrdiff_t
name|cp_lexer_token_difference
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|,
name|cp_token
modifier|*
name|start
parameter_list|,
name|cp_token
modifier|*
name|finish
parameter_list|)
block|{
if|if
condition|(
name|finish
operator|>=
name|start
condition|)
return|return
name|finish
operator|-
name|start
return|;
else|else
return|return
operator|(
operator|(
name|lexer
operator|->
name|buffer_end
operator|-
name|lexer
operator|->
name|buffer
operator|)
operator|-
operator|(
name|start
operator|-
name|finish
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Obtain another token from the C preprocessor and add it to the    token buffer.  Returns the newly read token.  */
end_comment

begin_function
specifier|static
name|cp_token
modifier|*
name|cp_lexer_read_token
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Make sure there is room in the buffer.  */
name|cp_lexer_maybe_grow_buffer
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
comment|/* If there weren't any tokens, then this one will be the first.  */
if|if
condition|(
operator|!
name|lexer
operator|->
name|first_token
condition|)
name|lexer
operator|->
name|first_token
operator|=
name|lexer
operator|->
name|last_token
expr_stmt|;
comment|/* Similarly, if there were no available tokens, there is one now.  */
if|if
condition|(
operator|!
name|lexer
operator|->
name|next_token
condition|)
name|lexer
operator|->
name|next_token
operator|=
name|lexer
operator|->
name|last_token
expr_stmt|;
comment|/* Figure out where we're going to store the new token.  */
name|token
operator|=
name|lexer
operator|->
name|last_token
expr_stmt|;
comment|/* Get a new token from the preprocessor.  */
name|cp_lexer_get_preprocessor_token
argument_list|(
name|lexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* Increment LAST_TOKEN.  */
name|lexer
operator|->
name|last_token
operator|=
name|cp_lexer_next_token
argument_list|(
name|lexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* Strings should have type `const char []'.  Right now, we will      have an ARRAY_TYPE that is constant rather than an array of      constant elements.      FIXME: Make fix_string_type get this right in the first place.  */
if|if
condition|(
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_STRING
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_WSTRING
operator|)
operator|&&
name|flag_const_strings
condition|)
block|{
name|tree
name|type
decl_stmt|;
comment|/* Get the current type.  It will be an ARRAY_TYPE.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|token
operator|->
name|value
argument_list|)
expr_stmt|;
comment|/* Use build_cplus_array_type to rebuild the array, thereby 	 getting the right type.  */
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reset the type of the token.  */
name|TREE_TYPE
argument_list|(
name|token
operator|->
name|value
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
end_function

begin_comment
comment|/* If the circular buffer is full, make it bigger.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_maybe_grow_buffer
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
comment|/* If the buffer is full, enlarge it.  */
if|if
condition|(
name|lexer
operator|->
name|last_token
operator|==
name|lexer
operator|->
name|first_token
condition|)
block|{
name|cp_token
modifier|*
name|new_buffer
decl_stmt|;
name|cp_token
modifier|*
name|old_buffer
decl_stmt|;
name|cp_token
modifier|*
name|new_first_token
decl_stmt|;
name|ptrdiff_t
name|buffer_length
decl_stmt|;
name|size_t
name|num_tokens_to_copy
decl_stmt|;
comment|/* Remember the current buffer pointer.  It will become invalid, 	 but we will need to do pointer arithmetic involving this 	 value.  */
name|old_buffer
operator|=
name|lexer
operator|->
name|buffer
expr_stmt|;
comment|/* Compute the current buffer size.  */
name|buffer_length
operator|=
name|lexer
operator|->
name|buffer_end
operator|-
name|lexer
operator|->
name|buffer
expr_stmt|;
comment|/* Allocate a buffer twice as big.  */
name|new_buffer
operator|=
name|ggc_realloc
argument_list|(
name|lexer
operator|->
name|buffer
argument_list|,
literal|2
operator|*
name|buffer_length
operator|*
sizeof|sizeof
argument_list|(
name|cp_token
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Because the buffer is circular, logically consecutive tokens 	 are not necessarily placed consecutively in memory. 	 Therefore, we must keep move the tokens that were before 	 FIRST_TOKEN to the second half of the newly allocated 	 buffer.  */
name|num_tokens_to_copy
operator|=
operator|(
name|lexer
operator|->
name|first_token
operator|-
name|old_buffer
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_buffer
operator|+
name|buffer_length
argument_list|,
name|new_buffer
argument_list|,
name|num_tokens_to_copy
operator|*
sizeof|sizeof
argument_list|(
name|cp_token
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear the rest of the buffer.  We never look at this storage, 	 but the garbage collector may.  */
name|memset
argument_list|(
name|new_buffer
operator|+
name|buffer_length
operator|+
name|num_tokens_to_copy
argument_list|,
literal|0
argument_list|,
operator|(
name|buffer_length
operator|-
name|num_tokens_to_copy
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|cp_token
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now recompute all of the buffer pointers.  */
name|new_first_token
operator|=
name|new_buffer
operator|+
operator|(
name|lexer
operator|->
name|first_token
operator|-
name|old_buffer
operator|)
expr_stmt|;
if|if
condition|(
name|lexer
operator|->
name|next_token
operator|!=
name|NULL
condition|)
block|{
name|ptrdiff_t
name|next_token_delta
decl_stmt|;
if|if
condition|(
name|lexer
operator|->
name|next_token
operator|>
name|lexer
operator|->
name|first_token
condition|)
name|next_token_delta
operator|=
name|lexer
operator|->
name|next_token
operator|-
name|lexer
operator|->
name|first_token
expr_stmt|;
else|else
name|next_token_delta
operator|=
name|buffer_length
operator|-
operator|(
name|lexer
operator|->
name|first_token
operator|-
name|lexer
operator|->
name|next_token
operator|)
expr_stmt|;
name|lexer
operator|->
name|next_token
operator|=
name|new_first_token
operator|+
name|next_token_delta
expr_stmt|;
block|}
name|lexer
operator|->
name|last_token
operator|=
name|new_first_token
operator|+
name|buffer_length
expr_stmt|;
name|lexer
operator|->
name|buffer
operator|=
name|new_buffer
expr_stmt|;
name|lexer
operator|->
name|buffer_end
operator|=
name|new_buffer
operator|+
name|buffer_length
operator|*
literal|2
expr_stmt|;
name|lexer
operator|->
name|first_token
operator|=
name|new_first_token
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store the next token from the preprocessor in *TOKEN.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_get_preprocessor_token
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
name|ATTRIBUTE_UNUSED
parameter_list|,
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
name|bool
name|done
decl_stmt|;
comment|/* If this not the main lexer, return a terminating CPP_EOF token.  */
if|if
condition|(
name|lexer
operator|!=
name|NULL
operator|&&
operator|!
name|lexer
operator|->
name|main_lexer_p
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|CPP_EOF
expr_stmt|;
name|token
operator|->
name|location
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|token
operator|->
name|location
operator|.
name|file
operator|=
name|NULL
expr_stmt|;
name|token
operator|->
name|value
operator|=
name|NULL_TREE
expr_stmt|;
name|token
operator|->
name|keyword
operator|=
name|RID_MAX
expr_stmt|;
return|return;
block|}
name|done
operator|=
name|false
expr_stmt|;
comment|/* Keep going until we get a token we like.  */
while|while
condition|(
operator|!
name|done
condition|)
block|{
comment|/* Get a new token from the preprocessor.  */
name|token
operator|->
name|type
operator|=
name|c_lex_with_flags
argument_list|(
operator|&
name|token
operator|->
name|value
argument_list|,
operator|&
name|token
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* Issue messages about tokens we cannot process.  */
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_ATSIGN
case|:
case|case
name|CPP_HASH
case|:
case|case
name|CPP_PASTE
case|:
name|error
argument_list|(
literal|"invalid token"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This is a good token, so we exit the loop.  */
name|done
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now we've got our token.  */
name|token
operator|->
name|location
operator|=
name|input_location
expr_stmt|;
comment|/* Check to see if this token is a keyword.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
operator|&&
name|C_IS_RESERVED_WORD
argument_list|(
name|token
operator|->
name|value
argument_list|)
condition|)
block|{
comment|/* Mark this token as a keyword.  */
name|token
operator|->
name|type
operator|=
name|CPP_KEYWORD
expr_stmt|;
comment|/* Record which keyword.  */
name|token
operator|->
name|keyword
operator|=
name|C_RID_CODE
argument_list|(
name|token
operator|->
name|value
argument_list|)
expr_stmt|;
comment|/* Update the value.  Some keywords are mapped to particular 	 entities, rather than simply having the value of the 	 corresponding IDENTIFIER_NODE.  For example, `__const' is 	 mapped to `const'.  */
name|token
operator|->
name|value
operator|=
name|ridpointers
index|[
name|token
operator|->
name|keyword
index|]
expr_stmt|;
block|}
else|else
name|token
operator|->
name|keyword
operator|=
name|RID_MAX
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the next token in the token stream, but do not    consume it.  */
end_comment

begin_function
specifier|static
name|cp_token
modifier|*
name|cp_lexer_peek_token
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* If there are no tokens, read one now.  */
if|if
condition|(
operator|!
name|lexer
operator|->
name|next_token
condition|)
name|cp_lexer_read_token
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
comment|/* Provide debugging output.  */
if|if
condition|(
name|cp_lexer_debugging_p
argument_list|(
name|lexer
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
literal|"cp_lexer: peeking at token: "
argument_list|)
expr_stmt|;
name|cp_lexer_print_token
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
name|lexer
operator|->
name|next_token
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|lexer
operator|->
name|next_token
expr_stmt|;
name|cp_lexer_set_source_position_from_token
argument_list|(
name|lexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
end_function

begin_comment
comment|/* Return true if the next token has the indicated TYPE.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_lexer_next_token_is
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|,
name|enum
name|cpp_ttype
name|type
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
comment|/* Check to see if it has the indicated TYPE.  */
return|return
name|token
operator|->
name|type
operator|==
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return true if the next token does not have the indicated TYPE.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_lexer_next_token_is_not
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|,
name|enum
name|cpp_ttype
name|type
parameter_list|)
block|{
return|return
operator|!
name|cp_lexer_next_token_is
argument_list|(
name|lexer
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the next token is the indicated KEYWORD.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_lexer_next_token_is_keyword
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|,
name|enum
name|rid
name|keyword
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
comment|/* Check to see if it is the indicated keyword.  */
return|return
name|token
operator|->
name|keyword
operator|==
name|keyword
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the Nth token in the token stream.  If N is 1,    then this is precisely equivalent to cp_lexer_peek_token.  */
end_comment

begin_function
specifier|static
name|cp_token
modifier|*
name|cp_lexer_peek_nth_token
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* N is 1-based, not zero-based.  */
name|my_friendly_assert
argument_list|(
name|n
operator|>
literal|0
argument_list|,
literal|20000224
argument_list|)
expr_stmt|;
comment|/* Skip ahead from NEXT_TOKEN, reading more tokens as necessary.  */
name|token
operator|=
name|lexer
operator|->
name|next_token
expr_stmt|;
comment|/* If there are no tokens in the buffer, get one now.  */
if|if
condition|(
operator|!
name|token
condition|)
block|{
name|cp_lexer_read_token
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
name|token
operator|=
name|lexer
operator|->
name|next_token
expr_stmt|;
block|}
comment|/* Now, read tokens until we have enough.  */
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
comment|/* Advance to the next token.  */
name|token
operator|=
name|cp_lexer_next_token
argument_list|(
name|lexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* If that's all the tokens we have, read a new one.  */
if|if
condition|(
name|token
operator|==
name|lexer
operator|->
name|last_token
condition|)
name|token
operator|=
name|cp_lexer_read_token
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
end_function

begin_comment
comment|/* Consume the next token.  The pointer returned is valid only until    another token is read.  Callers should preserve copy the token    explicitly if they will need its value for a longer period of    time.  */
end_comment

begin_function
specifier|static
name|cp_token
modifier|*
name|cp_lexer_consume_token
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* If there are no tokens, read one now.  */
if|if
condition|(
operator|!
name|lexer
operator|->
name|next_token
condition|)
name|cp_lexer_read_token
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
comment|/* Remember the token we'll be returning.  */
name|token
operator|=
name|lexer
operator|->
name|next_token
expr_stmt|;
comment|/* Increment NEXT_TOKEN.  */
name|lexer
operator|->
name|next_token
operator|=
name|cp_lexer_next_token
argument_list|(
name|lexer
argument_list|,
name|lexer
operator|->
name|next_token
argument_list|)
expr_stmt|;
comment|/* Check to see if we're all out of tokens.  */
if|if
condition|(
name|lexer
operator|->
name|next_token
operator|==
name|lexer
operator|->
name|last_token
condition|)
name|lexer
operator|->
name|next_token
operator|=
name|NULL
expr_stmt|;
comment|/* If we're not saving tokens, then move FIRST_TOKEN too.  */
if|if
condition|(
operator|!
name|cp_lexer_saving_tokens
argument_list|(
name|lexer
argument_list|)
condition|)
block|{
comment|/* If there are no tokens available, set FIRST_TOKEN to NULL.  */
if|if
condition|(
operator|!
name|lexer
operator|->
name|next_token
condition|)
name|lexer
operator|->
name|first_token
operator|=
name|NULL
expr_stmt|;
else|else
name|lexer
operator|->
name|first_token
operator|=
name|lexer
operator|->
name|next_token
expr_stmt|;
block|}
comment|/* Provide debugging output.  */
if|if
condition|(
name|cp_lexer_debugging_p
argument_list|(
name|lexer
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
literal|"cp_lexer: consuming token: "
argument_list|)
expr_stmt|;
name|cp_lexer_print_token
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
end_function

begin_comment
comment|/* Permanently remove the next token from the token stream.  There    must be a valid next token already; this token never reads    additional tokens from the preprocessor.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_purge_token
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|cp_token
modifier|*
name|next_token
decl_stmt|;
name|token
operator|=
name|lexer
operator|->
name|next_token
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|next_token
operator|=
name|cp_lexer_next_token
argument_list|(
name|lexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_token
operator|==
name|lexer
operator|->
name|last_token
condition|)
break|break;
operator|*
name|token
operator|=
operator|*
name|next_token
expr_stmt|;
name|token
operator|=
name|next_token
expr_stmt|;
block|}
name|lexer
operator|->
name|last_token
operator|=
name|token
expr_stmt|;
comment|/* The token purged may have been the only token remaining; if so,      clear NEXT_TOKEN.  */
if|if
condition|(
name|lexer
operator|->
name|next_token
operator|==
name|token
condition|)
name|lexer
operator|->
name|next_token
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Permanently remove all tokens after TOKEN, up to, but not    including, the token that will be returned next by    cp_lexer_peek_token.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_purge_tokens_after
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|,
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
name|cp_token
modifier|*
name|peek
decl_stmt|;
name|cp_token
modifier|*
name|t1
decl_stmt|;
name|cp_token
modifier|*
name|t2
decl_stmt|;
if|if
condition|(
name|lexer
operator|->
name|next_token
condition|)
block|{
comment|/* Copy the tokens that have not yet been read to the location 	 immediately following TOKEN.  */
name|t1
operator|=
name|cp_lexer_next_token
argument_list|(
name|lexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|t2
operator|=
name|peek
operator|=
name|cp_lexer_peek_token
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
comment|/* Move tokens into the vacant area between TOKEN and PEEK.  */
while|while
condition|(
name|t2
operator|!=
name|lexer
operator|->
name|last_token
condition|)
block|{
operator|*
name|t1
operator|=
operator|*
name|t2
expr_stmt|;
name|t1
operator|=
name|cp_lexer_next_token
argument_list|(
name|lexer
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|cp_lexer_next_token
argument_list|(
name|lexer
argument_list|,
name|t2
argument_list|)
expr_stmt|;
block|}
comment|/* Now, the next available token is right after TOKEN.  */
name|lexer
operator|->
name|next_token
operator|=
name|cp_lexer_next_token
argument_list|(
name|lexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* And the last token is wherever we ended up.  */
name|lexer
operator|->
name|last_token
operator|=
name|t1
expr_stmt|;
block|}
else|else
block|{
comment|/* There are no tokens in the buffer, so there is nothing to 	 copy.  The last token in the buffer is TOKEN itself.  */
name|lexer
operator|->
name|last_token
operator|=
name|cp_lexer_next_token
argument_list|(
name|lexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Begin saving tokens.  All tokens consumed after this point will be    preserved.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_save_tokens
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
comment|/* Provide debugging output.  */
if|if
condition|(
name|cp_lexer_debugging_p
argument_list|(
name|lexer
argument_list|)
condition|)
name|fprintf
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
literal|"cp_lexer: saving tokens\n"
argument_list|)
expr_stmt|;
comment|/* Make sure that LEXER->NEXT_TOKEN is non-NULL so that we can      restore the tokens if required.  */
if|if
condition|(
operator|!
name|lexer
operator|->
name|next_token
condition|)
name|cp_lexer_read_token
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
name|VARRAY_PUSH_INT
argument_list|(
name|lexer
operator|->
name|saved_tokens
argument_list|,
name|cp_lexer_token_difference
argument_list|(
name|lexer
argument_list|,
name|lexer
operator|->
name|first_token
argument_list|,
name|lexer
operator|->
name|next_token
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Commit to the portion of the token stream most recently saved.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_commit_tokens
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
comment|/* Provide debugging output.  */
if|if
condition|(
name|cp_lexer_debugging_p
argument_list|(
name|lexer
argument_list|)
condition|)
name|fprintf
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
literal|"cp_lexer: committing tokens\n"
argument_list|)
expr_stmt|;
name|VARRAY_POP
argument_list|(
name|lexer
operator|->
name|saved_tokens
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return all tokens saved since the last call to cp_lexer_save_tokens    to the token stream.  Stop saving tokens.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_rollback_tokens
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
name|size_t
name|delta
decl_stmt|;
comment|/* Provide debugging output.  */
if|if
condition|(
name|cp_lexer_debugging_p
argument_list|(
name|lexer
argument_list|)
condition|)
name|fprintf
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
literal|"cp_lexer: restoring tokens\n"
argument_list|)
expr_stmt|;
comment|/* Find the token that was the NEXT_TOKEN when we started saving      tokens.  */
name|delta
operator|=
name|VARRAY_TOP_INT
argument_list|(
name|lexer
operator|->
name|saved_tokens
argument_list|)
expr_stmt|;
comment|/* Make it the next token again now.  */
name|lexer
operator|->
name|next_token
operator|=
name|cp_lexer_advance_token
argument_list|(
name|lexer
argument_list|,
name|lexer
operator|->
name|first_token
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* It might be the case that there were no tokens when we started      saving tokens, but that there are some tokens now.  */
if|if
condition|(
operator|!
name|lexer
operator|->
name|next_token
operator|&&
name|lexer
operator|->
name|first_token
condition|)
name|lexer
operator|->
name|next_token
operator|=
name|lexer
operator|->
name|first_token
expr_stmt|;
comment|/* Stop saving tokens.  */
name|VARRAY_POP
argument_list|(
name|lexer
operator|->
name|saved_tokens
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a representation of the TOKEN on the STREAM.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_print_token
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|token_type
init|=
name|NULL
decl_stmt|;
comment|/* Figure out what kind of token this is.  */
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_EQ
case|:
name|token_type
operator|=
literal|"EQ"
expr_stmt|;
break|break;
case|case
name|CPP_COMMA
case|:
name|token_type
operator|=
literal|"COMMA"
expr_stmt|;
break|break;
case|case
name|CPP_OPEN_PAREN
case|:
name|token_type
operator|=
literal|"OPEN_PAREN"
expr_stmt|;
break|break;
case|case
name|CPP_CLOSE_PAREN
case|:
name|token_type
operator|=
literal|"CLOSE_PAREN"
expr_stmt|;
break|break;
case|case
name|CPP_OPEN_BRACE
case|:
name|token_type
operator|=
literal|"OPEN_BRACE"
expr_stmt|;
break|break;
case|case
name|CPP_CLOSE_BRACE
case|:
name|token_type
operator|=
literal|"CLOSE_BRACE"
expr_stmt|;
break|break;
case|case
name|CPP_SEMICOLON
case|:
name|token_type
operator|=
literal|"SEMICOLON"
expr_stmt|;
break|break;
case|case
name|CPP_NAME
case|:
name|token_type
operator|=
literal|"NAME"
expr_stmt|;
break|break;
case|case
name|CPP_EOF
case|:
name|token_type
operator|=
literal|"EOF"
expr_stmt|;
break|break;
case|case
name|CPP_KEYWORD
case|:
name|token_type
operator|=
literal|"keyword"
expr_stmt|;
break|break;
comment|/* This is not a token that we know how to handle yet.  */
default|default:
break|break;
block|}
comment|/* If we have a name for the token, print it out.  Otherwise, we      simply give the numeric code.  */
if|if
condition|(
name|token_type
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|token_type
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|token
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* And, for an identifier, print the identifier name.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
comment|/* Some keywords have a value that is not an IDENTIFIER_NODE. 	 For example, `struct' is mapped to an INTEGER_CST.  */
operator|||
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_KEYWORD
operator|&&
name|TREE_CODE
argument_list|(
name|token
operator|->
name|value
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" %s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|token
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start emitting debugging information.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_start_debugging
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
operator|++
name|lexer
operator|->
name|debugging_p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop emitting debugging information.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_stop_debugging
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
operator|--
name|lexer
operator|->
name|debugging_p
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The parser.  */
end_comment

begin_comment
comment|/* Overview    --------     A cp_parser parses the token stream as specified by the C++    grammar.  Its job is purely parsing, not semantic analysis.  For    example, the parser breaks the token stream into declarators,    expressions, statements, and other similar syntactic constructs.    It does not check that the types of the expressions on either side    of an assignment-statement are compatible, or that a function is    not declared with a parameter of type `void'.     The parser invokes routines elsewhere in the compiler to perform    semantic analysis and to build up the abstract syntax tree for the    code processed.       The parser (and the template instantiation code, which is, in a    way, a close relative of parsing) are the only parts of the    compiler that should be calling push_scope and pop_scope, or    related functions.  The parser (and template instantiation code)    keeps track of what scope is presently active; everything else    should simply honor that.  (The code that generates static    initializers may also need to set the scope, in order to check    access control correctly when emitting the initializers.)     Methodology    -----------        The parser is of the standard recursive-descent variety.  Upcoming    tokens in the token stream are examined in order to determine which    production to use when parsing a non-terminal.  Some C++ constructs    require arbitrary look ahead to disambiguate.  For example, it is    impossible, in the general case, to tell whether a statement is an    expression or declaration without scanning the entire statement.    Therefore, the parser is capable of "parsing tentatively."  When the    parser is not sure what construct comes next, it enters this mode.    Then, while we attempt to parse the construct, the parser queues up    error messages, rather than issuing them immediately, and saves the    tokens it consumes.  If the construct is parsed successfully, the    parser "commits", i.e., it issues any queued error messages and    the tokens that were being preserved are permanently discarded.    If, however, the construct is not parsed successfully, the parser    rolls back its state completely so that it can resume parsing using    a different alternative.     Future Improvements    -------------------        The performance of the parser could probably be improved    substantially.  Some possible improvements include:       - The expression parser recurses through the various levels of        precedence as specified in the grammar, rather than using an        operator-precedence technique.  Therefore, parsing a simple        identifier requires multiple recursive calls.       - We could often eliminate the need to parse tentatively by        looking ahead a little bit.  In some places, this approach        might not entirely eliminate the need to parse tentatively, but        it might still speed up the average case.  */
end_comment

begin_comment
comment|/* Flags that are passed to some parsing functions.  These values can    be bitwise-ored together.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|cp_parser_flags
block|{
comment|/* No flags.  */
name|CP_PARSER_FLAGS_NONE
init|=
literal|0x0
block|,
comment|/* The construct is optional.  If it is not present, then no error      should be issued.  */
name|CP_PARSER_FLAGS_OPTIONAL
init|=
literal|0x1
block|,
comment|/* When parsing a type-specifier, do not allow user-defined types.  */
name|CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES
init|=
literal|0x2
block|}
name|cp_parser_flags
typedef|;
end_typedef

begin_comment
comment|/* The different kinds of declarators we want to parse.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|cp_parser_declarator_kind
block|{
comment|/* We want an abstract declartor.  */
name|CP_PARSER_DECLARATOR_ABSTRACT
block|,
comment|/* We want a named declarator.  */
name|CP_PARSER_DECLARATOR_NAMED
block|,
comment|/* We don't mind, but the name must be an unqualified-id.  */
name|CP_PARSER_DECLARATOR_EITHER
block|}
name|cp_parser_declarator_kind
typedef|;
end_typedef

begin_comment
comment|/* A mapping from a token type to a corresponding tree node type.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cp_parser_token_tree_map_node
block|{
comment|/* The token type.  */
name|ENUM_BITFIELD
argument_list|(
argument|cpp_ttype
argument_list|)
name|token_type
label|:
literal|8
expr_stmt|;
comment|/* The corresponding tree code.  */
name|ENUM_BITFIELD
argument_list|(
argument|tree_code
argument_list|)
name|tree_type
label|:
literal|8
expr_stmt|;
block|}
name|cp_parser_token_tree_map_node
typedef|;
end_typedef

begin_comment
comment|/* A complete map consists of several ordinary entries, followed by a    terminator.  The terminating entry has a token_type of CPP_EOF.  */
end_comment

begin_typedef
typedef|typedef
name|cp_parser_token_tree_map_node
name|cp_parser_token_tree_map
index|[]
typedef|;
end_typedef

begin_comment
comment|/* The status of a tentative parse.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|cp_parser_status_kind
block|{
comment|/* No errors have occurred.  */
name|CP_PARSER_STATUS_KIND_NO_ERROR
block|,
comment|/* An error has occurred.  */
name|CP_PARSER_STATUS_KIND_ERROR
block|,
comment|/* We are committed to this tentative parse, whether or not an error      has occurred.  */
name|CP_PARSER_STATUS_KIND_COMMITTED
block|}
name|cp_parser_status_kind
typedef|;
end_typedef

begin_comment
comment|/* Context that is saved and restored when parsing tentatively.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cp_parser_context
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* If this is a tentative parsing context, the status of the      tentative parse.  */
name|enum
name|cp_parser_status_kind
name|status
block|;
comment|/* If non-NULL, we have just seen a `x->' or `x.' expression.  Names      that are looked up in this context must be looked up both in the      scope given by OBJECT_TYPE (the type of `x' or `*x') and also in      the context of the containing expression.  */
name|tree
name|object_type
block|;
comment|/* The next parsing context in the stack.  */
name|struct
name|cp_parser_context
modifier|*
name|next
block|; }
end_typedef

begin_expr_stmt
name|cp_parser_context
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Prototypes.  */
end_comment

begin_comment
comment|/* Constructors and destructors.  */
end_comment

begin_function_decl
specifier|static
name|cp_parser_context
modifier|*
name|cp_parser_context_new
parameter_list|(
name|cp_parser_context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Class variables.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable (
literal|""
argument|))
argument_list|)
name|cp_parser_context
operator|*
name|cp_parser_context_free_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Constructors and destructors.  */
end_comment

begin_comment
comment|/* Construct a new context.  The context below this one on the stack    is given by NEXT.  */
end_comment

begin_function
specifier|static
name|cp_parser_context
modifier|*
name|cp_parser_context_new
parameter_list|(
name|cp_parser_context
modifier|*
name|next
parameter_list|)
block|{
name|cp_parser_context
modifier|*
name|context
decl_stmt|;
comment|/* Allocate the storage.  */
if|if
condition|(
name|cp_parser_context_free_list
operator|!=
name|NULL
condition|)
block|{
comment|/* Pull the first entry from the free list.  */
name|context
operator|=
name|cp_parser_context_free_list
expr_stmt|;
name|cp_parser_context_free_list
operator|=
name|context
operator|->
name|next
expr_stmt|;
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|context
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|context
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
name|cp_parser_context
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No errors have occurred yet in this context.  */
name|context
operator|->
name|status
operator|=
name|CP_PARSER_STATUS_KIND_NO_ERROR
expr_stmt|;
comment|/* If this is not the bottomost context, copy information that we      need from the previous context.  */
if|if
condition|(
name|next
condition|)
block|{
comment|/* If, in the NEXT context, we are parsing an `x->' or `x.' 	 expression, then we are parsing one in this context, too.  */
name|context
operator|->
name|object_type
operator|=
name|next
operator|->
name|object_type
expr_stmt|;
comment|/* Thread the stack.  */
name|context
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|}
return|return
name|context
return|;
block|}
end_function

begin_comment
comment|/* The cp_parser structure represents the C++ parser.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cp_parser
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The lexer from which we are obtaining tokens.  */
name|cp_lexer
modifier|*
name|lexer
block|;
comment|/* The scope in which names should be looked up.  If NULL_TREE, then      we look up names in the scope that is currently open in the      source program.  If non-NULL, this is either a TYPE or      NAMESPACE_DECL for the scope in which we should look.         This value is not cleared automatically after a name is looked      up, so we must be careful to clear it before starting a new look      up sequence.  (If it is not cleared, then `X::Y' followed by `Z'      will look up `Z' in the scope of `X', rather than the current      scope.)  Unfortunately, it is difficult to tell when name lookup      is complete, because we sometimes peek at a token, look it up,      and then decide not to consume it.  */
name|tree
name|scope
block|;
comment|/* OBJECT_SCOPE and QUALIFYING_SCOPE give the scopes in which the      last lookup took place.  OBJECT_SCOPE is used if an expression      like "x->y" or "x.y" was used; it gives the type of "*x" or "x",      respectively.  QUALIFYING_SCOPE is used for an expression of the       form "X::Y"; it refers to X.  */
name|tree
name|object_scope
block|;
name|tree
name|qualifying_scope
block|;
comment|/* A stack of parsing contexts.  All but the bottom entry on the      stack will be tentative contexts.       We parse tentatively in order to determine which construct is in      use in some situations.  For example, in order to determine      whether a statement is an expression-statement or a      declaration-statement we parse it tentatively as a      declaration-statement.  If that fails, we then reparse the same      token stream as an expression-statement.  */
name|cp_parser_context
modifier|*
name|context
block|;
comment|/* True if we are parsing GNU C++.  If this flag is not set, then      GNU extensions are not recognized.  */
name|bool
name|allow_gnu_extensions_p
block|;
comment|/* TRUE if the `>' token should be interpreted as the greater-than      operator.  FALSE if it is the end of a template-id or      template-parameter-list.  */
name|bool
name|greater_than_is_operator_p
block|;
comment|/* TRUE if default arguments are allowed within a parameter list      that starts at this point. FALSE if only a gnu extension makes      them permissible.  */
name|bool
name|default_arg_ok_p
block|;
comment|/* TRUE if we are parsing an integral constant-expression.  See      [expr.const] for a precise definition.  */
name|bool
name|integral_constant_expression_p
block|;
comment|/* TRUE if we are parsing an integral constant-expression -- but a      non-constant expression should be permitted as well.  This flag      is used when parsing an array bound so that GNU variable-length      arrays are tolerated.  */
name|bool
name|allow_non_integral_constant_expression_p
block|;
comment|/* TRUE if ALLOW_NON_CONSTANT_EXPRESSION_P is TRUE and something has      been seen that makes the expression non-constant.  */
name|bool
name|non_integral_constant_expression_p
block|;
comment|/* TRUE if we are parsing the argument to "__offsetof__".  */
name|bool
name|in_offsetof_p
block|;
comment|/* TRUE if local variable names and `this' are forbidden in the      current context.  */
name|bool
name|local_variables_forbidden_p
block|;
comment|/* TRUE if the declaration we are parsing is part of a      linkage-specification of the form `extern string-literal      declaration'.  */
name|bool
name|in_unbraced_linkage_specification_p
block|;
comment|/* TRUE if we are presently parsing a declarator, after the      direct-declarator.  */
name|bool
name|in_declarator_p
block|;
comment|/* TRUE if we are presently parsing a template-argument-list.  */
name|bool
name|in_template_argument_list_p
block|;
comment|/* TRUE if we are presently parsing the body of an      iteration-statement.  */
name|bool
name|in_iteration_statement_p
block|;
comment|/* TRUE if we are presently parsing the body of a switch      statement.  */
name|bool
name|in_switch_statement_p
block|;
comment|/* TRUE if we are parsing a type-id in an expression context.  In      such a situation, both "type (expr)" and "type (type)" are valid      alternatives.  */
name|bool
name|in_type_id_in_expr_p
block|;
comment|/* If non-NULL, then we are parsing a construct where new type      definitions are not permitted.  The string stored here will be      issued as an error message if a type is defined.  */
specifier|const
name|char
modifier|*
name|type_definition_forbidden_message
block|;
comment|/* A list of lists. The outer list is a stack, used for member      functions of local classes. At each level there are two sub-list,      one on TREE_VALUE and one on TREE_PURPOSE. Each of those      sub-lists has a FUNCTION_DECL or TEMPLATE_DECL on their      TREE_VALUE's. The functions are chained in reverse declaration      order.       The TREE_PURPOSE sublist contains those functions with default      arguments that need post processing, and the TREE_VALUE sublist      contains those functions with definitions that need post      processing.       These lists can only be processed once the outermost class being      defined is complete.  */
name|tree
name|unparsed_functions_queues
block|;
comment|/* The number of classes whose definitions are currently in      progress.  */
name|unsigned
name|num_classes_being_defined
block|;
comment|/* The number of template parameter lists that apply directly to the      current declaration.  */
name|unsigned
name|num_template_parameter_lists
block|; }
end_typedef

begin_expr_stmt
name|cp_parser
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The type of a function that parses some kind of expression.  */
end_comment

begin_typedef
typedef|typedef
name|tree
function_decl|(
modifier|*
name|cp_parser_expression_fn
function_decl|)
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Prototypes.  */
end_comment

begin_comment
comment|/* Constructors and destructors.  */
end_comment

begin_function_decl
specifier|static
name|cp_parser
modifier|*
name|cp_parser_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Routines to parse various constructs.       Those that return `tree' will return the error_mark_node (rather    than NULL_TREE) if a parse error occurs, unless otherwise noted.    Sometimes, they will return an ordinary node if error-recovery was    attempted, even though a parse error occurred.  So, to check    whether or not a parse error occurred, you should always use    cp_parser_error_occurred.  If the construct is optional (indicated    either by an `_opt' in the name of the function that does the    parsing or via a FLAGS parameter), then NULL_TREE is returned if    the construct is not present.  */
end_comment

begin_comment
comment|/* Lexical conventions [gram.lex]  */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_identifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Basic concepts [gram.basic]  */
end_comment

begin_function_decl
specifier|static
name|bool
name|cp_parser_translation_unit
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Expressions [gram.expr]  */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_primary_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_id_kind
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_id_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_unqualified_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_nested_name_specifier_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_nested_name_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_class_or_namespace_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_postfix_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_parenthesized_expression_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_pseudo_destructor_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_unary_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tree_code
name|cp_parser_unary_operator
parameter_list|(
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_new_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_new_placement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_new_type_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_new_declarator_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_direct_new_declarator
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_new_initializer
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_delete_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_cast_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_pm_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_multiplicative_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_additive_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_shift_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_relational_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_equality_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_and_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_exclusive_or_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_inclusive_or_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_logical_and_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_logical_or_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_question_colon_clause
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_assignment_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tree_code
name|cp_parser_assignment_operator_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_constant_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Statements [gram.stmt.stmt]  */
end_comment

begin_function_decl
specifier|static
name|void
name|cp_parser_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_labeled_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_expression_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_compound_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_statement_seq_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_selection_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_condition
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_iteration_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_for_init_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_jump_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_declaration_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_implicitly_scoped_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_already_scoped_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Declarations [gram.dcl.dcl] */
end_comment

begin_function_decl
specifier|static
name|void
name|cp_parser_declaration_seq_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_block_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_simple_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_decl_specifier_seq
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_parser_flags
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_storage_class_specifier_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_function_specifier_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_type_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_parser_flags
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|int
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_simple_type_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_parser_flags
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_type_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_elaborated_type_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_enum_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_enumerator_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_enumerator_definition
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_namespace_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_namespace_definition
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_namespace_body
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_qualified_namespace_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_namespace_alias_definition
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_using_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_using_directive
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_asm_definition
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_linkage_specification
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Declarators [gram.dcl.decl] */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_init_declarator
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_declarator
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_parser_declarator_kind
parameter_list|,
name|int
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_direct_declarator
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_parser_declarator_kind
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tree_code
name|cp_parser_ptr_operator
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_cv_qualifier_seq_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_cv_qualifier_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_declarator_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_type_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_type_specifier_seq
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_parameter_declaration_clause
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_parameter_declaration_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_parameter_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_function_body
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_initializer
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_initializer_clause
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_initializer_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_ctor_initializer_opt_and_function_body
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Classes [gram.class] */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_class_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_class_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_class_head
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tag_types
name|cp_parser_class_key
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_member_specification_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_member_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_pure_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_constant_initializer
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Derived classes [gram.class.derived] */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_base_clause
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_base_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Special member functions [gram.special] */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_conversion_function_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_conversion_type_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_conversion_declarator_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_ctor_initializer_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_mem_initializer_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_mem_initializer
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_mem_initializer_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Overloading [gram.over] */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_operator_function_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_operator
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Templates [gram.temp] */
end_comment

begin_function_decl
specifier|static
name|void
name|cp_parser_template_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_template_parameter_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_template_parameter
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_type_parameter
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_template_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_template_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_template_argument_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_template_argument
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_explicit_instantiation
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_explicit_specialization
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Exception handling [gram.exception] */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_try_block
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_function_try_block
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_handler_seq
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_handler
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_exception_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_throw_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_exception_specification_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_type_id_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* GNU Extensions */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_asm_specification_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_asm_operand_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_asm_clobber_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_attributes_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_attribute_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_extension_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_label_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Utility Routines */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_lookup_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_lookup_name_simple
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_maybe_treat_template_as_class
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_check_declarator_template_parameters
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_check_template_parameters
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_simple_cast_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_binary_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
specifier|const
name|cp_parser_token_tree_map
parameter_list|,
name|cp_parser_expression_fn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_global_scope_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_constructor_declarator_p
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_function_definition_from_specifiers_and_declarator
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_function_definition_after_declarator
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_template_declaration_after_export
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_single_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_functional_cast
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_save_member_function_body
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_enclosed_template_argument_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_save_default_args
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_late_parsing_for_member
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_late_parsing_default_args
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_sizeof_operand
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|enum
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_declares_only_class_p
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_friend_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_token
modifier|*
name|cp_parser_require
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|enum
name|cpp_ttype
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_token
modifier|*
name|cp_parser_require_keyword
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|enum
name|rid
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_token_starts_function_definition_p
parameter_list|(
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_next_token_starts_class_definition_p
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_next_token_ends_template_argument_p
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_nth_token_starts_template_argument_list_p
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tag_types
name|cp_parser_token_is_class_key
parameter_list|(
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_check_class_key
parameter_list|(
name|enum
name|tag_types
parameter_list|,
name|tree
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_check_access_in_redeclaration
parameter_list|(
name|tree
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_optional_template_keyword
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_pre_parsed_nested_name_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_cache_group
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_token_cache
modifier|*
parameter_list|,
name|enum
name|cpp_ttype
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_parse_tentatively
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_commit_to_tentative_parse
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_abort_tentative_parse
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_parse_definitely
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|cp_parser_parsing_tentatively
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_committed_to_tentative_parse
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_error
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_name_lookup_error
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_simulate_error
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_check_type_definition
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_check_for_definition_in_return_type
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_check_for_invalid_template_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_non_integral_constant_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_diagnose_invalid_type_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cp_parser_skip_to_closing_parenthesis
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_skip_to_end_of_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_consume_semicolon_at_end_of_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_skip_to_end_of_block_or_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_skip_to_closing_brace
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_skip_until_found
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|enum
name|cpp_ttype
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_error_occurred
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_allow_gnu_extensions_p
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_is_string_literal
parameter_list|(
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_is_keyword
parameter_list|(
name|cp_token
modifier|*
parameter_list|,
name|enum
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Returns nonzero if we are parsing tentatively.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|cp_parser_parsing_tentatively
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
return|return
name|parser
operator|->
name|context
operator|->
name|next
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if TOKEN is a string literal.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_is_string_literal
parameter_list|(
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
return|return
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_STRING
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_WSTRING
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if TOKEN is the indicated KEYWORD.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_is_keyword
parameter_list|(
name|cp_token
modifier|*
name|token
parameter_list|,
name|enum
name|rid
name|keyword
parameter_list|)
block|{
return|return
name|token
operator|->
name|keyword
operator|==
name|keyword
return|;
block|}
end_function

begin_comment
comment|/* Issue the indicated error MESSAGE.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_error
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
comment|/* Output the MESSAGE -- unless we're parsing tentatively.  */
if|if
condition|(
operator|!
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|c_parse_error
argument_list|(
name|message
argument_list|,
comment|/* Because c_parser_error does not understand 			CPP_KEYWORD, keywords are treated like 			identifiers.  */
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_KEYWORD
condition|?
name|CPP_NAME
else|:
name|token
operator|->
name|type
operator|)
argument_list|,
name|token
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Issue an error about name-lookup failing.  NAME is the    IDENTIFIER_NODE DECL is the result of    the lookup (as returned from cp_parser_lookup_name).  DESIRED is    the thing that we hoped to find.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_name_lookup_error
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|desired
parameter_list|)
block|{
comment|/* If name lookup completely failed, tell the user that NAME was not      declared.  */
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|parser
operator|->
name|scope
operator|&&
name|parser
operator|->
name|scope
operator|!=
name|global_namespace
condition|)
name|error
argument_list|(
literal|"`%D::%D' has not been declared"
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parser
operator|->
name|scope
operator|==
name|global_namespace
condition|)
name|error
argument_list|(
literal|"`::%D' has not been declared"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`%D' has not been declared"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parser
operator|->
name|scope
operator|&&
name|parser
operator|->
name|scope
operator|!=
name|global_namespace
condition|)
name|error
argument_list|(
literal|"`%D::%D' %s"
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|name
argument_list|,
name|desired
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parser
operator|->
name|scope
operator|==
name|global_namespace
condition|)
name|error
argument_list|(
literal|"`::%D' %s"
argument_list|,
name|name
argument_list|,
name|desired
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`%D' %s"
argument_list|,
name|name
argument_list|,
name|desired
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If we are parsing tentatively, remember that an error has occurred    during this tentative parse.  Returns true if the error was    simulated; false if a messgae should be issued by the caller.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_simulate_error
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
if|if
condition|(
name|cp_parser_parsing_tentatively
argument_list|(
name|parser
argument_list|)
operator|&&
operator|!
name|cp_parser_committed_to_tentative_parse
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|parser
operator|->
name|context
operator|->
name|status
operator|=
name|CP_PARSER_STATUS_KIND_ERROR
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* This function is called when a type is defined.  If type    definitions are forbidden at this point, an error message is    issued.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_check_type_definition
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* If types are forbidden here, issue a message.  */
if|if
condition|(
name|parser
operator|->
name|type_definition_forbidden_message
condition|)
comment|/* Use `%s' to print the string in case there are any escape        characters in the message.  */
name|error
argument_list|(
literal|"%s"
argument_list|,
name|parser
operator|->
name|type_definition_forbidden_message
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called when a declaration is parsed.  If    DECLARATOR is a function declarator and DECLARES_CLASS_OR_ENUM    indicates that a type was defined in the decl-specifiers for DECL,    then an error is issued.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_check_for_definition_in_return_type
parameter_list|(
name|tree
name|declarator
parameter_list|,
name|int
name|declares_class_or_enum
parameter_list|)
block|{
comment|/* [dcl.fct] forbids type definitions in return types.      Unfortunately, it's not easy to know whether or not we are      processing a return type until after the fact.  */
while|while
condition|(
name|declarator
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|INDIRECT_REF
operator|||
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
operator|)
condition|)
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|declares_class_or_enum
operator|&
literal|2
condition|)
name|error
argument_list|(
literal|"new types may not be defined in a return type"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A type-specifier (TYPE) has been parsed which cannot be followed by    "<" in any valid C++ program.  If the next token is indeed "<",    issue a message warning the user about what appears to be an    invalid attempt to form a template-id.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_check_for_invalid_template_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|ptrdiff_t
name|start
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_LESS
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"`%T' is not a template"
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|error
argument_list|(
literal|"`%s' is not a template"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid template-id"
argument_list|)
expr_stmt|;
comment|/* Remember the location of the invalid "<".  */
if|if
condition|(
name|cp_parser_parsing_tentatively
argument_list|(
name|parser
argument_list|)
operator|&&
operator|!
name|cp_parser_committed_to_tentative_parse
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_prev_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|start
operator|=
name|cp_lexer_token_difference
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|parser
operator|->
name|lexer
operator|->
name|first_token
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
else|else
name|start
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Consume the "<".  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the template arguments.  */
name|cp_parser_enclosed_template_argument_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Permanently remove the invalid template arguments so that 	 this error message is not issued again.  */
if|if
condition|(
name|start
operator|>=
literal|0
condition|)
block|{
name|token
operator|=
name|cp_lexer_advance_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|parser
operator|->
name|lexer
operator|->
name|first_token
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|cp_lexer_purge_tokens_after
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* If parsing an integral constant-expression, issue an error message    about the fact that THING appeared and return true.  Otherwise,    return false, marking the current expression as non-constant.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_non_integral_constant_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|thing
parameter_list|)
block|{
if|if
condition|(
name|parser
operator|->
name|integral_constant_expression_p
condition|)
block|{
if|if
condition|(
operator|!
name|parser
operator|->
name|allow_non_integral_constant_expression_p
condition|)
block|{
name|error
argument_list|(
literal|"%s cannot appear in a constant-expression"
argument_list|,
name|thing
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|parser
operator|->
name|non_integral_constant_expression_p
operator|=
name|true
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Check for a common situation where a type-name should be present,    but is not, and issue a sensible error message.  Returns true if an    invalid type-name was detected.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_diagnose_invalid_type_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* If the next two tokens are both identifiers, the code is      erroneous. The usual cause of this situation is code like:         T t;       where "T" should name a type -- but does not.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
block|{
name|tree
name|name
decl_stmt|;
comment|/* If parsing tentatively, we should commit; we really are 	 looking at a declaration.  */
comment|/* Consume the first identifier.  */
name|name
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|value
expr_stmt|;
comment|/* Issue an error message.  */
name|error
argument_list|(
literal|"`%s' does not name a type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're in a template class, it's possible that the user was 	 referring to a type from a base class.  For example:  	   template<typename T> struct A { typedef T X; }; 	   template<typename T> struct B : public A<T> { X x; };  	 The user should have said "typename A<T>::X".  */
if|if
condition|(
name|processing_template_decl
operator|&&
name|current_class_type
condition|)
block|{
name|tree
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
init|;
name|b
condition|;
name|b
operator|=
name|TREE_CHAIN
argument_list|(
name|b
argument_list|)
control|)
block|{
name|tree
name|base_type
init|=
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|base_type
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|base_type
argument_list|)
condition|)
block|{
name|tree
name|field
decl_stmt|;
comment|/* Go from a particular instantiation of the 		     template (which will have an empty TYPE_FIELDs), 		     to the main version.  */
name|base_type
operator|=
name|CLASSTYPE_PRIMARY_TEMPLATE_TYPE
argument_list|(
name|base_type
argument_list|)
expr_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|base_type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|name
condition|)
block|{
name|error
argument_list|(
literal|"(perhaps `typename %T::%s' was intended)"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|field
condition|)
break|break;
block|}
block|}
block|}
comment|/* Skip to the end of the declaration; there's no point in 	 trying to process it.  */
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Consume tokens up to, and including, the next non-nested closing `)'.     Returns 1 iff we found a closing `)'.  RECOVERING is true, if we    are doing error recovery. Returns -1 if OR_COMMA is true and we    found an unnested comma.  */
end_comment

begin_function
specifier|static
name|int
name|cp_parser_skip_to_closing_parenthesis
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|recovering
parameter_list|,
name|bool
name|or_comma
parameter_list|,
name|bool
name|consume_paren
parameter_list|)
block|{
name|unsigned
name|paren_depth
init|=
literal|0
decl_stmt|;
name|unsigned
name|brace_depth
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|recovering
operator|&&
operator|!
name|or_comma
operator|&&
name|cp_parser_parsing_tentatively
argument_list|(
name|parser
argument_list|)
operator|&&
operator|!
name|cp_parser_committed_to_tentative_parse
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* If we've run out of tokens, then there is no closing `)'.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EOF
argument_list|)
condition|)
return|return
literal|0
return|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* This matches the processing in skip_to_end_of_statement.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_SEMICOLON
operator|&&
operator|!
name|brace_depth
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
condition|)
operator|++
name|brace_depth
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
condition|)
block|{
if|if
condition|(
operator|!
name|brace_depth
operator|--
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|recovering
operator|&&
name|or_comma
operator|&&
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
operator|&&
operator|!
name|brace_depth
operator|&&
operator|!
name|paren_depth
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|brace_depth
condition|)
block|{
comment|/* If it is an `(', we have entered another level of nesting.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
operator|++
name|paren_depth
expr_stmt|;
comment|/* If it is a `)', then we might be done.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
operator|&&
operator|!
name|paren_depth
operator|--
condition|)
block|{
if|if
condition|(
name|consume_paren
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Consume tokens until we reach the end of the current statement.    Normally, that will be just before consuming a `;'.  However, if a    non-nested `}' comes first, then we stop before consuming that.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_skip_to_end_of_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|unsigned
name|nesting_depth
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If we've run out of tokens, stop.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
comment|/* If the next token is a `;', we have reached the end of the 	 statement.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_SEMICOLON
operator|&&
operator|!
name|nesting_depth
condition|)
break|break;
comment|/* If the next token is a non-nested `}', then we have reached 	 the end of the current block.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
condition|)
block|{
comment|/* If this is a non-nested `}', stop before consuming it. 	     That way, when confronted with something like:  	       { 3 + }   	     we stop before consuming the closing `}', even though we 	     have not yet reached a `;'.  */
if|if
condition|(
name|nesting_depth
operator|==
literal|0
condition|)
break|break;
comment|/* If it is the closing `}' for a block that we have 	     scanned, stop -- but only after consuming the token. 	     That way given:  	        void f g () { ... } 		typedef int I;  	     we will stop after the body of the erroneously declared 	     function, but before consuming the following `typedef' 	     declaration.  */
if|if
condition|(
operator|--
name|nesting_depth
operator|==
literal|0
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If it the next token is a `{', then we are entering a new 	 block.  Consume the entire block.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
condition|)
operator|++
name|nesting_depth
expr_stmt|;
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called at the end of a statement or declaration.    If the next token is a semicolon, it is consumed; otherwise, error    recovery is attempted.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_consume_semicolon_at_end_of_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Look for the trailing `;'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
condition|)
block|{
comment|/* If there is additional (erroneous) input, skip to the end of 	 the statement.  */
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is now a `;', consume it.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Skip tokens until we have consumed an entire block, or until we    have consumed a non-nested `;'.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_skip_to_end_of_block_or_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|unsigned
name|nesting_depth
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If we've run out of tokens, stop.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
comment|/* If the next token is a `;', we have reached the end of the 	 statement.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_SEMICOLON
operator|&&
operator|!
name|nesting_depth
condition|)
block|{
comment|/* Consume the `;'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Consume the token.  */
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token is a non-nested `}', then we have reached 	 the end of the current block.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
operator|&&
operator|(
name|nesting_depth
operator|==
literal|0
operator|||
operator|--
name|nesting_depth
operator|==
literal|0
operator|)
condition|)
break|break;
comment|/* If it the next token is a `{', then we are entering a new 	 block.  Consume the entire block.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
condition|)
operator|++
name|nesting_depth
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Skip tokens until a non-nested closing curly brace is the next    token.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_skip_to_closing_brace
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|unsigned
name|nesting_depth
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If we've run out of tokens, stop.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
comment|/* If the next token is a non-nested `}', then we have reached 	 the end of the current block.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
operator|&&
name|nesting_depth
operator|--
operator|==
literal|0
condition|)
break|break;
comment|/* If it the next token is a `{', then we are entering a new 	 block.  Consume the entire block.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
condition|)
operator|++
name|nesting_depth
expr_stmt|;
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a new C++ parser.  */
end_comment

begin_function
specifier|static
name|cp_parser
modifier|*
name|cp_parser_new
parameter_list|(
name|void
parameter_list|)
block|{
name|cp_parser
modifier|*
name|parser
decl_stmt|;
name|cp_lexer
modifier|*
name|lexer
decl_stmt|;
comment|/* cp_lexer_new_main is called before calling ggc_alloc because      cp_lexer_new_main might load a PCH file.  */
name|lexer
operator|=
name|cp_lexer_new_main
argument_list|()
expr_stmt|;
name|parser
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
name|cp_parser
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|->
name|lexer
operator|=
name|lexer
expr_stmt|;
name|parser
operator|->
name|context
operator|=
name|cp_parser_context_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* For now, we always accept GNU extensions.  */
name|parser
operator|->
name|allow_gnu_extensions_p
operator|=
literal|1
expr_stmt|;
comment|/* The `>' token is a greater-than operator, not the end of a      template-id.  */
name|parser
operator|->
name|greater_than_is_operator_p
operator|=
name|true
expr_stmt|;
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|true
expr_stmt|;
comment|/* We are not parsing a constant-expression.  */
name|parser
operator|->
name|integral_constant_expression_p
operator|=
name|false
expr_stmt|;
name|parser
operator|->
name|allow_non_integral_constant_expression_p
operator|=
name|false
expr_stmt|;
name|parser
operator|->
name|non_integral_constant_expression_p
operator|=
name|false
expr_stmt|;
comment|/* We are not parsing offsetof.  */
name|parser
operator|->
name|in_offsetof_p
operator|=
name|false
expr_stmt|;
comment|/* Local variable names are not forbidden.  */
name|parser
operator|->
name|local_variables_forbidden_p
operator|=
name|false
expr_stmt|;
comment|/* We are not processing an `extern "C"' declaration.  */
name|parser
operator|->
name|in_unbraced_linkage_specification_p
operator|=
name|false
expr_stmt|;
comment|/* We are not processing a declarator.  */
name|parser
operator|->
name|in_declarator_p
operator|=
name|false
expr_stmt|;
comment|/* We are not processing a template-argument-list.  */
name|parser
operator|->
name|in_template_argument_list_p
operator|=
name|false
expr_stmt|;
comment|/* We are not in an iteration statement.  */
name|parser
operator|->
name|in_iteration_statement_p
operator|=
name|false
expr_stmt|;
comment|/* We are not in a switch statement.  */
name|parser
operator|->
name|in_switch_statement_p
operator|=
name|false
expr_stmt|;
comment|/* We are not parsing a type-id inside an expression.  */
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|false
expr_stmt|;
comment|/* The unparsed function queue is empty.  */
name|parser
operator|->
name|unparsed_functions_queues
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* There are no classes being defined.  */
name|parser
operator|->
name|num_classes_being_defined
operator|=
literal|0
expr_stmt|;
comment|/* No template parameters apply.  */
name|parser
operator|->
name|num_template_parameter_lists
operator|=
literal|0
expr_stmt|;
return|return
name|parser
return|;
block|}
end_function

begin_comment
comment|/* Lexical conventions [gram.lex]  */
end_comment

begin_comment
comment|/* Parse an identifier.  Returns an IDENTIFIER_NODE representing the    identifier.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_identifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Look for the identifier.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|,
literal|"identifier"
argument_list|)
expr_stmt|;
comment|/* Return the value.  */
return|return
name|token
condition|?
name|token
operator|->
name|value
else|:
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Basic concepts [gram.basic]  */
end_comment

begin_comment
comment|/* Parse a translation-unit.     translation-unit:      declaration-seq [opt]       Returns TRUE if all went well.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_translation_unit
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
name|cp_parser_declaration_seq_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If there are no tokens left then all went well.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EOF
argument_list|)
condition|)
break|break;
comment|/* Otherwise, issue an error message.  */
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected declaration"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Consume the EOF token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_EOF
argument_list|,
literal|"end-of-file"
argument_list|)
expr_stmt|;
comment|/* Finish up.  */
name|finish_translation_unit
argument_list|()
expr_stmt|;
comment|/* All went well.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Expressions [gram.expr] */
end_comment

begin_comment
comment|/* Parse a primary-expression.     primary-expression:      literal      this      ( expression )      id-expression     GNU Extensions:     primary-expression:      ( compound-statement )      __builtin_va_arg ( assignment-expression , type-id )     literal:      __null     Returns a representation of the expression.       *IDK indicates what kind of id-expression (if any) was present.       *QUALIFYING_CLASS is set to a non-NULL value if the id-expression can be    used as the operand of a pointer-to-member.  In that case,    *QUALIFYING_CLASS gives the class that is used as the qualifying    class in the pointer-to-member.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_primary_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_id_kind
modifier|*
name|idk
parameter_list|,
name|tree
modifier|*
name|qualifying_class
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Assume the primary expression is not an id-expression.  */
operator|*
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
comment|/* And that it cannot be used as pointer-to-member.  */
operator|*
name|qualifying_class
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
comment|/* literal: 	   integer-literal 	   character-literal 	   floating-literal 	   string-literal 	   boolean-literal  */
case|case
name|CPP_CHAR
case|:
case|case
name|CPP_WCHAR
case|:
case|case
name|CPP_STRING
case|:
case|case
name|CPP_WSTRING
case|:
case|case
name|CPP_NUMBER
case|:
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|token
operator|->
name|value
return|;
case|case
name|CPP_OPEN_PAREN
case|:
block|{
name|tree
name|expr
decl_stmt|;
name|bool
name|saved_greater_than_is_operator_p
decl_stmt|;
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Within a parenthesized expression, a `>' token is always 	   the greater-than operator.  */
name|saved_greater_than_is_operator_p
operator|=
name|parser
operator|->
name|greater_than_is_operator_p
expr_stmt|;
name|parser
operator|->
name|greater_than_is_operator_p
operator|=
name|true
expr_stmt|;
comment|/* If we see `( { ' then we are looking at the beginning of 	   a GNU statement-expression.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
block|{
comment|/* Statement-expressions are not allowed by the standard.  */
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids braced-groups within expressions"
argument_list|)
expr_stmt|;
comment|/* And they're not allowed outside of a function-body; you 	       cannot, for example, write: 	        	         int i = ({ int j = 3; j + 1; }); 	        	       at class or namespace scope.  */
if|if
condition|(
operator|!
name|at_function_scope_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"statement-expressions are allowed only inside functions"
argument_list|)
expr_stmt|;
comment|/* Start the statement-expression.  */
name|expr
operator|=
name|begin_stmt_expr
argument_list|()
expr_stmt|;
comment|/* Parse the compound-statement.  */
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Finish up.  */
name|expr
operator|=
name|finish_stmt_expr
argument_list|(
name|expr
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Parse the parenthesized expression.  */
name|expr
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Let the front end know that this expression was 	       enclosed in parentheses. This matters in case, for 	       example, the expression is of the form `A::B', since 	       `&A::B' might be a pointer-to-member, but `&(A::B)' is 	       not.  */
name|finish_parenthesized_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* The `>' token might be the end of a template-id or 	   template-parameter-list now.  */
name|parser
operator|->
name|greater_than_is_operator_p
operator|=
name|saved_greater_than_is_operator_p
expr_stmt|;
comment|/* Consume the `)'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
case|case
name|CPP_KEYWORD
case|:
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
comment|/* These two are the boolean literals.  */
case|case
name|RID_TRUE
case|:
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|boolean_true_node
return|;
case|case
name|RID_FALSE
case|:
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|boolean_false_node
return|;
comment|/* The `__null' literal.  */
case|case
name|RID_NULL
case|:
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|null_node
return|;
comment|/* Recognize the `this' keyword.  */
case|case
name|RID_THIS
case|:
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|local_variables_forbidden_p
condition|)
block|{
name|error
argument_list|(
literal|"`this' may not be used in this context"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Pointers cannot appear in constant-expressions.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"`this'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
return|return
name|finish_this_expr
argument_list|()
return|;
comment|/* The `operator' keyword can be the beginning of an 	     id-expression.  */
case|case
name|RID_OPERATOR
case|:
goto|goto
name|id_expression
goto|;
case|case
name|RID_FUNCTION_NAME
case|:
case|case
name|RID_PRETTY_FUNCTION_NAME
case|:
case|case
name|RID_C99_FUNCTION_NAME
case|:
comment|/* The symbols __FUNCTION__, __PRETTY_FUNCTION__, and 	     __func__ are the names of variables -- but they are 	     treated specially.  Therefore, they are handled here, 	     rather than relying on the generic id-expression logic 	     below.  Grammatically, these names are id-expressions.    	     Consume the token.  */
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look up the name.  */
return|return
name|finish_fname
argument_list|(
name|token
operator|->
name|value
argument_list|)
return|;
case|case
name|RID_VA_ARG
case|:
block|{
name|tree
name|expression
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* The `__builtin_va_arg' construct is used to handle 	       `va_arg'.  Consume the `__builtin_va_arg' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the opening `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Now, parse the assignment-expression.  */
name|expression
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the `,'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|,
literal|"`,'"
argument_list|)
expr_stmt|;
comment|/* Parse the type-id.  */
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the closing `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Using `va_arg' in a constant-expression is not 	       allowed.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"`va_arg'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_x_va_arg
argument_list|(
name|expression
argument_list|,
name|type
argument_list|)
return|;
block|}
case|case
name|RID_OFFSETOF
case|:
block|{
name|tree
name|expression
decl_stmt|;
name|bool
name|saved_in_offsetof_p
decl_stmt|;
comment|/* Consume the "__offsetof__" token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Consume the opening `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Parse the parenthesized (almost) constant-expression.  */
name|saved_in_offsetof_p
operator|=
name|parser
operator|->
name|in_offsetof_p
expr_stmt|;
name|parser
operator|->
name|in_offsetof_p
operator|=
name|true
expr_stmt|;
name|expression
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant_p=*/
name|false
argument_list|,
comment|/*non_constant_p=*/
name|NULL
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_offsetof_p
operator|=
name|saved_in_offsetof_p
expr_stmt|;
comment|/* Consume the closing ')'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
return|return
name|expression
return|;
block|}
default|default:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected primary-expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* An id-expression can start with either an identifier, a 	 `::' as the beginning of a qualified-id, or the "operator" 	 keyword.  */
case|case
name|CPP_NAME
case|:
case|case
name|CPP_SCOPE
case|:
case|case
name|CPP_TEMPLATE_ID
case|:
case|case
name|CPP_NESTED_NAME_SPECIFIER
case|:
block|{
name|tree
name|id_expression
decl_stmt|;
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|error_msg
decl_stmt|;
name|id_expression
label|:
comment|/* Parse the id-expression.  */
name|id_expression
operator|=
name|cp_parser_id_expression
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*template_p=*/
name|NULL
argument_list|,
comment|/*declarator_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|id_expression
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* If we have a template-id, then no further lookup is 	   required.  If the template-id was for a template-class, we 	   will sometimes have a TYPE_DECL at this point.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id_expression
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|id_expression
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|decl
operator|=
name|id_expression
expr_stmt|;
comment|/* Look up the name.  */
else|else
block|{
name|decl
operator|=
name|cp_parser_lookup_name_simple
argument_list|(
name|parser
argument_list|,
name|id_expression
argument_list|)
expr_stmt|;
comment|/* If name lookup gives us a SCOPE_REF, then the 	       qualifying scope was dependent.  Just propagate the 	       name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
operator|*
name|qualifying_class
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* Check to see if DECL is a local variable in a context 	       where that is forbidden.  */
if|if
condition|(
name|parser
operator|->
name|local_variables_forbidden_p
operator|&&
name|local_variable_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* It might be that we only found DECL because we are 		   trying to be generous with pre-ISO scoping rules. 		   For example, consider:  		     int i; 		     void g() { 		       for (int i = 0; i< 10; ++i) {} 		       extern void f(int j = i); 		     }  		   Here, name look up will originally find the out  		   of scope `i'.  We need to issue a warning message, 		   but then use the global `i'.  */
name|decl
operator|=
name|check_for_out_of_scope_variable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_variable_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"local variable `%D' may not appear in this context"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
block|}
name|decl
operator|=
name|finish_id_expression
argument_list|(
name|id_expression
argument_list|,
name|decl
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|idk
argument_list|,
name|qualifying_class
argument_list|,
name|parser
operator|->
name|integral_constant_expression_p
argument_list|,
name|parser
operator|->
name|allow_non_integral_constant_expression_p
argument_list|,
operator|&
name|parser
operator|->
name|non_integral_constant_expression_p
argument_list|,
operator|&
name|error_msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_msg
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
name|error_msg
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* Anything else is an error.  */
default|default:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected primary-expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an id-expression.     id-expression:      unqualified-id      qualified-id     qualified-id:      :: [opt] nested-name-specifier template [opt] unqualified-id      :: identifier      :: operator-function-id      :: template-id     Return a representation of the unqualified portion of the    identifier.  Sets PARSER->SCOPE to the qualifying scope if there is    a `::' or nested-name-specifier.     Often, if the id-expression was a qualified-id, the caller will    want to make a SCOPE_REF to represent the qualified-id.  This    function does not do this in order to avoid wastefully creating    SCOPE_REFs when they are not required.     If TEMPLATE_KEYWORD_P is true, then we have just seen the    `template' keyword.     If CHECK_DEPENDENCY_P is false, then names are looked up inside    uninstantiated templates.       If *TEMPLATE_P is non-NULL, it is set to true iff the    `template' keyword is used to explicitly indicate that the entity    named is a template.       If DECLARATOR_P is true, the id-expression is appearing as part of    a declarator, rather than as part of an expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_id_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|template_keyword_p
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
modifier|*
name|template_p
parameter_list|,
name|bool
name|declarator_p
parameter_list|)
block|{
name|bool
name|global_scope_p
decl_stmt|;
name|bool
name|nested_name_specifier_p
decl_stmt|;
comment|/* Assume the `template' keyword was not used.  */
if|if
condition|(
name|template_p
condition|)
operator|*
name|template_p
operator|=
name|false
expr_stmt|;
comment|/* Look for the optional `::' operator.  */
name|global_scope_p
operator|=
operator|(
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Look for the optional nested-name-specifier.  */
name|nested_name_specifier_p
operator|=
operator|(
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
name|check_dependency_p
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declarator=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* If there is a nested-name-specifier, then we are looking at      the first qualified-id production.  */
if|if
condition|(
name|nested_name_specifier_p
condition|)
block|{
name|tree
name|saved_scope
decl_stmt|;
name|tree
name|saved_object_scope
decl_stmt|;
name|tree
name|saved_qualifying_scope
decl_stmt|;
name|tree
name|unqualified_id
decl_stmt|;
name|bool
name|is_template
decl_stmt|;
comment|/* See if the next token is the `template' keyword.  */
if|if
condition|(
operator|!
name|template_p
condition|)
name|template_p
operator|=
operator|&
name|is_template
expr_stmt|;
operator|*
name|template_p
operator|=
name|cp_parser_optional_template_keyword
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Name lookup we do during the processing of the 	 unqualified-id might obliterate SCOPE.  */
name|saved_scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|saved_object_scope
operator|=
name|parser
operator|->
name|object_scope
expr_stmt|;
name|saved_qualifying_scope
operator|=
name|parser
operator|->
name|qualifying_scope
expr_stmt|;
comment|/* Process the final unqualified-id.  */
name|unqualified_id
operator|=
name|cp_parser_unqualified_id
argument_list|(
name|parser
argument_list|,
operator|*
name|template_p
argument_list|,
name|check_dependency_p
argument_list|,
name|declarator_p
argument_list|)
expr_stmt|;
comment|/* Restore the SAVED_SCOPE for our caller.  */
name|parser
operator|->
name|scope
operator|=
name|saved_scope
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|saved_object_scope
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|saved_qualifying_scope
expr_stmt|;
return|return
name|unqualified_id
return|;
block|}
comment|/* Otherwise, if we are in global scope, then we are looking at one      of the other qualified-id productions.  */
elseif|else
if|if
condition|(
name|global_scope_p
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|id
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's an identifier, and the next token is not a "<", then 	 we can avoid the template-id case.  This is an optimization 	 for this common case.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
operator|&&
operator|!
name|cp_parser_nth_token_starts_template_argument_list_p
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
return|;
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try a template-id.  */
name|id
operator|=
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
name|declarator_p
argument_list|)
expr_stmt|;
comment|/* If that worked, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|id
return|;
comment|/* Peek at the next token.  (Changes in the token buffer may 	 have invalidated the pointer obtained above.)  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_NAME
case|:
return|return
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
return|;
case|case
name|CPP_KEYWORD
case|:
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_OPERATOR
condition|)
return|return
name|cp_parser_operator_function_id
argument_list|(
name|parser
argument_list|)
return|;
comment|/* Fall through.  */
default|default:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected id-expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
return|return
name|cp_parser_unqualified_id
argument_list|(
name|parser
argument_list|,
name|template_keyword_p
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
name|declarator_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an unqualified-id.     unqualified-id:      identifier      operator-function-id      conversion-function-id      ~ class-name      template-id     If TEMPLATE_KEYWORD_P is TRUE, we have just seen the `template'    keyword, in a construct like `A::template ...'.     Returns a representation of unqualified-id.  For the `identifier'    production, an IDENTIFIER_NODE is returned.  For the `~ class-name'    production a BIT_NOT_EXPR is returned; the operand of the    BIT_NOT_EXPR is an IDENTIFIER_NODE for the class-name.  For the    other productions, see the documentation accompanying the    corresponding parsing functions.  If CHECK_DEPENDENCY_P is false,    names are looked up in uninstantiated templates.  If DECLARATOR_P    is true, the unqualified-id is appearing as part of a declarator,    rather than as part of an expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_unqualified_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|template_keyword_p
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
name|declarator_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_NAME
case|:
block|{
name|tree
name|id
decl_stmt|;
comment|/* We don't know yet whether or not this will be a 	   template-id.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try a template-id.  */
name|id
operator|=
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
name|template_keyword_p
argument_list|,
name|check_dependency_p
argument_list|,
name|declarator_p
argument_list|)
expr_stmt|;
comment|/* If it worked, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|id
return|;
comment|/* Otherwise, it's an ordinary identifier.  */
return|return
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
return|;
block|}
case|case
name|CPP_TEMPLATE_ID
case|:
return|return
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
name|template_keyword_p
argument_list|,
name|check_dependency_p
argument_list|,
name|declarator_p
argument_list|)
return|;
case|case
name|CPP_COMPL
case|:
block|{
name|tree
name|type_decl
decl_stmt|;
name|tree
name|qualifying_scope
decl_stmt|;
name|tree
name|object_scope
decl_stmt|;
name|tree
name|scope
decl_stmt|;
comment|/* Consume the `~' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the class-name.  The standard, as written, seems to 	   say that:  	     template<typename T> struct S { ~S (); }; 	     template<typename T> S<T>::~S() {}             is invalid, since `~' must be followed by a class-name, but 	   `S<T>' is dependent, and so not known to be a class. 	   That's not right; we need to look in uninstantiated 	   templates.  A further complication arises from:  	     template<typename T> void f(T t) { 	       t.T::~T(); 	     }   	   Here, it is not possible to look up `T' in the scope of `T' 	   itself.  We must look in both the current scope, and the 	   scope of the containing complete expression.    	   Yet another issue is:               struct S {                int S;                ~S();              };               S::~S() {}             The standard does not seem to say that the `S' in `~S' 	   should refer to the type `S' and not the data member 	   `S::S'.  */
comment|/* DR 244 says that we look up the name after the "~" in the 	   same scope as we looked up the qualifying name.  That idea 	   isn't fully worked out; it's more complicated than that.  */
name|scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|object_scope
operator|=
name|parser
operator|->
name|object_scope
expr_stmt|;
name|qualifying_scope
operator|=
name|parser
operator|->
name|qualifying_scope
expr_stmt|;
comment|/* If the name is of the form "X::~X" it's OK.  */
if|if
condition|(
name|scope
operator|&&
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
operator|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
operator|)
operator|&&
operator|(
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|value
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|scope
argument_list|)
operator|)
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|build_nt
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|scope
argument_list|)
return|;
block|}
comment|/* If there was an explicit qualification (S::~T), first look 	   in the scope given by the qualification (i.e., S).  */
if|if
condition|(
name|scope
condition|)
block|{
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*check_dependency=*/
name|false
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
name|declarator_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|build_nt
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|type_decl
argument_list|)
argument_list|)
return|;
block|}
comment|/* In "N::S::~S", look in "N" as well.  */
if|if
condition|(
name|scope
operator|&&
name|qualifying_scope
condition|)
block|{
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|scope
operator|=
name|qualifying_scope
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|type_decl
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*check_dependency=*/
name|false
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
name|declarator_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|build_nt
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|type_decl
argument_list|)
argument_list|)
return|;
block|}
comment|/* In "p->S::~T", look in the scope given by "*p" as well.  */
elseif|else
if|if
condition|(
name|object_scope
condition|)
block|{
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|scope
operator|=
name|object_scope
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|type_decl
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*check_dependency=*/
name|false
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
name|declarator_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|build_nt
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|type_decl
argument_list|)
argument_list|)
return|;
block|}
comment|/* Look in the surrounding context.  */
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|type_decl
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*check_dependency=*/
name|false
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
name|declarator_p
argument_list|)
expr_stmt|;
comment|/* If an error occurred, assume that the name of the 	   destructor is the same as the name of the qualifying 	   class.  That allows us to keep parsing after running 	   into ill-formed destructor names.  */
if|if
condition|(
name|type_decl
operator|==
name|error_mark_node
operator|&&
name|scope
operator|&&
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
return|return
name|build_nt
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|scope
argument_list|)
return|;
elseif|else
if|if
condition|(
name|type_decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* [class.dtor]  	   A typedef-name that names a class shall not be used as the 	   identifier in the declarator for a destructor declaration.  */
if|if
condition|(
name|declarator_p
operator|&&
operator|!
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|type_decl
argument_list|)
operator|&&
operator|!
name|DECL_SELF_REFERENCE_P
argument_list|(
name|type_decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"typedef-name `%D' used as destructor declarator"
argument_list|,
name|type_decl
argument_list|)
expr_stmt|;
return|return
name|build_nt
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|type_decl
argument_list|)
argument_list|)
return|;
block|}
case|case
name|CPP_KEYWORD
case|:
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_OPERATOR
condition|)
block|{
name|tree
name|id
decl_stmt|;
comment|/* This could be a template-id, so we try that first.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try a template-id.  */
name|id
operator|=
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
name|template_keyword_p
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
name|declarator_p
argument_list|)
expr_stmt|;
comment|/* If that worked, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|id
return|;
comment|/* We still don't know whether we're looking at an 	     operator-function-id or a conversion-function-id.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try an operator-function-id.  */
name|id
operator|=
name|cp_parser_operator_function_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If that didn't work, try a conversion-function-id.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|id
operator|=
name|cp_parser_conversion_function_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
comment|/* Fall through.  */
default|default:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected unqualified-id"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an (optional) nested-name-specifier.     nested-name-specifier:      class-or-namespace-name :: nested-name-specifier [opt]      class-or-namespace-name :: template nested-name-specifier [opt]     PARSER->SCOPE should be set appropriately before this function is    called.  TYPENAME_KEYWORD_P is TRUE if the `typename' keyword is in    effect.  TYPE_P is TRUE if we non-type bindings should be ignored    in name lookups.     Sets PARSER->SCOPE to the class (TYPE) or namespace    (NAMESPACE_DECL) specified by the nested-name-specifier, or leaves    it unchanged if there is no nested-name-specifier.  Returns the new    scope iff there is a nested-name-specifier, or NULL_TREE otherwise.       If IS_DECLARATION is TRUE, the nested-name-specifier is known to be    part of a declaration and/or decl-specifier.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_nested_name_specifier_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|typename_keyword_p
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
name|type_p
parameter_list|,
name|bool
name|is_declaration
parameter_list|)
block|{
name|bool
name|success
init|=
name|false
decl_stmt|;
name|tree
name|access_check
init|=
name|NULL_TREE
decl_stmt|;
name|ptrdiff_t
name|start
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* If the next token corresponds to a nested name specifier, there      is no need to reparse it.  However, if CHECK_DEPENDENCY_P is      false, it may have been true before, in which case something       like `A<X>::B<Y>::C' may have resulted in a nested-name-specifier      of `A<X>::', where it should now be `A<X>::B<Y>::'.  So, when      CHECK_DEPENDENCY_P is false, we have to fall through into the      main loop.  */
if|if
condition|(
name|check_dependency_p
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NESTED_NAME_SPECIFIER
argument_list|)
condition|)
block|{
name|cp_parser_pre_parsed_nested_name_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|parser
operator|->
name|scope
return|;
block|}
comment|/* Remember where the nested-name-specifier starts.  */
if|if
condition|(
name|cp_parser_parsing_tentatively
argument_list|(
name|parser
argument_list|)
operator|&&
operator|!
name|cp_parser_committed_to_tentative_parse
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|start
operator|=
name|cp_lexer_token_difference
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|parser
operator|->
name|lexer
operator|->
name|first_token
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
else|else
name|start
operator|=
operator|-
literal|1
expr_stmt|;
name|push_deferring_access_checks
argument_list|(
name|dk_deferred
argument_list|)
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|new_scope
decl_stmt|;
name|tree
name|old_scope
decl_stmt|;
name|tree
name|saved_qualifying_scope
decl_stmt|;
name|bool
name|template_keyword_p
decl_stmt|;
comment|/* Spot cases that cannot be the beginning of a 	 nested-name-specifier.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token is CPP_NESTED_NAME_SPECIFIER, just process 	 the already parsed nested-name-specifier.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NESTED_NAME_SPECIFIER
condition|)
block|{
comment|/* Grab the nested-name-specifier and continue the loop.  */
name|cp_parser_pre_parsed_nested_name_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|success
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
comment|/* Spot cases that cannot be the beginning of a 	 nested-name-specifier.  On the second and subsequent times 	 through the loop, we look for the `template' keyword.  */
if|if
condition|(
name|success
operator|&&
name|token
operator|->
name|keyword
operator|==
name|RID_TEMPLATE
condition|)
empty_stmt|;
comment|/* A template-id can start a nested-name-specifier.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_TEMPLATE_ID
condition|)
empty_stmt|;
else|else
block|{
comment|/* If the next token is not an identifier, then it is 	     definitely not a class-or-namespace-name.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NAME
condition|)
break|break;
comment|/* If the following token is neither a `<' (to begin a 	     template-id), nor a `::', then we are not looking at a 	     nested-name-specifier.  */
name|token
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_SCOPE
operator|&&
operator|!
name|cp_parser_nth_token_starts_template_argument_list_p
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
break|break;
block|}
comment|/* The nested-name-specifier is optional, so we parse 	 tentatively.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the optional `template' keyword, if this isn't the 	 first time through the loop.  */
if|if
condition|(
name|success
condition|)
name|template_keyword_p
operator|=
name|cp_parser_optional_template_keyword
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|template_keyword_p
operator|=
name|false
expr_stmt|;
comment|/* Save the old scope since the name lookup we are about to do 	 might destroy it.  */
name|old_scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|saved_qualifying_scope
operator|=
name|parser
operator|->
name|qualifying_scope
expr_stmt|;
comment|/* Parse the qualifying entity.  */
name|new_scope
operator|=
name|cp_parser_class_or_namespace_name
argument_list|(
name|parser
argument_list|,
name|typename_keyword_p
argument_list|,
name|template_keyword_p
argument_list|,
name|check_dependency_p
argument_list|,
name|type_p
argument_list|,
name|is_declaration
argument_list|)
expr_stmt|;
comment|/* Look for the `::' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SCOPE
argument_list|,
literal|"`::'"
argument_list|)
expr_stmt|;
comment|/* If we found what we wanted, we keep going; otherwise, we're 	 done.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|bool
name|error_p
init|=
name|false
decl_stmt|;
comment|/* Restore the OLD_SCOPE since it was valid before the 	     failed attempt at finding the last 	     class-or-namespace-name.  */
name|parser
operator|->
name|scope
operator|=
name|old_scope
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|saved_qualifying_scope
expr_stmt|;
comment|/* If the next token is an identifier, and the one after 	     that is a `::', then any valid interpretation would have 	     found a class-or-namespace-name.  */
while|while
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
operator|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|==
name|CPP_SCOPE
operator|)
operator|&&
operator|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|3
argument_list|)
operator|->
name|type
operator|!=
name|CPP_COMPL
operator|)
condition|)
block|{
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error_p
condition|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|cp_parser_lookup_name_simple
argument_list|(
name|parser
argument_list|,
name|token
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|error
argument_list|(
literal|"`%D' used without template parameters"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|cp_parser_name_lookup_error
argument_list|(
name|parser
argument_list|,
name|token
operator|->
name|value
argument_list|,
name|decl
argument_list|,
literal|"is not a class or namespace"
argument_list|)
expr_stmt|;
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|error_p
operator|=
name|true
expr_stmt|;
comment|/* Treat this as a successful nested-name-specifier 		     due to:  		     [basic.lookup.qual]  		     If the name found is not a class-name (clause 		     _class_) or namespace-name (_namespace.def_), the 		     program is ill-formed.  */
name|success
operator|=
name|true
expr_stmt|;
block|}
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* We've found one valid nested-name-specifier.  */
name|success
operator|=
name|true
expr_stmt|;
comment|/* Make sure we look in the right scope the next time through 	 the loop.  */
name|parser
operator|->
name|scope
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|new_scope
argument_list|)
operator|==
name|TYPE_DECL
condition|?
name|TREE_TYPE
argument_list|(
name|new_scope
argument_list|)
else|:
name|new_scope
operator|)
expr_stmt|;
comment|/* If it is a class scope, try to complete it; we are about to 	 be looking up names inside the class.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
comment|/* Since checking types for dependency can be expensive, 	     avoid doing it if the type is already complete.  */
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
comment|/* Do not try to complete dependent types.  */
operator|&&
operator|!
name|dependent_type_p
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
condition|)
name|complete_type
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
expr_stmt|;
block|}
comment|/* Retrieve any deferred checks.  Do not pop this access checks yet      so the memory will not be reclaimed during token replacing below.  */
name|access_check
operator|=
name|get_deferred_access_checks
argument_list|()
expr_stmt|;
comment|/* If parsing tentatively, replace the sequence of tokens that makes      up the nested-name-specifier with a CPP_NESTED_NAME_SPECIFIER      token.  That way, should we re-parse the token stream, we will      not have to repeat the effort required to do the parse, nor will      we issue duplicate error messages.  */
if|if
condition|(
name|success
operator|&&
name|start
operator|>=
literal|0
condition|)
block|{
comment|/* Find the token that corresponds to the start of the 	 template-id.  */
name|token
operator|=
name|cp_lexer_advance_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|parser
operator|->
name|lexer
operator|->
name|first_token
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* Reset the contents of the START token.  */
name|token
operator|->
name|type
operator|=
name|CPP_NESTED_NAME_SPECIFIER
expr_stmt|;
name|token
operator|->
name|value
operator|=
name|build_tree_list
argument_list|(
name|access_check
argument_list|,
name|parser
operator|->
name|scope
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|token
operator|->
name|value
argument_list|)
operator|=
name|parser
operator|->
name|qualifying_scope
expr_stmt|;
name|token
operator|->
name|keyword
operator|=
name|RID_MAX
expr_stmt|;
comment|/* Purge all subsequent tokens.  */
name|cp_lexer_purge_tokens_after
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|success
condition|?
name|parser
operator|->
name|scope
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Parse a nested-name-specifier.  See    cp_parser_nested_name_specifier_opt for details.  This function    behaves identically, except that it will an issue an error if no    nested-name-specifier is present, and it will return    ERROR_MARK_NODE, rather than NULL_TREE, if no nested-name-specifier    is present.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_nested_name_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|typename_keyword_p
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
name|type_p
parameter_list|,
name|bool
name|is_declaration
parameter_list|)
block|{
name|tree
name|scope
decl_stmt|;
comment|/* Look for the nested-name-specifier.  */
name|scope
operator|=
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
name|typename_keyword_p
argument_list|,
name|check_dependency_p
argument_list|,
name|type_p
argument_list|,
name|is_declaration
argument_list|)
expr_stmt|;
comment|/* If it was not present, issue an error message.  */
if|if
condition|(
operator|!
name|scope
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected nested-name-specifier"
argument_list|)
expr_stmt|;
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|scope
return|;
block|}
end_function

begin_comment
comment|/* Parse a class-or-namespace-name.     class-or-namespace-name:      class-name      namespace-name     TYPENAME_KEYWORD_P is TRUE iff the `typename' keyword is in effect.    TEMPLATE_KEYWORD_P is TRUE iff the `template' keyword is in effect.    CHECK_DEPENDENCY_P is FALSE iff dependent names should be looked up.    TYPE_P is TRUE iff the next name should be taken as a class-name,    even the same name is declared to be another entity in the same    scope.     Returns the class (TYPE_DECL) or namespace (NAMESPACE_DECL)    specified by the class-or-namespace-name.  If neither is found the    ERROR_MARK_NODE is returned.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_class_or_namespace_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|typename_keyword_p
parameter_list|,
name|bool
name|template_keyword_p
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
name|type_p
parameter_list|,
name|bool
name|is_declaration
parameter_list|)
block|{
name|tree
name|saved_scope
decl_stmt|;
name|tree
name|saved_qualifying_scope
decl_stmt|;
name|tree
name|saved_object_scope
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|bool
name|only_class_p
decl_stmt|;
comment|/* Before we try to parse the class-name, we must save away the      current PARSER->SCOPE since cp_parser_class_name will destroy      it.  */
name|saved_scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|saved_qualifying_scope
operator|=
name|parser
operator|->
name|qualifying_scope
expr_stmt|;
name|saved_object_scope
operator|=
name|parser
operator|->
name|object_scope
expr_stmt|;
comment|/* Try for a class-name first.  If the SAVED_SCOPE is a type, then      there is no need to look for a namespace-name.  */
name|only_class_p
operator|=
name|template_keyword_p
operator|||
operator|(
name|saved_scope
operator|&&
name|TYPE_P
argument_list|(
name|saved_scope
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|only_class_p
condition|)
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|scope
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
name|typename_keyword_p
argument_list|,
name|template_keyword_p
argument_list|,
name|type_p
argument_list|,
name|check_dependency_p
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
name|is_declaration
argument_list|)
expr_stmt|;
comment|/* If that didn't work, try for a namespace-name.  */
if|if
condition|(
operator|!
name|only_class_p
operator|&&
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* Restore the saved scope.  */
name|parser
operator|->
name|scope
operator|=
name|saved_scope
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|saved_qualifying_scope
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|saved_object_scope
expr_stmt|;
comment|/* If we are not looking at an identifier followed by the scope 	 resolution operator, then this is not part of a 	 nested-name-specifier.  (Note that this function is only used 	 to parse the components of a nested-name-specifier.)  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
operator|||
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|!=
name|CPP_SCOPE
condition|)
return|return
name|error_mark_node
return|;
name|scope
operator|=
name|cp_parser_namespace_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
return|return
name|scope
return|;
block|}
end_function

begin_comment
comment|/* Parse a postfix-expression.     postfix-expression:      primary-expression      postfix-expression [ expression ]      postfix-expression ( expression-list [opt] )      simple-type-specifier ( expression-list [opt] )      typename :: [opt] nested-name-specifier identifier         ( expression-list [opt] )      typename :: [opt] nested-name-specifier template [opt] template-id        ( expression-list [opt] )      postfix-expression . template [opt] id-expression      postfix-expression -> template [opt] id-expression      postfix-expression . pseudo-destructor-name      postfix-expression -> pseudo-destructor-name      postfix-expression ++      postfix-expression --      dynamic_cast< type-id> ( expression )      static_cast< type-id> ( expression )      reinterpret_cast< type-id> ( expression )      const_cast< type-id> ( expression )      typeid ( expression )      typeid ( type-id )     GNU Extension:          postfix-expression:      ( type-id ) { initializer-list , [opt] }     This extension is a GNU version of the C99 compound-literal    construct.  (The C99 grammar uses `type-name' instead of `type-id',    but they are essentially the same concept.)     If ADDRESS_P is true, the postfix expression is the operand of the    `&' operator.     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_postfix_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|address_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|rid
name|keyword
decl_stmt|;
name|cp_id_kind
name|idk
init|=
name|CP_ID_KIND_NONE
decl_stmt|;
name|tree
name|postfix_expression
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Non-NULL only if the current postfix-expression can be used to      form a pointer-to-member.  In that case, QUALIFYING_CLASS is the      class used to qualify the member.  */
name|tree
name|qualifying_class
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Some of the productions are determined by keywords.  */
name|keyword
operator|=
name|token
operator|->
name|keyword
expr_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_DYNCAST
case|:
case|case
name|RID_STATCAST
case|:
case|case
name|RID_REINTCAST
case|:
case|case
name|RID_CONSTCAST
case|:
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|expression
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
comment|/* All of these can be handled in the same way from the point 	   of view of parsing.  Begin by consuming the token 	   identifying the cast.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* New types cannot be defined in the cast.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in casts"
expr_stmt|;
comment|/* Look for the opening `<'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|,
literal|"`<'"
argument_list|)
expr_stmt|;
comment|/* Parse the type to which we are casting.  */
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the closing `>'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_GREATER
argument_list|,
literal|"`>'"
argument_list|)
expr_stmt|;
comment|/* Restore the old message.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
comment|/* And the expression which is being cast.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
name|expression
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Only type conversions to integral or enumeration types 	   can be used in constant-expressions.  */
if|if
condition|(
name|parser
operator|->
name|integral_constant_expression_p
operator|&&
operator|!
name|dependent_type_p
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|INTEGRAL_OR_ENUMERATION_TYPE_P
argument_list|(
name|type
argument_list|)
comment|/* A cast to pointer or reference type is allowed in the 	       implementation of "offsetof".  */
operator|&&
operator|!
operator|(
name|parser
operator|->
name|in_offsetof_p
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
operator|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"a cast to a type other than an integral or "
literal|"enumeration type"
argument_list|)
operator|)
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_DYNCAST
case|:
name|postfix_expression
operator|=
name|build_dynamic_cast
argument_list|(
name|type
argument_list|,
name|expression
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_STATCAST
case|:
name|postfix_expression
operator|=
name|build_static_cast
argument_list|(
name|type
argument_list|,
name|expression
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_REINTCAST
case|:
name|postfix_expression
operator|=
name|build_reinterpret_cast
argument_list|(
name|type
argument_list|,
name|expression
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_CONSTCAST
case|:
name|postfix_expression
operator|=
name|build_const_cast
argument_list|(
name|type
argument_list|,
name|expression
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RID_TYPEID
case|:
block|{
name|tree
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
name|bool
name|saved_in_type_id_in_expr_p
decl_stmt|;
comment|/* Consume the `typeid' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the `(' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Types cannot be defined in a `typeid' expression.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in a `typeid\' expression"
expr_stmt|;
comment|/* We can't be sure yet whether we're looking at a type-id or an 	   expression.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try a type-id first.  */
name|saved_in_type_id_in_expr_p
operator|=
name|parser
operator|->
name|in_type_id_in_expr_p
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|true
expr_stmt|;
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|saved_in_type_id_in_expr_p
expr_stmt|;
comment|/* Look for the `)' token.  Otherwise, we can't be sure that 	   we're not looking at an expression: consider `typeid (int 	   (3))', for example.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* If all went well, simply lookup the type-id.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|postfix_expression
operator|=
name|get_typeid
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Otherwise, fall back to the expression variant.  */
else|else
block|{
name|tree
name|expression
decl_stmt|;
comment|/* Look for an expression.  */
name|expression
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Compute its typeid.  */
name|postfix_expression
operator|=
name|build_typeid
argument_list|(
name|expression
argument_list|)
expr_stmt|;
comment|/* Look for the `)' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
block|}
comment|/* `typeid' may not appear in an integral constant expression.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"`typeid' operator"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Restore the saved message.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
block|}
break|break;
case|case
name|RID_TYPENAME
case|:
block|{
name|bool
name|template_p
init|=
name|false
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* Consume the `typename' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the optional `::' operator.  */
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the nested-name-specifier.  */
name|cp_parser_nested_name_specifier
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|true
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|true
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Look for the optional `template' keyword.  */
name|template_p
operator|=
name|cp_parser_optional_template_keyword
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* We don't know whether we're looking at a template-id or an 	   identifier.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try a template-id.  */
name|id
operator|=
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
name|template_p
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
comment|/* If that didn't work, try an identifier.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|id
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If we look up a template-id in a non-dependent qualifying 	   scope, there's no need to create a dependent type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
name|dependent_type_p
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* Create a TYPENAME_TYPE to represent the type to which the 	   functional cast is being performed.  */
else|else
name|type
operator|=
name|make_typename_type
argument_list|(
name|parser
operator|->
name|scope
argument_list|,
name|id
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
name|postfix_expression
operator|=
name|cp_parser_functional_cast
argument_list|(
name|parser
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|tree
name|type
decl_stmt|;
comment|/* If the next thing is a simple-type-specifier, we may be 	   looking at a functional cast.  We could also be looking at 	   an id-expression.  So, we try the functional cast, and if 	   that doesn't work we fall back to the primary-expression.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the simple-type-specifier.  */
name|type
operator|=
name|cp_parser_simple_type_specifier
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_FLAGS_NONE
argument_list|,
comment|/*identifier_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Parse the cast itself.  */
if|if
condition|(
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
name|postfix_expression
operator|=
name|cp_parser_functional_cast
argument_list|(
name|parser
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If that worked, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
break|break;
comment|/* If the functional-cast didn't work out, try a 	   compound-literal.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|tree
name|initializer_list
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|saved_in_type_id_in_expr_p
decl_stmt|;
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the type.  */
name|saved_in_type_id_in_expr_p
operator|=
name|parser
operator|->
name|in_type_id_in_expr_p
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|true
expr_stmt|;
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|saved_in_type_id_in_expr_p
expr_stmt|;
comment|/* Look for the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Look for the `{'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|,
literal|"`{'"
argument_list|)
expr_stmt|;
comment|/* If things aren't going well, there's no need to 	       keep going.  */
if|if
condition|(
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|bool
name|non_constant_p
decl_stmt|;
comment|/* Parse the initializer-list.  */
name|initializer_list
operator|=
name|cp_parser_initializer_list
argument_list|(
name|parser
argument_list|,
operator|&
name|non_constant_p
argument_list|)
expr_stmt|;
comment|/* Allow a trailing `,'.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the final `}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
block|}
comment|/* If that worked, we're definitely looking at a 	       compound-literal expression.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* Warn the user that a compound literal is not 		   allowed in standard C++.  */
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids compound-literals"
argument_list|)
expr_stmt|;
comment|/* Form the representation of the compound-literal.  */
name|postfix_expression
operator|=
name|finish_compound_literal
argument_list|(
name|type
argument_list|,
name|initializer_list
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* It must be a primary-expression.  */
name|postfix_expression
operator|=
name|cp_parser_primary_expression
argument_list|(
name|parser
argument_list|,
operator|&
name|idk
argument_list|,
operator|&
name|qualifying_class
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* If we were avoiding committing to the processing of a      qualified-id until we knew whether or not we had a      pointer-to-member, we now know.  */
if|if
condition|(
name|qualifying_class
condition|)
block|{
name|bool
name|done
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|done
operator|=
operator|(
name|token
operator|->
name|type
operator|!=
name|CPP_OPEN_SQUARE
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_OPEN_PAREN
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_DOT
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_DEREF
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_PLUS_PLUS
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_MINUS_MINUS
operator|)
expr_stmt|;
name|postfix_expression
operator|=
name|finish_qualified_id_expr
argument_list|(
name|qualifying_class
argument_list|,
name|postfix_expression
argument_list|,
name|done
argument_list|,
name|address_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
return|return
name|postfix_expression
return|;
block|}
comment|/* Keep looping until the postfix-expression is complete.  */
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
name|idk
operator|==
name|CP_ID_KIND_UNQUALIFIED
operator|&&
name|TREE_CODE
argument_list|(
name|postfix_expression
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
comment|/* It is not a Koenig lookup function call.  */
name|postfix_expression
operator|=
name|unqualified_name_lookup_error
argument_list|(
name|postfix_expression
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_OPEN_SQUARE
case|:
comment|/* postfix-expression [ expression ] */
block|{
name|tree
name|index
decl_stmt|;
comment|/* Consume the `[' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the index expression.  */
name|index
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the closing `]'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"`]'"
argument_list|)
expr_stmt|;
comment|/* Build the ARRAY_REF.  */
name|postfix_expression
operator|=
name|grok_array_decl
argument_list|(
name|postfix_expression
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
comment|/* Array references are not permitted in 	       constant-expressions (but they are allowed 	       in offsetof).  */
if|if
condition|(
operator|!
name|parser
operator|->
name|in_offsetof_p
operator|&&
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"an array reference"
argument_list|)
condition|)
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
block|}
break|break;
case|case
name|CPP_OPEN_PAREN
case|:
comment|/* postfix-expression ( expression-list [opt] ) */
block|{
name|bool
name|koenig_p
decl_stmt|;
name|tree
name|args
init|=
operator|(
name|cp_parser_parenthesized_expression_list
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
comment|/*non_constant_p=*/
name|NULL
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|error_mark_node
condition|)
block|{
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
comment|/* Function calls are not permitted in 	       constant-expressions.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"a function call"
argument_list|)
condition|)
block|{
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
name|koenig_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|idk
operator|==
name|CP_ID_KIND_UNQUALIFIED
condition|)
block|{
comment|/* We do not perform argument-dependent lookup if 		   normal lookup finds a non-function, in accordance 		   with the expected resolution of DR 218.  */
if|if
condition|(
name|args
operator|&&
operator|(
name|is_overloaded_fn
argument_list|(
name|postfix_expression
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|postfix_expression
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|)
block|{
name|koenig_p
operator|=
name|true
expr_stmt|;
name|postfix_expression
operator|=
name|perform_koenig_lookup
argument_list|(
name|postfix_expression
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|postfix_expression
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|postfix_expression
operator|=
name|unqualified_fn_lookup_error
argument_list|(
name|postfix_expression
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|postfix_expression
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|instance
init|=
name|TREE_OPERAND
argument_list|(
name|postfix_expression
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
name|TREE_OPERAND
argument_list|(
name|postfix_expression
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|processing_template_decl
operator|&&
operator|(
name|type_dependent_expression_p
argument_list|(
name|instance
argument_list|)
operator|||
operator|(
operator|!
name|BASELINK_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|FIELD_DECL
operator|)
operator|||
name|type_dependent_expression_p
argument_list|(
name|fn
argument_list|)
operator|||
name|any_type_dependent_arguments_p
argument_list|(
name|args
argument_list|)
operator|)
condition|)
block|{
name|postfix_expression
operator|=
name|build_min_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|postfix_expression
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|BASELINK_P
argument_list|(
name|fn
argument_list|)
condition|)
name|postfix_expression
operator|=
operator|(
name|build_new_method_call
argument_list|(
name|instance
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
operator|(
name|idk
operator|==
name|CP_ID_KIND_QUALIFIED
condition|?
name|LOOKUP_NONVIRTUAL
else|:
name|LOOKUP_NORMAL
operator|)
argument_list|)
operator|)
expr_stmt|;
else|else
name|postfix_expression
operator|=
name|finish_call_expr
argument_list|(
name|postfix_expression
argument_list|,
name|args
argument_list|,
comment|/*disallow_virtual=*/
name|false
argument_list|,
comment|/*koenig_p=*/
name|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|postfix_expression
argument_list|)
operator|==
name|OFFSET_REF
operator|||
name|TREE_CODE
argument_list|(
name|postfix_expression
argument_list|)
operator|==
name|MEMBER_REF
operator|||
name|TREE_CODE
argument_list|(
name|postfix_expression
argument_list|)
operator|==
name|DOTSTAR_EXPR
condition|)
name|postfix_expression
operator|=
operator|(
name|build_offset_ref_call_from_tree
argument_list|(
name|postfix_expression
argument_list|,
name|args
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|idk
operator|==
name|CP_ID_KIND_QUALIFIED
condition|)
comment|/* A call to a static class member, or a namespace-scope 		 function.  */
name|postfix_expression
operator|=
name|finish_call_expr
argument_list|(
name|postfix_expression
argument_list|,
name|args
argument_list|,
comment|/*disallow_virtual=*/
name|true
argument_list|,
name|koenig_p
argument_list|)
expr_stmt|;
else|else
comment|/* All other function calls.  */
name|postfix_expression
operator|=
name|finish_call_expr
argument_list|(
name|postfix_expression
argument_list|,
name|args
argument_list|,
comment|/*disallow_virtual=*/
name|false
argument_list|,
name|koenig_p
argument_list|)
expr_stmt|;
comment|/* The POSTFIX_EXPRESSION is certainly no longer an id.  */
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
block|}
break|break;
case|case
name|CPP_DOT
case|:
case|case
name|CPP_DEREF
case|:
comment|/* postfix-expression . template [opt] id-expression   	     postfix-expression . pseudo-destructor-name  	     postfix-expression -> template [opt] id-expression 	     postfix-expression -> pseudo-destructor-name */
block|{
name|tree
name|name
decl_stmt|;
name|bool
name|dependent_p
decl_stmt|;
name|bool
name|template_p
decl_stmt|;
name|tree
name|scope
init|=
name|NULL_TREE
decl_stmt|;
name|enum
name|cpp_ttype
name|token_type
init|=
name|token
operator|->
name|type
decl_stmt|;
comment|/* If this is a `->' operator, dereference the pointer.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_DEREF
condition|)
name|postfix_expression
operator|=
name|build_x_arrow
argument_list|(
name|postfix_expression
argument_list|)
expr_stmt|;
comment|/* Check to see whether or not the expression is 	       type-dependent.  */
name|dependent_p
operator|=
name|type_dependent_expression_p
argument_list|(
name|postfix_expression
argument_list|)
expr_stmt|;
comment|/* The identifier following the `->' or `.' is not 	       qualified.  */
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
comment|/* Enter the scope corresponding to the type of the object 	       given by the POSTFIX_EXPRESSION.  */
if|if
condition|(
operator|!
name|dependent_p
operator|&&
name|TREE_TYPE
argument_list|(
name|postfix_expression
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|scope
operator|=
name|TREE_TYPE
argument_list|(
name|postfix_expression
argument_list|)
expr_stmt|;
comment|/* According to the standard, no expression should 		   ever have reference type.  Unfortunately, we do not 		   currently match the standard in this respect in 		   that our internal representation of an expression 		   may have reference type even when the standard says 		   it does not.  Therefore, we have to manually obtain 		   the underlying type here.  */
name|scope
operator|=
name|non_reference
argument_list|(
name|scope
argument_list|)
expr_stmt|;
comment|/* The type of the POSTFIX_EXPRESSION must be 		   complete.  */
name|scope
operator|=
name|complete_type_or_else
argument_list|(
name|scope
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Let the name lookup machinery know that we are 		   processing a class member access expression.  */
name|parser
operator|->
name|context
operator|->
name|object_type
operator|=
name|scope
expr_stmt|;
comment|/* If something went wrong, we want to be able to 		   discern that case, as opposed to the case where 		   there was no SCOPE due to the type of expression 		   being dependent.  */
if|if
condition|(
operator|!
name|scope
condition|)
name|scope
operator|=
name|error_mark_node
expr_stmt|;
comment|/* If the SCOPE was erroneous, make the various 		   semantic analysis functions exit quickly -- and 		   without issuing additional error messages.  */
if|if
condition|(
name|scope
operator|==
name|error_mark_node
condition|)
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Consume the `.' or `->' operator.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the SCOPE is not a scalar type, we are looking at an 	       ordinary class member access expression, rather than a 	       pseudo-destructor-name.  */
if|if
condition|(
operator|!
name|scope
operator|||
operator|!
name|SCALAR_TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|template_p
operator|=
name|cp_parser_optional_template_keyword
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the id-expression.  */
name|name
operator|=
name|cp_parser_id_expression
argument_list|(
name|parser
argument_list|,
name|template_p
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*template_p=*/
name|NULL
argument_list|,
comment|/*declarator_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* In general, build a SCOPE_REF if the member name is 		   qualified.  However, if the name was not dependent 		   and has already been resolved; there is no need to 		   build the SCOPE_REF.  For example;                       struct X { void f(); };                      template<typename T> void f(T* t) { t->X::f(); }                      Even though "t" is dependent, "X::f" is not and has 		   been resolved to a BASELINK; there is no need to 		   include scope information.  */
comment|/* But we do need to remember that there was an explicit 		   scope for virtual function calls.  */
if|if
condition|(
name|parser
operator|->
name|scope
condition|)
name|idk
operator|=
name|CP_ID_KIND_QUALIFIED
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|error_mark_node
operator|&&
operator|!
name|BASELINK_P
argument_list|(
name|name
argument_list|)
operator|&&
name|parser
operator|->
name|scope
condition|)
block|{
name|name
operator|=
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|scope
operator|&&
name|name
operator|&&
name|BASELINK_P
argument_list|(
name|name
argument_list|)
condition|)
name|adjust_result_of_qualified_name_lookup
argument_list|(
name|name
argument_list|,
name|BINFO_TYPE
argument_list|(
name|BASELINK_BINFO
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|postfix_expression
operator|=
name|finish_class_member_access_expr
argument_list|(
name|postfix_expression
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, try the pseudo-destructor-name production.  */
else|else
block|{
name|tree
name|s
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* Parse the pseudo-destructor-name.  */
name|cp_parser_pseudo_destructor_name
argument_list|(
name|parser
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
comment|/* Form the call.  */
name|postfix_expression
operator|=
name|finish_pseudo_destructor_expr
argument_list|(
name|postfix_expression
argument_list|,
name|s
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We no longer need to look up names in the scope of the 	       object on the left-hand side of the `.' or `->' 	       operator.  */
name|parser
operator|->
name|context
operator|->
name|object_type
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* These operators may not appear in constant-expressions.  */
if|if
condition|(
comment|/* The "->" operator is allowed in the implementation 		   of "offsetof".  The "." operator may appear in the 		   name of the member.  */
operator|!
name|parser
operator|->
name|in_offsetof_p
operator|&&
operator|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
name|token_type
operator|==
name|CPP_DEREF
condition|?
literal|"'->'"
else|:
literal|"`.'"
argument_list|)
operator|)
condition|)
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
block|}
break|break;
case|case
name|CPP_PLUS_PLUS
case|:
comment|/* postfix-expression ++  */
comment|/* Consume the `++' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Generate a representation for the complete expression.  */
name|postfix_expression
operator|=
name|finish_increment_expr
argument_list|(
name|postfix_expression
argument_list|,
name|POSTINCREMENT_EXPR
argument_list|)
expr_stmt|;
comment|/* Increments may not appear in constant-expressions.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"an increment"
argument_list|)
condition|)
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
break|break;
case|case
name|CPP_MINUS_MINUS
case|:
comment|/* postfix-expression -- */
comment|/* Consume the `--' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Generate a representation for the complete expression.  */
name|postfix_expression
operator|=
name|finish_increment_expr
argument_list|(
name|postfix_expression
argument_list|,
name|POSTDECREMENT_EXPR
argument_list|)
expr_stmt|;
comment|/* Decrements may not appear in constant-expressions.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"a decrement"
argument_list|)
condition|)
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
break|break;
default|default:
return|return
name|postfix_expression
return|;
block|}
block|}
comment|/* We should never get here.  */
name|abort
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Parse a parenthesized expression-list.     expression-list:      assignment-expression      expression-list, assignment-expression     attribute-list:      expression-list      identifier      identifier, expression-list     Returns a TREE_LIST.  The TREE_VALUE of each node is a    representation of an assignment-expression.  Note that a TREE_LIST    is returned even if there is only a single expression in the list.    error_mark_node is returned if the ( and or ) are    missing. NULL_TREE is returned on no expressions. The parentheses    are eaten. IS_ATTRIBUTE_LIST is true if this is really an attribute    list being parsed.  If NON_CONSTANT_P is non-NULL, *NON_CONSTANT_P    indicates whether or not all of the expressions in the list were    constant.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_parenthesized_expression_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|is_attribute_list
parameter_list|,
name|bool
modifier|*
name|non_constant_p
parameter_list|)
block|{
name|tree
name|expression_list
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|identifier
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Assume all the expressions will be constant.  */
if|if
condition|(
name|non_constant_p
condition|)
operator|*
name|non_constant_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Consume expressions until there are no more.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|expr
decl_stmt|;
comment|/* At the beginning of attribute lists, check to see if the 	   next token is an identifier.  */
if|if
condition|(
name|is_attribute_list
operator|&&
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Consume the identifier.  */
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Save the identifier.  */
name|identifier
operator|=
name|token
operator|->
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* Parse the next assignment-expression.  */
if|if
condition|(
name|non_constant_p
condition|)
block|{
name|bool
name|expr_non_constant_p
decl_stmt|;
name|expr
operator|=
operator|(
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant_p=*/
name|true
argument_list|,
operator|&
name|expr_non_constant_p
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|expr_non_constant_p
condition|)
operator|*
name|non_constant_p
operator|=
name|true
expr_stmt|;
block|}
else|else
name|expr
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Add it to the list.  We add error_mark_node 		expressions to the list, so that we can still tell if 		the correct form for a parenthesized expression-list 		is found. That gives better errors.  */
name|expression_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|expression_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
goto|goto
name|skip_comma
goto|;
block|}
comment|/* After the first item, attribute lists look the same as 	   expression lists.  */
name|is_attribute_list
operator|=
name|false
expr_stmt|;
name|get_comma
label|:
empty_stmt|;
comment|/* If the next token isn't a `,', then we are done.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
comment|/* Otherwise, consume the `,' and keep going.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
block|{
name|int
name|ending
decl_stmt|;
name|skip_comma
label|:
empty_stmt|;
comment|/* We try and resync to an unnested comma, as that will give the 	 user better diagnostics.  */
name|ending
operator|=
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
comment|/*recovering=*/
name|true
argument_list|,
comment|/*or_comma=*/
name|true
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ending
operator|<
literal|0
condition|)
goto|goto
name|get_comma
goto|;
if|if
condition|(
operator|!
name|ending
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* We built up the list in reverse order so we must reverse it now.  */
name|expression_list
operator|=
name|nreverse
argument_list|(
name|expression_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier
condition|)
name|expression_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|identifier
argument_list|,
name|expression_list
argument_list|)
expr_stmt|;
return|return
name|expression_list
return|;
block|}
end_function

begin_comment
comment|/* Parse a pseudo-destructor-name.     pseudo-destructor-name:      :: [opt] nested-name-specifier [opt] type-name :: ~ type-name      :: [opt] nested-name-specifier template template-id :: ~ type-name      :: [opt] nested-name-specifier [opt] ~ type-name     If either of the first two productions is used, sets *SCOPE to the    TYPE specified before the final `::'.  Otherwise, *SCOPE is set to    NULL_TREE.  *TYPE is set to the TYPE_DECL for the final type-name,    or ERROR_MARK_NODE if the parse fails.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_pseudo_destructor_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
modifier|*
name|scope
parameter_list|,
name|tree
modifier|*
name|type
parameter_list|)
block|{
name|bool
name|nested_name_specifier_p
decl_stmt|;
comment|/* Look for the optional `::' operator.  */
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Look for the optional nested-name-specifier.  */
name|nested_name_specifier_p
operator|=
operator|(
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Now, if we saw a nested-name-specifier, we might be doing the      second production.  */
if|if
condition|(
name|nested_name_specifier_p
operator|&&
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TEMPLATE
argument_list|)
condition|)
block|{
comment|/* Consume the `template' keyword.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the template-id.  */
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|true
argument_list|,
comment|/*check_dependency_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Look for the `::' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SCOPE
argument_list|,
literal|"`::'"
argument_list|)
expr_stmt|;
block|}
comment|/* If the next token is not a `~', then there might be some      additional qualification.  */
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMPL
argument_list|)
condition|)
block|{
comment|/* Look for the type-name.  */
operator|*
name|scope
operator|=
name|TREE_TYPE
argument_list|(
name|cp_parser_type_name
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we didn't get an aggregate type, or we don't have ::~, 	 then something has gone wrong.  Since the only caller of this 	 function is looking for something after `.' or `->' after a 	 scalar type, most likely the program is trying to get a 	 member of a non-aggregate type.  */
if|if
condition|(
operator|*
name|scope
operator|==
name|error_mark_node
operator|||
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
operator|||
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|!=
name|CPP_COMPL
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"request for member of non-aggregate type"
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|error_mark_node
expr_stmt|;
return|return;
block|}
comment|/* Look for the `::' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SCOPE
argument_list|,
literal|"`::'"
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Look for the `~'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COMPL
argument_list|,
literal|"`~'"
argument_list|)
expr_stmt|;
comment|/* Look for the type-name again.  We are not responsible for      checking that it matches the first type-name.  */
operator|*
name|type
operator|=
name|cp_parser_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a unary-expression.     unary-expression:      postfix-expression      ++ cast-expression      -- cast-expression      unary-operator cast-expression      sizeof unary-expression      sizeof ( type-id )      new-expression      delete-expression     GNU Extensions:     unary-expression:      __extension__ cast-expression      __alignof__ unary-expression      __alignof__ ( type-id )      __real__ cast-expression      __imag__ cast-expression&& identifier     ADDRESS_P is true iff the unary-expression is appearing as the    operand of the `&' operator.     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_unary_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|address_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|tree_code
name|unary_operator
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Some keywords give away the kind of expression.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_KEYWORD
condition|)
block|{
name|enum
name|rid
name|keyword
init|=
name|token
operator|->
name|keyword
decl_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_ALIGNOF
case|:
case|case
name|RID_SIZEOF
case|:
block|{
name|tree
name|operand
decl_stmt|;
name|enum
name|tree_code
name|op
decl_stmt|;
name|op
operator|=
name|keyword
operator|==
name|RID_ALIGNOF
condition|?
name|ALIGNOF_EXPR
else|:
name|SIZEOF_EXPR
expr_stmt|;
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the operand.  */
name|operand
operator|=
name|cp_parser_sizeof_operand
argument_list|(
name|parser
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|operand
argument_list|)
condition|)
return|return
name|cxx_sizeof_or_alignof_type
argument_list|(
name|operand
argument_list|,
name|op
argument_list|,
name|true
argument_list|)
return|;
else|else
return|return
name|cxx_sizeof_or_alignof_expr
argument_list|(
name|operand
argument_list|,
name|op
argument_list|)
return|;
block|}
case|case
name|RID_NEW
case|:
return|return
name|cp_parser_new_expression
argument_list|(
name|parser
argument_list|)
return|;
case|case
name|RID_DELETE
case|:
return|return
name|cp_parser_delete_expression
argument_list|(
name|parser
argument_list|)
return|;
case|case
name|RID_EXTENSION
case|:
block|{
comment|/* The saved value of the PEDANTIC flag.  */
name|int
name|saved_pedantic
decl_stmt|;
name|tree
name|expr
decl_stmt|;
comment|/* Save away the PEDANTIC flag.  */
name|cp_parser_extension_opt
argument_list|(
name|parser
argument_list|,
operator|&
name|saved_pedantic
argument_list|)
expr_stmt|;
comment|/* Parse the cast-expression.  */
name|expr
operator|=
name|cp_parser_simple_cast_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Restore the PEDANTIC flag.  */
name|pedantic
operator|=
name|saved_pedantic
expr_stmt|;
return|return
name|expr
return|;
block|}
case|case
name|RID_REALPART
case|:
case|case
name|RID_IMAGPART
case|:
block|{
name|tree
name|expression
decl_stmt|;
comment|/* Consume the `__real__' or `__imag__' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the cast-expression.  */
name|expression
operator|=
name|cp_parser_simple_cast_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Create the complete representation.  */
return|return
name|build_x_unary_op
argument_list|(
operator|(
name|keyword
operator|==
name|RID_REALPART
condition|?
name|REALPART_EXPR
else|:
name|IMAGPART_EXPR
operator|)
argument_list|,
name|expression
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Look for the `:: new' and `:: delete', which also signal the      beginning of a new-expression, or delete-expression,      respectively.  If the next token is `::', then it might be one of      these.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
condition|)
block|{
name|enum
name|rid
name|keyword
decl_stmt|;
comment|/* See if the token after the `::' is one of the keywords in 	 which we're interested.  */
name|keyword
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|keyword
expr_stmt|;
comment|/* If it's `new', we have a new-expression.  */
if|if
condition|(
name|keyword
operator|==
name|RID_NEW
condition|)
return|return
name|cp_parser_new_expression
argument_list|(
name|parser
argument_list|)
return|;
comment|/* Similarly, for `delete'.  */
elseif|else
if|if
condition|(
name|keyword
operator|==
name|RID_DELETE
condition|)
return|return
name|cp_parser_delete_expression
argument_list|(
name|parser
argument_list|)
return|;
block|}
comment|/* Look for a unary operator.  */
name|unary_operator
operator|=
name|cp_parser_unary_operator
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|/* The `++' and `--' operators can be handled similarly, even though      they are not technically unary-operators in the grammar.  */
if|if
condition|(
name|unary_operator
operator|==
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PLUS_PLUS
condition|)
name|unary_operator
operator|=
name|PREINCREMENT_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_MINUS_MINUS
condition|)
name|unary_operator
operator|=
name|PREDECREMENT_EXPR
expr_stmt|;
comment|/* Handle the GNU address-of-label extension.  */
elseif|else
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|token
operator|->
name|type
operator|==
name|CPP_AND_AND
condition|)
block|{
name|tree
name|identifier
decl_stmt|;
comment|/* Consume the '&&' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the identifier.  */
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Create an expression representing the address.  */
return|return
name|finish_label_address_expr
argument_list|(
name|identifier
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|unary_operator
operator|!=
name|ERROR_MARK
condition|)
block|{
name|tree
name|cast_expression
decl_stmt|;
name|tree
name|expression
init|=
name|error_mark_node
decl_stmt|;
specifier|const
name|char
modifier|*
name|non_constant_p
init|=
name|NULL
decl_stmt|;
comment|/* Consume the operator token.  */
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the cast-expression.  */
name|cast_expression
operator|=
name|cp_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|unary_operator
operator|==
name|ADDR_EXPR
argument_list|)
expr_stmt|;
comment|/* Now, build an appropriate representation.  */
switch|switch
condition|(
name|unary_operator
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
name|non_constant_p
operator|=
literal|"`*'"
expr_stmt|;
name|expression
operator|=
name|build_x_indirect_ref
argument_list|(
name|cast_expression
argument_list|,
literal|"unary *"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
comment|/* The "&" operator is allowed in the implementation of 	     "offsetof".  */
if|if
condition|(
operator|!
name|parser
operator|->
name|in_offsetof_p
condition|)
name|non_constant_p
operator|=
literal|"`&'"
expr_stmt|;
comment|/* Fall through.  */
case|case
name|BIT_NOT_EXPR
case|:
name|expression
operator|=
name|build_x_unary_op
argument_list|(
name|unary_operator
argument_list|,
name|cast_expression
argument_list|)
expr_stmt|;
break|break;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
name|non_constant_p
operator|=
operator|(
name|unary_operator
operator|==
name|PREINCREMENT_EXPR
condition|?
literal|"`++'"
else|:
literal|"`--'"
operator|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|CONVERT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
name|expression
operator|=
name|finish_unary_op_expr
argument_list|(
name|unary_operator
argument_list|,
name|cast_expression
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|non_constant_p
operator|&&
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
name|non_constant_p
argument_list|)
condition|)
name|expression
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|expression
return|;
block|}
return|return
name|cp_parser_postfix_expression
argument_list|(
name|parser
argument_list|,
name|address_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns ERROR_MARK if TOKEN is not a unary-operator.  If TOKEN is a    unary-operator, the corresponding tree code is returned.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|cp_parser_unary_operator
parameter_list|(
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_MULT
case|:
return|return
name|INDIRECT_REF
return|;
case|case
name|CPP_AND
case|:
return|return
name|ADDR_EXPR
return|;
case|case
name|CPP_PLUS
case|:
return|return
name|CONVERT_EXPR
return|;
case|case
name|CPP_MINUS
case|:
return|return
name|NEGATE_EXPR
return|;
case|case
name|CPP_NOT
case|:
return|return
name|TRUTH_NOT_EXPR
return|;
case|case
name|CPP_COMPL
case|:
return|return
name|BIT_NOT_EXPR
return|;
default|default:
return|return
name|ERROR_MARK
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a new-expression.     new-expression:      :: [opt] new new-placement [opt] new-type-id new-initializer [opt]      :: [opt] new new-placement [opt] ( type-id ) new-initializer [opt]     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_new_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|bool
name|global_scope_p
decl_stmt|;
name|tree
name|placement
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|initializer
decl_stmt|;
comment|/* Look for the optional `::' operator.  */
name|global_scope_p
operator|=
operator|(
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Look for the `new' operator.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_NEW
argument_list|,
literal|"`new'"
argument_list|)
expr_stmt|;
comment|/* There's no easy way to tell a new-placement from the      `( type-id )' construct.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for a new-placement.  */
name|placement
operator|=
name|cp_parser_new_placement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If that didn't work out, there's no new-placement.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|placement
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If the next token is a `(', then we have a parenthesized      type-id.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the type-id.  */
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the closing `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* There should not be a direct-new-declarator in this production,           but GCC used to allowed this, so we check and emit a sensible error 	 message for this case.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"array bound forbidden after parenthesized type-id"
argument_list|)
expr_stmt|;
name|inform
argument_list|(
literal|"try removing the parentheses around the type-id"
argument_list|)
expr_stmt|;
name|cp_parser_direct_new_declarator
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Otherwise, there must be a new-type-id.  */
else|else
name|type
operator|=
name|cp_parser_new_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is a `(', then we have a new-initializer.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
name|initializer
operator|=
name|cp_parser_new_initializer
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|initializer
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* A new-expression may not appear in an integral constant      expression.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"`new'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Create a representation of the new-expression.  */
return|return
name|build_new
argument_list|(
name|placement
argument_list|,
name|type
argument_list|,
name|initializer
argument_list|,
name|global_scope_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a new-placement.     new-placement:      ( expression-list )     Returns the same representation as for an expression-list.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_new_placement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|expression_list
decl_stmt|;
comment|/* Parse the expression-list.  */
name|expression_list
operator|=
operator|(
name|cp_parser_parenthesized_expression_list
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
comment|/*non_constant_p=*/
name|NULL
argument_list|)
operator|)
expr_stmt|;
return|return
name|expression_list
return|;
block|}
end_function

begin_comment
comment|/* Parse a new-type-id.     new-type-id:      type-specifier-seq new-declarator [opt]     Returns a TREE_LIST whose TREE_PURPOSE is the type-specifier-seq,    and whose TREE_VALUE is the new-declarator.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_new_type_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|type_specifier_seq
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
comment|/* The type-specifier sequence must not contain type definitions.      (It cannot contain declarations of new types either, but if they      are not definitions we will catch that because they are not      complete.)  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in a new-type-id"
expr_stmt|;
comment|/* Parse the type-specifier-seq.  */
name|type_specifier_seq
operator|=
name|cp_parser_type_specifier_seq
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Restore the old message.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
comment|/* Parse the new-declarator.  */
name|declarator
operator|=
name|cp_parser_new_declarator_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|build_tree_list
argument_list|(
name|type_specifier_seq
argument_list|,
name|declarator
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) new-declarator.     new-declarator:      ptr-operator new-declarator [opt]      direct-new-declarator     Returns a representation of the declarator.  See    cp_parser_declarator for the representations used.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_new_declarator_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|cv_qualifier_seq
decl_stmt|;
comment|/* We don't know if there's a ptr-operator next, or not.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for a ptr-operator.  */
name|code
operator|=
name|cp_parser_ptr_operator
argument_list|(
name|parser
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|cv_qualifier_seq
argument_list|)
expr_stmt|;
comment|/* If that worked, look for more new-declarators.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|tree
name|declarator
decl_stmt|;
comment|/* Parse another optional declarator.  */
name|declarator
operator|=
name|cp_parser_new_declarator_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Create the representation of the declarator.  */
if|if
condition|(
name|code
operator|==
name|INDIRECT_REF
condition|)
name|declarator
operator|=
name|make_pointer_declarator
argument_list|(
name|cv_qualifier_seq
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
else|else
name|declarator
operator|=
name|make_reference_declarator
argument_list|(
name|cv_qualifier_seq
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
comment|/* Handle the pointer-to-member case.  */
if|if
condition|(
name|type
condition|)
name|declarator
operator|=
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|type
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|declarator
return|;
block|}
comment|/* If the next token is a `[', there is a direct-new-declarator.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|)
condition|)
return|return
name|cp_parser_direct_new_declarator
argument_list|(
name|parser
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Parse a direct-new-declarator.     direct-new-declarator:      [ expression ]      direct-new-declarator [constant-expression]       Returns an ARRAY_REF, following the same conventions as are    documented for cp_parser_direct_declarator.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_direct_new_declarator
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|declarator
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|expression
decl_stmt|;
comment|/* Look for the opening `['.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|,
literal|"`['"
argument_list|)
expr_stmt|;
comment|/* The first expression is not required to be constant.  */
if|if
condition|(
operator|!
name|declarator
condition|)
block|{
name|expression
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* The standard requires that the expression have integral 	     type.  DR 74 adds enumeration types.  We believe that the 	     real intent is that these expressions be handled like the 	     expression in a `switch' condition, which also allows 	     classes with a single conversion to integral or 	     enumeration type.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|expression
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_INT
operator||
name|WANT_ENUM
argument_list|,
name|expression
argument_list|,
comment|/*complain=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression
condition|)
block|{
name|error
argument_list|(
literal|"expression in new-declarator must have integral or enumeration type"
argument_list|)
expr_stmt|;
name|expression
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
block|}
comment|/* But all the other expressions must be.  */
else|else
name|expression
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant=*/
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Look for the closing `]'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"`]'"
argument_list|)
expr_stmt|;
comment|/* Add this bound to the declarator.  */
name|declarator
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|declarator
argument_list|,
name|expression
argument_list|)
expr_stmt|;
comment|/* If the next token is not a `[', then there are no more 	 bounds.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|)
condition|)
break|break;
block|}
return|return
name|declarator
return|;
block|}
end_function

begin_comment
comment|/* Parse a new-initializer.     new-initializer:      ( expression-list [opt] )     Returns a representation of the expression-list.  If there is no    expression-list, VOID_ZERO_NODE is returned.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_new_initializer
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|expression_list
decl_stmt|;
name|expression_list
operator|=
operator|(
name|cp_parser_parenthesized_expression_list
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
comment|/*non_constant_p=*/
name|NULL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_list
condition|)
name|expression_list
operator|=
name|void_zero_node
expr_stmt|;
return|return
name|expression_list
return|;
block|}
end_function

begin_comment
comment|/* Parse a delete-expression.     delete-expression:      :: [opt] delete cast-expression      :: [opt] delete [ ] cast-expression     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_delete_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|bool
name|global_scope_p
decl_stmt|;
name|bool
name|array_p
decl_stmt|;
name|tree
name|expression
decl_stmt|;
comment|/* Look for the optional `::' operator.  */
name|global_scope_p
operator|=
operator|(
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Look for the `delete' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_DELETE
argument_list|,
literal|"`delete'"
argument_list|)
expr_stmt|;
comment|/* See if the array syntax is in use.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|)
condition|)
block|{
comment|/* Consume the `[' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the `]' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"`]'"
argument_list|)
expr_stmt|;
comment|/* Remember that this is the `[]' construct.  */
name|array_p
operator|=
name|true
expr_stmt|;
block|}
else|else
name|array_p
operator|=
name|false
expr_stmt|;
comment|/* Parse the cast-expression.  */
name|expression
operator|=
name|cp_parser_simple_cast_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* A delete-expression may not appear in an integral constant      expression.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"`delete'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
return|return
name|delete_sanity
argument_list|(
name|expression
argument_list|,
name|NULL_TREE
argument_list|,
name|array_p
argument_list|,
name|global_scope_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a cast-expression.     cast-expression:      unary-expression      ( type-id ) cast-expression     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_cast_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|address_p
parameter_list|)
block|{
comment|/* If it's a `(', then we might be looking at a cast.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|expr
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|compound_literal_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
comment|/* There's no way to know yet whether or not this is a cast. 	 For example, `(int (3))' is a unary-expression, while `(int) 	 3' is a cast.  So, we resort to parsing tentatively.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Types may not be defined in a cast.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in casts"
expr_stmt|;
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* A very tricky bit is that `(struct S) { 3 }' is a 	 compound-literal (which we permit in C++ as an extension). 	 But, that construct is not a cast-expression -- it is a 	 postfix-expression.  (The reason is that `(struct S) { 3 }.i' 	 is legal; if the compound-literal were a cast-expression, 	 you'd need an extra set of parentheses.)  But, if we parse 	 the type-id, and it happens to be a class-specifier, then we 	 will commit to the parse at that point, because we cannot 	 undo the action that is done when creating a new class.  So, 	 then we cannot back up and do a postfix-expression.    	 Therefore, we scan ahead to the closing `)', and check to see 	 if the token after the `)' is a `{'.  If so, we are not 	 looking at a cast-expression.    	 Save tokens so that we can put them back.  */
name|cp_lexer_save_tokens
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Skip tokens until the next token is a closing parenthesis. 	 If we find the closing `)', and the next token is a `{', then 	 we are looking at a compound-literal.  */
name|compound_literal_p
operator|=
operator|(
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
operator|)
expr_stmt|;
comment|/* Roll back the tokens we skipped.  */
name|cp_lexer_rollback_tokens
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If we were looking at a compound-literal, simulate an error 	 so that the call to cp_parser_parse_definitely below will 	 fail.  */
if|if
condition|(
name|compound_literal_p
condition|)
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
block|{
name|bool
name|saved_in_type_id_in_expr_p
init|=
name|parser
operator|->
name|in_type_id_in_expr_p
decl_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|true
expr_stmt|;
comment|/* Look for the type-id.  */
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the closing `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|saved_in_type_id_in_expr_p
expr_stmt|;
block|}
comment|/* Restore the saved message.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
comment|/* If ok so far, parse the dependent expression. We cannot be          sure it is a cast. Consider `(T ())'.  It is a parenthesized          ctor of T, but looks like a cast to function returning T          without a dependent expression.  */
if|if
condition|(
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
name|expr
operator|=
name|cp_parser_simple_cast_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* Warn about old-style casts, if so requested.  */
if|if
condition|(
name|warn_old_style_cast
operator|&&
operator|!
name|in_system_header
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|current_lang_name
operator|!=
name|lang_name_c
condition|)
name|warning
argument_list|(
literal|"use of old-style cast"
argument_list|)
expr_stmt|;
comment|/* Only type conversions to integral or enumeration types 	     can be used in constant-expressions.  */
if|if
condition|(
name|parser
operator|->
name|integral_constant_expression_p
operator|&&
operator|!
name|dependent_type_p
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|INTEGRAL_OR_ENUMERATION_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"a casts to a type other than an integral or "
literal|"enumeration type"
argument_list|)
operator|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Perform the cast.  */
name|expr
operator|=
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
block|}
comment|/* If we get here, then it's not a cast, so it must be a      unary-expression.  */
return|return
name|cp_parser_unary_expression
argument_list|(
name|parser
argument_list|,
name|address_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a pm-expression.     pm-expression:      cast-expression      pm-expression .* cast-expression      pm-expression ->* cast-expression       Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_pm_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
specifier|static
specifier|const
name|cp_parser_token_tree_map
name|map
init|=
block|{
block|{
name|CPP_DEREF_STAR
block|,
name|MEMBER_REF
block|}
block|,
block|{
name|CPP_DOT_STAR
block|,
name|DOTSTAR_EXPR
block|}
block|,
block|{
name|CPP_EOF
block|,
name|ERROR_MARK
block|}
block|}
decl_stmt|;
return|return
name|cp_parser_binary_expression
argument_list|(
name|parser
argument_list|,
name|map
argument_list|,
name|cp_parser_simple_cast_expression
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a multiplicative-expression.     mulitplicative-expression:      pm-expression      multiplicative-expression * pm-expression      multiplicative-expression / pm-expression      multiplicative-expression % pm-expression     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_multiplicative_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
specifier|static
specifier|const
name|cp_parser_token_tree_map
name|map
init|=
block|{
block|{
name|CPP_MULT
block|,
name|MULT_EXPR
block|}
block|,
block|{
name|CPP_DIV
block|,
name|TRUNC_DIV_EXPR
block|}
block|,
block|{
name|CPP_MOD
block|,
name|TRUNC_MOD_EXPR
block|}
block|,
block|{
name|CPP_EOF
block|,
name|ERROR_MARK
block|}
block|}
decl_stmt|;
return|return
name|cp_parser_binary_expression
argument_list|(
name|parser
argument_list|,
name|map
argument_list|,
name|cp_parser_pm_expression
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an additive-expression.     additive-expression:      multiplicative-expression      additive-expression + multiplicative-expression      additive-expression - multiplicative-expression     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_additive_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
specifier|static
specifier|const
name|cp_parser_token_tree_map
name|map
init|=
block|{
block|{
name|CPP_PLUS
block|,
name|PLUS_EXPR
block|}
block|,
block|{
name|CPP_MINUS
block|,
name|MINUS_EXPR
block|}
block|,
block|{
name|CPP_EOF
block|,
name|ERROR_MARK
block|}
block|}
decl_stmt|;
return|return
name|cp_parser_binary_expression
argument_list|(
name|parser
argument_list|,
name|map
argument_list|,
name|cp_parser_multiplicative_expression
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a shift-expression.     shift-expression:      additive-expression      shift-expression<< additive-expression      shift-expression>> additive-expression     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_shift_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
specifier|static
specifier|const
name|cp_parser_token_tree_map
name|map
init|=
block|{
block|{
name|CPP_LSHIFT
block|,
name|LSHIFT_EXPR
block|}
block|,
block|{
name|CPP_RSHIFT
block|,
name|RSHIFT_EXPR
block|}
block|,
block|{
name|CPP_EOF
block|,
name|ERROR_MARK
block|}
block|}
decl_stmt|;
return|return
name|cp_parser_binary_expression
argument_list|(
name|parser
argument_list|,
name|map
argument_list|,
name|cp_parser_additive_expression
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a relational-expression.     relational-expression:      shift-expression      relational-expression< shift-expression      relational-expression> shift-expression      relational-expression<= shift-expression      relational-expression>= shift-expression     GNU Extension:     relational-expression:      relational-expression<? shift-expression      relational-expression>? shift-expression     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_relational_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
specifier|static
specifier|const
name|cp_parser_token_tree_map
name|map
init|=
block|{
block|{
name|CPP_LESS
block|,
name|LT_EXPR
block|}
block|,
block|{
name|CPP_GREATER
block|,
name|GT_EXPR
block|}
block|,
block|{
name|CPP_LESS_EQ
block|,
name|LE_EXPR
block|}
block|,
block|{
name|CPP_GREATER_EQ
block|,
name|GE_EXPR
block|}
block|,
block|{
name|CPP_MIN
block|,
name|MIN_EXPR
block|}
block|,
block|{
name|CPP_MAX
block|,
name|MAX_EXPR
block|}
block|,
block|{
name|CPP_EOF
block|,
name|ERROR_MARK
block|}
block|}
decl_stmt|;
return|return
name|cp_parser_binary_expression
argument_list|(
name|parser
argument_list|,
name|map
argument_list|,
name|cp_parser_shift_expression
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an equality-expression.     equality-expression:      relational-expression      equality-expression == relational-expression      equality-expression != relational-expression     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_equality_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
specifier|static
specifier|const
name|cp_parser_token_tree_map
name|map
init|=
block|{
block|{
name|CPP_EQ_EQ
block|,
name|EQ_EXPR
block|}
block|,
block|{
name|CPP_NOT_EQ
block|,
name|NE_EXPR
block|}
block|,
block|{
name|CPP_EOF
block|,
name|ERROR_MARK
block|}
block|}
decl_stmt|;
return|return
name|cp_parser_binary_expression
argument_list|(
name|parser
argument_list|,
name|map
argument_list|,
name|cp_parser_relational_expression
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an and-expression.     and-expression:      equality-expression      and-expression& equality-expression     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_and_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
specifier|static
specifier|const
name|cp_parser_token_tree_map
name|map
init|=
block|{
block|{
name|CPP_AND
block|,
name|BIT_AND_EXPR
block|}
block|,
block|{
name|CPP_EOF
block|,
name|ERROR_MARK
block|}
block|}
decl_stmt|;
return|return
name|cp_parser_binary_expression
argument_list|(
name|parser
argument_list|,
name|map
argument_list|,
name|cp_parser_equality_expression
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an exclusive-or-expression.     exclusive-or-expression:      and-expression      exclusive-or-expression ^ and-expression     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_exclusive_or_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
specifier|static
specifier|const
name|cp_parser_token_tree_map
name|map
init|=
block|{
block|{
name|CPP_XOR
block|,
name|BIT_XOR_EXPR
block|}
block|,
block|{
name|CPP_EOF
block|,
name|ERROR_MARK
block|}
block|}
decl_stmt|;
return|return
name|cp_parser_binary_expression
argument_list|(
name|parser
argument_list|,
name|map
argument_list|,
name|cp_parser_and_expression
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an inclusive-or-expression.     inclusive-or-expression:      exclusive-or-expression      inclusive-or-expression | exclusive-or-expression     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_inclusive_or_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
specifier|static
specifier|const
name|cp_parser_token_tree_map
name|map
init|=
block|{
block|{
name|CPP_OR
block|,
name|BIT_IOR_EXPR
block|}
block|,
block|{
name|CPP_EOF
block|,
name|ERROR_MARK
block|}
block|}
decl_stmt|;
return|return
name|cp_parser_binary_expression
argument_list|(
name|parser
argument_list|,
name|map
argument_list|,
name|cp_parser_exclusive_or_expression
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a logical-and-expression.     logical-and-expression:      inclusive-or-expression      logical-and-expression&& inclusive-or-expression     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_logical_and_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
specifier|static
specifier|const
name|cp_parser_token_tree_map
name|map
init|=
block|{
block|{
name|CPP_AND_AND
block|,
name|TRUTH_ANDIF_EXPR
block|}
block|,
block|{
name|CPP_EOF
block|,
name|ERROR_MARK
block|}
block|}
decl_stmt|;
return|return
name|cp_parser_binary_expression
argument_list|(
name|parser
argument_list|,
name|map
argument_list|,
name|cp_parser_inclusive_or_expression
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a logical-or-expression.     logical-or-expression:      logical-and-expression      logical-or-expression || logical-and-expression     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_logical_or_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
specifier|static
specifier|const
name|cp_parser_token_tree_map
name|map
init|=
block|{
block|{
name|CPP_OR_OR
block|,
name|TRUTH_ORIF_EXPR
block|}
block|,
block|{
name|CPP_EOF
block|,
name|ERROR_MARK
block|}
block|}
decl_stmt|;
return|return
name|cp_parser_binary_expression
argument_list|(
name|parser
argument_list|,
name|map
argument_list|,
name|cp_parser_logical_and_expression
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse the `? expression : assignment-expression' part of a    conditional-expression.  The LOGICAL_OR_EXPR is the    logical-or-expression that started the conditional-expression.    Returns a representation of the entire conditional-expression.     This routine is used by cp_parser_assignment_expression.       ? expression : assignment-expression        GNU Extensions:          ? : assignment-expression */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_question_colon_clause
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|logical_or_expr
parameter_list|)
block|{
name|tree
name|expr
decl_stmt|;
name|tree
name|assignment_expr
decl_stmt|;
comment|/* Consume the `?' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
comment|/* Implicit true clause.  */
name|expr
operator|=
name|NULL_TREE
expr_stmt|;
else|else
comment|/* Parse the expression.  */
name|expr
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* The next token should be a `:'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"`:'"
argument_list|)
expr_stmt|;
comment|/* Parse the assignment-expression.  */
name|assignment_expr
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Build the conditional-expression.  */
return|return
name|build_x_conditional_expr
argument_list|(
name|logical_or_expr
argument_list|,
name|expr
argument_list|,
name|assignment_expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an assignment-expression.     assignment-expression:      conditional-expression      logical-or-expression assignment-operator assignment_expression      throw-expression     Returns a representation for the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_assignment_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|expr
decl_stmt|;
comment|/* If the next token is the `throw' keyword, then we're looking at      a throw-expression.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_THROW
argument_list|)
condition|)
name|expr
operator|=
name|cp_parser_throw_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Otherwise, it must be that we are looking at a      logical-or-expression.  */
else|else
block|{
comment|/* Parse the logical-or-expression.  */
name|expr
operator|=
name|cp_parser_logical_or_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is a `?' then we're actually looking at a 	 conditional-expression.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_QUERY
argument_list|)
condition|)
return|return
name|cp_parser_question_colon_clause
argument_list|(
name|parser
argument_list|,
name|expr
argument_list|)
return|;
else|else
block|{
name|enum
name|tree_code
name|assignment_operator
decl_stmt|;
comment|/* If it's an assignment-operator, we're using the second 	     production.  */
name|assignment_operator
operator|=
name|cp_parser_assignment_operator_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|assignment_operator
operator|!=
name|ERROR_MARK
condition|)
block|{
name|tree
name|rhs
decl_stmt|;
comment|/* Parse the right-hand side of the assignment.  */
name|rhs
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* An assignment may not appear in a 		 constant-expression.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"an assignment"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Build the assignment expression.  */
name|expr
operator|=
name|build_x_modify_expr
argument_list|(
name|expr
argument_list|,
name|assignment_operator
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) assignment-operator.     assignment-operator: one of       = *= /= %= += -=>>=<<=&= ^= |=       GNU Extension:        assignment-operator: one of<?=>?=     If the next token is an assignment operator, the corresponding tree    code is returned, and the token is consumed.  For example, for    `+=', PLUS_EXPR is returned.  For `=' itself, the code returned is    NOP_EXPR.  For `/', TRUNC_DIV_EXPR is returned; for `%',    TRUNC_MOD_EXPR is returned.  If TOKEN is not an assignment    operator, ERROR_MARK is returned.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|cp_parser_assignment_operator_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|enum
name|tree_code
name|op
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next toen.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_EQ
case|:
name|op
operator|=
name|NOP_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MULT_EQ
case|:
name|op
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_DIV_EQ
case|:
name|op
operator|=
name|TRUNC_DIV_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MOD_EQ
case|:
name|op
operator|=
name|TRUNC_MOD_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_PLUS_EQ
case|:
name|op
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MINUS_EQ
case|:
name|op
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_RSHIFT_EQ
case|:
name|op
operator|=
name|RSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_LSHIFT_EQ
case|:
name|op
operator|=
name|LSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_AND_EQ
case|:
name|op
operator|=
name|BIT_AND_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_XOR_EQ
case|:
name|op
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_OR_EQ
case|:
name|op
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MIN_EQ
case|:
name|op
operator|=
name|MIN_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MAX_EQ
case|:
name|op
operator|=
name|MAX_EXPR
expr_stmt|;
break|break;
default|default:
comment|/* Nothing else is an assignment operator.  */
name|op
operator|=
name|ERROR_MARK
expr_stmt|;
block|}
comment|/* If it was an assignment operator, consume it.  */
if|if
condition|(
name|op
operator|!=
name|ERROR_MARK
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Parse an expression.     expression:      assignment-expression      expression , assignment-expression     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|expression
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|assignment_expression
decl_stmt|;
comment|/* Parse the next assignment-expression.  */
name|assignment_expression
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If this is the first assignment-expression, we can just 	 save it away.  */
if|if
condition|(
operator|!
name|expression
condition|)
name|expression
operator|=
name|assignment_expression
expr_stmt|;
else|else
name|expression
operator|=
name|build_x_compound_expr
argument_list|(
name|expression
argument_list|,
name|assignment_expression
argument_list|)
expr_stmt|;
comment|/* If the next token is not a comma, then we are done with the 	 expression.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
comment|/* Consume the `,'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* A comma operator cannot appear in a constant-expression.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"a comma operator"
argument_list|)
condition|)
name|expression
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|expression
return|;
block|}
end_function

begin_comment
comment|/* Parse a constant-expression.      constant-expression:      conditional-expression      If ALLOW_NON_CONSTANT_P a non-constant expression is silently   accepted.  If ALLOW_NON_CONSTANT_P is true and the expression is not   constant, *NON_CONSTANT_P is set to TRUE.  If ALLOW_NON_CONSTANT_P   is false, NON_CONSTANT_P should be NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_constant_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|allow_non_constant_p
parameter_list|,
name|bool
modifier|*
name|non_constant_p
parameter_list|)
block|{
name|bool
name|saved_integral_constant_expression_p
decl_stmt|;
name|bool
name|saved_allow_non_integral_constant_expression_p
decl_stmt|;
name|bool
name|saved_non_integral_constant_expression_p
decl_stmt|;
name|tree
name|expression
decl_stmt|;
comment|/* It might seem that we could simply parse the      conditional-expression, and then check to see if it were      TREE_CONSTANT.  However, an expression that is TREE_CONSTANT is      one that the compiler can figure out is constant, possibly after      doing some simplifications or optimizations.  The standard has a      precise definition of constant-expression, and we must honor      that, even though it is somewhat more restrictive.       For example:         int i[(2, 3)];       is not a legal declaration, because `(2, 3)' is not a      constant-expression.  The `,' operator is forbidden in a      constant-expression.  However, GCC's constant-folding machinery      will fold this operation to an INTEGER_CST for `3'.  */
comment|/* Save the old settings.  */
name|saved_integral_constant_expression_p
operator|=
name|parser
operator|->
name|integral_constant_expression_p
expr_stmt|;
name|saved_allow_non_integral_constant_expression_p
operator|=
name|parser
operator|->
name|allow_non_integral_constant_expression_p
expr_stmt|;
name|saved_non_integral_constant_expression_p
operator|=
name|parser
operator|->
name|non_integral_constant_expression_p
expr_stmt|;
comment|/* We are now parsing a constant-expression.  */
name|parser
operator|->
name|integral_constant_expression_p
operator|=
name|true
expr_stmt|;
name|parser
operator|->
name|allow_non_integral_constant_expression_p
operator|=
name|allow_non_constant_p
expr_stmt|;
name|parser
operator|->
name|non_integral_constant_expression_p
operator|=
name|false
expr_stmt|;
comment|/* Although the grammar says "conditional-expression", we parse an      "assignment-expression", which also permits "throw-expression"      and the use of assignment operators.  In the case that      ALLOW_NON_CONSTANT_P is false, we get better errors than we would      otherwise.  In the case that ALLOW_NON_CONSTANT_P is true, it is      actually essential that we look for an assignment-expression.      For example, cp_parser_initializer_clauses uses this function to      determine whether a particular assignment-expression is in fact      constant.  */
name|expression
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Restore the old settings.  */
name|parser
operator|->
name|integral_constant_expression_p
operator|=
name|saved_integral_constant_expression_p
expr_stmt|;
name|parser
operator|->
name|allow_non_integral_constant_expression_p
operator|=
name|saved_allow_non_integral_constant_expression_p
expr_stmt|;
if|if
condition|(
name|allow_non_constant_p
condition|)
operator|*
name|non_constant_p
operator|=
name|parser
operator|->
name|non_integral_constant_expression_p
expr_stmt|;
name|parser
operator|->
name|non_integral_constant_expression_p
operator|=
name|saved_non_integral_constant_expression_p
expr_stmt|;
return|return
name|expression
return|;
block|}
end_function

begin_comment
comment|/* Statements [gram.stmt.stmt]  */
end_comment

begin_comment
comment|/* Parse a statement.       statement:      labeled-statement      expression-statement      compound-statement      selection-statement      iteration-statement      jump-statement      declaration-statement      try-block  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|in_statement_expr_p
parameter_list|)
block|{
name|tree
name|statement
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|int
name|statement_line_number
decl_stmt|;
comment|/* There is no statement yet.  */
name|statement
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Remember the line number of the first token in the statement.  */
name|statement_line_number
operator|=
name|token
operator|->
name|location
operator|.
name|line
expr_stmt|;
comment|/* If this is a keyword, then that will often determine what kind of      statement we have.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_KEYWORD
condition|)
block|{
name|enum
name|rid
name|keyword
init|=
name|token
operator|->
name|keyword
decl_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_CASE
case|:
case|case
name|RID_DEFAULT
case|:
name|statement
operator|=
name|cp_parser_labeled_statement
argument_list|(
name|parser
argument_list|,
name|in_statement_expr_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_IF
case|:
case|case
name|RID_SWITCH
case|:
name|statement
operator|=
name|cp_parser_selection_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_WHILE
case|:
case|case
name|RID_DO
case|:
case|case
name|RID_FOR
case|:
name|statement
operator|=
name|cp_parser_iteration_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_BREAK
case|:
case|case
name|RID_CONTINUE
case|:
case|case
name|RID_RETURN
case|:
case|case
name|RID_GOTO
case|:
name|statement
operator|=
name|cp_parser_jump_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_TRY
case|:
name|statement
operator|=
name|cp_parser_try_block
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* It might be a keyword like `int' that can start a 	     declaration-statement.  */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
block|{
comment|/* If the next token is a `:', then we are looking at a 	 labeled-statement.  */
name|token
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COLON
condition|)
name|statement
operator|=
name|cp_parser_labeled_statement
argument_list|(
name|parser
argument_list|,
name|in_statement_expr_p
argument_list|)
expr_stmt|;
block|}
comment|/* Anything that starts with a `{' must be a compound-statement.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
condition|)
name|statement
operator|=
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Everything else must be a declaration-statement or an      expression-statement.  Try for the declaration-statement       first, unless we are looking at a `;', in which case we know that      we have an expression-statement.  */
if|if
condition|(
operator|!
name|statement
condition|)
block|{
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try to parse the declaration-statement.  */
name|cp_parser_declaration_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If that worked, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return;
block|}
comment|/* Look for an expression-statement instead.  */
name|statement
operator|=
name|cp_parser_expression_statement
argument_list|(
name|parser
argument_list|,
name|in_statement_expr_p
argument_list|)
expr_stmt|;
block|}
comment|/* Set the line number for the statement.  */
if|if
condition|(
name|statement
operator|&&
name|STATEMENT_CODE_P
argument_list|(
name|TREE_CODE
argument_list|(
name|statement
argument_list|)
argument_list|)
condition|)
name|STMT_LINENO
argument_list|(
name|statement
argument_list|)
operator|=
name|statement_line_number
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a labeled-statement.     labeled-statement:      identifier : statement      case constant-expression : statement      default : statement     GNU Extension:        labeled-statement:      case constant-expression ... constant-expression : statement     Returns the new CASE_LABEL, for a `case' or `default' label.  For    an ordinary label, returns a LABEL_STMT.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_labeled_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|in_statement_expr_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|statement
init|=
name|error_mark_node
decl_stmt|;
comment|/* The next token should be an identifier.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NAME
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_KEYWORD
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected labeled-statement"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_CASE
case|:
block|{
name|tree
name|expr
decl_stmt|,
name|expr_hi
decl_stmt|;
name|cp_token
modifier|*
name|ellipsis
decl_stmt|;
comment|/* Consume the `case' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the constant-expression.  */
name|expr
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant_p=*/
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ellipsis
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ellipsis
operator|->
name|type
operator|==
name|CPP_ELLIPSIS
condition|)
block|{
comment|/* Consume the `...' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|expr_hi
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant_p=*/
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* We don't need to emit warnings here, as the common code 	       will do this for us.  */
block|}
else|else
name|expr_hi
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|parser
operator|->
name|in_switch_statement_p
condition|)
name|error
argument_list|(
literal|"case label `%E' not within a switch statement"
argument_list|,
name|expr
argument_list|)
expr_stmt|;
else|else
name|statement
operator|=
name|finish_case_label
argument_list|(
name|expr
argument_list|,
name|expr_hi
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RID_DEFAULT
case|:
comment|/* Consume the `default' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parser
operator|->
name|in_switch_statement_p
condition|)
name|error
argument_list|(
literal|"case label not within a switch statement"
argument_list|)
expr_stmt|;
else|else
name|statement
operator|=
name|finish_case_label
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Anything else must be an ordinary label.  */
name|statement
operator|=
name|finish_label_stmt
argument_list|(
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Require the `:' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"`:'"
argument_list|)
expr_stmt|;
comment|/* Parse the labeled statement.  */
name|cp_parser_statement
argument_list|(
name|parser
argument_list|,
name|in_statement_expr_p
argument_list|)
expr_stmt|;
comment|/* Return the label, in the case of a `case' or `default' label.  */
return|return
name|statement
return|;
block|}
end_function

begin_comment
comment|/* Parse an expression-statement.     expression-statement:      expression [opt] ;     Returns the new EXPR_STMT -- or NULL_TREE if the expression    statement consists of nothing more than an `;'. IN_STATEMENT_EXPR_P    indicates whether this expression-statement is part of an    expression statement.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_expression_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|in_statement_expr_p
parameter_list|)
block|{
name|tree
name|statement
init|=
name|NULL_TREE
decl_stmt|;
comment|/* If the next token is a ';', then there is no expression      statement.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|statement
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Consume the final `;'.  */
name|cp_parser_consume_semicolon_at_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_statement_expr_p
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
block|{
comment|/* This is the final expression statement of a statement 	 expression.  */
name|statement
operator|=
name|finish_stmt_expr_expr
argument_list|(
name|statement
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|statement
condition|)
name|statement
operator|=
name|finish_expr_stmt
argument_list|(
name|statement
argument_list|)
expr_stmt|;
else|else
name|finish_stmt
argument_list|()
expr_stmt|;
return|return
name|statement
return|;
block|}
end_function

begin_comment
comment|/* Parse a compound-statement.     compound-statement:      { statement-seq [opt] }          Returns a COMPOUND_STMT representing the statement.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_compound_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|in_statement_expr_p
parameter_list|)
block|{
name|tree
name|compound_stmt
decl_stmt|;
comment|/* Consume the `{'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|,
literal|"`{'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Begin the compound-statement.  */
name|compound_stmt
operator|=
name|begin_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Parse an (optional) statement-seq.  */
name|cp_parser_statement_seq_opt
argument_list|(
name|parser
argument_list|,
name|in_statement_expr_p
argument_list|)
expr_stmt|;
comment|/* Finish the compound-statement.  */
name|finish_compound_stmt
argument_list|(
name|compound_stmt
argument_list|)
expr_stmt|;
comment|/* Consume the `}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
return|return
name|compound_stmt
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) statement-seq.     statement-seq:      statement      statement-seq [opt] statement  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_statement_seq_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|in_statement_expr_p
parameter_list|)
block|{
comment|/* Scan statements until there aren't any more.  */
while|while
condition|(
name|true
condition|)
block|{
comment|/* If we're looking at a `}', then we've run out of statements.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
operator|||
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EOF
argument_list|)
condition|)
break|break;
comment|/* Parse the statement.  */
name|cp_parser_statement
argument_list|(
name|parser
argument_list|,
name|in_statement_expr_p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a selection-statement.     selection-statement:      if ( condition ) statement      if ( condition ) statement else statement      switch ( condition ) statement       Returns the new IF_STMT or SWITCH_STMT.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_selection_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|rid
name|keyword
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|,
literal|"selection-statement"
argument_list|)
expr_stmt|;
comment|/* See what kind of keyword it is.  */
name|keyword
operator|=
name|token
operator|->
name|keyword
expr_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_IF
case|:
case|case
name|RID_SWITCH
case|:
block|{
name|tree
name|statement
decl_stmt|;
name|tree
name|condition
decl_stmt|;
comment|/* Look for the `('.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
condition|)
block|{
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Begin the selection-statement.  */
if|if
condition|(
name|keyword
operator|==
name|RID_IF
condition|)
name|statement
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
else|else
name|statement
operator|=
name|begin_switch_stmt
argument_list|()
expr_stmt|;
comment|/* Parse the condition.  */
name|condition
operator|=
name|cp_parser_condition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the `)'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyword
operator|==
name|RID_IF
condition|)
block|{
name|tree
name|then_stmt
decl_stmt|;
comment|/* Add the condition.  */
name|finish_if_stmt_cond
argument_list|(
name|condition
argument_list|,
name|statement
argument_list|)
expr_stmt|;
comment|/* Parse the then-clause.  */
name|then_stmt
operator|=
name|cp_parser_implicitly_scoped_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|finish_then_clause
argument_list|(
name|statement
argument_list|)
expr_stmt|;
comment|/* If the next token is `else', parse the else-clause.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_ELSE
argument_list|)
condition|)
block|{
name|tree
name|else_stmt
decl_stmt|;
comment|/* Consume the `else' keyword.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the else-clause.  */
name|else_stmt
operator|=
name|cp_parser_implicitly_scoped_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|finish_else_clause
argument_list|(
name|statement
argument_list|)
expr_stmt|;
block|}
comment|/* Now we're all done with the if-statement.  */
name|finish_if_stmt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tree
name|body
decl_stmt|;
name|bool
name|in_switch_statement_p
decl_stmt|;
comment|/* Add the condition.  */
name|finish_switch_cond
argument_list|(
name|condition
argument_list|,
name|statement
argument_list|)
expr_stmt|;
comment|/* Parse the body of the switch-statement.  */
name|in_switch_statement_p
operator|=
name|parser
operator|->
name|in_switch_statement_p
expr_stmt|;
name|parser
operator|->
name|in_switch_statement_p
operator|=
name|true
expr_stmt|;
name|body
operator|=
name|cp_parser_implicitly_scoped_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_switch_statement_p
operator|=
name|in_switch_statement_p
expr_stmt|;
comment|/* Now we're all done with the switch-statement.  */
name|finish_switch_stmt
argument_list|(
name|statement
argument_list|)
expr_stmt|;
block|}
return|return
name|statement
return|;
block|}
break|break;
default|default:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected selection-statement"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a condition.      condition:      expression      type-specifier-seq declarator = assignment-expression       GNU Extension:        condition:      type-specifier-seq declarator asm-specification [opt]         attributes [opt] = assignment-expression      Returns the expression that should be tested.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_condition
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|type_specifiers
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
comment|/* Try the declaration first.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* New types are not allowed in the type-specifier-seq for a      condition.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in conditions"
expr_stmt|;
comment|/* Parse the type-specifier-seq.  */
name|type_specifiers
operator|=
name|cp_parser_type_specifier_seq
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Restore the saved message.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
comment|/* If all is well, we might be looking at a declaration.  */
if|if
condition|(
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|asm_specification
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|tree
name|initializer
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Parse the declarator.  */
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_NAMED
argument_list|,
comment|/*ctor_dtor_or_conv_p=*/
name|NULL
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|)
expr_stmt|;
comment|/* Parse the attributes.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the asm-specification.  */
name|asm_specification
operator|=
name|cp_parser_asm_specification_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is not an `=', then we might still be 	 looking at an expression.  For example: 	  	   if (A(a).x) 	   	 looks like a decl-specifier-seq and a declarator -- but then 	 there is no `=', so this is an expression.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_EQ
argument_list|,
literal|"`='"
argument_list|)
expr_stmt|;
comment|/* If we did see an `=', then we are looking at a declaration 	 for sure.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* Create the declaration.  */
name|decl
operator|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|type_specifiers
argument_list|,
comment|/*initialized_p=*/
name|true
argument_list|,
name|attributes
argument_list|,
comment|/*prefix_attributes=*/
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Parse the assignment-expression.  */
name|initializer
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Process the initializer.  */
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|initializer
argument_list|,
name|asm_specification
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|decl
argument_list|)
return|;
block|}
block|}
comment|/* If we didn't even get past the declarator successfully, we are      definitely not looking at a declaration.  */
else|else
name|cp_parser_abort_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Otherwise, we are looking at an expression.  */
return|return
name|cp_parser_expression
argument_list|(
name|parser
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an iteration-statement.     iteration-statement:      while ( condition ) statement      do statement while ( expression ) ;      for ( for-init-statement condition [opt] ; expression [opt] )        statement     Returns the new WHILE_STMT, DO_STMT, or FOR_STMT.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_iteration_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|rid
name|keyword
decl_stmt|;
name|tree
name|statement
decl_stmt|;
name|bool
name|in_iteration_statement_p
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|,
literal|"iteration-statement"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
name|error_mark_node
return|;
comment|/* Remember whether or not we are already within an iteration      statement.  */
name|in_iteration_statement_p
operator|=
name|parser
operator|->
name|in_iteration_statement_p
expr_stmt|;
comment|/* See what kind of keyword it is.  */
name|keyword
operator|=
name|token
operator|->
name|keyword
expr_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_WHILE
case|:
block|{
name|tree
name|condition
decl_stmt|;
comment|/* Begin the while-statement.  */
name|statement
operator|=
name|begin_while_stmt
argument_list|()
expr_stmt|;
comment|/* Look for the `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Parse the condition.  */
name|condition
operator|=
name|cp_parser_condition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|finish_while_stmt_cond
argument_list|(
name|condition
argument_list|,
name|statement
argument_list|)
expr_stmt|;
comment|/* Look for the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Parse the dependent statement.  */
name|parser
operator|->
name|in_iteration_statement_p
operator|=
name|true
expr_stmt|;
name|cp_parser_already_scoped_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_iteration_statement_p
operator|=
name|in_iteration_statement_p
expr_stmt|;
comment|/* We're done with the while-statement.  */
name|finish_while_stmt
argument_list|(
name|statement
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RID_DO
case|:
block|{
name|tree
name|expression
decl_stmt|;
comment|/* Begin the do-statement.  */
name|statement
operator|=
name|begin_do_stmt
argument_list|()
expr_stmt|;
comment|/* Parse the body of the do-statement.  */
name|parser
operator|->
name|in_iteration_statement_p
operator|=
name|true
expr_stmt|;
name|cp_parser_implicitly_scoped_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_iteration_statement_p
operator|=
name|in_iteration_statement_p
expr_stmt|;
name|finish_do_body
argument_list|(
name|statement
argument_list|)
expr_stmt|;
comment|/* Look for the `while' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_WHILE
argument_list|,
literal|"`while'"
argument_list|)
expr_stmt|;
comment|/* Look for the `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Parse the expression.  */
name|expression
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* We're done with the do-statement.  */
name|finish_do_stmt
argument_list|(
name|expression
argument_list|,
name|statement
argument_list|)
expr_stmt|;
comment|/* Look for the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Look for the `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RID_FOR
case|:
block|{
name|tree
name|condition
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|expression
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Begin the for-statement.  */
name|statement
operator|=
name|begin_for_stmt
argument_list|()
expr_stmt|;
comment|/* Look for the `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Parse the initialization.  */
name|cp_parser_for_init_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|finish_for_init_stmt
argument_list|(
name|statement
argument_list|)
expr_stmt|;
comment|/* If there's a condition, process it.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|condition
operator|=
name|cp_parser_condition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|finish_for_cond
argument_list|(
name|condition
argument_list|,
name|statement
argument_list|)
expr_stmt|;
comment|/* Look for the `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
comment|/* If there's an expression, process it.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|expression
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|finish_for_expr
argument_list|(
name|expression
argument_list|,
name|statement
argument_list|)
expr_stmt|;
comment|/* Look for the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Parse the body of the for-statement.  */
name|parser
operator|->
name|in_iteration_statement_p
operator|=
name|true
expr_stmt|;
name|cp_parser_already_scoped_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_iteration_statement_p
operator|=
name|in_iteration_statement_p
expr_stmt|;
comment|/* We're done with the for-statement.  */
name|finish_for_stmt
argument_list|(
name|statement
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected iteration-statement"
argument_list|)
expr_stmt|;
name|statement
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
return|return
name|statement
return|;
block|}
end_function

begin_comment
comment|/* Parse a for-init-statement.     for-init-statement:      expression-statement      simple-declaration  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_for_init_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* If the next token is a `;', then we have an empty      expression-statement.  Grammatically, this is also a      simple-declaration, but an invalid one, because it does not      declare anything.  Therefore, if we did not handle this case      specially, we would issue an error message about an invalid      declaration.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
comment|/* We're going to speculatively look for a declaration, falling back 	 to an expression, if necessary.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the declaration.  */
name|cp_parser_simple_declaration
argument_list|(
name|parser
argument_list|,
comment|/*function_definition_allowed_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If the tentative parse failed, then we shall need to look for an 	 expression-statement.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return;
block|}
name|cp_parser_expression_statement
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a jump-statement.     jump-statement:      break ;      continue ;      return expression [opt] ;      goto identifier ;       GNU extension:     jump-statement:      goto * expression ;     Returns the new BREAK_STMT, CONTINUE_STMT, RETURN_STMT, or    GOTO_STMT.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_jump_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|statement
init|=
name|error_mark_node
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|rid
name|keyword
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|,
literal|"jump-statement"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
name|error_mark_node
return|;
comment|/* See what kind of keyword it is.  */
name|keyword
operator|=
name|token
operator|->
name|keyword
expr_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_BREAK
case|:
if|if
condition|(
operator|!
name|parser
operator|->
name|in_switch_statement_p
operator|&&
operator|!
name|parser
operator|->
name|in_iteration_statement_p
condition|)
block|{
name|error
argument_list|(
literal|"break statement not within loop or switch"
argument_list|)
expr_stmt|;
name|statement
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|statement
operator|=
name|finish_break_stmt
argument_list|()
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_CONTINUE
case|:
if|if
condition|(
operator|!
name|parser
operator|->
name|in_iteration_statement_p
condition|)
block|{
name|error
argument_list|(
literal|"continue statement not within a loop"
argument_list|)
expr_stmt|;
name|statement
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|statement
operator|=
name|finish_continue_stmt
argument_list|()
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_RETURN
case|:
block|{
name|tree
name|expr
decl_stmt|;
comment|/* If the next token is a `;', then there is no  	   expression.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|expr
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Build the return-statement.  */
name|statement
operator|=
name|finish_return_stmt
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Look for the final `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RID_GOTO
case|:
comment|/* Create the goto-statement.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_MULT
argument_list|)
condition|)
block|{
comment|/* Issue a warning about this use of a GNU extension.  */
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids computed gotos"
argument_list|)
expr_stmt|;
comment|/* Consume the '*' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the dependent expression.  */
name|finish_goto_stmt
argument_list|(
name|cp_parser_expression
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|finish_goto_stmt
argument_list|(
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Look for the final `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected jump-statement"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|statement
return|;
block|}
end_function

begin_comment
comment|/* Parse a declaration-statement.     declaration-statement:      block-declaration  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_declaration_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Parse the block-declaration.  */
name|cp_parser_block_declaration
argument_list|(
name|parser
argument_list|,
comment|/*statement_p=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Finish off the statement.  */
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Some dependent statements (like `if (cond) statement'), are    implicitly in their own scope.  In other words, if the statement is    a single statement (as opposed to a compound-statement), it is    none-the-less treated as if it were enclosed in braces.  Any    declarations appearing in the dependent statement are out of scope    after control passes that point.  This function parses a statement,    but ensures that is in its own scope, even if it is not a    compound-statement.       Returns the new statement.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_implicitly_scoped_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|statement
decl_stmt|;
comment|/* If the token is not a `{', then we must take special action.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
block|{
comment|/* Create a compound-statement.  */
name|statement
operator|=
name|begin_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Parse the dependent-statement.  */
name|cp_parser_statement
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Finish the dummy compound-statement.  */
name|finish_compound_stmt
argument_list|(
name|statement
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, we simply parse the statement directly.  */
else|else
name|statement
operator|=
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Return the statement.  */
return|return
name|statement
return|;
block|}
end_function

begin_comment
comment|/* For some dependent statements (like `while (cond) statement'), we    have already created a scope.  Therefore, even if the dependent    statement is a compound-statement, we do not want to create another    scope.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_already_scoped_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* If the token is not a `{', then we must take special action.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
block|{
name|tree
name|statement
decl_stmt|;
comment|/* Create a compound-statement.  */
name|statement
operator|=
name|begin_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Parse the dependent-statement.  */
name|cp_parser_statement
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Finish the dummy compound-statement.  */
name|finish_compound_stmt
argument_list|(
name|statement
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, we simply parse the statement directly.  */
else|else
name|cp_parser_statement
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Declarations [gram.dcl.dcl] */
end_comment

begin_comment
comment|/* Parse an optional declaration-sequence.     declaration-seq:      declaration      declaration-seq declaration  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_declaration_seq_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_SEMICOLON
condition|)
block|{
comment|/* A declaration consisting of a single semicolon is 	     invalid.  Allow it unless we're being pedantic.  */
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"extra `;'"
argument_list|)
expr_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* The C lexer modifies PENDING_LANG_CHANGE when it wants the 	 parser to enter or exit implicit `extern "C"' blocks.  */
while|while
condition|(
name|pending_lang_change
operator|>
literal|0
condition|)
block|{
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
operator|--
name|pending_lang_change
expr_stmt|;
block|}
while|while
condition|(
name|pending_lang_change
operator|<
literal|0
condition|)
block|{
name|pop_lang_context
argument_list|()
expr_stmt|;
operator|++
name|pending_lang_change
expr_stmt|;
block|}
comment|/* Parse the declaration itself.  */
name|cp_parser_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a declaration.     declaration:      block-declaration      function-definition      template-declaration      explicit-instantiation      explicit-specialization      linkage-specification      namespace-definition         GNU extension:     declaration:       __extension__ declaration */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
name|token1
decl_stmt|;
name|cp_token
name|token2
decl_stmt|;
name|int
name|saved_pedantic
decl_stmt|;
comment|/* Check for the `__extension__' keyword.  */
if|if
condition|(
name|cp_parser_extension_opt
argument_list|(
name|parser
argument_list|,
operator|&
name|saved_pedantic
argument_list|)
condition|)
block|{
comment|/* Parse the qualified declaration.  */
name|cp_parser_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Restore the PEDANTIC flag.  */
name|pedantic
operator|=
name|saved_pedantic
expr_stmt|;
return|return;
block|}
comment|/* Try to figure out what kind of declaration is present.  */
name|token1
operator|=
operator|*
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token1
operator|.
name|type
operator|!=
name|CPP_EOF
condition|)
name|token2
operator|=
operator|*
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If the next token is `extern' and the following token is a string      literal, then we have a linkage specification.  */
if|if
condition|(
name|token1
operator|.
name|keyword
operator|==
name|RID_EXTERN
operator|&&
name|cp_parser_is_string_literal
argument_list|(
operator|&
name|token2
argument_list|)
condition|)
name|cp_parser_linkage_specification
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is `template', then we have either a template      declaration, an explicit instantiation, or an explicit      specialization.  */
elseif|else
if|if
condition|(
name|token1
operator|.
name|keyword
operator|==
name|RID_TEMPLATE
condition|)
block|{
comment|/* `template<>' indicates a template specialization.  */
if|if
condition|(
name|token2
operator|.
name|type
operator|==
name|CPP_LESS
operator|&&
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|3
argument_list|)
operator|->
name|type
operator|==
name|CPP_GREATER
condition|)
name|cp_parser_explicit_specialization
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* `template<' indicates a template declaration.  */
elseif|else
if|if
condition|(
name|token2
operator|.
name|type
operator|==
name|CPP_LESS
condition|)
name|cp_parser_template_declaration
argument_list|(
name|parser
argument_list|,
comment|/*member_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Anything else must be an explicit instantiation.  */
else|else
name|cp_parser_explicit_instantiation
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* If the next token is `export', then we have a template      declaration.  */
elseif|else
if|if
condition|(
name|token1
operator|.
name|keyword
operator|==
name|RID_EXPORT
condition|)
name|cp_parser_template_declaration
argument_list|(
name|parser
argument_list|,
comment|/*member_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If the next token is `extern', 'static' or 'inline' and the one      after that is `template', we have a GNU extended explicit      instantiation directive.  */
elseif|else
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
operator|(
name|token1
operator|.
name|keyword
operator|==
name|RID_EXTERN
operator|||
name|token1
operator|.
name|keyword
operator|==
name|RID_STATIC
operator|||
name|token1
operator|.
name|keyword
operator|==
name|RID_INLINE
operator|)
operator|&&
name|token2
operator|.
name|keyword
operator|==
name|RID_TEMPLATE
condition|)
name|cp_parser_explicit_instantiation
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is `namespace', check for a named or unnamed      namespace definition.  */
elseif|else
if|if
condition|(
name|token1
operator|.
name|keyword
operator|==
name|RID_NAMESPACE
operator|&&
operator|(
comment|/* A named namespace definition.  */
operator|(
name|token2
operator|.
name|type
operator|==
name|CPP_NAME
operator|&&
operator|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|3
argument_list|)
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
operator|)
operator|)
comment|/* An unnamed namespace definition.  */
operator|||
name|token2
operator|.
name|type
operator|==
name|CPP_OPEN_BRACE
operator|)
condition|)
name|cp_parser_namespace_definition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* We must have either a block declaration or a function      definition.  */
else|else
comment|/* Try to parse a block-declaration, or a function-definition.  */
name|cp_parser_block_declaration
argument_list|(
name|parser
argument_list|,
comment|/*statement_p=*/
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a block-declaration.       block-declaration:      simple-declaration      asm-definition      namespace-alias-definition      using-declaration      using-directive       GNU Extension:     block-declaration:      __extension__ block-declaration       label-declaration     If STATEMENT_P is TRUE, then this block-declaration is occurring as    part of a declaration-statement.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_block_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|statement_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token1
decl_stmt|;
name|int
name|saved_pedantic
decl_stmt|;
comment|/* Check for the `__extension__' keyword.  */
if|if
condition|(
name|cp_parser_extension_opt
argument_list|(
name|parser
argument_list|,
operator|&
name|saved_pedantic
argument_list|)
condition|)
block|{
comment|/* Parse the qualified declaration.  */
name|cp_parser_block_declaration
argument_list|(
name|parser
argument_list|,
name|statement_p
argument_list|)
expr_stmt|;
comment|/* Restore the PEDANTIC flag.  */
name|pedantic
operator|=
name|saved_pedantic
expr_stmt|;
return|return;
block|}
comment|/* Peek at the next token to figure out which kind of declaration is      present.  */
name|token1
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next keyword is `asm', we have an asm-definition.  */
if|if
condition|(
name|token1
operator|->
name|keyword
operator|==
name|RID_ASM
condition|)
block|{
if|if
condition|(
name|statement_p
condition|)
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_asm_definition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* If the next keyword is `namespace', we have a      namespace-alias-definition.  */
elseif|else
if|if
condition|(
name|token1
operator|->
name|keyword
operator|==
name|RID_NAMESPACE
condition|)
name|cp_parser_namespace_alias_definition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next keyword is `using', we have either a      using-declaration or a using-directive.  */
elseif|else
if|if
condition|(
name|token1
operator|->
name|keyword
operator|==
name|RID_USING
condition|)
block|{
name|cp_token
modifier|*
name|token2
decl_stmt|;
if|if
condition|(
name|statement_p
condition|)
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the token after `using' is `namespace', then we have a 	 using-directive.  */
name|token2
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|token2
operator|->
name|keyword
operator|==
name|RID_NAMESPACE
condition|)
name|cp_parser_using_directive
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Otherwise, it's a using-declaration.  */
else|else
name|cp_parser_using_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* If the next keyword is `__label__' we have a label declaration.  */
elseif|else
if|if
condition|(
name|token1
operator|->
name|keyword
operator|==
name|RID_LABEL
condition|)
block|{
if|if
condition|(
name|statement_p
condition|)
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_label_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Anything else must be a simple-declaration.  */
else|else
name|cp_parser_simple_declaration
argument_list|(
name|parser
argument_list|,
operator|!
name|statement_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a simple-declaration.     simple-declaration:      decl-specifier-seq [opt] init-declarator-list [opt] ;       init-declarator-list:      init-declarator      init-declarator-list , init-declarator      If FUNCTION_DEFINITION_ALLOWED_P is TRUE, then we also recognize a    function-definition as a simple-declaration.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_simple_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|function_definition_allowed_p
parameter_list|)
block|{
name|tree
name|decl_specifiers
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|int
name|declares_class_or_enum
decl_stmt|;
name|bool
name|saw_declarator
decl_stmt|;
comment|/* Defer access checks until we know what is being declared; the      checks for names appearing in the decl-specifier-seq should be      done as if we were in the scope of the thing being declared.  */
name|push_deferring_access_checks
argument_list|(
name|dk_deferred
argument_list|)
expr_stmt|;
comment|/* Parse the decl-specifier-seq.  We have to keep track of whether      or not the decl-specifier-seq declares a named class or      enumeration type, since that is the only case in which the      init-declarator-list is allowed to be empty.         [dcl.dcl]       In a simple-declaration, the optional init-declarator-list can be      omitted only when declaring a class or enumeration, that is when      the decl-specifier-seq contains either a class-specifier, an      elaborated-type-specifier, or an enum-specifier.  */
name|decl_specifiers
operator|=
name|cp_parser_decl_specifier_seq
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_FLAGS_OPTIONAL
argument_list|,
operator|&
name|attributes
argument_list|,
operator|&
name|declares_class_or_enum
argument_list|)
expr_stmt|;
comment|/* We no longer need to defer access checks.  */
name|stop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* In a block scope, a valid declaration must always have a      decl-specifier-seq.  By not trying to parse declarators, we can      resolve the declaration/expression ambiguity more quickly.  */
if|if
condition|(
operator|!
name|function_definition_allowed_p
operator|&&
operator|!
name|decl_specifiers
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected declaration"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* If the next two tokens are both identifiers, the code is      erroneous. The usual cause of this situation is code like:         T t;       where "T" should name a type -- but does not.  */
if|if
condition|(
name|cp_parser_diagnose_invalid_type_name
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* If parsing tentatively, we should commit; we really are 	 looking at a declaration.  */
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Give up.  */
goto|goto
name|done
goto|;
block|}
comment|/* Keep going until we hit the `;' at the end of the simple      declaration.  */
name|saw_declarator
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|bool
name|function_definition_p
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|saw_declarator
operator|=
name|true
expr_stmt|;
comment|/* Parse the init-declarator.  */
name|decl
operator|=
name|cp_parser_init_declarator
argument_list|(
name|parser
argument_list|,
name|decl_specifiers
argument_list|,
name|attributes
argument_list|,
name|function_definition_allowed_p
argument_list|,
comment|/*member_p=*/
name|false
argument_list|,
name|declares_class_or_enum
argument_list|,
operator|&
name|function_definition_p
argument_list|)
expr_stmt|;
comment|/* If an error occurred while parsing tentatively, exit quickly. 	 (That usually happens when in the body of a function; each 	 statement is treated as a declaration-statement until proven 	 otherwise.)  */
if|if
condition|(
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* Handle function definitions specially.  */
if|if
condition|(
name|function_definition_p
condition|)
block|{
comment|/* If the next token is a `,', then we are probably 	     processing something like:  	       void f() {}, *p;  	     which is erroneous.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|error
argument_list|(
literal|"mixing declarations and function-definitions is forbidden"
argument_list|)
expr_stmt|;
comment|/* Otherwise, we're done with the list of declarators.  */
else|else
block|{
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* The next token should be either a `,' or a `;'.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's a `,', there are more declarators to come.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's a `;', we are done.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_SEMICOLON
condition|)
break|break;
comment|/* Anything else is an error.  */
else|else
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected `,' or `;'"
argument_list|)
expr_stmt|;
comment|/* Skip tokens until we reach the end of the statement.  */
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is now a `;', consume it.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* After the first time around, a function-definition is not 	 allowed -- even if it was OK at first.  For example:             int i, f() {}           is not valid.  */
name|function_definition_allowed_p
operator|=
name|false
expr_stmt|;
block|}
comment|/* Issue an error message if no declarators are present, and the      decl-specifier-seq does not itself declare a class or      enumeration.  */
if|if
condition|(
operator|!
name|saw_declarator
condition|)
block|{
if|if
condition|(
name|cp_parser_declares_only_class_p
argument_list|(
name|parser
argument_list|)
condition|)
name|shadow_tag
argument_list|(
name|decl_specifiers
argument_list|)
expr_stmt|;
comment|/* Perform any deferred access checks.  */
name|perform_deferred_access_checks
argument_list|()
expr_stmt|;
block|}
comment|/* Consume the `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
name|done
label|:
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a decl-specifier-seq.     decl-specifier-seq:      decl-specifier-seq [opt] decl-specifier     decl-specifier:      storage-class-specifier      type-specifier      function-specifier      friend      typedef       GNU Extension:     decl-specifier:      attributes     Returns a TREE_LIST, giving the decl-specifiers in the order they    appear in the source code.  The TREE_VALUE of each node is the    decl-specifier.  For a keyword (such as `auto' or `friend'), the    TREE_VALUE is simply the corresponding TREE_IDENTIFIER.  For the    representation of a type-specifier, see cp_parser_type_specifier.       If there are attributes, they will be stored in *ATTRIBUTES,    represented as described above cp_parser_attributes.       If FRIEND_IS_NOT_CLASS_P is non-NULL, and the `friend' specifier    appears, and the entity that will be a friend is not going to be a    class, then *FRIEND_IS_NOT_CLASS_P will be set to TRUE.  Note that    even if *FRIEND_IS_NOT_CLASS_P is FALSE, the entity to which    friendship is granted might not be a class.       *DECLARES_CLASS_OR_ENUM is set to the bitwise or of the following    flags:       1: one of the decl-specifiers is an elaborated-type-specifier         (i.e., a type declaration)      2: one of the decl-specifiers is an enum-specifier or a         class-specifier (i.e., a type definition)     */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_decl_specifier_seq
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_parser_flags
name|flags
parameter_list|,
name|tree
modifier|*
name|attributes
parameter_list|,
name|int
modifier|*
name|declares_class_or_enum
parameter_list|)
block|{
name|tree
name|decl_specs
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|friend_p
init|=
name|false
decl_stmt|;
name|bool
name|constructor_possible_p
init|=
operator|!
name|parser
operator|->
name|in_declarator_p
decl_stmt|;
comment|/* Assume no class or enumeration type is declared.  */
operator|*
name|declares_class_or_enum
operator|=
literal|0
expr_stmt|;
comment|/* Assume there are no attributes.  */
operator|*
name|attributes
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Keep reading specifiers until there are no more to read.  */
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|decl_spec
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|constructor_p
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Handle attributes.  */
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_ATTRIBUTE
condition|)
block|{
comment|/* Parse the attributes.  */
name|decl_spec
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Add them to the list.  */
operator|*
name|attributes
operator|=
name|chainon
argument_list|(
operator|*
name|attributes
argument_list|,
name|decl_spec
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If the next token is an appropriate keyword, we can simply 	 add it to the list.  */
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_FRIEND
case|:
comment|/* decl-specifier: 	       friend  */
if|if
condition|(
name|friend_p
condition|)
name|error
argument_list|(
literal|"duplicate `friend'"
argument_list|)
expr_stmt|;
else|else
name|friend_p
operator|=
name|true
expr_stmt|;
comment|/* The representation of the specifier is simply the 	     appropriate TREE_IDENTIFIER node.  */
name|decl_spec
operator|=
name|token
operator|->
name|value
expr_stmt|;
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
break|break;
comment|/* function-specifier: 	       inline 	       virtual 	       explicit  */
case|case
name|RID_INLINE
case|:
case|case
name|RID_VIRTUAL
case|:
case|case
name|RID_EXPLICIT
case|:
name|decl_spec
operator|=
name|cp_parser_function_specifier_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
comment|/* decl-specifier: 	       typedef  */
case|case
name|RID_TYPEDEF
case|:
comment|/* The representation of the specifier is simply the 	     appropriate TREE_IDENTIFIER node.  */
name|decl_spec
operator|=
name|token
operator|->
name|value
expr_stmt|;
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* A constructor declarator cannot appear in a typedef.  */
name|constructor_possible_p
operator|=
name|false
expr_stmt|;
comment|/* The "typedef" keyword can only occur in a declaration; we 	     may as well commit at this point.  */
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
comment|/* storage-class-specifier: 	       auto 	       register 	       static 	       extern 	       mutable                 GNU Extension: 	       thread  */
case|case
name|RID_AUTO
case|:
case|case
name|RID_REGISTER
case|:
case|case
name|RID_STATIC
case|:
case|case
name|RID_EXTERN
case|:
case|case
name|RID_MUTABLE
case|:
case|case
name|RID_THREAD
case|:
name|decl_spec
operator|=
name|cp_parser_storage_class_specifier_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Constructors are a special case.  The `S' in `S()' is not a 	 decl-specifier; it is the beginning of the declarator.  */
name|constructor_p
operator|=
operator|(
operator|!
name|decl_spec
operator|&&
name|constructor_possible_p
operator|&&
name|cp_parser_constructor_declarator_p
argument_list|(
name|parser
argument_list|,
name|friend_p
argument_list|)
operator|)
expr_stmt|;
comment|/* If we don't have a DECL_SPEC yet, then we must be looking at 	 a type-specifier.  */
if|if
condition|(
operator|!
name|decl_spec
operator|&&
operator|!
name|constructor_p
condition|)
block|{
name|int
name|decl_spec_declares_class_or_enum
decl_stmt|;
name|bool
name|is_cv_qualifier
decl_stmt|;
name|decl_spec
operator|=
name|cp_parser_type_specifier
argument_list|(
name|parser
argument_list|,
name|flags
argument_list|,
name|friend_p
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|,
operator|&
name|decl_spec_declares_class_or_enum
argument_list|,
operator|&
name|is_cv_qualifier
argument_list|)
expr_stmt|;
operator|*
name|declares_class_or_enum
operator||=
name|decl_spec_declares_class_or_enum
expr_stmt|;
comment|/* If this type-specifier referenced a user-defined type 	     (a typedef, class-name, etc.), then we can't allow any 	     more such type-specifiers henceforth.  	     [dcl.spec]  	     The longest sequence of decl-specifiers that could 	     possibly be a type name is taken as the 	     decl-specifier-seq of a declaration.  The sequence shall 	     be self-consistent as described below.  	     [dcl.type]  	     As a general rule, at most one type-specifier is allowed 	     in the complete decl-specifier-seq of a declaration.  The 	     only exceptions are the following:  	     -- const or volatile can be combined with any other 		type-specifier.   	     -- signed or unsigned can be combined with char, long, 		short, or int.  	     -- ..  	     Example:  	       typedef char* Pc; 	       void g (const int Pc);  	     Here, Pc is *not* part of the decl-specifier seq; it's 	     the declarator.  Therefore, once we see a type-specifier 	     (other than a cv-qualifier), we forbid any additional 	     user-defined types.  We *do* still allow things like `int 	     int' to be considered a decl-specifier-seq, and issue the 	     error message later.  */
if|if
condition|(
name|decl_spec
operator|&&
operator|!
name|is_cv_qualifier
condition|)
name|flags
operator||=
name|CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES
expr_stmt|;
comment|/* A constructor declarator cannot follow a type-specifier.  */
if|if
condition|(
name|decl_spec
condition|)
name|constructor_possible_p
operator|=
name|false
expr_stmt|;
block|}
comment|/* If we still do not have a DECL_SPEC, then there are no more 	 decl-specifiers.  */
if|if
condition|(
operator|!
name|decl_spec
condition|)
block|{
comment|/* Issue an error message, unless the entire construct was              optional.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CP_PARSER_FLAGS_OPTIONAL
operator|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected decl specifier"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
break|break;
block|}
comment|/* Add the DECL_SPEC to the list of specifiers.  */
if|if
condition|(
name|decl_specs
operator|==
name|NULL
operator|||
name|TREE_VALUE
argument_list|(
name|decl_specs
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl_spec
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
comment|/* After we see one decl-specifier, further decl-specifiers are 	 always optional.  */
name|flags
operator||=
name|CP_PARSER_FLAGS_OPTIONAL
expr_stmt|;
block|}
comment|/* Don't allow a friend specifier with a class definition.  */
if|if
condition|(
name|friend_p
operator|&&
operator|(
operator|*
name|declares_class_or_enum
operator|&
literal|2
operator|)
condition|)
name|error
argument_list|(
literal|"class definition may not be declared a friend"
argument_list|)
expr_stmt|;
comment|/* We have built up the DECL_SPECS in reverse order.  Return them in      the correct order.  */
return|return
name|nreverse
argument_list|(
name|decl_specs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) storage-class-specifier.      storage-class-specifier:      auto      register      static      extern      mutable       GNU Extension:     storage-class-specifier:      thread     Returns an IDENTIFIER_NODE corresponding to the keyword used.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_storage_class_specifier_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
switch|switch
condition|(
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_AUTO
case|:
case|case
name|RID_REGISTER
case|:
case|case
name|RID_STATIC
case|:
case|case
name|RID_EXTERN
case|:
case|case
name|RID_MUTABLE
case|:
case|case
name|RID_THREAD
case|:
comment|/* Consume the token.  */
return|return
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|value
return|;
default|default:
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an (optional) function-specifier.      function-specifier:      inline      virtual      explicit     Returns an IDENTIFIER_NODE corresponding to the keyword used.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_function_specifier_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
switch|switch
condition|(
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_INLINE
case|:
case|case
name|RID_VIRTUAL
case|:
case|case
name|RID_EXPLICIT
case|:
comment|/* Consume the token.  */
return|return
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|value
return|;
default|default:
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a linkage-specification.     linkage-specification:      extern string-literal { declaration-seq [opt] }      extern string-literal declaration  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_linkage_specification
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|linkage
decl_stmt|;
comment|/* Look for the `extern' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_EXTERN
argument_list|,
literal|"`extern'"
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's not a string-literal, then there's a problem.  */
if|if
condition|(
operator|!
name|cp_parser_is_string_literal
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected language-name"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Transform the literal into an identifier.  If the literal is a      wide-character string, or contains embedded NULs, then we can't      handle it as the user wants.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_WSTRING
operator|||
operator|(
name|strlen
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|token
operator|->
name|value
argument_list|)
argument_list|)
operator|!=
call|(
name|size_t
call|)
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|token
operator|->
name|value
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"invalid linkage-specification"
argument_list|)
expr_stmt|;
comment|/* Assume C++ linkage.  */
name|linkage
operator|=
name|get_identifier
argument_list|(
literal|"c++"
argument_list|)
expr_stmt|;
block|}
comment|/* If it's a simple string constant, things are easier.  */
else|else
name|linkage
operator|=
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|token
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're now using the new linkage.  */
name|push_lang_context
argument_list|(
name|linkage
argument_list|)
expr_stmt|;
comment|/* If the next token is a `{', then we're using the first      production.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
block|{
comment|/* Consume the `{' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the declarations.  */
name|cp_parser_declaration_seq_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the closing `}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, there's just one declaration.  */
else|else
block|{
name|bool
name|saved_in_unbraced_linkage_specification_p
decl_stmt|;
name|saved_in_unbraced_linkage_specification_p
operator|=
name|parser
operator|->
name|in_unbraced_linkage_specification_p
expr_stmt|;
name|parser
operator|->
name|in_unbraced_linkage_specification_p
operator|=
name|true
expr_stmt|;
name|have_extern_spec
operator|=
name|true
expr_stmt|;
name|cp_parser_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|have_extern_spec
operator|=
name|false
expr_stmt|;
name|parser
operator|->
name|in_unbraced_linkage_specification_p
operator|=
name|saved_in_unbraced_linkage_specification_p
expr_stmt|;
block|}
comment|/* We're done with the linkage-specification.  */
name|pop_lang_context
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Special member functions [gram.special] */
end_comment

begin_comment
comment|/* Parse a conversion-function-id.     conversion-function-id:      operator conversion-type-id       Returns an IDENTIFIER_NODE representing the operator.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_conversion_function_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|saved_scope
decl_stmt|;
name|tree
name|saved_qualifying_scope
decl_stmt|;
name|tree
name|saved_object_scope
decl_stmt|;
name|bool
name|pop_p
init|=
name|false
decl_stmt|;
comment|/* Look for the `operator' token.  */
if|if
condition|(
operator|!
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_OPERATOR
argument_list|,
literal|"`operator'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* When we parse the conversion-type-id, the current scope will be      reset.  However, we need that information in able to look up the      conversion function later, so we save it here.  */
name|saved_scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|saved_qualifying_scope
operator|=
name|parser
operator|->
name|qualifying_scope
expr_stmt|;
name|saved_object_scope
operator|=
name|parser
operator|->
name|object_scope
expr_stmt|;
comment|/* We must enter the scope of the class so that the names of      entities declared within the class are available in the      conversion-type-id.  For example, consider:         struct S {           typedef int I; 	 operator I();        };         S::operator I() { ... }       In order to see that `I' is a type-name in the definition, we      must be in the scope of `S'.  */
if|if
condition|(
name|saved_scope
condition|)
name|pop_p
operator|=
name|push_scope
argument_list|(
name|saved_scope
argument_list|)
expr_stmt|;
comment|/* Parse the conversion-type-id.  */
name|type
operator|=
name|cp_parser_conversion_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Leave the scope of the class, if any.  */
if|if
condition|(
name|pop_p
condition|)
name|pop_scope
argument_list|(
name|saved_scope
argument_list|)
expr_stmt|;
comment|/* Restore the saved scope.  */
name|parser
operator|->
name|scope
operator|=
name|saved_scope
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|saved_qualifying_scope
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|saved_object_scope
expr_stmt|;
comment|/* If the TYPE is invalid, indicate failure.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|mangle_conv_op_name_for_type
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a conversion-type-id:     conversion-type-id:      type-specifier-seq conversion-declarator [opt]     Returns the TYPE specified.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_conversion_type_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|attributes
decl_stmt|;
name|tree
name|type_specifiers
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
comment|/* Parse the attributes.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the type-specifiers.  */
name|type_specifiers
operator|=
name|cp_parser_type_specifier_seq
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If that didn't work, stop.  */
if|if
condition|(
name|type_specifiers
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Parse the conversion-declarator.  */
name|declarator
operator|=
name|cp_parser_conversion_declarator_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|type_specifiers
argument_list|,
name|TYPENAME
argument_list|,
comment|/*initialized=*/
literal|0
argument_list|,
operator|&
name|attributes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) conversion-declarator.     conversion-declarator:      ptr-operator conversion-declarator [opt]       Returns a representation of the declarator.  See    cp_parser_declarator for details.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_conversion_declarator_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|class_type
decl_stmt|;
name|tree
name|cv_qualifier_seq
decl_stmt|;
comment|/* We don't know if there's a ptr-operator next, or not.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try the ptr-operator.  */
name|code
operator|=
name|cp_parser_ptr_operator
argument_list|(
name|parser
argument_list|,
operator|&
name|class_type
argument_list|,
operator|&
name|cv_qualifier_seq
argument_list|)
expr_stmt|;
comment|/* If it worked, look for more conversion-declarators.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|tree
name|declarator
decl_stmt|;
comment|/* Parse another optional declarator.  */
name|declarator
operator|=
name|cp_parser_conversion_declarator_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Create the representation of the declarator.  */
if|if
condition|(
name|code
operator|==
name|INDIRECT_REF
condition|)
name|declarator
operator|=
name|make_pointer_declarator
argument_list|(
name|cv_qualifier_seq
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
else|else
name|declarator
operator|=
name|make_reference_declarator
argument_list|(
name|cv_qualifier_seq
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
comment|/* Handle the pointer-to-member case.  */
if|if
condition|(
name|class_type
condition|)
name|declarator
operator|=
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|class_type
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|declarator
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) ctor-initializer.     ctor-initializer:      : mem-initializer-list       Returns TRUE iff the ctor-initializer was actually present.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_ctor_initializer_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* If the next token is not a `:', then there is no      ctor-initializer.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
block|{
comment|/* Do default initialization of any bases and members.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|finish_mem_initializers
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Consume the `:' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* And the mem-initializer-list.  */
name|cp_parser_mem_initializer_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Parse a mem-initializer-list.     mem-initializer-list:      mem-initializer      mem-initializer , mem-initializer-list  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_mem_initializer_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|mem_initializer_list
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Let the semantic analysis code know that we are starting the      mem-initializer-list.  */
if|if
condition|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"only constructors take base initializers"
argument_list|)
expr_stmt|;
comment|/* Loop through the list.  */
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|mem_initializer
decl_stmt|;
comment|/* Parse the mem-initializer.  */
name|mem_initializer
operator|=
name|cp_parser_mem_initializer
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Add it to the list, unless it was erroneous.  */
if|if
condition|(
name|mem_initializer
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|mem_initializer
argument_list|)
operator|=
name|mem_initializer_list
expr_stmt|;
name|mem_initializer_list
operator|=
name|mem_initializer
expr_stmt|;
block|}
comment|/* If the next token is not a `,', we're done.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
comment|/* Consume the `,' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* Perform semantic analysis.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|finish_mem_initializers
argument_list|(
name|mem_initializer_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a mem-initializer.     mem-initializer:      mem-initializer-id ( expression-list [opt] )       GNU extension:       mem-initializer:      ( expression-list [opt] )     Returns a TREE_LIST.  The TREE_PURPOSE is the TYPE (for a base    class) or FIELD_DECL (for a non-static data member) to initialize;    the TREE_VALUE is the expression-list.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_mem_initializer
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|mem_initializer_id
decl_stmt|;
name|tree
name|expression_list
decl_stmt|;
name|tree
name|member
decl_stmt|;
comment|/* Find out what is being initialized.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"anachronistic old-style base class initializer"
argument_list|)
expr_stmt|;
name|mem_initializer_id
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|mem_initializer_id
operator|=
name|cp_parser_mem_initializer_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|member
operator|=
name|expand_member_init
argument_list|(
name|mem_initializer_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|&&
operator|!
name|DECL_P
argument_list|(
name|member
argument_list|)
condition|)
name|in_base_initializer
operator|=
literal|1
expr_stmt|;
name|expression_list
operator|=
name|cp_parser_parenthesized_expression_list
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
comment|/*non_constant_p=*/
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_list
condition|)
name|expression_list
operator|=
name|void_type_node
expr_stmt|;
name|in_base_initializer
operator|=
literal|0
expr_stmt|;
return|return
name|member
condition|?
name|build_tree_list
argument_list|(
name|member
argument_list|,
name|expression_list
argument_list|)
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Parse a mem-initializer-id.     mem-initializer-id:      :: [opt] nested-name-specifier [opt] class-name      identifier       Returns a TYPE indicating the class to be initializer for the first    production.  Returns an IDENTIFIER_NODE indicating the data member    to be initialized for the second production.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_mem_initializer_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|bool
name|global_scope_p
decl_stmt|;
name|bool
name|nested_name_specifier_p
decl_stmt|;
name|bool
name|template_p
init|=
name|false
decl_stmt|;
name|tree
name|id
decl_stmt|;
comment|/* `typename' is not allowed in this context ([temp.res]).  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TYPENAME
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"keyword `typename' not allowed in this context (a qualified "
literal|"member initializer is implicitly a type)"
argument_list|)
expr_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* Look for the optional `::' operator.  */
name|global_scope_p
operator|=
operator|(
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Look for the optional nested-name-specifier.  The simplest way to      implement:         [temp.res]         The keyword `typename' is not permitted in a base-specifier or        mem-initializer; in these contexts a qualified name that        depends on a template-parameter is implicitly assumed to be a        type name.       is to assume that we have seen the `typename' keyword at this      point.  */
name|nested_name_specifier_p
operator|=
operator|(
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|true
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|true
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
if|if
condition|(
name|nested_name_specifier_p
condition|)
name|template_p
operator|=
name|cp_parser_optional_template_keyword
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If there is a `::' operator or a nested-name-specifier, then we      are definitely looking for a class-name.  */
if|if
condition|(
name|global_scope_p
operator|||
name|nested_name_specifier_p
condition|)
return|return
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|true
argument_list|,
comment|/*template_keyword_p=*/
name|template_p
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
return|;
comment|/* Otherwise, we could also be looking for an ordinary identifier.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try a class-name.  */
name|id
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|true
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
comment|/* If we found one, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|id
return|;
comment|/* Otherwise, look for an ordinary identifier.  */
return|return
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Overloading [gram.over] */
end_comment

begin_comment
comment|/* Parse an operator-function-id.     operator-function-id:      operator operator       Returns an IDENTIFIER_NODE for the operator which is a    human-readable spelling of the identifier, e.g., `operator +'.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_operator_function_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Look for the `operator' keyword.  */
if|if
condition|(
operator|!
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_OPERATOR
argument_list|,
literal|"`operator'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* And then the name of the operator itself.  */
return|return
name|cp_parser_operator
argument_list|(
name|parser
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an operator.     operator:      new delete new[] delete[] + - * / % ^& | ~ ! =<>      += -= *= /= %= ^=&= |=<<>>>>=<<= == !=<=>=&&      || ++ -- , ->* -> () []     GNU Extensions:        operator:<?>?<?=>?=     Returns an IDENTIFIER_NODE for the operator which is a    human-readable spelling of the identifier, e.g., `operator +'.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_operator
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|id
init|=
name|NULL_TREE
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Figure out which operator we have.  */
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_KEYWORD
case|:
block|{
name|enum
name|tree_code
name|op
decl_stmt|;
comment|/* The keyword should be either `new' or `delete'.  */
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_NEW
condition|)
name|op
operator|=
name|NEW_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_DELETE
condition|)
name|op
operator|=
name|DELETE_EXPR
expr_stmt|;
else|else
break|break;
comment|/* Consume the `new' or `delete' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's a `[' token then this is the array variant of the 	   operator.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_SQUARE
condition|)
block|{
comment|/* Consume the `[' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the `]' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"`]'"
argument_list|)
expr_stmt|;
name|id
operator|=
name|ansi_opname
argument_list|(
name|op
operator|==
name|NEW_EXPR
condition|?
name|VEC_NEW_EXPR
else|:
name|VEC_DELETE_EXPR
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, we have the non-array variant.  */
else|else
name|id
operator|=
name|ansi_opname
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
case|case
name|CPP_PLUS
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|PLUS_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MINUS
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|MINUS_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MULT
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|MULT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_DIV
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MOD
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_XOR
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|BIT_XOR_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_AND
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|BIT_AND_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_OR
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|BIT_IOR_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_COMPL
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|BIT_NOT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_NOT
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|NOP_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_LESS
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|LT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_GREATER
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|GT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_PLUS_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|PLUS_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MINUS_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|MINUS_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MULT_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|MULT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_DIV_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MOD_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_XOR_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|BIT_XOR_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_AND_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|BIT_AND_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_OR_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|BIT_IOR_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_LSHIFT
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|LSHIFT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_RSHIFT
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|RSHIFT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_LSHIFT_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|LSHIFT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_RSHIFT_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|RSHIFT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_EQ_EQ
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|EQ_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_NOT_EQ
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|NE_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_LESS_EQ
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|LE_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_GREATER_EQ
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|GE_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_AND_AND
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_OR_OR
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_PLUS_PLUS
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|POSTINCREMENT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MINUS_MINUS
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|PREDECREMENT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_COMMA
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|COMPOUND_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_DEREF_STAR
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|MEMBER_REF
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_DEREF
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|COMPONENT_REF
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_OPEN_PAREN
case|:
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the matching `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
return|return
name|ansi_opname
argument_list|(
name|CALL_EXPR
argument_list|)
return|;
case|case
name|CPP_OPEN_SQUARE
case|:
comment|/* Consume the `['.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the matching `]'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"`]'"
argument_list|)
expr_stmt|;
return|return
name|ansi_opname
argument_list|(
name|ARRAY_REF
argument_list|)
return|;
comment|/* Extensions.  */
case|case
name|CPP_MIN
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|MIN_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MAX
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|MAX_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MIN_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|MIN_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MAX_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|MAX_EXPR
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Anything else is an error.  */
break|break;
block|}
comment|/* If we have selected an identifier, we need to consume the      operator token.  */
if|if
condition|(
name|id
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Otherwise, no valid operator name was present.  */
else|else
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected operator"
argument_list|)
expr_stmt|;
name|id
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|id
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-declaration.     template-declaration:      export [opt] template< template-parameter-list> declaration       If MEMBER_P is TRUE, this template-declaration occurs within a    class-specifier.       The grammar rule given by the standard isn't correct.  What    is really meant is:     template-declaration:      export [opt] template-parameter-list-seq         decl-specifier-seq [opt] init-declarator [opt] ;      export [opt] template-parameter-list-seq         function-definition     template-parameter-list-seq:      template-parameter-list-seq [opt]      template< template-parameter-list>  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_template_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|member_p
parameter_list|)
block|{
comment|/* Check for `export'.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_EXPORT
argument_list|)
condition|)
block|{
comment|/* Consume the `export' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Warn that we do not support `export'.  */
name|warning
argument_list|(
literal|"keyword `export' not implemented, and will be ignored"
argument_list|)
expr_stmt|;
block|}
name|cp_parser_template_declaration_after_export
argument_list|(
name|parser
argument_list|,
name|member_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a template-parameter-list.     template-parameter-list:      template-parameter      template-parameter-list , template-parameter     Returns a TREE_LIST.  Each node represents a template parameter.    The nodes are connected via their TREE_CHAINs.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_template_parameter_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|parameter_list
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|parameter
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Parse the template-parameter.  */
name|parameter
operator|=
name|cp_parser_template_parameter
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Add it to the list.  */
name|parameter_list
operator|=
name|process_template_parm
argument_list|(
name|parameter_list
argument_list|,
name|parameter
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's not a `,', we're done.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_COMMA
condition|)
break|break;
comment|/* Otherwise, consume the `,' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
return|return
name|parameter_list
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-parameter.     template-parameter:      type-parameter      parameter-declaration     Returns a TREE_LIST.  The TREE_VALUE represents the parameter.  The    TREE_PURPOSE is the default value, if any.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_template_parameter
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it is `class' or `template', we have a type-parameter.  */
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_TEMPLATE
condition|)
return|return
name|cp_parser_type_parameter
argument_list|(
name|parser
argument_list|)
return|;
comment|/* If it is `class' or `typename' we do not know yet whether it is a      type parameter or a non-type parameter.  Consider:         template<typename T, typename T::X X> ...       or:              template<class C, class D*> ...       Here, the first parameter is a type parameter, and the second is      a non-type parameter.  We can tell by looking at the token after      the identifier -- if it is a `,', `=', or `>' then we have a type      parameter.  */
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_TYPENAME
operator|||
name|token
operator|->
name|keyword
operator|==
name|RID_CLASS
condition|)
block|{
comment|/* Peek at the token after `class' or `typename'.  */
name|token
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If it's an identifier, skip it.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
name|token
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Now, see if the token looks like the end of a template 	 parameter.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_EQ
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_GREATER
condition|)
return|return
name|cp_parser_type_parameter
argument_list|(
name|parser
argument_list|)
return|;
block|}
comment|/* Otherwise, it is a non-type parameter.         [temp.param]       When parsing a default template-argument for a non-type      template-parameter, the first non-nested `>' is taken as the end      of the template parameter-list rather than a greater-than      operator.  */
return|return
name|cp_parser_parameter_declaration
argument_list|(
name|parser
argument_list|,
comment|/*template_parm_p=*/
name|true
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a type-parameter.     type-parameter:      class identifier [opt]      class identifier [opt] = type-id      typename identifier [opt]      typename identifier [opt] = type-id      template< template-parameter-list> class identifier [opt]      template< template-parameter-list> class identifier [opt]         = id-expression       Returns a TREE_LIST.  The TREE_VALUE is itself a TREE_LIST.  The    TREE_PURPOSE is the default-argument, if any.  The TREE_VALUE is    the declaration of the parameter.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_type_parameter
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|parameter
decl_stmt|;
comment|/* Look for a keyword to tell us what kind of parameter this is.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|,
literal|"`class', `typename', or `template'"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_CLASS
case|:
case|case
name|RID_TYPENAME
case|:
block|{
name|tree
name|identifier
decl_stmt|;
name|tree
name|default_argument
decl_stmt|;
comment|/* If the next token is an identifier, then it names the            parameter.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|identifier
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Create the parameter.  */
name|parameter
operator|=
name|finish_template_type_parm
argument_list|(
name|class_type_node
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
comment|/* If the next token is an `=', we have a default argument.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EQ
argument_list|)
condition|)
block|{
comment|/* Consume the `=' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the default-argument.  */
name|default_argument
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
name|default_argument
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Create the combined representation of the parameter and the 	   default argument.  */
name|parameter
operator|=
name|build_tree_list
argument_list|(
name|default_argument
argument_list|,
name|parameter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RID_TEMPLATE
case|:
block|{
name|tree
name|parameter_list
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|tree
name|default_argument
decl_stmt|;
comment|/* Look for the `<'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|,
literal|"`<'"
argument_list|)
expr_stmt|;
comment|/* Parse the template-parameter-list.  */
name|begin_template_parm_list
argument_list|()
expr_stmt|;
name|parameter_list
operator|=
name|cp_parser_template_parameter_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parameter_list
operator|=
name|end_template_parm_list
argument_list|(
name|parameter_list
argument_list|)
expr_stmt|;
comment|/* Look for the `>'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_GREATER
argument_list|,
literal|"`>'"
argument_list|)
expr_stmt|;
comment|/* Look for the `class' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_CLASS
argument_list|,
literal|"`class'"
argument_list|)
expr_stmt|;
comment|/* If the next token is an `=', then there is a 	   default-argument.  If the next token is a `>', we are at 	   the end of the parameter-list.  If the next token is a `,', 	   then we are at the end of this parameter.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EQ
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_GREATER
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|identifier
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Create the template parameter.  */
name|parameter
operator|=
name|finish_template_template_parm
argument_list|(
name|class_type_node
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
comment|/* If the next token is an `=', then there is a 	   default-argument.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EQ
argument_list|)
condition|)
block|{
name|bool
name|is_template
decl_stmt|;
comment|/* Consume the `='.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the id-expression.  */
name|default_argument
operator|=
name|cp_parser_id_expression
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*template_p=*/
operator|&
name|is_template
argument_list|,
comment|/*declarator_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|default_argument
argument_list|)
operator|==
name|TYPE_DECL
condition|)
comment|/* If the id-expression was a template-id that refers to 		 a template-class, we already have the declaration here, 		 so no further lookup is needed.  */
empty_stmt|;
else|else
comment|/* Look up the name.  */
name|default_argument
operator|=
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|default_argument
argument_list|,
comment|/*is_type=*/
name|false
argument_list|,
comment|/*is_template=*/
name|is_template
argument_list|,
comment|/*is_namespace=*/
name|false
argument_list|,
comment|/*check_dependency=*/
name|true
argument_list|)
expr_stmt|;
comment|/* See if the default argument is valid.  */
name|default_argument
operator|=
name|check_template_template_default_arg
argument_list|(
name|default_argument
argument_list|)
expr_stmt|;
block|}
else|else
name|default_argument
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Create the combined representation of the parameter and the 	   default argument.  */
name|parameter
operator|=
name|build_tree_list
argument_list|(
name|default_argument
argument_list|,
name|parameter
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Anything else is an error.  */
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected `class', `typename', or `template'"
argument_list|)
expr_stmt|;
name|parameter
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|parameter
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-id.     template-id:      template-name< template-argument-list [opt]>     If TEMPLATE_KEYWORD_P is TRUE, then we have just seen the    `template' keyword.  In this case, a TEMPLATE_ID_EXPR will be    returned.  Otherwise, if the template-name names a function, or set    of functions, returns a TEMPLATE_ID_EXPR.  If the template-name    names a class, returns a TYPE_DECL for the specialization.       If CHECK_DEPENDENCY_P is FALSE, names are looked up in    uninstantiated templates.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_template_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|template_keyword_p
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
name|is_declaration
parameter_list|)
block|{
name|tree
name|template
decl_stmt|;
name|tree
name|arguments
decl_stmt|;
name|tree
name|template_id
decl_stmt|;
name|ptrdiff_t
name|start_of_id
decl_stmt|;
name|tree
name|access_check
init|=
name|NULL_TREE
decl_stmt|;
name|cp_token
modifier|*
name|next_token
decl_stmt|,
modifier|*
name|next_token_2
decl_stmt|;
name|bool
name|is_identifier
decl_stmt|;
comment|/* If the next token corresponds to a template-id, there is no need      to reparse it.  */
name|next_token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_token
operator|->
name|type
operator|==
name|CPP_TEMPLATE_ID
condition|)
block|{
name|tree
name|value
decl_stmt|;
name|tree
name|check
decl_stmt|;
comment|/* Get the stored value.  */
name|value
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|value
expr_stmt|;
comment|/* Perform any access checks that were deferred.  */
for|for
control|(
name|check
operator|=
name|TREE_PURPOSE
argument_list|(
name|value
argument_list|)
init|;
name|check
condition|;
name|check
operator|=
name|TREE_CHAIN
argument_list|(
name|check
argument_list|)
control|)
name|perform_or_defer_access_check
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|check
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|check
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the stored value.  */
return|return
name|TREE_VALUE
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/* Avoid performing name lookup if there is no possibility of      finding a template-id.  */
if|if
condition|(
operator|(
name|next_token
operator|->
name|type
operator|!=
name|CPP_NAME
operator|&&
name|next_token
operator|->
name|keyword
operator|!=
name|RID_OPERATOR
operator|)
operator|||
operator|(
name|next_token
operator|->
name|type
operator|==
name|CPP_NAME
operator|&&
operator|!
name|cp_parser_nth_token_starts_template_argument_list_p
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-id"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Remember where the template-id starts.  */
if|if
condition|(
name|cp_parser_parsing_tentatively
argument_list|(
name|parser
argument_list|)
operator|&&
operator|!
name|cp_parser_committed_to_tentative_parse
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|next_token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|start_of_id
operator|=
name|cp_lexer_token_difference
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|parser
operator|->
name|lexer
operator|->
name|first_token
argument_list|,
name|next_token
argument_list|)
expr_stmt|;
block|}
else|else
name|start_of_id
operator|=
operator|-
literal|1
expr_stmt|;
name|push_deferring_access_checks
argument_list|(
name|dk_deferred
argument_list|)
expr_stmt|;
comment|/* Parse the template-name.  */
name|is_identifier
operator|=
name|false
expr_stmt|;
name|template
operator|=
name|cp_parser_template_name
argument_list|(
name|parser
argument_list|,
name|template_keyword_p
argument_list|,
name|check_dependency_p
argument_list|,
name|is_declaration
argument_list|,
operator|&
name|is_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|template
operator|==
name|error_mark_node
operator|||
name|is_identifier
condition|)
block|{
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|template
return|;
block|}
comment|/* If we find the sequence `[:' after a template-name, it's probably       a digraph-typo for `< ::'. Substitute the tokens and check if we can      parse correctly the argument list.  */
name|next_token
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|next_token_2
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_token
operator|->
name|type
operator|==
name|CPP_OPEN_SQUARE
operator|&&
name|next_token
operator|->
name|flags
operator|&
name|DIGRAPH
operator|&&
name|next_token_2
operator|->
name|type
operator|==
name|CPP_COLON
operator|&&
operator|!
operator|(
name|next_token_2
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|)
condition|)
block|{
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Change `:' into `::'.  */
name|next_token_2
operator|->
name|type
operator|=
name|CPP_SCOPE
expr_stmt|;
comment|/* Consume the first token (CPP_OPEN_SQUARE - which we pretend it is          CPP_LESS.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the arguments.  */
name|arguments
operator|=
name|cp_parser_enclosed_template_argument_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* If we couldn't parse an argument list, then we revert our changes 	     and return simply an error. Maybe this is not a template-id 	     after all.  */
name|next_token_2
operator|->
name|type
operator|=
name|CPP_COLON
expr_stmt|;
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected `<'"
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Otherwise, emit an error about the invalid digraph, but continue          parsing because we got our argument list.  */
name|pedwarn
argument_list|(
literal|"`<::' cannot begin a template-argument list"
argument_list|)
expr_stmt|;
name|inform
argument_list|(
literal|"`<:' is an alternate spelling for `['. Insert whitespace "
literal|"between `<' and `::'"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_permissive
condition|)
block|{
specifier|static
name|bool
name|hint
decl_stmt|;
if|if
condition|(
operator|!
name|hint
condition|)
block|{
name|inform
argument_list|(
literal|"(if you use `-fpermissive' G++ will accept your code)"
argument_list|)
expr_stmt|;
name|hint
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Look for the `<' that starts the template-argument-list.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|,
literal|"`<'"
argument_list|)
condition|)
block|{
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Parse the arguments.  */
name|arguments
operator|=
name|cp_parser_enclosed_template_argument_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Build a representation of the specialization.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|template_id
operator|=
name|build_min_nt
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|template
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|template
argument_list|)
operator|||
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|template
argument_list|)
condition|)
name|template_id
operator|=
name|finish_template_type
argument_list|(
name|template
argument_list|,
name|arguments
argument_list|,
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If it's not a class-template or a template-template, it should be 	 a function-template.  */
name|my_friendly_assert
argument_list|(
operator|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|template
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|==
name|OVERLOAD
operator|||
name|BASELINK_P
argument_list|(
name|template
argument_list|)
operator|)
argument_list|,
literal|20010716
argument_list|)
expr_stmt|;
name|template_id
operator|=
name|lookup_template_function
argument_list|(
name|template
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
block|}
comment|/* Retrieve any deferred checks.  Do not pop this access checks yet      so the memory will not be reclaimed during token replacing below.  */
name|access_check
operator|=
name|get_deferred_access_checks
argument_list|()
expr_stmt|;
comment|/* If parsing tentatively, replace the sequence of tokens that makes      up the template-id with a CPP_TEMPLATE_ID token.  That way,      should we re-parse the token stream, we will not have to repeat      the effort required to do the parse, nor will we issue duplicate      error messages about problems during instantiation of the      template.  */
if|if
condition|(
name|start_of_id
operator|>=
literal|0
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Find the token that corresponds to the start of the 	 template-id.  */
name|token
operator|=
name|cp_lexer_advance_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|parser
operator|->
name|lexer
operator|->
name|first_token
argument_list|,
name|start_of_id
argument_list|)
expr_stmt|;
comment|/* Reset the contents of the START_OF_ID token.  */
name|token
operator|->
name|type
operator|=
name|CPP_TEMPLATE_ID
expr_stmt|;
name|token
operator|->
name|value
operator|=
name|build_tree_list
argument_list|(
name|access_check
argument_list|,
name|template_id
argument_list|)
expr_stmt|;
name|token
operator|->
name|keyword
operator|=
name|RID_MAX
expr_stmt|;
comment|/* Purge all subsequent tokens.  */
name|cp_lexer_purge_tokens_after
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|template_id
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-name.     template-name:      identifier      The standard should actually say:     template-name:      identifier      operator-function-id     A defect report has been filed about this issue.     A conversion-function-id cannot be a template name because they cannot    be part of a template-id. In fact, looking at this code:     a.operator K<int>()     the conversion-function-id is "operator K<int>", and K<int> is a type-id.    It is impossible to call a templated conversion-function-id with an     explicit argument list, since the only allowed template parameter is    the type to which it is converting.     If TEMPLATE_KEYWORD_P is true, then we have just seen the    `template' keyword, in a construction like:       T::template f<3>()     In that case `f' is taken to be a template-name, even though there    is no way of knowing for sure.     Returns the TEMPLATE_DECL for the template, or an OVERLOAD if the    name refers to a set of overloaded functions, at least one of which    is a template, or an IDENTIFIER_NODE with the name of the template,    if TEMPLATE_KEYWORD_P is true.  If CHECK_DEPENDENCY_P is FALSE,    names are looked up inside uninstantiated templates.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_template_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|template_keyword_p
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
name|is_declaration
parameter_list|,
name|bool
modifier|*
name|is_identifier
parameter_list|)
block|{
name|tree
name|identifier
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|fns
decl_stmt|;
comment|/* If the next token is `operator', then we have either an      operator-function-id or a conversion-function-id.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_OPERATOR
argument_list|)
condition|)
block|{
comment|/* We don't know whether we're looking at an 	 operator-function-id or a conversion-function-id.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try an operator-function-id.  */
name|identifier
operator|=
name|cp_parser_operator_function_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If that didn't work, try a conversion-function-id.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-name"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Look for the identifier.  */
else|else
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If we didn't find an identifier, we don't have a template-id.  */
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* If the name immediately followed the `template' keyword, then it      is a template-name.  However, if the next token is not `<', then      we do not treat it as a template-name, since it is not being used      as part of a template-id.  This enables us to handle constructs      like:         template<typename T> struct S { S(); };        template<typename T> S<T>::S();       correctly.  We would treat `S' as a template -- if it were `S<T>'      -- but we do not if there is no `<'.  */
if|if
condition|(
name|processing_template_decl
operator|&&
name|cp_parser_nth_token_starts_template_argument_list_p
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* In a declaration, in a dependent context, we pretend that the 	 "template" keyword was present in order to improve error 	 recovery.  For example, given: 	  	   template<typename T> void f(T::X<int>); 	  	 we want to treat "X<int>" as a template-id.  */
if|if
condition|(
name|is_declaration
operator|&&
operator|!
name|template_keyword_p
operator|&&
name|parser
operator|->
name|scope
operator|&&
name|TYPE_P
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
comment|/* Do not do this for dtors (or ctors), since they never 	     need the template keyword before their name.  */
operator|&&
operator|!
name|constructor_name_p
argument_list|(
name|identifier
argument_list|,
name|parser
operator|->
name|scope
argument_list|)
condition|)
block|{
name|ptrdiff_t
name|start
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Explain what went wrong.  */
name|error
argument_list|(
literal|"non-template `%D' used as template"
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
name|inform
argument_list|(
literal|"use `%T::template %D' to indicate that it is a template"
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
comment|/* If parsing tentatively, find the location of the "<" 	     token.  */
if|if
condition|(
name|cp_parser_parsing_tentatively
argument_list|(
name|parser
argument_list|)
operator|&&
operator|!
name|cp_parser_committed_to_tentative_parse
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_prev_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|start
operator|=
name|cp_lexer_token_difference
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|parser
operator|->
name|lexer
operator|->
name|first_token
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
else|else
name|start
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Parse the template arguments so that we can issue error 	     messages about them.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|cp_parser_enclosed_template_argument_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Skip tokens until we find a good place from which to 	     continue parsing.  */
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
comment|/*recovering=*/
name|true
argument_list|,
comment|/*or_comma=*/
name|true
argument_list|,
comment|/*consume_paren=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If parsing tentatively, permanently remove the 	     template argument list.  That will prevent duplicate 	     error messages from being issued about the missing 	     "template" keyword.  */
if|if
condition|(
name|start
operator|>=
literal|0
condition|)
block|{
name|token
operator|=
name|cp_lexer_advance_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|parser
operator|->
name|lexer
operator|->
name|first_token
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|cp_lexer_purge_tokens_after
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_identifier
condition|)
operator|*
name|is_identifier
operator|=
name|true
expr_stmt|;
return|return
name|identifier
return|;
block|}
comment|/* If the "template" keyword is present, then there is generally 	 no point in doing name-lookup, so we just return IDENTIFIER. 	 But, if the qualifying scope is non-dependent then we can 	 (and must) do name-lookup normally.  */
if|if
condition|(
name|template_keyword_p
operator|&&
operator|(
operator|!
name|parser
operator|->
name|scope
operator|||
operator|(
name|TYPE_P
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|)
operator|)
condition|)
return|return
name|identifier
return|;
block|}
comment|/* Look up the name.  */
name|decl
operator|=
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|,
comment|/*is_type=*/
name|false
argument_list|,
comment|/*is_template=*/
name|false
argument_list|,
comment|/*is_namespace=*/
name|false
argument_list|,
name|check_dependency_p
argument_list|)
expr_stmt|;
name|decl
operator|=
name|maybe_get_template_decl_from_type_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If DECL is a template, then the name was a template-name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
empty_stmt|;
else|else
block|{
comment|/* The standard does not explicitly indicate whether a name that 	 names a set of overloaded declarations, some of which are 	 templates, is a template-name.  However, such a name should 	 be a template-name; otherwise, there is no way to form a 	 template-id for the overloaded templates.  */
name|fns
operator|=
name|BASELINK_P
argument_list|(
name|decl
argument_list|)
condition|?
name|BASELINK_FUNCTIONS
argument_list|(
name|decl
argument_list|)
else|:
name|decl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
name|tree
name|fn
decl_stmt|;
for|for
control|(
name|fn
operator|=
name|fns
init|;
name|fn
condition|;
name|fn
operator|=
name|OVL_NEXT
argument_list|(
name|fn
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
break|break;
block|}
else|else
block|{
comment|/* Otherwise, the name does not name a template.  */
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-name"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* If DECL is dependent, and refers to a function, then just return      its name; we will look it up again during template instantiation.  */
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|scope
init|=
name|CP_DECL_CONTEXT
argument_list|(
name|get_first_fn
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|scope
argument_list|)
condition|)
return|return
name|identifier
return|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-argument-list.     template-argument-list:      template-argument      template-argument-list , template-argument     Returns a TREE_VEC containing the arguments.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_template_argument_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|fixed_args
index|[
literal|10
index|]
decl_stmt|;
name|unsigned
name|n_args
init|=
literal|0
decl_stmt|;
name|unsigned
name|alloced
init|=
literal|10
decl_stmt|;
name|tree
modifier|*
name|arg_ary
init|=
name|fixed_args
decl_stmt|;
name|tree
name|vec
decl_stmt|;
name|bool
name|saved_in_template_argument_list_p
decl_stmt|;
name|saved_in_template_argument_list_p
operator|=
name|parser
operator|->
name|in_template_argument_list_p
expr_stmt|;
name|parser
operator|->
name|in_template_argument_list_p
operator|=
name|true
expr_stmt|;
do|do
block|{
name|tree
name|argument
decl_stmt|;
if|if
condition|(
name|n_args
condition|)
comment|/* Consume the comma.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the template-argument.  */
name|argument
operator|=
name|cp_parser_template_argument
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_args
operator|==
name|alloced
condition|)
block|{
name|alloced
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|arg_ary
operator|==
name|fixed_args
condition|)
block|{
name|arg_ary
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|alloced
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|arg_ary
argument_list|,
name|fixed_args
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|n_args
argument_list|)
expr_stmt|;
block|}
else|else
name|arg_ary
operator|=
name|xrealloc
argument_list|(
name|arg_ary
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|alloced
argument_list|)
expr_stmt|;
block|}
name|arg_ary
index|[
name|n_args
operator|++
index|]
operator|=
name|argument
expr_stmt|;
block|}
do|while
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
do|;
name|vec
operator|=
name|make_tree_vec
argument_list|(
name|n_args
argument_list|)
expr_stmt|;
while|while
condition|(
name|n_args
operator|--
condition|)
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|n_args
argument_list|)
operator|=
name|arg_ary
index|[
name|n_args
index|]
expr_stmt|;
if|if
condition|(
name|arg_ary
operator|!=
name|fixed_args
condition|)
name|free
argument_list|(
name|arg_ary
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_template_argument_list_p
operator|=
name|saved_in_template_argument_list_p
expr_stmt|;
return|return
name|vec
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-argument.     template-argument:      assignment-expression      type-id      id-expression     The representation is that of an assignment-expression, type-id, or    id-expression -- except that the qualified id-expression is    evaluated, so that the value returned is either a DECL or an    OVERLOAD.       Although the standard says "assignment-expression", it forbids    throw-expressions or assignments in the template argument.    Therefore, we use "conditional-expression" instead.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_template_argument
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|argument
decl_stmt|;
name|bool
name|template_p
decl_stmt|;
name|bool
name|address_p
decl_stmt|;
name|bool
name|maybe_type_id
init|=
name|false
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|cp_id_kind
name|idk
decl_stmt|;
name|tree
name|qualifying_class
decl_stmt|;
comment|/* There's really no way to know what we're looking at, so we just      try each alternative in order.           [temp.arg]         In a template-argument, an ambiguity between a type-id and an        expression is resolved to a type-id, regardless of the form of        the corresponding template-parameter.         Therefore, we try a type-id first.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|argument
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If there was no error parsing the type-id but the next token is a '>>',      we probably found a typo for '>>'. But there are type-id which are       also valid expressions. For instance:       struct X { int operator>> (int); };      template<int V> struct Foo {};      Foo<X ()>> 5> r;       Here 'X()' is a valid type-id of a function type, but the user just      wanted to write the expression "X()>> 5". Thus, we remember that we      found a valid type-id, but we still try to parse the argument as an      expression to see what happens.  */
if|if
condition|(
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_RSHIFT
argument_list|)
condition|)
block|{
name|maybe_type_id
operator|=
name|true
expr_stmt|;
name|cp_parser_abort_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the next token isn't a `,' or a `>', then this argument wasn't       really finished. This means that the argument is not a valid       type-id.  */
if|if
condition|(
operator|!
name|cp_parser_next_token_ends_template_argument_p
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-argument"
argument_list|)
expr_stmt|;
comment|/* If that worked, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|argument
return|;
block|}
comment|/* We're still not sure what the argument will be.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try a template.  */
name|argument
operator|=
name|cp_parser_id_expression
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
operator|&
name|template_p
argument_list|,
comment|/*declarator_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If the next token isn't a `,' or a `>', then this argument wasn't      really finished.  */
if|if
condition|(
operator|!
name|cp_parser_next_token_ends_template_argument_p
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-argument"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* Figure out what is being referred to.  If the id-expression 	 was for a class template specialization, then we will have a 	 TYPE_DECL at this point.  There is no need to do name lookup 	 at this point in that case.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|argument
operator|=
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|argument
argument_list|,
comment|/*is_type=*/
name|false
argument_list|,
comment|/*is_template=*/
name|template_p
argument_list|,
comment|/*is_namespace=*/
name|false
argument_list|,
comment|/*check_dependency=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|!=
name|UNBOUND_CLASS_TEMPLATE
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-name"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|argument
return|;
comment|/* It must be a non-type argument.  There permitted cases are given      in [temp.arg.nontype]:       -- an integral constant-expression of integral or enumeration         type; or       -- the name of a non-type template-parameter; or       -- the name of an object or function with external linkage...       -- the address of an object or function with external linkage...       -- a pointer to member...  */
comment|/* Look for a non-type template parameter.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|argument
operator|=
name|cp_parser_primary_expression
argument_list|(
name|parser
argument_list|,
operator|&
name|idk
argument_list|,
operator|&
name|qualifying_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|!=
name|TEMPLATE_PARM_INDEX
operator|||
operator|!
name|cp_parser_next_token_ends_template_argument_p
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|argument
return|;
block|}
comment|/* If the next token is "&", the argument must be the address of an      object or function with external linkage.  */
name|address_p
operator|=
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_AND
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_p
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* See if we might have an id-expression.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
operator|||
name|token
operator|->
name|keyword
operator|==
name|RID_OPERATOR
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_SCOPE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_TEMPLATE_ID
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_NESTED_NAME_SPECIFIER
condition|)
block|{
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|argument
operator|=
name|cp_parser_primary_expression
argument_list|(
name|parser
argument_list|,
operator|&
name|idk
argument_list|,
operator|&
name|qualifying_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
operator|||
operator|!
name|cp_parser_next_token_ends_template_argument_p
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_abort_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|qualifying_class
condition|)
name|argument
operator|=
name|finish_qualified_id_expr
argument_list|(
name|qualifying_class
argument_list|,
name|argument
argument_list|,
comment|/*done=*/
name|true
argument_list|,
name|address_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* A variable without external linkage might still be a 		 valid constant-expression, so no error is issued here 		 if the external-linkage check fails.  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL_LINKAGE_P
argument_list|(
name|argument
argument_list|)
condition|)
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|argument
argument_list|)
condition|)
comment|/* All overloaded functions are allowed; if the external 	       linkage test does not pass, an error will be issued 	       later.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|address_p
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|==
name|OFFSET_REF
operator|||
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|==
name|SCOPE_REF
operator|)
condition|)
comment|/* A pointer-to-member.  */
empty_stmt|;
else|else
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
if|if
condition|(
name|address_p
condition|)
name|argument
operator|=
name|build_x_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|argument
argument_list|)
expr_stmt|;
return|return
name|argument
return|;
block|}
block|}
block|}
comment|/* If the argument started with "&", there are no other valid      alternatives at this point.  */
if|if
condition|(
name|address_p
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"invalid non-type template argument"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If the argument wasn't successfully parsed as a type-id followed      by '>>', the argument can only be a constant expression now.        Otherwise, we try parsing the constant-expression tentatively,      because the argument could really be a type-id.  */
if|if
condition|(
name|maybe_type_id
condition|)
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|argument
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant_p=*/
name|false
argument_list|,
comment|/*non_constant_p=*/
name|NULL
argument_list|)
expr_stmt|;
name|argument
operator|=
name|fold_non_dependent_expr
argument_list|(
name|argument
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|maybe_type_id
condition|)
return|return
name|argument
return|;
if|if
condition|(
operator|!
name|cp_parser_next_token_ends_template_argument_p
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-argument"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|argument
return|;
comment|/* We did our best to parse the argument as a non type-id, but that      was the only alternative that matched (albeit with a '>' after      it). We can assume it's just a typo from the user, and a       diagnostic will then be issued.  */
return|return
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an explicit-instantiation.     explicit-instantiation:      template declaration       Although the standard says `declaration', what it really means is:     explicit-instantiation:      template decl-specifier-seq [opt] declarator [opt] ;      Things like `template int S<int>::i = 5, int S<double>::j;' are not    supposed to be allowed.  A defect report has been filed about this    issue.       GNU Extension:       explicit-instantiation:      storage-class-specifier template         decl-specifier-seq [opt] declarator [opt] ;      function-specifier template         decl-specifier-seq [opt] declarator [opt] ;  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_explicit_instantiation
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|int
name|declares_class_or_enum
decl_stmt|;
name|tree
name|decl_specifiers
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|tree
name|extension_specifier
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Look for an (optional) storage-class-specifier or      function-specifier.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|extension_specifier
operator|=
name|cp_parser_storage_class_specifier_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extension_specifier
condition|)
name|extension_specifier
operator|=
name|cp_parser_function_specifier_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Look for the `template' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_TEMPLATE
argument_list|,
literal|"`template'"
argument_list|)
expr_stmt|;
comment|/* Let the front end know that we are processing an explicit      instantiation.  */
name|begin_explicit_instantiation
argument_list|()
expr_stmt|;
comment|/* [temp.explicit] says that we are supposed to ignore access      control while processing explicit instantiation directives.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
comment|/* Parse a decl-specifier-seq.  */
name|decl_specifiers
operator|=
name|cp_parser_decl_specifier_seq
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_FLAGS_OPTIONAL
argument_list|,
operator|&
name|attributes
argument_list|,
operator|&
name|declares_class_or_enum
argument_list|)
expr_stmt|;
comment|/* If there was exactly one decl-specifier, and it declared a class,      and there's no declarator, then we have an explicit type      instantiation.  */
if|if
condition|(
name|declares_class_or_enum
operator|&&
name|cp_parser_declares_only_class_p
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|check_tag_decl
argument_list|(
name|decl_specifiers
argument_list|)
expr_stmt|;
comment|/* Turn access control back on for names used during 	 template instantiation.  */
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|do_type_instantiation
argument_list|(
name|type
argument_list|,
name|extension_specifier
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|declarator
decl_stmt|;
name|tree
name|decl
decl_stmt|;
comment|/* Parse the declarator.  */
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_NAMED
argument_list|,
comment|/*ctor_dtor_or_conv_p=*/
name|NULL
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|)
expr_stmt|;
name|cp_parser_check_for_definition_in_return_type
argument_list|(
name|declarator
argument_list|,
name|declares_class_or_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|!=
name|error_mark_node
condition|)
block|{
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|decl_specifiers
argument_list|,
name|NORMAL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Turn access control back on for names used during 	     template instantiation.  */
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Do the explicit instantiation.  */
name|do_decl_instantiation
argument_list|(
name|decl
argument_list|,
name|extension_specifier
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Skip the body of the explicit instantiation.  */
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We're done with the instantiation.  */
name|end_explicit_instantiation
argument_list|()
expr_stmt|;
name|cp_parser_consume_semicolon_at_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an explicit-specialization.     explicit-specialization:      template<> declaration       Although the standard says `declaration', what it really means is:     explicit-specialization:      template<> decl-specifier [opt] init-declarator [opt] ;      template<> function-definition       template<> explicit-specialization      template<> template-declaration  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_explicit_specialization
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Look for the `template' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_TEMPLATE
argument_list|,
literal|"`template'"
argument_list|)
expr_stmt|;
comment|/* Look for the `<'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|,
literal|"`<'"
argument_list|)
expr_stmt|;
comment|/* Look for the `>'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_GREATER
argument_list|,
literal|"`>'"
argument_list|)
expr_stmt|;
comment|/* We have processed another parameter list.  */
operator|++
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
comment|/* Let the front end know that we are beginning a specialization.  */
name|begin_specialization
argument_list|()
expr_stmt|;
comment|/* If the next keyword is `template', we need to figure out whether      or not we're looking a template-declaration.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TEMPLATE
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|==
name|CPP_LESS
operator|&&
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|3
argument_list|)
operator|->
name|type
operator|!=
name|CPP_GREATER
condition|)
name|cp_parser_template_declaration_after_export
argument_list|(
name|parser
argument_list|,
comment|/*member_p=*/
name|false
argument_list|)
expr_stmt|;
else|else
name|cp_parser_explicit_specialization
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Parse the dependent declaration.  */
name|cp_parser_single_declaration
argument_list|(
name|parser
argument_list|,
comment|/*member_p=*/
name|false
argument_list|,
comment|/*friend_p=*/
name|NULL
argument_list|)
expr_stmt|;
comment|/* We're done with the specialization.  */
name|end_specialization
argument_list|()
expr_stmt|;
comment|/* We're done with this parameter list.  */
operator|--
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a type-specifier.     type-specifier:      simple-type-specifier      class-specifier      enum-specifier      elaborated-type-specifier      cv-qualifier     GNU Extension:     type-specifier:      __complex__     Returns a representation of the type-specifier.  If the    type-specifier is a keyword (like `int' or `const', or    `__complex__') then the corresponding IDENTIFIER_NODE is returned.    For a class-specifier, enum-specifier, or elaborated-type-specifier    a TREE_TYPE is returned; otherwise, a TYPE_DECL is returned.     If IS_FRIEND is TRUE then this type-specifier is being declared a    `friend'.  If IS_DECLARATION is TRUE, then this type-specifier is    appearing in a decl-specifier-seq.     If DECLARES_CLASS_OR_ENUM is non-NULL, and the type-specifier is a    class-specifier, enum-specifier, or elaborated-type-specifier, then    *DECLARES_CLASS_OR_ENUM is set to a nonzero value.  The value is 1    if a type is declared; 2 if it is defined.  Otherwise, it is set to    zero.     If IS_CV_QUALIFIER is non-NULL, and the type-specifier is a    cv-qualifier, then IS_CV_QUALIFIER is set to TRUE.  Otherwise, it    is set to FALSE.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_type_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_parser_flags
name|flags
parameter_list|,
name|bool
name|is_friend
parameter_list|,
name|bool
name|is_declaration
parameter_list|,
name|int
modifier|*
name|declares_class_or_enum
parameter_list|,
name|bool
modifier|*
name|is_cv_qualifier
parameter_list|)
block|{
name|tree
name|type_spec
init|=
name|NULL_TREE
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|rid
name|keyword
decl_stmt|;
comment|/* Assume this type-specifier does not declare a new type.  */
if|if
condition|(
name|declares_class_or_enum
condition|)
operator|*
name|declares_class_or_enum
operator|=
literal|0
expr_stmt|;
comment|/* And that it does not specify a cv-qualifier.  */
if|if
condition|(
name|is_cv_qualifier
condition|)
operator|*
name|is_cv_qualifier
operator|=
name|false
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If we're looking at a keyword, we can use that to guide the      production we choose.  */
name|keyword
operator|=
name|token
operator|->
name|keyword
expr_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
comment|/* Any of these indicate either a class-specifier, or an 	 elaborated-type-specifier.  */
case|case
name|RID_CLASS
case|:
case|case
name|RID_STRUCT
case|:
case|case
name|RID_UNION
case|:
case|case
name|RID_ENUM
case|:
comment|/* Parse tentatively so that we can back up if we don't find a 	 class-specifier or enum-specifier.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the class-specifier or enum-specifier.  */
if|if
condition|(
name|keyword
operator|==
name|RID_ENUM
condition|)
name|type_spec
operator|=
name|cp_parser_enum_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|type_spec
operator|=
name|cp_parser_class_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If that worked, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
if|if
condition|(
name|declares_class_or_enum
condition|)
operator|*
name|declares_class_or_enum
operator|=
literal|2
expr_stmt|;
return|return
name|type_spec
return|;
block|}
comment|/* Fall through.  */
case|case
name|RID_TYPENAME
case|:
comment|/* Look for an elaborated-type-specifier.  */
name|type_spec
operator|=
name|cp_parser_elaborated_type_specifier
argument_list|(
name|parser
argument_list|,
name|is_friend
argument_list|,
name|is_declaration
argument_list|)
expr_stmt|;
comment|/* We're declaring a class or enum -- unless we're using 	 `typename'.  */
if|if
condition|(
name|declares_class_or_enum
operator|&&
name|keyword
operator|!=
name|RID_TYPENAME
condition|)
operator|*
name|declares_class_or_enum
operator|=
literal|1
expr_stmt|;
return|return
name|type_spec
return|;
case|case
name|RID_CONST
case|:
case|case
name|RID_VOLATILE
case|:
case|case
name|RID_RESTRICT
case|:
name|type_spec
operator|=
name|cp_parser_cv_qualifier_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Even though we call a routine that looks for an optional 	 qualifier, we know that there should be one.  */
name|my_friendly_assert
argument_list|(
name|type_spec
operator|!=
name|NULL
argument_list|,
literal|20000328
argument_list|)
expr_stmt|;
comment|/* This type-specifier was a cv-qualified.  */
if|if
condition|(
name|is_cv_qualifier
condition|)
operator|*
name|is_cv_qualifier
operator|=
name|true
expr_stmt|;
return|return
name|type_spec
return|;
case|case
name|RID_COMPLEX
case|:
comment|/* The `__complex__' keyword is a GNU extension.  */
return|return
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|value
return|;
default|default:
break|break;
block|}
comment|/* If we do not already have a type-specifier, assume we are looking      at a simple-type-specifier.  */
name|type_spec
operator|=
name|cp_parser_simple_type_specifier
argument_list|(
name|parser
argument_list|,
name|flags
argument_list|,
comment|/*identifier_p=*/
name|true
argument_list|)
expr_stmt|;
comment|/* If we didn't find a type-specifier, and a type-specifier was not      optional in this context, issue an error message.  */
if|if
condition|(
operator|!
name|type_spec
operator|&&
operator|!
operator|(
name|flags
operator|&
name|CP_PARSER_FLAGS_OPTIONAL
operator|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected type specifier"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|type_spec
return|;
block|}
end_function

begin_comment
comment|/* Parse a simple-type-specifier.     simple-type-specifier:      :: [opt] nested-name-specifier [opt] type-name      :: [opt] nested-name-specifier template template-id      char      wchar_t      bool      short      int      long      signed      unsigned      float      double      void       GNU Extension:     simple-type-specifier:      __typeof__ unary-expression      __typeof__ ( type-id )     For the various keywords, the value returned is simply the    TREE_IDENTIFIER representing the keyword if IDENTIFIER_P is true.    For the first two productions, and if IDENTIFIER_P is false, the    value returned is the indicated TYPE_DECL.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_simple_type_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_parser_flags
name|flags
parameter_list|,
name|bool
name|identifier_p
parameter_list|)
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If we're looking at a keyword, things are easy.  */
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_CHAR
case|:
name|type
operator|=
name|char_type_node
expr_stmt|;
break|break;
case|case
name|RID_WCHAR
case|:
name|type
operator|=
name|wchar_type_node
expr_stmt|;
break|break;
case|case
name|RID_BOOL
case|:
name|type
operator|=
name|boolean_type_node
expr_stmt|;
break|break;
case|case
name|RID_SHORT
case|:
name|type
operator|=
name|short_integer_type_node
expr_stmt|;
break|break;
case|case
name|RID_INT
case|:
name|type
operator|=
name|integer_type_node
expr_stmt|;
break|break;
case|case
name|RID_LONG
case|:
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
break|break;
case|case
name|RID_SIGNED
case|:
name|type
operator|=
name|integer_type_node
expr_stmt|;
break|break;
case|case
name|RID_UNSIGNED
case|:
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
break|break;
case|case
name|RID_FLOAT
case|:
name|type
operator|=
name|float_type_node
expr_stmt|;
break|break;
case|case
name|RID_DOUBLE
case|:
name|type
operator|=
name|double_type_node
expr_stmt|;
break|break;
case|case
name|RID_VOID
case|:
name|type
operator|=
name|void_type_node
expr_stmt|;
break|break;
case|case
name|RID_TYPEOF
case|:
block|{
name|tree
name|operand
decl_stmt|;
comment|/* Consume the `typeof' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the operand to `typeof'.  */
name|operand
operator|=
name|cp_parser_sizeof_operand
argument_list|(
name|parser
argument_list|,
name|RID_TYPEOF
argument_list|)
expr_stmt|;
comment|/* If it is not already a TYPE, take its type.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|operand
argument_list|)
condition|)
name|operand
operator|=
name|finish_typeof
argument_list|(
name|operand
argument_list|)
expr_stmt|;
return|return
name|operand
return|;
block|}
default|default:
break|break;
block|}
comment|/* If the type-specifier was for a built-in type, we're done.  */
if|if
condition|(
name|type
condition|)
block|{
name|tree
name|id
decl_stmt|;
comment|/* Consume the token.  */
name|id
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|value
expr_stmt|;
comment|/* There is no valid C++ program where a non-template type is 	 followed by a "<".  That usually indicates that the user thought 	 that the type was a template.  */
name|cp_parser_check_for_invalid_template_id
argument_list|(
name|parser
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|identifier_p
condition|?
name|id
else|:
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/* The type-specifier must be a user-defined type.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES
operator|)
condition|)
block|{
name|bool
name|qualified_p
decl_stmt|;
name|bool
name|global_p
decl_stmt|;
comment|/* Don't gobble tokens or issue error messages if this is an 	 optional type-specifier.  */
if|if
condition|(
name|flags
operator|&
name|CP_PARSER_FLAGS_OPTIONAL
condition|)
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the optional `::' operator.  */
name|global_p
operator|=
operator|(
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Look for the nested-name specifier.  */
name|qualified_p
operator|=
operator|(
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* If we have seen a nested-name-specifier, and the next token 	 is `template', then we are using the template-id production.  */
if|if
condition|(
name|parser
operator|->
name|scope
operator|&&
name|cp_parser_optional_template_keyword
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* Look for the template-id.  */
name|type
operator|=
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|true
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If the template-id did not name a type, we are out of 	     luck.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-id for type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* Otherwise, look for a type-name.  */
else|else
name|type
operator|=
name|cp_parser_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Keep track of all name-lookups performed in class scopes.  */
if|if
condition|(
name|type
operator|&&
operator|!
name|global_p
operator|&&
operator|!
name|qualified_p
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|maybe_note_name_used_in_class
argument_list|(
name|DECL_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If it didn't work out, we don't have a TYPE.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|CP_PARSER_FLAGS_OPTIONAL
operator|)
operator|&&
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* If we didn't get a type-name, issue an error message.  */
if|if
condition|(
operator|!
name|type
operator|&&
operator|!
operator|(
name|flags
operator|&
name|CP_PARSER_FLAGS_OPTIONAL
operator|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected type-name"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* There is no valid C++ program where a non-template type is      followed by a "<".  That usually indicates that the user thought      that the type was a template.  */
if|if
condition|(
name|type
operator|&&
name|type
operator|!=
name|error_mark_node
condition|)
name|cp_parser_check_for_invalid_template_id
argument_list|(
name|parser
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Parse a type-name.     type-name:      class-name      enum-name      typedef-name       enum-name:      identifier     typedef-name:      identifier      Returns a TYPE_DECL for the the type.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_type_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|type_decl
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
comment|/* We can't know yet whether it is a class-name or not.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try a class-name.  */
name|type_decl
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If it's not a class-name, keep looking.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* It must be a typedef-name or an enum-name.  */
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Look up the type-name.  */
name|type_decl
operator|=
name|cp_parser_lookup_name_simple
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
comment|/* Issue an error if we did not find a type-name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
operator|!
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_name_lookup_error
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|,
name|type_decl
argument_list|,
literal|"is not a type"
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Remember that the name was used in the definition of the 	 current class so that we can check later to see if the 	 meaning would have been different after the class was 	 entirely defined.  */
elseif|else
if|if
condition|(
name|type_decl
operator|!=
name|error_mark_node
operator|&&
operator|!
name|parser
operator|->
name|scope
condition|)
name|maybe_note_name_used_in_class
argument_list|(
name|identifier
argument_list|,
name|type_decl
argument_list|)
expr_stmt|;
block|}
return|return
name|type_decl
return|;
block|}
end_function

begin_comment
comment|/* Parse an elaborated-type-specifier.  Note that the grammar given    here incorporates the resolution to DR68.     elaborated-type-specifier:      class-key :: [opt] nested-name-specifier [opt] identifier      class-key :: [opt] nested-name-specifier [opt] template [opt] template-id      enum :: [opt] nested-name-specifier [opt] identifier      typename :: [opt] nested-name-specifier identifier      typename :: [opt] nested-name-specifier template [opt]         template-id      GNU extension:     elaborated-type-specifier:      class-key attributes :: [opt] nested-name-specifier [opt] identifier      class-key attributes :: [opt] nested-name-specifier [opt]                 template [opt] template-id      enum attributes :: [opt] nested-name-specifier [opt] identifier     If IS_FRIEND is TRUE, then this elaborated-type-specifier is being    declared `friend'.  If IS_DECLARATION is TRUE, then this    elaborated-type-specifier appears in a decl-specifiers-seq, i.e.,    something is being declared.     Returns the TYPE specified.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_elaborated_type_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|is_friend
parameter_list|,
name|bool
name|is_declaration
parameter_list|)
block|{
name|enum
name|tag_types
name|tag_type
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|attributes
init|=
name|NULL_TREE
decl_stmt|;
comment|/* See if we're looking at the `enum' keyword.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_ENUM
argument_list|)
condition|)
block|{
comment|/* Consume the `enum' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Remember that it's an enumeration type.  */
name|tag_type
operator|=
name|enum_type
expr_stmt|;
comment|/* Parse the attributes.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Or, it might be `typename'.  */
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TYPENAME
argument_list|)
condition|)
block|{
comment|/* Consume the `typename' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Remember that it's a `typename' type.  */
name|tag_type
operator|=
name|typename_type
expr_stmt|;
comment|/* The `typename' keyword is only allowed in templates.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|pedwarn
argument_list|(
literal|"using `typename' outside of template"
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise it must be a class-key.  */
else|else
block|{
name|tag_type
operator|=
name|cp_parser_class_key
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag_type
operator|==
name|none_type
condition|)
return|return
name|error_mark_node
return|;
comment|/* Parse the attributes.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Look for the `::' operator.  */
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the nested-name-specifier.  */
if|if
condition|(
name|tag_type
operator|==
name|typename_type
condition|)
block|{
if|if
condition|(
name|cp_parser_nested_name_specifier
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|true
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|true
argument_list|,
name|is_declaration
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
else|else
comment|/* Even though `typename' is not present, the proposed resolution        to Core Issue 180 says that in `class A<T>::B', `B' should be        considered a type-name, even if `A<T>' is dependent.  */
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|true
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|true
argument_list|,
name|is_declaration
argument_list|)
expr_stmt|;
comment|/* For everything but enumeration types, consider a template-id.  */
if|if
condition|(
name|tag_type
operator|!=
name|enum_type
condition|)
block|{
name|bool
name|template_p
init|=
name|false
decl_stmt|;
name|tree
name|decl
decl_stmt|;
comment|/* Allow the `template' keyword.  */
name|template_p
operator|=
name|cp_parser_optional_template_keyword
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If we didn't see `template', we don't know if there's a          template-id or not.  */
if|if
condition|(
operator|!
name|template_p
condition|)
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the template-id.  */
name|decl
operator|=
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
name|template_p
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
name|is_declaration
argument_list|)
expr_stmt|;
comment|/* If we didn't find a template-id, look for an ordinary          identifier.  */
if|if
condition|(
operator|!
name|template_p
operator|&&
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
empty_stmt|;
comment|/* If DECL is a TEMPLATE_ID_EXPR, and the `typename' keyword is 	 in effect, then we must assume that, upon instantiation, the 	 template will correspond to a class.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|&&
name|tag_type
operator|==
name|typename_type
condition|)
name|type
operator|=
name|make_typename_type
argument_list|(
name|parser
operator|->
name|scope
argument_list|,
name|decl
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* For an enumeration type, consider only a plain identifier.  */
if|if
condition|(
operator|!
name|type
condition|)
block|{
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
block|{
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* For a `typename', we needn't call xref_tag.  */
if|if
condition|(
name|tag_type
operator|==
name|typename_type
condition|)
return|return
name|make_typename_type
argument_list|(
name|parser
operator|->
name|scope
argument_list|,
name|identifier
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
return|;
comment|/* Look up a qualified name in the usual way.  */
if|if
condition|(
name|parser
operator|->
name|scope
condition|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* In an elaborated-type-specifier, names are assumed to name 	     types, so we set IS_TYPE to TRUE when calling 	     cp_parser_lookup_name.  */
name|decl
operator|=
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|,
comment|/*is_type=*/
name|true
argument_list|,
comment|/*is_template=*/
name|false
argument_list|,
comment|/*is_namespace=*/
name|false
argument_list|,
comment|/*check_dependency=*/
name|true
argument_list|)
expr_stmt|;
comment|/* If we are parsing friend declaration, DECL may be a 	     TEMPLATE_DECL tree node here.  However, we need to check 	     whether this TEMPLATE_DECL results in valid code.  Consider 	     the following example:  	       namespace N { 		 template<class T> class C {}; 	       } 	       class X { 		 template<class T> friend class N::C; // #1, valid code 	       }; 	       template<class T> class Y { 		 friend class N::C;		       // #2, invalid code 	       };  	     For both case #1 and #2, we arrive at a TEMPLATE_DECL after 	     name lookup of `N::C'.  We see that friend declaration must 	     be template for the code to be valid.  Note that 	     processing_template_decl does not work here since it is 	     always 1 for the above two cases.  */
name|decl
operator|=
operator|(
name|cp_parser_maybe_treat_template_as_class
argument_list|(
name|decl
argument_list|,
comment|/*tag_name_p=*/
name|is_friend
operator|&&
name|parser
operator|->
name|num_template_parameter_lists
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"expected type-name"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|TYPENAME_TYPE
condition|)
name|check_elaborated_type_specifier
argument_list|(
name|tag_type
argument_list|,
name|decl
argument_list|,
operator|(
name|parser
operator|->
name|num_template_parameter_lists
operator|||
name|DECL_SELF_REFERENCE_P
argument_list|(
name|decl
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* An elaborated-type-specifier sometimes introduces a new type and 	     sometimes names an existing type.  Normally, the rule is that it 	     introduces a new type only if there is not an existing type of 	     the same name already in scope.  For example, given:  	       struct S {}; 	       void f() { struct S s; }  	     the `struct S' in the body of `f' is the same `struct S' as in 	     the global scope; the existing definition is used.  However, if 	     there were no global declaration, this would introduce a new  	     local class named `S'.  	     An exception to this rule applies to the following code:  	       namespace N { struct S; }  	     Here, the elaborated-type-specifier names a new type 	     unconditionally; even if there is already an `S' in the 	     containing scope this declaration names a new type. 	     This exception only applies if the elaborated-type-specifier 	     forms the complete declaration:  	       [class.name]   	       A declaration consisting solely of `class-key identifier ;' is 	       either a redeclaration of the name in the current scope or a 	       forward declaration of the identifier as a class name.  It 	       introduces the name into the current scope.  	     We are in this situation precisely when the next token is a `;'.  	     An exception to the exception is that a `friend' declaration does 	     *not* name a new type; i.e., given:  	       struct S { friend struct T; };  	     `T' is not a new type in the scope of `S'.    	     Also, `new struct S' or `sizeof (struct S)' never results in the 	     definition of a new type; a new type can only be declared in a 	     declaration context.  */
comment|/* Warn about attributes. They are ignored.  */
if|if
condition|(
name|attributes
condition|)
name|warning
argument_list|(
literal|"type attributes are honored only at type definition"
argument_list|)
expr_stmt|;
name|type
operator|=
name|xref_tag
argument_list|(
name|tag_type
argument_list|,
name|identifier
argument_list|,
operator|(
name|is_friend
operator|||
operator|!
name|is_declaration
operator|||
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
operator|)
argument_list|,
name|parser
operator|->
name|num_template_parameter_lists
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tag_type
operator|!=
name|enum_type
condition|)
name|cp_parser_check_class_key
argument_list|(
name|tag_type
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* A "<" cannot follow an elaborated type specifier.  If that      happens, the user was probably trying to form a template-id.  */
name|cp_parser_check_for_invalid_template_id
argument_list|(
name|parser
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Parse an enum-specifier.     enum-specifier:      enum identifier [opt] { enumerator-list [opt] }     Returns an ENUM_TYPE representing the enumeration.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_enum_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|identifier
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* Look for the `enum' keyword.  */
if|if
condition|(
operator|!
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ENUM
argument_list|,
literal|"`enum'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* See if it is an identifier.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the `{'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|,
literal|"`{'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* At this point, we're going ahead with the enum-specifier, even      if some other problem occurs.  */
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Issue an error message if type-definitions are forbidden here.  */
name|cp_parser_check_type_definition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Create the new type.  */
name|type
operator|=
name|start_enum
argument_list|(
name|identifier
condition|?
name|identifier
else|:
name|make_anon_name
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's not a `}', then there are some enumerators.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_CLOSE_BRACE
condition|)
name|cp_parser_enumerator_list
argument_list|(
name|parser
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Look for the `}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
comment|/* Finish up the enumeration.  */
name|finish_enum
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Parse an enumerator-list.  The enumerators all have the indicated    TYPE.       enumerator-list:      enumerator-definition      enumerator-list , enumerator-definition  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_enumerator_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Parse an enumerator-definition.  */
name|cp_parser_enumerator_definition
argument_list|(
name|parser
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's not a `,', then we've reached the end of the  	 list.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_COMMA
condition|)
break|break;
comment|/* Otherwise, consume the `,' and keep going.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token is a `}', there is a trailing comma.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"comma at end of enumerator list"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Parse an enumerator-definition.  The enumerator has the indicated    TYPE.     enumerator-definition:      enumerator      enumerator = constant-expression         enumerator:      identifier  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_enumerator_definition
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|tree
name|value
decl_stmt|;
comment|/* Look for the identifier.  */
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's an `=', then there's an explicit value.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EQ
condition|)
block|{
comment|/* Consume the `=' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the value.  */
name|value
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant_p=*/
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|value
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Create the enumerator.  */
name|build_enumerator
argument_list|(
name|identifier
argument_list|,
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a namespace-name.     namespace-name:      original-namespace-name      namespace-alias     Returns the NAMESPACE_DECL for the namespace.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_namespace_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|identifier
decl_stmt|;
name|tree
name|namespace_decl
decl_stmt|;
comment|/* Get the name of the namespace.  */
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Look up the identifier in the currently active scope.  Look only      for namespaces, due to:         [basic.lookup.udir]         When looking up a namespace-name in a using-directive or alias        definition, only namespace names are considered.         And:         [basic.lookup.qual]         During the lookup of a name preceding the :: scope resolution        operator, object, function, and enumerator names are ignored.         (Note that cp_parser_class_or_namespace_name only calls this      function if the token after the name is the scope resolution      operator.)  */
name|namespace_decl
operator|=
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|,
comment|/*is_type=*/
name|false
argument_list|,
comment|/*is_template=*/
name|false
argument_list|,
comment|/*is_namespace=*/
name|true
argument_list|,
comment|/*check_dependency=*/
name|true
argument_list|)
expr_stmt|;
comment|/* If it's not a namespace, issue an error.  */
if|if
condition|(
name|namespace_decl
operator|==
name|error_mark_node
operator|||
name|TREE_CODE
argument_list|(
name|namespace_decl
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected namespace-name"
argument_list|)
expr_stmt|;
name|namespace_decl
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|namespace_decl
return|;
block|}
end_function

begin_comment
comment|/* Parse a namespace-definition.     namespace-definition:      named-namespace-definition      unnamed-namespace-definition       named-namespace-definition:      original-namespace-definition      extension-namespace-definition     original-namespace-definition:      namespace identifier { namespace-body }        extension-namespace-definition:      namespace original-namespace-name { namespace-body }      unnamed-namespace-definition:      namespace { namespace-body } */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_namespace_definition
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|identifier
decl_stmt|;
comment|/* Look for the `namespace' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_NAMESPACE
argument_list|,
literal|"`namespace'"
argument_list|)
expr_stmt|;
comment|/* Get the name of the namespace.  We do not attempt to distinguish      between an original-namespace-definition and an      extension-namespace-definition at this point.  The semantic      analysis routines are responsible for that.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|identifier
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Look for the `{' to start the namespace.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|,
literal|"`{'"
argument_list|)
expr_stmt|;
comment|/* Start the namespace.  */
name|push_namespace
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
comment|/* Parse the body of the namespace.  */
name|cp_parser_namespace_body
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Finish the namespace.  */
name|pop_namespace
argument_list|()
expr_stmt|;
comment|/* Look for the final `}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a namespace-body.     namespace-body:      declaration-seq [opt]  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_namespace_body
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_parser_declaration_seq_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a namespace-alias-definition.     namespace-alias-definition:      namespace identifier = qualified-namespace-specifier ;  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_namespace_alias_definition
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|identifier
decl_stmt|;
name|tree
name|namespace_specifier
decl_stmt|;
comment|/* Look for the `namespace' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_NAMESPACE
argument_list|,
literal|"`namespace'"
argument_list|)
expr_stmt|;
comment|/* Look for the identifier.  */
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Look for the `=' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_EQ
argument_list|,
literal|"`='"
argument_list|)
expr_stmt|;
comment|/* Look for the qualified-namespace-specifier.  */
name|namespace_specifier
operator|=
name|cp_parser_qualified_namespace_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the `;' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
comment|/* Register the alias in the symbol table.  */
name|do_namespace_alias
argument_list|(
name|identifier
argument_list|,
name|namespace_specifier
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a qualified-namespace-specifier.     qualified-namespace-specifier:      :: [opt] nested-name-specifier [opt] namespace-name     Returns a NAMESPACE_DECL corresponding to the specified    namespace.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_qualified_namespace_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Look for the optional `::'.  */
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the optional nested-name-specifier.  */
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|cp_parser_namespace_name
argument_list|(
name|parser
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a using-declaration.     using-declaration:      using typename [opt] :: [opt] nested-name-specifier unqualified-id ;      using :: unqualified-id ;  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_using_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|bool
name|typename_p
init|=
name|false
decl_stmt|;
name|bool
name|global_scope_p
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|tree
name|qscope
decl_stmt|;
comment|/* Look for the `using' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_USING
argument_list|,
literal|"`using'"
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* See if it's `typename'.  */
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_TYPENAME
condition|)
block|{
comment|/* Remember that we've seen it.  */
name|typename_p
operator|=
name|true
expr_stmt|;
comment|/* Consume the `typename' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* Look for the optional global scope qualification.  */
name|global_scope_p
operator|=
operator|(
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* If we saw `typename', or didn't see `::', then there must be a      nested-name-specifier present.  */
if|if
condition|(
name|typename_p
operator|||
operator|!
name|global_scope_p
condition|)
name|qscope
operator|=
name|cp_parser_nested_name_specifier
argument_list|(
name|parser
argument_list|,
name|typename_p
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Otherwise, we could be in either of the two productions.  In that      case, treat the nested-name-specifier as optional.  */
else|else
name|qscope
operator|=
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qscope
condition|)
name|qscope
operator|=
name|global_namespace
expr_stmt|;
comment|/* Parse the unqualified-id.  */
name|identifier
operator|=
name|cp_parser_unqualified_id
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*declarator_p=*/
name|true
argument_list|)
expr_stmt|;
comment|/* The function we call to handle a using-declaration is different      depending on what scope we are in.  */
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|identifier
argument_list|)
operator|!=
name|IDENTIFIER_NODE
operator|&&
name|TREE_CODE
argument_list|(
name|identifier
argument_list|)
operator|!=
name|BIT_NOT_EXPR
condition|)
comment|/* [namespace.udecl]         A using declaration shall not name a template-id.  */
name|error
argument_list|(
literal|"a template-id may not appear in a using-declaration"
argument_list|)
expr_stmt|;
else|else
block|{
name|scope
operator|=
name|current_scope
argument_list|()
expr_stmt|;
if|if
condition|(
name|scope
operator|&&
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
comment|/* Create the USING_DECL.  */
name|decl
operator|=
name|do_class_using_decl
argument_list|(
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|identifier
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add it to the list of members in this class.  */
name|finish_member_declaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|cp_parser_lookup_name_simple
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
name|cp_parser_name_lookup_error
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|,
name|decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|scope
condition|)
name|do_local_using_decl
argument_list|(
name|decl
argument_list|,
name|qscope
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
else|else
name|do_toplevel_using_decl
argument_list|(
name|decl
argument_list|,
name|qscope
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Look for the final `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a using-directive.        using-directive:      using namespace :: [opt] nested-name-specifier [opt]        namespace-name ;  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_using_directive
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|namespace_decl
decl_stmt|;
name|tree
name|attribs
decl_stmt|;
comment|/* Look for the `using' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_USING
argument_list|,
literal|"`using'"
argument_list|)
expr_stmt|;
comment|/* And the `namespace' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_NAMESPACE
argument_list|,
literal|"`namespace'"
argument_list|)
expr_stmt|;
comment|/* Look for the optional `::' operator.  */
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* And the optional nested-name-specifier.  */
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Get the namespace being used.  */
name|namespace_decl
operator|=
name|cp_parser_namespace_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* And any specified attributes.  */
name|attribs
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Update the symbol table.  */
name|parse_using_directive
argument_list|(
name|namespace_decl
argument_list|,
name|attribs
argument_list|)
expr_stmt|;
comment|/* Look for the final `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an asm-definition.     asm-definition:      asm ( string-literal ) ;       GNU Extension:     asm-definition:      asm volatile [opt] ( string-literal ) ;      asm volatile [opt] ( string-literal : asm-operand-list [opt] ) ;      asm volatile [opt] ( string-literal : asm-operand-list [opt]                           : asm-operand-list [opt] ) ;      asm volatile [opt] ( string-literal : asm-operand-list [opt]                            : asm-operand-list [opt]                            : asm-operand-list [opt] ) ;  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_asm_definition
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|string
decl_stmt|;
name|tree
name|outputs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|inputs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|clobbers
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|asm_stmt
decl_stmt|;
name|bool
name|volatile_p
init|=
name|false
decl_stmt|;
name|bool
name|extended_p
init|=
name|false
decl_stmt|;
comment|/* Look for the `asm' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ASM
argument_list|,
literal|"`asm'"
argument_list|)
expr_stmt|;
comment|/* See if the next token is `volatile'.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_VOLATILE
argument_list|)
condition|)
block|{
comment|/* Remember that we saw the `volatile' keyword.  */
name|volatile_p
operator|=
name|true
expr_stmt|;
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* Look for the opening `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Look for the string.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_STRING
argument_list|,
literal|"asm body"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return;
name|string
operator|=
name|token
operator|->
name|value
expr_stmt|;
comment|/* If we're allowing GNU extensions, check for the extended assembly      syntax.  Unfortunately, the `:' tokens need not be separated by       a space in C, and so, for compatibility, we tolerate that here      too.  Doing that means that we have to treat the `::' operator as      two `:' tokens.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|at_function_scope_p
argument_list|()
operator|&&
operator|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
operator|||
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
operator|)
condition|)
block|{
name|bool
name|inputs_p
init|=
name|false
decl_stmt|;
name|bool
name|clobbers_p
init|=
name|false
decl_stmt|;
comment|/* The extended syntax was used.  */
name|extended_p
operator|=
name|true
expr_stmt|;
comment|/* Look for outputs.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
block|{
comment|/* Consume the `:'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the output-operands.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|outputs
operator|=
name|cp_parser_asm_operand_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* If the next token is `::', there are no outputs, and the 	 next token is the beginning of the inputs.  */
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
condition|)
block|{
comment|/* Consume the `::' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* The inputs are coming next.  */
name|inputs_p
operator|=
name|true
expr_stmt|;
block|}
comment|/* Look for inputs.  */
if|if
condition|(
name|inputs_p
operator|||
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inputs_p
condition|)
comment|/* Consume the `:'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the output-operands.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|inputs
operator|=
name|cp_parser_asm_operand_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
condition|)
comment|/* The clobbers are coming next.  */
name|clobbers_p
operator|=
name|true
expr_stmt|;
comment|/* Look for clobbers.  */
if|if
condition|(
name|clobbers_p
operator|||
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|clobbers_p
condition|)
comment|/* Consume the `:'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the clobbers.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|clobbers
operator|=
name|cp_parser_asm_clobber_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Look for the closing `)'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
comment|/* Create the ASM_STMT.  */
if|if
condition|(
name|at_function_scope_p
argument_list|()
condition|)
block|{
name|asm_stmt
operator|=
name|finish_asm_stmt
argument_list|(
name|volatile_p
condition|?
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
else|:
name|NULL_TREE
argument_list|,
name|string
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|,
name|clobbers
argument_list|)
expr_stmt|;
comment|/* If the extended syntax was not used, mark the ASM_STMT.  */
if|if
condition|(
operator|!
name|extended_p
condition|)
name|ASM_INPUT_P
argument_list|(
name|asm_stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|assemble_asm
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Declarators [gram.dcl.decl] */
end_comment

begin_comment
comment|/* Parse an init-declarator.     init-declarator:      declarator initializer [opt]     GNU Extension:     init-declarator:      declarator asm-specification [opt] attributes [opt] initializer [opt]     function-definition:      decl-specifier-seq [opt] declarator ctor-initializer [opt]        function-body       decl-specifier-seq [opt] declarator function-try-block       GNU Extension:     function-definition:      __extension__ function-definition      The DECL_SPECIFIERS and PREFIX_ATTRIBUTES apply to this declarator.    Returns a representation of the entity declared.  If MEMBER_P is TRUE,    then this declarator appears in a class scope.  The new DECL created    by this declarator is returned.     If FUNCTION_DEFINITION_ALLOWED_P then we handle the declarator and    for a function-definition here as well.  If the declarator is a    declarator for a function-definition, *FUNCTION_DEFINITION_P will    be TRUE upon return.  By that point, the function-definition will    have been completely parsed.     FUNCTION_DEFINITION_P may be NULL if FUNCTION_DEFINITION_ALLOWED_P    is FALSE.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_init_declarator
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|decl_specifiers
parameter_list|,
name|tree
name|prefix_attributes
parameter_list|,
name|bool
name|function_definition_allowed_p
parameter_list|,
name|bool
name|member_p
parameter_list|,
name|int
name|declares_class_or_enum
parameter_list|,
name|bool
modifier|*
name|function_definition_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|tree
name|asm_specification
decl_stmt|;
name|tree
name|initializer
decl_stmt|;
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|bool
name|is_initialized
decl_stmt|;
name|bool
name|is_parenthesized_init
decl_stmt|;
name|bool
name|is_non_constant_init
decl_stmt|;
name|int
name|ctor_dtor_or_conv_p
decl_stmt|;
name|bool
name|friend_p
decl_stmt|;
name|bool
name|pop_p
init|=
name|false
decl_stmt|;
comment|/* Assume that this is not the declarator for a function      definition.  */
if|if
condition|(
name|function_definition_p
condition|)
operator|*
name|function_definition_p
operator|=
name|false
expr_stmt|;
comment|/* Defer access checks while parsing the declarator; we cannot know      what names are accessible until we know what is being       declared.  */
name|resume_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Parse the declarator.  */
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_NAMED
argument_list|,
operator|&
name|ctor_dtor_or_conv_p
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|)
expr_stmt|;
comment|/* Gather up the deferred checks.  */
name|stop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* If the DECLARATOR was erroneous, there's no need to go      further.  */
if|if
condition|(
name|declarator
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|cp_parser_check_for_definition_in_return_type
argument_list|(
name|declarator
argument_list|,
name|declares_class_or_enum
argument_list|)
expr_stmt|;
comment|/* Figure out what scope the entity declared by the DECLARATOR is      located in.  `grokdeclarator' sometimes changes the scope, so      we compute it now.  */
name|scope
operator|=
name|get_scope_of_declarator
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
comment|/* If we're allowing GNU extensions, look for an asm-specification      and attributes.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* Look for an asm-specification.  */
name|asm_specification
operator|=
name|cp_parser_asm_specification_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* And attributes.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asm_specification
operator|=
name|NULL_TREE
expr_stmt|;
name|attributes
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Check to see if the token indicates the start of a      function-definition.  */
if|if
condition|(
name|cp_parser_token_starts_function_definition_p
argument_list|(
name|token
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|function_definition_allowed_p
condition|)
block|{
comment|/* If a function-definition should not appear here, issue an 	     error message.  */
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"a function-definition is not allowed here"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
comment|/* Neither attributes nor an asm-specification are allowed 	     on a function-definition.  */
if|if
condition|(
name|asm_specification
condition|)
name|error
argument_list|(
literal|"an asm-specification is not allowed on a function-definition"
argument_list|)
expr_stmt|;
if|if
condition|(
name|attributes
condition|)
name|error
argument_list|(
literal|"attributes are not allowed on a function-definition"
argument_list|)
expr_stmt|;
comment|/* This is a function-definition.  */
operator|*
name|function_definition_p
operator|=
name|true
expr_stmt|;
comment|/* Parse the function definition.  */
if|if
condition|(
name|member_p
condition|)
name|decl
operator|=
name|cp_parser_save_member_function_body
argument_list|(
name|parser
argument_list|,
name|decl_specifiers
argument_list|,
name|declarator
argument_list|,
name|prefix_attributes
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
operator|(
name|cp_parser_function_definition_from_specifiers_and_declarator
argument_list|(
name|parser
argument_list|,
name|decl_specifiers
argument_list|,
name|prefix_attributes
argument_list|,
name|declarator
argument_list|)
operator|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
comment|/* [dcl.dcl]       Only in function declarations for constructors, destructors, and      type conversions can the decl-specifier-seq be omitted.         We explicitly postpone this check past the point where we handle      function-definitions because we tolerate function-definitions      that are missing their return types in some modes.  */
if|if
condition|(
operator|!
name|decl_specifiers
operator|&&
name|ctor_dtor_or_conv_p
operator|<=
literal|0
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected constructor, destructor, or type conversion"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* An `=' or an `(' indicates an initializer.  */
name|is_initialized
operator|=
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_EQ
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
operator|)
expr_stmt|;
comment|/* If the init-declarator isn't initialized and isn't followed by a      `,' or `;', it's not a valid init-declarator.  */
if|if
condition|(
operator|!
name|is_initialized
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_COMMA
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_SEMICOLON
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected init-declarator"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Because start_decl has side-effects, we should only call it if we      know we're going ahead.  By this point, we know that we cannot      possibly be looking at any other construct.  */
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the decl specifiers were bad, issue an error now that we're      sure this was intended to be a declarator.  Then continue      declaring the variable(s), as int, to try to cut down on further      errors.  */
if|if
condition|(
name|decl_specifiers
operator|!=
name|NULL
operator|&&
name|TREE_VALUE
argument_list|(
name|decl_specifiers
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"invalid type in declaration"
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|decl_specifiers
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Check to see whether or not this declaration is a friend.  */
name|friend_p
operator|=
name|cp_parser_friend_p
argument_list|(
name|decl_specifiers
argument_list|)
expr_stmt|;
comment|/* Check that the number of template-parameter-lists is OK.  */
if|if
condition|(
operator|!
name|cp_parser_check_declarator_template_parameters
argument_list|(
name|parser
argument_list|,
name|declarator
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Enter the newly declared entry in the symbol table.  If we're      processing a declaration in a class-specifier, we wait until      after processing the initializer.  */
if|if
condition|(
operator|!
name|member_p
condition|)
block|{
if|if
condition|(
name|parser
operator|->
name|in_unbraced_linkage_specification_p
condition|)
block|{
name|decl_specifiers
operator|=
name|tree_cons
argument_list|(
name|error_mark_node
argument_list|,
name|get_identifier
argument_list|(
literal|"extern"
argument_list|)
argument_list|,
name|decl_specifiers
argument_list|)
expr_stmt|;
name|have_extern_spec
operator|=
name|false
expr_stmt|;
block|}
name|decl
operator|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|decl_specifiers
argument_list|,
name|is_initialized
argument_list|,
name|attributes
argument_list|,
name|prefix_attributes
argument_list|)
expr_stmt|;
block|}
comment|/* Enter the SCOPE.  That way unqualified names appearing in the      initializer will be looked up in SCOPE.  */
if|if
condition|(
name|scope
condition|)
name|pop_p
operator|=
name|push_scope
argument_list|(
name|scope
argument_list|)
expr_stmt|;
comment|/* Perform deferred access control checks, now that we know in which      SCOPE the declared entity resides.  */
if|if
condition|(
operator|!
name|member_p
operator|&&
name|decl
condition|)
block|{
name|tree
name|saved_current_function_decl
init|=
name|NULL_TREE
decl_stmt|;
comment|/* If the entity being declared is a function, pretend that we 	 are in its scope.  If it is a `friend', it may have access to 	 things that would not otherwise be accessible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|saved_current_function_decl
operator|=
name|current_function_decl
expr_stmt|;
name|current_function_decl
operator|=
name|decl
expr_stmt|;
block|}
comment|/* Perform the access control checks for the declarator and the 	 the decl-specifiers.  */
name|perform_deferred_access_checks
argument_list|()
expr_stmt|;
comment|/* Restore the saved value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|current_function_decl
operator|=
name|saved_current_function_decl
expr_stmt|;
block|}
comment|/* Parse the initializer.  */
if|if
condition|(
name|is_initialized
condition|)
name|initializer
operator|=
name|cp_parser_initializer
argument_list|(
name|parser
argument_list|,
operator|&
name|is_parenthesized_init
argument_list|,
operator|&
name|is_non_constant_init
argument_list|)
expr_stmt|;
else|else
block|{
name|initializer
operator|=
name|NULL_TREE
expr_stmt|;
name|is_parenthesized_init
operator|=
name|false
expr_stmt|;
name|is_non_constant_init
operator|=
name|true
expr_stmt|;
block|}
comment|/* The old parser allows attributes to appear after a parenthesized      initializer.  Mark Mitchell proposed removing this functionality      on the GCC mailing lists on 2002-08-13.  This parser accepts the      attributes -- but ignores them.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|is_parenthesized_init
condition|)
if|if
condition|(
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
condition|)
name|warning
argument_list|(
literal|"attributes after parenthesized initializer ignored"
argument_list|)
expr_stmt|;
comment|/* Leave the SCOPE, now that we have processed the initializer.  It      is important to do this before calling cp_finish_decl because it      makes decisions about whether to create DECL_STMTs or not based      on the current scope.  */
if|if
condition|(
name|pop_p
condition|)
name|pop_scope
argument_list|(
name|scope
argument_list|)
expr_stmt|;
comment|/* For an in-class declaration, use `grokfield' to create the      declaration.  */
if|if
condition|(
name|member_p
condition|)
block|{
name|decl
operator|=
name|grokfield
argument_list|(
name|declarator
argument_list|,
name|decl_specifiers
argument_list|,
name|initializer
argument_list|,
comment|/*asmspec=*/
name|NULL_TREE
argument_list|,
comment|/*attributes=*/
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|cp_parser_save_default_args
argument_list|(
name|parser
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Finish processing the declaration.  But, skip friend      declarations.  */
if|if
condition|(
operator|!
name|friend_p
operator|&&
name|decl
condition|)
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|initializer
argument_list|,
name|asm_specification
argument_list|,
comment|/* If the initializer is in parentheses, then this is 		       a direct-initialization, which means that an 		       `explicit' constructor is OK.  Otherwise, an 		       `explicit' constructor cannot be used.  */
operator|(
operator|(
name|is_parenthesized_init
operator|||
operator|!
name|is_initialized
operator|)
condition|?
literal|0
else|:
name|LOOKUP_ONLYCONVERTING
operator|)
argument_list|)
expr_stmt|;
comment|/* Remember whether or not variables were initialized by      constant-expressions.  */
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|is_initialized
operator|&&
operator|!
name|is_non_constant_init
condition|)
name|DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P
argument_list|(
name|decl
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Parse a declarator.        declarator:      direct-declarator      ptr-operator declarator       abstract-declarator:      ptr-operator abstract-declarator [opt]      direct-abstract-declarator     GNU Extensions:     declarator:      attributes [opt] direct-declarator      attributes [opt] ptr-operator declarator       abstract-declarator:      attributes [opt] ptr-operator abstract-declarator [opt]      attributes [opt] direct-abstract-declarator          Returns a representation of the declarator.  If the declarator has    the form `* declarator', then an INDIRECT_REF is returned, whose    only operand is the sub-declarator.  Analogously, `& declarator' is    represented as an ADDR_EXPR.  For `X::* declarator', a SCOPE_REF is    used.  The first operand is the TYPE for `X'.  The second operand    is an INDIRECT_REF whose operand is the sub-declarator.     Otherwise, the representation is as for a direct-declarator.     (It would be better to define a structure type to represent    declarators, rather than abusing `tree' nodes to represent    declarators.  That would be much clearer and save some memory.    There is no reason for declarators to be garbage-collected, for    example; they are created during parser and no longer needed after    `grokdeclarator' has been called.)     For a ptr-operator that has the optional cv-qualifier-seq,    cv-qualifiers will be stored in the TREE_TYPE of the INDIRECT_REF    node.     If CTOR_DTOR_OR_CONV_P is not NULL, *CTOR_DTOR_OR_CONV_P is used to    detect constructor, destructor or conversion operators. It is set    to -1 if the declarator is a name, and +1 if it is a    function. Otherwise it is set to zero. Usually you just want to    test for>0, but internally the negative value is used.        (The reason for CTOR_DTOR_OR_CONV_P is that a declaration must have    a decl-specifier-seq unless it declares a constructor, destructor,    or conversion.  It might seem that we could check this condition in    semantic analysis, rather than parsing, but that makes it difficult    to handle something like `f()'.  We want to notice that there are    no decl-specifiers, and therefore realize that this is an    expression, not a declaration.)        If PARENTHESIZED_P is non-NULL, *PARENTHESIZED_P is set to true iff    the declarator is a direct-declarator of the form "(...)".  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_declarator
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_parser_declarator_kind
name|dcl_kind
parameter_list|,
name|int
modifier|*
name|ctor_dtor_or_conv_p
parameter_list|,
name|bool
modifier|*
name|parenthesized_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|cv_qualifier_seq
decl_stmt|;
name|tree
name|class_type
decl_stmt|;
name|tree
name|attributes
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Assume this is not a constructor, destructor, or type-conversion      operator.  */
if|if
condition|(
name|ctor_dtor_or_conv_p
condition|)
operator|*
name|ctor_dtor_or_conv_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
condition|)
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Check for the ptr-operator production.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the ptr-operator.  */
name|code
operator|=
name|cp_parser_ptr_operator
argument_list|(
name|parser
argument_list|,
operator|&
name|class_type
argument_list|,
operator|&
name|cv_qualifier_seq
argument_list|)
expr_stmt|;
comment|/* If that worked, then we have a ptr-operator.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* If a ptr-operator was found, then this declarator was not 	 parenthesized.  */
if|if
condition|(
name|parenthesized_p
condition|)
operator|*
name|parenthesized_p
operator|=
name|true
expr_stmt|;
comment|/* The dependent declarator is optional if we are parsing an 	 abstract-declarator.  */
if|if
condition|(
name|dcl_kind
operator|!=
name|CP_PARSER_DECLARATOR_NAMED
condition|)
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the dependent declarator.  */
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|dcl_kind
argument_list|,
comment|/*ctor_dtor_or_conv_p=*/
name|NULL
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we are parsing an abstract-declarator, we must handle the 	 case where the dependent declarator is absent.  */
if|if
condition|(
name|dcl_kind
operator|!=
name|CP_PARSER_DECLARATOR_NAMED
operator|&&
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|declarator
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Build the representation of the ptr-operator.  */
if|if
condition|(
name|code
operator|==
name|INDIRECT_REF
condition|)
name|declarator
operator|=
name|make_pointer_declarator
argument_list|(
name|cv_qualifier_seq
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
else|else
name|declarator
operator|=
name|make_reference_declarator
argument_list|(
name|cv_qualifier_seq
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
comment|/* Handle the pointer-to-member case.  */
if|if
condition|(
name|class_type
condition|)
name|declarator
operator|=
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|class_type
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
block|}
comment|/* Everything else is a direct-declarator.  */
else|else
block|{
if|if
condition|(
name|parenthesized_p
condition|)
operator|*
name|parenthesized_p
operator|=
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|cp_parser_direct_declarator
argument_list|(
name|parser
argument_list|,
name|dcl_kind
argument_list|,
name|ctor_dtor_or_conv_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attributes
operator|&&
name|declarator
operator|!=
name|error_mark_node
condition|)
name|declarator
operator|=
name|tree_cons
argument_list|(
name|attributes
argument_list|,
name|declarator
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|declarator
return|;
block|}
end_function

begin_comment
comment|/* Parse a direct-declarator or direct-abstract-declarator.     direct-declarator:      declarator-id      direct-declarator ( parameter-declaration-clause )        cv-qualifier-seq [opt]         exception-specification [opt]      direct-declarator [ constant-expression [opt] ]      ( declarator )       direct-abstract-declarator:      direct-abstract-declarator [opt]        ( parameter-declaration-clause )         cv-qualifier-seq [opt]        exception-specification [opt]      direct-abstract-declarator [opt] [ constant-expression [opt] ]      ( abstract-declarator )     Returns a representation of the declarator.  DCL_KIND is    CP_PARSER_DECLARATOR_ABSTRACT, if we are parsing a    direct-abstract-declarator.  It is CP_PARSER_DECLARATOR_NAMED, if    we are parsing a direct-declarator.  It is    CP_PARSER_DECLARATOR_EITHER, if we can accept either - in the case    of ambiguity we prefer an abstract declarator, as per    [dcl.ambig.res].  CTOR_DTOR_OR_CONV_P is as for    cp_parser_declarator.     For the declarator-id production, the representation is as for an    id-expression, except that a qualified name is represented as a    SCOPE_REF.  A function-declarator is represented as a CALL_EXPR;    see the documentation of the FUNCTION_DECLARATOR_* macros for    information about how to find the various declarator components.    An array-declarator is represented as an ARRAY_REF.  The    direct-declarator is the first operand; the constant-expression    indicating the size of the array is the second operand.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_direct_declarator
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_parser_declarator_kind
name|dcl_kind
parameter_list|,
name|int
modifier|*
name|ctor_dtor_or_conv_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|declarator
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|scope
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|saved_default_arg_ok_p
init|=
name|parser
operator|->
name|default_arg_ok_p
decl_stmt|;
name|bool
name|saved_in_declarator_p
init|=
name|parser
operator|->
name|in_declarator_p
decl_stmt|;
name|bool
name|first
init|=
name|true
decl_stmt|;
name|bool
name|pop_p
init|=
name|false
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
block|{
comment|/* This is either a parameter-declaration-clause, or a   	     parenthesized declarator. When we know we are parsing a   	     named declarator, it must be a parenthesized declarator   	     if FIRST is true. For instance, `(int)' is a   	     parameter-declaration-clause, with an omitted   	     direct-abstract-declarator. But `((*))', is a   	     parenthesized abstract declarator. Finally, when T is a   	     template parameter `(T)' is a   	     parameter-declaration-clause, and not a parenthesized   	     named declarator. 	      	     We first try and parse a parameter-declaration-clause, 	     and then try a nested declarator (if FIRST is true).  	     It is not an error for it not to be a 	     parameter-declaration-clause, even when FIRST is 	     false. Consider,  	       int i (int); 	       int i (3);  	     The first is the declaration of a function while the 	     second is a the definition of a variable, including its 	     initializer.  	     Having seen only the parenthesis, we cannot know which of 	     these two alternatives should be selected.  Even more 	     complex are examples like:                 int i (int (a)); 	       int i (int (3));  	     The former is a function-declaration; the latter is a 	     variable initialization.    	     Thus again, we try a parameter-declaration-clause, and if 	     that fails, we back out and return.  */
if|if
condition|(
operator|!
name|first
operator|||
name|dcl_kind
operator|!=
name|CP_PARSER_DECLARATOR_NAMED
condition|)
block|{
name|tree
name|params
decl_stmt|;
name|unsigned
name|saved_num_template_parameter_lists
decl_stmt|;
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
comment|/* If this is going to be an abstract declarator, we're 		     in a declarator and we can't have default args.  */
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|false
expr_stmt|;
name|parser
operator|->
name|in_declarator_p
operator|=
name|true
expr_stmt|;
block|}
comment|/* Inside the function parameter list, surrounding 		 template-parameter-lists do not apply.  */
name|saved_num_template_parameter_lists
operator|=
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
name|parser
operator|->
name|num_template_parameter_lists
operator|=
literal|0
expr_stmt|;
comment|/* Parse the parameter-declaration-clause.  */
name|params
operator|=
name|cp_parser_parameter_declaration_clause
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|num_template_parameter_lists
operator|=
name|saved_num_template_parameter_lists
expr_stmt|;
comment|/* If all went well, parse the cv-qualifier-seq and the 	     	 exception-specification.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|tree
name|cv_qualifiers
decl_stmt|;
name|tree
name|exception_specification
decl_stmt|;
if|if
condition|(
name|ctor_dtor_or_conv_p
condition|)
operator|*
name|ctor_dtor_or_conv_p
operator|=
operator|*
name|ctor_dtor_or_conv_p
operator|<
literal|0
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
comment|/* Consume the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Parse the cv-qualifier-seq.  */
name|cv_qualifiers
operator|=
name|cp_parser_cv_qualifier_seq_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* And the exception-specification.  */
name|exception_specification
operator|=
name|cp_parser_exception_specification_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Create the function-declarator.  */
name|declarator
operator|=
name|make_call_declarator
argument_list|(
name|declarator
argument_list|,
name|params
argument_list|,
name|cv_qualifiers
argument_list|,
name|exception_specification
argument_list|)
expr_stmt|;
comment|/* Any subsequent parameter lists are to do with 	 	     return type, so are not those of the declared 	 	     function.  */
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|false
expr_stmt|;
comment|/* Repeat the main loop.  */
continue|continue;
block|}
block|}
comment|/* If this is the first, we can try a parenthesized 	     declarator.  */
if|if
condition|(
name|first
condition|)
block|{
name|bool
name|saved_in_type_id_in_expr_p
decl_stmt|;
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|saved_default_arg_ok_p
expr_stmt|;
name|parser
operator|->
name|in_declarator_p
operator|=
name|saved_in_declarator_p
expr_stmt|;
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the nested declarator.  */
name|saved_in_type_id_in_expr_p
operator|=
name|parser
operator|->
name|in_type_id_in_expr_p
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|true
expr_stmt|;
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|dcl_kind
argument_list|,
name|ctor_dtor_or_conv_p
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|saved_in_type_id_in_expr_p
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
comment|/* Expect a `)'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
name|declarator
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|declarator
operator|==
name|error_mark_node
condition|)
break|break;
goto|goto
name|handle_declarator
goto|;
block|}
comment|/* Otherwise, we must be done.  */
else|else
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|first
operator|||
name|dcl_kind
operator|!=
name|CP_PARSER_DECLARATOR_NAMED
operator|)
operator|&&
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_SQUARE
condition|)
block|{
comment|/* Parse an array-declarator.  */
name|tree
name|bounds
decl_stmt|;
if|if
condition|(
name|ctor_dtor_or_conv_p
condition|)
operator|*
name|ctor_dtor_or_conv_p
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|false
expr_stmt|;
name|parser
operator|->
name|in_declarator_p
operator|=
name|true
expr_stmt|;
comment|/* Consume the `['.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token is `]', then there is no 	     constant-expression.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_CLOSE_SQUARE
condition|)
block|{
name|bool
name|non_constant_p
decl_stmt|;
name|bounds
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant=*/
name|true
argument_list|,
operator|&
name|non_constant_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|non_constant_p
condition|)
name|bounds
operator|=
name|fold_non_dependent_expr
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
block|}
else|else
name|bounds
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Look for the closing `]'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"`]'"
argument_list|)
condition|)
block|{
name|declarator
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
name|declarator
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|declarator
argument_list|,
name|bounds
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first
operator|&&
name|dcl_kind
operator|!=
name|CP_PARSER_DECLARATOR_ABSTRACT
condition|)
block|{
comment|/* Parse a declarator-id */
if|if
condition|(
name|dcl_kind
operator|==
name|CP_PARSER_DECLARATOR_EITHER
condition|)
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|cp_parser_declarator_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcl_kind
operator|==
name|CP_PARSER_DECLARATOR_EITHER
condition|)
block|{
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|declarator
operator|=
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected unqualified-id"
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|declarator
operator|==
name|error_mark_node
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
operator|!
name|current_scope
argument_list|()
condition|)
block|{
name|tree
name|scope
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* In the declaration of a member of a template class 	     	 outside of the class itself, the SCOPE will sometimes 	     	 be a TYPENAME_TYPE.  For example, given: 	     	                  	 template<typename T> 	       	 int S<T>::R::i = 3; 		                	 the SCOPE will be a TYPENAME_TYPE for `S<T>::R'.  In              	 this context, we must resolve S<T>::R to an ordinary              	 type, rather than a typename type. 		   	     	 The reason we normally avoid resolving TYPENAME_TYPEs 	     	 is that a specialization of `S' might render 	     	 `S<T>::R' not a type.  However, if `S' is 	     	 specialized, then this `i' will not be used, so there 	     	 is no harm in resolving the types here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
name|tree
name|type
decl_stmt|;
comment|/* Resolve the TYPENAME_TYPE.  */
name|type
operator|=
name|resolve_typename_type
argument_list|(
name|scope
argument_list|,
comment|/*only_current_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If that failed, the declarator is invalid.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"`%T::%D' is not a type"
argument_list|,
name|TYPE_CONTEXT
argument_list|(
name|scope
argument_list|)
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|scope
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build a new DECLARATOR.  */
name|declarator
operator|=
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check to see whether the declarator-id names a constructor,  	     destructor, or conversion.  */
if|if
condition|(
name|declarator
operator|&&
name|ctor_dtor_or_conv_p
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|SCOPE_REF
operator|&&
name|at_class_scope_p
argument_list|()
operator|)
operator|)
condition|)
block|{
name|tree
name|unqualified_name
decl_stmt|;
name|tree
name|class_type
decl_stmt|;
comment|/* Get the unqualified part of the name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
name|class_type
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unqualified_name
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|class_type
operator|=
name|current_class_type
expr_stmt|;
name|unqualified_name
operator|=
name|declarator
expr_stmt|;
block|}
comment|/* See if it names ctor, dtor or conv.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|unqualified_name
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|||
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|unqualified_name
argument_list|)
operator|||
name|constructor_name_p
argument_list|(
name|unqualified_name
argument_list|,
name|class_type
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|unqualified_name
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|unqualified_name
argument_list|)
argument_list|,
name|class_type
argument_list|)
operator|)
condition|)
operator|*
name|ctor_dtor_or_conv_p
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|handle_declarator
label|:
empty_stmt|;
name|scope
operator|=
name|get_scope_of_declarator
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
condition|)
comment|/* Any names that appear after the declarator-id for a 	       member are looked up in the containing scope.  */
name|pop_p
operator|=
name|push_scope
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_declarator_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|ctor_dtor_or_conv_p
operator|&&
operator|*
name|ctor_dtor_or_conv_p
operator|)
operator|||
operator|(
name|declarator
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|SCOPE_REF
operator|||
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
operator|)
condition|)
comment|/* Default args are only allowed on function 	       declarations.  */
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|saved_default_arg_ok_p
expr_stmt|;
else|else
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|false
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
block|}
comment|/* We're done.  */
else|else
break|break;
block|}
comment|/* For an abstract declarator, we might wind up with nothing at this      point.  That's an error; the declarator is not optional.  */
if|if
condition|(
operator|!
name|declarator
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected declarator"
argument_list|)
expr_stmt|;
comment|/* If we entered a scope, we must exit it now.  */
if|if
condition|(
name|pop_p
condition|)
name|pop_scope
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|saved_default_arg_ok_p
expr_stmt|;
name|parser
operator|->
name|in_declarator_p
operator|=
name|saved_in_declarator_p
expr_stmt|;
return|return
name|declarator
return|;
block|}
end_function

begin_comment
comment|/* Parse a ptr-operator.       ptr-operator:      * cv-qualifier-seq [opt]&      :: [opt] nested-name-specifier * cv-qualifier-seq [opt]     GNU Extension:     ptr-operator:& cv-qualifier-seq [opt]     Returns INDIRECT_REF if a pointer, or pointer-to-member, was    used.  Returns ADDR_EXPR if a reference was used.  In the    case of a pointer-to-member, *TYPE is filled in with the     TYPE containing the member.  *CV_QUALIFIER_SEQ is filled in    with the cv-qualifier-seq, or NULL_TREE, if there are no    cv-qualifiers.  Returns ERROR_MARK if an error occurred.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|cp_parser_ptr_operator
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
modifier|*
name|type
parameter_list|,
name|tree
modifier|*
name|cv_qualifier_seq
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|ERROR_MARK
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Assume that it's not a pointer-to-member.  */
operator|*
name|type
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* And that there are no cv-qualifiers.  */
operator|*
name|cv_qualifier_seq
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's a `*' or `&' we have a pointer or reference.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_MULT
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_AND
condition|)
block|{
comment|/* Remember which ptr-operator we were processing.  */
name|code
operator|=
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_AND
condition|?
name|ADDR_EXPR
else|:
name|INDIRECT_REF
operator|)
expr_stmt|;
comment|/* Consume the `*' or `&'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* A `*' can be followed by a cv-qualifier-seq, and so can a 	 `&', if we are allowing GNU extensions.  (The only qualifier 	 that can legally appear after `&' is `restrict', but that is 	 enforced during semantic analysis.  */
if|if
condition|(
name|code
operator|==
name|INDIRECT_REF
operator|||
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
condition|)
operator|*
name|cv_qualifier_seq
operator|=
name|cp_parser_cv_qualifier_seq_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Try the pointer-to-member case.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the optional `::' operator.  */
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the nested-name specifier.  */
name|cp_parser_nested_name_specifier
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If we found it, and the next token is a `*', then we are 	 indeed looking at a pointer-to-member operator.  */
if|if
condition|(
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_MULT
argument_list|,
literal|"`*'"
argument_list|)
condition|)
block|{
comment|/* The type of which the member is a member is given by the 	     current SCOPE.  */
operator|*
name|type
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
comment|/* The next name will not be qualified.  */
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Indicate that the `*' operator was used.  */
name|code
operator|=
name|INDIRECT_REF
expr_stmt|;
comment|/* Look for the optional cv-qualifier-seq.  */
operator|*
name|cv_qualifier_seq
operator|=
name|cp_parser_cv_qualifier_seq_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* If that didn't work we don't have a ptr-operator.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected ptr-operator"
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) cv-qualifier-seq.     cv-qualifier-seq:      cv-qualifier cv-qualifier-seq [opt]       Returns a TREE_LIST.  The TREE_VALUE of each node is the    representation of a cv-qualifier.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_cv_qualifier_seq_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|cv_qualifiers
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|cv_qualifier
decl_stmt|;
comment|/* Look for the next cv-qualifier.  */
name|cv_qualifier
operator|=
name|cp_parser_cv_qualifier_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If we didn't find one, we're done.  */
if|if
condition|(
operator|!
name|cv_qualifier
condition|)
break|break;
comment|/* Add this cv-qualifier to the list.  */
name|cv_qualifiers
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cv_qualifier
argument_list|,
name|cv_qualifiers
argument_list|)
expr_stmt|;
block|}
comment|/* We built up the list in reverse order.  */
return|return
name|nreverse
argument_list|(
name|cv_qualifiers
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) cv-qualifier.     cv-qualifier:      const      volatile       GNU Extension:     cv-qualifier:      __restrict__ */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_cv_qualifier_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|cv_qualifier
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* See if it's a cv-qualifier.  */
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_CONST
case|:
case|case
name|RID_VOLATILE
case|:
case|case
name|RID_RESTRICT
case|:
comment|/* Save the value of the token.  */
name|cv_qualifier
operator|=
name|token
operator|->
name|value
expr_stmt|;
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|cv_qualifier
return|;
block|}
end_function

begin_comment
comment|/* Parse a declarator-id.     declarator-id:      id-expression      :: [opt] nested-name-specifier [opt] type-name       In the `id-expression' case, the value returned is as for    cp_parser_id_expression if the id-expression was an unqualified-id.    If the id-expression was a qualified-id, then a SCOPE_REF is    returned.  The first operand is the scope (either a NAMESPACE_DECL    or TREE_TYPE), but the second is still just a representation of an    unqualified-id.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_declarator_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|id_expression
decl_stmt|;
comment|/* The expression must be an id-expression.  Assume that qualified      names are the names of types so that:         template<class T>        int S<T>::R::i = 3;       will work; we must treat `S<T>::R' as the name of a type.      Similarly, assume that qualified names are templates, where      required, so that:         template<class T>        int S<T>::R<T>::i = 3;       will work, too.  */
name|id_expression
operator|=
name|cp_parser_id_expression
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|false
argument_list|,
comment|/*template_p=*/
name|NULL
argument_list|,
comment|/*declarator_p=*/
name|true
argument_list|)
expr_stmt|;
comment|/* If the name was qualified, create a SCOPE_REF to represent       that.  */
if|if
condition|(
name|parser
operator|->
name|scope
condition|)
block|{
name|id_expression
operator|=
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|id_expression
argument_list|)
expr_stmt|;
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|id_expression
return|;
block|}
end_function

begin_comment
comment|/* Parse a type-id.     type-id:      type-specifier-seq abstract-declarator [opt]     Returns the TYPE specified.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_type_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|type_specifier_seq
decl_stmt|;
name|tree
name|abstract_declarator
decl_stmt|;
comment|/* Parse the type-specifier-seq.  */
name|type_specifier_seq
operator|=
name|cp_parser_type_specifier_seq
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_specifier_seq
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* There might or might not be an abstract declarator.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the declarator.  */
name|abstract_declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_ABSTRACT
argument_list|,
name|NULL
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check to see if there really was a declarator.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|abstract_declarator
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|type_specifier_seq
argument_list|,
name|abstract_declarator
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a type-specifier-seq.     type-specifier-seq:      type-specifier type-specifier-seq [opt]     GNU extension:     type-specifier-seq:      attributes type-specifier-seq [opt]     Returns a TREE_LIST.  Either the TREE_VALUE of each node is a    type-specifier, or the TREE_PURPOSE is a list of attributes.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_type_specifier_seq
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|bool
name|seen_type_specifier
init|=
name|false
decl_stmt|;
name|tree
name|type_specifier_seq
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Parse the type-specifiers and attributes.  */
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|type_specifier
decl_stmt|;
comment|/* Check for attributes first.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_ATTRIBUTE
argument_list|)
condition|)
block|{
name|type_specifier_seq
operator|=
name|tree_cons
argument_list|(
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|type_specifier_seq
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* After the first type-specifier, others are optional.  */
if|if
condition|(
name|seen_type_specifier
condition|)
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the type-specifier.  */
name|type_specifier
operator|=
name|cp_parser_type_specifier
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_FLAGS_NONE
argument_list|,
comment|/*is_friend=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If the first type-specifier could not be found, this is not a 	 type-specifier-seq at all.  */
if|if
condition|(
operator|!
name|seen_type_specifier
operator|&&
name|type_specifier
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* If subsequent type-specifiers could not be found, the 	 type-specifier-seq is complete.  */
elseif|else
if|if
condition|(
name|seen_type_specifier
operator|&&
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
break|break;
comment|/* Add the new type-specifier to the list.  */
name|type_specifier_seq
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type_specifier
argument_list|,
name|type_specifier_seq
argument_list|)
expr_stmt|;
name|seen_type_specifier
operator|=
name|true
expr_stmt|;
block|}
comment|/* We built up the list in reverse order.  */
return|return
name|nreverse
argument_list|(
name|type_specifier_seq
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a parameter-declaration-clause.     parameter-declaration-clause:      parameter-declaration-list [opt] ... [opt]      parameter-declaration-list , ...     Returns a representation for the parameter declarations.  Each node    is a TREE_LIST.  (See cp_parser_parameter_declaration for the exact    representation.)  If the parameter-declaration-clause ends with an    ellipsis, PARMLIST_ELLIPSIS_P will hold of the first node in the    list.  A return value of NULL_TREE indicates a    parameter-declaration-clause consisting only of an ellipsis.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_parameter_declaration_clause
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|parameters
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|bool
name|ellipsis_p
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Check for trivial parameter-declaration-clauses.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_ELLIPSIS
condition|)
block|{
comment|/* Consume the `...' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
condition|)
comment|/* There are no parameters.  */
block|{
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
if|if
condition|(
name|in_system_header
operator|&&
name|current_class_type
operator|==
name|NULL
operator|&&
name|current_lang_name
operator|==
name|lang_name_c
condition|)
return|return
name|NULL_TREE
return|;
else|else
endif|#
directive|endif
return|return
name|void_list_node
return|;
block|}
comment|/* Check for `(void)', too, which is a special case.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_VOID
operator|&&
operator|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
operator|)
condition|)
block|{
comment|/* Consume the `void' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* There are no parameters.  */
return|return
name|void_list_node
return|;
block|}
comment|/* Parse the parameter-declaration-list.  */
name|parameters
operator|=
name|cp_parser_parameter_declaration_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If a parse error occurred while parsing the      parameter-declaration-list, then the entire      parameter-declaration-clause is erroneous.  */
if|if
condition|(
name|parameters
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's a `,', the clause should terminate with an ellipsis.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
condition|)
block|{
comment|/* Consume the `,'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Expect an ellipsis.  */
name|ellipsis_p
operator|=
operator|(
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_ELLIPSIS
argument_list|,
literal|"`...'"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
comment|/* It might also be `...' if the optional trailing `,' was       omitted.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_ELLIPSIS
condition|)
block|{
comment|/* Consume the `...' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* And remember that we saw it.  */
name|ellipsis_p
operator|=
name|true
expr_stmt|;
block|}
else|else
name|ellipsis_p
operator|=
name|false
expr_stmt|;
comment|/* Finish the parameter list.  */
return|return
name|finish_parmlist
argument_list|(
name|parameters
argument_list|,
name|ellipsis_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a parameter-declaration-list.     parameter-declaration-list:      parameter-declaration      parameter-declaration-list , parameter-declaration     Returns a representation of the parameter-declaration-list, as for    cp_parser_parameter_declaration_clause.  However, the    `void_list_node' is never appended to the list.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_parameter_declaration_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|parameters
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Look for more parameters.  */
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|parameter
decl_stmt|;
name|bool
name|parenthesized_p
decl_stmt|;
comment|/* Parse the parameter.  */
name|parameter
operator|=
name|cp_parser_parameter_declaration
argument_list|(
name|parser
argument_list|,
comment|/*template_parm_p=*/
name|false
argument_list|,
operator|&
name|parenthesized_p
argument_list|)
expr_stmt|;
comment|/* If a parse error occurred parsing the parameter declaration, 	 then the entire parameter-declaration-list is erroneous.  */
if|if
condition|(
name|parameter
operator|==
name|error_mark_node
condition|)
block|{
name|parameters
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
comment|/* Add the new parameter to the list.  */
name|TREE_CHAIN
argument_list|(
name|parameter
argument_list|)
operator|=
name|parameters
expr_stmt|;
name|parameters
operator|=
name|parameter
expr_stmt|;
comment|/* Peek at the next token.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
operator|||
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_ELLIPSIS
argument_list|)
condition|)
comment|/* The parameter-declaration-list is complete.  */
break|break;
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If it's an ellipsis, then the list is complete.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_ELLIPSIS
condition|)
break|break;
comment|/* Otherwise, there must be more parameters.  Consume the 	     `,'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* When parsing something like:  	        int i(float f, double d) 		              we can tell after seeing the declaration for "f" that we 	     are not looking at an initialization of a variable "i", 	     but rather at the declaration of a function "i".    	     Due to the fact that the parsing of template arguments 	     (as specified to a template-id) requires backtracking we 	     cannot use this technique when inside a template argument 	     list.  */
if|if
condition|(
operator|!
name|parser
operator|->
name|in_template_argument_list_p
operator|&&
operator|!
name|parser
operator|->
name|in_type_id_in_expr_p
operator|&&
name|cp_parser_parsing_tentatively
argument_list|(
name|parser
argument_list|)
operator|&&
operator|!
name|cp_parser_committed_to_tentative_parse
argument_list|(
name|parser
argument_list|)
comment|/* However, a parameter-declaration of the form 		 "foat(f)" (which is a valid declaration of a 		 parameter "f") can also be interpreted as an 		 expression (the conversion of "f" to "float").  */
operator|&&
operator|!
name|parenthesized_p
condition|)
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected `,' or `...'"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_parsing_tentatively
argument_list|(
name|parser
argument_list|)
operator|||
name|cp_parser_committed_to_tentative_parse
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
comment|/*recovering=*/
name|true
argument_list|,
comment|/*or_comma=*/
name|false
argument_list|,
comment|/*consume_paren=*/
name|false
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* We built up the list in reverse order; straighten it out now.  */
return|return
name|nreverse
argument_list|(
name|parameters
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a parameter declaration.     parameter-declaration:      decl-specifier-seq declarator      decl-specifier-seq declarator = assignment-expression      decl-specifier-seq abstract-declarator [opt]      decl-specifier-seq abstract-declarator [opt] = assignment-expression     If TEMPLATE_PARM_P is TRUE, then this parameter-declaration    declares a template parameter.  (In that case, a non-nested `>'    token encountered during the parsing of the assignment-expression    is not interpreted as a greater-than operator.)     Returns a TREE_LIST representing the parameter-declaration.  The    TREE_PURPOSE is the default argument expression, or NULL_TREE if    there is no default argument.  The TREE_VALUE is a representation    of the decl-specifier-seq and declarator.  In particular, the    TREE_VALUE will be a TREE_LIST whose TREE_PURPOSE represents the    decl-specifier-seq and whose TREE_VALUE represents the declarator.    If PARENTHESIZED_P is non-NULL, *PARENTHESIZED_P is set to true iff    the declarator is of the form "(p)".  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_parameter_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|template_parm_p
parameter_list|,
name|bool
modifier|*
name|parenthesized_p
parameter_list|)
block|{
name|int
name|declares_class_or_enum
decl_stmt|;
name|bool
name|greater_than_is_operator_p
decl_stmt|;
name|tree
name|decl_specifiers
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|tree
name|default_argument
decl_stmt|;
name|tree
name|parameter
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
comment|/* In a template parameter, `>' is not an operator.       [temp.param]       When parsing a default template-argument for a non-type      template-parameter, the first non-nested `>' is taken as the end      of the template parameter-list rather than a greater-than      operator.  */
name|greater_than_is_operator_p
operator|=
operator|!
name|template_parm_p
expr_stmt|;
comment|/* Type definitions may not appear in parameter types.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in parameter types"
expr_stmt|;
comment|/* Parse the declaration-specifiers.  */
name|decl_specifiers
operator|=
name|cp_parser_decl_specifier_seq
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_FLAGS_NONE
argument_list|,
operator|&
name|attributes
argument_list|,
operator|&
name|declares_class_or_enum
argument_list|)
expr_stmt|;
comment|/* If an error occurred, there's no reason to attempt to parse the      rest of the declaration.  */
if|if
condition|(
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token is a `)', `,', `=', `>', or `...', then there      is no declarator.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_EQ
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_ELLIPSIS
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_GREATER
condition|)
block|{
name|declarator
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|parenthesized_p
condition|)
operator|*
name|parenthesized_p
operator|=
name|false
expr_stmt|;
block|}
comment|/* Otherwise, there should be a declarator.  */
else|else
block|{
name|bool
name|saved_default_arg_ok_p
init|=
name|parser
operator|->
name|default_arg_ok_p
decl_stmt|;
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|false
expr_stmt|;
comment|/* After seeing a decl-specifier-seq, if the next token is not a 	 "(", there is no possibility that the code is a valid 	 expression.  Therefore, if parsing tentatively, we commit at 	 this point.  */
if|if
condition|(
operator|!
name|parser
operator|->
name|in_template_argument_list_p
comment|/* In an expression context, having seen:  	       (int((char ...  	     we cannot be sure whether we are looking at a 	     function-type (taking a "char" as a parameter) or a cast 	     of some object of type "char" to "int".  */
operator|&&
operator|!
name|parser
operator|->
name|in_type_id_in_expr_p
operator|&&
name|cp_parser_parsing_tentatively
argument_list|(
name|parser
argument_list|)
operator|&&
operator|!
name|cp_parser_committed_to_tentative_parse
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the declarator.  */
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_EITHER
argument_list|,
comment|/*ctor_dtor_or_conv_p=*/
name|NULL
argument_list|,
name|parenthesized_p
argument_list|)
expr_stmt|;
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|saved_default_arg_ok_p
expr_stmt|;
comment|/* After the declarator, allow more attributes.  */
name|attributes
operator|=
name|chainon
argument_list|(
name|attributes
argument_list|,
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The restriction on defining new types applies only to the type      of the parameter, not to the default argument.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
comment|/* If the next token is `=', then process a default argument.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EQ
argument_list|)
condition|)
block|{
name|bool
name|saved_greater_than_is_operator_p
decl_stmt|;
comment|/* Consume the `='.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If we are defining a class, then the tokens that make up the 	 default argument must be saved and processed later.  */
if|if
condition|(
operator|!
name|template_parm_p
operator|&&
name|at_class_scope_p
argument_list|()
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|unsigned
name|depth
init|=
literal|0
decl_stmt|;
comment|/* Create a DEFAULT_ARG to represented the unparsed default              argument.  */
name|default_argument
operator|=
name|make_node
argument_list|(
name|DEFAULT_ARG
argument_list|)
expr_stmt|;
name|DEFARG_TOKENS
argument_list|(
name|default_argument
argument_list|)
operator|=
name|cp_token_cache_new
argument_list|()
expr_stmt|;
comment|/* Add tokens until we have processed the entire default 	     argument.  */
while|while
condition|(
name|true
condition|)
block|{
name|bool
name|done
init|=
name|false
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* What we do depends on what token we have.  */
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
comment|/* In valid code, a default argument must be 		     immediately followed by a `,' `)', or `...'.  */
case|case
name|CPP_COMMA
case|:
case|case
name|CPP_CLOSE_PAREN
case|:
case|case
name|CPP_ELLIPSIS
case|:
comment|/* If we run into a non-nested `;', `}', or `]', 		     then the code is invalid -- but the default 		     argument is certainly over.  */
case|case
name|CPP_SEMICOLON
case|:
case|case
name|CPP_CLOSE_BRACE
case|:
case|case
name|CPP_CLOSE_SQUARE
case|:
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
name|done
operator|=
name|true
expr_stmt|;
comment|/* Update DEPTH, if necessary.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_SQUARE
condition|)
operator|--
name|depth
expr_stmt|;
break|break;
case|case
name|CPP_OPEN_PAREN
case|:
case|case
name|CPP_OPEN_SQUARE
case|:
case|case
name|CPP_OPEN_BRACE
case|:
operator|++
name|depth
expr_stmt|;
break|break;
case|case
name|CPP_GREATER
case|:
comment|/* If we see a non-nested `>', and `>' is not an 		     operator, then it marks the end of the default 		     argument.  */
if|if
condition|(
operator|!
name|depth
operator|&&
operator|!
name|greater_than_is_operator_p
condition|)
name|done
operator|=
name|true
expr_stmt|;
break|break;
comment|/* If we run out of tokens, issue an error message.  */
case|case
name|CPP_EOF
case|:
name|error
argument_list|(
literal|"file ends in default argument"
argument_list|)
expr_stmt|;
name|done
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|CPP_NAME
case|:
case|case
name|CPP_SCOPE
case|:
comment|/* In these cases, we should look for template-ids. 		     For example, if the default argument is  		     `X<int, double>()', we need to do name lookup to 		     figure out whether or not `X' is a template; if 		     so, the `,' does not end the default argument.  		     That is not yet done.  */
break|break;
default|default:
break|break;
block|}
comment|/* If we've reached the end, stop.  */
if|if
condition|(
name|done
condition|)
break|break;
comment|/* Add the token to the token block.  */
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|cp_token_cache_push_token
argument_list|(
name|DEFARG_TOKENS
argument_list|(
name|default_argument
argument_list|)
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Outside of a class definition, we can just parse the          assignment-expression.  */
else|else
block|{
name|bool
name|saved_local_variables_forbidden_p
decl_stmt|;
comment|/* Make sure that PARSER->GREATER_THAN_IS_OPERATOR_P is 	     set correctly.  */
name|saved_greater_than_is_operator_p
operator|=
name|parser
operator|->
name|greater_than_is_operator_p
expr_stmt|;
name|parser
operator|->
name|greater_than_is_operator_p
operator|=
name|greater_than_is_operator_p
expr_stmt|;
comment|/* Local variable names (and the `this' keyword) may not 	     appear in a default argument.  */
name|saved_local_variables_forbidden_p
operator|=
name|parser
operator|->
name|local_variables_forbidden_p
expr_stmt|;
name|parser
operator|->
name|local_variables_forbidden_p
operator|=
name|true
expr_stmt|;
comment|/* Parse the assignment-expression.  */
name|default_argument
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Restore saved state.  */
name|parser
operator|->
name|greater_than_is_operator_p
operator|=
name|saved_greater_than_is_operator_p
expr_stmt|;
name|parser
operator|->
name|local_variables_forbidden_p
operator|=
name|saved_local_variables_forbidden_p
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parser
operator|->
name|default_arg_ok_p
condition|)
block|{
if|if
condition|(
operator|!
name|flag_pedantic_errors
condition|)
name|warning
argument_list|(
literal|"deprecated use of default argument for parameter of non-function"
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"default arguments are only permitted for function parameters"
argument_list|)
expr_stmt|;
name|default_argument
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
else|else
name|default_argument
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Create the representation of the parameter.  */
if|if
condition|(
name|attributes
condition|)
name|decl_specifiers
operator|=
name|tree_cons
argument_list|(
name|attributes
argument_list|,
name|NULL_TREE
argument_list|,
name|decl_specifiers
argument_list|)
expr_stmt|;
name|parameter
operator|=
name|build_tree_list
argument_list|(
name|default_argument
argument_list|,
name|build_tree_list
argument_list|(
name|decl_specifiers
argument_list|,
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|parameter
return|;
block|}
end_function

begin_comment
comment|/* Parse a function-body.     function-body:      compound_statement  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_function_body
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a ctor-initializer-opt followed by a function-body.  Return    true if a ctor-initializer was present.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_ctor_initializer_opt_and_function_body
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|body
decl_stmt|;
name|bool
name|ctor_initializer_p
decl_stmt|;
comment|/* Begin the function body.  */
name|body
operator|=
name|begin_function_body
argument_list|()
expr_stmt|;
comment|/* Parse the optional ctor-initializer.  */
name|ctor_initializer_p
operator|=
name|cp_parser_ctor_initializer_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the function-body.  */
name|cp_parser_function_body
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Finish the function body.  */
name|finish_function_body
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|ctor_initializer_p
return|;
block|}
end_function

begin_comment
comment|/* Parse an initializer.     initializer:      = initializer-clause      ( expression-list )       Returns a expression representing the initializer.  If no    initializer is present, NULL_TREE is returned.       *IS_PARENTHESIZED_INIT is set to TRUE if the `( expression-list )'    production is used, and zero otherwise.  *IS_PARENTHESIZED_INIT is    set to FALSE if there is no initializer present.  If there is an    initializer, and it is not a constant-expression, *NON_CONSTANT_P    is set to true; otherwise it is set to false.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_initializer
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
modifier|*
name|is_parenthesized_init
parameter_list|,
name|bool
modifier|*
name|non_constant_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|init
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Let our caller know whether or not this initializer was      parenthesized.  */
operator|*
name|is_parenthesized_init
operator|=
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
operator|)
expr_stmt|;
comment|/* Assume that the initializer is constant.  */
operator|*
name|non_constant_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EQ
condition|)
block|{
comment|/* Consume the `='.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the initializer-clause.  */
name|init
operator|=
name|cp_parser_initializer_clause
argument_list|(
name|parser
argument_list|,
name|non_constant_p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
name|init
operator|=
name|cp_parser_parenthesized_expression_list
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
name|non_constant_p
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Anything else is an error.  */
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected initializer"
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Parse an initializer-clause.       initializer-clause:      assignment-expression      { initializer-list , [opt] }      { }     Returns an expression representing the initializer.       If the `assignment-expression' production is used the value    returned is simply a representation for the expression.       Otherwise, a CONSTRUCTOR is returned.  The CONSTRUCTOR_ELTS will be    the elements of the initializer-list (or NULL_TREE, if the last    production is used).  The TREE_TYPE for the CONSTRUCTOR will be    NULL_TREE.  There is no way to detect whether or not the optional    trailing `,' was provided.  NON_CONSTANT_P is as for    cp_parser_initializer.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_initializer_clause
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
modifier|*
name|non_constant_p
parameter_list|)
block|{
name|tree
name|initializer
decl_stmt|;
comment|/* If it is not a `{', then we are looking at an      assignment-expression.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
block|{
name|initializer
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant_p=*/
name|true
argument_list|,
name|non_constant_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|non_constant_p
condition|)
name|initializer
operator|=
name|fold_non_dependent_expr
argument_list|(
name|initializer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Consume the `{' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Create a CONSTRUCTOR to represent the braced-initializer.  */
name|initializer
operator|=
name|make_node
argument_list|(
name|CONSTRUCTOR
argument_list|)
expr_stmt|;
comment|/* Mark it with TREE_HAS_CONSTRUCTOR.  This should not be 	 necessary, but check_initializer depends upon it, for  	 now.  */
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|initializer
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If it's not a `}', then there is a non-trivial initializer.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
block|{
comment|/* Parse the initializer list.  */
name|CONSTRUCTOR_ELTS
argument_list|(
name|initializer
argument_list|)
operator|=
name|cp_parser_initializer_list
argument_list|(
name|parser
argument_list|,
name|non_constant_p
argument_list|)
expr_stmt|;
comment|/* A trailing `,' token is allowed.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* Now, there should be a trailing `}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
block|}
return|return
name|initializer
return|;
block|}
end_function

begin_comment
comment|/* Parse an initializer-list.     initializer-list:      initializer-clause      initializer-list , initializer-clause     GNU Extension:        initializer-list:      identifier : initializer-clause      initializer-list, identifier : initializer-clause     Returns a TREE_LIST.  The TREE_VALUE of each node is an expression    for the initializer.  If the TREE_PURPOSE is non-NULL, it is the    IDENTIFIER_NODE naming the field to initialize.  NON_CONSTANT_P is    as for cp_parser_initializer.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_initializer_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
modifier|*
name|non_constant_p
parameter_list|)
block|{
name|tree
name|initializers
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Assume all of the expressions are constant.  */
operator|*
name|non_constant_p
operator|=
name|false
expr_stmt|;
comment|/* Parse the rest of the list.  */
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|tree
name|initializer
decl_stmt|;
name|bool
name|clause_non_constant_p
decl_stmt|;
comment|/* If the next token is an identifier and the following one is a 	 colon, we are looking at the GNU designated-initializer 	 syntax.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|==
name|CPP_COLON
condition|)
block|{
comment|/* Consume the identifier.  */
name|identifier
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|value
expr_stmt|;
comment|/* Consume the `:'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
else|else
name|identifier
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Parse the initializer.  */
name|initializer
operator|=
name|cp_parser_initializer_clause
argument_list|(
name|parser
argument_list|,
operator|&
name|clause_non_constant_p
argument_list|)
expr_stmt|;
comment|/* If any clause is non-constant, so is the entire initializer.  */
if|if
condition|(
name|clause_non_constant_p
condition|)
operator|*
name|non_constant_p
operator|=
name|true
expr_stmt|;
comment|/* Add it to the list.  */
name|initializers
operator|=
name|tree_cons
argument_list|(
name|identifier
argument_list|,
name|initializer
argument_list|,
name|initializers
argument_list|)
expr_stmt|;
comment|/* If the next token is not a comma, we have reached the end of 	 the list.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If the next token is a `}', then we're still done.  An 	 initializer-clause can have a trailing `,' after the 	 initializer-list and before the closing `}'.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
condition|)
break|break;
comment|/* Consume the `,' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* The initializers were built up in reverse order, so we need to      reverse them now.  */
return|return
name|nreverse
argument_list|(
name|initializers
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Classes [gram.class] */
end_comment

begin_comment
comment|/* Parse a class-name.     class-name:      identifier      template-id     TYPENAME_KEYWORD_P is true iff the `typename' keyword has been used    to indicate that names looked up in dependent types should be    assumed to be types.  TEMPLATE_KEYWORD_P is true iff the `template'    keyword has been used to indicate that the name that appears next    is a template.  TYPE_P is true iff the next name should be treated    as class-name, even if it is declared to be some other kind of name    as well.  If CHECK_DEPENDENCY_P is FALSE, names are looked up in    dependent scopes.  If CLASS_HEAD_P is TRUE, this class is the class    being defined in a class-head.     Returns the TYPE_DECL representing the class.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_class_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|typename_keyword_p
parameter_list|,
name|bool
name|template_keyword_p
parameter_list|,
name|bool
name|type_p
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
name|class_head_p
parameter_list|,
name|bool
name|is_declaration
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|bool
name|typename_p
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* All class-names start with an identifier.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NAME
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_TEMPLATE_ID
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected class-name"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* PARSER->SCOPE can be cleared when parsing the template-arguments      to a template-id, so we save it here.  */
name|scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
if|if
condition|(
name|scope
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Any name names a type if we're following the `typename' keyword      in a qualified name where the enclosing scope is type-dependent.  */
name|typename_p
operator|=
operator|(
name|typename_keyword_p
operator|&&
name|scope
operator|&&
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|scope
argument_list|)
operator|)
expr_stmt|;
comment|/* Handle the common case (an identifier, but not a template-id)      efficiently.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
operator|&&
operator|!
name|cp_parser_nth_token_starts_template_argument_list_p
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|tree
name|identifier
decl_stmt|;
comment|/* Look for the identifier.  */
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token isn't an identifier, we are certainly not 	 looking at a class-name.  */
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
name|decl
operator|=
name|error_mark_node
expr_stmt|;
comment|/* If we know this is a type-name, there's no need to look it 	 up.  */
elseif|else
if|if
condition|(
name|typename_p
condition|)
name|decl
operator|=
name|identifier
expr_stmt|;
else|else
block|{
comment|/* If the next token is a `::', then the name must be a type 	     name.  	     [basic.lookup.qual]  	     During the lookup for a name preceding the :: scope 	     resolution operator, object, function, and enumerator 	     names are ignored.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
condition|)
name|type_p
operator|=
name|true
expr_stmt|;
comment|/* Look up the name.  */
name|decl
operator|=
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|,
name|type_p
argument_list|,
comment|/*is_template=*/
name|false
argument_list|,
comment|/*is_namespace=*/
name|false
argument_list|,
name|check_dependency_p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Try a template-id.  */
name|decl
operator|=
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
name|template_keyword_p
argument_list|,
name|check_dependency_p
argument_list|,
name|is_declaration
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
name|decl
operator|=
name|cp_parser_maybe_treat_template_as_class
argument_list|(
name|decl
argument_list|,
name|class_head_p
argument_list|)
expr_stmt|;
comment|/* If this is a typename, create a TYPENAME_TYPE.  */
if|if
condition|(
name|typename_p
operator|&&
name|decl
operator|!=
name|error_mark_node
condition|)
block|{
name|decl
operator|=
name|make_typename_type
argument_list|(
name|scope
argument_list|,
name|decl
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
name|error_mark_node
condition|)
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Check to see that it is really the name of a class.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
condition|)
comment|/* Situations like this:  	 template<typename T> struct A { 	   typename T::template X<int>::I i;  	 };         are problematic.  Is `T::template X<int>' a class-name?  The        standard does not seem to be definitive, but there is no other        valid interpretation of the following `::'.  Therefore, those        names are considered class-names.  */
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|make_typename_type
argument_list|(
name|scope
argument_list|,
name|decl
argument_list|,
name|tf_error
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
operator|==
name|error_mark_node
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected class-name"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Parse a class-specifier.     class-specifier:      class-head { member-specification [opt] }     Returns the TREE_TYPE representing the class.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_class_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|int
name|has_trailing_semicolon
decl_stmt|;
name|bool
name|nested_name_specifier_p
decl_stmt|;
name|unsigned
name|saved_num_template_parameter_lists
decl_stmt|;
name|bool
name|pop_p
init|=
name|false
decl_stmt|;
name|push_deferring_access_checks
argument_list|(
name|dk_no_deferred
argument_list|)
expr_stmt|;
comment|/* Parse the class-head.  */
name|type
operator|=
name|cp_parser_class_head
argument_list|(
name|parser
argument_list|,
operator|&
name|nested_name_specifier_p
argument_list|,
operator|&
name|attributes
argument_list|)
expr_stmt|;
comment|/* If the class-head was a semantic disaster, skip the entire body      of the class.  */
if|if
condition|(
operator|!
name|type
condition|)
block|{
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Look for the `{'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|,
literal|"`{'"
argument_list|)
condition|)
block|{
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Issue an error message if type-definitions are forbidden here.  */
name|cp_parser_check_type_definition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Remember that we are defining one more class.  */
operator|++
name|parser
operator|->
name|num_classes_being_defined
expr_stmt|;
comment|/* Inside the class, surrounding template-parameter-lists do not      apply.  */
name|saved_num_template_parameter_lists
operator|=
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
name|parser
operator|->
name|num_template_parameter_lists
operator|=
literal|0
expr_stmt|;
comment|/* Start the class.  */
if|if
condition|(
name|nested_name_specifier_p
condition|)
name|pop_p
operator|=
name|push_scope
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|begin_class_definition
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
comment|/* If the type is erroneous, skip the entire body of the class.  */
name|cp_parser_skip_to_closing_brace
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
comment|/* Parse the member-specification.  */
name|cp_parser_member_specification_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the trailing `}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
comment|/* We get better error messages by noticing a common problem: a      missing trailing `;'.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|has_trailing_semicolon
operator|=
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_SEMICOLON
operator|)
expr_stmt|;
comment|/* Look for trailing attributes to apply to this class.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|tree
name|sub_attr
init|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|attributes
operator|=
name|chainon
argument_list|(
name|attributes
argument_list|,
name|sub_attr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|error_mark_node
condition|)
name|type
operator|=
name|finish_struct
argument_list|(
name|type
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|pop_p
condition|)
name|pop_scope
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this class is not itself within the scope of another class,      then we need to parse the bodies of all of the queued function      definitions.  Note that the queued functions defined in a class      are not always processed immediately following the      class-specifier for that class.  Consider:         struct A {          struct B { void f() { sizeof (A); } };        };       If `f' were processed before the processing of `A' were      completed, there would be no way to compute the size of `A'.      Note that the nesting we are interested in here is lexical --      not the semantic nesting given by TYPE_CONTEXT.  In particular,      for:         struct A { struct B; };        struct A::B { void f() { } };       there is no need to delay the parsing of `A::B::f'.  */
if|if
condition|(
operator|--
name|parser
operator|->
name|num_classes_being_defined
operator|==
literal|0
condition|)
block|{
name|tree
name|queue_entry
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* In a first pass, parse default arguments to the functions. 	 Then, in a second pass, parse the bodies of the functions. 	 This two-phased approach handles cases like: 	  	    struct S {                void f() { g(); }                void g(int i = 3);             };           */
for|for
control|(
name|TREE_PURPOSE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|=
name|nreverse
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
argument_list|)
init|;
operator|(
name|queue_entry
operator|=
name|TREE_PURPOSE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|)
condition|;
name|TREE_PURPOSE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
argument_list|)
control|)
block|{
name|fn
operator|=
name|TREE_VALUE
argument_list|(
name|queue_entry
argument_list|)
expr_stmt|;
comment|/* Make sure that any template parameters are in scope.  */
name|maybe_begin_member_template_processing
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* If there are default arguments that have not yet been processed, 	     take care of them now.  */
name|cp_parser_late_parsing_default_args
argument_list|(
name|parser
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* Remove any template parameters from the symbol table.  */
name|maybe_end_member_template_processing
argument_list|()
expr_stmt|;
block|}
comment|/* Now parse the body of the functions.  */
for|for
control|(
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|=
name|nreverse
argument_list|(
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
argument_list|)
init|;
operator|(
name|queue_entry
operator|=
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|)
condition|;
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
argument_list|)
control|)
block|{
comment|/* Figure out which function we need to process.  */
name|fn
operator|=
name|TREE_VALUE
argument_list|(
name|queue_entry
argument_list|)
expr_stmt|;
comment|/* A hack to prevent garbage collection.  */
name|function_depth
operator|++
expr_stmt|;
comment|/* Parse the function.  */
name|cp_parser_late_parsing_for_member
argument_list|(
name|parser
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|function_depth
operator|--
expr_stmt|;
block|}
block|}
comment|/* Put back any saved access checks.  */
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Restore the count of active template-parameter-lists.  */
name|parser
operator|->
name|num_template_parameter_lists
operator|=
name|saved_num_template_parameter_lists
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Parse a class-head.     class-head:      class-key identifier [opt] base-clause [opt]      class-key nested-name-specifier identifier base-clause [opt]      class-key nested-name-specifier [opt] template-id         base-clause [opt]       GNU Extensions:      class-key attributes identifier [opt] base-clause [opt]      class-key attributes nested-name-specifier identifier base-clause [opt]      class-key attributes nested-name-specifier [opt] template-id         base-clause [opt]       Returns the TYPE of the indicated class.  Sets    *NESTED_NAME_SPECIFIER_P to TRUE iff one of the productions    involving a nested-name-specifier was used, and FALSE otherwise.     Returns NULL_TREE if the class-head is syntactically valid, but    semantically invalid in a way that means we should skip the entire    body of the class.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_class_head
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
modifier|*
name|nested_name_specifier_p
parameter_list|,
name|tree
modifier|*
name|attributes_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|nested_name_specifier
decl_stmt|;
name|enum
name|tag_types
name|class_key
decl_stmt|;
name|tree
name|id
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|bool
name|template_id_p
init|=
name|false
decl_stmt|;
name|bool
name|qualified_p
init|=
name|false
decl_stmt|;
name|bool
name|invalid_nested_name_p
init|=
name|false
decl_stmt|;
name|bool
name|invalid_explicit_specialization_p
init|=
name|false
decl_stmt|;
name|bool
name|pop_p
init|=
name|false
decl_stmt|;
name|unsigned
name|num_templates
decl_stmt|;
comment|/* Assume no nested-name-specifier will be present.  */
operator|*
name|nested_name_specifier_p
operator|=
name|false
expr_stmt|;
comment|/* Assume no template parameter lists will be used in defining the      type.  */
name|num_templates
operator|=
literal|0
expr_stmt|;
comment|/* Look for the class-key.  */
name|class_key
operator|=
name|cp_parser_class_key
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_key
operator|==
name|none_type
condition|)
return|return
name|error_mark_node
return|;
comment|/* Parse the attributes.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is `::', that is invalid -- but sometimes      people do try to write:         struct ::S {};         Handle this gracefully by accepting the extra qualifier, and then      issuing an error about it later if this really is a      class-head.  If it turns out just to be an elaborated type      specifier, remain silent.  */
if|if
condition|(
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
condition|)
name|qualified_p
operator|=
name|true
expr_stmt|;
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
comment|/* Determine the name of the class.  Begin by looking for an      optional nested-name-specifier.  */
name|nested_name_specifier
operator|=
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|false
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If there was a nested-name-specifier, then there *must* be an      identifier.  */
if|if
condition|(
name|nested_name_specifier
condition|)
block|{
comment|/* Although the grammar says `identifier', it really means 	 `class-name' or `template-name'.  You are only allowed to 	 define a class that has already been declared with this 	 syntax.    	 The proposed resolution for Core Issue 180 says that whever 	 you see `class T::X' you should treat `X' as a type-name. 	  	 It is OK to define an inaccessible class; for example: 	             class A { class B; };            class A::B {}; 	           We do not know if we will see a class-name, or a 	 template-name.  We look for a class-name first, in case the 	 class-name is a template-id; if we looked for the 	 template-name first we would stop after the template-name.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|type
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*type_p=*/
name|true
argument_list|,
comment|/*check_dependency_p=*/
name|false
argument_list|,
comment|/*class_head_p=*/
name|true
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If that didn't work, ignore the nested-name-specifier.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|invalid_nested_name_p
operator|=
name|true
expr_stmt|;
name|id
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|error_mark_node
condition|)
name|id
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* If we could not find a corresponding TYPE, treat this 	 declaration like an unqualified declaration.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|nested_name_specifier
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Otherwise, count the number of templates used in TYPE and its 	 containing scopes.  */
else|else
block|{
name|tree
name|scope
decl_stmt|;
for|for
control|(
name|scope
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
init|;
name|scope
operator|&&
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|;
name|scope
operator|=
operator|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|?
name|TYPE_CONTEXT
argument_list|(
name|scope
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|scope
argument_list|)
operator|)
control|)
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|scope
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|scope
argument_list|)
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|scope
argument_list|)
condition|)
operator|++
name|num_templates
expr_stmt|;
block|}
block|}
comment|/* Otherwise, the identifier is optional.  */
else|else
block|{
comment|/* We don't know whether what comes next is a template-id, 	 an identifier, or nothing at all.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Check for a template-id.  */
name|id
operator|=
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
comment|/* If that didn't work, it could still be an identifier.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
name|id
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|id
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|template_id_p
operator|=
name|true
expr_stmt|;
operator|++
name|num_templates
expr_stmt|;
block|}
block|}
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|cp_parser_check_for_invalid_template_id
argument_list|(
name|parser
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* If it's not a `:' or a `{' then we can't really be looking at a      class-head, since a class-head only appears as part of a      class-specifier.  We have to detect this situation before calling      xref_tag, since that has irreversible side-effects.  */
if|if
condition|(
operator|!
name|cp_parser_next_token_starts_class_definition_p
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected `{' or `:'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* At this point, we're going ahead with the class-specifier, even      if some other problem occurs.  */
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Issue the error about the overly-qualified name now.  */
if|if
condition|(
name|qualified_p
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"global qualification of class name is invalid"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|invalid_nested_name_p
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"qualified name does not name a class"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nested_name_specifier
condition|)
block|{
name|tree
name|scope
decl_stmt|;
comment|/* Figure out in what scope the declaration is being placed.  */
name|scope
operator|=
name|current_scope
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scope
condition|)
name|scope
operator|=
name|current_namespace
expr_stmt|;
comment|/* If that scope does not contain the scope in which the 	 class was originally declared, the program is invalid.  */
if|if
condition|(
name|scope
operator|&&
operator|!
name|is_ancestor
argument_list|(
name|scope
argument_list|,
name|nested_name_specifier
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%D' in `%D' which does not "
literal|"enclose `%D'"
argument_list|,
name|type
argument_list|,
name|scope
argument_list|,
name|nested_name_specifier
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL_TREE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* [dcl.meaning]           A declarator-id shall not be qualified exception of the 	 definition of a ... nested class outside of its class 	 ... [or] a the definition or explicit instantiation of a 	 class member of a namespace outside of its namespace.  */
if|if
condition|(
name|scope
operator|==
name|nested_name_specifier
condition|)
block|{
name|pedwarn
argument_list|(
literal|"extra qualification ignored"
argument_list|)
expr_stmt|;
name|nested_name_specifier
operator|=
name|NULL_TREE
expr_stmt|;
name|num_templates
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* An explicit-specialization must be preceded by "template<>".  If      it is not, try to recover gracefully.  */
if|if
condition|(
name|at_namespace_scope_p
argument_list|()
operator|&&
name|parser
operator|->
name|num_template_parameter_lists
operator|==
literal|0
operator|&&
name|template_id_p
condition|)
block|{
name|error
argument_list|(
literal|"an explicit specialization must be preceded by 'template<>'"
argument_list|)
expr_stmt|;
name|invalid_explicit_specialization_p
operator|=
name|true
expr_stmt|;
comment|/* Take the same action that would have been taken by 	 cp_parser_explicit_specialization.  */
operator|++
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
name|begin_specialization
argument_list|()
expr_stmt|;
block|}
comment|/* There must be no "return" statements between this point and the      end of this function; set "type "to the correct return value and      use "goto done;" to return.  */
comment|/* Make sure that the right number of template parameters were      present.  */
if|if
condition|(
operator|!
name|cp_parser_check_template_parameters
argument_list|(
name|parser
argument_list|,
name|num_templates
argument_list|)
condition|)
block|{
comment|/* If something went wrong, there is no point in even trying to 	 process the class-definition.  */
name|type
operator|=
name|NULL_TREE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Look up the type.  */
if|if
condition|(
name|template_id_p
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|maybe_process_partial_specialization
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|nested_name_specifier
condition|)
block|{
comment|/* If the class was unnamed, create a dummy name.  */
if|if
condition|(
operator|!
name|id
condition|)
name|id
operator|=
name|make_anon_name
argument_list|()
expr_stmt|;
name|type
operator|=
name|xref_tag
argument_list|(
name|class_key
argument_list|,
name|id
argument_list|,
comment|/*globalize=*/
name|false
argument_list|,
name|parser
operator|->
name|num_template_parameter_lists
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|class_type
decl_stmt|;
name|bool
name|pop_p
init|=
name|false
decl_stmt|;
comment|/* Given:  	    template<typename T> struct S { struct T }; 	    template<typename T> struct S<T>::T { };  	 we will get a TYPENAME_TYPE when processing the definition of 	 `S::T'.  We need to resolve it to the actual type before we 	 try to define it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
name|class_type
operator|=
name|resolve_typename_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
comment|/*only_current_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_type
operator|!=
name|error_mark_node
condition|)
name|type
operator|=
name|TYPE_NAME
argument_list|(
name|class_type
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"could not resolve typename type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
name|maybe_process_partial_specialization
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|class_type
operator|=
name|current_class_type
expr_stmt|;
comment|/* Enter the scope indicated by the nested-name-specifier.  */
if|if
condition|(
name|nested_name_specifier
condition|)
name|pop_p
operator|=
name|push_scope
argument_list|(
name|nested_name_specifier
argument_list|)
expr_stmt|;
comment|/* Get the canonical version of this type.  */
name|type
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
operator|&&
operator|!
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|type
operator|=
name|push_template_decl
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|nested_name_specifier
condition|)
block|{
operator|*
name|nested_name_specifier_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|pop_p
condition|)
name|pop_scope
argument_list|(
name|nested_name_specifier
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Indicate whether this class was declared as a `class' or as a      `struct'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|class_key
operator|==
name|class_type
operator|)
expr_stmt|;
name|cp_parser_check_class_key
argument_list|(
name|class_key
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Enter the scope containing the class; the names of base classes      should be looked up in that context.  For example, given:         struct A { struct B {}; struct C; };        struct A::C : B {};       is valid.  */
if|if
condition|(
name|nested_name_specifier
condition|)
name|pop_p
operator|=
name|push_scope
argument_list|(
name|nested_name_specifier
argument_list|)
expr_stmt|;
comment|/* Now, look for the base-clause.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COLON
condition|)
block|{
name|tree
name|bases
decl_stmt|;
comment|/* Get the list of base-classes.  */
name|bases
operator|=
name|cp_parser_base_clause
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Process them.  */
name|xref_basetypes
argument_list|(
name|type
argument_list|,
name|bases
argument_list|)
expr_stmt|;
block|}
comment|/* Leave the scope given by the nested-name-specifier.  We will      enter the class scope itself while processing the members.  */
if|if
condition|(
name|pop_p
condition|)
name|pop_scope
argument_list|(
name|nested_name_specifier
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|invalid_explicit_specialization_p
condition|)
block|{
name|end_specialization
argument_list|()
expr_stmt|;
operator|--
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
block|}
operator|*
name|attributes_p
operator|=
name|attributes
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Parse a class-key.     class-key:      class      struct      union     Returns the kind of class-key specified, or none_type to indicate    error.  */
end_comment

begin_function
specifier|static
name|enum
name|tag_types
name|cp_parser_class_key
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|tag_types
name|tag_type
decl_stmt|;
comment|/* Look for the class-key.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|,
literal|"class-key"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
name|none_type
return|;
comment|/* Check to see if the TOKEN is a class-key.  */
name|tag_type
operator|=
name|cp_parser_token_is_class_key
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag_type
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected class-key"
argument_list|)
expr_stmt|;
return|return
name|tag_type
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) member-specification.     member-specification:      member-declaration member-specification [opt]      access-specifier : member-specification [opt]  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_member_specification_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|rid
name|keyword
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's a `}', or EOF then we've seen all the members.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
comment|/* See if this token is a keyword.  */
name|keyword
operator|=
name|token
operator|->
name|keyword
expr_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_PUBLIC
case|:
case|case
name|RID_PROTECTED
case|:
case|case
name|RID_PRIVATE
case|:
comment|/* Consume the access-specifier.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Remember which access-specifier is active.  */
name|current_access_specifier
operator|=
name|token
operator|->
name|value
expr_stmt|;
comment|/* Look for the `:'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"`:'"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Otherwise, the next construction must be a 	     member-declaration.  */
name|cp_parser_member_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Parse a member-declaration.       member-declaration:      decl-specifier-seq [opt] member-declarator-list [opt] ;      function-definition ; [opt]      :: [opt] nested-name-specifier template [opt] unqualified-id ;      using-declaration      template-declaration      member-declarator-list:      member-declarator      member-declarator-list , member-declarator     member-declarator:      declarator pure-specifier [opt]       declarator constant-initializer [opt]      identifier [opt] : constant-expression      GNU Extensions:     member-declaration:      __extension__ member-declaration     member-declarator:      declarator attributes [opt] pure-specifier [opt]      declarator attributes [opt] constant-initializer [opt]      identifier [opt] attributes [opt] : constant-expression  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_member_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|decl_specifiers
decl_stmt|;
name|tree
name|prefix_attributes
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|declares_class_or_enum
decl_stmt|;
name|bool
name|friend_p
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|int
name|saved_pedantic
decl_stmt|;
comment|/* Check for the `__extension__' keyword.  */
if|if
condition|(
name|cp_parser_extension_opt
argument_list|(
name|parser
argument_list|,
operator|&
name|saved_pedantic
argument_list|)
condition|)
block|{
comment|/* Recurse.  */
name|cp_parser_member_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Restore the old value of the PEDANTIC flag.  */
name|pedantic
operator|=
name|saved_pedantic
expr_stmt|;
return|return;
block|}
comment|/* Check for a template-declaration.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TEMPLATE
argument_list|)
condition|)
block|{
comment|/* Parse the template-declaration.  */
name|cp_parser_template_declaration
argument_list|(
name|parser
argument_list|,
comment|/*member_p=*/
name|true
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for a using-declaration.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_USING
argument_list|)
condition|)
block|{
comment|/* Parse the using-declaration.  */
name|cp_parser_using_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Parse the decl-specifier-seq.  */
name|decl_specifiers
operator|=
name|cp_parser_decl_specifier_seq
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_FLAGS_OPTIONAL
argument_list|,
operator|&
name|prefix_attributes
argument_list|,
operator|&
name|declares_class_or_enum
argument_list|)
expr_stmt|;
comment|/* Check for an invalid type-name.  */
if|if
condition|(
name|cp_parser_diagnose_invalid_type_name
argument_list|(
name|parser
argument_list|)
condition|)
return|return;
comment|/* If there is no declarator, then the decl-specifier-seq should      specify a type.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
comment|/* If there was no decl-specifier-seq, and the next token is a 	 `;', then we have something like:  	   struct S { ; };  	 [class.mem]  	 Each member-declaration shall declare at least one member 	 name of the class.  */
if|if
condition|(
operator|!
name|decl_specifiers
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"extra semicolon"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|type
decl_stmt|;
comment|/* See if this declaration is a friend.  */
name|friend_p
operator|=
name|cp_parser_friend_p
argument_list|(
name|decl_specifiers
argument_list|)
expr_stmt|;
comment|/* If there were decl-specifiers, check to see if there was 	     a class-declaration.  */
name|type
operator|=
name|check_tag_decl
argument_list|(
name|decl_specifiers
argument_list|)
expr_stmt|;
comment|/* Nested classes have already been added to the class, but 	     a `friend' needs to be explicitly registered.  */
if|if
condition|(
name|friend_p
condition|)
block|{
comment|/* If the `friend' keyword was present, the friend must 		 be introduced with a class-key.  */
if|if
condition|(
operator|!
name|declares_class_or_enum
condition|)
name|error
argument_list|(
literal|"a class-key must be used when declaring a friend"
argument_list|)
expr_stmt|;
comment|/* In this case:  		    template<typename T> struct A {                        friend struct A<T>::B;                      };   		  A<T>::B will be represented by a TYPENAME_TYPE, and 		  therefore not recognized by check_tag_decl.  */
if|if
condition|(
operator|!
name|type
condition|)
block|{
name|tree
name|specifier
decl_stmt|;
for|for
control|(
name|specifier
operator|=
name|decl_specifiers
init|;
name|specifier
condition|;
name|specifier
operator|=
name|TREE_CHAIN
argument_list|(
name|specifier
argument_list|)
control|)
block|{
name|tree
name|s
init|=
name|TREE_VALUE
argument_list|(
name|specifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|s
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|get_global_value_if_present
argument_list|(
name|s
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|s
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|s
operator|=
name|TREE_TYPE
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|type
operator|=
name|s
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"friend declaration does not name a class or "
literal|"function"
argument_list|)
expr_stmt|;
else|else
name|make_friend_class
argument_list|(
name|current_class_type
argument_list|,
name|type
argument_list|,
comment|/*complain=*/
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* If there is no TYPE, an error message will already have 	     been issued.  */
elseif|else
if|if
condition|(
operator|!
name|type
condition|)
empty_stmt|;
comment|/* An anonymous aggregate has to be handled specially; such 	     a declaration really declares a data member (with a 	     particular type), as opposed to a nested class.  */
elseif|else
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Remove constructors and such from TYPE, now that we 		 know it is an anonymous aggregate.  */
name|fixup_anonymous_aggr
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* And make the corresponding data member.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Add it to the class.  */
name|finish_member_declaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|cp_parser_check_access_in_redeclaration
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* See if these declarations will be friends.  */
name|friend_p
operator|=
name|cp_parser_friend_p
argument_list|(
name|decl_specifiers
argument_list|)
expr_stmt|;
comment|/* Keep going until we hit the `;' at the end of the  	 declaration.  */
while|while
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|tree
name|attributes
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|first_attribute
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Check for a bitfield declaration.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COLON
operator|||
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
operator|&&
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|==
name|CPP_COLON
operator|)
condition|)
block|{
name|tree
name|identifier
decl_stmt|;
name|tree
name|width
decl_stmt|;
comment|/* Get the name of the bitfield.  Note that we cannot just 		 check TOKEN here because it may have been invalidated by 		 the call to cp_lexer_peek_nth_token above.  */
if|if
condition|(
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|type
operator|!=
name|CPP_COLON
condition|)
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|identifier
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Consume the `:' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Get the width of the bitfield.  */
name|width
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant=*/
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Look for attributes that apply to the bitfield.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Remember which attributes are prefix attributes and 		 which are not.  */
name|first_attribute
operator|=
name|attributes
expr_stmt|;
comment|/* Combine the attributes.  */
name|attributes
operator|=
name|chainon
argument_list|(
name|prefix_attributes
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
comment|/* Create the bitfield declaration.  */
name|decl
operator|=
name|grokbitfield
argument_list|(
name|identifier
argument_list|,
name|decl_specifiers
argument_list|,
name|width
argument_list|)
expr_stmt|;
comment|/* Apply the attributes.  */
name|cplus_decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attributes
argument_list|,
comment|/*flags=*/
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|declarator
decl_stmt|;
name|tree
name|initializer
decl_stmt|;
name|tree
name|asm_specification
decl_stmt|;
name|int
name|ctor_dtor_or_conv_p
decl_stmt|;
comment|/* Parse the declarator.  */
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_NAMED
argument_list|,
operator|&
name|ctor_dtor_or_conv_p
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|)
expr_stmt|;
comment|/* If something went wrong parsing the declarator, make sure 		 that we at least consume some tokens.  */
if|if
condition|(
name|declarator
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Skip to the end of the statement.  */
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is not a semicolon, that is 		     probably because we just skipped over the body of 		     a function.  So, we consume a semicolon if 		     present, but do not issue an error message if it 		     is not present.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp_parser_check_for_definition_in_return_type
argument_list|(
name|declarator
argument_list|,
name|declares_class_or_enum
argument_list|)
expr_stmt|;
comment|/* Look for an asm-specification.  */
name|asm_specification
operator|=
name|cp_parser_asm_specification_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for attributes that apply to the declaration.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Remember which attributes are prefix attributes and 		 which are not.  */
name|first_attribute
operator|=
name|attributes
expr_stmt|;
comment|/* Combine the attributes.  */
name|attributes
operator|=
name|chainon
argument_list|(
name|prefix_attributes
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
comment|/* If it's an `=', then we have a constant-initializer or a 		 pure-specifier.  It is not correct to parse the 		 initializer before registering the member declaration 		 since the member declaration should be in scope while 		 its initializer is processed.  However, the rest of the 		 front end does not yet provide an interface that allows 		 us to handle this correctly.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EQ
argument_list|)
condition|)
block|{
comment|/* In [class.mem]:  		     A pure-specifier shall be used only in the declaration of 		     a virtual function.    		     A member-declarator can contain a constant-initializer 		     only if it declares a static member of integral or 		     enumeration type.    		     Therefore, if the DECLARATOR is for a function, we look 		     for a pure-specifier; otherwise, we look for a 		     constant-initializer.  When we call `grokfield', it will 		     perform more stringent semantics checks.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|initializer
operator|=
name|cp_parser_pure_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
comment|/* Parse the initializer.  */
name|initializer
operator|=
name|cp_parser_constant_initializer
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, there is no initializer.  */
else|else
name|initializer
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* See if we are probably looking at a function 		 definition.  We are certainly not looking at at a 		 member-declarator.  Calling `grokfield' has 		 side-effects, so we must not do it unless we are sure 		 that we are looking at a member-declarator.  */
if|if
condition|(
name|cp_parser_token_starts_function_definition_p
argument_list|(
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The grammar does not allow a pure-specifier to be 		     used when a member function is defined.  (It is 		     possible that this fact is an oversight in the 		     standard, since a pure function may be defined 		     outside of the class-specifier.  */
if|if
condition|(
name|initializer
condition|)
name|error
argument_list|(
literal|"pure-specifier on function-definition"
argument_list|)
expr_stmt|;
name|decl
operator|=
name|cp_parser_save_member_function_body
argument_list|(
name|parser
argument_list|,
name|decl_specifiers
argument_list|,
name|declarator
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
comment|/* If the member was not a friend, declare it here.  */
if|if
condition|(
operator|!
name|friend_p
condition|)
name|finish_member_declaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token is a semicolon, consume it.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_SEMICOLON
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Create the declaration.  */
name|decl
operator|=
name|grokfield
argument_list|(
name|declarator
argument_list|,
name|decl_specifiers
argument_list|,
name|initializer
argument_list|,
name|asm_specification
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
comment|/* Any initialization must have been from a 		     constant-expression.  */
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|initializer
condition|)
name|DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Reset PREFIX_ATTRIBUTES.  */
while|while
condition|(
name|attributes
operator|&&
name|TREE_CHAIN
argument_list|(
name|attributes
argument_list|)
operator|!=
name|first_attribute
condition|)
name|attributes
operator|=
name|TREE_CHAIN
argument_list|(
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|attributes
condition|)
name|TREE_CHAIN
argument_list|(
name|attributes
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If there is any qualification still in effect, clear it 	     now; we will be starting fresh with the next declarator.  */
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If it's a `,', then there are more declarators.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token isn't a `;', then we have a parse error.  */
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected `;'"
argument_list|)
expr_stmt|;
comment|/* Skip tokens until we find a `;'.  */
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|decl
condition|)
block|{
comment|/* Add DECL to the list of members.  */
if|if
condition|(
operator|!
name|friend_p
condition|)
name|finish_member_declaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|cp_parser_save_default_args
argument_list|(
name|parser
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a pure-specifier.     pure-specifier:      = 0     Returns INTEGER_ZERO_NODE if a pure specifier is found.    Otherwise, ERROR_MARK_NODE is returned.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_pure_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Look for the `=' token.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_EQ
argument_list|,
literal|"`='"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Look for the `0' token.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_NUMBER
argument_list|,
literal|"`0'"
argument_list|)
expr_stmt|;
comment|/* Unfortunately, this will accept `0L' and `0x00' as well.  We need      to get information from the lexer about how the number was      spelled in order to fix this problem.  */
if|if
condition|(
operator|!
name|token
operator|||
operator|!
name|integer_zerop
argument_list|(
name|token
operator|->
name|value
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
return|return
name|integer_zero_node
return|;
block|}
end_function

begin_comment
comment|/* Parse a constant-initializer.     constant-initializer:      = constant-expression     Returns a representation of the constant-expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_constant_initializer
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Look for the `=' token.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_EQ
argument_list|,
literal|"`='"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* It is invalid to write:         struct S { static const int i = { 7 }; };       */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"a brace-enclosed initializer is not allowed here"
argument_list|)
expr_stmt|;
comment|/* Consume the opening brace.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Skip the initializer.  */
name|cp_parser_skip_to_closing_brace
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the trailing `}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant=*/
name|false
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Derived classes [gram.class.derived] */
end_comment

begin_comment
comment|/* Parse a base-clause.     base-clause:      : base-specifier-list       base-specifier-list:      base-specifier      base-specifier-list , base-specifier     Returns a TREE_LIST representing the base-classes, in the order in    which they were declared.  The representation of each node is as    described by cp_parser_base_specifier.       In the case that no bases are specified, this function will return    NULL_TREE, not ERROR_MARK_NODE.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_base_clause
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|bases
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Look for the `:' that begins the list.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"`:'"
argument_list|)
expr_stmt|;
comment|/* Scan the base-specifier-list.  */
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|base
decl_stmt|;
comment|/* Look for the base-specifier.  */
name|base
operator|=
name|cp_parser_base_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Add BASE to the front of the list.  */
if|if
condition|(
name|base
operator|!=
name|error_mark_node
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|base
argument_list|)
operator|=
name|bases
expr_stmt|;
name|bases
operator|=
name|base
expr_stmt|;
block|}
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's not a comma, then the list is complete.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_COMMA
condition|)
break|break;
comment|/* Consume the `,'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* PARSER->SCOPE may still be non-NULL at this point, if the last      base class had a qualified name.  However, the next name that      appears is certainly not qualified.  */
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|nreverse
argument_list|(
name|bases
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a base-specifier.     base-specifier:      :: [opt] nested-name-specifier [opt] class-name      virtual access-specifier [opt] :: [opt] nested-name-specifier        [opt] class-name      access-specifier virtual [opt] :: [opt] nested-name-specifier        [opt] class-name     Returns a TREE_LIST.  The TREE_PURPOSE will be one of    ACCESS_{DEFAULT,PUBLIC,PROTECTED,PRIVATE}_[VIRTUAL]_NODE to    indicate the specifiers provided.  The TREE_VALUE will be a TYPE    (or the ERROR_MARK_NODE) indicating the type that was specified.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_base_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|bool
name|done
init|=
name|false
decl_stmt|;
name|bool
name|virtual_p
init|=
name|false
decl_stmt|;
name|bool
name|duplicate_virtual_error_issued_p
init|=
name|false
decl_stmt|;
name|bool
name|duplicate_access_error_issued_p
init|=
name|false
decl_stmt|;
name|bool
name|class_scope_p
decl_stmt|,
name|template_p
decl_stmt|;
name|tree
name|access
init|=
name|access_default_node
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* Process the optional `virtual' and `access-specifier'.  */
while|while
condition|(
operator|!
name|done
condition|)
block|{
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Process `virtual'.  */
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_VIRTUAL
case|:
comment|/* If `virtual' appears more than once, issue an error.  */
if|if
condition|(
name|virtual_p
operator|&&
operator|!
name|duplicate_virtual_error_issued_p
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"`virtual' specified more than once in base-specified"
argument_list|)
expr_stmt|;
name|duplicate_virtual_error_issued_p
operator|=
name|true
expr_stmt|;
block|}
name|virtual_p
operator|=
name|true
expr_stmt|;
comment|/* Consume the `virtual' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_PUBLIC
case|:
case|case
name|RID_PROTECTED
case|:
case|case
name|RID_PRIVATE
case|:
comment|/* If more than one access specifier appears, issue an 	     error.  */
if|if
condition|(
name|access
operator|!=
name|access_default_node
operator|&&
operator|!
name|duplicate_access_error_issued_p
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"more than one access specifier in base-specified"
argument_list|)
expr_stmt|;
name|duplicate_access_error_issued_p
operator|=
name|true
expr_stmt|;
block|}
name|access
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|token
operator|->
name|keyword
index|]
expr_stmt|;
comment|/* Consume the access-specifier.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
break|break;
default|default:
name|done
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|/* It is not uncommon to see programs mechanically, errouneously, use      the 'typename' keyword to denote (dependent) qualified types      as base classes.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TYPENAME
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|error
argument_list|(
literal|"keyword `typename' not allowed outside of templates"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"keyword `typename' not allowed in this context "
literal|"(the base class is implicitly a type)"
argument_list|)
expr_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* Look for the optional `::' operator.  */
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the nested-name-specifier.  The simplest way to      implement:         [temp.res]         The keyword `typename' is not permitted in a base-specifier or        mem-initializer; in these contexts a qualified name that        depends on a template-parameter is implicitly assumed to be a        type name.       is to pretend that we have seen the `typename' keyword at this      point.  */
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|true
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|true
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
comment|/* If the base class is given by a qualified name, assume that names      we see are type names or templates, as appropriate.  */
name|class_scope_p
operator|=
operator|(
name|parser
operator|->
name|scope
operator|&&
name|TYPE_P
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|)
expr_stmt|;
name|template_p
operator|=
name|class_scope_p
operator|&&
name|cp_parser_optional_template_keyword
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Finally, look for the class-name.  */
name|type
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
name|class_scope_p
argument_list|,
name|template_p
argument_list|,
comment|/*type_p=*/
name|true
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|finish_base_specifier
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|access
argument_list|,
name|virtual_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Exception handling [gram.exception] */
end_comment

begin_comment
comment|/* Parse an (optional) exception-specification.     exception-specification:      throw ( type-id-list [opt] )     Returns a TREE_LIST representing the exception-specification.  The    TREE_VALUE of each node is a type.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_exception_specification_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|type_id_list
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's not `throw', then there's no exception-specification.  */
if|if
condition|(
operator|!
name|cp_parser_is_keyword
argument_list|(
name|token
argument_list|,
name|RID_THROW
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Consume the `throw'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's not a `)', then there is a type-id-list.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_CLOSE_PAREN
condition|)
block|{
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
comment|/* Types may not be defined in an exception-specification.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in an exception-specification"
expr_stmt|;
comment|/* Parse the type-id-list.  */
name|type_id_list
operator|=
name|cp_parser_type_id_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Restore the saved message.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
block|}
else|else
name|type_id_list
operator|=
name|empty_except_spec
expr_stmt|;
comment|/* Look for the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
return|return
name|type_id_list
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) type-id-list.     type-id-list:      type-id      type-id-list , type-id     Returns a TREE_LIST.  The TREE_VALUE of each node is a TYPE,    in the order that the types were presented.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_type_id_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|types
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* Get the next type-id.  */
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Add it to the list.  */
name|types
operator|=
name|add_exception_specifier
argument_list|(
name|types
argument_list|,
name|type
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it is not a `,', we are done.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_COMMA
condition|)
break|break;
comment|/* Consume the `,'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
return|return
name|nreverse
argument_list|(
name|types
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a try-block.     try-block:      try compound-statement handler-seq  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_try_block
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|try_block
decl_stmt|;
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_TRY
argument_list|,
literal|"`try'"
argument_list|)
expr_stmt|;
name|try_block
operator|=
name|begin_try_block
argument_list|()
expr_stmt|;
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|finish_try_block
argument_list|(
name|try_block
argument_list|)
expr_stmt|;
name|cp_parser_handler_seq
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|finish_handler_sequence
argument_list|(
name|try_block
argument_list|)
expr_stmt|;
return|return
name|try_block
return|;
block|}
end_function

begin_comment
comment|/* Parse a function-try-block.     function-try-block:      try ctor-initializer [opt] function-body handler-seq  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_function_try_block
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|try_block
decl_stmt|;
name|bool
name|ctor_initializer_p
decl_stmt|;
comment|/* Look for the `try' keyword.  */
if|if
condition|(
operator|!
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_TRY
argument_list|,
literal|"`try'"
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Let the rest of the front-end know where we are.  */
name|try_block
operator|=
name|begin_function_try_block
argument_list|()
expr_stmt|;
comment|/* Parse the function-body.  */
name|ctor_initializer_p
operator|=
name|cp_parser_ctor_initializer_opt_and_function_body
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* We're done with the `try' part.  */
name|finish_function_try_block
argument_list|(
name|try_block
argument_list|)
expr_stmt|;
comment|/* Parse the handlers.  */
name|cp_parser_handler_seq
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* We're done with the handlers.  */
name|finish_function_handler_sequence
argument_list|(
name|try_block
argument_list|)
expr_stmt|;
return|return
name|ctor_initializer_p
return|;
block|}
end_function

begin_comment
comment|/* Parse a handler-seq.     handler-seq:      handler handler-seq [opt]  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_handler_seq
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Parse the handler.  */
name|cp_parser_handler
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's not `catch' then there are no more handlers.  */
if|if
condition|(
operator|!
name|cp_parser_is_keyword
argument_list|(
name|token
argument_list|,
name|RID_CATCH
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Parse a handler.     handler:      catch ( exception-declaration ) compound-statement  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_handler
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|handler
decl_stmt|;
name|tree
name|declaration
decl_stmt|;
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_CATCH
argument_list|,
literal|"`catch'"
argument_list|)
expr_stmt|;
name|handler
operator|=
name|begin_handler
argument_list|()
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
name|declaration
operator|=
name|cp_parser_exception_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|finish_handler_parms
argument_list|(
name|declaration
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|finish_handler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an exception-declaration.     exception-declaration:      type-specifier-seq declarator      type-specifier-seq abstract-declarator      type-specifier-seq      ...       Returns a VAR_DECL for the declaration, or NULL_TREE if the    ellipsis variant is used.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_exception_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|type_specifiers
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
comment|/* If it's an ellipsis, it's easy to handle.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_ELLIPSIS
argument_list|)
condition|)
block|{
comment|/* Consume the `...' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Types may not be defined in exception-declarations.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in exception-declarations"
expr_stmt|;
comment|/* Parse the type-specifier-seq.  */
name|type_specifiers
operator|=
name|cp_parser_type_specifier_seq
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If it's a `)', then there is no declarator.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|declarator
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_EITHER
argument_list|,
comment|/*ctor_dtor_or_conv_p=*/
name|NULL
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|)
expr_stmt|;
comment|/* Restore the saved message.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
return|return
name|start_handler_parms
argument_list|(
name|type_specifiers
argument_list|,
name|declarator
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a throw-expression.      throw-expression:      throw assignment-expression [opt]     Returns a THROW_EXPR representing the throw-expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_throw_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|expression
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_THROW
argument_list|,
literal|"`throw'"
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Figure out whether or not there is an assignment-expression      following the "throw" keyword.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_SEMICOLON
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_SQUARE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_COLON
condition|)
name|expression
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|expression
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|build_throw
argument_list|(
name|expression
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* GNU Extensions */
end_comment

begin_comment
comment|/* Parse an (optional) asm-specification.     asm-specification:      asm ( string-literal )     If the asm-specification is present, returns a STRING_CST    corresponding to the string-literal.  Otherwise, returns    NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_asm_specification_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|asm_specification
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token isn't the `asm' keyword, then there's no       asm-specification.  */
if|if
condition|(
operator|!
name|cp_parser_is_keyword
argument_list|(
name|token
argument_list|,
name|RID_ASM
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Consume the `asm' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Look for the string-literal.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_STRING
argument_list|,
literal|"string-literal"
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
condition|)
name|asm_specification
operator|=
name|token
operator|->
name|value
expr_stmt|;
else|else
name|asm_specification
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Look for the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
return|return
name|asm_specification
return|;
block|}
end_function

begin_comment
comment|/* Parse an asm-operand-list.       asm-operand-list:      asm-operand      asm-operand-list , asm-operand          asm-operand:      string-literal ( expression )        [ string-literal ] string-literal ( expression )     Returns a TREE_LIST representing the operands.  The TREE_VALUE of    each node is the expression.  The TREE_PURPOSE is itself a    TREE_LIST whose TREE_PURPOSE is a STRING_CST for the bracketed    string-literal (or NULL_TREE if not present) and whose TREE_VALUE    is a STRING_CST for the string literal before the parenthesis.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_asm_operand_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|asm_operands
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|string_literal
decl_stmt|;
name|tree
name|expression
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|)
condition|)
block|{
comment|/* Consume the `[' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Read the operand name.  */
name|name
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|error_mark_node
condition|)
name|name
operator|=
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Look for the closing `]'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"`]'"
argument_list|)
expr_stmt|;
block|}
else|else
name|name
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Look for the string-literal.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_STRING
argument_list|,
literal|"string-literal"
argument_list|)
expr_stmt|;
name|string_literal
operator|=
name|token
condition|?
name|token
operator|->
name|value
else|:
name|error_mark_node
expr_stmt|;
comment|/* Look for the `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Parse the expression.  */
name|expression
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Add this operand to the list.  */
name|asm_operands
operator|=
name|tree_cons
argument_list|(
name|build_tree_list
argument_list|(
name|name
argument_list|,
name|string_literal
argument_list|)
argument_list|,
name|expression
argument_list|,
name|asm_operands
argument_list|)
expr_stmt|;
comment|/* If the next token is not a `,', there are no more  	 operands.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
comment|/* Consume the `,'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
return|return
name|nreverse
argument_list|(
name|asm_operands
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an asm-clobber-list.       asm-clobber-list:      string-literal      asm-clobber-list , string-literal       Returns a TREE_LIST, indicating the clobbers in the order that they    appeared.  The TREE_VALUE of each node is a STRING_CST.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_asm_clobber_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|clobbers
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|string_literal
decl_stmt|;
comment|/* Look for the string literal.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_STRING
argument_list|,
literal|"string-literal"
argument_list|)
expr_stmt|;
name|string_literal
operator|=
name|token
condition|?
name|token
operator|->
name|value
else|:
name|error_mark_node
expr_stmt|;
comment|/* Add it to the list.  */
name|clobbers
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|string_literal
argument_list|,
name|clobbers
argument_list|)
expr_stmt|;
comment|/* If the next token is not a `,', then the list is  	 complete.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
comment|/* Consume the `,' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
return|return
name|clobbers
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) series of attributes.     attributes:      attributes attribute     attribute:      __attribute__ (( attribute-list [opt] ))       The return value is as for cp_parser_attribute_list.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_attributes_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|attributes
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|attribute_list
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's not `__attribute__', then we're done.  */
if|if
condition|(
name|token
operator|->
name|keyword
operator|!=
name|RID_ATTRIBUTE
condition|)
break|break;
comment|/* Consume the `__attribute__' keyword.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the two `(' tokens.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_CLOSE_PAREN
condition|)
comment|/* Parse the attribute-list.  */
name|attribute_list
operator|=
name|cp_parser_attribute_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
comment|/* If the next token is a `)', then there is no attribute 	   list.  */
name|attribute_list
operator|=
name|NULL
expr_stmt|;
comment|/* Look for the two `)' tokens.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Add these new attributes to the list.  */
name|attributes
operator|=
name|chainon
argument_list|(
name|attributes
argument_list|,
name|attribute_list
argument_list|)
expr_stmt|;
block|}
return|return
name|attributes
return|;
block|}
end_function

begin_comment
comment|/* Parse an attribute-list.       attribute-list:        attribute       attribute-list , attribute     attribute:      identifier           identifier ( identifier )      identifier ( identifier , expression-list )      identifier ( expression-list )      Returns a TREE_LIST.  Each node corresponds to an attribute.  THe    TREE_PURPOSE of each node is the identifier indicating which    attribute is in use.  The TREE_VALUE represents the arguments, if    any.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_attribute_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|attribute_list
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|tree
name|attribute
decl_stmt|;
comment|/* Look for the identifier.  We also allow keywords here; for 	 example `__attribute__ ((const))' is legal.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NAME
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_KEYWORD
condition|)
return|return
name|error_mark_node
return|;
comment|/* Consume the token.  */
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Save away the identifier that indicates which attribute this is.  */
name|identifier
operator|=
name|token
operator|->
name|value
expr_stmt|;
name|attribute
operator|=
name|build_tree_list
argument_list|(
name|identifier
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's an `(', then parse the attribute arguments.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
block|{
name|tree
name|arguments
decl_stmt|;
name|arguments
operator|=
operator|(
name|cp_parser_parenthesized_expression_list
argument_list|(
name|parser
argument_list|,
name|true
argument_list|,
comment|/*non_constant_p=*/
name|NULL
argument_list|)
operator|)
expr_stmt|;
comment|/* Save the identifier and arguments away.  */
name|TREE_VALUE
argument_list|(
name|attribute
argument_list|)
operator|=
name|arguments
expr_stmt|;
block|}
comment|/* Add this attribute to the list.  */
name|TREE_CHAIN
argument_list|(
name|attribute
argument_list|)
operator|=
name|attribute_list
expr_stmt|;
name|attribute_list
operator|=
name|attribute
expr_stmt|;
comment|/* Now, look for more attributes.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token isn't a `,', we're done.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_COMMA
condition|)
break|break;
comment|/* Consume the comma and keep going.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* We built up the list in reverse order.  */
return|return
name|nreverse
argument_list|(
name|attribute_list
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an optional `__extension__' keyword.  Returns TRUE if it is    present, and FALSE otherwise.  *SAVED_PEDANTIC is set to the    current value of the PEDANTIC flag, regardless of whether or not    the `__extension__' keyword is present.  The caller is responsible    for restoring the value of the PEDANTIC flag.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_extension_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|int
modifier|*
name|saved_pedantic
parameter_list|)
block|{
comment|/* Save the old value of the PEDANTIC flag.  */
operator|*
name|saved_pedantic
operator|=
name|pedantic
expr_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_EXTENSION
argument_list|)
condition|)
block|{
comment|/* Consume the `__extension__' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* We're not being pedantic while the `__extension__' keyword is 	 in effect.  */
name|pedantic
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Parse a label declaration.     label-declaration:      __label__ label-declarator-seq ;     label-declarator-seq:      identifier , label-declarator-seq      identifier  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_label_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Look for the `__label__' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_LABEL
argument_list|,
literal|"`__label__'"
argument_list|)
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|identifier
decl_stmt|;
comment|/* Look for an identifier.  */
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Declare it as a lobel.  */
name|finish_label_decl
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
comment|/* If the next token is a `;', stop.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
break|break;
comment|/* Look for the `,' separating the label declarations.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|,
literal|"`,'"
argument_list|)
expr_stmt|;
block|}
comment|/* Look for the final `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Support Functions */
end_comment

begin_comment
comment|/* Looks up NAME in the current scope, as given by PARSER->SCOPE.    NAME should have one of the representations used for an    id-expression.  If NAME is the ERROR_MARK_NODE, the ERROR_MARK_NODE    is returned.  If PARSER->SCOPE is a dependent type, then a    SCOPE_REF is returned.     If NAME is a TEMPLATE_ID_EXPR, then it will be immediately    returned; the name was already resolved when the TEMPLATE_ID_EXPR    was formed.  Abstractly, such entities should not be passed to this    function, because they do not need to be looked up, but it is    simpler to check for this special case here, rather than at the    call-sites.     In cases not explicitly covered above, this function returns a    DECL, OVERLOAD, or baselink representing the result of the lookup.    If there was no entity with the indicated NAME, the ERROR_MARK_NODE    is returned.     If IS_TYPE is TRUE, bindings that do not refer to types are    ignored.     If IS_TEMPLATE is TRUE, bindings that do not refer to templates are    ignored.     If IS_NAMESPACE is TRUE, bindings that do not refer to namespaces    are ignored.     If CHECK_DEPENDENCY is TRUE, names are not looked up in dependent    types.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_lookup_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|name
parameter_list|,
name|bool
name|is_type
parameter_list|,
name|bool
name|is_template
parameter_list|,
name|bool
name|is_namespace
parameter_list|,
name|bool
name|check_dependency
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|object_type
init|=
name|parser
operator|->
name|context
operator|->
name|object_type
decl_stmt|;
comment|/* Now that we have looked up the name, the OBJECT_TYPE (if any) is      no longer valid.  Note that if we are parsing tentatively, and      the parse fails, OBJECT_TYPE will be automatically restored.  */
name|parser
operator|->
name|context
operator|->
name|object_type
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* A template-id has already been resolved; there is no lookup to      do.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
return|return
name|name
return|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|BASELINK_FUNCTIONS
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|)
argument_list|,
literal|20020909
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
comment|/* A BIT_NOT_EXPR is used to represent a destructor.  By this point,      it should already have been checked to make sure that the name      used matches the type being destroyed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|tree
name|type
decl_stmt|;
comment|/* Figure out to which type this destructor applies.  */
if|if
condition|(
name|parser
operator|->
name|scope
condition|)
name|type
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
elseif|else
if|if
condition|(
name|object_type
condition|)
name|type
operator|=
name|object_type
expr_stmt|;
else|else
name|type
operator|=
name|current_class_type
expr_stmt|;
comment|/* If that's not a class type, there is no destructor.  */
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|CLASSTYPE_DESTRUCTORS
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* If it was a class type, return the destructor.  */
return|return
name|CLASSTYPE_DESTRUCTORS
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/* By this point, the NAME should be an ordinary identifier.  If      the id-expression was a qualified name, the qualifying scope is      stored in PARSER->SCOPE at this point.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|20000619
argument_list|)
expr_stmt|;
comment|/* Perform the lookup.  */
if|if
condition|(
name|parser
operator|->
name|scope
condition|)
block|{
name|bool
name|dependent_p
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|scope
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* If the SCOPE is dependent, the lookup must be deferred until 	 the template is instantiated -- unless we are explicitly 	 looking up names in uninstantiated templates.  Even then, we 	 cannot look up the name if the scope is not a class type; it 	 might, for example, be a template type parameter.  */
name|dependent_p
operator|=
operator|(
name|TYPE_P
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|&&
operator|!
operator|(
name|parser
operator|->
name|in_declarator_p
operator|&&
name|currently_open_class
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|)
operator|&&
name|dependent_type_p
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|check_dependency
operator|||
operator|!
name|CLASS_TYPE_P
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|)
operator|&&
name|dependent_p
condition|)
block|{
if|if
condition|(
name|is_type
condition|)
comment|/* The resolution to Core Issue 180 says that `struct A::B' 	       should be considered a type-name, even if `A' is 	       dependent.  */
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|make_typename_type
argument_list|(
name|parser
operator|->
name|scope
argument_list|,
name|name
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_template
condition|)
name|decl
operator|=
name|make_unbound_class_template
argument_list|(
name|parser
operator|->
name|scope
argument_list|,
name|name
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|pop_p
init|=
name|false
decl_stmt|;
comment|/* If PARSER->SCOPE is a dependent type, then it must be a 	     class type, and we must not be checking dependencies; 	     otherwise, we would have processed this lookup above.  So 	     that PARSER->SCOPE is not considered a dependent base by 	     lookup_member, we must enter the scope here.  */
if|if
condition|(
name|dependent_p
condition|)
name|pop_p
operator|=
name|push_scope
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
expr_stmt|;
comment|/* If the PARSER->SCOPE is a a template specialization, it 	     may be instantiated during name lookup.  In that case, 	     errors may be issued.  Even if we rollback the current 	     tentative parse, those errors are valid.  */
name|decl
operator|=
name|lookup_qualified_name
argument_list|(
name|parser
operator|->
name|scope
argument_list|,
name|name
argument_list|,
name|is_type
argument_list|,
comment|/*complain=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|pop_p
condition|)
name|pop_scope
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
expr_stmt|;
block|}
name|parser
operator|->
name|qualifying_scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|object_type
condition|)
block|{
name|tree
name|object_decl
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Look up the name in the scope of the OBJECT_TYPE, unless the 	 OBJECT_TYPE is not a class.  */
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|object_type
argument_list|)
condition|)
comment|/* If the OBJECT_TYPE is a template specialization, it may 	   be instantiated during name lookup.  In that case, errors 	   may be issued.  Even if we rollback the current tentative 	   parse, those errors are valid.  */
name|object_decl
operator|=
name|lookup_member
argument_list|(
name|object_type
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|0
argument_list|,
name|is_type
argument_list|)
expr_stmt|;
comment|/* Look it up in the enclosing context, too.  */
name|decl
operator|=
name|lookup_name_real
argument_list|(
name|name
argument_list|,
name|is_type
argument_list|,
comment|/*nonclass=*/
literal|0
argument_list|,
name|is_namespace
argument_list|,
comment|/*flags=*/
literal|0
argument_list|)
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|object_type
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|object_decl
condition|)
name|decl
operator|=
name|object_decl
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|lookup_name_real
argument_list|(
name|name
argument_list|,
name|is_type
argument_list|,
comment|/*nonclass=*/
literal|0
argument_list|,
name|is_namespace
argument_list|,
comment|/*flags=*/
literal|0
argument_list|)
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* If the lookup failed, let our caller know.  */
if|if
condition|(
operator|!
name|decl
operator|||
name|decl
operator|==
name|error_mark_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ANTICIPATED
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* If it's a TREE_LIST, the result of the lookup was ambiguous.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* The error message we have to print is too complicated for 	 cp_parser_error, so we incorporate its actions directly.  */
if|if
condition|(
operator|!
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"reference to `%D' is ambiguous"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
name|my_friendly_assert
argument_list|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SCOPE_REF
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|UNBOUND_CLASS_TEMPLATE
operator|||
name|BASELINK_P
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|20000619
argument_list|)
expr_stmt|;
comment|/* If we have resolved the name of a member declaration, check to      see if the declaration is accessible.  When the name resolves to      set of overloaded functions, accessibility is checked when      overload resolution is done.         During an explicit instantiation, access is not checked at all,      as per [temp.explicit].  */
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|check_accessibility_of_qualified_id
argument_list|(
name|decl
argument_list|,
name|object_type
argument_list|,
name|parser
operator|->
name|scope
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Like cp_parser_lookup_name, but for use in the typical case where    CHECK_ACCESS is TRUE, IS_TYPE is FALSE, IS_TEMPLATE is FALSE,    IS_NAMESPACE is FALSE, and CHECK_DEPENDENCY is TRUE.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_lookup_name_simple
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
return|return
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|name
argument_list|,
comment|/*is_type=*/
name|false
argument_list|,
comment|/*is_template=*/
name|false
argument_list|,
comment|/*is_namespace=*/
name|false
argument_list|,
comment|/*check_dependency=*/
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If DECL is a TEMPLATE_DECL that can be treated like a TYPE_DECL in    the current context, return the TYPE_DECL.  If TAG_NAME_P is    true, the DECL indicates the class being defined in a class-head,    or declared in an elaborated-type-specifier.     Otherwise, return DECL.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_maybe_treat_template_as_class
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
name|tag_name_p
parameter_list|)
block|{
comment|/* If the TEMPLATE_DECL is being declared as part of a class-head,      the translation from TEMPLATE_DECL to TYPE_DECL occurs:         struct A {           template<typename T> struct B;        };         template<typename T> struct A::B {};           Similarly, in a elaborated-type-specifier:         namespace N { struct X{}; }         struct A {          template<typename T> friend struct N::X;        };       However, if the DECL refers to a class type, and we are in      the scope of the class, then the name lookup automatically      finds the TYPE_DECL created by build_self_reference rather      than a TEMPLATE_DECL.  For example, in:         template<class T> struct S {          S s;        };       there is no need to handle such case.  */
if|if
condition|(
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|tag_name_p
condition|)
return|return
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
return|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* If too many, or too few, template-parameter lists apply to the    declarator, issue an error message.  Returns TRUE if all went well,    and FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_check_declarator_template_parameters
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|declarator
parameter_list|)
block|{
name|unsigned
name|num_templates
decl_stmt|;
comment|/* We haven't seen any classes that involve template parameters yet.  */
name|num_templates
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
case|case
name|CALL_EXPR
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|ADDR_EXPR
case|:
block|{
name|tree
name|main_declarator
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|cp_parser_check_declarator_template_parameters
argument_list|(
name|parser
argument_list|,
name|main_declarator
argument_list|)
return|;
block|}
case|case
name|SCOPE_REF
case|:
block|{
name|tree
name|scope
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|scope
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|member
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If this is a pointer-to-member, then we are not interested 	   in the SCOPE, because it does not qualify the thing that is 	   being declared.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
return|return
operator|(
name|cp_parser_check_declarator_template_parameters
argument_list|(
name|parser
argument_list|,
name|member
argument_list|)
operator|)
return|;
while|while
condition|(
name|scope
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
comment|/* You're supposed to have one `template<...>' 	       for every template class, but you don't need one 	       for a full specialization.  For example: 	        	       template<class T> struct S{}; 	       template<> struct S<int> { void f(); }; 	       void S<int>::f () {} 	        	       is correct; there shouldn't be a `template<>' for 	       the definition of `S<int>::f'.  */
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|scope
argument_list|)
operator|&&
operator|(
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|scope
argument_list|)
operator|||
name|uses_template_parms
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|scope
argument_list|)
argument_list|)
operator|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|scope
argument_list|)
argument_list|)
condition|)
operator|++
name|num_templates
expr_stmt|;
name|scope
operator|=
name|TYPE_CONTEXT
argument_list|(
name|scope
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fall through.  */
default|default:
comment|/* If the DECLARATOR has the form `X<y>' then it uses one 	 additional level of template parameters.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
operator|++
name|num_templates
expr_stmt|;
return|return
name|cp_parser_check_template_parameters
argument_list|(
name|parser
argument_list|,
name|num_templates
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* NUM_TEMPLATES were used in the current declaration.  If that is    invalid, return FALSE and issue an error messages.  Otherwise,    return TRUE.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_check_template_parameters
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|unsigned
name|num_templates
parameter_list|)
block|{
comment|/* If there are more template classes than parameter lists, we have      something like:              template<class T> void S<T>::R<T>::f ();  */
if|if
condition|(
name|parser
operator|->
name|num_template_parameter_lists
operator|<
name|num_templates
condition|)
block|{
name|error
argument_list|(
literal|"too few template-parameter-lists"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If there are the same number of template classes and parameter      lists, that's OK.  */
if|if
condition|(
name|parser
operator|->
name|num_template_parameter_lists
operator|==
name|num_templates
condition|)
return|return
name|true
return|;
comment|/* If there are more, but only one more, then we are referring to a      member template.  That's OK too.  */
if|if
condition|(
name|parser
operator|->
name|num_template_parameter_lists
operator|==
name|num_templates
operator|+
literal|1
condition|)
return|return
name|true
return|;
comment|/* Otherwise, there are too many template parameter lists.  We have      something like:       template<class T> template<class U> void S::f();  */
name|error
argument_list|(
literal|"too many template-parameter-lists"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Parse a binary-expression of the general form:     binary-expression:<expr>      binary-expression<token><expr>     The TOKEN_TREE_MAP maps<token> types to<expr> codes.  FN is used    to parser the<expr>s.  If the first production is used, then the    value returned by FN is returned directly.  Otherwise, a node with    the indicated EXPR_TYPE is returned, with operands corresponding to    the two sub-expressions.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_binary_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|cp_parser_token_tree_map
name|token_tree_map
parameter_list|,
name|cp_parser_expression_fn
name|fn
parameter_list|)
block|{
name|tree
name|lhs
decl_stmt|;
comment|/* Parse the first expression.  */
name|lhs
operator|=
call|(
modifier|*
name|fn
call|)
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Now, look for more expressions.  */
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
specifier|const
name|cp_parser_token_tree_map_node
modifier|*
name|map_node
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the token is `>', and that's not an operator at the 	 moment, then we're done.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_GREATER
operator|&&
operator|!
name|parser
operator|->
name|greater_than_is_operator_p
condition|)
break|break;
comment|/* If we find one of the tokens we want, build the corresponding 	 tree representation.  */
for|for
control|(
name|map_node
operator|=
name|token_tree_map
init|;
name|map_node
operator|->
name|token_type
operator|!=
name|CPP_EOF
condition|;
operator|++
name|map_node
control|)
if|if
condition|(
name|map_node
operator|->
name|token_type
operator|==
name|token
operator|->
name|type
condition|)
block|{
comment|/* Assume that an overloaded operator will not be used.  */
name|bool
name|overloaded_p
init|=
name|false
decl_stmt|;
comment|/* Consume the operator token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the right-hand side of the expression.  */
name|rhs
operator|=
call|(
modifier|*
name|fn
call|)
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Build the binary tree node.  */
name|lhs
operator|=
name|build_x_binary_op
argument_list|(
name|map_node
operator|->
name|tree_type
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
operator|&
name|overloaded_p
argument_list|)
expr_stmt|;
comment|/* If the binary operator required the use of an 	       overloaded operator, then this expression cannot be an 	       integral constant-expression.  An overloaded operator 	       can be used even if both operands are otherwise 	       permissible in an integral constant-expression if at 	       least one of the operands is of enumeration type.  */
if|if
condition|(
name|overloaded_p
operator|&&
operator|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"calls to overloaded operators"
argument_list|)
operator|)
condition|)
name|lhs
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
comment|/* If the token wasn't one of the ones we want, we're done.  */
if|if
condition|(
name|map_node
operator|->
name|token_type
operator|==
name|CPP_EOF
condition|)
break|break;
block|}
return|return
name|lhs
return|;
block|}
end_function

begin_comment
comment|/* Parse an optional `::' token indicating that the following name is    from the global namespace.  If so, PARSER->SCOPE is set to the    GLOBAL_NAMESPACE. Otherwise, PARSER->SCOPE is set to NULL_TREE,    unless CURRENT_SCOPE_VALID_P is TRUE, in which case it is left alone.    Returns the new value of PARSER->SCOPE, if the `::' token is    present, and NULL_TREE otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_global_scope_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|current_scope_valid_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If we're looking at a `::' token then we're starting from the      global namespace, not our current location.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_SCOPE
condition|)
block|{
comment|/* Consume the `::' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Set the SCOPE so that we know where to start the lookup.  */
name|parser
operator|->
name|scope
operator|=
name|global_namespace
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|global_namespace
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|parser
operator|->
name|scope
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|current_scope_valid_p
condition|)
block|{
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if the upcoming token sequence is the start of a    constructor declarator.  If FRIEND_P is true, the declarator is    preceded by the `friend' specifier.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_constructor_declarator_p
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|friend_p
parameter_list|)
block|{
name|bool
name|constructor_p
decl_stmt|;
name|tree
name|type_decl
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|nested_name_p
decl_stmt|;
name|cp_token
modifier|*
name|next_token
decl_stmt|;
comment|/* The common case is that this is not a constructor declarator, so      try to avoid doing lots of work if at all possible.  It's not      valid declare a constructor at function scope.  */
if|if
condition|(
name|at_function_scope_p
argument_list|()
condition|)
return|return
name|false
return|;
comment|/* And only certain tokens can begin a constructor declarator.  */
name|next_token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_token
operator|->
name|type
operator|!=
name|CPP_NAME
operator|&&
name|next_token
operator|->
name|type
operator|!=
name|CPP_SCOPE
operator|&&
name|next_token
operator|->
name|type
operator|!=
name|CPP_NESTED_NAME_SPECIFIER
operator|&&
name|next_token
operator|->
name|type
operator|!=
name|CPP_TEMPLATE_ID
condition|)
return|return
name|false
return|;
comment|/* Parse tentatively; we are going to roll back all of the tokens      consumed here.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Assume that we are looking at a constructor declarator.  */
name|constructor_p
operator|=
name|true
expr_stmt|;
comment|/* Look for the optional `::' operator.  */
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the nested-name-specifier.  */
name|nested_name_p
operator|=
operator|(
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|false
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Outside of a class-specifier, there must be a      nested-name-specifier.  */
if|if
condition|(
operator|!
name|nested_name_p
operator|&&
operator|(
operator|!
name|at_class_scope_p
argument_list|()
operator|||
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
operator|||
name|friend_p
operator|)
condition|)
name|constructor_p
operator|=
name|false
expr_stmt|;
comment|/* If we still think that this might be a constructor-declarator,      look for a class-name.  */
if|if
condition|(
name|constructor_p
condition|)
block|{
comment|/* If we have:  	   template<typename T> struct S { S(); }; 	   template<typename T> S<T>::S ();  	 we must recognize that the nested `S' names a class. 	 Similarly, for:  	   template<typename T> S<T>::S<T> ();  	 we must recognize that the nested `S' names a template.  */
name|type_decl
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|false
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If there was no class-name, then this is not a constructor.  */
name|constructor_p
operator|=
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* If we're still considering a constructor, we have to see a `(',      to begin the parameter-declaration-clause, followed by either a      `)', an `...', or a decl-specifier.  We need to check for a      type-specifier to avoid being fooled into thinking that:         S::S (f) (int);       is a constructor.  (It is actually a function named `f' that      takes one parameter (of type `int') and returns a value of type      `S::S'.  */
if|if
condition|(
name|constructor_p
operator|&&
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_ELLIPSIS
argument_list|)
comment|/* A parameter declaration begins with a decl-specifier, 	     which is either the "attribute" keyword, a storage class 	     specifier, or (usually) a type-specifier.  */
operator|&&
operator|!
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_ATTRIBUTE
argument_list|)
operator|&&
operator|!
name|cp_parser_storage_class_specifier_opt
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|bool
name|pop_p
init|=
name|false
decl_stmt|;
name|unsigned
name|saved_num_template_parameter_lists
decl_stmt|;
comment|/* Names appearing in the type-specifier should be looked up 	     in the scope of the class.  */
if|if
condition|(
name|current_class_type
condition|)
name|type
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
name|type
operator|=
name|resolve_typename_type
argument_list|(
name|type
argument_list|,
comment|/*only_current_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|cp_parser_abort_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|pop_p
operator|=
name|push_scope
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Inside the constructor parameter list, surrounding 	     template-parameter-lists do not apply.  */
name|saved_num_template_parameter_lists
operator|=
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
name|parser
operator|->
name|num_template_parameter_lists
operator|=
literal|0
expr_stmt|;
comment|/* Look for the type-specifier.  */
name|cp_parser_type_specifier
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_FLAGS_NONE
argument_list|,
comment|/*is_friend=*/
name|false
argument_list|,
comment|/*is_declarator=*/
name|true
argument_list|,
comment|/*declares_class_or_enum=*/
name|NULL
argument_list|,
comment|/*is_cv_qualifier=*/
name|NULL
argument_list|)
expr_stmt|;
name|parser
operator|->
name|num_template_parameter_lists
operator|=
name|saved_num_template_parameter_lists
expr_stmt|;
comment|/* Leave the scope of the class.  */
if|if
condition|(
name|pop_p
condition|)
name|pop_scope
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|constructor_p
operator|=
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|constructor_p
operator|=
name|false
expr_stmt|;
comment|/* We did not really want to consume any tokens.  */
name|cp_parser_abort_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|constructor_p
return|;
block|}
end_function

begin_comment
comment|/* Parse the definition of the function given by the DECL_SPECIFIERS,    ATTRIBUTES, and DECLARATOR.  The access checks have been deferred;    they must be performed once we are in the scope of the function.     Returns the function defined.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_function_definition_from_specifiers_and_declarator
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|decl_specifiers
parameter_list|,
name|tree
name|attributes
parameter_list|,
name|tree
name|declarator
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|;
name|bool
name|success_p
decl_stmt|;
comment|/* Begin the function-definition.  */
name|success_p
operator|=
name|begin_function_definition
argument_list|(
name|decl_specifiers
argument_list|,
name|attributes
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
comment|/* If there were names looked up in the decl-specifier-seq that we      did not check, check them now.  We must wait until we are in the      scope of the function to perform the checks, since the function      might be a friend.  */
name|perform_deferred_access_checks
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|success_p
condition|)
block|{
comment|/* If begin_function_definition didn't like the definition, skip 	 the entire function.  */
name|error
argument_list|(
literal|"invalid function declaration"
argument_list|)
expr_stmt|;
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|fn
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|fn
operator|=
name|cp_parser_function_definition_after_declarator
argument_list|(
name|parser
argument_list|,
comment|/*inline_p=*/
name|false
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Parse the part of a function-definition that follows the    declarator.  INLINE_P is TRUE iff this function is an inline    function defined with a class-specifier.     Returns the function defined.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_function_definition_after_declarator
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|inline_p
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|;
name|bool
name|ctor_initializer_p
init|=
name|false
decl_stmt|;
name|bool
name|saved_in_unbraced_linkage_specification_p
decl_stmt|;
name|unsigned
name|saved_num_template_parameter_lists
decl_stmt|;
comment|/* If the next token is `return', then the code may be trying to      make use of the "named return value" extension that G++ used to      support.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_RETURN
argument_list|)
condition|)
block|{
comment|/* Consume the `return' keyword.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the identifier that indicates what value is to be 	 returned.  */
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Issue an error message.  */
name|error
argument_list|(
literal|"named return values are no longer supported"
argument_list|)
expr_stmt|;
comment|/* Skip tokens until we reach the start of the function body.  */
while|while
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EOF
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* The `extern' in `extern "C" void f () { ... }' does not apply to      anything declared inside `f'.  */
name|saved_in_unbraced_linkage_specification_p
operator|=
name|parser
operator|->
name|in_unbraced_linkage_specification_p
expr_stmt|;
name|parser
operator|->
name|in_unbraced_linkage_specification_p
operator|=
name|false
expr_stmt|;
comment|/* Inside the function, surrounding template-parameter-lists do not      apply.  */
name|saved_num_template_parameter_lists
operator|=
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
name|parser
operator|->
name|num_template_parameter_lists
operator|=
literal|0
expr_stmt|;
comment|/* If the next token is `try', then we are looking at a      function-try-block.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TRY
argument_list|)
condition|)
name|ctor_initializer_p
operator|=
name|cp_parser_function_try_block
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* A function-try-block includes the function-body, so we only do      this next part if we're not processing a function-try-block.  */
else|else
name|ctor_initializer_p
operator|=
name|cp_parser_ctor_initializer_opt_and_function_body
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Finish the function.  */
name|fn
operator|=
name|finish_function
argument_list|(
operator|(
name|ctor_initializer_p
condition|?
literal|1
else|:
literal|0
operator|)
operator||
operator|(
name|inline_p
condition|?
literal|2
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Generate code for it, if necessary.  */
name|expand_or_defer_fn
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Restore the saved values.  */
name|parser
operator|->
name|in_unbraced_linkage_specification_p
operator|=
name|saved_in_unbraced_linkage_specification_p
expr_stmt|;
name|parser
operator|->
name|num_template_parameter_lists
operator|=
name|saved_num_template_parameter_lists
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-declaration, assuming that the `export' (and    `extern') keywords, if present, has already been scanned.  MEMBER_P    is as for cp_parser_template_declaration.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_template_declaration_after_export
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|member_p
parameter_list|)
block|{
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|parameter_list
decl_stmt|;
name|bool
name|friend_p
init|=
name|false
decl_stmt|;
comment|/* Look for the `template' keyword.  */
if|if
condition|(
operator|!
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_TEMPLATE
argument_list|,
literal|"`template'"
argument_list|)
condition|)
return|return;
comment|/* And the `<'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|,
literal|"`<'"
argument_list|)
condition|)
return|return;
comment|/* If the next token is `>', then we have an invalid      specialization.  Rather than complain about an invalid template      parameter, issue an error message here.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_GREATER
argument_list|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"invalid explicit specialization"
argument_list|)
expr_stmt|;
name|begin_specialization
argument_list|()
expr_stmt|;
name|parameter_list
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
comment|/* Parse the template parameters.  */
name|begin_template_parm_list
argument_list|()
expr_stmt|;
name|parameter_list
operator|=
name|cp_parser_template_parameter_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parameter_list
operator|=
name|end_template_parm_list
argument_list|(
name|parameter_list
argument_list|)
expr_stmt|;
block|}
comment|/* Look for the `>'.  */
name|cp_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_GREATER
argument_list|,
literal|"`>'"
argument_list|)
expr_stmt|;
comment|/* We just processed one more parameter list.  */
operator|++
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
comment|/* If the next token is `template', there are more template      parameters.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TEMPLATE
argument_list|)
condition|)
name|cp_parser_template_declaration_after_export
argument_list|(
name|parser
argument_list|,
name|member_p
argument_list|)
expr_stmt|;
else|else
block|{
name|decl
operator|=
name|cp_parser_single_declaration
argument_list|(
name|parser
argument_list|,
name|member_p
argument_list|,
operator|&
name|friend_p
argument_list|)
expr_stmt|;
comment|/* If this is a member template declaration, let the front 	 end know.  */
if|if
condition|(
name|member_p
operator|&&
operator|!
name|friend_p
operator|&&
name|decl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|cp_parser_check_access_in_redeclaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|finish_member_template_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|friend_p
operator|&&
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|make_friend_class
argument_list|(
name|current_class_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
comment|/*complain=*/
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* We are done with the current parameter list.  */
operator|--
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
comment|/* Finish up.  */
name|finish_template_decl
argument_list|(
name|parameter_list
argument_list|)
expr_stmt|;
comment|/* Register member declarations.  */
if|if
condition|(
name|member_p
operator|&&
operator|!
name|friend_p
operator|&&
name|decl
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|finish_member_declaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If DECL is a function template, we must return to parse it later.      (Even though there is no definition, there might be default      arguments that need handling.)  */
if|if
condition|(
name|member_p
operator|&&
name|decl
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a `decl-specifier-seq [opt] init-declarator [opt] ;' or    `function-definition' sequence.  MEMBER_P is true, this declaration    appears in a class scope.     Returns the DECL for the declared entity.  If FRIEND_P is non-NULL,    *FRIEND_P is set to TRUE iff the declaration is a friend.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_single_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|member_p
parameter_list|,
name|bool
modifier|*
name|friend_p
parameter_list|)
block|{
name|int
name|declares_class_or_enum
decl_stmt|;
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decl_specifiers
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|bool
name|function_definition_p
init|=
name|false
decl_stmt|;
comment|/* Defer access checks until we know what is being declared.  */
name|push_deferring_access_checks
argument_list|(
name|dk_deferred
argument_list|)
expr_stmt|;
comment|/* Try the `decl-specifier-seq [opt] init-declarator [opt]'      alternative.  */
name|decl_specifiers
operator|=
name|cp_parser_decl_specifier_seq
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_FLAGS_OPTIONAL
argument_list|,
operator|&
name|attributes
argument_list|,
operator|&
name|declares_class_or_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|friend_p
condition|)
operator|*
name|friend_p
operator|=
name|cp_parser_friend_p
argument_list|(
name|decl_specifiers
argument_list|)
expr_stmt|;
comment|/* Gather up the access checks that occurred the      decl-specifier-seq.  */
name|stop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Check for the declaration of a template class.  */
if|if
condition|(
name|declares_class_or_enum
condition|)
block|{
if|if
condition|(
name|cp_parser_declares_only_class_p
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|decl
operator|=
name|shadow_tag
argument_list|(
name|decl_specifiers
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
else|else
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If it's not a template class, try for a template function.  If      the next token is a `;', then this declaration does not declare      anything.  But, if there were errors in the decl-specifiers, then      the error might well have come from an attempted class-specifier.      In that case, there's no need to warn about a missing declarator.  */
if|if
condition|(
operator|!
name|decl
operator|&&
operator|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
operator|||
operator|!
name|value_member
argument_list|(
name|error_mark_node
argument_list|,
name|decl_specifiers
argument_list|)
operator|)
condition|)
name|decl
operator|=
name|cp_parser_init_declarator
argument_list|(
name|parser
argument_list|,
name|decl_specifiers
argument_list|,
name|attributes
argument_list|,
comment|/*function_definition_allowed_p=*/
name|true
argument_list|,
name|member_p
argument_list|,
name|declares_class_or_enum
argument_list|,
operator|&
name|function_definition_p
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Clear any current qualification; whatever comes next is the start      of something new.  */
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Look for a trailing `;' after the declaration.  */
if|if
condition|(
operator|!
name|function_definition_p
operator|&&
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
condition|)
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Parse a cast-expression that is not the operand of a unary "&".  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_simple_cast_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
return|return
name|cp_parser_cast_expression
argument_list|(
name|parser
argument_list|,
comment|/*address_p=*/
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a functional cast to TYPE.  Returns an expression    representing the cast.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_functional_cast
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|expression_list
decl_stmt|;
name|tree
name|cast
decl_stmt|;
name|expression_list
operator|=
name|cp_parser_parenthesized_expression_list
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
comment|/*non_constant_p=*/
name|NULL
argument_list|)
expr_stmt|;
name|cast
operator|=
name|build_functional_cast
argument_list|(
name|type
argument_list|,
name|expression_list
argument_list|)
expr_stmt|;
comment|/* [expr.const]/1: In an integral constant expression "only type      conversions to integral or enumeration type can be used".  */
if|if
condition|(
name|cast
operator|!=
name|error_mark_node
operator|&&
operator|!
name|type_dependent_expression_p
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|INTEGRAL_OR_ENUMERATION_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"a call to a constructor"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
return|return
name|cast
return|;
block|}
end_function

begin_comment
comment|/* Save the tokens that make up the body of a member function defined    in a class-specifier.  The DECL_SPECIFIERS and DECLARATOR have    already been parsed.  The ATTRIBUTES are any GNU "__attribute__"    specifiers applied to the declaration.  Returns the FUNCTION_DECL    for the member function.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_save_member_function_body
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|decl_specifiers
parameter_list|,
name|tree
name|declarator
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
name|cp_token_cache
modifier|*
name|cache
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* Create the function-declaration.  */
name|fn
operator|=
name|start_method
argument_list|(
name|decl_specifiers
argument_list|,
name|declarator
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
comment|/* If something went badly wrong, bail out now.  */
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
block|{
comment|/* If there's a function-body, skip it.  */
if|if
condition|(
name|cp_parser_token_starts_function_definition_p
argument_list|(
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
argument_list|)
condition|)
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Remember it, if there default args to post process.  */
name|cp_parser_save_default_args
argument_list|(
name|parser
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* Create a token cache.  */
name|cache
operator|=
name|cp_token_cache_new
argument_list|()
expr_stmt|;
comment|/* Save away the tokens that make up the body of the       function.  */
name|cp_parser_cache_group
argument_list|(
name|parser
argument_list|,
name|cache
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
comment|/*depth=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle function try blocks.  */
while|while
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_CATCH
argument_list|)
condition|)
name|cp_parser_cache_group
argument_list|(
name|parser
argument_list|,
name|cache
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
comment|/*depth=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* Save away the inline definition; we will process it when the      class is complete.  */
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|fn
argument_list|)
operator|=
name|cache
expr_stmt|;
name|DECL_PENDING_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We need to know that this was defined in the class, so that      friend templates are handled correctly.  */
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We're done with the inline definition.  */
name|finish_method
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Add FN to the queue of functions to be parsed later.  */
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-argument-list, as well as the trailing ">" (but    not the opening ">").  See cp_parser_template_argument_list for the    return value.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_enclosed_template_argument_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|arguments
decl_stmt|;
name|tree
name|saved_scope
decl_stmt|;
name|tree
name|saved_qualifying_scope
decl_stmt|;
name|tree
name|saved_object_scope
decl_stmt|;
name|bool
name|saved_greater_than_is_operator_p
decl_stmt|;
comment|/* [temp.names]       When parsing a template-id, the first non-nested `>' is taken as      the end of the template-argument-list rather than a greater-than      operator.  */
name|saved_greater_than_is_operator_p
operator|=
name|parser
operator|->
name|greater_than_is_operator_p
expr_stmt|;
name|parser
operator|->
name|greater_than_is_operator_p
operator|=
name|false
expr_stmt|;
comment|/* Parsing the argument list may modify SCOPE, so we save it      here.  */
name|saved_scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|saved_qualifying_scope
operator|=
name|parser
operator|->
name|qualifying_scope
expr_stmt|;
name|saved_object_scope
operator|=
name|parser
operator|->
name|object_scope
expr_stmt|;
comment|/* Parse the template-argument-list itself.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_GREATER
argument_list|)
condition|)
name|arguments
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|arguments
operator|=
name|cp_parser_template_argument_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the `>' that ends the template-argument-list. If we find      a '>>' instead, it's probably just a typo.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_RSHIFT
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|saved_greater_than_is_operator_p
condition|)
block|{
comment|/* If we're in a nested template argument list, the '>>' has to be 	    a typo for '>>'. We emit the error message, but we continue 	    parsing and we push a '>' as next token, so that the argument 	    list will be parsed correctly..  */
name|cp_token
modifier|*
name|token
decl_stmt|;
name|error
argument_list|(
literal|"`>>' should be `>>' within a nested template argument list"
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|token
operator|->
name|type
operator|=
name|CPP_GREATER
expr_stmt|;
block|}
else|else
block|{
comment|/* If this is not a nested template argument list, the '>>' is 	    a typo for '>'. Emit an error message and continue.  */
name|error
argument_list|(
literal|"spurious `>>', use `>' to terminate a template argument list"
argument_list|)
expr_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_GREATER
argument_list|,
literal|"`>'"
argument_list|)
condition|)
name|error
argument_list|(
literal|"missing `>' to terminate the template argument list"
argument_list|)
expr_stmt|;
comment|/* The `>' token might be a greater-than operator again now.  */
name|parser
operator|->
name|greater_than_is_operator_p
operator|=
name|saved_greater_than_is_operator_p
expr_stmt|;
comment|/* Restore the SAVED_SCOPE.  */
name|parser
operator|->
name|scope
operator|=
name|saved_scope
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|saved_qualifying_scope
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|saved_object_scope
expr_stmt|;
return|return
name|arguments
return|;
block|}
end_function

begin_comment
comment|/* MEMBER_FUNCTION is a member function, or a friend.  If default    arguments, or the body of the function have not yet been parsed,    parse them now.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_late_parsing_for_member
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|member_function
parameter_list|)
block|{
name|cp_lexer
modifier|*
name|saved_lexer
decl_stmt|;
comment|/* If this member is a template, get the underlying      FUNCTION_DECL.  */
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|member_function
argument_list|)
condition|)
name|member_function
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|member_function
argument_list|)
expr_stmt|;
comment|/* There should not be any class definitions in progress at this      point; the bodies of members are only parsed outside of all class      definitions.  */
name|my_friendly_assert
argument_list|(
name|parser
operator|->
name|num_classes_being_defined
operator|==
literal|0
argument_list|,
literal|20010816
argument_list|)
expr_stmt|;
comment|/* While we're parsing the member functions we might encounter more      classes.  We want to handle them right away, but we don't want      them getting mixed up with functions that are currently in the      queue.  */
name|parser
operator|->
name|unparsed_functions_queues
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
expr_stmt|;
comment|/* Make sure that any template parameters are in scope.  */
name|maybe_begin_member_template_processing
argument_list|(
name|member_function
argument_list|)
expr_stmt|;
comment|/* If the body of the function has not yet been parsed, parse it      now.  */
if|if
condition|(
name|DECL_PENDING_INLINE_P
argument_list|(
name|member_function
argument_list|)
condition|)
block|{
name|tree
name|function_scope
decl_stmt|;
name|cp_token_cache
modifier|*
name|tokens
decl_stmt|;
comment|/* The function is no longer pending; we are processing it.  */
name|tokens
operator|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|member_function
argument_list|)
expr_stmt|;
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|member_function
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_PENDING_INLINE_P
argument_list|(
name|member_function
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If this was an inline function in a local class, enter the scope 	 of the containing function.  */
name|function_scope
operator|=
name|decl_function_context
argument_list|(
name|member_function
argument_list|)
expr_stmt|;
if|if
condition|(
name|function_scope
condition|)
name|push_function_context_to
argument_list|(
name|function_scope
argument_list|)
expr_stmt|;
comment|/* Save away the current lexer.  */
name|saved_lexer
operator|=
name|parser
operator|->
name|lexer
expr_stmt|;
comment|/* Make a new lexer to feed us the tokens saved for this function.  */
name|parser
operator|->
name|lexer
operator|=
name|cp_lexer_new_from_tokens
argument_list|(
name|tokens
argument_list|)
expr_stmt|;
name|parser
operator|->
name|lexer
operator|->
name|next
operator|=
name|saved_lexer
expr_stmt|;
comment|/* Set the current source position to be the location of the first 	 token in the saved inline body.  */
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Let the front end know that we going to be defining this 	 function.  */
name|start_function
argument_list|(
name|NULL_TREE
argument_list|,
name|member_function
argument_list|,
name|NULL_TREE
argument_list|,
name|SF_PRE_PARSED
operator||
name|SF_INCLASS_INLINE
argument_list|)
expr_stmt|;
comment|/* Now, parse the body of the function.  */
name|cp_parser_function_definition_after_declarator
argument_list|(
name|parser
argument_list|,
comment|/*inline_p=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Leave the scope of the containing function.  */
if|if
condition|(
name|function_scope
condition|)
name|pop_function_context_from
argument_list|(
name|function_scope
argument_list|)
expr_stmt|;
comment|/* Restore the lexer.  */
name|parser
operator|->
name|lexer
operator|=
name|saved_lexer
expr_stmt|;
block|}
comment|/* Remove any template parameters from the symbol table.  */
name|maybe_end_member_template_processing
argument_list|()
expr_stmt|;
comment|/* Restore the queue.  */
name|parser
operator|->
name|unparsed_functions_queues
operator|=
name|TREE_CHAIN
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If DECL contains any default args, remember it on the unparsed    functions queue.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_save_default_args
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|probe
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
init|;
name|probe
condition|;
name|probe
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|probe
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* FN is a FUNCTION_DECL which may contains a parameter with an    unparsed DEFAULT_ARG.  Parse the default args now.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_late_parsing_default_args
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|fn
parameter_list|)
block|{
name|cp_lexer
modifier|*
name|saved_lexer
decl_stmt|;
name|cp_token_cache
modifier|*
name|tokens
decl_stmt|;
name|bool
name|saved_local_variables_forbidden_p
decl_stmt|;
name|tree
name|parameters
decl_stmt|;
comment|/* While we're parsing the default args, we might (due to the      statement expression extension) encounter more classes.  We want      to handle them right away, but we don't want them getting mixed      up with default args that are currently in the queue.  */
name|parser
operator|->
name|unparsed_functions_queues
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
expr_stmt|;
for|for
control|(
name|parameters
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
init|;
name|parameters
condition|;
name|parameters
operator|=
name|TREE_CHAIN
argument_list|(
name|parameters
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
name|parameters
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parameters
argument_list|)
argument_list|)
operator|!=
name|DEFAULT_ARG
condition|)
continue|continue;
comment|/* Save away the current lexer.  */
name|saved_lexer
operator|=
name|parser
operator|->
name|lexer
expr_stmt|;
comment|/* Create a new one, using the tokens we have saved.  */
name|tokens
operator|=
name|DEFARG_TOKENS
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parameters
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|->
name|lexer
operator|=
name|cp_lexer_new_from_tokens
argument_list|(
name|tokens
argument_list|)
expr_stmt|;
comment|/* Set the current source position to be the location of the      	  first token in the default argument.  */
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Local variable names (and the `this' keyword) may not appear      	  in a default argument.  */
name|saved_local_variables_forbidden_p
operator|=
name|parser
operator|->
name|local_variables_forbidden_p
expr_stmt|;
name|parser
operator|->
name|local_variables_forbidden_p
operator|=
name|true
expr_stmt|;
comment|/* Parse the assignment-expression.  */
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|fn
argument_list|)
condition|)
name|push_nested_class
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|parameters
argument_list|)
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|fn
argument_list|)
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
comment|/* If the token stream has not been completely used up, then 	 there was extra junk after the end of the default 	 argument.  */
if|if
condition|(
operator|!
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EOF
argument_list|)
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected `,'"
argument_list|)
expr_stmt|;
comment|/* Restore saved state.  */
name|parser
operator|->
name|lexer
operator|=
name|saved_lexer
expr_stmt|;
name|parser
operator|->
name|local_variables_forbidden_p
operator|=
name|saved_local_variables_forbidden_p
expr_stmt|;
block|}
comment|/* Restore the queue.  */
name|parser
operator|->
name|unparsed_functions_queues
operator|=
name|TREE_CHAIN
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the operand of `sizeof' (or a similar operator).  Returns    either a TYPE or an expression, depending on the form of the    input.  The KEYWORD indicates which kind of expression we have    encountered.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_sizeof_operand
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|rid
name|keyword
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|tree
name|expr
init|=
name|NULL_TREE
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
name|bool
name|saved_integral_constant_expression_p
decl_stmt|;
comment|/* Initialize FORMAT the first time we get here.  */
if|if
condition|(
operator|!
name|format
condition|)
name|format
operator|=
literal|"types may not be defined in `%s' expressions"
expr_stmt|;
comment|/* Types cannot be defined in a `sizeof' expression.  Save away the      old message.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
comment|/* And create the new one.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|format
argument_list|)
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|ridpointers
index|[
name|keyword
index|]
argument_list|)
argument_list|)
operator|+
literal|1
comment|/* `\0' */
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parser
operator|->
name|type_definition_forbidden_message
argument_list|,
name|format
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ridpointers
index|[
name|keyword
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The restrictions on constant-expressions do not apply inside      sizeof expressions.  */
name|saved_integral_constant_expression_p
operator|=
name|parser
operator|->
name|integral_constant_expression_p
expr_stmt|;
name|parser
operator|->
name|integral_constant_expression_p
operator|=
name|false
expr_stmt|;
comment|/* Do not actually evaluate the expression.  */
operator|++
name|skip_evaluation
expr_stmt|;
comment|/* If it's a `(', then we might be looking at the type-id      construction.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|bool
name|saved_in_type_id_in_expr_p
decl_stmt|;
comment|/* We can't be sure yet whether we're looking at a type-id or an 	 expression.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the type-id.  */
name|saved_in_type_id_in_expr_p
operator|=
name|parser
operator|->
name|in_type_id_in_expr_p
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|true
expr_stmt|;
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|saved_in_type_id_in_expr_p
expr_stmt|;
comment|/* Now, look for the trailing `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* If all went well, then we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* Build a list of decl-specifiers; right now, we have only 	     a single type-specifier.  */
name|type
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Call grokdeclarator to figure out what type this is.  */
name|expr
operator|=
name|grokdeclarator
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|TYPENAME
argument_list|,
comment|/*initialized=*/
literal|0
argument_list|,
comment|/*attrlist=*/
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the type-id production did not work out, then we must be      looking at the unary-expression production.  */
if|if
condition|(
operator|!
name|expr
condition|)
name|expr
operator|=
name|cp_parser_unary_expression
argument_list|(
name|parser
argument_list|,
comment|/*address_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Go back to evaluating expressions.  */
operator|--
name|skip_evaluation
expr_stmt|;
comment|/* Free the message we created.  */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parser
operator|->
name|type_definition_forbidden_message
argument_list|)
expr_stmt|;
comment|/* And restore the old one.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
name|parser
operator|->
name|integral_constant_expression_p
operator|=
name|saved_integral_constant_expression_p
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* If the current declaration has no declarator, return true.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_declares_only_class_p
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* If the next token is a `;' or a `,' then there is no       declarator.  */
return|return
operator|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
operator|||
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* DECL_SPECIFIERS is the representation of a decl-specifier-seq.    Returns TRUE iff `friend' appears among the DECL_SPECIFIERS.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_friend_p
parameter_list|(
name|tree
name|decl_specifiers
parameter_list|)
block|{
while|while
condition|(
name|decl_specifiers
condition|)
block|{
comment|/* See if this decl-specifier is `friend'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|decl_specifiers
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|C_RID_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|decl_specifiers
argument_list|)
argument_list|)
operator|==
name|RID_FRIEND
condition|)
return|return
name|true
return|;
comment|/* Go on to the next decl-specifier.  */
name|decl_specifiers
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_specifiers
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* If the next token is of the indicated TYPE, consume it.  Otherwise,    issue an error message indicating that TOKEN_DESC was expected.        Returns the token consumed, if the token had the appropriate type.    Otherwise, returns NULL.  */
end_comment

begin_function
specifier|static
name|cp_token
modifier|*
name|cp_parser_require
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|cpp_ttype
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|token_desc
parameter_list|)
block|{
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
return|;
else|else
block|{
comment|/* Output the MESSAGE -- unless we're parsing tentatively.  */
if|if
condition|(
operator|!
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|char
modifier|*
name|message
init|=
name|concat
argument_list|(
literal|"expected "
argument_list|,
name|token_desc
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like cp_parser_require, except that tokens will be skipped until    the desired token is found.  An error message is still produced if    the next token is not as expected.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_skip_until_found
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|cpp_ttype
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|token_desc
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|unsigned
name|nesting_depth
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|type
argument_list|,
name|token_desc
argument_list|)
condition|)
return|return;
comment|/* Skip tokens until the desired token is found.  */
while|while
condition|(
name|true
condition|)
block|{
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If we've reached the token we want, consume it and  	 stop.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|type
operator|&&
operator|!
name|nesting_depth
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we've run out of tokens, stop.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
return|return;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_SQUARE
condition|)
operator|++
name|nesting_depth
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_SQUARE
condition|)
block|{
if|if
condition|(
name|nesting_depth
operator|--
operator|==
literal|0
condition|)
return|return;
block|}
comment|/* Consume this token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If the next token is the indicated keyword, consume it.  Otherwise,    issue an error message indicating that TOKEN_DESC was expected.        Returns the token consumed, if the token had the appropriate type.    Otherwise, returns NULL.  */
end_comment

begin_function
specifier|static
name|cp_token
modifier|*
name|cp_parser_require_keyword
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|rid
name|keyword
parameter_list|,
specifier|const
name|char
modifier|*
name|token_desc
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|,
name|token_desc
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|&&
name|token
operator|->
name|keyword
operator|!=
name|keyword
condition|)
block|{
name|dyn_string_t
name|error_msg
decl_stmt|;
comment|/* Format the error message.  */
name|error_msg
operator|=
name|dyn_string_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dyn_string_append_cstr
argument_list|(
name|error_msg
argument_list|,
literal|"expected "
argument_list|)
expr_stmt|;
name|dyn_string_append_cstr
argument_list|(
name|error_msg
argument_list|,
name|token_desc
argument_list|)
expr_stmt|;
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
name|error_msg
operator|->
name|s
argument_list|)
expr_stmt|;
name|dyn_string_delete
argument_list|(
name|error_msg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|token
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE iff TOKEN is a token that can begin the body of a    function-definition.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_token_starts_function_definition_p
parameter_list|(
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
return|return
operator|(
comment|/* An ordinary function-body begins with an `{'.  */
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
comment|/* A ctor-initializer begins with a `:'.  */
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_COLON
comment|/* A function-try-block begins with `try'.  */
operator|||
name|token
operator|->
name|keyword
operator|==
name|RID_TRY
comment|/* The named return value extension begins with `return'.  */
operator|||
name|token
operator|->
name|keyword
operator|==
name|RID_RETURN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE iff the next token is the ":" or "{" beginning a class    definition.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_next_token_starts_class_definition_p
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_COLON
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE iff the next token is the "," or ">" ending a    template-argument. ">>" is also accepted (after the full    argument was parsed) because it's probably a typo for ">>",    and there is a specific diagnostic for this.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_next_token_ends_template_argument_p
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_GREATER
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_RSHIFT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE iff the n-th token is a ">", or the n-th is a "[" and the    (n+1)-th is a ":" (which is a possible digraph typo for "< ::").  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_nth_token_starts_template_argument_list_p
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_LESS
condition|)
return|return
name|true
return|;
comment|/* Check for the sequence `<::' in the original code. It would be lexed as      `[:', where `[' is a digraph, and there is no whitespace before      `:'.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_SQUARE
operator|&&
name|token
operator|->
name|flags
operator|&
name|DIGRAPH
condition|)
block|{
name|cp_token
modifier|*
name|token2
decl_stmt|;
name|token2
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|token2
operator|->
name|type
operator|==
name|CPP_COLON
operator|&&
operator|!
operator|(
name|token2
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns the kind of tag indicated by TOKEN, if it is a class-key,    or none_type otherwise.  */
end_comment

begin_function
specifier|static
name|enum
name|tag_types
name|cp_parser_token_is_class_key
parameter_list|(
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_CLASS
case|:
return|return
name|class_type
return|;
case|case
name|RID_STRUCT
case|:
return|return
name|record_type
return|;
case|case
name|RID_UNION
case|:
return|return
name|union_type
return|;
default|default:
return|return
name|none_type
return|;
block|}
block|}
end_function

begin_comment
comment|/* Issue an error message if the CLASS_KEY does not match the TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_check_class_key
parameter_list|(
name|enum
name|tag_types
name|class_key
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|!=
operator|(
name|class_key
operator|==
name|union_type
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"`%s' tag used in naming `%#T'"
argument_list|,
name|class_key
operator|==
name|union_type
condition|?
literal|"union"
else|:
name|class_key
operator|==
name|record_type
condition|?
literal|"struct"
else|:
literal|"class"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue an error message if DECL is redeclared with different    access than its original declaration [class.access.spec/3].    This applies to nested classes and nested class templates.    [class.mem/1].  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_check_access_in_redeclaration
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
operator|!=
operator|(
name|current_access_specifier
operator|==
name|access_private_node
operator|)
operator|)
operator|||
operator|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
operator|!=
operator|(
name|current_access_specifier
operator|==
name|access_protected_node
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|"%D redeclared with different access"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look for the `template' keyword, as a syntactic disambiguator.    Return TRUE iff it is present, in which case it will be     consumed.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_optional_template_keyword
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TEMPLATE
argument_list|)
condition|)
block|{
comment|/* The `template' keyword can only be used within templates; 	 outside templates the parser can always figure out what is a 	 template and what is not.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|error
argument_list|(
literal|"`template' (as a disambiguator) is only allowed "
literal|"within templates"
argument_list|)
expr_stmt|;
comment|/* If this part of the token stream is rescanned, the same 	     error message would be generated.  So, we purge the token 	     from the stream.  */
name|cp_lexer_purge_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* Consume the `template' keyword.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* The next token is a CPP_NESTED_NAME_SPECIFIER.  Consume the token,    set PARSER->SCOPE, and perform other related actions.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_pre_parsed_nested_name_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|value
decl_stmt|;
name|tree
name|check
decl_stmt|;
comment|/* Get the stored value.  */
name|value
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|value
expr_stmt|;
comment|/* Perform any access checks that were deferred.  */
for|for
control|(
name|check
operator|=
name|TREE_PURPOSE
argument_list|(
name|value
argument_list|)
init|;
name|check
condition|;
name|check
operator|=
name|TREE_CHAIN
argument_list|(
name|check
argument_list|)
control|)
name|perform_or_defer_access_check
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|check
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|check
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the scope from the stored value.  */
name|parser
operator|->
name|scope
operator|=
name|TREE_VALUE
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add tokens to CACHE until an non-nested END token appears.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_cache_group
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token_cache
modifier|*
name|cache
parameter_list|,
name|enum
name|cpp_ttype
name|end
parameter_list|,
name|unsigned
name|depth
parameter_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Abort a parenthesized expression if we encounter a brace.  */
if|if
condition|(
operator|(
name|end
operator|==
name|CPP_CLOSE_PAREN
operator|||
name|depth
operator|==
literal|0
operator|)
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
return|return;
comment|/* If we've reached the end of the file, stop.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EOF
argument_list|)
condition|)
return|return;
comment|/* Consume the next token.  */
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Add this token to the tokens we are saving.  */
name|cp_token_cache_push_token
argument_list|(
name|cache
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* See if it starts a new group.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
condition|)
block|{
name|cp_parser_cache_group
argument_list|(
name|parser
argument_list|,
name|cache
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
name|cp_parser_cache_group
argument_list|(
name|parser
argument_list|,
name|cache
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|end
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Begin parsing tentatively.  We always save tokens while parsing    tentatively so that if the tentative parsing fails we can restore the    tokens.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_parse_tentatively
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Enter a new parsing context.  */
name|parser
operator|->
name|context
operator|=
name|cp_parser_context_new
argument_list|(
name|parser
operator|->
name|context
argument_list|)
expr_stmt|;
comment|/* Begin saving tokens.  */
name|cp_lexer_save_tokens
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* In order to avoid repetitive access control error messages,      access checks are queued up until we are no longer parsing      tentatively.  */
name|push_deferring_access_checks
argument_list|(
name|dk_deferred
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Commit to the currently active tentative parse.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_commit_to_tentative_parse
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_parser_context
modifier|*
name|context
decl_stmt|;
name|cp_lexer
modifier|*
name|lexer
decl_stmt|;
comment|/* Mark all of the levels as committed.  */
name|lexer
operator|=
name|parser
operator|->
name|lexer
expr_stmt|;
for|for
control|(
name|context
operator|=
name|parser
operator|->
name|context
init|;
name|context
operator|->
name|next
condition|;
name|context
operator|=
name|context
operator|->
name|next
control|)
block|{
if|if
condition|(
name|context
operator|->
name|status
operator|==
name|CP_PARSER_STATUS_KIND_COMMITTED
condition|)
break|break;
name|context
operator|->
name|status
operator|=
name|CP_PARSER_STATUS_KIND_COMMITTED
expr_stmt|;
while|while
condition|(
operator|!
name|cp_lexer_saving_tokens
argument_list|(
name|lexer
argument_list|)
condition|)
name|lexer
operator|=
name|lexer
operator|->
name|next
expr_stmt|;
name|cp_lexer_commit_tokens
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Abort the currently active tentative parse.  All consumed tokens    will be rolled back, and no diagnostics will be issued.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_abort_tentative_parse
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Now, pretend that we want to see if the construct was      successfully parsed.  */
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop parsing tentatively.  If a parse error has occurred, restore the    token stream.  Otherwise, commit to the tokens we have consumed.    Returns true if no error occurred; false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_parse_definitely
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|bool
name|error_occurred
decl_stmt|;
name|cp_parser_context
modifier|*
name|context
decl_stmt|;
comment|/* Remember whether or not an error occurred, since we are about to      destroy that information.  */
name|error_occurred
operator|=
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Remove the topmost context from the stack.  */
name|context
operator|=
name|parser
operator|->
name|context
expr_stmt|;
name|parser
operator|->
name|context
operator|=
name|context
operator|->
name|next
expr_stmt|;
comment|/* If no parse errors occurred, commit to the tentative parse.  */
if|if
condition|(
operator|!
name|error_occurred
condition|)
block|{
comment|/* Commit to the tokens read tentatively, unless that was 	 already done.  */
if|if
condition|(
name|context
operator|->
name|status
operator|!=
name|CP_PARSER_STATUS_KIND_COMMITTED
condition|)
name|cp_lexer_commit_tokens
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|pop_to_parent_deferring_access_checks
argument_list|()
expr_stmt|;
block|}
comment|/* Otherwise, if errors occurred, roll back our state so that things      are just as they were before we began the tentative parse.  */
else|else
block|{
name|cp_lexer_rollback_tokens
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
block|}
comment|/* Add the context to the front of the free list.  */
name|context
operator|->
name|next
operator|=
name|cp_parser_context_free_list
expr_stmt|;
name|cp_parser_context_free_list
operator|=
name|context
expr_stmt|;
return|return
operator|!
name|error_occurred
return|;
block|}
end_function

begin_comment
comment|/* Returns true if we are parsing tentatively -- but have decided that    we will stick with this tentative parse, even if errors occur.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_committed_to_tentative_parse
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
return|return
operator|(
name|cp_parser_parsing_tentatively
argument_list|(
name|parser
argument_list|)
operator|&&
name|parser
operator|->
name|context
operator|->
name|status
operator|==
name|CP_PARSER_STATUS_KIND_COMMITTED
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero iff an error has occurred during the most recent    tentative parse.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_error_occurred
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
return|return
operator|(
name|cp_parser_parsing_tentatively
argument_list|(
name|parser
argument_list|)
operator|&&
name|parser
operator|->
name|context
operator|->
name|status
operator|==
name|CP_PARSER_STATUS_KIND_ERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if GNU extensions are allowed.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_allow_gnu_extensions_p
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
return|return
name|parser
operator|->
name|allow_gnu_extensions_p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The parser.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|cp_parser
operator|*
name|the_parser
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* External interface.  */
end_comment

begin_comment
comment|/* Parse one entire translation unit.  */
end_comment

begin_function
name|void
name|c_parse_file
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|error_occurred
decl_stmt|;
name|the_parser
operator|=
name|cp_parser_new
argument_list|()
expr_stmt|;
name|push_deferring_access_checks
argument_list|(
name|flag_access_control
condition|?
name|dk_no_deferred
else|:
name|dk_no_check
argument_list|)
expr_stmt|;
name|error_occurred
operator|=
name|cp_parser_translation_unit
argument_list|(
name|the_parser
argument_list|)
expr_stmt|;
name|the_parser
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This variable must be provided by every front end.  */
end_comment

begin_decl_stmt
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"gt-cp-parser.h"
end_include

end_unit

