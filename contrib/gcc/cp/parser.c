begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C++ Parser.    Copyright (C) 2000, 2001, 2002, 2003, 2004,    2005  Free Software Foundation, Inc.    Written by Mark Mitchell<mark@codesourcery.com>.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"dyn-string.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* The lexer.  */
end_comment

begin_comment
comment|/* The cp_lexer_* routines mediate between the lexer proper (in libcpp    and c-lex.c) and the C++ parser.  */
end_comment

begin_comment
comment|/* A token's value and its associated deferred access checks and    qualifying scope.  */
end_comment

begin_decl_stmt
name|struct
name|tree_check
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The value associated with the token.  */
name|tree
name|value
decl_stmt|;
comment|/* The checks that have been associated with value.  */
name|VEC
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|)
operator|*
name|checks
expr_stmt|;
comment|/* The token's qualifying scope (used when it is a      CPP_NESTED_NAME_SPECIFIER).  */
name|tree
name|qualifying_scope
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* A C++ token.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cp_token
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The kind of token.  */
name|ENUM_BITFIELD
argument_list|(
argument|cpp_ttype
argument_list|)
name|type
label|:
literal|8
expr_stmt|;
comment|/* If this token is a keyword, this value indicates which keyword.      Otherwise, this value is RID_MAX.  */
name|ENUM_BITFIELD
argument_list|(
argument|rid
argument_list|)
name|keyword
label|:
literal|8
expr_stmt|;
comment|/* Token flags.  */
name|unsigned
name|char
name|flags
block|;
comment|/* Identifier for the pragma.  */
name|ENUM_BITFIELD
argument_list|(
argument|pragma_kind
argument_list|)
name|pragma_kind
label|:
literal|6
expr_stmt|;
comment|/* True if this token is from a system header.  */
name|BOOL_BITFIELD
name|in_system_header
range|:
literal|1
block|;
comment|/* True if this token is from a context where it is implicitly extern "C" */
name|BOOL_BITFIELD
name|implicit_extern_c
range|:
literal|1
block|;
comment|/* True for a CPP_NAME token that is not a keyword (i.e., for which      KEYWORD is RID_MAX) iff this name was looked up and found to be      ambiguous.  An error has already been reported.  */
name|BOOL_BITFIELD
name|ambiguous_p
range|:
literal|1
block|;
comment|/* The input file stack index at which this token was found.  */
name|unsigned
name|input_file_stack_index
range|:
name|INPUT_FILE_STACK_BITS
block|;
comment|/* The value associated with this token, if any.  */
union|union
name|cp_token_value
block|{
comment|/* Used for CPP_NESTED_NAME_SPECIFIER and CPP_TEMPLATE_ID.  */
name|struct
name|tree_check
modifier|*
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"1"
argument_list|)
operator|)
argument_list|)
name|tree_check_value
block|;
comment|/* Use for all other tokens.  */
name|tree
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"0"
argument_list|)
operator|)
argument_list|)
name|value
block|;   }
name|GTY
argument_list|(
operator|(
name|desc
argument_list|(
literal|"(%1.type == CPP_TEMPLATE_ID) || (%1.type == CPP_NESTED_NAME_SPECIFIER)"
argument_list|)
operator|)
argument_list|)
name|u
union|;
comment|/* The location at which this token was found.  */
name|location_t
name|location
block|; }
end_typedef

begin_expr_stmt
name|cp_token
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* We use a stack of token pointer for saving token sets.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cp_token
modifier|*
name|cp_token_position
typedef|;
end_typedef

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|cp_token_position
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|cp_token_position
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|cp_token
name|eof_token
init|=
block|{
name|CPP_EOF
block|,
name|RID_MAX
block|,
literal|0
block|,
name|PRAGMA_NONE
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
literal|0
block|,
block|{
name|NULL
block|}
block|,
if|#
directive|if
name|USE_MAPPED_LOCATION
literal|0
else|#
directive|else
block|{
literal|0
block|,
literal|0
block|}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The cp_lexer structure represents the C++ lexer.  It is responsible    for managing the token stream from the preprocessor and supplying    it to the parser.  Tokens are never added to the cp_lexer after    it is created.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cp_lexer
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The memory allocated for the buffer.  NULL if this lexer does not      own the token buffer.  */
name|cp_token
modifier|*
name|GTY
argument_list|(
operator|(
name|length
argument_list|(
literal|"%h.buffer_length"
argument_list|)
operator|)
argument_list|)
name|buffer
block|;
comment|/* If the lexer owns the buffer, this is the number of tokens in the      buffer.  */
name|size_t
name|buffer_length
block|;
comment|/* A pointer just past the last available token.  The tokens      in this lexer are [buffer, last_token).  */
name|cp_token_position
name|GTY
argument_list|(
operator|(
name|skip
operator|)
argument_list|)
name|last_token
block|;
comment|/* The next available token.  If NEXT_TOKEN is&eof_token, then there are      no more available tokens.  */
name|cp_token_position
name|GTY
argument_list|(
operator|(
name|skip
operator|)
argument_list|)
name|next_token
block|;
comment|/* A stack indicating positions at which cp_lexer_save_tokens was      called.  The top entry is the most recent position at which we      began saving tokens.  If the stack is non-empty, we are saving      tokens.  */
name|VEC
argument_list|(
name|cp_token_position
argument_list|,
name|heap
argument_list|)
operator|*
name|GTY
argument_list|(
argument|(skip)
argument_list|)
name|saved_tokens
expr_stmt|;
comment|/* The next lexer in a linked list of lexers.  */
name|struct
name|cp_lexer
modifier|*
name|next
block|;
comment|/* True if we should output debugging information.  */
name|bool
name|debugging_p
block|;
comment|/* True if we're in the context of parsing a pragma, and should not      increment past the end-of-line marker.  */
name|bool
name|in_pragma
block|; }
end_typedef

begin_expr_stmt
name|cp_lexer
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* cp_token_cache is a range of tokens.  There is no need to represent    allocate heap memory for it, since tokens are never removed from the    lexer's array.  There is also no need for the GC to walk through    a cp_token_cache, since everything in here is referenced through    a lexer.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cp_token_cache
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The beginning of the token range.  */
name|cp_token
modifier|*
name|GTY
argument_list|(
operator|(
name|skip
operator|)
argument_list|)
name|first
block|;
comment|/* Points immediately after the last token in the range.  */
name|cp_token
modifier|*
name|GTY
argument_list|(
operator|(
name|skip
operator|)
argument_list|)
name|last
block|; }
end_typedef

begin_expr_stmt
name|cp_token_cache
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Prototypes.  */
end_comment

begin_function_decl
specifier|static
name|cp_lexer
modifier|*
name|cp_lexer_new_main
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_lexer
modifier|*
name|cp_lexer_new_from_tokens
parameter_list|(
name|cp_token_cache
modifier|*
name|tokens
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_lexer_destroy
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cp_lexer_saving_tokens
parameter_list|(
specifier|const
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_token_position
name|cp_lexer_token_position
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_token
modifier|*
name|cp_lexer_token_at
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|cp_token_position
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_lexer_get_preprocessor_token
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|cp_token
modifier|*
name|cp_lexer_peek_token
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_token
modifier|*
name|cp_lexer_peek_nth_token
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|cp_lexer_next_token_is
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|enum
name|cpp_ttype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_lexer_next_token_is_not
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|enum
name|cpp_ttype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_lexer_next_token_is_keyword
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|enum
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_token
modifier|*
name|cp_lexer_consume_token
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_lexer_purge_token
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_lexer_purge_tokens_after
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|,
name|cp_token_position
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_lexer_save_tokens
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_lexer_commit_tokens
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_lexer_rollback_tokens
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_function_decl
specifier|static
name|void
name|cp_lexer_print_token
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|cp_lexer_debugging_p
parameter_list|(
name|cp_lexer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|cp_lexer_start_debugging
argument_list|(
name|cp_lexer
operator|*
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cp_lexer_stop_debugging
argument_list|(
name|cp_lexer
operator|*
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* If we define cp_lexer_debug_stream to NULL it will provoke warnings    about passing NULL to functions that require non-NULL arguments    (fputs, fprintf).  It will never be used, so all we need is a value    of the right type that's guaranteed not to be NULL.  */
end_comment

begin_define
define|#
directive|define
name|cp_lexer_debug_stream
value|stdout
end_define

begin_define
define|#
directive|define
name|cp_lexer_print_token
parameter_list|(
name|str
parameter_list|,
name|tok
parameter_list|)
value|(void) 0
end_define

begin_define
define|#
directive|define
name|cp_lexer_debugging_p
parameter_list|(
name|lexer
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_CHECKING */
end_comment

begin_function_decl
specifier|static
name|cp_token_cache
modifier|*
name|cp_token_cache_new
parameter_list|(
name|cp_token
modifier|*
parameter_list|,
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_initial_pragma
parameter_list|(
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Manifest constants.  */
end_comment

begin_define
define|#
directive|define
name|CP_LEXER_BUFFER_SIZE
value|((256 * 1024) / sizeof (cp_token))
end_define

begin_define
define|#
directive|define
name|CP_SAVED_TOKEN_STACK
value|5
end_define

begin_comment
comment|/* A token type for keywords, as opposed to ordinary identifiers.  */
end_comment

begin_define
define|#
directive|define
name|CPP_KEYWORD
value|((enum cpp_ttype) (N_TTYPES + 1))
end_define

begin_comment
comment|/* A token type for template-ids.  If a template-id is processed while    parsing tentatively, it is replaced with a CPP_TEMPLATE_ID token;    the value of the CPP_TEMPLATE_ID is whatever was returned by    cp_parser_template_id.  */
end_comment

begin_define
define|#
directive|define
name|CPP_TEMPLATE_ID
value|((enum cpp_ttype) (CPP_KEYWORD + 1))
end_define

begin_comment
comment|/* A token type for nested-name-specifiers.  If a    nested-name-specifier is processed while parsing tentatively, it is    replaced with a CPP_NESTED_NAME_SPECIFIER token; the value of the    CPP_NESTED_NAME_SPECIFIER is whatever was returned by    cp_parser_nested_name_specifier_opt.  */
end_comment

begin_define
define|#
directive|define
name|CPP_NESTED_NAME_SPECIFIER
value|((enum cpp_ttype) (CPP_TEMPLATE_ID + 1))
end_define

begin_comment
comment|/* A token type for tokens that are not tokens at all; these are used    to represent slots in the array where there used to be a token    that has now been deleted.  */
end_comment

begin_define
define|#
directive|define
name|CPP_PURGED
value|((enum cpp_ttype) (CPP_NESTED_NAME_SPECIFIER + 1))
end_define

begin_comment
comment|/* The number of token types, including C++-specific ones.  */
end_comment

begin_define
define|#
directive|define
name|N_CP_TTYPES
value|((int) (CPP_PURGED + 1))
end_define

begin_comment
comment|/* Variables.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_comment
comment|/* The stream to which debugging output should be written.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|cp_lexer_debug_stream
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_CHECKING */
end_comment

begin_comment
comment|/* Create a new main C++ lexer, the lexer that gets tokens from the    preprocessor.  */
end_comment

begin_function
specifier|static
name|cp_lexer
modifier|*
name|cp_lexer_new_main
parameter_list|(
name|void
parameter_list|)
block|{
name|cp_token
name|first_token
decl_stmt|;
name|cp_lexer
modifier|*
name|lexer
decl_stmt|;
name|cp_token
modifier|*
name|pos
decl_stmt|;
name|size_t
name|alloc
decl_stmt|;
name|size_t
name|space
decl_stmt|;
name|cp_token
modifier|*
name|buffer
decl_stmt|;
comment|/* It's possible that parsing the first pragma will load a PCH file,      which is a GC collection point.  So we have to do that before      allocating any memory.  */
name|cp_parser_initial_pragma
argument_list|(
operator|&
name|first_token
argument_list|)
expr_stmt|;
comment|/* Tell c_lex_with_flags not to merge string constants.  */
name|c_lex_return_raw_strings
operator|=
name|true
expr_stmt|;
name|c_common_no_more_pch
argument_list|()
expr_stmt|;
comment|/* Allocate the memory.  */
name|lexer
operator|=
name|GGC_CNEW
argument_list|(
name|cp_lexer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Initially we are not debugging.  */
name|lexer
operator|->
name|debugging_p
operator|=
name|false
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_CHECKING */
name|lexer
operator|->
name|saved_tokens
operator|=
name|VEC_alloc
argument_list|(
name|cp_token_position
argument_list|,
name|heap
argument_list|,
name|CP_SAVED_TOKEN_STACK
argument_list|)
expr_stmt|;
comment|/* Create the buffer.  */
name|alloc
operator|=
name|CP_LEXER_BUFFER_SIZE
expr_stmt|;
name|buffer
operator|=
name|GGC_NEWVEC
argument_list|(
name|cp_token
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
comment|/* Put the first token in the buffer.  */
name|space
operator|=
name|alloc
expr_stmt|;
name|pos
operator|=
name|buffer
expr_stmt|;
operator|*
name|pos
operator|=
name|first_token
expr_stmt|;
comment|/* Get the remaining tokens from the preprocessor.  */
while|while
condition|(
name|pos
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
block|{
name|pos
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|space
condition|)
block|{
name|space
operator|=
name|alloc
expr_stmt|;
name|alloc
operator|*=
literal|2
expr_stmt|;
name|buffer
operator|=
name|GGC_RESIZEVEC
argument_list|(
name|cp_token
argument_list|,
name|buffer
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|pos
operator|=
name|buffer
operator|+
name|space
expr_stmt|;
block|}
name|cp_lexer_get_preprocessor_token
argument_list|(
name|lexer
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
name|lexer
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
name|lexer
operator|->
name|buffer_length
operator|=
name|alloc
operator|-
name|space
expr_stmt|;
name|lexer
operator|->
name|last_token
operator|=
name|pos
expr_stmt|;
name|lexer
operator|->
name|next_token
operator|=
name|lexer
operator|->
name|buffer_length
condition|?
name|buffer
else|:
operator|(
name|cp_token
operator|*
operator|)
operator|&
name|eof_token
expr_stmt|;
comment|/* Subsequent preprocessor diagnostics should use compiler      diagnostic functions to get the compiler source location.  */
name|cpp_get_options
argument_list|(
name|parse_in
argument_list|)
operator|->
name|client_diagnostic
operator|=
name|true
expr_stmt|;
name|cpp_get_callbacks
argument_list|(
name|parse_in
argument_list|)
operator|->
name|error
operator|=
name|cp_cpp_error
expr_stmt|;
name|gcc_assert
argument_list|(
name|lexer
operator|->
name|next_token
operator|->
name|type
operator|!=
name|CPP_PURGED
argument_list|)
expr_stmt|;
return|return
name|lexer
return|;
block|}
end_function

begin_comment
comment|/* Create a new lexer whose token stream is primed with the tokens in    CACHE.  When these tokens are exhausted, no new tokens will be read.  */
end_comment

begin_function
specifier|static
name|cp_lexer
modifier|*
name|cp_lexer_new_from_tokens
parameter_list|(
name|cp_token_cache
modifier|*
name|cache
parameter_list|)
block|{
name|cp_token
modifier|*
name|first
init|=
name|cache
operator|->
name|first
decl_stmt|;
name|cp_token
modifier|*
name|last
init|=
name|cache
operator|->
name|last
decl_stmt|;
name|cp_lexer
modifier|*
name|lexer
init|=
name|GGC_CNEW
argument_list|(
name|cp_lexer
argument_list|)
decl_stmt|;
comment|/* We do not own the buffer.  */
name|lexer
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|lexer
operator|->
name|buffer_length
operator|=
literal|0
expr_stmt|;
name|lexer
operator|->
name|next_token
operator|=
name|first
operator|==
name|last
condition|?
operator|(
name|cp_token
operator|*
operator|)
operator|&
name|eof_token
else|:
name|first
expr_stmt|;
name|lexer
operator|->
name|last_token
operator|=
name|last
expr_stmt|;
name|lexer
operator|->
name|saved_tokens
operator|=
name|VEC_alloc
argument_list|(
name|cp_token_position
argument_list|,
name|heap
argument_list|,
name|CP_SAVED_TOKEN_STACK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Initially we are not debugging.  */
name|lexer
operator|->
name|debugging_p
operator|=
name|false
expr_stmt|;
endif|#
directive|endif
name|gcc_assert
argument_list|(
name|lexer
operator|->
name|next_token
operator|->
name|type
operator|!=
name|CPP_PURGED
argument_list|)
expr_stmt|;
return|return
name|lexer
return|;
block|}
end_function

begin_comment
comment|/* Frees all resources associated with LEXER.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_destroy
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
if|if
condition|(
name|lexer
operator|->
name|buffer
condition|)
name|ggc_free
argument_list|(
name|lexer
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|cp_token_position
argument_list|,
name|heap
argument_list|,
name|lexer
operator|->
name|saved_tokens
argument_list|)
expr_stmt|;
name|ggc_free
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if debugging information should be output.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_function
specifier|static
specifier|inline
name|bool
name|cp_lexer_debugging_p
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
return|return
name|lexer
operator|->
name|debugging_p
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_CHECKING */
end_comment

begin_function
specifier|static
specifier|inline
name|cp_token_position
name|cp_lexer_token_position
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|,
name|bool
name|previous_p
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|previous_p
operator|||
name|lexer
operator|->
name|next_token
operator|!=
operator|&
name|eof_token
argument_list|)
expr_stmt|;
return|return
name|lexer
operator|->
name|next_token
operator|-
name|previous_p
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|cp_token
modifier|*
name|cp_lexer_token_at
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
name|ATTRIBUTE_UNUSED
parameter_list|,
name|cp_token_position
name|pos
parameter_list|)
block|{
return|return
name|pos
return|;
block|}
end_function

begin_comment
comment|/* nonzero if we are presently saving tokens.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|cp_lexer_saving_tokens
parameter_list|(
specifier|const
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
return|return
name|VEC_length
argument_list|(
name|cp_token_position
argument_list|,
name|lexer
operator|->
name|saved_tokens
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Store the next token from the preprocessor in *TOKEN.  Return true    if we reach EOF.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_get_preprocessor_token
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
name|ATTRIBUTE_UNUSED
parameter_list|,
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
specifier|static
name|int
name|is_extern_c
init|=
literal|0
decl_stmt|;
comment|/* Get a new token from the preprocessor.  */
name|token
operator|->
name|type
operator|=
name|c_lex_with_flags
argument_list|(
operator|&
name|token
operator|->
name|u
operator|.
name|value
argument_list|,
operator|&
name|token
operator|->
name|location
argument_list|,
operator|&
name|token
operator|->
name|flags
argument_list|)
expr_stmt|;
name|token
operator|->
name|input_file_stack_index
operator|=
name|input_file_stack_tick
expr_stmt|;
name|token
operator|->
name|keyword
operator|=
name|RID_MAX
expr_stmt|;
name|token
operator|->
name|pragma_kind
operator|=
name|PRAGMA_NONE
expr_stmt|;
name|token
operator|->
name|in_system_header
operator|=
name|in_system_header
expr_stmt|;
comment|/* On some systems, some header files are surrounded by an      implicit extern "C" block.  Set a flag in the token if it      comes from such a header.  */
name|is_extern_c
operator|+=
name|pending_lang_change
expr_stmt|;
name|pending_lang_change
operator|=
literal|0
expr_stmt|;
name|token
operator|->
name|implicit_extern_c
operator|=
name|is_extern_c
operator|>
literal|0
expr_stmt|;
comment|/* Check to see if this token is a keyword.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
block|{
if|if
condition|(
name|C_IS_RESERVED_WORD
argument_list|(
name|token
operator|->
name|u
operator|.
name|value
argument_list|)
condition|)
block|{
comment|/* Mark this token as a keyword.  */
name|token
operator|->
name|type
operator|=
name|CPP_KEYWORD
expr_stmt|;
comment|/* Record which keyword.  */
name|token
operator|->
name|keyword
operator|=
name|C_RID_CODE
argument_list|(
name|token
operator|->
name|u
operator|.
name|value
argument_list|)
expr_stmt|;
comment|/* Update the value.  Some keywords are mapped to particular 	     entities, rather than simply having the value of the 	     corresponding IDENTIFIER_NODE.  For example, `__const' is 	     mapped to `const'.  */
name|token
operator|->
name|u
operator|.
name|value
operator|=
name|ridpointers
index|[
name|token
operator|->
name|keyword
index|]
expr_stmt|;
block|}
else|else
block|{
name|token
operator|->
name|ambiguous_p
operator|=
name|false
expr_stmt|;
name|token
operator|->
name|keyword
operator|=
name|RID_MAX
expr_stmt|;
block|}
block|}
comment|/* Handle Objective-C++ keywords.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_AT_NAME
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|CPP_KEYWORD
expr_stmt|;
switch|switch
condition|(
name|C_RID_CODE
argument_list|(
name|token
operator|->
name|u
operator|.
name|value
argument_list|)
condition|)
block|{
comment|/* Map 'class' to '@class', 'private' to '@private', etc.  */
case|case
name|RID_CLASS
case|:
name|token
operator|->
name|keyword
operator|=
name|RID_AT_CLASS
expr_stmt|;
break|break;
case|case
name|RID_PRIVATE
case|:
name|token
operator|->
name|keyword
operator|=
name|RID_AT_PRIVATE
expr_stmt|;
break|break;
case|case
name|RID_PROTECTED
case|:
name|token
operator|->
name|keyword
operator|=
name|RID_AT_PROTECTED
expr_stmt|;
break|break;
case|case
name|RID_PUBLIC
case|:
name|token
operator|->
name|keyword
operator|=
name|RID_AT_PUBLIC
expr_stmt|;
break|break;
case|case
name|RID_THROW
case|:
name|token
operator|->
name|keyword
operator|=
name|RID_AT_THROW
expr_stmt|;
break|break;
case|case
name|RID_TRY
case|:
name|token
operator|->
name|keyword
operator|=
name|RID_AT_TRY
expr_stmt|;
break|break;
case|case
name|RID_CATCH
case|:
name|token
operator|->
name|keyword
operator|=
name|RID_AT_CATCH
expr_stmt|;
break|break;
default|default:
name|token
operator|->
name|keyword
operator|=
name|C_RID_CODE
argument_list|(
name|token
operator|->
name|u
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PRAGMA
condition|)
block|{
comment|/* We smuggled the cpp_token->u.pragma value in an INTEGER_CST.  */
name|token
operator|->
name|pragma_kind
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|token
operator|->
name|u
operator|.
name|value
argument_list|)
expr_stmt|;
name|token
operator|->
name|u
operator|.
name|value
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update the globals input_location and in_system_header and the    input file stack from TOKEN.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|cp_lexer_set_source_position_from_token
parameter_list|(
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
block|{
name|input_location
operator|=
name|token
operator|->
name|location
expr_stmt|;
name|in_system_header
operator|=
name|token
operator|->
name|in_system_header
expr_stmt|;
name|restore_input_file_stack
argument_list|(
name|token
operator|->
name|input_file_stack_index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to the next token in the token stream, but do not    consume it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|cp_token
modifier|*
name|cp_lexer_peek_token
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
if|if
condition|(
name|cp_lexer_debugging_p
argument_list|(
name|lexer
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"cp_lexer: peeking at token: "
argument_list|,
name|cp_lexer_debug_stream
argument_list|)
expr_stmt|;
name|cp_lexer_print_token
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
name|lexer
operator|->
name|next_token
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|cp_lexer_debug_stream
argument_list|)
expr_stmt|;
block|}
return|return
name|lexer
operator|->
name|next_token
return|;
block|}
end_function

begin_comment
comment|/* Return true if the next token has the indicated TYPE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|cp_lexer_next_token_is
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|,
name|enum
name|cpp_ttype
name|type
parameter_list|)
block|{
return|return
name|cp_lexer_peek_token
argument_list|(
name|lexer
argument_list|)
operator|->
name|type
operator|==
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return true if the next token does not have the indicated TYPE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|cp_lexer_next_token_is_not
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|,
name|enum
name|cpp_ttype
name|type
parameter_list|)
block|{
return|return
operator|!
name|cp_lexer_next_token_is
argument_list|(
name|lexer
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the next token is the indicated KEYWORD.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|cp_lexer_next_token_is_keyword
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|,
name|enum
name|rid
name|keyword
parameter_list|)
block|{
return|return
name|cp_lexer_peek_token
argument_list|(
name|lexer
argument_list|)
operator|->
name|keyword
operator|==
name|keyword
return|;
block|}
end_function

begin_comment
comment|/* Return true if the next token is a keyword for a decl-specifier.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_lexer_next_token_is_decl_specifier_keyword
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
comment|/* Storage classes.  */
case|case
name|RID_AUTO
case|:
case|case
name|RID_REGISTER
case|:
case|case
name|RID_STATIC
case|:
case|case
name|RID_EXTERN
case|:
case|case
name|RID_MUTABLE
case|:
case|case
name|RID_THREAD
case|:
comment|/* Elaborated type specifiers.  */
case|case
name|RID_ENUM
case|:
case|case
name|RID_CLASS
case|:
case|case
name|RID_STRUCT
case|:
case|case
name|RID_UNION
case|:
case|case
name|RID_TYPENAME
case|:
comment|/* Simple type specifiers.  */
case|case
name|RID_CHAR
case|:
case|case
name|RID_WCHAR
case|:
case|case
name|RID_BOOL
case|:
case|case
name|RID_SHORT
case|:
case|case
name|RID_INT
case|:
case|case
name|RID_LONG
case|:
case|case
name|RID_SIGNED
case|:
case|case
name|RID_UNSIGNED
case|:
case|case
name|RID_FLOAT
case|:
case|case
name|RID_DOUBLE
case|:
case|case
name|RID_VOID
case|:
comment|/* GNU extensions.  */
case|case
name|RID_ATTRIBUTE
case|:
case|case
name|RID_TYPEOF
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to the Nth token in the token stream.  If N is 1,    then this is precisely equivalent to cp_lexer_peek_token (except    that it is not inline).  One would like to disallow that case, but    there is one case (cp_parser_nth_token_starts_template_id) where    the caller passes a variable for N and it might be 1.  */
end_comment

begin_function
specifier|static
name|cp_token
modifier|*
name|cp_lexer_peek_nth_token
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* N is 1-based, not zero-based.  */
name|gcc_assert
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_lexer_debugging_p
argument_list|(
name|lexer
argument_list|)
condition|)
name|fprintf
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
literal|"cp_lexer: peeking ahead %ld at token: "
argument_list|,
operator|(
name|long
operator|)
name|n
argument_list|)
expr_stmt|;
operator|--
name|n
expr_stmt|;
name|token
operator|=
name|lexer
operator|->
name|next_token
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|n
operator|||
name|token
operator|!=
operator|&
name|eof_token
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
operator|++
name|token
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|lexer
operator|->
name|last_token
condition|)
block|{
name|token
operator|=
operator|(
name|cp_token
operator|*
operator|)
operator|&
name|eof_token
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_PURGED
condition|)
operator|--
name|n
expr_stmt|;
block|}
if|if
condition|(
name|cp_lexer_debugging_p
argument_list|(
name|lexer
argument_list|)
condition|)
block|{
name|cp_lexer_print_token
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|cp_lexer_debug_stream
argument_list|)
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
end_function

begin_comment
comment|/* Return the next token, and advance the lexer's next_token pointer    to point to the next non-purged token.  */
end_comment

begin_function
specifier|static
name|cp_token
modifier|*
name|cp_lexer_consume_token
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|lexer
operator|->
name|next_token
decl_stmt|;
name|gcc_assert
argument_list|(
name|token
operator|!=
operator|&
name|eof_token
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|lexer
operator|->
name|in_pragma
operator|||
name|token
operator|->
name|type
operator|!=
name|CPP_PRAGMA_EOL
argument_list|)
expr_stmt|;
do|do
block|{
name|lexer
operator|->
name|next_token
operator|++
expr_stmt|;
if|if
condition|(
name|lexer
operator|->
name|next_token
operator|==
name|lexer
operator|->
name|last_token
condition|)
block|{
name|lexer
operator|->
name|next_token
operator|=
operator|(
name|cp_token
operator|*
operator|)
operator|&
name|eof_token
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|lexer
operator|->
name|next_token
operator|->
name|type
operator|==
name|CPP_PURGED
condition|)
do|;
name|cp_lexer_set_source_position_from_token
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|/* Provide debugging output.  */
if|if
condition|(
name|cp_lexer_debugging_p
argument_list|(
name|lexer
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"cp_lexer: consuming token: "
argument_list|,
name|cp_lexer_debug_stream
argument_list|)
expr_stmt|;
name|cp_lexer_print_token
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|cp_lexer_debug_stream
argument_list|)
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
end_function

begin_comment
comment|/* Permanently remove the next token from the token stream, and    advance the next_token pointer to refer to the next non-purged    token.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_purge_token
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
name|cp_token
modifier|*
name|tok
init|=
name|lexer
operator|->
name|next_token
decl_stmt|;
name|gcc_assert
argument_list|(
name|tok
operator|!=
operator|&
name|eof_token
argument_list|)
expr_stmt|;
name|tok
operator|->
name|type
operator|=
name|CPP_PURGED
expr_stmt|;
name|tok
operator|->
name|location
operator|=
name|UNKNOWN_LOCATION
expr_stmt|;
name|tok
operator|->
name|u
operator|.
name|value
operator|=
name|NULL_TREE
expr_stmt|;
name|tok
operator|->
name|keyword
operator|=
name|RID_MAX
expr_stmt|;
do|do
block|{
name|tok
operator|++
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|lexer
operator|->
name|last_token
condition|)
block|{
name|tok
operator|=
operator|(
name|cp_token
operator|*
operator|)
operator|&
name|eof_token
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_PURGED
condition|)
do|;
name|lexer
operator|->
name|next_token
operator|=
name|tok
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Permanently remove all tokens after TOK, up to, but not    including, the token that will be returned next by    cp_lexer_peek_token.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_purge_tokens_after
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|,
name|cp_token
modifier|*
name|tok
parameter_list|)
block|{
name|cp_token
modifier|*
name|peek
init|=
name|lexer
operator|->
name|next_token
decl_stmt|;
if|if
condition|(
name|peek
operator|==
operator|&
name|eof_token
condition|)
name|peek
operator|=
name|lexer
operator|->
name|last_token
expr_stmt|;
name|gcc_assert
argument_list|(
name|tok
operator|<
name|peek
argument_list|)
expr_stmt|;
for|for
control|(
name|tok
operator|+=
literal|1
init|;
name|tok
operator|!=
name|peek
condition|;
name|tok
operator|+=
literal|1
control|)
block|{
name|tok
operator|->
name|type
operator|=
name|CPP_PURGED
expr_stmt|;
name|tok
operator|->
name|location
operator|=
name|UNKNOWN_LOCATION
expr_stmt|;
name|tok
operator|->
name|u
operator|.
name|value
operator|=
name|NULL_TREE
expr_stmt|;
name|tok
operator|->
name|keyword
operator|=
name|RID_MAX
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Begin saving tokens.  All tokens consumed after this point will be    preserved.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_save_tokens
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
comment|/* Provide debugging output.  */
if|if
condition|(
name|cp_lexer_debugging_p
argument_list|(
name|lexer
argument_list|)
condition|)
name|fprintf
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
literal|"cp_lexer: saving tokens\n"
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|cp_token_position
argument_list|,
name|heap
argument_list|,
name|lexer
operator|->
name|saved_tokens
argument_list|,
name|lexer
operator|->
name|next_token
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Commit to the portion of the token stream most recently saved.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_commit_tokens
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
comment|/* Provide debugging output.  */
if|if
condition|(
name|cp_lexer_debugging_p
argument_list|(
name|lexer
argument_list|)
condition|)
name|fprintf
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
literal|"cp_lexer: committing tokens\n"
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|cp_token_position
argument_list|,
name|lexer
operator|->
name|saved_tokens
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return all tokens saved since the last call to cp_lexer_save_tokens    to the token stream.  Stop saving tokens.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_rollback_tokens
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
comment|/* Provide debugging output.  */
if|if
condition|(
name|cp_lexer_debugging_p
argument_list|(
name|lexer
argument_list|)
condition|)
name|fprintf
argument_list|(
name|cp_lexer_debug_stream
argument_list|,
literal|"cp_lexer: restoring tokens\n"
argument_list|)
expr_stmt|;
name|lexer
operator|->
name|next_token
operator|=
name|VEC_pop
argument_list|(
name|cp_token_position
argument_list|,
name|lexer
operator|->
name|saved_tokens
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a representation of the TOKEN on the STREAM.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_function
specifier|static
name|void
name|cp_lexer_print_token
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
comment|/* We don't use cpp_type2name here because the parser defines      a few tokens of its own.  */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|token_names
index|[]
init|=
block|{
comment|/* cpplib-defined token types */
define|#
directive|define
name|OP
parameter_list|(
name|e
parameter_list|,
name|s
parameter_list|)
value|#e,
define|#
directive|define
name|TK
parameter_list|(
name|e
parameter_list|,
name|s
parameter_list|)
value|#e,
name|TTYPE_TABLE
undef|#
directive|undef
name|OP
undef|#
directive|undef
name|TK
comment|/* C++ parser token types - see "Manifest constants", above.  */
literal|"KEYWORD"
block|,
literal|"TEMPLATE_ID"
block|,
literal|"NESTED_NAME_SPECIFIER"
block|,
literal|"PURGED"
block|}
decl_stmt|;
comment|/* If we have a name for the token, print it out.  Otherwise, we      simply give the numeric code.  */
name|gcc_assert
argument_list|(
name|token
operator|->
name|type
operator|<
name|ARRAY_SIZE
argument_list|(
name|token_names
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|token_names
index|[
name|token
operator|->
name|type
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* For some tokens, print the associated data.  */
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_KEYWORD
case|:
comment|/* Some keywords have a value that is not an IDENTIFIER_NODE. 	 For example, `struct' is mapped to an INTEGER_CST.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|token
operator|->
name|u
operator|.
name|value
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
break|break;
comment|/* else fall through */
case|case
name|CPP_NAME
case|:
name|fputs
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|token
operator|->
name|u
operator|.
name|value
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_STRING
case|:
case|case
name|CPP_WSTRING
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" \"%s\""
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|token
operator|->
name|u
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Start emitting debugging information.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_start_debugging
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
name|lexer
operator|->
name|debugging_p
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop emitting debugging information.  */
end_comment

begin_function
specifier|static
name|void
name|cp_lexer_stop_debugging
parameter_list|(
name|cp_lexer
modifier|*
name|lexer
parameter_list|)
block|{
name|lexer
operator|->
name|debugging_p
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_CHECKING */
end_comment

begin_comment
comment|/* Create a new cp_token_cache, representing a range of tokens.  */
end_comment

begin_function
specifier|static
name|cp_token_cache
modifier|*
name|cp_token_cache_new
parameter_list|(
name|cp_token
modifier|*
name|first
parameter_list|,
name|cp_token
modifier|*
name|last
parameter_list|)
block|{
name|cp_token_cache
modifier|*
name|cache
init|=
name|GGC_NEW
argument_list|(
name|cp_token_cache
argument_list|)
decl_stmt|;
name|cache
operator|->
name|first
operator|=
name|first
expr_stmt|;
name|cache
operator|->
name|last
operator|=
name|last
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decl-specifiers.  */
end_comment

begin_comment
comment|/* Set *DECL_SPECS to represent an empty decl-specifier-seq.  */
end_comment

begin_function
specifier|static
name|void
name|clear_decl_specs
parameter_list|(
name|cp_decl_specifier_seq
modifier|*
name|decl_specs
parameter_list|)
block|{
name|memset
argument_list|(
name|decl_specs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cp_decl_specifier_seq
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Declarators.  */
end_comment

begin_comment
comment|/* Nothing other than the parser should be creating declarators;    declarators are a semi-syntactic representation of C++ entities.    Other parts of the front end that need to create entities (like    VAR_DECLs or FUNCTION_DECLs) should do that directly.  */
end_comment

begin_function_decl
specifier|static
name|cp_declarator
modifier|*
name|make_call_declarator
parameter_list|(
name|cp_declarator
modifier|*
parameter_list|,
name|cp_parameter_declarator
modifier|*
parameter_list|,
name|cp_cv_quals
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_declarator
modifier|*
name|make_array_declarator
parameter_list|(
name|cp_declarator
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_declarator
modifier|*
name|make_pointer_declarator
parameter_list|(
name|cp_cv_quals
parameter_list|,
name|cp_declarator
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_declarator
modifier|*
name|make_reference_declarator
parameter_list|(
name|cp_cv_quals
parameter_list|,
name|cp_declarator
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_parameter_declarator
modifier|*
name|make_parameter_declarator
parameter_list|(
name|cp_decl_specifier_seq
modifier|*
parameter_list|,
name|cp_declarator
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_declarator
modifier|*
name|make_ptrmem_declarator
parameter_list|(
name|cp_cv_quals
parameter_list|,
name|tree
parameter_list|,
name|cp_declarator
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* An erroneous declarator.  */
end_comment

begin_decl_stmt
specifier|static
name|cp_declarator
modifier|*
name|cp_error_declarator
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The obstack on which declarators and related data structures are    allocated.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|declarator_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alloc BYTES from the declarator memory pool.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|alloc_declarator
parameter_list|(
name|size_t
name|bytes
parameter_list|)
block|{
return|return
name|obstack_alloc
argument_list|(
operator|&
name|declarator_obstack
argument_list|,
name|bytes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate a declarator of the indicated KIND.  Clear fields that are    common to all declarators.  */
end_comment

begin_function
specifier|static
name|cp_declarator
modifier|*
name|make_declarator
parameter_list|(
name|cp_declarator_kind
name|kind
parameter_list|)
block|{
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
name|declarator
operator|=
operator|(
name|cp_declarator
operator|*
operator|)
name|alloc_declarator
argument_list|(
sizeof|sizeof
argument_list|(
name|cp_declarator
argument_list|)
argument_list|)
expr_stmt|;
name|declarator
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|declarator
operator|->
name|attributes
operator|=
name|NULL_TREE
expr_stmt|;
name|declarator
operator|->
name|declarator
operator|=
name|NULL
expr_stmt|;
return|return
name|declarator
return|;
block|}
end_function

begin_comment
comment|/* Make a declarator for a generalized identifier.  If    QUALIFYING_SCOPE is non-NULL, the identifier is    QUALIFYING_SCOPE::UNQUALIFIED_NAME; otherwise, it is just    UNQUALIFIED_NAME.  SFK indicates the kind of special function this    is, if any.   */
end_comment

begin_function
specifier|static
name|cp_declarator
modifier|*
name|make_id_declarator
parameter_list|(
name|tree
name|qualifying_scope
parameter_list|,
name|tree
name|unqualified_name
parameter_list|,
name|special_function_kind
name|sfk
parameter_list|)
block|{
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
comment|/* It is valid to write:         class C { void f(); };        typedef C D;        void D::f();       The standard is not clear about whether `typedef const C D' is      legal; as of 2002-09-15 the committee is considering that      question.  EDG 3.0 allows that syntax.  Therefore, we do as      well.  */
if|if
condition|(
name|qualifying_scope
operator|&&
name|TYPE_P
argument_list|(
name|qualifying_scope
argument_list|)
condition|)
name|qualifying_scope
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|qualifying_scope
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|unqualified_name
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|unqualified_name
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|unqualified_name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|make_declarator
argument_list|(
name|cdk_id
argument_list|)
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|id
operator|.
name|qualifying_scope
operator|=
name|qualifying_scope
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|id
operator|.
name|unqualified_name
operator|=
name|unqualified_name
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|id
operator|.
name|sfk
operator|=
name|sfk
expr_stmt|;
return|return
name|declarator
return|;
block|}
end_function

begin_comment
comment|/* Make a declarator for a pointer to TARGET.  CV_QUALIFIERS is a list    of modifiers such as const or volatile to apply to the pointer    type, represented as identifiers.  */
end_comment

begin_function
name|cp_declarator
modifier|*
name|make_pointer_declarator
parameter_list|(
name|cp_cv_quals
name|cv_qualifiers
parameter_list|,
name|cp_declarator
modifier|*
name|target
parameter_list|)
block|{
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
name|declarator
operator|=
name|make_declarator
argument_list|(
name|cdk_pointer
argument_list|)
expr_stmt|;
name|declarator
operator|->
name|declarator
operator|=
name|target
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|pointer
operator|.
name|qualifiers
operator|=
name|cv_qualifiers
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|pointer
operator|.
name|class_type
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|declarator
return|;
block|}
end_function

begin_comment
comment|/* Like make_pointer_declarator -- but for references.  */
end_comment

begin_function
name|cp_declarator
modifier|*
name|make_reference_declarator
parameter_list|(
name|cp_cv_quals
name|cv_qualifiers
parameter_list|,
name|cp_declarator
modifier|*
name|target
parameter_list|)
block|{
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
name|declarator
operator|=
name|make_declarator
argument_list|(
name|cdk_reference
argument_list|)
expr_stmt|;
name|declarator
operator|->
name|declarator
operator|=
name|target
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|pointer
operator|.
name|qualifiers
operator|=
name|cv_qualifiers
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|pointer
operator|.
name|class_type
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|declarator
return|;
block|}
end_function

begin_comment
comment|/* Like make_pointer_declarator -- but for a pointer to a non-static    member of CLASS_TYPE.  */
end_comment

begin_function
name|cp_declarator
modifier|*
name|make_ptrmem_declarator
parameter_list|(
name|cp_cv_quals
name|cv_qualifiers
parameter_list|,
name|tree
name|class_type
parameter_list|,
name|cp_declarator
modifier|*
name|pointee
parameter_list|)
block|{
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
name|declarator
operator|=
name|make_declarator
argument_list|(
name|cdk_ptrmem
argument_list|)
expr_stmt|;
name|declarator
operator|->
name|declarator
operator|=
name|pointee
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|pointer
operator|.
name|qualifiers
operator|=
name|cv_qualifiers
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|pointer
operator|.
name|class_type
operator|=
name|class_type
expr_stmt|;
return|return
name|declarator
return|;
block|}
end_function

begin_comment
comment|/* Make a declarator for the function given by TARGET, with the    indicated PARMS.  The CV_QUALIFIERS aply to the function, as in    "const"-qualified member function.  The EXCEPTION_SPECIFICATION    indicates what exceptions can be thrown.  */
end_comment

begin_function
name|cp_declarator
modifier|*
name|make_call_declarator
parameter_list|(
name|cp_declarator
modifier|*
name|target
parameter_list|,
name|cp_parameter_declarator
modifier|*
name|parms
parameter_list|,
name|cp_cv_quals
name|cv_qualifiers
parameter_list|,
name|tree
name|exception_specification
parameter_list|)
block|{
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
name|declarator
operator|=
name|make_declarator
argument_list|(
name|cdk_function
argument_list|)
expr_stmt|;
name|declarator
operator|->
name|declarator
operator|=
name|target
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|function
operator|.
name|parameters
operator|=
name|parms
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|function
operator|.
name|qualifiers
operator|=
name|cv_qualifiers
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|function
operator|.
name|exception_specification
operator|=
name|exception_specification
expr_stmt|;
return|return
name|declarator
return|;
block|}
end_function

begin_comment
comment|/* Make a declarator for an array of BOUNDS elements, each of which is    defined by ELEMENT.  */
end_comment

begin_function
name|cp_declarator
modifier|*
name|make_array_declarator
parameter_list|(
name|cp_declarator
modifier|*
name|element
parameter_list|,
name|tree
name|bounds
parameter_list|)
block|{
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
name|declarator
operator|=
name|make_declarator
argument_list|(
name|cdk_array
argument_list|)
expr_stmt|;
name|declarator
operator|->
name|declarator
operator|=
name|element
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|bounds
operator|=
name|bounds
expr_stmt|;
return|return
name|declarator
return|;
block|}
end_function

begin_decl_stmt
name|cp_parameter_declarator
modifier|*
name|no_parameters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a parameter declarator with the indicated DECL_SPECIFIERS,    DECLARATOR and DEFAULT_ARGUMENT.  */
end_comment

begin_function
name|cp_parameter_declarator
modifier|*
name|make_parameter_declarator
parameter_list|(
name|cp_decl_specifier_seq
modifier|*
name|decl_specifiers
parameter_list|,
name|cp_declarator
modifier|*
name|declarator
parameter_list|,
name|tree
name|default_argument
parameter_list|)
block|{
name|cp_parameter_declarator
modifier|*
name|parameter
decl_stmt|;
name|parameter
operator|=
operator|(
operator|(
name|cp_parameter_declarator
operator|*
operator|)
name|alloc_declarator
argument_list|(
sizeof|sizeof
argument_list|(
name|cp_parameter_declarator
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|parameter
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|decl_specifiers
condition|)
name|parameter
operator|->
name|decl_specifiers
operator|=
operator|*
name|decl_specifiers
expr_stmt|;
else|else
name|clear_decl_specs
argument_list|(
operator|&
name|parameter
operator|->
name|decl_specifiers
argument_list|)
expr_stmt|;
name|parameter
operator|->
name|declarator
operator|=
name|declarator
expr_stmt|;
name|parameter
operator|->
name|default_argument
operator|=
name|default_argument
expr_stmt|;
name|parameter
operator|->
name|ellipsis_p
operator|=
name|false
expr_stmt|;
return|return
name|parameter
return|;
block|}
end_function

begin_comment
comment|/* Returns true iff DECLARATOR  is a declaration for a function.  */
end_comment

begin_function
specifier|static
name|bool
name|function_declarator_p
parameter_list|(
specifier|const
name|cp_declarator
modifier|*
name|declarator
parameter_list|)
block|{
while|while
condition|(
name|declarator
condition|)
block|{
if|if
condition|(
name|declarator
operator|->
name|kind
operator|==
name|cdk_function
operator|&&
name|declarator
operator|->
name|declarator
operator|->
name|kind
operator|==
name|cdk_id
condition|)
return|return
name|true
return|;
if|if
condition|(
name|declarator
operator|->
name|kind
operator|==
name|cdk_id
operator|||
name|declarator
operator|->
name|kind
operator|==
name|cdk_error
condition|)
return|return
name|false
return|;
name|declarator
operator|=
name|declarator
operator|->
name|declarator
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* The parser.  */
end_comment

begin_comment
comment|/* Overview    --------     A cp_parser parses the token stream as specified by the C++    grammar.  Its job is purely parsing, not semantic analysis.  For    example, the parser breaks the token stream into declarators,    expressions, statements, and other similar syntactic constructs.    It does not check that the types of the expressions on either side    of an assignment-statement are compatible, or that a function is    not declared with a parameter of type `void'.     The parser invokes routines elsewhere in the compiler to perform    semantic analysis and to build up the abstract syntax tree for the    code processed.     The parser (and the template instantiation code, which is, in a    way, a close relative of parsing) are the only parts of the    compiler that should be calling push_scope and pop_scope, or    related functions.  The parser (and template instantiation code)    keeps track of what scope is presently active; everything else    should simply honor that.  (The code that generates static    initializers may also need to set the scope, in order to check    access control correctly when emitting the initializers.)     Methodology    -----------     The parser is of the standard recursive-descent variety.  Upcoming    tokens in the token stream are examined in order to determine which    production to use when parsing a non-terminal.  Some C++ constructs    require arbitrary look ahead to disambiguate.  For example, it is    impossible, in the general case, to tell whether a statement is an    expression or declaration without scanning the entire statement.    Therefore, the parser is capable of "parsing tentatively."  When the    parser is not sure what construct comes next, it enters this mode.    Then, while we attempt to parse the construct, the parser queues up    error messages, rather than issuing them immediately, and saves the    tokens it consumes.  If the construct is parsed successfully, the    parser "commits", i.e., it issues any queued error messages and    the tokens that were being preserved are permanently discarded.    If, however, the construct is not parsed successfully, the parser    rolls back its state completely so that it can resume parsing using    a different alternative.     Future Improvements    -------------------     The performance of the parser could probably be improved substantially.    We could often eliminate the need to parse tentatively by looking ahead    a little bit.  In some places, this approach might not entirely eliminate    the need to parse tentatively, but it might still speed up the average    case.  */
end_comment

begin_comment
comment|/* Flags that are passed to some parsing functions.  These values can    be bitwise-ored together.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|cp_parser_flags
block|{
comment|/* No flags.  */
name|CP_PARSER_FLAGS_NONE
init|=
literal|0x0
block|,
comment|/* The construct is optional.  If it is not present, then no error      should be issued.  */
name|CP_PARSER_FLAGS_OPTIONAL
init|=
literal|0x1
block|,
comment|/* When parsing a type-specifier, do not allow user-defined types.  */
name|CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES
init|=
literal|0x2
block|}
name|cp_parser_flags
typedef|;
end_typedef

begin_comment
comment|/* The different kinds of declarators we want to parse.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|cp_parser_declarator_kind
block|{
comment|/* We want an abstract declarator.  */
name|CP_PARSER_DECLARATOR_ABSTRACT
block|,
comment|/* We want a named declarator.  */
name|CP_PARSER_DECLARATOR_NAMED
block|,
comment|/* We don't mind, but the name must be an unqualified-id.  */
name|CP_PARSER_DECLARATOR_EITHER
block|}
name|cp_parser_declarator_kind
typedef|;
end_typedef

begin_comment
comment|/* The precedence values used to parse binary expressions.  The minimum value    of PREC must be 1, because zero is reserved to quickly discriminate    binary operators from other tokens.  */
end_comment

begin_enum
enum|enum
name|cp_parser_prec
block|{
name|PREC_NOT_OPERATOR
block|,
name|PREC_LOGICAL_OR_EXPRESSION
block|,
name|PREC_LOGICAL_AND_EXPRESSION
block|,
name|PREC_INCLUSIVE_OR_EXPRESSION
block|,
name|PREC_EXCLUSIVE_OR_EXPRESSION
block|,
name|PREC_AND_EXPRESSION
block|,
name|PREC_EQUALITY_EXPRESSION
block|,
name|PREC_RELATIONAL_EXPRESSION
block|,
name|PREC_SHIFT_EXPRESSION
block|,
name|PREC_ADDITIVE_EXPRESSION
block|,
name|PREC_MULTIPLICATIVE_EXPRESSION
block|,
name|PREC_PM_EXPRESSION
block|,
name|NUM_PREC_VALUES
init|=
name|PREC_PM_EXPRESSION
block|}
enum|;
end_enum

begin_comment
comment|/* A mapping from a token type to a corresponding tree node type, with a    precedence value.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cp_parser_binary_operations_map_node
block|{
comment|/* The token type.  */
name|enum
name|cpp_ttype
name|token_type
decl_stmt|;
comment|/* The corresponding tree code.  */
name|enum
name|tree_code
name|tree_type
decl_stmt|;
comment|/* The precedence of this operator.  */
name|enum
name|cp_parser_prec
name|prec
decl_stmt|;
block|}
name|cp_parser_binary_operations_map_node
typedef|;
end_typedef

begin_comment
comment|/* The status of a tentative parse.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|cp_parser_status_kind
block|{
comment|/* No errors have occurred.  */
name|CP_PARSER_STATUS_KIND_NO_ERROR
block|,
comment|/* An error has occurred.  */
name|CP_PARSER_STATUS_KIND_ERROR
block|,
comment|/* We are committed to this tentative parse, whether or not an error      has occurred.  */
name|CP_PARSER_STATUS_KIND_COMMITTED
block|}
name|cp_parser_status_kind
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|cp_parser_expression_stack_entry
block|{
comment|/* Left hand side of the binary operation we are currently      parsing.  */
name|tree
name|lhs
decl_stmt|;
comment|/* Original tree code for left hand side, if it was a binary      expression itself (used for -Wparentheses).  */
name|enum
name|tree_code
name|lhs_type
decl_stmt|;
comment|/* Tree code for the binary operation we are parsing.  */
name|enum
name|tree_code
name|tree_type
decl_stmt|;
comment|/* Precedence of the binary operation we are parsing.  */
name|int
name|prec
decl_stmt|;
block|}
name|cp_parser_expression_stack_entry
typedef|;
end_typedef

begin_comment
comment|/* The stack for storing partial expressions.  We only need NUM_PREC_VALUES    entries because precedence levels on the stack are monotonically    increasing.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cp_parser_expression_stack_entry
name|cp_parser_expression_stack
index|[
name|NUM_PREC_VALUES
index|]
typedef|;
end_typedef

begin_comment
comment|/* Context that is saved and restored when parsing tentatively.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cp_parser_context
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* If this is a tentative parsing context, the status of the      tentative parse.  */
name|enum
name|cp_parser_status_kind
name|status
block|;
comment|/* If non-NULL, we have just seen a `x->' or `x.' expression.  Names      that are looked up in this context must be looked up both in the      scope given by OBJECT_TYPE (the type of `x' or `*x') and also in      the context of the containing expression.  */
name|tree
name|object_type
block|;
comment|/* The next parsing context in the stack.  */
name|struct
name|cp_parser_context
modifier|*
name|next
block|; }
end_typedef

begin_expr_stmt
name|cp_parser_context
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Prototypes.  */
end_comment

begin_comment
comment|/* Constructors and destructors.  */
end_comment

begin_function_decl
specifier|static
name|cp_parser_context
modifier|*
name|cp_parser_context_new
parameter_list|(
name|cp_parser_context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Class variables.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable)
argument_list|)
name|cp_parser_context
operator|*
name|cp_parser_context_free_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The operator-precedence table used by cp_parser_binary_expression.    Transformed into an associative array (binops_by_token) by    cp_parser_new.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|cp_parser_binary_operations_map_node
name|binops
index|[]
init|=
block|{
block|{
name|CPP_DEREF_STAR
block|,
name|MEMBER_REF
block|,
name|PREC_PM_EXPRESSION
block|}
block|,
block|{
name|CPP_DOT_STAR
block|,
name|DOTSTAR_EXPR
block|,
name|PREC_PM_EXPRESSION
block|}
block|,
block|{
name|CPP_MULT
block|,
name|MULT_EXPR
block|,
name|PREC_MULTIPLICATIVE_EXPRESSION
block|}
block|,
block|{
name|CPP_DIV
block|,
name|TRUNC_DIV_EXPR
block|,
name|PREC_MULTIPLICATIVE_EXPRESSION
block|}
block|,
block|{
name|CPP_MOD
block|,
name|TRUNC_MOD_EXPR
block|,
name|PREC_MULTIPLICATIVE_EXPRESSION
block|}
block|,
block|{
name|CPP_PLUS
block|,
name|PLUS_EXPR
block|,
name|PREC_ADDITIVE_EXPRESSION
block|}
block|,
block|{
name|CPP_MINUS
block|,
name|MINUS_EXPR
block|,
name|PREC_ADDITIVE_EXPRESSION
block|}
block|,
block|{
name|CPP_LSHIFT
block|,
name|LSHIFT_EXPR
block|,
name|PREC_SHIFT_EXPRESSION
block|}
block|,
block|{
name|CPP_RSHIFT
block|,
name|RSHIFT_EXPR
block|,
name|PREC_SHIFT_EXPRESSION
block|}
block|,
block|{
name|CPP_LESS
block|,
name|LT_EXPR
block|,
name|PREC_RELATIONAL_EXPRESSION
block|}
block|,
block|{
name|CPP_GREATER
block|,
name|GT_EXPR
block|,
name|PREC_RELATIONAL_EXPRESSION
block|}
block|,
block|{
name|CPP_LESS_EQ
block|,
name|LE_EXPR
block|,
name|PREC_RELATIONAL_EXPRESSION
block|}
block|,
block|{
name|CPP_GREATER_EQ
block|,
name|GE_EXPR
block|,
name|PREC_RELATIONAL_EXPRESSION
block|}
block|,
block|{
name|CPP_EQ_EQ
block|,
name|EQ_EXPR
block|,
name|PREC_EQUALITY_EXPRESSION
block|}
block|,
block|{
name|CPP_NOT_EQ
block|,
name|NE_EXPR
block|,
name|PREC_EQUALITY_EXPRESSION
block|}
block|,
block|{
name|CPP_AND
block|,
name|BIT_AND_EXPR
block|,
name|PREC_AND_EXPRESSION
block|}
block|,
block|{
name|CPP_XOR
block|,
name|BIT_XOR_EXPR
block|,
name|PREC_EXCLUSIVE_OR_EXPRESSION
block|}
block|,
block|{
name|CPP_OR
block|,
name|BIT_IOR_EXPR
block|,
name|PREC_INCLUSIVE_OR_EXPRESSION
block|}
block|,
block|{
name|CPP_AND_AND
block|,
name|TRUTH_ANDIF_EXPR
block|,
name|PREC_LOGICAL_AND_EXPRESSION
block|}
block|,
block|{
name|CPP_OR_OR
block|,
name|TRUTH_ORIF_EXPR
block|,
name|PREC_LOGICAL_OR_EXPRESSION
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The same as binops, but initialized by cp_parser_new so that    binops_by_token[N].token_type == N.  Used in cp_parser_binary_expression    for speed.  */
end_comment

begin_decl_stmt
specifier|static
name|cp_parser_binary_operations_map_node
name|binops_by_token
index|[
name|N_CP_TTYPES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Constructors and destructors.  */
end_comment

begin_comment
comment|/* Construct a new context.  The context below this one on the stack    is given by NEXT.  */
end_comment

begin_function
specifier|static
name|cp_parser_context
modifier|*
name|cp_parser_context_new
parameter_list|(
name|cp_parser_context
modifier|*
name|next
parameter_list|)
block|{
name|cp_parser_context
modifier|*
name|context
decl_stmt|;
comment|/* Allocate the storage.  */
if|if
condition|(
name|cp_parser_context_free_list
operator|!=
name|NULL
condition|)
block|{
comment|/* Pull the first entry from the free list.  */
name|context
operator|=
name|cp_parser_context_free_list
expr_stmt|;
name|cp_parser_context_free_list
operator|=
name|context
operator|->
name|next
expr_stmt|;
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|context
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|context
operator|=
name|GGC_CNEW
argument_list|(
name|cp_parser_context
argument_list|)
expr_stmt|;
comment|/* No errors have occurred yet in this context.  */
name|context
operator|->
name|status
operator|=
name|CP_PARSER_STATUS_KIND_NO_ERROR
expr_stmt|;
comment|/* If this is not the bottomost context, copy information that we      need from the previous context.  */
if|if
condition|(
name|next
condition|)
block|{
comment|/* If, in the NEXT context, we are parsing an `x->' or `x.' 	 expression, then we are parsing one in this context, too.  */
name|context
operator|->
name|object_type
operator|=
name|next
operator|->
name|object_type
expr_stmt|;
comment|/* Thread the stack.  */
name|context
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|}
return|return
name|context
return|;
block|}
end_function

begin_comment
comment|/* The cp_parser structure represents the C++ parser.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cp_parser
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The lexer from which we are obtaining tokens.  */
name|cp_lexer
modifier|*
name|lexer
block|;
comment|/* The scope in which names should be looked up.  If NULL_TREE, then      we look up names in the scope that is currently open in the      source program.  If non-NULL, this is either a TYPE or      NAMESPACE_DECL for the scope in which we should look.  It can      also be ERROR_MARK, when we've parsed a bogus scope.       This value is not cleared automatically after a name is looked      up, so we must be careful to clear it before starting a new look      up sequence.  (If it is not cleared, then `X::Y' followed by `Z'      will look up `Z' in the scope of `X', rather than the current      scope.)  Unfortunately, it is difficult to tell when name lookup      is complete, because we sometimes peek at a token, look it up,      and then decide not to consume it.   */
name|tree
name|scope
block|;
comment|/* OBJECT_SCOPE and QUALIFYING_SCOPE give the scopes in which the      last lookup took place.  OBJECT_SCOPE is used if an expression      like "x->y" or "x.y" was used; it gives the type of "*x" or "x",      respectively.  QUALIFYING_SCOPE is used for an expression of the      form "X::Y"; it refers to X.  */
name|tree
name|object_scope
block|;
name|tree
name|qualifying_scope
block|;
comment|/* A stack of parsing contexts.  All but the bottom entry on the      stack will be tentative contexts.       We parse tentatively in order to determine which construct is in      use in some situations.  For example, in order to determine      whether a statement is an expression-statement or a      declaration-statement we parse it tentatively as a      declaration-statement.  If that fails, we then reparse the same      token stream as an expression-statement.  */
name|cp_parser_context
modifier|*
name|context
block|;
comment|/* True if we are parsing GNU C++.  If this flag is not set, then      GNU extensions are not recognized.  */
name|bool
name|allow_gnu_extensions_p
block|;
comment|/* TRUE if the `>' token should be interpreted as the greater-than      operator.  FALSE if it is the end of a template-id or      template-parameter-list.  */
name|bool
name|greater_than_is_operator_p
block|;
comment|/* TRUE if default arguments are allowed within a parameter list      that starts at this point. FALSE if only a gnu extension makes      them permissible.  */
name|bool
name|default_arg_ok_p
block|;
comment|/* TRUE if we are parsing an integral constant-expression.  See      [expr.const] for a precise definition.  */
name|bool
name|integral_constant_expression_p
block|;
comment|/* TRUE if we are parsing an integral constant-expression -- but a      non-constant expression should be permitted as well.  This flag      is used when parsing an array bound so that GNU variable-length      arrays are tolerated.  */
name|bool
name|allow_non_integral_constant_expression_p
block|;
comment|/* TRUE if ALLOW_NON_CONSTANT_EXPRESSION_P is TRUE and something has      been seen that makes the expression non-constant.  */
name|bool
name|non_integral_constant_expression_p
block|;
comment|/* TRUE if local variable names and `this' are forbidden in the      current context.  */
name|bool
name|local_variables_forbidden_p
block|;
comment|/* TRUE if the declaration we are parsing is part of a      linkage-specification of the form `extern string-literal      declaration'.  */
name|bool
name|in_unbraced_linkage_specification_p
block|;
comment|/* TRUE if we are presently parsing a declarator, after the      direct-declarator.  */
name|bool
name|in_declarator_p
block|;
comment|/* TRUE if we are presently parsing a template-argument-list.  */
name|bool
name|in_template_argument_list_p
block|;
comment|/* Set to IN_ITERATION_STMT if parsing an iteration-statement,      to IN_OMP_BLOCK if parsing OpenMP structured block and      IN_OMP_FOR if parsing OpenMP loop.  If parsing a switch statement,      this is bitwise ORed with IN_SWITCH_STMT, unless parsing an      iteration-statement, OpenMP block or loop within that switch.  */
define|#
directive|define
name|IN_SWITCH_STMT
value|1
define|#
directive|define
name|IN_ITERATION_STMT
value|2
define|#
directive|define
name|IN_OMP_BLOCK
value|4
define|#
directive|define
name|IN_OMP_FOR
value|8
name|unsigned
name|char
name|in_statement
block|;
comment|/* TRUE if we are presently parsing the body of a switch statement.      Note that this doesn't quite overlap with in_statement above.      The difference relates to giving the right sets of error messages:      "case not in switch" vs "break statement used with OpenMP...".  */
name|bool
name|in_switch_statement_p
block|;
comment|/* TRUE if we are parsing a type-id in an expression context.  In      such a situation, both "type (expr)" and "type (type)" are valid      alternatives.  */
name|bool
name|in_type_id_in_expr_p
block|;
comment|/* TRUE if we are currently in a header file where declarations are      implicitly extern "C".  */
name|bool
name|implicit_extern_c
block|;
comment|/* TRUE if strings in expressions should be translated to the execution      character set.  */
name|bool
name|translate_strings_p
block|;
comment|/* TRUE if we are presently parsing the body of a function, but not      a local class.  */
name|bool
name|in_function_body
block|;
comment|/* If non-NULL, then we are parsing a construct where new type      definitions are not permitted.  The string stored here will be      issued as an error message if a type is defined.  */
specifier|const
name|char
modifier|*
name|type_definition_forbidden_message
block|;
comment|/* A list of lists. The outer list is a stack, used for member      functions of local classes. At each level there are two sub-list,      one on TREE_VALUE and one on TREE_PURPOSE. Each of those      sub-lists has a FUNCTION_DECL or TEMPLATE_DECL on their      TREE_VALUE's. The functions are chained in reverse declaration      order.       The TREE_PURPOSE sublist contains those functions with default      arguments that need post processing, and the TREE_VALUE sublist      contains those functions with definitions that need post      processing.       These lists can only be processed once the outermost class being      defined is complete.  */
name|tree
name|unparsed_functions_queues
block|;
comment|/* The number of classes whose definitions are currently in      progress.  */
name|unsigned
name|num_classes_being_defined
block|;
comment|/* The number of template parameter lists that apply directly to the      current declaration.  */
name|unsigned
name|num_template_parameter_lists
block|; }
end_typedef

begin_expr_stmt
name|cp_parser
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Prototypes.  */
end_comment

begin_comment
comment|/* Constructors and destructors.  */
end_comment

begin_function_decl
specifier|static
name|cp_parser
modifier|*
name|cp_parser_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Routines to parse various constructs.     Those that return `tree' will return the error_mark_node (rather    than NULL_TREE) if a parse error occurs, unless otherwise noted.    Sometimes, they will return an ordinary node if error-recovery was    attempted, even though a parse error occurred.  So, to check    whether or not a parse error occurred, you should always use    cp_parser_error_occurred.  If the construct is optional (indicated    either by an `_opt' in the name of the function that does the    parsing or via a FLAGS parameter), then NULL_TREE is returned if    the construct is not present.  */
end_comment

begin_comment
comment|/* Lexical conventions [gram.lex]  */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_identifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_string_literal
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Basic concepts [gram.basic]  */
end_comment

begin_function_decl
specifier|static
name|bool
name|cp_parser_translation_unit
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Expressions [gram.expr]  */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_primary_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|cp_id_kind
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_id_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_unqualified_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_nested_name_specifier_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_nested_name_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_class_or_namespace_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_postfix_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_postfix_open_square_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_postfix_dot_deref_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|enum
name|cpp_ttype
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|,
name|cp_id_kind
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_parenthesized_expression_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_pseudo_destructor_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_unary_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tree_code
name|cp_parser_unary_operator
parameter_list|(
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_new_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_new_placement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_new_type_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_declarator
modifier|*
name|cp_parser_new_declarator_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_declarator
modifier|*
name|cp_parser_direct_new_declarator
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_new_initializer
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_delete_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_cast_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_binary_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_question_colon_clause
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_assignment_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tree_code
name|cp_parser_assignment_operator_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_constant_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_builtin_offsetof
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Statements [gram.stmt.stmt]  */
end_comment

begin_function_decl
specifier|static
name|void
name|cp_parser_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_label_for_labeled_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_expression_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_compound_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_statement_seq_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_selection_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_condition
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_iteration_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_for_init_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_jump_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_declaration_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_implicitly_scoped_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_already_scoped_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Declarations [gram.dcl.dcl] */
end_comment

begin_function_decl
specifier|static
name|void
name|cp_parser_declaration_seq_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_block_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_simple_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_decl_specifier_seq
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_parser_flags
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_storage_class_specifier_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_function_specifier_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_type_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_parser_flags
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|int
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_simple_type_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
parameter_list|,
name|cp_parser_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_type_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_elaborated_type_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_enum_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_enumerator_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_enumerator_definition
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_namespace_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_namespace_definition
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_namespace_body
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_qualified_namespace_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_namespace_alias_definition
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_using_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_using_directive
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_asm_definition
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_linkage_specification
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Declarators [gram.dcl.decl] */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|cp_parser_init_declarator
argument_list|(
name|cp_parser
operator|*
argument_list|,
name|cp_decl_specifier_seq
operator|*
argument_list|,
name|VEC
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|)
operator|*
argument_list|,
name|bool
argument_list|,
name|bool
argument_list|,
name|int
argument_list|,
name|bool
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|cp_declarator
modifier|*
name|cp_parser_declarator
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_parser_declarator_kind
parameter_list|,
name|int
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_declarator
modifier|*
name|cp_parser_direct_declarator
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_parser_declarator_kind
parameter_list|,
name|int
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tree_code
name|cp_parser_ptr_operator
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|cp_cv_quals
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_cv_quals
name|cp_parser_cv_qualifier_seq_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_declarator_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_type_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_type_specifier_seq
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_parameter_declarator
modifier|*
name|cp_parser_parameter_declaration_clause
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_parameter_declarator
modifier|*
name|cp_parser_parameter_declaration_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_parameter_declarator
modifier|*
name|cp_parser_parameter_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_function_body
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_initializer
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_initializer_clause
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|cp_parser_initializer_list
argument_list|(
name|cp_parser
operator|*
argument_list|,
name|bool
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|bool
name|cp_parser_ctor_initializer_opt_and_function_body
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Classes [gram.class] */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_class_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|enum
name|tag_types
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_class_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_class_head
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tag_types
name|cp_parser_class_key
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_member_specification_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_member_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_pure_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_constant_initializer
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Derived classes [gram.class.derived] */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_base_clause
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_base_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Special member functions [gram.special] */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_conversion_function_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_conversion_type_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_declarator
modifier|*
name|cp_parser_conversion_declarator_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_ctor_initializer_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_mem_initializer_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_mem_initializer
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_mem_initializer_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Overloading [gram.over] */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_operator_function_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_operator
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Templates [gram.temp] */
end_comment

begin_function_decl
specifier|static
name|void
name|cp_parser_template_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_template_parameter_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_template_parameter
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_type_parameter
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_template_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_template_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_template_argument_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_template_argument
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_explicit_instantiation
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_explicit_specialization
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Exception handling [gram.exception] */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_try_block
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_function_try_block
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_handler_seq
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_handler
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_exception_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_throw_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_exception_specification_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_type_id_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* GNU Extensions */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_asm_specification_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_asm_operand_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_asm_clobber_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_attributes_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_attribute_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_extension_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_label_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_enum
enum|enum
name|pragma_context
block|{
name|pragma_external
block|,
name|pragma_stmt
block|,
name|pragma_compound
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|bool
name|cp_parser_pragma
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|enum
name|pragma_context
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Objective-C++ Productions */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_objc_message_receiver
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_objc_message_args
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_objc_message_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_objc_encode_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_objc_defs_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_objc_protocol_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_objc_selector_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_objc_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_objc_selector_p
parameter_list|(
name|enum
name|cpp_ttype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_objc_selector
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_objc_protocol_refs_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_objc_declaration
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_objc_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Utility Routines */
end_comment

begin_function_decl
specifier|static
name|tree
name|cp_parser_lookup_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|enum
name|tag_types
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_lookup_name_simple
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_maybe_treat_template_as_class
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_check_declarator_template_parameters
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_declarator
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_check_template_parameters
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_simple_cast_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_global_scope_opt
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_constructor_declarator_p
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_function_definition_from_specifiers_and_declarator
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
parameter_list|,
name|tree
parameter_list|,
specifier|const
name|cp_declarator
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_function_definition_after_declarator
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_template_declaration_after_export
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|cp_parser_perform_template_parameter_access_checks
argument_list|(
name|VEC
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|)
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|cp_parser_single_declaration
argument_list|(
name|cp_parser
operator|*
argument_list|,
name|VEC
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|)
operator|*
argument_list|,
name|bool
argument_list|,
name|bool
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|tree
name|cp_parser_functional_cast
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_save_member_function_body
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
parameter_list|,
name|cp_declarator
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_enclosed_template_argument_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_save_default_args
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_late_parsing_for_member
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_late_parsing_default_args
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_sizeof_operand
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|enum
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_declares_only_class_p
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_set_storage_class
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
parameter_list|,
name|enum
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_set_decl_spec_type
parameter_list|(
name|cp_decl_specifier_seq
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_friend_p
parameter_list|(
specifier|const
name|cp_decl_specifier_seq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_token
modifier|*
name|cp_parser_require
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|enum
name|cpp_ttype
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cp_token
modifier|*
name|cp_parser_require_keyword
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|enum
name|rid
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_token_starts_function_definition_p
parameter_list|(
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_next_token_starts_class_definition_p
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_next_token_ends_template_argument_p
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_nth_token_starts_template_argument_list_p
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tag_types
name|cp_parser_token_is_class_key
parameter_list|(
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_check_class_key
parameter_list|(
name|enum
name|tag_types
parameter_list|,
name|tree
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_check_access_in_redeclaration
parameter_list|(
name|tree
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_optional_template_keyword
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_pre_parsed_nested_name_specifier
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_cache_group
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|enum
name|cpp_ttype
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_parse_tentatively
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_commit_to_tentative_parse
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_abort_tentative_parse
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_parse_definitely
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|cp_parser_parsing_tentatively
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_uncommitted_to_tentative_parse_p
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_error
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_name_lookup_error
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_simulate_error
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_check_type_definition
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_check_for_definition_in_return_type
parameter_list|(
name|cp_declarator
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_check_for_invalid_template_id
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_non_integral_constant_expression
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_diagnose_invalid_type_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_parse_and_diagnose_invalid_type_name
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cp_parser_skip_to_closing_parenthesis
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_skip_to_end_of_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_consume_semicolon_at_end_of_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_skip_to_end_of_block_or_statement
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_skip_to_closing_brace
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_skip_to_end_of_template_parameter_list
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_parser_skip_to_pragma_eol
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_error_occurred
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_allow_gnu_extensions_p
parameter_list|(
name|cp_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_is_string_literal
parameter_list|(
name|cp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cp_parser_is_keyword
parameter_list|(
name|cp_token
modifier|*
parameter_list|,
name|enum
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_parser_make_typename_type
parameter_list|(
name|cp_parser
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Returns nonzero if we are parsing tentatively.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|cp_parser_parsing_tentatively
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
return|return
name|parser
operator|->
name|context
operator|->
name|next
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if TOKEN is a string literal.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_is_string_literal
parameter_list|(
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
return|return
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_STRING
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_WSTRING
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if TOKEN is the indicated KEYWORD.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_is_keyword
parameter_list|(
name|cp_token
modifier|*
name|token
parameter_list|,
name|enum
name|rid
name|keyword
parameter_list|)
block|{
return|return
name|token
operator|->
name|keyword
operator|==
name|keyword
return|;
block|}
end_function

begin_comment
comment|/* If not parsing tentatively, issue a diagnostic of the form       FILE:LINE: MESSAGE before TOKEN    where TOKEN is the next token in the input stream.  MESSAGE    (specified by the caller) is usually of the form "expected    OTHER-TOKEN".  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_error
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
comment|/* This diagnostic makes more sense if it is tagged to the line 	 of the token we just peeked at.  */
name|cp_lexer_set_source_position_from_token
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PRAGMA
condition|)
block|{
name|error
argument_list|(
literal|"%<#pragma%> is not allowed here"
argument_list|)
expr_stmt|;
name|cp_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return;
block|}
name|c_parse_error
argument_list|(
name|message
argument_list|,
comment|/* Because c_parser_error does not understand 			CPP_KEYWORD, keywords are treated like 			identifiers.  */
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_KEYWORD
condition|?
name|CPP_NAME
else|:
name|token
operator|->
name|type
operator|)
argument_list|,
name|token
operator|->
name|u
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Issue an error about name-lookup failing.  NAME is the    IDENTIFIER_NODE DECL is the result of    the lookup (as returned from cp_parser_lookup_name).  DESIRED is    the thing that we hoped to find.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_name_lookup_error
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|desired
parameter_list|)
block|{
comment|/* If name lookup completely failed, tell the user that NAME was not      declared.  */
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|parser
operator|->
name|scope
operator|&&
name|parser
operator|->
name|scope
operator|!=
name|global_namespace
condition|)
name|error
argument_list|(
literal|"%<%D::%D%> has not been declared"
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parser
operator|->
name|scope
operator|==
name|global_namespace
condition|)
name|error
argument_list|(
literal|"%<::%D%> has not been declared"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parser
operator|->
name|object_scope
operator|&&
operator|!
name|CLASS_TYPE_P
argument_list|(
name|parser
operator|->
name|object_scope
argument_list|)
condition|)
name|error
argument_list|(
literal|"request for member %qD in non-class type %qT"
argument_list|,
name|name
argument_list|,
name|parser
operator|->
name|object_scope
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parser
operator|->
name|object_scope
condition|)
name|error
argument_list|(
literal|"%<%T::%D%> has not been declared"
argument_list|,
name|parser
operator|->
name|object_scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%qD has not been declared"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parser
operator|->
name|scope
operator|&&
name|parser
operator|->
name|scope
operator|!=
name|global_namespace
condition|)
name|error
argument_list|(
literal|"%<%D::%D%> %s"
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|name
argument_list|,
name|desired
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parser
operator|->
name|scope
operator|==
name|global_namespace
condition|)
name|error
argument_list|(
literal|"%<::%D%> %s"
argument_list|,
name|name
argument_list|,
name|desired
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%qD %s"
argument_list|,
name|name
argument_list|,
name|desired
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If we are parsing tentatively, remember that an error has occurred    during this tentative parse.  Returns true if the error was    simulated; false if a message should be issued by the caller.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_simulate_error
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
if|if
condition|(
name|cp_parser_uncommitted_to_tentative_parse_p
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|parser
operator|->
name|context
operator|->
name|status
operator|=
name|CP_PARSER_STATUS_KIND_ERROR
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Check for repeated decl-specifiers.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_check_decl_spec
parameter_list|(
name|cp_decl_specifier_seq
modifier|*
name|decl_specs
parameter_list|)
block|{
name|cp_decl_spec
name|ds
decl_stmt|;
for|for
control|(
name|ds
operator|=
name|ds_first
init|;
name|ds
operator|!=
name|ds_last
condition|;
operator|++
name|ds
control|)
block|{
name|unsigned
name|count
init|=
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds
index|]
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|2
condition|)
continue|continue;
comment|/* The "long" specifier is a special case because of "long long".  */
if|if
condition|(
name|ds
operator|==
name|ds_long
condition|)
block|{
if|if
condition|(
name|count
operator|>
literal|2
condition|)
name|error
argument_list|(
literal|"%<long long long%> is too long for GCC"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
operator|&&
name|warn_long_long
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ does not support %<long long%>"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|decl_spec_names
index|[]
init|=
block|{
literal|"signed"
block|,
literal|"unsigned"
block|,
literal|"short"
block|,
literal|"long"
block|,
literal|"const"
block|,
literal|"volatile"
block|,
literal|"restrict"
block|,
literal|"inline"
block|,
literal|"virtual"
block|,
literal|"explicit"
block|,
literal|"friend"
block|,
literal|"typedef"
block|,
literal|"__complex"
block|,
literal|"__thread"
block|}
decl_stmt|;
name|error
argument_list|(
literal|"duplicate %qs"
argument_list|,
name|decl_spec_names
index|[
operator|(
name|int
operator|)
name|ds
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This function is called when a type is defined.  If type    definitions are forbidden at this point, an error message is    issued.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_check_type_definition
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* If types are forbidden here, issue a message.  */
if|if
condition|(
name|parser
operator|->
name|type_definition_forbidden_message
condition|)
block|{
comment|/* Use `%s' to print the string in case there are any escape 	 characters in the message.  */
name|error
argument_list|(
literal|"%s"
argument_list|,
name|parser
operator|->
name|type_definition_forbidden_message
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This function is called when the DECLARATOR is processed.  The TYPE    was a type defined in the decl-specifiers.  If it is invalid to    define a type in the decl-specifiers for DECLARATOR, an error is    issued.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_check_for_definition_in_return_type
parameter_list|(
name|cp_declarator
modifier|*
name|declarator
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
comment|/* [dcl.fct] forbids type definitions in return types.      Unfortunately, it's not easy to know whether or not we are      processing a return type until after the fact.  */
while|while
condition|(
name|declarator
operator|&&
operator|(
name|declarator
operator|->
name|kind
operator|==
name|cdk_pointer
operator|||
name|declarator
operator|->
name|kind
operator|==
name|cdk_reference
operator|||
name|declarator
operator|->
name|kind
operator|==
name|cdk_ptrmem
operator|)
condition|)
name|declarator
operator|=
name|declarator
operator|->
name|declarator
expr_stmt|;
if|if
condition|(
name|declarator
operator|&&
name|declarator
operator|->
name|kind
operator|==
name|cdk_function
condition|)
block|{
name|error
argument_list|(
literal|"new types may not be defined in a return type"
argument_list|)
expr_stmt|;
name|inform
argument_list|(
literal|"(perhaps a semicolon is missing after the definition of %qT)"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A type-specifier (TYPE) has been parsed which cannot be followed by    "<" in any valid C++ program.  If the next token is indeed "<",    issue a message warning the user about what appears to be an    invalid attempt to form a template-id.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_check_for_invalid_template_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|cp_token_position
name|start
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_LESS
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"%qT is not a template"
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|error
argument_list|(
literal|"%qE is not a template"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid template-id"
argument_list|)
expr_stmt|;
comment|/* Remember the location of the invalid "<".  */
if|if
condition|(
name|cp_parser_uncommitted_to_tentative_parse_p
argument_list|(
name|parser
argument_list|)
condition|)
name|start
operator|=
name|cp_lexer_token_position
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Consume the "<".  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the template arguments.  */
name|cp_parser_enclosed_template_argument_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Permanently remove the invalid template arguments so that 	 this error message is not issued again.  */
if|if
condition|(
name|start
condition|)
name|cp_lexer_purge_tokens_after
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If parsing an integral constant-expression, issue an error message    about the fact that THING appeared and return true.  Otherwise,    return false.  In either case, set    PARSER->NON_INTEGRAL_CONSTANT_EXPRESSION_P.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_non_integral_constant_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|thing
parameter_list|)
block|{
name|parser
operator|->
name|non_integral_constant_expression_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|integral_constant_expression_p
condition|)
block|{
if|if
condition|(
operator|!
name|parser
operator|->
name|allow_non_integral_constant_expression_p
condition|)
block|{
name|error
argument_list|(
literal|"%s cannot appear in a constant-expression"
argument_list|,
name|thing
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Emit a diagnostic for an invalid type name.  SCOPE is the    qualifying scope (or NULL, if none) for ID.  This function commits    to the current active tentative parse, if any.  (Otherwise, the    problematic construct might be encountered again later, resulting    in duplicate error messages.)  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_diagnose_invalid_type_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|scope
parameter_list|,
name|tree
name|id
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|old_scope
decl_stmt|;
comment|/* Try to lookup the identifier.  */
name|old_scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|parser
operator|->
name|scope
operator|=
name|scope
expr_stmt|;
name|decl
operator|=
name|cp_parser_lookup_name_simple
argument_list|(
name|parser
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|parser
operator|->
name|scope
operator|=
name|old_scope
expr_stmt|;
comment|/* If the lookup found a template-name, it means that the user forgot   to specify an argument list. Emit a useful error message.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|error
argument_list|(
literal|"invalid use of template-name %qE without an argument list"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|error
argument_list|(
literal|"invalid use of destructor %qD as a type"
argument_list|,
name|id
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
comment|/* Something like 'unsigned A a;'  */
name|error
argument_list|(
literal|"invalid combination of multiple type-specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|parser
operator|->
name|scope
condition|)
block|{
comment|/* Issue an error message.  */
name|error
argument_list|(
literal|"%qE does not name a type"
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* If we're in a template class, it's possible that the user was 	 referring to a type from a base class.  For example:  	   template<typename T> struct A { typedef T X; }; 	   template<typename T> struct B : public A<T> { X x; };  	 The user should have said "typename A<T>::X".  */
if|if
condition|(
name|processing_template_decl
operator|&&
name|current_class_type
operator|&&
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
init|;
name|b
condition|;
name|b
operator|=
name|TREE_CHAIN
argument_list|(
name|b
argument_list|)
control|)
block|{
name|tree
name|base_type
init|=
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|base_type
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|base_type
argument_list|)
condition|)
block|{
name|tree
name|field
decl_stmt|;
comment|/* Go from a particular instantiation of the 		     template (which will have an empty TYPE_FIELDs), 		     to the main version.  */
name|base_type
operator|=
name|CLASSTYPE_PRIMARY_TEMPLATE_TYPE
argument_list|(
name|base_type
argument_list|)
expr_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|base_type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|id
condition|)
block|{
name|inform
argument_list|(
literal|"(perhaps %<typename %T::%E%> was intended)"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|b
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|field
condition|)
break|break;
block|}
block|}
block|}
block|}
comment|/* Here we diagnose qualified-ids where the scope is actually correct,      but the identifier does not resolve to a valid type name.  */
elseif|else
if|if
condition|(
name|parser
operator|->
name|scope
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|error
argument_list|(
literal|"%qE in namespace %qE does not name a type"
argument_list|,
name|id
argument_list|,
name|parser
operator|->
name|scope
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
condition|)
name|error
argument_list|(
literal|"%qE in class %qT does not name a type"
argument_list|,
name|id
argument_list|,
name|parser
operator|->
name|scope
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check for a common situation where a type-name should be present,    but is not, and issue a sensible error message.  Returns true if an    invalid type-name was detected.     The situation handled by this function are variable declarations of the    form `ID a', where `ID' is an id-expression and `a' is a plain identifier.    Usually, `ID' should name a type, but if we got here it means that it    does not. We try to emit the best possible error message depending on    how exactly the id-expression looks like.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_parse_and_diagnose_invalid_type_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|id
decl_stmt|;
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|id
operator|=
name|cp_parser_id_expression
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*template_p=*/
name|NULL
argument_list|,
comment|/*declarator_p=*/
name|true
argument_list|,
comment|/*optional_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* After the id-expression, there should be a plain identifier,      otherwise this is not a simple variable declaration. Also, if      the scope is dependent, we cannot do much.  */
if|if
condition|(
operator|!
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
operator|||
operator|(
name|parser
operator|->
name|scope
operator|&&
name|TYPE_P
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|cp_parser_abort_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Emit a diagnostic for the invalid type.  */
name|cp_parser_diagnose_invalid_type_name
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* Skip to the end of the declaration; there's no point in      trying to process it.  */
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Consume tokens up to, and including, the next non-nested closing `)'.    Returns 1 iff we found a closing `)'.  RECOVERING is true, if we    are doing error recovery. Returns -1 if OR_COMMA is true and we    found an unnested comma.  */
end_comment

begin_function
specifier|static
name|int
name|cp_parser_skip_to_closing_parenthesis
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|recovering
parameter_list|,
name|bool
name|or_comma
parameter_list|,
name|bool
name|consume_paren
parameter_list|)
block|{
name|unsigned
name|paren_depth
init|=
literal|0
decl_stmt|;
name|unsigned
name|brace_depth
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|recovering
operator|&&
operator|!
name|or_comma
operator|&&
name|cp_parser_uncommitted_to_tentative_parse_p
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_EOF
case|:
case|case
name|CPP_PRAGMA_EOL
case|:
comment|/* If we've run out of tokens, then there is no closing `)'.  */
return|return
literal|0
return|;
case|case
name|CPP_SEMICOLON
case|:
comment|/* This matches the processing in skip_to_end_of_statement.  */
if|if
condition|(
operator|!
name|brace_depth
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CPP_OPEN_BRACE
case|:
operator|++
name|brace_depth
expr_stmt|;
break|break;
case|case
name|CPP_CLOSE_BRACE
case|:
if|if
condition|(
operator|!
name|brace_depth
operator|--
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CPP_COMMA
case|:
if|if
condition|(
name|recovering
operator|&&
name|or_comma
operator|&&
operator|!
name|brace_depth
operator|&&
operator|!
name|paren_depth
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|CPP_OPEN_PAREN
case|:
if|if
condition|(
operator|!
name|brace_depth
condition|)
operator|++
name|paren_depth
expr_stmt|;
break|break;
case|case
name|CPP_CLOSE_PAREN
case|:
if|if
condition|(
operator|!
name|brace_depth
operator|&&
operator|!
name|paren_depth
operator|--
condition|)
block|{
if|if
condition|(
name|consume_paren
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Consume tokens until we reach the end of the current statement.    Normally, that will be just before consuming a `;'.  However, if a    non-nested `}' comes first, then we stop before consuming that.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_skip_to_end_of_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|unsigned
name|nesting_depth
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_EOF
case|:
case|case
name|CPP_PRAGMA_EOL
case|:
comment|/* If we've run out of tokens, stop.  */
return|return;
case|case
name|CPP_SEMICOLON
case|:
comment|/* If the next token is a `;', we have reached the end of the 	     statement.  */
if|if
condition|(
operator|!
name|nesting_depth
condition|)
return|return;
break|break;
case|case
name|CPP_CLOSE_BRACE
case|:
comment|/* If this is a non-nested '}', stop before consuming it. 	     That way, when confronted with something like:  	       { 3 + }  	     we stop before consuming the closing '}', even though we 	     have not yet reached a `;'.  */
if|if
condition|(
name|nesting_depth
operator|==
literal|0
condition|)
return|return;
comment|/* If it is the closing '}' for a block that we have 	     scanned, stop -- but only after consuming the token. 	     That way given:  		void f g () { ... } 		typedef int I;  	     we will stop after the body of the erroneously declared 	     function, but before consuming the following `typedef' 	     declaration.  */
if|if
condition|(
operator|--
name|nesting_depth
operator|==
literal|0
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|CPP_OPEN_BRACE
case|:
operator|++
name|nesting_depth
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called at the end of a statement or declaration.    If the next token is a semicolon, it is consumed; otherwise, error    recovery is attempted.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_consume_semicolon_at_end_of_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Look for the trailing `;'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
condition|)
block|{
comment|/* If there is additional (erroneous) input, skip to the end of 	 the statement.  */
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is now a `;', consume it.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Skip tokens until we have consumed an entire block, or until we    have consumed a non-nested `;'.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_skip_to_end_of_block_or_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|int
name|nesting_depth
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|nesting_depth
operator|>=
literal|0
condition|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_EOF
case|:
case|case
name|CPP_PRAGMA_EOL
case|:
comment|/* If we've run out of tokens, stop.  */
return|return;
case|case
name|CPP_SEMICOLON
case|:
comment|/* Stop if this is an unnested ';'. */
if|if
condition|(
operator|!
name|nesting_depth
condition|)
name|nesting_depth
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|CPP_CLOSE_BRACE
case|:
comment|/* Stop if this is an unnested '}', or closes the outermost 	     nesting level.  */
name|nesting_depth
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|nesting_depth
condition|)
name|nesting_depth
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|CPP_OPEN_BRACE
case|:
comment|/* Nest. */
name|nesting_depth
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Skip tokens until a non-nested closing curly brace is the next    token.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_skip_to_closing_brace
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|unsigned
name|nesting_depth
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_EOF
case|:
case|case
name|CPP_PRAGMA_EOL
case|:
comment|/* If we've run out of tokens, stop.  */
return|return;
case|case
name|CPP_CLOSE_BRACE
case|:
comment|/* If the next token is a non-nested `}', then we have reached 	     the end of the current block.  */
if|if
condition|(
name|nesting_depth
operator|--
operator|==
literal|0
condition|)
return|return;
break|break;
case|case
name|CPP_OPEN_BRACE
case|:
comment|/* If it the next token is a `{', then we are entering a new 	     block.  Consume the entire block.  */
operator|++
name|nesting_depth
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Consume tokens until we reach the end of the pragma.  The PRAGMA_TOK    parameter is the PRAGMA token, allowing us to purge the entire pragma    sequence.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_skip_to_pragma_eol
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token
modifier|*
name|pragma_tok
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|parser
operator|->
name|lexer
operator|->
name|in_pragma
operator|=
name|false
expr_stmt|;
do|do
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
do|while
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_PRAGMA_EOL
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
do|;
comment|/* Ensure that the pragma is not parsed again.  */
name|cp_lexer_purge_tokens_after
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Require pragma end of line, resyncing with it as necessary.  The    arguments are as for cp_parser_skip_to_pragma_eol.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_require_pragma_eol
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token
modifier|*
name|pragma_tok
parameter_list|)
block|{
name|parser
operator|->
name|lexer
operator|->
name|in_pragma
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_PRAGMA_EOL
argument_list|,
literal|"end of line"
argument_list|)
condition|)
name|cp_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a simple wrapper around make_typename_type. When the id is    an unresolved identifier node, we can provide a superior diagnostic    using cp_parser_diagnose_invalid_type_name.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_make_typename_type
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|scope
parameter_list|,
name|tree
name|id
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|result
operator|=
name|make_typename_type
argument_list|(
name|scope
argument_list|,
name|id
argument_list|,
name|typename_type
argument_list|,
comment|/*complain=*/
name|tf_none
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|error_mark_node
condition|)
name|cp_parser_diagnose_invalid_type_name
argument_list|(
name|parser
argument_list|,
name|scope
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|make_typename_type
argument_list|(
name|scope
argument_list|,
name|id
argument_list|,
name|typename_type
argument_list|,
name|tf_error
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a new C++ parser.  */
end_comment

begin_function
specifier|static
name|cp_parser
modifier|*
name|cp_parser_new
parameter_list|(
name|void
parameter_list|)
block|{
name|cp_parser
modifier|*
name|parser
decl_stmt|;
name|cp_lexer
modifier|*
name|lexer
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* cp_lexer_new_main is called before calling ggc_alloc because      cp_lexer_new_main might load a PCH file.  */
name|lexer
operator|=
name|cp_lexer_new_main
argument_list|()
expr_stmt|;
comment|/* Initialize the binops_by_token so that we can get the tree      directly from the token.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|binops
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|binops
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|binops_by_token
index|[
name|binops
index|[
name|i
index|]
operator|.
name|token_type
index|]
operator|=
name|binops
index|[
name|i
index|]
expr_stmt|;
name|parser
operator|=
name|GGC_CNEW
argument_list|(
name|cp_parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|lexer
operator|=
name|lexer
expr_stmt|;
name|parser
operator|->
name|context
operator|=
name|cp_parser_context_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* For now, we always accept GNU extensions.  */
name|parser
operator|->
name|allow_gnu_extensions_p
operator|=
literal|1
expr_stmt|;
comment|/* The `>' token is a greater-than operator, not the end of a      template-id.  */
name|parser
operator|->
name|greater_than_is_operator_p
operator|=
name|true
expr_stmt|;
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|true
expr_stmt|;
comment|/* We are not parsing a constant-expression.  */
name|parser
operator|->
name|integral_constant_expression_p
operator|=
name|false
expr_stmt|;
name|parser
operator|->
name|allow_non_integral_constant_expression_p
operator|=
name|false
expr_stmt|;
name|parser
operator|->
name|non_integral_constant_expression_p
operator|=
name|false
expr_stmt|;
comment|/* Local variable names are not forbidden.  */
name|parser
operator|->
name|local_variables_forbidden_p
operator|=
name|false
expr_stmt|;
comment|/* We are not processing an `extern "C"' declaration.  */
name|parser
operator|->
name|in_unbraced_linkage_specification_p
operator|=
name|false
expr_stmt|;
comment|/* We are not processing a declarator.  */
name|parser
operator|->
name|in_declarator_p
operator|=
name|false
expr_stmt|;
comment|/* We are not processing a template-argument-list.  */
name|parser
operator|->
name|in_template_argument_list_p
operator|=
name|false
expr_stmt|;
comment|/* We are not in an iteration statement.  */
name|parser
operator|->
name|in_statement
operator|=
literal|0
expr_stmt|;
comment|/* We are not in a switch statement.  */
name|parser
operator|->
name|in_switch_statement_p
operator|=
name|false
expr_stmt|;
comment|/* We are not parsing a type-id inside an expression.  */
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|false
expr_stmt|;
comment|/* Declarations aren't implicitly extern "C".  */
name|parser
operator|->
name|implicit_extern_c
operator|=
name|false
expr_stmt|;
comment|/* String literals should be translated to the execution character set.  */
name|parser
operator|->
name|translate_strings_p
operator|=
name|true
expr_stmt|;
comment|/* We are not parsing a function body.  */
name|parser
operator|->
name|in_function_body
operator|=
name|false
expr_stmt|;
comment|/* The unparsed function queue is empty.  */
name|parser
operator|->
name|unparsed_functions_queues
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* There are no classes being defined.  */
name|parser
operator|->
name|num_classes_being_defined
operator|=
literal|0
expr_stmt|;
comment|/* No template parameters apply.  */
name|parser
operator|->
name|num_template_parameter_lists
operator|=
literal|0
expr_stmt|;
return|return
name|parser
return|;
block|}
end_function

begin_comment
comment|/* Create a cp_lexer structure which will emit the tokens in CACHE    and push it onto the parser's lexer stack.  This is used for delayed    parsing of in-class method bodies and default arguments, and should    not be confused with tentative parsing.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_push_lexer_for_tokens
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token_cache
modifier|*
name|cache
parameter_list|)
block|{
name|cp_lexer
modifier|*
name|lexer
init|=
name|cp_lexer_new_from_tokens
argument_list|(
name|cache
argument_list|)
decl_stmt|;
name|lexer
operator|->
name|next
operator|=
name|parser
operator|->
name|lexer
expr_stmt|;
name|parser
operator|->
name|lexer
operator|=
name|lexer
expr_stmt|;
comment|/* Move the current source position to that of the first token in the      new lexer.  */
name|cp_lexer_set_source_position_from_token
argument_list|(
name|lexer
operator|->
name|next_token
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the top lexer off the parser stack.  This is never used for the    "main" lexer, only for those pushed by cp_parser_push_lexer_for_tokens.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_pop_lexer
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_lexer
modifier|*
name|lexer
init|=
name|parser
operator|->
name|lexer
decl_stmt|;
name|parser
operator|->
name|lexer
operator|=
name|lexer
operator|->
name|next
expr_stmt|;
name|cp_lexer_destroy
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
comment|/* Put the current source position back where it was before this      lexer was pushed.  */
name|cp_lexer_set_source_position_from_token
argument_list|(
name|parser
operator|->
name|lexer
operator|->
name|next_token
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lexical conventions [gram.lex]  */
end_comment

begin_comment
comment|/* Parse an identifier.  Returns an IDENTIFIER_NODE representing the    identifier.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_identifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Look for the identifier.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|,
literal|"identifier"
argument_list|)
expr_stmt|;
comment|/* Return the value.  */
return|return
name|token
condition|?
name|token
operator|->
name|u
operator|.
name|value
else|:
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Parse a sequence of adjacent string constants.  Returns a    TREE_STRING representing the combined, nul-terminated string    constant.  If TRANSLATE is true, translate the string to the    execution character set.  If WIDE_OK is true, a wide string is    invalid here.     C++98 [lex.string] says that if a narrow string literal token is    adjacent to a wide string literal token, the behavior is undefined.    However, C99 6.4.5p4 says that this results in a wide string literal.    We follow C99 here, for consistency with the C front end.     This code is largely lifted from lex_string() in c-lex.c.     FUTURE: ObjC++ will need to handle @-strings here.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_string_literal
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|translate
parameter_list|,
name|bool
name|wide_ok
parameter_list|)
block|{
name|tree
name|value
decl_stmt|;
name|bool
name|wide
init|=
name|false
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|struct
name|obstack
name|str_ob
decl_stmt|;
name|cpp_string
name|str
decl_stmt|,
name|istr
decl_stmt|,
modifier|*
name|strs
decl_stmt|;
name|cp_token
modifier|*
name|tok
decl_stmt|;
name|tok
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_is_string_literal
argument_list|(
name|tok
argument_list|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected string-literal"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Try to avoid the overhead of creating and destroying an obstack      for the common case of just one string.  */
if|if
condition|(
operator|!
name|cp_parser_is_string_literal
argument_list|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|str
operator|.
name|text
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|TREE_STRING_POINTER
argument_list|(
name|tok
operator|->
name|u
operator|.
name|value
argument_list|)
expr_stmt|;
name|str
operator|.
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|tok
operator|->
name|u
operator|.
name|value
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_WSTRING
condition|)
name|wide
operator|=
name|true
expr_stmt|;
name|strs
operator|=
operator|&
name|str
expr_stmt|;
block|}
else|else
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|str_ob
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|str
operator|.
name|text
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|TREE_STRING_POINTER
argument_list|(
name|tok
operator|->
name|u
operator|.
name|value
argument_list|)
expr_stmt|;
name|str
operator|.
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|tok
operator|->
name|u
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_WSTRING
condition|)
name|wide
operator|=
name|true
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|str_ob
argument_list|,
operator|&
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_string
argument_list|)
argument_list|)
expr_stmt|;
name|tok
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cp_parser_is_string_literal
argument_list|(
name|tok
argument_list|)
condition|)
do|;
name|strs
operator|=
operator|(
name|cpp_string
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|str_ob
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wide
operator|&&
operator|!
name|wide_ok
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"a wide string is invalid in this context"
argument_list|)
expr_stmt|;
name|wide
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|translate
condition|?
name|cpp_interpret_string
else|:
name|cpp_interpret_string_notranslate
operator|)
operator|(
name|parse_in
operator|,
name|strs
operator|,
name|count
operator|,
operator|&
name|istr
operator|,
name|wide
operator|)
condition|)
block|{
name|value
operator|=
name|build_string
argument_list|(
name|istr
operator|.
name|len
argument_list|,
operator|(
name|char
operator|*
operator|)
name|istr
operator|.
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|istr
operator|.
name|text
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|wide
condition|?
name|wchar_array_type_node
else|:
name|char_array_type_node
expr_stmt|;
name|value
operator|=
name|fix_string_type
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* cpp_interpret_string has issued an error.  */
name|value
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|obstack_free
argument_list|(
operator|&
name|str_ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Basic concepts [gram.basic]  */
end_comment

begin_comment
comment|/* Parse a translation-unit.     translation-unit:      declaration-seq [opt]     Returns TRUE if all went well.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_translation_unit
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* The address of the first non-permanent object on the declarator      obstack.  */
specifier|static
name|void
modifier|*
name|declarator_obstack_base
decl_stmt|;
name|bool
name|success
decl_stmt|;
comment|/* Create the declarator obstack, if necessary.  */
if|if
condition|(
operator|!
name|cp_error_declarator
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|declarator_obstack
argument_list|)
expr_stmt|;
comment|/* Create the error declarator.  */
name|cp_error_declarator
operator|=
name|make_declarator
argument_list|(
name|cdk_error
argument_list|)
expr_stmt|;
comment|/* Create the empty parameter list.  */
name|no_parameters
operator|=
name|make_parameter_declarator
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Remember where the base of the declarator obstack lies.  */
name|declarator_obstack_base
operator|=
name|obstack_next_free
argument_list|(
operator|&
name|declarator_obstack
argument_list|)
expr_stmt|;
block|}
name|cp_parser_declaration_seq_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If there are no tokens left then all went well.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EOF
argument_list|)
condition|)
block|{
comment|/* Get rid of the token array; we don't need it any more.  */
name|cp_lexer_destroy
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|parser
operator|->
name|lexer
operator|=
name|NULL
expr_stmt|;
comment|/* This file might have been a context that's implicitly extern 	 "C".  If so, pop the lang context.  (Only relevant for PCH.) */
if|if
condition|(
name|parser
operator|->
name|implicit_extern_c
condition|)
block|{
name|pop_lang_context
argument_list|()
expr_stmt|;
name|parser
operator|->
name|implicit_extern_c
operator|=
name|false
expr_stmt|;
block|}
comment|/* Finish up.  */
name|finish_translation_unit
argument_list|()
expr_stmt|;
name|success
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected declaration"
argument_list|)
expr_stmt|;
name|success
operator|=
name|false
expr_stmt|;
block|}
comment|/* Make sure the declarator obstack was fully cleaned up.  */
name|gcc_assert
argument_list|(
name|obstack_next_free
argument_list|(
operator|&
name|declarator_obstack
argument_list|)
operator|==
name|declarator_obstack_base
argument_list|)
expr_stmt|;
comment|/* All went well.  */
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/* Expressions [gram.expr] */
end_comment

begin_comment
comment|/* Parse a primary-expression.     primary-expression:      literal      this      ( expression )      id-expression     GNU Extensions:     primary-expression:      ( compound-statement )      __builtin_va_arg ( assignment-expression , type-id )      __builtin_offsetof ( type-id , offsetof-expression )     Objective-C++ Extension:     primary-expression:      objc-expression     literal:      __null     ADDRESS_P is true iff this expression was immediately preceded by    "&" and therefore might denote a pointer-to-member.  CAST_P is true    iff this expression is the target of a cast.  TEMPLATE_ARG_P is    true iff this expression is a template argument.     Returns a representation of the expression.  Upon return, *IDK    indicates what kind of id-expression (if any) was present.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_primary_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|address_p
parameter_list|,
name|bool
name|cast_p
parameter_list|,
name|bool
name|template_arg_p
parameter_list|,
name|cp_id_kind
modifier|*
name|idk
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Assume the primary expression is not an id-expression.  */
operator|*
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
comment|/* literal: 	   integer-literal 	   character-literal 	   floating-literal 	   string-literal 	   boolean-literal  */
case|case
name|CPP_CHAR
case|:
case|case
name|CPP_WCHAR
case|:
case|case
name|CPP_NUMBER
case|:
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Floating-point literals are only allowed in an integral 	 constant expression if they are cast to an integral or 	 enumeration type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|token
operator|->
name|u
operator|.
name|value
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|parser
operator|->
name|integral_constant_expression_p
operator|&&
name|pedantic
condition|)
block|{
comment|/* CAST_P will be set even in invalid code like "int(2.7 + 	     ...)".   Therefore, we have to check that the next token 	     is sure to end the cast.  */
if|if
condition|(
name|cast_p
condition|)
block|{
name|cp_token
modifier|*
name|next_token
decl_stmt|;
name|next_token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* The comma at the end of an 		     enumerator-definition.  */
name|next_token
operator|->
name|type
operator|!=
name|CPP_COMMA
comment|/* The curly brace at the end of an enum-specifier.  */
operator|&&
name|next_token
operator|->
name|type
operator|!=
name|CPP_CLOSE_BRACE
comment|/* The end of a statement.  */
operator|&&
name|next_token
operator|->
name|type
operator|!=
name|CPP_SEMICOLON
comment|/* The end of the cast-expression.  */
operator|&&
name|next_token
operator|->
name|type
operator|!=
name|CPP_CLOSE_PAREN
comment|/* The end of an array bound.  */
operator|&&
name|next_token
operator|->
name|type
operator|!=
name|CPP_CLOSE_SQUARE
comment|/* The closing ">" in a template-argument-list.  */
operator|&&
operator|(
name|next_token
operator|->
name|type
operator|!=
name|CPP_GREATER
operator|||
name|parser
operator|->
name|greater_than_is_operator_p
operator|)
condition|)
name|cast_p
operator|=
name|false
expr_stmt|;
block|}
comment|/* If we are within a cast, then the constraint that the 	     cast is to an integral or enumeration type will be 	     checked at that point.  If we are not within a cast, then 	     this code is invalid.  */
if|if
condition|(
operator|!
name|cast_p
condition|)
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"floating-point literal"
argument_list|)
expr_stmt|;
block|}
return|return
name|token
operator|->
name|u
operator|.
name|value
return|;
case|case
name|CPP_STRING
case|:
case|case
name|CPP_WSTRING
case|:
comment|/* ??? Should wide strings be allowed when parser->translate_strings_p 	 is false (i.e. in attributes)?  If not, we can kill the third 	 argument to cp_parser_string_literal.  */
return|return
name|cp_parser_string_literal
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|translate_strings_p
argument_list|,
name|true
argument_list|)
return|;
case|case
name|CPP_OPEN_PAREN
case|:
block|{
name|tree
name|expr
decl_stmt|;
name|bool
name|saved_greater_than_is_operator_p
decl_stmt|;
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Within a parenthesized expression, a `>' token is always 	   the greater-than operator.  */
name|saved_greater_than_is_operator_p
operator|=
name|parser
operator|->
name|greater_than_is_operator_p
expr_stmt|;
name|parser
operator|->
name|greater_than_is_operator_p
operator|=
name|true
expr_stmt|;
comment|/* If we see `( { ' then we are looking at the beginning of 	   a GNU statement-expression.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
block|{
comment|/* Statement-expressions are not allowed by the standard.  */
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids braced-groups within expressions"
argument_list|)
expr_stmt|;
comment|/* And they're not allowed outside of a function-body; you 	       cannot, for example, write:  		 int i = ({ int j = 3; j + 1; });  	       at class or namespace scope.  */
if|if
condition|(
operator|!
name|parser
operator|->
name|in_function_body
condition|)
name|error
argument_list|(
literal|"statement-expressions are allowed only inside functions"
argument_list|)
expr_stmt|;
comment|/* Start the statement-expression.  */
name|expr
operator|=
name|begin_stmt_expr
argument_list|()
expr_stmt|;
comment|/* Parse the compound-statement.  */
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|expr
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Finish up.  */
name|expr
operator|=
name|finish_stmt_expr
argument_list|(
name|expr
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Parse the parenthesized expression.  */
name|expr
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
name|cast_p
argument_list|)
expr_stmt|;
comment|/* Let the front end know that this expression was 	       enclosed in parentheses. This matters in case, for 	       example, the expression is of the form `A::B', since 	       `&A::B' might be a pointer-to-member, but `&(A::B)' is 	       not.  */
name|finish_parenthesized_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* The `>' token might be the end of a template-id or 	   template-parameter-list now.  */
name|parser
operator|->
name|greater_than_is_operator_p
operator|=
name|saved_greater_than_is_operator_p
expr_stmt|;
comment|/* Consume the `)'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
case|case
name|CPP_KEYWORD
case|:
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
comment|/* These two are the boolean literals.  */
case|case
name|RID_TRUE
case|:
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|boolean_true_node
return|;
case|case
name|RID_FALSE
case|:
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|boolean_false_node
return|;
comment|/* The `__null' literal.  */
case|case
name|RID_NULL
case|:
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|null_node
return|;
comment|/* Recognize the `this' keyword.  */
case|case
name|RID_THIS
case|:
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|local_variables_forbidden_p
condition|)
block|{
name|error
argument_list|(
literal|"%<this%> may not be used in this context"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Pointers cannot appear in constant-expressions.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"`this'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
return|return
name|finish_this_expr
argument_list|()
return|;
comment|/* The `operator' keyword can be the beginning of an 	     id-expression.  */
case|case
name|RID_OPERATOR
case|:
goto|goto
name|id_expression
goto|;
case|case
name|RID_FUNCTION_NAME
case|:
case|case
name|RID_PRETTY_FUNCTION_NAME
case|:
case|case
name|RID_C99_FUNCTION_NAME
case|:
comment|/* The symbols __FUNCTION__, __PRETTY_FUNCTION__, and 	     __func__ are the names of variables -- but they are 	     treated specially.  Therefore, they are handled here, 	     rather than relying on the generic id-expression logic 	     below.  Grammatically, these names are id-expressions.  	     Consume the token.  */
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look up the name.  */
return|return
name|finish_fname
argument_list|(
name|token
operator|->
name|u
operator|.
name|value
argument_list|)
return|;
case|case
name|RID_VA_ARG
case|:
block|{
name|tree
name|expression
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* The `__builtin_va_arg' construct is used to handle 	       `va_arg'.  Consume the `__builtin_va_arg' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the opening `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Now, parse the assignment-expression.  */
name|expression
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the `,'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|,
literal|"`,'"
argument_list|)
expr_stmt|;
comment|/* Parse the type-id.  */
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the closing `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Using `va_arg' in a constant-expression is not 	       allowed.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"`va_arg'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_x_va_arg
argument_list|(
name|expression
argument_list|,
name|type
argument_list|)
return|;
block|}
case|case
name|RID_OFFSETOF
case|:
return|return
name|cp_parser_builtin_offsetof
argument_list|(
name|parser
argument_list|)
return|;
comment|/* Objective-C++ expressions.  */
case|case
name|RID_AT_ENCODE
case|:
case|case
name|RID_AT_PROTOCOL
case|:
case|case
name|RID_AT_SELECTOR
case|:
return|return
name|cp_parser_objc_expression
argument_list|(
name|parser
argument_list|)
return|;
default|default:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected primary-expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* An id-expression can start with either an identifier, a 	 `::' as the beginning of a qualified-id, or the "operator" 	 keyword.  */
case|case
name|CPP_NAME
case|:
case|case
name|CPP_SCOPE
case|:
case|case
name|CPP_TEMPLATE_ID
case|:
case|case
name|CPP_NESTED_NAME_SPECIFIER
case|:
block|{
name|tree
name|id_expression
decl_stmt|;
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|error_msg
decl_stmt|;
name|bool
name|template_p
decl_stmt|;
name|bool
name|done
decl_stmt|;
name|id_expression
label|:
comment|/* Parse the id-expression.  */
name|id_expression
operator|=
name|cp_parser_id_expression
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
operator|&
name|template_p
argument_list|,
comment|/*declarator_p=*/
name|false
argument_list|,
comment|/*optional_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|id_expression
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|done
operator|=
operator|(
name|token
operator|->
name|type
operator|!=
name|CPP_OPEN_SQUARE
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_OPEN_PAREN
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_DOT
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_DEREF
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_PLUS_PLUS
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_MINUS_MINUS
operator|)
expr_stmt|;
comment|/* If we have a template-id, then no further lookup is 	   required.  If the template-id was for a template-class, we 	   will sometimes have a TYPE_DECL at this point.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id_expression
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|id_expression
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|decl
operator|=
name|id_expression
expr_stmt|;
comment|/* Look up the name.  */
else|else
block|{
name|tree
name|ambiguous_decls
decl_stmt|;
name|decl
operator|=
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|id_expression
argument_list|,
name|none_type
argument_list|,
name|template_p
argument_list|,
comment|/*is_namespace=*/
name|false
argument_list|,
comment|/*check_dependency=*/
name|true
argument_list|,
operator|&
name|ambiguous_decls
argument_list|)
expr_stmt|;
comment|/* If the lookup was ambiguous, an error will already have 	       been issued.  */
if|if
condition|(
name|ambiguous_decls
condition|)
return|return
name|error_mark_node
return|;
comment|/* In Objective-C++, an instance variable (ivar) may be preferred 	       to whatever cp_parser_lookup_name() found.  */
name|decl
operator|=
name|objc_lookup_ivar
argument_list|(
name|decl
argument_list|,
name|id_expression
argument_list|)
expr_stmt|;
comment|/* If name lookup gives us a SCOPE_REF, then the 	       qualifying scope was dependent.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
comment|/* At this point, we do not know if DECL is a valid 		   integral constant expression.  We assume that it is 		   in fact such an expression, so that code like:  		      template<int N> struct A { 			int a[B<N>::i]; 		      }; 		      		   is accepted.  At template-instantiation time, we 		   will check that B<N>::i is actually a constant.  */
return|return
name|decl
return|;
block|}
comment|/* Check to see if DECL is a local variable in a context 	       where that is forbidden.  */
if|if
condition|(
name|parser
operator|->
name|local_variables_forbidden_p
operator|&&
name|local_variable_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* It might be that we only found DECL because we are 		   trying to be generous with pre-ISO scoping rules. 		   For example, consider:  		     int i; 		     void g() { 		       for (int i = 0; i< 10; ++i) {} 		       extern void f(int j = i); 		     }  		   Here, name look up will originally find the out 		   of scope `i'.  We need to issue a warning message, 		   but then use the global `i'.  */
name|decl
operator|=
name|check_for_out_of_scope_variable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_variable_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"local variable %qD may not appear in this context"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
block|}
name|decl
operator|=
operator|(
name|finish_id_expression
argument_list|(
name|id_expression
argument_list|,
name|decl
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|idk
argument_list|,
name|parser
operator|->
name|integral_constant_expression_p
argument_list|,
name|parser
operator|->
name|allow_non_integral_constant_expression_p
argument_list|,
operator|&
name|parser
operator|->
name|non_integral_constant_expression_p
argument_list|,
name|template_p
argument_list|,
name|done
argument_list|,
name|address_p
argument_list|,
name|template_arg_p
argument_list|,
operator|&
name|error_msg
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|error_msg
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
name|error_msg
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* Anything else is an error.  */
default|default:
comment|/* ...unless we have an Objective-C++ message or string literal, that is.  */
if|if
condition|(
name|c_dialect_objc
argument_list|()
operator|&&
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_SQUARE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_OBJC_STRING
operator|)
condition|)
return|return
name|cp_parser_objc_expression
argument_list|(
name|parser
argument_list|)
return|;
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected primary-expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an id-expression.     id-expression:      unqualified-id      qualified-id     qualified-id:      :: [opt] nested-name-specifier template [opt] unqualified-id      :: identifier      :: operator-function-id      :: template-id     Return a representation of the unqualified portion of the    identifier.  Sets PARSER->SCOPE to the qualifying scope if there is    a `::' or nested-name-specifier.     Often, if the id-expression was a qualified-id, the caller will    want to make a SCOPE_REF to represent the qualified-id.  This    function does not do this in order to avoid wastefully creating    SCOPE_REFs when they are not required.     If TEMPLATE_KEYWORD_P is true, then we have just seen the    `template' keyword.     If CHECK_DEPENDENCY_P is false, then names are looked up inside    uninstantiated templates.     If *TEMPLATE_P is non-NULL, it is set to true iff the    `template' keyword is used to explicitly indicate that the entity    named is a template.     If DECLARATOR_P is true, the id-expression is appearing as part of    a declarator, rather than as part of an expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_id_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|template_keyword_p
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
modifier|*
name|template_p
parameter_list|,
name|bool
name|declarator_p
parameter_list|,
name|bool
name|optional_p
parameter_list|)
block|{
name|bool
name|global_scope_p
decl_stmt|;
name|bool
name|nested_name_specifier_p
decl_stmt|;
comment|/* Assume the `template' keyword was not used.  */
if|if
condition|(
name|template_p
condition|)
operator|*
name|template_p
operator|=
name|template_keyword_p
expr_stmt|;
comment|/* Look for the optional `::' operator.  */
name|global_scope_p
operator|=
operator|(
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Look for the optional nested-name-specifier.  */
name|nested_name_specifier_p
operator|=
operator|(
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
name|check_dependency_p
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
name|declarator_p
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* If there is a nested-name-specifier, then we are looking at      the first qualified-id production.  */
if|if
condition|(
name|nested_name_specifier_p
condition|)
block|{
name|tree
name|saved_scope
decl_stmt|;
name|tree
name|saved_object_scope
decl_stmt|;
name|tree
name|saved_qualifying_scope
decl_stmt|;
name|tree
name|unqualified_id
decl_stmt|;
name|bool
name|is_template
decl_stmt|;
comment|/* See if the next token is the `template' keyword.  */
if|if
condition|(
operator|!
name|template_p
condition|)
name|template_p
operator|=
operator|&
name|is_template
expr_stmt|;
operator|*
name|template_p
operator|=
name|cp_parser_optional_template_keyword
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Name lookup we do during the processing of the 	 unqualified-id might obliterate SCOPE.  */
name|saved_scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|saved_object_scope
operator|=
name|parser
operator|->
name|object_scope
expr_stmt|;
name|saved_qualifying_scope
operator|=
name|parser
operator|->
name|qualifying_scope
expr_stmt|;
comment|/* Process the final unqualified-id.  */
name|unqualified_id
operator|=
name|cp_parser_unqualified_id
argument_list|(
name|parser
argument_list|,
operator|*
name|template_p
argument_list|,
name|check_dependency_p
argument_list|,
name|declarator_p
argument_list|,
comment|/*optional_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Restore the SAVED_SCOPE for our caller.  */
name|parser
operator|->
name|scope
operator|=
name|saved_scope
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|saved_object_scope
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|saved_qualifying_scope
expr_stmt|;
return|return
name|unqualified_id
return|;
block|}
comment|/* Otherwise, if we are in global scope, then we are looking at one      of the other qualified-id productions.  */
elseif|else
if|if
condition|(
name|global_scope_p
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|id
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's an identifier, and the next token is not a "<", then 	 we can avoid the template-id case.  This is an optimization 	 for this common case.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
operator|&&
operator|!
name|cp_parser_nth_token_starts_template_argument_list_p
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
return|;
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try a template-id.  */
name|id
operator|=
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
name|declarator_p
argument_list|)
expr_stmt|;
comment|/* If that worked, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|id
return|;
comment|/* Peek at the next token.  (Changes in the token buffer may 	 have invalidated the pointer obtained above.)  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_NAME
case|:
return|return
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
return|;
case|case
name|CPP_KEYWORD
case|:
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_OPERATOR
condition|)
return|return
name|cp_parser_operator_function_id
argument_list|(
name|parser
argument_list|)
return|;
comment|/* Fall through.  */
default|default:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected id-expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
return|return
name|cp_parser_unqualified_id
argument_list|(
name|parser
argument_list|,
name|template_keyword_p
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
name|declarator_p
argument_list|,
name|optional_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an unqualified-id.     unqualified-id:      identifier      operator-function-id      conversion-function-id      ~ class-name      template-id     If TEMPLATE_KEYWORD_P is TRUE, we have just seen the `template'    keyword, in a construct like `A::template ...'.     Returns a representation of unqualified-id.  For the `identifier'    production, an IDENTIFIER_NODE is returned.  For the `~ class-name'    production a BIT_NOT_EXPR is returned; the operand of the    BIT_NOT_EXPR is an IDENTIFIER_NODE for the class-name.  For the    other productions, see the documentation accompanying the    corresponding parsing functions.  If CHECK_DEPENDENCY_P is false,    names are looked up in uninstantiated templates.  If DECLARATOR_P    is true, the unqualified-id is appearing as part of a declarator,    rather than as part of an expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_unqualified_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|template_keyword_p
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
name|declarator_p
parameter_list|,
name|bool
name|optional_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_NAME
case|:
block|{
name|tree
name|id
decl_stmt|;
comment|/* We don't know yet whether or not this will be a 	   template-id.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try a template-id.  */
name|id
operator|=
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
name|template_keyword_p
argument_list|,
name|check_dependency_p
argument_list|,
name|declarator_p
argument_list|)
expr_stmt|;
comment|/* If it worked, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|id
return|;
comment|/* Otherwise, it's an ordinary identifier.  */
return|return
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
return|;
block|}
case|case
name|CPP_TEMPLATE_ID
case|:
return|return
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
name|template_keyword_p
argument_list|,
name|check_dependency_p
argument_list|,
name|declarator_p
argument_list|)
return|;
case|case
name|CPP_COMPL
case|:
block|{
name|tree
name|type_decl
decl_stmt|;
name|tree
name|qualifying_scope
decl_stmt|;
name|tree
name|object_scope
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|bool
name|done
decl_stmt|;
comment|/* Consume the `~' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the class-name.  The standard, as written, seems to 	   say that:  	     template<typename T> struct S { ~S (); }; 	     template<typename T> S<T>::~S() {}  	   is invalid, since `~' must be followed by a class-name, but 	   `S<T>' is dependent, and so not known to be a class. 	   That's not right; we need to look in uninstantiated 	   templates.  A further complication arises from:  	     template<typename T> void f(T t) { 	       t.T::~T(); 	     }  	   Here, it is not possible to look up `T' in the scope of `T' 	   itself.  We must look in both the current scope, and the 	   scope of the containing complete expression.  	   Yet another issue is:  	     struct S { 	       int S; 	       ~S(); 	     };  	     S::~S() {}  	   The standard does not seem to say that the `S' in `~S' 	   should refer to the type `S' and not the data member 	   `S::S'.  */
comment|/* DR 244 says that we look up the name after the "~" in the 	   same scope as we looked up the qualifying name.  That idea 	   isn't fully worked out; it's more complicated than that.  */
name|scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|object_scope
operator|=
name|parser
operator|->
name|object_scope
expr_stmt|;
name|qualifying_scope
operator|=
name|parser
operator|->
name|qualifying_scope
expr_stmt|;
comment|/* Check for invalid scopes.  */
if|if
condition|(
name|scope
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|scope
operator|&&
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
if|if
condition|(
operator|!
name|cp_parser_uncommitted_to_tentative_parse_p
argument_list|(
name|parser
argument_list|)
condition|)
name|error
argument_list|(
literal|"scope %qT before %<~%> is not a class-name"
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|gcc_assert
argument_list|(
operator|!
name|scope
operator|||
name|TYPE_P
argument_list|(
name|scope
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the name is of the form "X::~X" it's OK.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
operator|&&
name|token
operator|->
name|type
operator|==
name|CPP_NAME
operator|&&
operator|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
operator|)
operator|&&
name|constructor_name_p
argument_list|(
name|token
operator|->
name|u
operator|.
name|value
argument_list|,
name|scope
argument_list|)
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|build_nt
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|scope
argument_list|)
return|;
block|}
comment|/* If there was an explicit qualification (S::~T), first look 	   in the scope given by the qualification (i.e., S).  */
name|done
operator|=
name|false
expr_stmt|;
name|type_decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|scope
condition|)
block|{
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
name|none_type
argument_list|,
comment|/*check_dependency=*/
name|false
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
name|declarator_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|done
operator|=
name|true
expr_stmt|;
block|}
comment|/* In "N::S::~S", look in "N" as well.  */
if|if
condition|(
operator|!
name|done
operator|&&
name|scope
operator|&&
name|qualifying_scope
condition|)
block|{
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|scope
operator|=
name|qualifying_scope
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|type_decl
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
name|none_type
argument_list|,
comment|/*check_dependency=*/
name|false
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
name|declarator_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|done
operator|=
name|true
expr_stmt|;
block|}
comment|/* In "p->S::~T", look in the scope given by "*p" as well.  */
elseif|else
if|if
condition|(
operator|!
name|done
operator|&&
name|object_scope
condition|)
block|{
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|scope
operator|=
name|object_scope
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|type_decl
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
name|none_type
argument_list|,
comment|/*check_dependency=*/
name|false
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
name|declarator_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|done
operator|=
name|true
expr_stmt|;
block|}
comment|/* Look in the surrounding context.  */
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|type_decl
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
name|none_type
argument_list|,
comment|/*check_dependency=*/
name|false
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
name|declarator_p
argument_list|)
expr_stmt|;
block|}
comment|/* If an error occurred, assume that the name of the 	   destructor is the same as the name of the qualifying 	   class.  That allows us to keep parsing after running 	   into ill-formed destructor names.  */
if|if
condition|(
name|type_decl
operator|==
name|error_mark_node
operator|&&
name|scope
condition|)
return|return
name|build_nt
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|scope
argument_list|)
return|;
elseif|else
if|if
condition|(
name|type_decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Check that destructor name and scope match.  */
if|if
condition|(
name|declarator_p
operator|&&
name|scope
operator|&&
operator|!
name|check_dtor_name
argument_list|(
name|scope
argument_list|,
name|type_decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cp_parser_uncommitted_to_tentative_parse_p
argument_list|(
name|parser
argument_list|)
condition|)
name|error
argument_list|(
literal|"declaration of %<~%T%> as member of %qT"
argument_list|,
name|type_decl
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* [class.dtor]  	   A typedef-name that names a class shall not be used as the 	   identifier in the declarator for a destructor declaration.  */
if|if
condition|(
name|declarator_p
operator|&&
operator|!
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|type_decl
argument_list|)
operator|&&
operator|!
name|DECL_SELF_REFERENCE_P
argument_list|(
name|type_decl
argument_list|)
operator|&&
operator|!
name|cp_parser_uncommitted_to_tentative_parse_p
argument_list|(
name|parser
argument_list|)
condition|)
name|error
argument_list|(
literal|"typedef-name %qD used as destructor declarator"
argument_list|,
name|type_decl
argument_list|)
expr_stmt|;
return|return
name|build_nt
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|type_decl
argument_list|)
argument_list|)
return|;
block|}
case|case
name|CPP_KEYWORD
case|:
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_OPERATOR
condition|)
block|{
name|tree
name|id
decl_stmt|;
comment|/* This could be a template-id, so we try that first.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try a template-id.  */
name|id
operator|=
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
name|template_keyword_p
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
name|declarator_p
argument_list|)
expr_stmt|;
comment|/* If that worked, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|id
return|;
comment|/* We still don't know whether we're looking at an 	     operator-function-id or a conversion-function-id.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try an operator-function-id.  */
name|id
operator|=
name|cp_parser_operator_function_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If that didn't work, try a conversion-function-id.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|id
operator|=
name|cp_parser_conversion_function_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
comment|/* Fall through.  */
default|default:
if|if
condition|(
name|optional_p
condition|)
return|return
name|NULL_TREE
return|;
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected unqualified-id"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an (optional) nested-name-specifier.     nested-name-specifier:      class-or-namespace-name :: nested-name-specifier [opt]      class-or-namespace-name :: template nested-name-specifier [opt]     PARSER->SCOPE should be set appropriately before this function is    called.  TYPENAME_KEYWORD_P is TRUE if the `typename' keyword is in    effect.  TYPE_P is TRUE if we non-type bindings should be ignored    in name lookups.     Sets PARSER->SCOPE to the class (TYPE) or namespace    (NAMESPACE_DECL) specified by the nested-name-specifier, or leaves    it unchanged if there is no nested-name-specifier.  Returns the new    scope iff there is a nested-name-specifier, or NULL_TREE otherwise.     If IS_DECLARATION is TRUE, the nested-name-specifier is known to be    part of a declaration and/or decl-specifier.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_nested_name_specifier_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|typename_keyword_p
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
name|type_p
parameter_list|,
name|bool
name|is_declaration
parameter_list|)
block|{
name|bool
name|success
init|=
name|false
decl_stmt|;
name|cp_token_position
name|start
init|=
literal|0
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Remember where the nested-name-specifier starts.  */
if|if
condition|(
name|cp_parser_uncommitted_to_tentative_parse_p
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|start
operator|=
name|cp_lexer_token_position
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|push_deferring_access_checks
argument_list|(
name|dk_deferred
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|new_scope
decl_stmt|;
name|tree
name|old_scope
decl_stmt|;
name|tree
name|saved_qualifying_scope
decl_stmt|;
name|bool
name|template_keyword_p
decl_stmt|;
comment|/* Spot cases that cannot be the beginning of a 	 nested-name-specifier.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token is CPP_NESTED_NAME_SPECIFIER, just process 	 the already parsed nested-name-specifier.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NESTED_NAME_SPECIFIER
condition|)
block|{
comment|/* Grab the nested-name-specifier and continue the loop.  */
name|cp_parser_pre_parsed_nested_name_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If we originally encountered this nested-name-specifier 	     with IS_DECLARATION set to false, we will not have 	     resolved TYPENAME_TYPEs, so we must do so here.  */
if|if
condition|(
name|is_declaration
operator|&&
name|TREE_CODE
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
name|new_scope
operator|=
name|resolve_typename_type
argument_list|(
name|parser
operator|->
name|scope
argument_list|,
comment|/*only_current_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_scope
operator|!=
name|error_mark_node
condition|)
name|parser
operator|->
name|scope
operator|=
name|new_scope
expr_stmt|;
block|}
name|success
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
comment|/* Spot cases that cannot be the beginning of a 	 nested-name-specifier.  On the second and subsequent times 	 through the loop, we look for the `template' keyword.  */
if|if
condition|(
name|success
operator|&&
name|token
operator|->
name|keyword
operator|==
name|RID_TEMPLATE
condition|)
empty_stmt|;
comment|/* A template-id can start a nested-name-specifier.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_TEMPLATE_ID
condition|)
empty_stmt|;
else|else
block|{
comment|/* If the next token is not an identifier, then it is 	     definitely not a class-or-namespace-name.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NAME
condition|)
break|break;
comment|/* If the following token is neither a `<' (to begin a 	     template-id), nor a `::', then we are not looking at a 	     nested-name-specifier.  */
name|token
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_SCOPE
operator|&&
operator|!
name|cp_parser_nth_token_starts_template_argument_list_p
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
break|break;
block|}
comment|/* The nested-name-specifier is optional, so we parse 	 tentatively.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the optional `template' keyword, if this isn't the 	 first time through the loop.  */
if|if
condition|(
name|success
condition|)
name|template_keyword_p
operator|=
name|cp_parser_optional_template_keyword
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|template_keyword_p
operator|=
name|false
expr_stmt|;
comment|/* Save the old scope since the name lookup we are about to do 	 might destroy it.  */
name|old_scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|saved_qualifying_scope
operator|=
name|parser
operator|->
name|qualifying_scope
expr_stmt|;
comment|/* In a declarator-id like "X<T>::I::Y<T>" we must be able to 	 look up names in "X<T>::I" in order to determine that "Y" is 	 a template.  So, if we have a typename at this point, we make 	 an effort to look through it.  */
if|if
condition|(
name|is_declaration
operator|&&
operator|!
name|typename_keyword_p
operator|&&
name|parser
operator|->
name|scope
operator|&&
name|TREE_CODE
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
name|parser
operator|->
name|scope
operator|=
name|resolve_typename_type
argument_list|(
name|parser
operator|->
name|scope
argument_list|,
comment|/*only_current_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Parse the qualifying entity.  */
name|new_scope
operator|=
name|cp_parser_class_or_namespace_name
argument_list|(
name|parser
argument_list|,
name|typename_keyword_p
argument_list|,
name|template_keyword_p
argument_list|,
name|check_dependency_p
argument_list|,
name|type_p
argument_list|,
name|is_declaration
argument_list|)
expr_stmt|;
comment|/* Look for the `::' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SCOPE
argument_list|,
literal|"`::'"
argument_list|)
expr_stmt|;
comment|/* If we found what we wanted, we keep going; otherwise, we're 	 done.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|bool
name|error_p
init|=
name|false
decl_stmt|;
comment|/* Restore the OLD_SCOPE since it was valid before the 	     failed attempt at finding the last 	     class-or-namespace-name.  */
name|parser
operator|->
name|scope
operator|=
name|old_scope
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|saved_qualifying_scope
expr_stmt|;
if|if
condition|(
name|cp_parser_uncommitted_to_tentative_parse_p
argument_list|(
name|parser
argument_list|)
condition|)
break|break;
comment|/* If the next token is an identifier, and the one after 	     that is a `::', then any valid interpretation would have 	     found a class-or-namespace-name.  */
while|while
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
operator|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|==
name|CPP_SCOPE
operator|)
operator|&&
operator|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|3
argument_list|)
operator|->
name|type
operator|!=
name|CPP_COMPL
operator|)
condition|)
block|{
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error_p
condition|)
block|{
if|if
condition|(
operator|!
name|token
operator|->
name|ambiguous_p
condition|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|ambiguous_decls
decl_stmt|;
name|decl
operator|=
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|token
operator|->
name|u
operator|.
name|value
argument_list|,
name|none_type
argument_list|,
comment|/*is_template=*/
name|false
argument_list|,
comment|/*is_namespace=*/
name|false
argument_list|,
comment|/*check_dependency=*/
name|true
argument_list|,
operator|&
name|ambiguous_decls
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|error
argument_list|(
literal|"%qD used without template parameters"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ambiguous_decls
condition|)
block|{
name|error
argument_list|(
literal|"reference to %qD is ambiguous"
argument_list|,
name|token
operator|->
name|u
operator|.
name|value
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|ambiguous_decls
argument_list|)
expr_stmt|;
name|decl
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|cp_parser_name_lookup_error
argument_list|(
name|parser
argument_list|,
name|token
operator|->
name|u
operator|.
name|value
argument_list|,
name|decl
argument_list|,
literal|"is not a class or namespace"
argument_list|)
expr_stmt|;
block|}
name|parser
operator|->
name|scope
operator|=
name|error_mark_node
expr_stmt|;
name|error_p
operator|=
name|true
expr_stmt|;
comment|/* Treat this as a successful nested-name-specifier 		     due to:  		     [basic.lookup.qual]  		     If the name found is not a class-name (clause 		     _class_) or namespace-name (_namespace.def_), the 		     program is ill-formed.  */
name|success
operator|=
name|true
expr_stmt|;
block|}
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* We've found one valid nested-name-specifier.  */
name|success
operator|=
name|true
expr_stmt|;
comment|/* Name lookup always gives us a DECL.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_scope
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|new_scope
operator|=
name|TREE_TYPE
argument_list|(
name|new_scope
argument_list|)
expr_stmt|;
comment|/* Uses of "template" must be followed by actual templates.  */
if|if
condition|(
name|template_keyword_p
operator|&&
operator|!
operator|(
name|CLASS_TYPE_P
argument_list|(
name|new_scope
argument_list|)
operator|&&
operator|(
operator|(
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|new_scope
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|new_scope
argument_list|)
argument_list|)
operator|)
operator|||
name|CLASSTYPE_IS_TEMPLATE
argument_list|(
name|new_scope
argument_list|)
operator|)
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|new_scope
argument_list|)
operator|==
name|TYPENAME_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|new_scope
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|)
operator|)
condition|)
name|pedwarn
argument_list|(
name|TYPE_P
argument_list|(
name|new_scope
argument_list|)
condition|?
literal|"%qT is not a template"
else|:
literal|"%qD is not a template"
argument_list|,
name|new_scope
argument_list|)
expr_stmt|;
comment|/* If it is a class scope, try to complete it; we are about to 	 be looking up names inside the class.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|new_scope
argument_list|)
comment|/* Since checking types for dependency can be expensive, 	     avoid doing it if the type is already complete.  */
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|new_scope
argument_list|)
comment|/* Do not try to complete dependent types.  */
operator|&&
operator|!
name|dependent_type_p
argument_list|(
name|new_scope
argument_list|)
condition|)
name|new_scope
operator|=
name|complete_type
argument_list|(
name|new_scope
argument_list|)
expr_stmt|;
comment|/* Make sure we look in the right scope the next time through 	 the loop.  */
name|parser
operator|->
name|scope
operator|=
name|new_scope
expr_stmt|;
block|}
comment|/* If parsing tentatively, replace the sequence of tokens that makes      up the nested-name-specifier with a CPP_NESTED_NAME_SPECIFIER      token.  That way, should we re-parse the token stream, we will      not have to repeat the effort required to do the parse, nor will      we issue duplicate error messages.  */
if|if
condition|(
name|success
operator|&&
name|start
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|cp_lexer_token_at
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* Reset the contents of the START token.  */
name|token
operator|->
name|type
operator|=
name|CPP_NESTED_NAME_SPECIFIER
expr_stmt|;
comment|/* Retrieve any deferred checks.  Do not pop this access checks yet 	 so the memory will not be reclaimed during token replacing below.  */
name|token
operator|->
name|u
operator|.
name|tree_check_value
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|tree_check
argument_list|)
expr_stmt|;
name|token
operator|->
name|u
operator|.
name|tree_check_value
operator|->
name|value
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|token
operator|->
name|u
operator|.
name|tree_check_value
operator|->
name|checks
operator|=
name|get_deferred_access_checks
argument_list|()
expr_stmt|;
name|token
operator|->
name|u
operator|.
name|tree_check_value
operator|->
name|qualifying_scope
operator|=
name|parser
operator|->
name|qualifying_scope
expr_stmt|;
name|token
operator|->
name|keyword
operator|=
name|RID_MAX
expr_stmt|;
comment|/* Purge all subsequent tokens.  */
name|cp_lexer_purge_tokens_after
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|start
condition|)
name|pop_to_parent_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|success
condition|?
name|parser
operator|->
name|scope
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Parse a nested-name-specifier.  See    cp_parser_nested_name_specifier_opt for details.  This function    behaves identically, except that it will an issue an error if no    nested-name-specifier is present.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_nested_name_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|typename_keyword_p
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
name|type_p
parameter_list|,
name|bool
name|is_declaration
parameter_list|)
block|{
name|tree
name|scope
decl_stmt|;
comment|/* Look for the nested-name-specifier.  */
name|scope
operator|=
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
name|typename_keyword_p
argument_list|,
name|check_dependency_p
argument_list|,
name|type_p
argument_list|,
name|is_declaration
argument_list|)
expr_stmt|;
comment|/* If it was not present, issue an error message.  */
if|if
condition|(
operator|!
name|scope
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected nested-name-specifier"
argument_list|)
expr_stmt|;
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|scope
return|;
block|}
end_function

begin_comment
comment|/* Parse a class-or-namespace-name.     class-or-namespace-name:      class-name      namespace-name     TYPENAME_KEYWORD_P is TRUE iff the `typename' keyword is in effect.    TEMPLATE_KEYWORD_P is TRUE iff the `template' keyword is in effect.    CHECK_DEPENDENCY_P is FALSE iff dependent names should be looked up.    TYPE_P is TRUE iff the next name should be taken as a class-name,    even the same name is declared to be another entity in the same    scope.     Returns the class (TYPE_DECL) or namespace (NAMESPACE_DECL)    specified by the class-or-namespace-name.  If neither is found the    ERROR_MARK_NODE is returned.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_class_or_namespace_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|typename_keyword_p
parameter_list|,
name|bool
name|template_keyword_p
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
name|type_p
parameter_list|,
name|bool
name|is_declaration
parameter_list|)
block|{
name|tree
name|saved_scope
decl_stmt|;
name|tree
name|saved_qualifying_scope
decl_stmt|;
name|tree
name|saved_object_scope
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|bool
name|only_class_p
decl_stmt|;
comment|/* Before we try to parse the class-name, we must save away the      current PARSER->SCOPE since cp_parser_class_name will destroy      it.  */
name|saved_scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|saved_qualifying_scope
operator|=
name|parser
operator|->
name|qualifying_scope
expr_stmt|;
name|saved_object_scope
operator|=
name|parser
operator|->
name|object_scope
expr_stmt|;
comment|/* Try for a class-name first.  If the SAVED_SCOPE is a type, then      there is no need to look for a namespace-name.  */
name|only_class_p
operator|=
name|template_keyword_p
operator|||
operator|(
name|saved_scope
operator|&&
name|TYPE_P
argument_list|(
name|saved_scope
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|only_class_p
condition|)
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|scope
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
name|typename_keyword_p
argument_list|,
name|template_keyword_p
argument_list|,
name|type_p
condition|?
name|class_type
else|:
name|none_type
argument_list|,
name|check_dependency_p
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
name|is_declaration
argument_list|)
expr_stmt|;
comment|/* If that didn't work, try for a namespace-name.  */
if|if
condition|(
operator|!
name|only_class_p
operator|&&
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* Restore the saved scope.  */
name|parser
operator|->
name|scope
operator|=
name|saved_scope
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|saved_qualifying_scope
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|saved_object_scope
expr_stmt|;
comment|/* If we are not looking at an identifier followed by the scope 	 resolution operator, then this is not part of a 	 nested-name-specifier.  (Note that this function is only used 	 to parse the components of a nested-name-specifier.)  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
operator|||
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|!=
name|CPP_SCOPE
condition|)
return|return
name|error_mark_node
return|;
name|scope
operator|=
name|cp_parser_namespace_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
return|return
name|scope
return|;
block|}
end_function

begin_comment
comment|/* Parse a postfix-expression.     postfix-expression:      primary-expression      postfix-expression [ expression ]      postfix-expression ( expression-list [opt] )      simple-type-specifier ( expression-list [opt] )      typename :: [opt] nested-name-specifier identifier        ( expression-list [opt] )      typename :: [opt] nested-name-specifier template [opt] template-id        ( expression-list [opt] )      postfix-expression . template [opt] id-expression      postfix-expression -> template [opt] id-expression      postfix-expression . pseudo-destructor-name      postfix-expression -> pseudo-destructor-name      postfix-expression ++      postfix-expression --      dynamic_cast< type-id> ( expression )      static_cast< type-id> ( expression )      reinterpret_cast< type-id> ( expression )      const_cast< type-id> ( expression )      typeid ( expression )      typeid ( type-id )     GNU Extension:     postfix-expression:      ( type-id ) { initializer-list , [opt] }     This extension is a GNU version of the C99 compound-literal    construct.  (The C99 grammar uses `type-name' instead of `type-id',    but they are essentially the same concept.)     If ADDRESS_P is true, the postfix expression is the operand of the    `&' operator.  CAST_P is true if this expression is the target of a    cast.     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_postfix_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|address_p
parameter_list|,
name|bool
name|cast_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|rid
name|keyword
decl_stmt|;
name|cp_id_kind
name|idk
init|=
name|CP_ID_KIND_NONE
decl_stmt|;
name|tree
name|postfix_expression
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Some of the productions are determined by keywords.  */
name|keyword
operator|=
name|token
operator|->
name|keyword
expr_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_DYNCAST
case|:
case|case
name|RID_STATCAST
case|:
case|case
name|RID_REINTCAST
case|:
case|case
name|RID_CONSTCAST
case|:
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|expression
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
comment|/* All of these can be handled in the same way from the point 	   of view of parsing.  Begin by consuming the token 	   identifying the cast.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* New types cannot be defined in the cast.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in casts"
expr_stmt|;
comment|/* Look for the opening `<'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|,
literal|"`<'"
argument_list|)
expr_stmt|;
comment|/* Parse the type to which we are casting.  */
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the closing `>'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_GREATER
argument_list|,
literal|"`>'"
argument_list|)
expr_stmt|;
comment|/* Restore the old message.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
comment|/* And the expression which is being cast.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
name|expression
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|true
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Only type conversions to integral or enumeration types 	   can be used in constant-expressions.  */
if|if
condition|(
operator|!
name|cast_valid_in_integral_constant_expression_p
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"a cast to a type other than an integral or "
literal|"enumeration type"
argument_list|)
operator|)
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_DYNCAST
case|:
name|postfix_expression
operator|=
name|build_dynamic_cast
argument_list|(
name|type
argument_list|,
name|expression
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_STATCAST
case|:
name|postfix_expression
operator|=
name|build_static_cast
argument_list|(
name|type
argument_list|,
name|expression
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_REINTCAST
case|:
name|postfix_expression
operator|=
name|build_reinterpret_cast
argument_list|(
name|type
argument_list|,
name|expression
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_CONSTCAST
case|:
name|postfix_expression
operator|=
name|build_const_cast
argument_list|(
name|type
argument_list|,
name|expression
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RID_TYPEID
case|:
block|{
name|tree
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
name|bool
name|saved_in_type_id_in_expr_p
decl_stmt|;
comment|/* Consume the `typeid' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the `(' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Types cannot be defined in a `typeid' expression.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in a `typeid\' expression"
expr_stmt|;
comment|/* We can't be sure yet whether we're looking at a type-id or an 	   expression.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try a type-id first.  */
name|saved_in_type_id_in_expr_p
operator|=
name|parser
operator|->
name|in_type_id_in_expr_p
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|true
expr_stmt|;
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|saved_in_type_id_in_expr_p
expr_stmt|;
comment|/* Look for the `)' token.  Otherwise, we can't be sure that 	   we're not looking at an expression: consider `typeid (int 	   (3))', for example.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* If all went well, simply lookup the type-id.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|postfix_expression
operator|=
name|get_typeid
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Otherwise, fall back to the expression variant.  */
else|else
block|{
name|tree
name|expression
decl_stmt|;
comment|/* Look for an expression.  */
name|expression
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Compute its typeid.  */
name|postfix_expression
operator|=
name|build_typeid
argument_list|(
name|expression
argument_list|)
expr_stmt|;
comment|/* Look for the `)' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the saved message.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
comment|/* `typeid' may not appear in an integral constant expression.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"`typeid' operator"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
break|break;
case|case
name|RID_TYPENAME
case|:
block|{
name|tree
name|type
decl_stmt|;
comment|/* The syntax permitted here is the same permitted for an 	   elaborated-type-specifier.  */
name|type
operator|=
name|cp_parser_elaborated_type_specifier
argument_list|(
name|parser
argument_list|,
comment|/*is_friend=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
expr_stmt|;
name|postfix_expression
operator|=
name|cp_parser_functional_cast
argument_list|(
name|parser
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|tree
name|type
decl_stmt|;
comment|/* If the next thing is a simple-type-specifier, we may be 	   looking at a functional cast.  We could also be looking at 	   an id-expression.  So, we try the functional cast, and if 	   that doesn't work we fall back to the primary-expression.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the simple-type-specifier.  */
name|type
operator|=
name|cp_parser_simple_type_specifier
argument_list|(
name|parser
argument_list|,
comment|/*decl_specs=*/
name|NULL
argument_list|,
name|CP_PARSER_FLAGS_NONE
argument_list|)
expr_stmt|;
comment|/* Parse the cast itself.  */
if|if
condition|(
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
name|postfix_expression
operator|=
name|cp_parser_functional_cast
argument_list|(
name|parser
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If that worked, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
break|break;
comment|/* If the functional-cast didn't work out, try a 	   compound-literal.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|initializer_list
operator|=
name|NULL
expr_stmt|;
name|bool
name|saved_in_type_id_in_expr_p
decl_stmt|;
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the type.  */
name|saved_in_type_id_in_expr_p
operator|=
name|parser
operator|->
name|in_type_id_in_expr_p
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|true
expr_stmt|;
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|saved_in_type_id_in_expr_p
expr_stmt|;
comment|/* Look for the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Look for the `{'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|,
literal|"`{'"
argument_list|)
expr_stmt|;
comment|/* If things aren't going well, there's no need to 	       keep going.  */
if|if
condition|(
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|bool
name|non_constant_p
decl_stmt|;
comment|/* Parse the initializer-list.  */
name|initializer_list
operator|=
name|cp_parser_initializer_list
argument_list|(
name|parser
argument_list|,
operator|&
name|non_constant_p
argument_list|)
expr_stmt|;
comment|/* Allow a trailing `,'.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the final `}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
block|}
comment|/* If that worked, we're definitely looking at a 	       compound-literal expression.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* Warn the user that a compound literal is not 		   allowed in standard C++.  */
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids compound-literals"
argument_list|)
expr_stmt|;
comment|/* For simplicitly, we disallow compound literals in 		   constant-expressions for simpliicitly.  We could 		   allow compound literals of integer type, whose 		   initializer was a constant, in constant 		   expressions.  Permitting that usage, as a further 		   extension, would not change the meaning of any 		   currently accepted programs.  (Of course, as 		   compound literals are not part of ISO C++, the 		   standard has nothing to say.)  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"non-constant compound literals"
argument_list|)
condition|)
block|{
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
comment|/* Form the representation of the compound-literal.  */
name|postfix_expression
operator|=
name|finish_compound_literal
argument_list|(
name|type
argument_list|,
name|initializer_list
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* It must be a primary-expression.  */
name|postfix_expression
operator|=
name|cp_parser_primary_expression
argument_list|(
name|parser
argument_list|,
name|address_p
argument_list|,
name|cast_p
argument_list|,
comment|/*template_arg_p=*/
name|false
argument_list|,
operator|&
name|idk
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Keep looping until the postfix-expression is complete.  */
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
name|idk
operator|==
name|CP_ID_KIND_UNQUALIFIED
operator|&&
name|TREE_CODE
argument_list|(
name|postfix_expression
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
comment|/* It is not a Koenig lookup function call.  */
name|postfix_expression
operator|=
name|unqualified_name_lookup_error
argument_list|(
name|postfix_expression
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_OPEN_SQUARE
case|:
name|postfix_expression
operator|=
name|cp_parser_postfix_open_square_expression
argument_list|(
name|parser
argument_list|,
name|postfix_expression
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
break|break;
case|case
name|CPP_OPEN_PAREN
case|:
comment|/* postfix-expression ( expression-list [opt] ) */
block|{
name|bool
name|koenig_p
decl_stmt|;
name|bool
name|is_builtin_constant_p
decl_stmt|;
name|bool
name|saved_integral_constant_expression_p
init|=
name|false
decl_stmt|;
name|bool
name|saved_non_integral_constant_expression_p
init|=
name|false
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|is_builtin_constant_p
operator|=
name|DECL_IS_BUILTIN_CONSTANT_P
argument_list|(
name|postfix_expression
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_builtin_constant_p
condition|)
block|{
comment|/* The whole point of __builtin_constant_p is to allow 		   non-constant expressions to appear as arguments.  */
name|saved_integral_constant_expression_p
operator|=
name|parser
operator|->
name|integral_constant_expression_p
expr_stmt|;
name|saved_non_integral_constant_expression_p
operator|=
name|parser
operator|->
name|non_integral_constant_expression_p
expr_stmt|;
name|parser
operator|->
name|integral_constant_expression_p
operator|=
name|false
expr_stmt|;
block|}
name|args
operator|=
operator|(
name|cp_parser_parenthesized_expression_list
argument_list|(
name|parser
argument_list|,
comment|/*is_attribute_list=*/
name|false
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|,
comment|/*non_constant_p=*/
name|NULL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|is_builtin_constant_p
condition|)
block|{
name|parser
operator|->
name|integral_constant_expression_p
operator|=
name|saved_integral_constant_expression_p
expr_stmt|;
name|parser
operator|->
name|non_integral_constant_expression_p
operator|=
name|saved_non_integral_constant_expression_p
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|==
name|error_mark_node
condition|)
block|{
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
comment|/* Function calls are not permitted in 	       constant-expressions.  */
if|if
condition|(
operator|!
name|builtin_valid_in_constant_expr_p
argument_list|(
name|postfix_expression
argument_list|)
operator|&&
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"a function call"
argument_list|)
condition|)
block|{
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
name|koenig_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|idk
operator|==
name|CP_ID_KIND_UNQUALIFIED
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|postfix_expression
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|args
condition|)
block|{
name|koenig_p
operator|=
name|true
expr_stmt|;
name|postfix_expression
operator|=
name|perform_koenig_lookup
argument_list|(
name|postfix_expression
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
name|postfix_expression
operator|=
name|unqualified_fn_lookup_error
argument_list|(
name|postfix_expression
argument_list|)
expr_stmt|;
block|}
comment|/* We do not perform argument-dependent lookup if 		   normal lookup finds a non-function, in accordance 		   with the expected resolution of DR 218.  */
elseif|else
if|if
condition|(
name|args
operator|&&
name|is_overloaded_fn
argument_list|(
name|postfix_expression
argument_list|)
condition|)
block|{
name|tree
name|fn
init|=
name|get_first_fn
argument_list|(
name|postfix_expression
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|fn
operator|=
name|OVL_CURRENT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only do argument dependent lookup if regular 		       lookup does not find a set of member functions. 		       [basic.lookup.koenig]/2a  */
if|if
condition|(
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|koenig_p
operator|=
name|true
expr_stmt|;
name|postfix_expression
operator|=
name|perform_koenig_lookup
argument_list|(
name|postfix_expression
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|postfix_expression
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|instance
init|=
name|TREE_OPERAND
argument_list|(
name|postfix_expression
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
name|TREE_OPERAND
argument_list|(
name|postfix_expression
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|processing_template_decl
operator|&&
operator|(
name|type_dependent_expression_p
argument_list|(
name|instance
argument_list|)
operator|||
operator|(
operator|!
name|BASELINK_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|FIELD_DECL
operator|)
operator|||
name|type_dependent_expression_p
argument_list|(
name|fn
argument_list|)
operator|||
name|any_type_dependent_arguments_p
argument_list|(
name|args
argument_list|)
operator|)
condition|)
block|{
name|postfix_expression
operator|=
name|build_min_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|postfix_expression
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|BASELINK_P
argument_list|(
name|fn
argument_list|)
condition|)
name|postfix_expression
operator|=
operator|(
name|build_new_method_call
argument_list|(
name|instance
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
operator|(
name|idk
operator|==
name|CP_ID_KIND_QUALIFIED
condition|?
name|LOOKUP_NONVIRTUAL
else|:
name|LOOKUP_NORMAL
operator|)
argument_list|,
comment|/*fn_p=*/
name|NULL
argument_list|)
operator|)
expr_stmt|;
else|else
name|postfix_expression
operator|=
name|finish_call_expr
argument_list|(
name|postfix_expression
argument_list|,
name|args
argument_list|,
comment|/*disallow_virtual=*/
name|false
argument_list|,
comment|/*koenig_p=*/
name|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|postfix_expression
argument_list|)
operator|==
name|OFFSET_REF
operator|||
name|TREE_CODE
argument_list|(
name|postfix_expression
argument_list|)
operator|==
name|MEMBER_REF
operator|||
name|TREE_CODE
argument_list|(
name|postfix_expression
argument_list|)
operator|==
name|DOTSTAR_EXPR
condition|)
name|postfix_expression
operator|=
operator|(
name|build_offset_ref_call_from_tree
argument_list|(
name|postfix_expression
argument_list|,
name|args
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|idk
operator|==
name|CP_ID_KIND_QUALIFIED
condition|)
comment|/* A call to a static class member, or a namespace-scope 		 function.  */
name|postfix_expression
operator|=
name|finish_call_expr
argument_list|(
name|postfix_expression
argument_list|,
name|args
argument_list|,
comment|/*disallow_virtual=*/
name|true
argument_list|,
name|koenig_p
argument_list|)
expr_stmt|;
else|else
comment|/* All other function calls.  */
name|postfix_expression
operator|=
name|finish_call_expr
argument_list|(
name|postfix_expression
argument_list|,
name|args
argument_list|,
comment|/*disallow_virtual=*/
name|false
argument_list|,
name|koenig_p
argument_list|)
expr_stmt|;
comment|/* The POSTFIX_EXPRESSION is certainly no longer an id.  */
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
block|}
break|break;
case|case
name|CPP_DOT
case|:
case|case
name|CPP_DEREF
case|:
comment|/* postfix-expression . template [opt] id-expression 	     postfix-expression . pseudo-destructor-name 	     postfix-expression -> template [opt] id-expression 	     postfix-expression -> pseudo-destructor-name */
comment|/* Consume the `.' or `->' operator.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|postfix_expression
operator|=
name|cp_parser_postfix_dot_deref_expression
argument_list|(
name|parser
argument_list|,
name|token
operator|->
name|type
argument_list|,
name|postfix_expression
argument_list|,
name|false
argument_list|,
operator|&
name|idk
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_PLUS_PLUS
case|:
comment|/* postfix-expression ++  */
comment|/* Consume the `++' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Generate a representation for the complete expression.  */
name|postfix_expression
operator|=
name|finish_increment_expr
argument_list|(
name|postfix_expression
argument_list|,
name|POSTINCREMENT_EXPR
argument_list|)
expr_stmt|;
comment|/* Increments may not appear in constant-expressions.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"an increment"
argument_list|)
condition|)
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
break|break;
case|case
name|CPP_MINUS_MINUS
case|:
comment|/* postfix-expression -- */
comment|/* Consume the `--' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Generate a representation for the complete expression.  */
name|postfix_expression
operator|=
name|finish_increment_expr
argument_list|(
name|postfix_expression
argument_list|,
name|POSTDECREMENT_EXPR
argument_list|)
expr_stmt|;
comment|/* Decrements may not appear in constant-expressions.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"a decrement"
argument_list|)
condition|)
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
break|break;
default|default:
return|return
name|postfix_expression
return|;
block|}
block|}
comment|/* We should never get here.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of cp_parser_postfix_expression that also gets hijacked    by cp_parser_builtin_offsetof.  We're looking for       postfix-expression [ expression ]     FOR_OFFSETOF is set if we're being called in that context, which    changes how we deal with integer constant expressions.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_postfix_open_square_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|postfix_expression
parameter_list|,
name|bool
name|for_offsetof
parameter_list|)
block|{
name|tree
name|index
decl_stmt|;
comment|/* Consume the `[' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the index expression.  */
comment|/* ??? For offsetof, there is a question of what to allow here.  If      offsetof is not being used in an integral constant expression context,      then we *could* get the right answer by computing the value at runtime.      If we are in an integral constant expression context, then we might      could accept any constant expression; hard to say without analysis.      Rather than open the barn door too wide right away, allow only integer      constant expressions here.  */
if|if
condition|(
name|for_offsetof
condition|)
name|index
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|index
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the closing `]'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"`]'"
argument_list|)
expr_stmt|;
comment|/* Build the ARRAY_REF.  */
name|postfix_expression
operator|=
name|grok_array_decl
argument_list|(
name|postfix_expression
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* When not doing offsetof, array references are not permitted in      constant-expressions.  */
if|if
condition|(
operator|!
name|for_offsetof
operator|&&
operator|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"an array reference"
argument_list|)
operator|)
condition|)
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|postfix_expression
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of cp_parser_postfix_expression that also gets hijacked    by cp_parser_builtin_offsetof.  We're looking for       postfix-expression . template [opt] id-expression      postfix-expression . pseudo-destructor-name      postfix-expression -> template [opt] id-expression      postfix-expression -> pseudo-destructor-name     FOR_OFFSETOF is set if we're being called in that context.  That sorta    limits what of the above we'll actually accept, but nevermind.    TOKEN_TYPE is the "." or "->" token, which will already have been    removed from the stream.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_postfix_dot_deref_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|cpp_ttype
name|token_type
parameter_list|,
name|tree
name|postfix_expression
parameter_list|,
name|bool
name|for_offsetof
parameter_list|,
name|cp_id_kind
modifier|*
name|idk
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
name|bool
name|dependent_p
decl_stmt|;
name|bool
name|pseudo_destructor_p
decl_stmt|;
name|tree
name|scope
init|=
name|NULL_TREE
decl_stmt|;
comment|/* If this is a `->' operator, dereference the pointer.  */
if|if
condition|(
name|token_type
operator|==
name|CPP_DEREF
condition|)
name|postfix_expression
operator|=
name|build_x_arrow
argument_list|(
name|postfix_expression
argument_list|)
expr_stmt|;
comment|/* Check to see whether or not the expression is type-dependent.  */
name|dependent_p
operator|=
name|type_dependent_expression_p
argument_list|(
name|postfix_expression
argument_list|)
expr_stmt|;
comment|/* The identifier following the `->' or `.' is not qualified.  */
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
comment|/* Enter the scope corresponding to the type of the object      given by the POSTFIX_EXPRESSION.  */
if|if
condition|(
operator|!
name|dependent_p
operator|&&
name|TREE_TYPE
argument_list|(
name|postfix_expression
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|scope
operator|=
name|TREE_TYPE
argument_list|(
name|postfix_expression
argument_list|)
expr_stmt|;
comment|/* According to the standard, no expression should ever have 	 reference type.  Unfortunately, we do not currently match 	 the standard in this respect in that our internal representation 	 of an expression may have reference type even when the standard 	 says it does not.  Therefore, we have to manually obtain the 	 underlying type here.  */
name|scope
operator|=
name|non_reference
argument_list|(
name|scope
argument_list|)
expr_stmt|;
comment|/* The type of the POSTFIX_EXPRESSION must be complete.  */
if|if
condition|(
name|scope
operator|==
name|unknown_type_node
condition|)
block|{
name|error
argument_list|(
literal|"%qE does not have class type"
argument_list|,
name|postfix_expression
argument_list|)
expr_stmt|;
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|scope
operator|=
name|complete_type_or_else
argument_list|(
name|scope
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Let the name lookup machinery know that we are processing a 	 class member access expression.  */
name|parser
operator|->
name|context
operator|->
name|object_type
operator|=
name|scope
expr_stmt|;
comment|/* If something went wrong, we want to be able to discern that case, 	 as opposed to the case where there was no SCOPE due to the type 	 of expression being dependent.  */
if|if
condition|(
operator|!
name|scope
condition|)
name|scope
operator|=
name|error_mark_node
expr_stmt|;
comment|/* If the SCOPE was erroneous, make the various semantic analysis 	 functions exit quickly -- and without issuing additional error 	 messages.  */
if|if
condition|(
name|scope
operator|==
name|error_mark_node
condition|)
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Assume this expression is not a pseudo-destructor access.  */
name|pseudo_destructor_p
operator|=
name|false
expr_stmt|;
comment|/* If the SCOPE is a scalar type, then, if this is a valid program,      we must be looking at a pseudo-destructor-name.  */
if|if
condition|(
name|scope
operator|&&
name|SCALAR_TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|tree
name|s
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the pseudo-destructor-name.  */
name|s
operator|=
name|NULL_TREE
expr_stmt|;
name|cp_parser_pseudo_destructor_name
argument_list|(
name|parser
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|pseudo_destructor_p
operator|=
name|true
expr_stmt|;
name|postfix_expression
operator|=
name|finish_pseudo_destructor_expr
argument_list|(
name|postfix_expression
argument_list|,
name|s
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|pseudo_destructor_p
condition|)
block|{
comment|/* If the SCOPE is not a scalar type, we are looking at an 	 ordinary class member access expression, rather than a 	 pseudo-destructor-name.  */
name|bool
name|template_p
decl_stmt|;
comment|/* Parse the id-expression.  */
name|name
operator|=
operator|(
name|cp_parser_id_expression
argument_list|(
name|parser
argument_list|,
name|cp_parser_optional_template_keyword
argument_list|(
name|parser
argument_list|)
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
operator|&
name|template_p
argument_list|,
comment|/*declarator_p=*/
name|false
argument_list|,
comment|/*optional_p=*/
name|false
argument_list|)
operator|)
expr_stmt|;
comment|/* In general, build a SCOPE_REF if the member name is qualified. 	 However, if the name was not dependent and has already been 	 resolved; there is no need to build the SCOPE_REF.  For example;  	     struct X { void f(); }; 	     template<typename T> void f(T* t) { t->X::f(); }  	 Even though "t" is dependent, "X::f" is not and has been resolved 	 to a BASELINK; there is no need to include scope information.  */
comment|/* But we do need to remember that there was an explicit scope for 	 virtual function calls.  */
if|if
condition|(
name|parser
operator|->
name|scope
condition|)
operator|*
name|idk
operator|=
name|CP_ID_KIND_QUALIFIED
expr_stmt|;
comment|/* If the name is a template-id that names a type, we will get a 	 TYPE_DECL here.  That is invalid code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of %qD"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|name
operator|!=
name|error_mark_node
operator|&&
operator|!
name|BASELINK_P
argument_list|(
name|name
argument_list|)
operator|&&
name|parser
operator|->
name|scope
condition|)
block|{
name|name
operator|=
name|build_qualified_name
argument_list|(
comment|/*type=*/
name|NULL_TREE
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|name
argument_list|,
name|template_p
argument_list|)
expr_stmt|;
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|scope
operator|&&
name|name
operator|&&
name|BASELINK_P
argument_list|(
name|name
argument_list|)
condition|)
name|adjust_result_of_qualified_name_lookup
argument_list|(
name|name
argument_list|,
name|BINFO_TYPE
argument_list|(
name|BASELINK_ACCESS_BINFO
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|postfix_expression
operator|=
name|finish_class_member_access_expr
argument_list|(
name|postfix_expression
argument_list|,
name|name
argument_list|,
name|template_p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We no longer need to look up names in the scope of the object on      the left-hand side of the `.' or `->' operator.  */
name|parser
operator|->
name|context
operator|->
name|object_type
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Outside of offsetof, these operators may not appear in      constant-expressions.  */
if|if
condition|(
operator|!
name|for_offsetof
operator|&&
operator|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
name|token_type
operator|==
name|CPP_DEREF
condition|?
literal|"'->'"
else|:
literal|"`.'"
argument_list|)
operator|)
condition|)
name|postfix_expression
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|postfix_expression
return|;
block|}
end_function

begin_comment
comment|/* Parse a parenthesized expression-list.     expression-list:      assignment-expression      expression-list, assignment-expression     attribute-list:      expression-list      identifier      identifier, expression-list     CAST_P is true if this expression is the target of a cast.     Returns a TREE_LIST.  The TREE_VALUE of each node is a    representation of an assignment-expression.  Note that a TREE_LIST    is returned even if there is only a single expression in the list.    error_mark_node is returned if the ( and or ) are    missing. NULL_TREE is returned on no expressions. The parentheses    are eaten. IS_ATTRIBUTE_LIST is true if this is really an attribute    list being parsed.  If NON_CONSTANT_P is non-NULL, *NON_CONSTANT_P    indicates whether or not all of the expressions in the list were    constant.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_parenthesized_expression_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|is_attribute_list
parameter_list|,
name|bool
name|cast_p
parameter_list|,
name|bool
modifier|*
name|non_constant_p
parameter_list|)
block|{
name|tree
name|expression_list
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|fold_expr_p
init|=
name|is_attribute_list
decl_stmt|;
name|tree
name|identifier
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Assume all the expressions will be constant.  */
if|if
condition|(
name|non_constant_p
condition|)
operator|*
name|non_constant_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Consume expressions until there are no more.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|expr
decl_stmt|;
comment|/* At the beginning of attribute lists, check to see if the 	   next token is an identifier.  */
if|if
condition|(
name|is_attribute_list
operator|&&
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Consume the identifier.  */
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Save the identifier.  */
name|identifier
operator|=
name|token
operator|->
name|u
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* Parse the next assignment-expression.  */
if|if
condition|(
name|non_constant_p
condition|)
block|{
name|bool
name|expr_non_constant_p
decl_stmt|;
name|expr
operator|=
operator|(
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant_p=*/
name|true
argument_list|,
operator|&
name|expr_non_constant_p
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|expr_non_constant_p
condition|)
operator|*
name|non_constant_p
operator|=
name|true
expr_stmt|;
block|}
else|else
name|expr
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|,
name|cast_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|fold_expr_p
condition|)
name|expr
operator|=
name|fold_non_dependent_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Add it to the list.  We add error_mark_node 		expressions to the list, so that we can still tell if 		the correct form for a parenthesized expression-list 		is found. That gives better errors.  */
name|expression_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|expression_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
goto|goto
name|skip_comma
goto|;
block|}
comment|/* After the first item, attribute lists look the same as 	   expression lists.  */
name|is_attribute_list
operator|=
name|false
expr_stmt|;
name|get_comma
label|:
empty_stmt|;
comment|/* If the next token isn't a `,', then we are done.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
comment|/* Otherwise, consume the `,' and keep going.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
block|{
name|int
name|ending
decl_stmt|;
name|skip_comma
label|:
empty_stmt|;
comment|/* We try and resync to an unnested comma, as that will give the 	 user better diagnostics.  */
name|ending
operator|=
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
comment|/*recovering=*/
name|true
argument_list|,
comment|/*or_comma=*/
name|true
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ending
operator|<
literal|0
condition|)
goto|goto
name|get_comma
goto|;
if|if
condition|(
operator|!
name|ending
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* We built up the list in reverse order so we must reverse it now.  */
name|expression_list
operator|=
name|nreverse
argument_list|(
name|expression_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier
condition|)
name|expression_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|identifier
argument_list|,
name|expression_list
argument_list|)
expr_stmt|;
return|return
name|expression_list
return|;
block|}
end_function

begin_comment
comment|/* Parse a pseudo-destructor-name.     pseudo-destructor-name:      :: [opt] nested-name-specifier [opt] type-name :: ~ type-name      :: [opt] nested-name-specifier template template-id :: ~ type-name      :: [opt] nested-name-specifier [opt] ~ type-name     If either of the first two productions is used, sets *SCOPE to the    TYPE specified before the final `::'.  Otherwise, *SCOPE is set to    NULL_TREE.  *TYPE is set to the TYPE_DECL for the final type-name,    or ERROR_MARK_NODE if the parse fails.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_pseudo_destructor_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
modifier|*
name|scope
parameter_list|,
name|tree
modifier|*
name|type
parameter_list|)
block|{
name|bool
name|nested_name_specifier_p
decl_stmt|;
comment|/* Assume that things will not work out.  */
operator|*
name|type
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Look for the optional `::' operator.  */
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Look for the optional nested-name-specifier.  */
name|nested_name_specifier_p
operator|=
operator|(
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Now, if we saw a nested-name-specifier, we might be doing the      second production.  */
if|if
condition|(
name|nested_name_specifier_p
operator|&&
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TEMPLATE
argument_list|)
condition|)
block|{
comment|/* Consume the `template' keyword.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the template-id.  */
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|true
argument_list|,
comment|/*check_dependency_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Look for the `::' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SCOPE
argument_list|,
literal|"`::'"
argument_list|)
expr_stmt|;
block|}
comment|/* If the next token is not a `~', then there might be some      additional qualification.  */
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMPL
argument_list|)
condition|)
block|{
comment|/* Look for the type-name.  */
operator|*
name|scope
operator|=
name|TREE_TYPE
argument_list|(
name|cp_parser_type_name
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|scope
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* If we don't have ::~, then something has gone wrong.  Since 	 the only caller of this function is looking for something 	 after `.' or `->' after a scalar type, most likely the 	 program is trying to get a member of a non-aggregate 	 type.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
operator|||
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|!=
name|CPP_COMPL
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"request for member of non-aggregate type"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Look for the `::' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SCOPE
argument_list|,
literal|"`::'"
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Look for the `~'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COMPL
argument_list|,
literal|"`~'"
argument_list|)
expr_stmt|;
comment|/* Look for the type-name again.  We are not responsible for      checking that it matches the first type-name.  */
operator|*
name|type
operator|=
name|cp_parser_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a unary-expression.     unary-expression:      postfix-expression      ++ cast-expression      -- cast-expression      unary-operator cast-expression      sizeof unary-expression      sizeof ( type-id )      new-expression      delete-expression     GNU Extensions:     unary-expression:      __extension__ cast-expression      __alignof__ unary-expression      __alignof__ ( type-id )      __real__ cast-expression      __imag__ cast-expression&& identifier     ADDRESS_P is true iff the unary-expression is appearing as the    operand of the `&' operator.   CAST_P is true if this expression is    the target of a cast.     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_unary_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|address_p
parameter_list|,
name|bool
name|cast_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|tree_code
name|unary_operator
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Some keywords give away the kind of expression.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_KEYWORD
condition|)
block|{
name|enum
name|rid
name|keyword
init|=
name|token
operator|->
name|keyword
decl_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_ALIGNOF
case|:
case|case
name|RID_SIZEOF
case|:
block|{
name|tree
name|operand
decl_stmt|;
name|enum
name|tree_code
name|op
decl_stmt|;
name|op
operator|=
name|keyword
operator|==
name|RID_ALIGNOF
condition|?
name|ALIGNOF_EXPR
else|:
name|SIZEOF_EXPR
expr_stmt|;
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the operand.  */
name|operand
operator|=
name|cp_parser_sizeof_operand
argument_list|(
name|parser
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|operand
argument_list|)
condition|)
return|return
name|cxx_sizeof_or_alignof_type
argument_list|(
name|operand
argument_list|,
name|op
argument_list|,
name|true
argument_list|)
return|;
else|else
return|return
name|cxx_sizeof_or_alignof_expr
argument_list|(
name|operand
argument_list|,
name|op
argument_list|)
return|;
block|}
case|case
name|RID_NEW
case|:
return|return
name|cp_parser_new_expression
argument_list|(
name|parser
argument_list|)
return|;
case|case
name|RID_DELETE
case|:
return|return
name|cp_parser_delete_expression
argument_list|(
name|parser
argument_list|)
return|;
case|case
name|RID_EXTENSION
case|:
block|{
comment|/* The saved value of the PEDANTIC flag.  */
name|int
name|saved_pedantic
decl_stmt|;
name|tree
name|expr
decl_stmt|;
comment|/* Save away the PEDANTIC flag.  */
name|cp_parser_extension_opt
argument_list|(
name|parser
argument_list|,
operator|&
name|saved_pedantic
argument_list|)
expr_stmt|;
comment|/* Parse the cast-expression.  */
name|expr
operator|=
name|cp_parser_simple_cast_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Restore the PEDANTIC flag.  */
name|pedantic
operator|=
name|saved_pedantic
expr_stmt|;
return|return
name|expr
return|;
block|}
case|case
name|RID_REALPART
case|:
case|case
name|RID_IMAGPART
case|:
block|{
name|tree
name|expression
decl_stmt|;
comment|/* Consume the `__real__' or `__imag__' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the cast-expression.  */
name|expression
operator|=
name|cp_parser_simple_cast_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Create the complete representation.  */
return|return
name|build_x_unary_op
argument_list|(
operator|(
name|keyword
operator|==
name|RID_REALPART
condition|?
name|REALPART_EXPR
else|:
name|IMAGPART_EXPR
operator|)
argument_list|,
name|expression
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Look for the `:: new' and `:: delete', which also signal the      beginning of a new-expression, or delete-expression,      respectively.  If the next token is `::', then it might be one of      these.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
condition|)
block|{
name|enum
name|rid
name|keyword
decl_stmt|;
comment|/* See if the token after the `::' is one of the keywords in 	 which we're interested.  */
name|keyword
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|keyword
expr_stmt|;
comment|/* If it's `new', we have a new-expression.  */
if|if
condition|(
name|keyword
operator|==
name|RID_NEW
condition|)
return|return
name|cp_parser_new_expression
argument_list|(
name|parser
argument_list|)
return|;
comment|/* Similarly, for `delete'.  */
elseif|else
if|if
condition|(
name|keyword
operator|==
name|RID_DELETE
condition|)
return|return
name|cp_parser_delete_expression
argument_list|(
name|parser
argument_list|)
return|;
block|}
comment|/* Look for a unary operator.  */
name|unary_operator
operator|=
name|cp_parser_unary_operator
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|/* The `++' and `--' operators can be handled similarly, even though      they are not technically unary-operators in the grammar.  */
if|if
condition|(
name|unary_operator
operator|==
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PLUS_PLUS
condition|)
name|unary_operator
operator|=
name|PREINCREMENT_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_MINUS_MINUS
condition|)
name|unary_operator
operator|=
name|PREDECREMENT_EXPR
expr_stmt|;
comment|/* Handle the GNU address-of-label extension.  */
elseif|else
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|token
operator|->
name|type
operator|==
name|CPP_AND_AND
condition|)
block|{
name|tree
name|identifier
decl_stmt|;
comment|/* Consume the '&&' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the identifier.  */
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Create an expression representing the address.  */
return|return
name|finish_label_address_expr
argument_list|(
name|identifier
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|unary_operator
operator|!=
name|ERROR_MARK
condition|)
block|{
name|tree
name|cast_expression
decl_stmt|;
name|tree
name|expression
init|=
name|error_mark_node
decl_stmt|;
specifier|const
name|char
modifier|*
name|non_constant_p
init|=
name|NULL
decl_stmt|;
comment|/* Consume the operator token.  */
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the cast-expression.  */
name|cast_expression
operator|=
name|cp_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|unary_operator
operator|==
name|ADDR_EXPR
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Now, build an appropriate representation.  */
switch|switch
condition|(
name|unary_operator
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
name|non_constant_p
operator|=
literal|"`*'"
expr_stmt|;
name|expression
operator|=
name|build_x_indirect_ref
argument_list|(
name|cast_expression
argument_list|,
literal|"unary *"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
name|non_constant_p
operator|=
literal|"`&'"
expr_stmt|;
comment|/* Fall through.  */
case|case
name|BIT_NOT_EXPR
case|:
name|expression
operator|=
name|build_x_unary_op
argument_list|(
name|unary_operator
argument_list|,
name|cast_expression
argument_list|)
expr_stmt|;
break|break;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
name|non_constant_p
operator|=
operator|(
name|unary_operator
operator|==
name|PREINCREMENT_EXPR
condition|?
literal|"`++'"
else|:
literal|"`--'"
operator|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|UNARY_PLUS_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
name|expression
operator|=
name|finish_unary_op_expr
argument_list|(
name|unary_operator
argument_list|,
name|cast_expression
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|non_constant_p
operator|&&
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
name|non_constant_p
argument_list|)
condition|)
name|expression
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|expression
return|;
block|}
return|return
name|cp_parser_postfix_expression
argument_list|(
name|parser
argument_list|,
name|address_p
argument_list|,
name|cast_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns ERROR_MARK if TOKEN is not a unary-operator.  If TOKEN is a    unary-operator, the corresponding tree code is returned.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|cp_parser_unary_operator
parameter_list|(
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_MULT
case|:
return|return
name|INDIRECT_REF
return|;
case|case
name|CPP_AND
case|:
return|return
name|ADDR_EXPR
return|;
case|case
name|CPP_PLUS
case|:
return|return
name|UNARY_PLUS_EXPR
return|;
case|case
name|CPP_MINUS
case|:
return|return
name|NEGATE_EXPR
return|;
case|case
name|CPP_NOT
case|:
return|return
name|TRUTH_NOT_EXPR
return|;
case|case
name|CPP_COMPL
case|:
return|return
name|BIT_NOT_EXPR
return|;
default|default:
return|return
name|ERROR_MARK
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a new-expression.     new-expression:      :: [opt] new new-placement [opt] new-type-id new-initializer [opt]      :: [opt] new new-placement [opt] ( type-id ) new-initializer [opt]     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_new_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|bool
name|global_scope_p
decl_stmt|;
name|tree
name|placement
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|initializer
decl_stmt|;
name|tree
name|nelts
decl_stmt|;
comment|/* Look for the optional `::' operator.  */
name|global_scope_p
operator|=
operator|(
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Look for the `new' operator.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_NEW
argument_list|,
literal|"`new'"
argument_list|)
expr_stmt|;
comment|/* There's no easy way to tell a new-placement from the      `( type-id )' construct.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for a new-placement.  */
name|placement
operator|=
name|cp_parser_new_placement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If that didn't work out, there's no new-placement.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|placement
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If the next token is a `(', then we have a parenthesized      type-id.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the type-id.  */
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the closing `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* There should not be a direct-new-declarator in this production, 	 but GCC used to allowed this, so we check and emit a sensible error 	 message for this case.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"array bound forbidden after parenthesized type-id"
argument_list|)
expr_stmt|;
name|inform
argument_list|(
literal|"try removing the parentheses around the type-id"
argument_list|)
expr_stmt|;
name|cp_parser_direct_new_declarator
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|nelts
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Otherwise, there must be a new-type-id.  */
else|else
name|type
operator|=
name|cp_parser_new_type_id
argument_list|(
name|parser
argument_list|,
operator|&
name|nelts
argument_list|)
expr_stmt|;
comment|/* If the next token is a `(', then we have a new-initializer.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
name|initializer
operator|=
name|cp_parser_new_initializer
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|initializer
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* A new-expression may not appear in an integral constant      expression.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"`new'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Create a representation of the new-expression.  */
return|return
name|build_new
argument_list|(
name|placement
argument_list|,
name|type
argument_list|,
name|nelts
argument_list|,
name|initializer
argument_list|,
name|global_scope_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a new-placement.     new-placement:      ( expression-list )     Returns the same representation as for an expression-list.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_new_placement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|expression_list
decl_stmt|;
comment|/* Parse the expression-list.  */
name|expression_list
operator|=
operator|(
name|cp_parser_parenthesized_expression_list
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|,
comment|/*non_constant_p=*/
name|NULL
argument_list|)
operator|)
expr_stmt|;
return|return
name|expression_list
return|;
block|}
end_function

begin_comment
comment|/* Parse a new-type-id.     new-type-id:      type-specifier-seq new-declarator [opt]     Returns the TYPE allocated.  If the new-type-id indicates an array    type, *NELTS is set to the number of elements in the last array    bound; the TYPE will not include the last array bound.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_new_type_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
modifier|*
name|nelts
parameter_list|)
block|{
name|cp_decl_specifier_seq
name|type_specifier_seq
decl_stmt|;
name|cp_declarator
modifier|*
name|new_declarator
decl_stmt|;
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
name|cp_declarator
modifier|*
name|outer_declarator
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* The type-specifier sequence must not contain type definitions.      (It cannot contain declarations of new types either, but if they      are not definitions we will catch that because they are not      complete.)  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in a new-type-id"
expr_stmt|;
comment|/* Parse the type-specifier-seq.  */
name|cp_parser_type_specifier_seq
argument_list|(
name|parser
argument_list|,
comment|/*is_condition=*/
name|false
argument_list|,
operator|&
name|type_specifier_seq
argument_list|)
expr_stmt|;
comment|/* Restore the old message.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
comment|/* Parse the new-declarator.  */
name|new_declarator
operator|=
name|cp_parser_new_declarator_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Determine the number of elements in the last array dimension, if      any.  */
operator|*
name|nelts
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Skip down to the last array dimension.  */
name|declarator
operator|=
name|new_declarator
expr_stmt|;
name|outer_declarator
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|declarator
operator|&&
operator|(
name|declarator
operator|->
name|kind
operator|==
name|cdk_pointer
operator|||
name|declarator
operator|->
name|kind
operator|==
name|cdk_ptrmem
operator|)
condition|)
block|{
name|outer_declarator
operator|=
name|declarator
expr_stmt|;
name|declarator
operator|=
name|declarator
operator|->
name|declarator
expr_stmt|;
block|}
while|while
condition|(
name|declarator
operator|&&
name|declarator
operator|->
name|kind
operator|==
name|cdk_array
operator|&&
name|declarator
operator|->
name|declarator
operator|&&
name|declarator
operator|->
name|declarator
operator|->
name|kind
operator|==
name|cdk_array
condition|)
block|{
name|outer_declarator
operator|=
name|declarator
expr_stmt|;
name|declarator
operator|=
name|declarator
operator|->
name|declarator
expr_stmt|;
block|}
if|if
condition|(
name|declarator
operator|&&
name|declarator
operator|->
name|kind
operator|==
name|cdk_array
condition|)
block|{
operator|*
name|nelts
operator|=
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|bounds
expr_stmt|;
if|if
condition|(
operator|*
name|nelts
operator|==
name|error_mark_node
condition|)
operator|*
name|nelts
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
name|outer_declarator
condition|)
name|outer_declarator
operator|->
name|declarator
operator|=
name|declarator
operator|->
name|declarator
expr_stmt|;
else|else
name|new_declarator
operator|=
name|NULL
expr_stmt|;
block|}
name|type
operator|=
name|groktypename
argument_list|(
operator|&
name|type_specifier_seq
argument_list|,
name|new_declarator
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|*
name|nelts
operator|==
name|NULL_TREE
condition|)
block|{
operator|*
name|nelts
operator|=
name|array_type_nelts_top
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) new-declarator.     new-declarator:      ptr-operator new-declarator [opt]      direct-new-declarator     Returns the declarator.  */
end_comment

begin_function
specifier|static
name|cp_declarator
modifier|*
name|cp_parser_new_declarator_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|cp_cv_quals
name|cv_quals
decl_stmt|;
comment|/* We don't know if there's a ptr-operator next, or not.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for a ptr-operator.  */
name|code
operator|=
name|cp_parser_ptr_operator
argument_list|(
name|parser
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|cv_quals
argument_list|)
expr_stmt|;
comment|/* If that worked, look for more new-declarators.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
comment|/* Parse another optional declarator.  */
name|declarator
operator|=
name|cp_parser_new_declarator_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Create the representation of the declarator.  */
if|if
condition|(
name|type
condition|)
name|declarator
operator|=
name|make_ptrmem_declarator
argument_list|(
name|cv_quals
argument_list|,
name|type
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|INDIRECT_REF
condition|)
name|declarator
operator|=
name|make_pointer_declarator
argument_list|(
name|cv_quals
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
else|else
name|declarator
operator|=
name|make_reference_declarator
argument_list|(
name|cv_quals
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|declarator
return|;
block|}
comment|/* If the next token is a `[', there is a direct-new-declarator.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|)
condition|)
return|return
name|cp_parser_direct_new_declarator
argument_list|(
name|parser
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Parse a direct-new-declarator.     direct-new-declarator:      [ expression ]      direct-new-declarator [constant-expression]     */
end_comment

begin_function
specifier|static
name|cp_declarator
modifier|*
name|cp_parser_direct_new_declarator
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_declarator
modifier|*
name|declarator
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|expression
decl_stmt|;
comment|/* Look for the opening `['.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|,
literal|"`['"
argument_list|)
expr_stmt|;
comment|/* The first expression is not required to be constant.  */
if|if
condition|(
operator|!
name|declarator
condition|)
block|{
name|expression
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* The standard requires that the expression have integral 	     type.  DR 74 adds enumeration types.  We believe that the 	     real intent is that these expressions be handled like the 	     expression in a `switch' condition, which also allows 	     classes with a single conversion to integral or 	     enumeration type.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|expression
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_INT
operator||
name|WANT_ENUM
argument_list|,
name|expression
argument_list|,
comment|/*complain=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression
condition|)
block|{
name|error
argument_list|(
literal|"expression in new-declarator must have integral "
literal|"or enumeration type"
argument_list|)
expr_stmt|;
name|expression
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
block|}
comment|/* But all the other expressions must be.  */
else|else
name|expression
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant=*/
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Look for the closing `]'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"`]'"
argument_list|)
expr_stmt|;
comment|/* Add this bound to the declarator.  */
name|declarator
operator|=
name|make_array_declarator
argument_list|(
name|declarator
argument_list|,
name|expression
argument_list|)
expr_stmt|;
comment|/* If the next token is not a `[', then there are no more 	 bounds.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|)
condition|)
break|break;
block|}
return|return
name|declarator
return|;
block|}
end_function

begin_comment
comment|/* Parse a new-initializer.     new-initializer:      ( expression-list [opt] )     Returns a representation of the expression-list.  If there is no    expression-list, VOID_ZERO_NODE is returned.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_new_initializer
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|expression_list
decl_stmt|;
name|expression_list
operator|=
operator|(
name|cp_parser_parenthesized_expression_list
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|,
comment|/*non_constant_p=*/
name|NULL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_list
condition|)
name|expression_list
operator|=
name|void_zero_node
expr_stmt|;
return|return
name|expression_list
return|;
block|}
end_function

begin_comment
comment|/* Parse a delete-expression.     delete-expression:      :: [opt] delete cast-expression      :: [opt] delete [ ] cast-expression     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_delete_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|bool
name|global_scope_p
decl_stmt|;
name|bool
name|array_p
decl_stmt|;
name|tree
name|expression
decl_stmt|;
comment|/* Look for the optional `::' operator.  */
name|global_scope_p
operator|=
operator|(
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Look for the `delete' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_DELETE
argument_list|,
literal|"`delete'"
argument_list|)
expr_stmt|;
comment|/* See if the array syntax is in use.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|)
condition|)
block|{
comment|/* Consume the `[' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the `]' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"`]'"
argument_list|)
expr_stmt|;
comment|/* Remember that this is the `[]' construct.  */
name|array_p
operator|=
name|true
expr_stmt|;
block|}
else|else
name|array_p
operator|=
name|false
expr_stmt|;
comment|/* Parse the cast-expression.  */
name|expression
operator|=
name|cp_parser_simple_cast_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* A delete-expression may not appear in an integral constant      expression.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"`delete'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
return|return
name|delete_sanity
argument_list|(
name|expression
argument_list|,
name|NULL_TREE
argument_list|,
name|array_p
argument_list|,
name|global_scope_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a cast-expression.     cast-expression:      unary-expression      ( type-id ) cast-expression     ADDRESS_P is true iff the unary-expression is appearing as the    operand of the `&' operator.   CAST_P is true if this expression is    the target of a cast.     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_cast_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|address_p
parameter_list|,
name|bool
name|cast_p
parameter_list|)
block|{
comment|/* If it's a `(', then we might be looking at a cast.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|expr
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|compound_literal_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
comment|/* There's no way to know yet whether or not this is a cast. 	 For example, `(int (3))' is a unary-expression, while `(int) 	 3' is a cast.  So, we resort to parsing tentatively.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Types may not be defined in a cast.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in casts"
expr_stmt|;
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* A very tricky bit is that `(struct S) { 3 }' is a 	 compound-literal (which we permit in C++ as an extension). 	 But, that construct is not a cast-expression -- it is a 	 postfix-expression.  (The reason is that `(struct S) { 3 }.i' 	 is legal; if the compound-literal were a cast-expression, 	 you'd need an extra set of parentheses.)  But, if we parse 	 the type-id, and it happens to be a class-specifier, then we 	 will commit to the parse at that point, because we cannot 	 undo the action that is done when creating a new class.  So, 	 then we cannot back up and do a postfix-expression.  	 Therefore, we scan ahead to the closing `)', and check to see 	 if the token after the `)' is a `{'.  If so, we are not 	 looking at a cast-expression.  	 Save tokens so that we can put them back.  */
name|cp_lexer_save_tokens
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Skip tokens until the next token is a closing parenthesis. 	 If we find the closing `)', and the next token is a `{', then 	 we are looking at a compound-literal.  */
name|compound_literal_p
operator|=
operator|(
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
operator|)
expr_stmt|;
comment|/* Roll back the tokens we skipped.  */
name|cp_lexer_rollback_tokens
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If we were looking at a compound-literal, simulate an error 	 so that the call to cp_parser_parse_definitely below will 	 fail.  */
if|if
condition|(
name|compound_literal_p
condition|)
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
block|{
name|bool
name|saved_in_type_id_in_expr_p
init|=
name|parser
operator|->
name|in_type_id_in_expr_p
decl_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|true
expr_stmt|;
comment|/* Look for the type-id.  */
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the closing `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|saved_in_type_id_in_expr_p
expr_stmt|;
block|}
comment|/* Restore the saved message.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
comment|/* If ok so far, parse the dependent expression. We cannot be 	 sure it is a cast. Consider `(T ())'.  It is a parenthesized 	 ctor of T, but looks like a cast to function returning T 	 without a dependent expression.  */
if|if
condition|(
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
name|expr
operator|=
name|cp_parser_cast_expression
argument_list|(
name|parser
argument_list|,
comment|/*address_p=*/
name|false
argument_list|,
comment|/*cast_p=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* Warn about old-style casts, if so requested.  */
if|if
condition|(
name|warn_old_style_cast
operator|&&
operator|!
name|in_system_header
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|current_lang_name
operator|!=
name|lang_name_c
condition|)
name|warning
argument_list|(
name|OPT_Wold_style_cast
argument_list|,
literal|"use of old-style cast"
argument_list|)
expr_stmt|;
comment|/* Only type conversions to integral or enumeration types 	     can be used in constant-expressions.  */
if|if
condition|(
operator|!
name|cast_valid_in_integral_constant_expression_p
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"a cast to a type other than an integral or "
literal|"enumeration type"
argument_list|)
operator|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Perform the cast.  */
name|expr
operator|=
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
block|}
comment|/* If we get here, then it's not a cast, so it must be a      unary-expression.  */
return|return
name|cp_parser_unary_expression
argument_list|(
name|parser
argument_list|,
name|address_p
argument_list|,
name|cast_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a binary expression of the general form:     pm-expression:      cast-expression      pm-expression .* cast-expression      pm-expression ->* cast-expression     multiplicative-expression:      pm-expression      multiplicative-expression * pm-expression      multiplicative-expression / pm-expression      multiplicative-expression % pm-expression     additive-expression:      multiplicative-expression      additive-expression + multiplicative-expression      additive-expression - multiplicative-expression     shift-expression:      additive-expression      shift-expression<< additive-expression      shift-expression>> additive-expression     relational-expression:      shift-expression      relational-expression< shift-expression      relational-expression> shift-expression      relational-expression<= shift-expression      relational-expression>= shift-expression    GNU Extension:     relational-expression:      relational-expression<? shift-expression      relational-expression>? shift-expression     equality-expression:      relational-expression      equality-expression == relational-expression      equality-expression != relational-expression     and-expression:      equality-expression      and-expression& equality-expression     exclusive-or-expression:      and-expression      exclusive-or-expression ^ and-expression     inclusive-or-expression:      exclusive-or-expression      inclusive-or-expression | exclusive-or-expression     logical-and-expression:      inclusive-or-expression      logical-and-expression&& inclusive-or-expression     logical-or-expression:      logical-and-expression      logical-or-expression || logical-and-expression     All these are implemented with a single function like:     binary-expression:      simple-cast-expression      binary-expression<token> binary-expression     CAST_P is true if this expression is the target of a cast.     The binops_by_token map is used to get the tree codes for each<token> type.    binary-expressions are associated according to a precedence table.  */
end_comment

begin_define
define|#
directive|define
name|TOKEN_PRECEDENCE
parameter_list|(
name|token
parameter_list|)
define|\
value|((token->type == CPP_GREATER&& !parser->greater_than_is_operator_p) \    ? PREC_NOT_OPERATOR \    : binops_by_token[token->type].prec)
end_define

begin_function
specifier|static
name|tree
name|cp_parser_binary_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|cast_p
parameter_list|)
block|{
name|cp_parser_expression_stack
name|stack
decl_stmt|;
name|cp_parser_expression_stack_entry
modifier|*
name|sp
init|=
operator|&
name|stack
index|[
literal|0
index|]
decl_stmt|;
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|tree_code
name|tree_type
decl_stmt|,
name|lhs_type
decl_stmt|,
name|rhs_type
decl_stmt|;
name|enum
name|cp_parser_prec
name|prec
init|=
name|PREC_NOT_OPERATOR
decl_stmt|,
name|new_prec
decl_stmt|,
name|lookahead_prec
decl_stmt|;
name|bool
name|overloaded_p
decl_stmt|;
comment|/* Parse the first expression.  */
name|lhs
operator|=
name|cp_parser_cast_expression
argument_list|(
name|parser
argument_list|,
comment|/*address_p=*/
name|false
argument_list|,
name|cast_p
argument_list|)
expr_stmt|;
name|lhs_type
operator|=
name|ERROR_MARK
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Get an operator token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|new_prec
operator|=
name|TOKEN_PRECEDENCE
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|/* Popping an entry off the stack means we completed a subexpression: 	 - either we found a token which is not an operator (`>' where it is not 	   an operator, or prec == PREC_NOT_OPERATOR), in which case popping 	   will happen repeatedly; 	 - or, we found an operator which has lower priority.  This is the case 	   where the recursive descent *ascends*, as in `3 * 4 + 5' after 	   parsing `3 * 4'.  */
if|if
condition|(
name|new_prec
operator|<=
name|prec
condition|)
block|{
if|if
condition|(
name|sp
operator|==
name|stack
condition|)
break|break;
else|else
goto|goto
name|pop
goto|;
block|}
name|get_rhs
label|:
name|tree_type
operator|=
name|binops_by_token
index|[
name|token
operator|->
name|type
index|]
operator|.
name|tree_type
expr_stmt|;
comment|/* We used the operator token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Extract another operand.  It may be the RHS of this expression 	 or the LHS of a new, higher priority expression.  */
name|rhs
operator|=
name|cp_parser_simple_cast_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|rhs_type
operator|=
name|ERROR_MARK
expr_stmt|;
comment|/* Get another operator token.  Look up its precedence to avoid 	 building a useless (immediately popped) stack entry for common 	 cases such as 3 + 4 + 5 or 3 * 4 + 5.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|lookahead_prec
operator|=
name|TOKEN_PRECEDENCE
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookahead_prec
operator|>
name|new_prec
condition|)
block|{
comment|/* ... and prepare to parse the RHS of the new, higher priority 	     expression.  Since precedence levels on the stack are 	     monotonically increasing, we do not have to care about 	     stack overflows.  */
name|sp
operator|->
name|prec
operator|=
name|prec
expr_stmt|;
name|sp
operator|->
name|tree_type
operator|=
name|tree_type
expr_stmt|;
name|sp
operator|->
name|lhs
operator|=
name|lhs
expr_stmt|;
name|sp
operator|->
name|lhs_type
operator|=
name|lhs_type
expr_stmt|;
name|sp
operator|++
expr_stmt|;
name|lhs
operator|=
name|rhs
expr_stmt|;
name|lhs_type
operator|=
name|rhs_type
expr_stmt|;
name|prec
operator|=
name|new_prec
expr_stmt|;
name|new_prec
operator|=
name|lookahead_prec
expr_stmt|;
goto|goto
name|get_rhs
goto|;
name|pop
label|:
comment|/* If the stack is not empty, we have parsed into LHS the right side 	     (`4' in the example above) of an expression we had suspended. 	     We can use the information on the stack to recover the LHS (`3') 	     from the stack together with the tree code (`MULT_EXPR'), and 	     the precedence of the higher level subexpression 	     (`PREC_ADDITIVE_EXPRESSION').  TOKEN is the CPP_PLUS token, 	     which will be used to actually build the additive expression.  */
operator|--
name|sp
expr_stmt|;
name|prec
operator|=
name|sp
operator|->
name|prec
expr_stmt|;
name|tree_type
operator|=
name|sp
operator|->
name|tree_type
expr_stmt|;
name|rhs
operator|=
name|lhs
expr_stmt|;
name|rhs_type
operator|=
name|lhs_type
expr_stmt|;
name|lhs
operator|=
name|sp
operator|->
name|lhs
expr_stmt|;
name|lhs_type
operator|=
name|sp
operator|->
name|lhs_type
expr_stmt|;
block|}
name|overloaded_p
operator|=
name|false
expr_stmt|;
name|lhs
operator|=
name|build_x_binary_op
argument_list|(
name|tree_type
argument_list|,
name|lhs
argument_list|,
name|lhs_type
argument_list|,
name|rhs
argument_list|,
name|rhs_type
argument_list|,
operator|&
name|overloaded_p
argument_list|)
expr_stmt|;
name|lhs_type
operator|=
name|tree_type
expr_stmt|;
comment|/* If the binary operator required the use of an overloaded operator, 	 then this expression cannot be an integral constant-expression. 	 An overloaded operator can be used even if both operands are 	 otherwise permissible in an integral constant-expression if at 	 least one of the operands is of enumeration type.  */
if|if
condition|(
name|overloaded_p
operator|&&
operator|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"calls to overloaded operators"
argument_list|)
operator|)
condition|)
return|return
name|error_mark_node
return|;
block|}
return|return
name|lhs
return|;
block|}
end_function

begin_comment
comment|/* Parse the `? expression : assignment-expression' part of a    conditional-expression.  The LOGICAL_OR_EXPR is the    logical-or-expression that started the conditional-expression.    Returns a representation of the entire conditional-expression.     This routine is used by cp_parser_assignment_expression.       ? expression : assignment-expression     GNU Extensions:       ? : assignment-expression */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_question_colon_clause
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|logical_or_expr
parameter_list|)
block|{
name|tree
name|expr
decl_stmt|;
name|tree
name|assignment_expr
decl_stmt|;
comment|/* Consume the `?' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
comment|/* Implicit true clause.  */
name|expr
operator|=
name|NULL_TREE
expr_stmt|;
else|else
comment|/* Parse the expression.  */
name|expr
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* The next token should be a `:'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"`:'"
argument_list|)
expr_stmt|;
comment|/* Parse the assignment-expression.  */
name|assignment_expr
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Build the conditional-expression.  */
return|return
name|build_x_conditional_expr
argument_list|(
name|logical_or_expr
argument_list|,
name|expr
argument_list|,
name|assignment_expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an assignment-expression.     assignment-expression:      conditional-expression      logical-or-expression assignment-operator assignment_expression      throw-expression     CAST_P is true if this expression is the target of a cast.     Returns a representation for the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_assignment_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|cast_p
parameter_list|)
block|{
name|tree
name|expr
decl_stmt|;
comment|/* If the next token is the `throw' keyword, then we're looking at      a throw-expression.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_THROW
argument_list|)
condition|)
name|expr
operator|=
name|cp_parser_throw_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Otherwise, it must be that we are looking at a      logical-or-expression.  */
else|else
block|{
comment|/* Parse the binary expressions (logical-or-expression).  */
name|expr
operator|=
name|cp_parser_binary_expression
argument_list|(
name|parser
argument_list|,
name|cast_p
argument_list|)
expr_stmt|;
comment|/* If the next token is a `?' then we're actually looking at a 	 conditional-expression.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_QUERY
argument_list|)
condition|)
return|return
name|cp_parser_question_colon_clause
argument_list|(
name|parser
argument_list|,
name|expr
argument_list|)
return|;
else|else
block|{
name|enum
name|tree_code
name|assignment_operator
decl_stmt|;
comment|/* If it's an assignment-operator, we're using the second 	     production.  */
name|assignment_operator
operator|=
name|cp_parser_assignment_operator_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|assignment_operator
operator|!=
name|ERROR_MARK
condition|)
block|{
name|tree
name|rhs
decl_stmt|;
comment|/* Parse the right-hand side of the assignment.  */
name|rhs
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|,
name|cast_p
argument_list|)
expr_stmt|;
comment|/* An assignment may not appear in a 		 constant-expression.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"an assignment"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Build the assignment expression.  */
name|expr
operator|=
name|build_x_modify_expr
argument_list|(
name|expr
argument_list|,
name|assignment_operator
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) assignment-operator.     assignment-operator: one of      = *= /= %= += -=>>=<<=&= ^= |=     GNU Extension:     assignment-operator: one of<?=>?=     If the next token is an assignment operator, the corresponding tree    code is returned, and the token is consumed.  For example, for    `+=', PLUS_EXPR is returned.  For `=' itself, the code returned is    NOP_EXPR.  For `/', TRUNC_DIV_EXPR is returned; for `%',    TRUNC_MOD_EXPR is returned.  If TOKEN is not an assignment    operator, ERROR_MARK is returned.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|cp_parser_assignment_operator_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|enum
name|tree_code
name|op
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next toen.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_EQ
case|:
name|op
operator|=
name|NOP_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MULT_EQ
case|:
name|op
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_DIV_EQ
case|:
name|op
operator|=
name|TRUNC_DIV_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MOD_EQ
case|:
name|op
operator|=
name|TRUNC_MOD_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_PLUS_EQ
case|:
name|op
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MINUS_EQ
case|:
name|op
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_RSHIFT_EQ
case|:
name|op
operator|=
name|RSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_LSHIFT_EQ
case|:
name|op
operator|=
name|LSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_AND_EQ
case|:
name|op
operator|=
name|BIT_AND_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_XOR_EQ
case|:
name|op
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_OR_EQ
case|:
name|op
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
break|break;
default|default:
comment|/* Nothing else is an assignment operator.  */
name|op
operator|=
name|ERROR_MARK
expr_stmt|;
block|}
comment|/* If it was an assignment operator, consume it.  */
if|if
condition|(
name|op
operator|!=
name|ERROR_MARK
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Parse an expression.     expression:      assignment-expression      expression , assignment-expression     CAST_P is true if this expression is the target of a cast.     Returns a representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|cast_p
parameter_list|)
block|{
name|tree
name|expression
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|assignment_expression
decl_stmt|;
comment|/* Parse the next assignment-expression.  */
name|assignment_expression
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|,
name|cast_p
argument_list|)
expr_stmt|;
comment|/* If this is the first assignment-expression, we can just 	 save it away.  */
if|if
condition|(
operator|!
name|expression
condition|)
name|expression
operator|=
name|assignment_expression
expr_stmt|;
else|else
name|expression
operator|=
name|build_x_compound_expr
argument_list|(
name|expression
argument_list|,
name|assignment_expression
argument_list|)
expr_stmt|;
comment|/* If the next token is not a comma, then we are done with the 	 expression.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
comment|/* Consume the `,'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* A comma operator cannot appear in a constant-expression.  */
if|if
condition|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"a comma operator"
argument_list|)
condition|)
name|expression
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|expression
return|;
block|}
end_function

begin_comment
comment|/* Parse a constant-expression.     constant-expression:      conditional-expression    If ALLOW_NON_CONSTANT_P a non-constant expression is silently   accepted.  If ALLOW_NON_CONSTANT_P is true and the expression is not   constant, *NON_CONSTANT_P is set to TRUE.  If ALLOW_NON_CONSTANT_P   is false, NON_CONSTANT_P should be NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_constant_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|allow_non_constant_p
parameter_list|,
name|bool
modifier|*
name|non_constant_p
parameter_list|)
block|{
name|bool
name|saved_integral_constant_expression_p
decl_stmt|;
name|bool
name|saved_allow_non_integral_constant_expression_p
decl_stmt|;
name|bool
name|saved_non_integral_constant_expression_p
decl_stmt|;
name|tree
name|expression
decl_stmt|;
comment|/* It might seem that we could simply parse the      conditional-expression, and then check to see if it were      TREE_CONSTANT.  However, an expression that is TREE_CONSTANT is      one that the compiler can figure out is constant, possibly after      doing some simplifications or optimizations.  The standard has a      precise definition of constant-expression, and we must honor      that, even though it is somewhat more restrictive.       For example:         int i[(2, 3)];       is not a legal declaration, because `(2, 3)' is not a      constant-expression.  The `,' operator is forbidden in a      constant-expression.  However, GCC's constant-folding machinery      will fold this operation to an INTEGER_CST for `3'.  */
comment|/* Save the old settings.  */
name|saved_integral_constant_expression_p
operator|=
name|parser
operator|->
name|integral_constant_expression_p
expr_stmt|;
name|saved_allow_non_integral_constant_expression_p
operator|=
name|parser
operator|->
name|allow_non_integral_constant_expression_p
expr_stmt|;
name|saved_non_integral_constant_expression_p
operator|=
name|parser
operator|->
name|non_integral_constant_expression_p
expr_stmt|;
comment|/* We are now parsing a constant-expression.  */
name|parser
operator|->
name|integral_constant_expression_p
operator|=
name|true
expr_stmt|;
name|parser
operator|->
name|allow_non_integral_constant_expression_p
operator|=
name|allow_non_constant_p
expr_stmt|;
name|parser
operator|->
name|non_integral_constant_expression_p
operator|=
name|false
expr_stmt|;
comment|/* Although the grammar says "conditional-expression", we parse an      "assignment-expression", which also permits "throw-expression"      and the use of assignment operators.  In the case that      ALLOW_NON_CONSTANT_P is false, we get better errors than we would      otherwise.  In the case that ALLOW_NON_CONSTANT_P is true, it is      actually essential that we look for an assignment-expression.      For example, cp_parser_initializer_clauses uses this function to      determine whether a particular assignment-expression is in fact      constant.  */
name|expression
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Restore the old settings.  */
name|parser
operator|->
name|integral_constant_expression_p
operator|=
name|saved_integral_constant_expression_p
expr_stmt|;
name|parser
operator|->
name|allow_non_integral_constant_expression_p
operator|=
name|saved_allow_non_integral_constant_expression_p
expr_stmt|;
if|if
condition|(
name|allow_non_constant_p
condition|)
operator|*
name|non_constant_p
operator|=
name|parser
operator|->
name|non_integral_constant_expression_p
expr_stmt|;
elseif|else
if|if
condition|(
name|parser
operator|->
name|non_integral_constant_expression_p
condition|)
name|expression
operator|=
name|error_mark_node
expr_stmt|;
name|parser
operator|->
name|non_integral_constant_expression_p
operator|=
name|saved_non_integral_constant_expression_p
expr_stmt|;
return|return
name|expression
return|;
block|}
end_function

begin_comment
comment|/* Parse __builtin_offsetof.     offsetof-expression:      "__builtin_offsetof" "(" type-id "," offsetof-member-designator ")"     offsetof-member-designator:      id-expression      | offsetof-member-designator "." id-expression      | offsetof-member-designator "[" expression "]"  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_builtin_offsetof
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|int
name|save_ice_p
decl_stmt|,
name|save_non_ice_p
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
name|cp_id_kind
name|dummy
decl_stmt|;
comment|/* We're about to accept non-integral-constant things, but will      definitely yield an integral constant expression.  Save and      restore these values around our local parsing.  */
name|save_ice_p
operator|=
name|parser
operator|->
name|integral_constant_expression_p
expr_stmt|;
name|save_non_ice_p
operator|=
name|parser
operator|->
name|non_integral_constant_expression_p
expr_stmt|;
comment|/* Consume the "__builtin_offsetof" token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Consume the opening `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Parse the type-id.  */
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the `,'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|,
literal|"`,'"
argument_list|)
expr_stmt|;
comment|/* Build the (type *)null that begins the traditional offsetof macro.  */
name|expr
operator|=
name|build_static_cast
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|null_pointer_node
argument_list|)
expr_stmt|;
comment|/* Parse the offsetof-member-designator.  We begin as if we saw "expr->".  */
name|expr
operator|=
name|cp_parser_postfix_dot_deref_expression
argument_list|(
name|parser
argument_list|,
name|CPP_DEREF
argument_list|,
name|expr
argument_list|,
name|true
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_OPEN_SQUARE
case|:
comment|/* offsetof-member-designator "[" expression "]" */
name|expr
operator|=
name|cp_parser_postfix_open_square_expression
argument_list|(
name|parser
argument_list|,
name|expr
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_DOT
case|:
comment|/* offsetof-member-designator "." identifier */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|expr
operator|=
name|cp_parser_postfix_dot_deref_expression
argument_list|(
name|parser
argument_list|,
name|CPP_DOT
argument_list|,
name|expr
argument_list|,
name|true
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_CLOSE_PAREN
case|:
comment|/* Consume the ")" token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
goto|goto
name|success
goto|;
default|default:
comment|/* Error.  We know the following require will fail, but 	     that gives the proper error message.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|expr
operator|=
name|error_mark_node
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
name|success
label|:
comment|/* If we're processing a template, we can't finish the semantics yet.      Otherwise we can fold the entire expression now.  */
if|if
condition|(
name|processing_template_decl
condition|)
name|expr
operator|=
name|build1
argument_list|(
name|OFFSETOF_EXPR
argument_list|,
name|size_type_node
argument_list|,
name|expr
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|finish_offsetof
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|failure
label|:
name|parser
operator|->
name|integral_constant_expression_p
operator|=
name|save_ice_p
expr_stmt|;
name|parser
operator|->
name|non_integral_constant_expression_p
operator|=
name|save_non_ice_p
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Statements [gram.stmt.stmt]  */
end_comment

begin_comment
comment|/* Parse a statement.     statement:      labeled-statement      expression-statement      compound-statement      selection-statement      iteration-statement      jump-statement      declaration-statement      try-block    IN_COMPOUND is true when the statement is nested inside a   cp_parser_compound_statement; this matters for certain pragmas.    If IF_P is not NULL, *IF_P is set to indicate whether the statement   is a (possibly labeled) if statement which is not enclosed in braces   and has an else clause.  This is used to implement -Wparentheses.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|in_statement_expr
parameter_list|,
name|bool
name|in_compound
parameter_list|,
name|bool
modifier|*
name|if_p
parameter_list|)
block|{
name|tree
name|statement
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|location_t
name|statement_location
decl_stmt|;
name|restart
label|:
if|if
condition|(
name|if_p
operator|!=
name|NULL
condition|)
operator|*
name|if_p
operator|=
name|false
expr_stmt|;
comment|/* There is no statement yet.  */
name|statement
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Remember the location of the first token in the statement.  */
name|statement_location
operator|=
name|token
operator|->
name|location
expr_stmt|;
comment|/* If this is a keyword, then that will often determine what kind of      statement we have.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_KEYWORD
condition|)
block|{
name|enum
name|rid
name|keyword
init|=
name|token
operator|->
name|keyword
decl_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_CASE
case|:
case|case
name|RID_DEFAULT
case|:
comment|/* Looks like a labeled-statement with a case label. 	     Parse the label, and then use tail recursion to parse 	     the statement.  */
name|cp_parser_label_for_labeled_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|RID_IF
case|:
case|case
name|RID_SWITCH
case|:
name|statement
operator|=
name|cp_parser_selection_statement
argument_list|(
name|parser
argument_list|,
name|if_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_WHILE
case|:
case|case
name|RID_DO
case|:
case|case
name|RID_FOR
case|:
name|statement
operator|=
name|cp_parser_iteration_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_BREAK
case|:
case|case
name|RID_CONTINUE
case|:
case|case
name|RID_RETURN
case|:
case|case
name|RID_GOTO
case|:
name|statement
operator|=
name|cp_parser_jump_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
comment|/* Objective-C++ exception-handling constructs.  */
case|case
name|RID_AT_TRY
case|:
case|case
name|RID_AT_CATCH
case|:
case|case
name|RID_AT_FINALLY
case|:
case|case
name|RID_AT_SYNCHRONIZED
case|:
case|case
name|RID_AT_THROW
case|:
name|statement
operator|=
name|cp_parser_objc_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_TRY
case|:
name|statement
operator|=
name|cp_parser_try_block
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* It might be a keyword like `int' that can start a 	     declaration-statement.  */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
block|{
comment|/* If the next token is a `:', then we are looking at a 	 labeled-statement.  */
name|token
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COLON
condition|)
block|{
comment|/* Looks like a labeled-statement with an ordinary label. 	     Parse the label, and then use tail recursion to parse 	     the statement.  */
name|cp_parser_label_for_labeled_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
comment|/* Anything that starts with a `{' must be a compound-statement.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
condition|)
name|statement
operator|=
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* CPP_PRAGMA is a #pragma inside a function body, which constitutes      a statement all its own.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PRAGMA
condition|)
block|{
comment|/* Only certain OpenMP pragmas are attached to statements, and thus 	 are considered statements themselves.  All others are not.  In 	 the context of a compound, accept the pragma as a "statement" and 	 return so that we can check for a close brace.  Otherwise we 	 require a real statement and must go back and read one.  */
if|if
condition|(
name|in_compound
condition|)
name|cp_parser_pragma
argument_list|(
name|parser
argument_list|,
name|pragma_compound
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|cp_parser_pragma
argument_list|(
name|parser
argument_list|,
name|pragma_stmt
argument_list|)
condition|)
goto|goto
name|restart
goto|;
return|return;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected statement"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Everything else must be a declaration-statement or an      expression-statement.  Try for the declaration-statement      first, unless we are looking at a `;', in which case we know that      we have an expression-statement.  */
if|if
condition|(
operator|!
name|statement
condition|)
block|{
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try to parse the declaration-statement.  */
name|cp_parser_declaration_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If that worked, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return;
block|}
comment|/* Look for an expression-statement instead.  */
name|statement
operator|=
name|cp_parser_expression_statement
argument_list|(
name|parser
argument_list|,
name|in_statement_expr
argument_list|)
expr_stmt|;
block|}
comment|/* Set the line number for the statement.  */
if|if
condition|(
name|statement
operator|&&
name|STATEMENT_CODE_P
argument_list|(
name|TREE_CODE
argument_list|(
name|statement
argument_list|)
argument_list|)
condition|)
name|SET_EXPR_LOCATION
argument_list|(
name|statement
argument_list|,
name|statement_location
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the label for a labeled-statement, i.e.     identifier :    case constant-expression :    default :     GNU Extension:    case constant-expression ... constant-expression : statement     When a label is parsed without errors, the label is added to the    parse tree by the finish_* functions, so this function doesn't    have to return the label.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_label_for_labeled_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* The next token should be an identifier.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NAME
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_KEYWORD
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected labeled-statement"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_CASE
case|:
block|{
name|tree
name|expr
decl_stmt|,
name|expr_hi
decl_stmt|;
name|cp_token
modifier|*
name|ellipsis
decl_stmt|;
comment|/* Consume the `case' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the constant-expression.  */
name|expr
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant_p=*/
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ellipsis
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ellipsis
operator|->
name|type
operator|==
name|CPP_ELLIPSIS
condition|)
block|{
comment|/* Consume the `...' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|expr_hi
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant_p=*/
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* We don't need to emit warnings here, as the common code 	       will do this for us.  */
block|}
else|else
name|expr_hi
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|in_switch_statement_p
condition|)
name|finish_case_label
argument_list|(
name|expr
argument_list|,
name|expr_hi
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"case label %qE not within a switch statement"
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RID_DEFAULT
case|:
comment|/* Consume the `default' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|in_switch_statement_p
condition|)
name|finish_case_label
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"case label not within a switch statement"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Anything else must be an ordinary label.  */
name|finish_label_stmt
argument_list|(
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Require the `:' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"`:'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an expression-statement.     expression-statement:      expression [opt] ;     Returns the new EXPR_STMT -- or NULL_TREE if the expression    statement consists of nothing more than an `;'. IN_STATEMENT_EXPR_P    indicates whether this expression-statement is part of an    expression statement.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_expression_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|in_statement_expr
parameter_list|)
block|{
name|tree
name|statement
init|=
name|NULL_TREE
decl_stmt|;
comment|/* If the next token is a ';', then there is no expression      statement.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|statement
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Consume the final `;'.  */
name|cp_parser_consume_semicolon_at_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_statement_expr
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
comment|/* This is the final expression statement of a statement        expression.  */
name|statement
operator|=
name|finish_stmt_expr_expr
argument_list|(
name|statement
argument_list|,
name|in_statement_expr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|statement
condition|)
name|statement
operator|=
name|finish_expr_stmt
argument_list|(
name|statement
argument_list|)
expr_stmt|;
else|else
name|finish_stmt
argument_list|()
expr_stmt|;
return|return
name|statement
return|;
block|}
end_function

begin_comment
comment|/* Parse a compound-statement.     compound-statement:      { statement-seq [opt] }     Returns a tree representing the statement.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_compound_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|in_statement_expr
parameter_list|,
name|bool
name|in_try
parameter_list|)
block|{
name|tree
name|compound_stmt
decl_stmt|;
comment|/* Consume the `{'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|,
literal|"`{'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Begin the compound-statement.  */
name|compound_stmt
operator|=
name|begin_compound_stmt
argument_list|(
name|in_try
condition|?
name|BCS_TRY_BLOCK
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* Parse an (optional) statement-seq.  */
name|cp_parser_statement_seq_opt
argument_list|(
name|parser
argument_list|,
name|in_statement_expr
argument_list|)
expr_stmt|;
comment|/* Finish the compound-statement.  */
name|finish_compound_stmt
argument_list|(
name|compound_stmt
argument_list|)
expr_stmt|;
comment|/* Consume the `}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
return|return
name|compound_stmt
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) statement-seq.     statement-seq:      statement      statement-seq [opt] statement  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_statement_seq_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|in_statement_expr
parameter_list|)
block|{
comment|/* Scan statements until there aren't any more.  */
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
comment|/* If we're looking at a `}', then we've run out of statements.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_EOF
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_PRAGMA_EOL
condition|)
break|break;
comment|/* Parse the statement.  */
name|cp_parser_statement
argument_list|(
name|parser
argument_list|,
name|in_statement_expr
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a selection-statement.     selection-statement:      if ( condition ) statement      if ( condition ) statement else statement      switch ( condition ) statement     Returns the new IF_STMT or SWITCH_STMT.     If IF_P is not NULL, *IF_P is set to indicate whether the statement    is a (possibly labeled) if statement which is not enclosed in    braces and has an else clause.  This is used to implement    -Wparentheses.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_selection_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
modifier|*
name|if_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|rid
name|keyword
decl_stmt|;
if|if
condition|(
name|if_p
operator|!=
name|NULL
condition|)
operator|*
name|if_p
operator|=
name|false
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|,
literal|"selection-statement"
argument_list|)
expr_stmt|;
comment|/* See what kind of keyword it is.  */
name|keyword
operator|=
name|token
operator|->
name|keyword
expr_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_IF
case|:
case|case
name|RID_SWITCH
case|:
block|{
name|tree
name|statement
decl_stmt|;
name|tree
name|condition
decl_stmt|;
comment|/* Look for the `('.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
condition|)
block|{
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Begin the selection-statement.  */
if|if
condition|(
name|keyword
operator|==
name|RID_IF
condition|)
name|statement
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
else|else
name|statement
operator|=
name|begin_switch_stmt
argument_list|()
expr_stmt|;
comment|/* Parse the condition.  */
name|condition
operator|=
name|cp_parser_condition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the `)'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyword
operator|==
name|RID_IF
condition|)
block|{
name|bool
name|nested_if
decl_stmt|;
comment|/* Add the condition.  */
name|finish_if_stmt_cond
argument_list|(
name|condition
argument_list|,
name|statement
argument_list|)
expr_stmt|;
comment|/* Parse the then-clause.  */
name|cp_parser_implicitly_scoped_statement
argument_list|(
name|parser
argument_list|,
operator|&
name|nested_if
argument_list|)
expr_stmt|;
name|finish_then_clause
argument_list|(
name|statement
argument_list|)
expr_stmt|;
comment|/* If the next token is `else', parse the else-clause.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_ELSE
argument_list|)
condition|)
block|{
comment|/* Consume the `else' keyword.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|begin_else_clause
argument_list|(
name|statement
argument_list|)
expr_stmt|;
comment|/* Parse the else-clause.  */
name|cp_parser_implicitly_scoped_statement
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|finish_else_clause
argument_list|(
name|statement
argument_list|)
expr_stmt|;
comment|/* If we are currently parsing a then-clause, then 		   IF_P will not be NULL.  We set it to true to 		   indicate that this if statement has an else clause. 		   This may trigger the Wparentheses warning below 		   when we get back up to the parent if statement.  */
if|if
condition|(
name|if_p
operator|!=
name|NULL
condition|)
operator|*
name|if_p
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* This if statement does not have an else clause.  If 		   NESTED_IF is true, then the then-clause is an if 		   statement which does have an else clause.  We warn 		   about the potential ambiguity.  */
if|if
condition|(
name|nested_if
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
operator|(
literal|"%Hsuggest explicit braces "
literal|"to avoid ambiguous %<else%>"
operator|)
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|statement
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now we're all done with the if-statement.  */
name|finish_if_stmt
argument_list|(
name|statement
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|in_switch_statement_p
decl_stmt|;
name|unsigned
name|char
name|in_statement
decl_stmt|;
comment|/* Add the condition.  */
name|finish_switch_cond
argument_list|(
name|condition
argument_list|,
name|statement
argument_list|)
expr_stmt|;
comment|/* Parse the body of the switch-statement.  */
name|in_switch_statement_p
operator|=
name|parser
operator|->
name|in_switch_statement_p
expr_stmt|;
name|in_statement
operator|=
name|parser
operator|->
name|in_statement
expr_stmt|;
name|parser
operator|->
name|in_switch_statement_p
operator|=
name|true
expr_stmt|;
name|parser
operator|->
name|in_statement
operator||=
name|IN_SWITCH_STMT
expr_stmt|;
name|cp_parser_implicitly_scoped_statement
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_switch_statement_p
operator|=
name|in_switch_statement_p
expr_stmt|;
name|parser
operator|->
name|in_statement
operator|=
name|in_statement
expr_stmt|;
comment|/* Now we're all done with the switch-statement.  */
name|finish_switch_stmt
argument_list|(
name|statement
argument_list|)
expr_stmt|;
block|}
return|return
name|statement
return|;
block|}
break|break;
default|default:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected selection-statement"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a condition.     condition:      expression      type-specifier-seq declarator = assignment-expression     GNU Extension:     condition:      type-specifier-seq declarator asm-specification [opt]        attributes [opt] = assignment-expression     Returns the expression that should be tested.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_condition
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_decl_specifier_seq
name|type_specifiers
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
comment|/* Try the declaration first.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* New types are not allowed in the type-specifier-seq for a      condition.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in conditions"
expr_stmt|;
comment|/* Parse the type-specifier-seq.  */
name|cp_parser_type_specifier_seq
argument_list|(
name|parser
argument_list|,
comment|/*is_condition==*/
name|true
argument_list|,
operator|&
name|type_specifiers
argument_list|)
expr_stmt|;
comment|/* Restore the saved message.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
comment|/* If all is well, we might be looking at a declaration.  */
if|if
condition|(
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|asm_specification
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
name|tree
name|initializer
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Parse the declarator.  */
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_NAMED
argument_list|,
comment|/*ctor_dtor_or_conv_p=*/
name|NULL
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|,
comment|/*member_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Parse the attributes.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the asm-specification.  */
name|asm_specification
operator|=
name|cp_parser_asm_specification_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is not an `=', then we might still be 	 looking at an expression.  For example:  	   if (A(a).x)  	 looks like a decl-specifier-seq and a declarator -- but then 	 there is no `=', so this is an expression.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_EQ
argument_list|,
literal|"`='"
argument_list|)
expr_stmt|;
comment|/* If we did see an `=', then we are looking at a declaration 	 for sure.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|tree
name|pushed_scope
decl_stmt|;
name|bool
name|non_constant_p
decl_stmt|;
comment|/* Create the declaration.  */
name|decl
operator|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
operator|&
name|type_specifiers
argument_list|,
comment|/*initialized_p=*/
name|true
argument_list|,
name|attributes
argument_list|,
comment|/*prefix_attributes=*/
name|NULL_TREE
argument_list|,
operator|&
name|pushed_scope
argument_list|)
expr_stmt|;
comment|/* Parse the assignment-expression.  */
name|initializer
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant_p=*/
name|true
argument_list|,
operator|&
name|non_constant_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|non_constant_p
condition|)
name|initializer
operator|=
name|fold_non_dependent_expr
argument_list|(
name|initializer
argument_list|)
expr_stmt|;
comment|/* Process the initializer.  */
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|initializer
argument_list|,
operator|!
name|non_constant_p
argument_list|,
name|asm_specification
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
if|if
condition|(
name|pushed_scope
condition|)
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|decl
argument_list|)
return|;
block|}
block|}
comment|/* If we didn't even get past the declarator successfully, we are      definitely not looking at a declaration.  */
else|else
name|cp_parser_abort_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Otherwise, we are looking at an expression.  */
return|return
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an iteration-statement.     iteration-statement:      while ( condition ) statement      do statement while ( expression ) ;      for ( for-init-statement condition [opt] ; expression [opt] )        statement     APPLE LOCAL begin for-fsf-4_4 3274130 5295549    GNU extension:       while attributes [opt] ( condition ) statement      do attributes [opt] statement while ( expression ) ;      for attributes [opt]         ( for-init-statement condition [opt] ; expression [opt] )        statement     APPLE LOCAL end for-fsf-4_4 3274130 5295549    Returns the new WHILE_STMT, DO_STMT, or FOR_STMT.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_iteration_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|rid
name|keyword
decl_stmt|;
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|tree
name|statement
decl_stmt|,
name|attributes
decl_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|unsigned
name|char
name|in_statement
decl_stmt|;
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
comment|/* Get the keyword at the start of the loop.  */
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|,
literal|"iteration-statement"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
name|error_mark_node
return|;
comment|/* Remember whether or not we are already within an iteration      statement.  */
name|in_statement
operator|=
name|parser
operator|->
name|in_statement
expr_stmt|;
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
comment|/* Parse the attributes, if any.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
comment|/* See what kind of keyword it is.  */
name|keyword
operator|=
name|token
operator|->
name|keyword
expr_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_WHILE
case|:
block|{
name|tree
name|condition
decl_stmt|;
comment|/* Begin the while-statement.  */
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|statement
operator|=
name|begin_while_stmt
argument_list|(
name|attributes
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
comment|/* Look for the `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Parse the condition.  */
name|condition
operator|=
name|cp_parser_condition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|finish_while_stmt_cond
argument_list|(
name|condition
argument_list|,
name|statement
argument_list|)
expr_stmt|;
comment|/* Look for the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Parse the dependent statement.  */
name|parser
operator|->
name|in_statement
operator|=
name|IN_ITERATION_STMT
expr_stmt|;
name|cp_parser_already_scoped_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_statement
operator|=
name|in_statement
expr_stmt|;
comment|/* We're done with the while-statement.  */
name|finish_while_stmt
argument_list|(
name|statement
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RID_DO
case|:
block|{
name|tree
name|expression
decl_stmt|;
comment|/* Begin the do-statement.  */
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|statement
operator|=
name|begin_do_stmt
argument_list|(
name|attributes
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
comment|/* Parse the body of the do-statement.  */
name|parser
operator|->
name|in_statement
operator|=
name|IN_ITERATION_STMT
expr_stmt|;
name|cp_parser_implicitly_scoped_statement
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_statement
operator|=
name|in_statement
expr_stmt|;
name|finish_do_body
argument_list|(
name|statement
argument_list|)
expr_stmt|;
comment|/* Look for the `while' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_WHILE
argument_list|,
literal|"`while'"
argument_list|)
expr_stmt|;
comment|/* Look for the `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Parse the expression.  */
name|expression
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* We're done with the do-statement.  */
name|finish_do_stmt
argument_list|(
name|expression
argument_list|,
name|statement
argument_list|)
expr_stmt|;
comment|/* Look for the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Look for the `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RID_FOR
case|:
block|{
name|tree
name|condition
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|expression
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Begin the for-statement.  */
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|statement
operator|=
name|begin_for_stmt
argument_list|(
name|attributes
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
comment|/* Look for the `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Parse the initialization.  */
name|cp_parser_for_init_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|finish_for_init_stmt
argument_list|(
name|statement
argument_list|)
expr_stmt|;
comment|/* If there's a condition, process it.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|condition
operator|=
name|cp_parser_condition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|finish_for_cond
argument_list|(
name|condition
argument_list|,
name|statement
argument_list|)
expr_stmt|;
comment|/* Look for the `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
comment|/* If there's an expression, process it.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|expression
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
name|finish_for_expr
argument_list|(
name|expression
argument_list|,
name|statement
argument_list|)
expr_stmt|;
comment|/* Look for the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Parse the body of the for-statement.  */
name|parser
operator|->
name|in_statement
operator|=
name|IN_ITERATION_STMT
expr_stmt|;
name|cp_parser_already_scoped_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_statement
operator|=
name|in_statement
expr_stmt|;
comment|/* We're done with the for-statement.  */
name|finish_for_stmt
argument_list|(
name|statement
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected iteration-statement"
argument_list|)
expr_stmt|;
name|statement
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
return|return
name|statement
return|;
block|}
end_function

begin_comment
comment|/* Parse a for-init-statement.     for-init-statement:      expression-statement      simple-declaration  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_for_init_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* If the next token is a `;', then we have an empty      expression-statement.  Grammatically, this is also a      simple-declaration, but an invalid one, because it does not      declare anything.  Therefore, if we did not handle this case      specially, we would issue an error message about an invalid      declaration.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
comment|/* We're going to speculatively look for a declaration, falling back 	 to an expression, if necessary.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the declaration.  */
name|cp_parser_simple_declaration
argument_list|(
name|parser
argument_list|,
comment|/*function_definition_allowed_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If the tentative parse failed, then we shall need to look for an 	 expression-statement.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return;
block|}
name|cp_parser_expression_statement
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a jump-statement.     jump-statement:      break ;      continue ;      return expression [opt] ;      goto identifier ;     GNU extension:     jump-statement:      goto * expression ;     Returns the new BREAK_STMT, CONTINUE_STMT, RETURN_EXPR, or GOTO_EXPR.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_jump_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|statement
init|=
name|error_mark_node
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|rid
name|keyword
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|,
literal|"jump-statement"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
name|error_mark_node
return|;
comment|/* See what kind of keyword it is.  */
name|keyword
operator|=
name|token
operator|->
name|keyword
expr_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_BREAK
case|:
switch|switch
condition|(
name|parser
operator|->
name|in_statement
condition|)
block|{
case|case
literal|0
case|:
name|error
argument_list|(
literal|"break statement not within loop or switch"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_assert
argument_list|(
operator|(
name|parser
operator|->
name|in_statement
operator|&
name|IN_SWITCH_STMT
operator|)
operator|||
name|parser
operator|->
name|in_statement
operator|==
name|IN_ITERATION_STMT
argument_list|)
expr_stmt|;
name|statement
operator|=
name|finish_break_stmt
argument_list|()
expr_stmt|;
break|break;
case|case
name|IN_OMP_BLOCK
case|:
name|error
argument_list|(
literal|"invalid exit from OpenMP structured block"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IN_OMP_FOR
case|:
name|error
argument_list|(
literal|"break statement used with OpenMP for loop"
argument_list|)
expr_stmt|;
break|break;
block|}
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"%<;%>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_CONTINUE
case|:
switch|switch
condition|(
name|parser
operator|->
name|in_statement
operator|&
operator|~
name|IN_SWITCH_STMT
condition|)
block|{
case|case
literal|0
case|:
name|error
argument_list|(
literal|"continue statement not within a loop"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IN_ITERATION_STMT
case|:
case|case
name|IN_OMP_FOR
case|:
name|statement
operator|=
name|finish_continue_stmt
argument_list|()
expr_stmt|;
break|break;
case|case
name|IN_OMP_BLOCK
case|:
name|error
argument_list|(
literal|"invalid exit from OpenMP structured block"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"%<;%>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_RETURN
case|:
block|{
name|tree
name|expr
decl_stmt|;
comment|/* If the next token is a `;', then there is no 	   expression.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|expr
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Build the return-statement.  */
name|statement
operator|=
name|finish_return_stmt
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Look for the final `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"%<;%>"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RID_GOTO
case|:
comment|/* Create the goto-statement.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_MULT
argument_list|)
condition|)
block|{
comment|/* Issue a warning about this use of a GNU extension.  */
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids computed gotos"
argument_list|)
expr_stmt|;
comment|/* Consume the '*' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the dependent expression.  */
name|finish_goto_stmt
argument_list|(
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|finish_goto_stmt
argument_list|(
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Look for the final `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"%<;%>"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected jump-statement"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|statement
return|;
block|}
end_function

begin_comment
comment|/* Parse a declaration-statement.     declaration-statement:      block-declaration  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_declaration_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
comment|/* Get the high-water mark for the DECLARATOR_OBSTACK.  */
name|p
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|declarator_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Parse the block-declaration.  */
name|cp_parser_block_declaration
argument_list|(
name|parser
argument_list|,
comment|/*statement_p=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Free any declarators allocated.  */
name|obstack_free
argument_list|(
operator|&
name|declarator_obstack
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Finish off the statement.  */
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Some dependent statements (like `if (cond) statement'), are    implicitly in their own scope.  In other words, if the statement is    a single statement (as opposed to a compound-statement), it is    none-the-less treated as if it were enclosed in braces.  Any    declarations appearing in the dependent statement are out of scope    after control passes that point.  This function parses a statement,    but ensures that is in its own scope, even if it is not a    compound-statement.     If IF_P is not NULL, *IF_P is set to indicate whether the statement    is a (possibly labeled) if statement which is not enclosed in    braces and has an else clause.  This is used to implement    -Wparentheses.     Returns the new statement.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_implicitly_scoped_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
modifier|*
name|if_p
parameter_list|)
block|{
name|tree
name|statement
decl_stmt|;
if|if
condition|(
name|if_p
operator|!=
name|NULL
condition|)
operator|*
name|if_p
operator|=
name|false
expr_stmt|;
comment|/* Mark if () ; with a special NOP_EXPR.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|statement
operator|=
name|add_stmt
argument_list|(
name|build_empty_stmt
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* if a compound is opened, we simply parse the statement directly.  */
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
name|statement
operator|=
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* If the token is not a `{', then we must take special action.  */
else|else
block|{
comment|/* Create a compound-statement.  */
name|statement
operator|=
name|begin_compound_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Parse the dependent-statement.  */
name|cp_parser_statement
argument_list|(
name|parser
argument_list|,
name|NULL_TREE
argument_list|,
name|false
argument_list|,
name|if_p
argument_list|)
expr_stmt|;
comment|/* Finish the dummy compound-statement.  */
name|finish_compound_stmt
argument_list|(
name|statement
argument_list|)
expr_stmt|;
block|}
comment|/* Return the statement.  */
return|return
name|statement
return|;
block|}
end_function

begin_comment
comment|/* For some dependent statements (like `while (cond) statement'), we    have already created a scope.  Therefore, even if the dependent    statement is a compound-statement, we do not want to create another    scope.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_already_scoped_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* If the token is a `{', then we must take special action.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
name|cp_parser_statement
argument_list|(
name|parser
argument_list|,
name|NULL_TREE
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Avoid calling cp_parser_compound_statement, so that we 	 don't create a new scope.  Do everything else by hand.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|,
literal|"`{'"
argument_list|)
expr_stmt|;
name|cp_parser_statement_seq_opt
argument_list|(
name|parser
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Declarations [gram.dcl.dcl] */
end_comment

begin_comment
comment|/* Parse an optional declaration-sequence.     declaration-seq:      declaration      declaration-seq declaration  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_declaration_seq_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_EOF
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_PRAGMA_EOL
condition|)
break|break;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_SEMICOLON
condition|)
block|{
comment|/* A declaration consisting of a single semicolon is 	     invalid.  Allow it unless we're being pedantic.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"extra %<;%>"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we're entering or exiting a region that's implicitly 	 extern "C", modify the lang context appropriately.  */
if|if
condition|(
operator|!
name|parser
operator|->
name|implicit_extern_c
operator|&&
name|token
operator|->
name|implicit_extern_c
condition|)
block|{
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
name|parser
operator|->
name|implicit_extern_c
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parser
operator|->
name|implicit_extern_c
operator|&&
operator|!
name|token
operator|->
name|implicit_extern_c
condition|)
block|{
name|pop_lang_context
argument_list|()
expr_stmt|;
name|parser
operator|->
name|implicit_extern_c
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PRAGMA
condition|)
block|{
comment|/* A top-level declaration can consist solely of a #pragma. 	     A nested declaration cannot, so this is done here and not 	     in cp_parser_declaration.  (A #pragma at block scope is 	     handled in cp_parser_statement.)  */
name|cp_parser_pragma
argument_list|(
name|parser
argument_list|,
name|pragma_external
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Parse the declaration itself.  */
name|cp_parser_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a declaration.     declaration:      block-declaration      function-definition      template-declaration      explicit-instantiation      explicit-specialization      linkage-specification      namespace-definition     GNU extension:     declaration:       __extension__ declaration */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
name|token1
decl_stmt|;
name|cp_token
name|token2
decl_stmt|;
name|int
name|saved_pedantic
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
comment|/* Check for the `__extension__' keyword.  */
if|if
condition|(
name|cp_parser_extension_opt
argument_list|(
name|parser
argument_list|,
operator|&
name|saved_pedantic
argument_list|)
condition|)
block|{
comment|/* Parse the qualified declaration.  */
name|cp_parser_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Restore the PEDANTIC flag.  */
name|pedantic
operator|=
name|saved_pedantic
expr_stmt|;
return|return;
block|}
comment|/* Try to figure out what kind of declaration is present.  */
name|token1
operator|=
operator|*
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token1
operator|.
name|type
operator|!=
name|CPP_EOF
condition|)
name|token2
operator|=
operator|*
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
name|token2
operator|.
name|type
operator|=
name|CPP_EOF
expr_stmt|;
name|token2
operator|.
name|keyword
operator|=
name|RID_MAX
expr_stmt|;
block|}
comment|/* Get the high-water mark for the DECLARATOR_OBSTACK.  */
name|p
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|declarator_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the next token is `extern' and the following token is a string      literal, then we have a linkage specification.  */
if|if
condition|(
name|token1
operator|.
name|keyword
operator|==
name|RID_EXTERN
operator|&&
name|cp_parser_is_string_literal
argument_list|(
operator|&
name|token2
argument_list|)
condition|)
name|cp_parser_linkage_specification
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is `template', then we have either a template      declaration, an explicit instantiation, or an explicit      specialization.  */
elseif|else
if|if
condition|(
name|token1
operator|.
name|keyword
operator|==
name|RID_TEMPLATE
condition|)
block|{
comment|/* `template<>' indicates a template specialization.  */
if|if
condition|(
name|token2
operator|.
name|type
operator|==
name|CPP_LESS
operator|&&
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|3
argument_list|)
operator|->
name|type
operator|==
name|CPP_GREATER
condition|)
name|cp_parser_explicit_specialization
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* `template<' indicates a template declaration.  */
elseif|else
if|if
condition|(
name|token2
operator|.
name|type
operator|==
name|CPP_LESS
condition|)
name|cp_parser_template_declaration
argument_list|(
name|parser
argument_list|,
comment|/*member_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Anything else must be an explicit instantiation.  */
else|else
name|cp_parser_explicit_instantiation
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* If the next token is `export', then we have a template      declaration.  */
elseif|else
if|if
condition|(
name|token1
operator|.
name|keyword
operator|==
name|RID_EXPORT
condition|)
name|cp_parser_template_declaration
argument_list|(
name|parser
argument_list|,
comment|/*member_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If the next token is `extern', 'static' or 'inline' and the one      after that is `template', we have a GNU extended explicit      instantiation directive.  */
elseif|else
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
operator|(
name|token1
operator|.
name|keyword
operator|==
name|RID_EXTERN
operator|||
name|token1
operator|.
name|keyword
operator|==
name|RID_STATIC
operator|||
name|token1
operator|.
name|keyword
operator|==
name|RID_INLINE
operator|)
operator|&&
name|token2
operator|.
name|keyword
operator|==
name|RID_TEMPLATE
condition|)
name|cp_parser_explicit_instantiation
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is `namespace', check for a named or unnamed      namespace definition.  */
elseif|else
if|if
condition|(
name|token1
operator|.
name|keyword
operator|==
name|RID_NAMESPACE
operator|&&
operator|(
comment|/* A named namespace definition.  */
operator|(
name|token2
operator|.
name|type
operator|==
name|CPP_NAME
operator|&&
operator|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|3
argument_list|)
operator|->
name|type
operator|!=
name|CPP_EQ
operator|)
operator|)
comment|/* An unnamed namespace definition.  */
operator|||
name|token2
operator|.
name|type
operator|==
name|CPP_OPEN_BRACE
operator|||
name|token2
operator|.
name|keyword
operator|==
name|RID_ATTRIBUTE
operator|)
condition|)
name|cp_parser_namespace_definition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Objective-C++ declaration/definition.  */
elseif|else
if|if
condition|(
name|c_dialect_objc
argument_list|()
operator|&&
name|OBJC_IS_AT_KEYWORD
argument_list|(
name|token1
operator|.
name|keyword
argument_list|)
condition|)
name|cp_parser_objc_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* We must have either a block declaration or a function      definition.  */
else|else
comment|/* Try to parse a block-declaration, or a function-definition.  */
name|cp_parser_block_declaration
argument_list|(
name|parser
argument_list|,
comment|/*statement_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Free any declarators allocated.  */
name|obstack_free
argument_list|(
operator|&
name|declarator_obstack
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a block-declaration.     block-declaration:      simple-declaration      asm-definition      namespace-alias-definition      using-declaration      using-directive     GNU Extension:     block-declaration:      __extension__ block-declaration      label-declaration     If STATEMENT_P is TRUE, then this block-declaration is occurring as    part of a declaration-statement.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_block_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|statement_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token1
decl_stmt|;
name|int
name|saved_pedantic
decl_stmt|;
comment|/* Check for the `__extension__' keyword.  */
if|if
condition|(
name|cp_parser_extension_opt
argument_list|(
name|parser
argument_list|,
operator|&
name|saved_pedantic
argument_list|)
condition|)
block|{
comment|/* Parse the qualified declaration.  */
name|cp_parser_block_declaration
argument_list|(
name|parser
argument_list|,
name|statement_p
argument_list|)
expr_stmt|;
comment|/* Restore the PEDANTIC flag.  */
name|pedantic
operator|=
name|saved_pedantic
expr_stmt|;
return|return;
block|}
comment|/* Peek at the next token to figure out which kind of declaration is      present.  */
name|token1
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next keyword is `asm', we have an asm-definition.  */
if|if
condition|(
name|token1
operator|->
name|keyword
operator|==
name|RID_ASM
condition|)
block|{
if|if
condition|(
name|statement_p
condition|)
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_asm_definition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* If the next keyword is `namespace', we have a      namespace-alias-definition.  */
elseif|else
if|if
condition|(
name|token1
operator|->
name|keyword
operator|==
name|RID_NAMESPACE
condition|)
name|cp_parser_namespace_alias_definition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next keyword is `using', we have either a      using-declaration or a using-directive.  */
elseif|else
if|if
condition|(
name|token1
operator|->
name|keyword
operator|==
name|RID_USING
condition|)
block|{
name|cp_token
modifier|*
name|token2
decl_stmt|;
if|if
condition|(
name|statement_p
condition|)
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the token after `using' is `namespace', then we have a 	 using-directive.  */
name|token2
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|token2
operator|->
name|keyword
operator|==
name|RID_NAMESPACE
condition|)
name|cp_parser_using_directive
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Otherwise, it's a using-declaration.  */
else|else
name|cp_parser_using_declaration
argument_list|(
name|parser
argument_list|,
comment|/*access_declaration_p=*/
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* If the next keyword is `__label__' we have a label declaration.  */
elseif|else
if|if
condition|(
name|token1
operator|->
name|keyword
operator|==
name|RID_LABEL
condition|)
block|{
if|if
condition|(
name|statement_p
condition|)
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_label_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Anything else must be a simple-declaration.  */
else|else
name|cp_parser_simple_declaration
argument_list|(
name|parser
argument_list|,
operator|!
name|statement_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a simple-declaration.     simple-declaration:      decl-specifier-seq [opt] init-declarator-list [opt] ;     init-declarator-list:      init-declarator      init-declarator-list , init-declarator     If FUNCTION_DEFINITION_ALLOWED_P is TRUE, then we also recognize a    function-definition as a simple-declaration.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_simple_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|function_definition_allowed_p
parameter_list|)
block|{
name|cp_decl_specifier_seq
name|decl_specifiers
decl_stmt|;
name|int
name|declares_class_or_enum
decl_stmt|;
name|bool
name|saw_declarator
decl_stmt|;
comment|/* Defer access checks until we know what is being declared; the      checks for names appearing in the decl-specifier-seq should be      done as if we were in the scope of the thing being declared.  */
name|push_deferring_access_checks
argument_list|(
name|dk_deferred
argument_list|)
expr_stmt|;
comment|/* Parse the decl-specifier-seq.  We have to keep track of whether      or not the decl-specifier-seq declares a named class or      enumeration type, since that is the only case in which the      init-declarator-list is allowed to be empty.       [dcl.dcl]       In a simple-declaration, the optional init-declarator-list can be      omitted only when declaring a class or enumeration, that is when      the decl-specifier-seq contains either a class-specifier, an      elaborated-type-specifier, or an enum-specifier.  */
name|cp_parser_decl_specifier_seq
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_FLAGS_OPTIONAL
argument_list|,
operator|&
name|decl_specifiers
argument_list|,
operator|&
name|declares_class_or_enum
argument_list|)
expr_stmt|;
comment|/* We no longer need to defer access checks.  */
name|stop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* In a block scope, a valid declaration must always have a      decl-specifier-seq.  By not trying to parse declarators, we can      resolve the declaration/expression ambiguity more quickly.  */
if|if
condition|(
operator|!
name|function_definition_allowed_p
operator|&&
operator|!
name|decl_specifiers
operator|.
name|any_specifiers_p
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected declaration"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* If the next two tokens are both identifiers, the code is      erroneous. The usual cause of this situation is code like:         T t;       where "T" should name a type -- but does not.  */
if|if
condition|(
operator|!
name|decl_specifiers
operator|.
name|type
operator|&&
name|cp_parser_parse_and_diagnose_invalid_type_name
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* If parsing tentatively, we should commit; we really are 	 looking at a declaration.  */
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Give up.  */
goto|goto
name|done
goto|;
block|}
comment|/* If we have seen at least one decl-specifier, and the next token      is not a parenthesis, then we must be looking at a declaration.      (After "int (" we might be looking at a functional cast.)  */
if|if
condition|(
name|decl_specifiers
operator|.
name|any_specifiers_p
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Keep going until we hit the `;' at the end of the simple      declaration.  */
name|saw_declarator
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|bool
name|function_definition_p
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|saw_declarator
condition|)
block|{
comment|/* If we are processing next declarator, coma is expected */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
argument_list|)
expr_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
else|else
name|saw_declarator
operator|=
name|true
expr_stmt|;
comment|/* Parse the init-declarator.  */
name|decl
operator|=
name|cp_parser_init_declarator
argument_list|(
name|parser
argument_list|,
operator|&
name|decl_specifiers
argument_list|,
comment|/*checks=*/
name|NULL
argument_list|,
name|function_definition_allowed_p
argument_list|,
comment|/*member_p=*/
name|false
argument_list|,
name|declares_class_or_enum
argument_list|,
operator|&
name|function_definition_p
argument_list|)
expr_stmt|;
comment|/* If an error occurred while parsing tentatively, exit quickly. 	 (That usually happens when in the body of a function; each 	 statement is treated as a declaration-statement until proven 	 otherwise.)  */
if|if
condition|(
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* Handle function definitions specially.  */
if|if
condition|(
name|function_definition_p
condition|)
block|{
comment|/* If the next token is a `,', then we are probably 	     processing something like:  	       void f() {}, *p;  	     which is erroneous.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|error
argument_list|(
literal|"mixing declarations and function-definitions is forbidden"
argument_list|)
expr_stmt|;
comment|/* Otherwise, we're done with the list of declarators.  */
else|else
block|{
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* The next token should be either a `,' or a `;'.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's a `,', there are more declarators to come.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
condition|)
comment|/* will be consumed next time around */
empty_stmt|;
comment|/* If it's a `;', we are done.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_SEMICOLON
condition|)
break|break;
comment|/* Anything else is an error.  */
else|else
block|{
comment|/* If we have already issued an error message we don't need 	     to issue another one.  */
if|if
condition|(
name|decl
operator|!=
name|error_mark_node
operator|||
name|cp_parser_uncommitted_to_tentative_parse_p
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<,%> or %<;%>"
argument_list|)
expr_stmt|;
comment|/* Skip tokens until we reach the end of the statement.  */
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is now a `;', consume it.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* After the first time around, a function-definition is not 	 allowed -- even if it was OK at first.  For example:  	   int i, f() {}  	 is not valid.  */
name|function_definition_allowed_p
operator|=
name|false
expr_stmt|;
block|}
comment|/* Issue an error message if no declarators are present, and the      decl-specifier-seq does not itself declare a class or      enumeration.  */
if|if
condition|(
operator|!
name|saw_declarator
condition|)
block|{
if|if
condition|(
name|cp_parser_declares_only_class_p
argument_list|(
name|parser
argument_list|)
condition|)
name|shadow_tag
argument_list|(
operator|&
name|decl_specifiers
argument_list|)
expr_stmt|;
comment|/* Perform any deferred access checks.  */
name|perform_deferred_access_checks
argument_list|()
expr_stmt|;
block|}
comment|/* Consume the `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
name|done
label|:
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a decl-specifier-seq.     decl-specifier-seq:      decl-specifier-seq [opt] decl-specifier     decl-specifier:      storage-class-specifier      type-specifier      function-specifier      friend      typedef     GNU Extension:     decl-specifier:      attributes     Set *DECL_SPECS to a representation of the decl-specifier-seq.     The parser flags FLAGS is used to control type-specifier parsing.     *DECLARES_CLASS_OR_ENUM is set to the bitwise or of the following    flags:       1: one of the decl-specifiers is an elaborated-type-specifier 	(i.e., a type declaration)      2: one of the decl-specifiers is an enum-specifier or a 	class-specifier (i.e., a type definition)     */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_decl_specifier_seq
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_parser_flags
name|flags
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
name|decl_specs
parameter_list|,
name|int
modifier|*
name|declares_class_or_enum
parameter_list|)
block|{
name|bool
name|constructor_possible_p
init|=
operator|!
name|parser
operator|->
name|in_declarator_p
decl_stmt|;
comment|/* Clear DECL_SPECS.  */
name|clear_decl_specs
argument_list|(
name|decl_specs
argument_list|)
expr_stmt|;
comment|/* Assume no class or enumeration type is declared.  */
operator|*
name|declares_class_or_enum
operator|=
literal|0
expr_stmt|;
comment|/* Keep reading specifiers until there are no more to read.  */
while|while
condition|(
name|true
condition|)
block|{
name|bool
name|constructor_p
decl_stmt|;
name|bool
name|found_decl_spec
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Handle attributes.  */
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_ATTRIBUTE
condition|)
block|{
comment|/* Parse the attributes.  */
name|decl_specs
operator|->
name|attributes
operator|=
name|chainon
argument_list|(
name|decl_specs
operator|->
name|attributes
argument_list|,
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Assume we will find a decl-specifier keyword.  */
name|found_decl_spec
operator|=
name|true
expr_stmt|;
comment|/* If the next token is an appropriate keyword, we can simply 	 add it to the list.  */
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
comment|/* decl-specifier: 	       friend  */
case|case
name|RID_FRIEND
case|:
if|if
condition|(
operator|!
name|at_class_scope_p
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"%<friend%> used outside of class"
argument_list|)
expr_stmt|;
name|cp_lexer_purge_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_friend
index|]
expr_stmt|;
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* function-specifier: 	       inline 	       virtual 	       explicit  */
case|case
name|RID_INLINE
case|:
case|case
name|RID_VIRTUAL
case|:
case|case
name|RID_EXPLICIT
case|:
name|cp_parser_function_specifier_opt
argument_list|(
name|parser
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
break|break;
comment|/* decl-specifier: 	       typedef  */
case|case
name|RID_TYPEDEF
case|:
operator|++
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_typedef
index|]
expr_stmt|;
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* A constructor declarator cannot appear in a typedef.  */
name|constructor_possible_p
operator|=
name|false
expr_stmt|;
comment|/* The "typedef" keyword can only occur in a declaration; we 	     may as well commit at this point.  */
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_specs
operator|->
name|storage_class
operator|!=
name|sc_none
condition|)
name|decl_specs
operator|->
name|conflicting_specifiers_p
operator|=
name|true
expr_stmt|;
break|break;
comment|/* storage-class-specifier: 	       auto 	       register 	       static 	       extern 	       mutable  	     GNU Extension: 	       thread  */
case|case
name|RID_AUTO
case|:
case|case
name|RID_REGISTER
case|:
case|case
name|RID_STATIC
case|:
case|case
name|RID_EXTERN
case|:
case|case
name|RID_MUTABLE
case|:
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|cp_parser_set_storage_class
argument_list|(
name|parser
argument_list|,
name|decl_specs
argument_list|,
name|token
operator|->
name|keyword
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_THREAD
case|:
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
operator|++
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_thread
index|]
expr_stmt|;
break|break;
default|default:
comment|/* We did not yet find a decl-specifier yet.  */
name|found_decl_spec
operator|=
name|false
expr_stmt|;
break|break;
block|}
comment|/* Constructors are a special case.  The `S' in `S()' is not a 	 decl-specifier; it is the beginning of the declarator.  */
name|constructor_p
operator|=
operator|(
operator|!
name|found_decl_spec
operator|&&
name|constructor_possible_p
operator|&&
operator|(
name|cp_parser_constructor_declarator_p
argument_list|(
name|parser
argument_list|,
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_friend
index|]
operator|!=
literal|0
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* If we don't have a DECL_SPEC yet, then we must be looking at 	 a type-specifier.  */
if|if
condition|(
operator|!
name|found_decl_spec
operator|&&
operator|!
name|constructor_p
condition|)
block|{
name|int
name|decl_spec_declares_class_or_enum
decl_stmt|;
name|bool
name|is_cv_qualifier
decl_stmt|;
name|tree
name|type_spec
decl_stmt|;
name|type_spec
operator|=
name|cp_parser_type_specifier
argument_list|(
name|parser
argument_list|,
name|flags
argument_list|,
name|decl_specs
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|,
operator|&
name|decl_spec_declares_class_or_enum
argument_list|,
operator|&
name|is_cv_qualifier
argument_list|)
expr_stmt|;
operator|*
name|declares_class_or_enum
operator||=
name|decl_spec_declares_class_or_enum
expr_stmt|;
comment|/* If this type-specifier referenced a user-defined type 	     (a typedef, class-name, etc.), then we can't allow any 	     more such type-specifiers henceforth.  	     [dcl.spec]  	     The longest sequence of decl-specifiers that could 	     possibly be a type name is taken as the 	     decl-specifier-seq of a declaration.  The sequence shall 	     be self-consistent as described below.  	     [dcl.type]  	     As a general rule, at most one type-specifier is allowed 	     in the complete decl-specifier-seq of a declaration.  The 	     only exceptions are the following:  	     -- const or volatile can be combined with any other 		type-specifier.  	     -- signed or unsigned can be combined with char, long, 		short, or int.  	     -- ..  	     Example:  	       typedef char* Pc; 	       void g (const int Pc);  	     Here, Pc is *not* part of the decl-specifier seq; it's 	     the declarator.  Therefore, once we see a type-specifier 	     (other than a cv-qualifier), we forbid any additional 	     user-defined types.  We *do* still allow things like `int 	     int' to be considered a decl-specifier-seq, and issue the 	     error message later.  */
if|if
condition|(
name|type_spec
operator|&&
operator|!
name|is_cv_qualifier
condition|)
name|flags
operator||=
name|CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES
expr_stmt|;
comment|/* A constructor declarator cannot follow a type-specifier.  */
if|if
condition|(
name|type_spec
condition|)
block|{
name|constructor_possible_p
operator|=
name|false
expr_stmt|;
name|found_decl_spec
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* If we still do not have a DECL_SPEC, then there are no more 	 decl-specifiers.  */
if|if
condition|(
operator|!
name|found_decl_spec
condition|)
break|break;
name|decl_specs
operator|->
name|any_specifiers_p
operator|=
name|true
expr_stmt|;
comment|/* After we see one decl-specifier, further decl-specifiers are 	 always optional.  */
name|flags
operator||=
name|CP_PARSER_FLAGS_OPTIONAL
expr_stmt|;
block|}
name|cp_parser_check_decl_spec
argument_list|(
name|decl_specs
argument_list|)
expr_stmt|;
comment|/* Don't allow a friend specifier with a class definition.  */
if|if
condition|(
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_friend
index|]
operator|!=
literal|0
operator|&&
operator|(
operator|*
name|declares_class_or_enum
operator|&
literal|2
operator|)
condition|)
name|error
argument_list|(
literal|"class definition may not be declared a friend"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) storage-class-specifier.     storage-class-specifier:      auto      register      static      extern      mutable     GNU Extension:     storage-class-specifier:      thread     Returns an IDENTIFIER_NODE corresponding to the keyword used.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_storage_class_specifier_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
switch|switch
condition|(
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_AUTO
case|:
case|case
name|RID_REGISTER
case|:
case|case
name|RID_STATIC
case|:
case|case
name|RID_EXTERN
case|:
case|case
name|RID_MUTABLE
case|:
case|case
name|RID_THREAD
case|:
comment|/* Consume the token.  */
return|return
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|u
operator|.
name|value
return|;
default|default:
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an (optional) function-specifier.     function-specifier:      inline      virtual      explicit     Returns an IDENTIFIER_NODE corresponding to the keyword used.    Updates DECL_SPECS, if it is non-NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_function_specifier_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
name|decl_specs
parameter_list|)
block|{
switch|switch
condition|(
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_INLINE
case|:
if|if
condition|(
name|decl_specs
condition|)
operator|++
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_inline
index|]
expr_stmt|;
break|break;
case|case
name|RID_VIRTUAL
case|:
comment|/* 14.5.2.3 [temp.mem]  	 A member function template shall not be virtual.  */
if|if
condition|(
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
condition|)
name|error
argument_list|(
literal|"templates may not be %<virtual%>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_specs
condition|)
operator|++
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_virtual
index|]
expr_stmt|;
break|break;
case|case
name|RID_EXPLICIT
case|:
if|if
condition|(
name|decl_specs
condition|)
operator|++
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_explicit
index|]
expr_stmt|;
break|break;
default|default:
return|return
name|NULL_TREE
return|;
block|}
comment|/* Consume the token.  */
return|return
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|u
operator|.
name|value
return|;
block|}
end_function

begin_comment
comment|/* Parse a linkage-specification.     linkage-specification:      extern string-literal { declaration-seq [opt] }      extern string-literal declaration  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_linkage_specification
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|linkage
decl_stmt|;
comment|/* Look for the `extern' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_EXTERN
argument_list|,
literal|"`extern'"
argument_list|)
expr_stmt|;
comment|/* Look for the string-literal.  */
name|linkage
operator|=
name|cp_parser_string_literal
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Transform the literal into an identifier.  If the literal is a      wide-character string, or contains embedded NULs, then we can't      handle it as the user wants.  */
if|if
condition|(
name|strlen
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|linkage
argument_list|)
argument_list|)
operator|!=
call|(
name|size_t
call|)
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|linkage
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"invalid linkage-specification"
argument_list|)
expr_stmt|;
comment|/* Assume C++ linkage.  */
name|linkage
operator|=
name|lang_name_cplusplus
expr_stmt|;
block|}
else|else
name|linkage
operator|=
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|linkage
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're now using the new linkage.  */
name|push_lang_context
argument_list|(
name|linkage
argument_list|)
expr_stmt|;
comment|/* If the next token is a `{', then we're using the first      production.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
block|{
comment|/* Consume the `{' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the declarations.  */
name|cp_parser_declaration_seq_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the closing `}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, there's just one declaration.  */
else|else
block|{
name|bool
name|saved_in_unbraced_linkage_specification_p
decl_stmt|;
name|saved_in_unbraced_linkage_specification_p
operator|=
name|parser
operator|->
name|in_unbraced_linkage_specification_p
expr_stmt|;
name|parser
operator|->
name|in_unbraced_linkage_specification_p
operator|=
name|true
expr_stmt|;
name|cp_parser_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_unbraced_linkage_specification_p
operator|=
name|saved_in_unbraced_linkage_specification_p
expr_stmt|;
block|}
comment|/* We're done with the linkage-specification.  */
name|pop_lang_context
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Special member functions [gram.special] */
end_comment

begin_comment
comment|/* Parse a conversion-function-id.     conversion-function-id:      operator conversion-type-id     Returns an IDENTIFIER_NODE representing the operator.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_conversion_function_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|saved_scope
decl_stmt|;
name|tree
name|saved_qualifying_scope
decl_stmt|;
name|tree
name|saved_object_scope
decl_stmt|;
name|tree
name|pushed_scope
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Look for the `operator' token.  */
if|if
condition|(
operator|!
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_OPERATOR
argument_list|,
literal|"`operator'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* When we parse the conversion-type-id, the current scope will be      reset.  However, we need that information in able to look up the      conversion function later, so we save it here.  */
name|saved_scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|saved_qualifying_scope
operator|=
name|parser
operator|->
name|qualifying_scope
expr_stmt|;
name|saved_object_scope
operator|=
name|parser
operator|->
name|object_scope
expr_stmt|;
comment|/* We must enter the scope of the class so that the names of      entities declared within the class are available in the      conversion-type-id.  For example, consider:         struct S { 	 typedef int I; 	 operator I();        };         S::operator I() { ... }       In order to see that `I' is a type-name in the definition, we      must be in the scope of `S'.  */
if|if
condition|(
name|saved_scope
condition|)
name|pushed_scope
operator|=
name|push_scope
argument_list|(
name|saved_scope
argument_list|)
expr_stmt|;
comment|/* Parse the conversion-type-id.  */
name|type
operator|=
name|cp_parser_conversion_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Leave the scope of the class, if any.  */
if|if
condition|(
name|pushed_scope
condition|)
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
comment|/* Restore the saved scope.  */
name|parser
operator|->
name|scope
operator|=
name|saved_scope
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|saved_qualifying_scope
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|saved_object_scope
expr_stmt|;
comment|/* If the TYPE is invalid, indicate failure.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|mangle_conv_op_name_for_type
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a conversion-type-id:     conversion-type-id:      type-specifier-seq conversion-declarator [opt]     Returns the TYPE specified.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_conversion_type_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|attributes
decl_stmt|;
name|cp_decl_specifier_seq
name|type_specifiers
decl_stmt|;
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
name|tree
name|type_specified
decl_stmt|;
comment|/* Parse the attributes.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the type-specifiers.  */
name|cp_parser_type_specifier_seq
argument_list|(
name|parser
argument_list|,
comment|/*is_condition=*/
name|false
argument_list|,
operator|&
name|type_specifiers
argument_list|)
expr_stmt|;
comment|/* If that didn't work, stop.  */
if|if
condition|(
name|type_specifiers
operator|.
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Parse the conversion-declarator.  */
name|declarator
operator|=
name|cp_parser_conversion_declarator_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|type_specified
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
operator|&
name|type_specifiers
argument_list|,
name|TYPENAME
argument_list|,
comment|/*initialized=*/
literal|0
argument_list|,
operator|&
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|attributes
condition|)
name|cplus_decl_attributes
argument_list|(
operator|&
name|type_specified
argument_list|,
name|attributes
argument_list|,
comment|/*flags=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|type_specified
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) conversion-declarator.     conversion-declarator:      ptr-operator conversion-declarator [opt]     */
end_comment

begin_function
specifier|static
name|cp_declarator
modifier|*
name|cp_parser_conversion_declarator_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|class_type
decl_stmt|;
name|cp_cv_quals
name|cv_quals
decl_stmt|;
comment|/* We don't know if there's a ptr-operator next, or not.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try the ptr-operator.  */
name|code
operator|=
name|cp_parser_ptr_operator
argument_list|(
name|parser
argument_list|,
operator|&
name|class_type
argument_list|,
operator|&
name|cv_quals
argument_list|)
expr_stmt|;
comment|/* If it worked, look for more conversion-declarators.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
comment|/* Parse another optional declarator.  */
name|declarator
operator|=
name|cp_parser_conversion_declarator_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Create the representation of the declarator.  */
if|if
condition|(
name|class_type
condition|)
name|declarator
operator|=
name|make_ptrmem_declarator
argument_list|(
name|cv_quals
argument_list|,
name|class_type
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|INDIRECT_REF
condition|)
name|declarator
operator|=
name|make_pointer_declarator
argument_list|(
name|cv_quals
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
else|else
name|declarator
operator|=
name|make_reference_declarator
argument_list|(
name|cv_quals
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|declarator
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) ctor-initializer.     ctor-initializer:      : mem-initializer-list     Returns TRUE iff the ctor-initializer was actually present.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_ctor_initializer_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* If the next token is not a `:', then there is no      ctor-initializer.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
block|{
comment|/* Do default initialization of any bases and members.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|finish_mem_initializers
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Consume the `:' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* And the mem-initializer-list.  */
name|cp_parser_mem_initializer_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Parse a mem-initializer-list.     mem-initializer-list:      mem-initializer      mem-initializer , mem-initializer-list  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_mem_initializer_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|mem_initializer_list
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Let the semantic analysis code know that we are starting the      mem-initializer-list.  */
if|if
condition|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"only constructors take base initializers"
argument_list|)
expr_stmt|;
comment|/* Loop through the list.  */
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|mem_initializer
decl_stmt|;
comment|/* Parse the mem-initializer.  */
name|mem_initializer
operator|=
name|cp_parser_mem_initializer
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Add it to the list, unless it was erroneous.  */
if|if
condition|(
name|mem_initializer
operator|!=
name|error_mark_node
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|mem_initializer
argument_list|)
operator|=
name|mem_initializer_list
expr_stmt|;
name|mem_initializer_list
operator|=
name|mem_initializer
expr_stmt|;
block|}
comment|/* If the next token is not a `,', we're done.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
comment|/* Consume the `,' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* Perform semantic analysis.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|finish_mem_initializers
argument_list|(
name|mem_initializer_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a mem-initializer.     mem-initializer:      mem-initializer-id ( expression-list [opt] )     GNU extension:     mem-initializer:      ( expression-list [opt] )     Returns a TREE_LIST.  The TREE_PURPOSE is the TYPE (for a base    class) or FIELD_DECL (for a non-static data member) to initialize;    the TREE_VALUE is the expression-list.  An empty initialization    list is represented by void_list_node.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_mem_initializer
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|mem_initializer_id
decl_stmt|;
name|tree
name|expression_list
decl_stmt|;
name|tree
name|member
decl_stmt|;
comment|/* Find out what is being initialized.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"anachronistic old-style base class initializer"
argument_list|)
expr_stmt|;
name|mem_initializer_id
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|mem_initializer_id
operator|=
name|cp_parser_mem_initializer_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|member
operator|=
name|expand_member_init
argument_list|(
name|mem_initializer_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|&&
operator|!
name|DECL_P
argument_list|(
name|member
argument_list|)
condition|)
name|in_base_initializer
operator|=
literal|1
expr_stmt|;
name|expression_list
operator|=
name|cp_parser_parenthesized_expression_list
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|,
comment|/*non_constant_p=*/
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|expression_list
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|expression_list
condition|)
name|expression_list
operator|=
name|void_type_node
expr_stmt|;
name|in_base_initializer
operator|=
literal|0
expr_stmt|;
return|return
name|member
condition|?
name|build_tree_list
argument_list|(
name|member
argument_list|,
name|expression_list
argument_list|)
else|:
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Parse a mem-initializer-id.     mem-initializer-id:      :: [opt] nested-name-specifier [opt] class-name      identifier     Returns a TYPE indicating the class to be initializer for the first    production.  Returns an IDENTIFIER_NODE indicating the data member    to be initialized for the second production.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_mem_initializer_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|bool
name|global_scope_p
decl_stmt|;
name|bool
name|nested_name_specifier_p
decl_stmt|;
name|bool
name|template_p
init|=
name|false
decl_stmt|;
name|tree
name|id
decl_stmt|;
comment|/* `typename' is not allowed in this context ([temp.res]).  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TYPENAME
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"keyword %<typename%> not allowed in this context (a qualified "
literal|"member initializer is implicitly a type)"
argument_list|)
expr_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* Look for the optional `::' operator.  */
name|global_scope_p
operator|=
operator|(
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Look for the optional nested-name-specifier.  The simplest way to      implement:         [temp.res]         The keyword `typename' is not permitted in a base-specifier or        mem-initializer; in these contexts a qualified name that        depends on a template-parameter is implicitly assumed to be a        type name.       is to assume that we have seen the `typename' keyword at this      point.  */
name|nested_name_specifier_p
operator|=
operator|(
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|true
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|true
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
if|if
condition|(
name|nested_name_specifier_p
condition|)
name|template_p
operator|=
name|cp_parser_optional_template_keyword
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If there is a `::' operator or a nested-name-specifier, then we      are definitely looking for a class-name.  */
if|if
condition|(
name|global_scope_p
operator|||
name|nested_name_specifier_p
condition|)
return|return
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|true
argument_list|,
comment|/*template_keyword_p=*/
name|template_p
argument_list|,
name|none_type
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
return|;
comment|/* Otherwise, we could also be looking for an ordinary identifier.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try a class-name.  */
name|id
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|true
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
name|none_type
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
comment|/* If we found one, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|id
return|;
comment|/* Otherwise, look for an ordinary identifier.  */
return|return
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Overloading [gram.over] */
end_comment

begin_comment
comment|/* Parse an operator-function-id.     operator-function-id:      operator operator     Returns an IDENTIFIER_NODE for the operator which is a    human-readable spelling of the identifier, e.g., `operator +'.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_operator_function_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Look for the `operator' keyword.  */
if|if
condition|(
operator|!
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_OPERATOR
argument_list|,
literal|"`operator'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* And then the name of the operator itself.  */
return|return
name|cp_parser_operator
argument_list|(
name|parser
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an operator.     operator:      new delete new[] delete[] + - * / % ^& | ~ ! =<>      += -= *= /= %= ^=&= |=<<>>>>=<<= == !=<=>=&&      || ++ -- , ->* -> () []     GNU Extensions:     operator:<?>?<?=>?=     Returns an IDENTIFIER_NODE for the operator which is a    human-readable spelling of the identifier, e.g., `operator +'.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_operator
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|id
init|=
name|NULL_TREE
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Figure out which operator we have.  */
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_KEYWORD
case|:
block|{
name|enum
name|tree_code
name|op
decl_stmt|;
comment|/* The keyword should be either `new' or `delete'.  */
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_NEW
condition|)
name|op
operator|=
name|NEW_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_DELETE
condition|)
name|op
operator|=
name|DELETE_EXPR
expr_stmt|;
else|else
break|break;
comment|/* Consume the `new' or `delete' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's a `[' token then this is the array variant of the 	   operator.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_SQUARE
condition|)
block|{
comment|/* Consume the `[' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the `]' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"`]'"
argument_list|)
expr_stmt|;
name|id
operator|=
name|ansi_opname
argument_list|(
name|op
operator|==
name|NEW_EXPR
condition|?
name|VEC_NEW_EXPR
else|:
name|VEC_DELETE_EXPR
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, we have the non-array variant.  */
else|else
name|id
operator|=
name|ansi_opname
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
case|case
name|CPP_PLUS
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|PLUS_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MINUS
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|MINUS_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MULT
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|MULT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_DIV
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MOD
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_XOR
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|BIT_XOR_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_AND
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|BIT_AND_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_OR
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|BIT_IOR_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_COMPL
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|BIT_NOT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_NOT
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|NOP_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_LESS
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|LT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_GREATER
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|GT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_PLUS_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|PLUS_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MINUS_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|MINUS_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MULT_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|MULT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_DIV_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MOD_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_XOR_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|BIT_XOR_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_AND_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|BIT_AND_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_OR_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|BIT_IOR_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_LSHIFT
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|LSHIFT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_RSHIFT
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|RSHIFT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_LSHIFT_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|LSHIFT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_RSHIFT_EQ
case|:
name|id
operator|=
name|ansi_assopname
argument_list|(
name|RSHIFT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_EQ_EQ
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|EQ_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_NOT_EQ
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|NE_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_LESS_EQ
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|LE_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_GREATER_EQ
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|GE_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_AND_AND
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_OR_OR
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_PLUS_PLUS
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|POSTINCREMENT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MINUS_MINUS
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|PREDECREMENT_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_COMMA
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|COMPOUND_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_DEREF_STAR
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|MEMBER_REF
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_DEREF
case|:
name|id
operator|=
name|ansi_opname
argument_list|(
name|COMPONENT_REF
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_OPEN_PAREN
case|:
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the matching `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
return|return
name|ansi_opname
argument_list|(
name|CALL_EXPR
argument_list|)
return|;
case|case
name|CPP_OPEN_SQUARE
case|:
comment|/* Consume the `['.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the matching `]'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"`]'"
argument_list|)
expr_stmt|;
return|return
name|ansi_opname
argument_list|(
name|ARRAY_REF
argument_list|)
return|;
default|default:
comment|/* Anything else is an error.  */
break|break;
block|}
comment|/* If we have selected an identifier, we need to consume the      operator token.  */
if|if
condition|(
name|id
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Otherwise, no valid operator name was present.  */
else|else
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected operator"
argument_list|)
expr_stmt|;
name|id
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|id
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-declaration.     template-declaration:      export [opt] template< template-parameter-list> declaration     If MEMBER_P is TRUE, this template-declaration occurs within a    class-specifier.     The grammar rule given by the standard isn't correct.  What    is really meant is:     template-declaration:      export [opt] template-parameter-list-seq        decl-specifier-seq [opt] init-declarator [opt] ;      export [opt] template-parameter-list-seq        function-definition     template-parameter-list-seq:      template-parameter-list-seq [opt]      template< template-parameter-list>  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_template_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|member_p
parameter_list|)
block|{
comment|/* Check for `export'.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_EXPORT
argument_list|)
condition|)
block|{
comment|/* Consume the `export' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Warn that we do not support `export'.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"keyword %<export%> not implemented, and will be ignored"
argument_list|)
expr_stmt|;
block|}
name|cp_parser_template_declaration_after_export
argument_list|(
name|parser
argument_list|,
name|member_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a template-parameter-list.     template-parameter-list:      template-parameter      template-parameter-list , template-parameter     Returns a TREE_LIST.  Each node represents a template parameter.    The nodes are connected via their TREE_CHAINs.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_template_parameter_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|parameter_list
init|=
name|NULL_TREE
decl_stmt|;
name|begin_template_parm_list
argument_list|()
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|parameter
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|bool
name|is_non_type
decl_stmt|;
comment|/* Parse the template-parameter.  */
name|parameter
operator|=
name|cp_parser_template_parameter
argument_list|(
name|parser
argument_list|,
operator|&
name|is_non_type
argument_list|)
expr_stmt|;
comment|/* Add it to the list.  */
if|if
condition|(
name|parameter
operator|!=
name|error_mark_node
condition|)
name|parameter_list
operator|=
name|process_template_parm
argument_list|(
name|parameter_list
argument_list|,
name|parameter
argument_list|,
name|is_non_type
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|err_parm
init|=
name|build_tree_list
argument_list|(
name|parameter
argument_list|,
name|parameter
argument_list|)
decl_stmt|;
name|TREE_VALUE
argument_list|(
name|err_parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|parameter_list
operator|=
name|chainon
argument_list|(
name|parameter_list
argument_list|,
name|err_parm
argument_list|)
expr_stmt|;
block|}
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's not a `,', we're done.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_COMMA
condition|)
break|break;
comment|/* Otherwise, consume the `,' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
return|return
name|end_template_parm_list
argument_list|(
name|parameter_list
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-parameter.     template-parameter:      type-parameter      parameter-declaration     If all goes well, returns a TREE_LIST.  The TREE_VALUE represents    the parameter.  The TREE_PURPOSE is the default value, if any.    Returns ERROR_MARK_NODE on failure.  *IS_NON_TYPE is set to true    iff this parameter is a non-type parameter.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_template_parameter
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
modifier|*
name|is_non_type
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|cp_parameter_declarator
modifier|*
name|parameter_declarator
decl_stmt|;
name|tree
name|parm
decl_stmt|;
comment|/* Assume it is a type parameter or a template parameter.  */
operator|*
name|is_non_type
operator|=
name|false
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it is `class' or `template', we have a type-parameter.  */
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_TEMPLATE
condition|)
return|return
name|cp_parser_type_parameter
argument_list|(
name|parser
argument_list|)
return|;
comment|/* If it is `class' or `typename' we do not know yet whether it is a      type parameter or a non-type parameter.  Consider:         template<typename T, typename T::X X> ...       or:         template<class C, class D*> ...       Here, the first parameter is a type parameter, and the second is      a non-type parameter.  We can tell by looking at the token after      the identifier -- if it is a `,', `=', or `>' then we have a type      parameter.  */
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_TYPENAME
operator|||
name|token
operator|->
name|keyword
operator|==
name|RID_CLASS
condition|)
block|{
comment|/* Peek at the token after `class' or `typename'.  */
name|token
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If it's an identifier, skip it.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
name|token
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Now, see if the token looks like the end of a template 	 parameter.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_EQ
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_GREATER
condition|)
return|return
name|cp_parser_type_parameter
argument_list|(
name|parser
argument_list|)
return|;
block|}
comment|/* Otherwise, it is a non-type parameter.       [temp.param]       When parsing a default template-argument for a non-type      template-parameter, the first non-nested `>' is taken as the end      of the template parameter-list rather than a greater-than      operator.  */
operator|*
name|is_non_type
operator|=
name|true
expr_stmt|;
name|parameter_declarator
operator|=
name|cp_parser_parameter_declaration
argument_list|(
name|parser
argument_list|,
comment|/*template_parm_p=*/
name|true
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|)
expr_stmt|;
name|parm
operator|=
name|grokdeclarator
argument_list|(
name|parameter_declarator
operator|->
name|declarator
argument_list|,
operator|&
name|parameter_declarator
operator|->
name|decl_specifiers
argument_list|,
name|PARM
argument_list|,
comment|/*initialized=*/
literal|0
argument_list|,
comment|/*attrlist=*/
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_tree_list
argument_list|(
name|parameter_declarator
operator|->
name|default_argument
argument_list|,
name|parm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a type-parameter.     type-parameter:      class identifier [opt]      class identifier [opt] = type-id      typename identifier [opt]      typename identifier [opt] = type-id      template< template-parameter-list> class identifier [opt]      template< template-parameter-list> class identifier [opt]        = id-expression     Returns a TREE_LIST.  The TREE_VALUE is itself a TREE_LIST.  The    TREE_PURPOSE is the default-argument, if any.  The TREE_VALUE is    the declaration of the parameter.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_type_parameter
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|parameter
decl_stmt|;
comment|/* Look for a keyword to tell us what kind of parameter this is.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|,
literal|"`class', `typename', or `template'"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_CLASS
case|:
case|case
name|RID_TYPENAME
case|:
block|{
name|tree
name|identifier
decl_stmt|;
name|tree
name|default_argument
decl_stmt|;
comment|/* If the next token is an identifier, then it names the 	   parameter.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|identifier
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Create the parameter.  */
name|parameter
operator|=
name|finish_template_type_parm
argument_list|(
name|class_type_node
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
comment|/* If the next token is an `=', we have a default argument.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EQ
argument_list|)
condition|)
block|{
comment|/* Consume the `=' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the default-argument.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_deferred
argument_list|)
expr_stmt|;
name|default_argument
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
block|}
else|else
name|default_argument
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Create the combined representation of the parameter and the 	   default argument.  */
name|parameter
operator|=
name|build_tree_list
argument_list|(
name|default_argument
argument_list|,
name|parameter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RID_TEMPLATE
case|:
block|{
name|tree
name|parameter_list
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|tree
name|default_argument
decl_stmt|;
comment|/* Look for the `<'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|,
literal|"`<'"
argument_list|)
expr_stmt|;
comment|/* Parse the template-parameter-list.  */
name|parameter_list
operator|=
name|cp_parser_template_parameter_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the `>'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_GREATER
argument_list|,
literal|"`>'"
argument_list|)
expr_stmt|;
comment|/* Look for the `class' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_CLASS
argument_list|,
literal|"`class'"
argument_list|)
expr_stmt|;
comment|/* If the next token is an `=', then there is a 	   default-argument.  If the next token is a `>', we are at 	   the end of the parameter-list.  If the next token is a `,', 	   then we are at the end of this parameter.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EQ
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_GREATER
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
block|{
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Treat invalid names as if the parameter were nameless.  */
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
name|identifier
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|identifier
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Create the template parameter.  */
name|parameter
operator|=
name|finish_template_template_parm
argument_list|(
name|class_type_node
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
comment|/* If the next token is an `=', then there is a 	   default-argument.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EQ
argument_list|)
condition|)
block|{
name|bool
name|is_template
decl_stmt|;
comment|/* Consume the `='.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the id-expression.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_deferred
argument_list|)
expr_stmt|;
name|default_argument
operator|=
name|cp_parser_id_expression
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*template_p=*/
operator|&
name|is_template
argument_list|,
comment|/*declarator_p=*/
name|false
argument_list|,
comment|/*optional_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|default_argument
argument_list|)
operator|==
name|TYPE_DECL
condition|)
comment|/* If the id-expression was a template-id that refers to 		 a template-class, we already have the declaration here, 		 so no further lookup is needed.  */
empty_stmt|;
else|else
comment|/* Look up the name.  */
name|default_argument
operator|=
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|default_argument
argument_list|,
name|none_type
argument_list|,
comment|/*is_template=*/
name|is_template
argument_list|,
comment|/*is_namespace=*/
name|false
argument_list|,
comment|/*check_dependency=*/
name|true
argument_list|,
comment|/*ambiguous_decls=*/
name|NULL
argument_list|)
expr_stmt|;
comment|/* See if the default argument is valid.  */
name|default_argument
operator|=
name|check_template_template_default_arg
argument_list|(
name|default_argument
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
block|}
else|else
name|default_argument
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Create the combined representation of the parameter and the 	   default argument.  */
name|parameter
operator|=
name|build_tree_list
argument_list|(
name|default_argument
argument_list|,
name|parameter
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|parameter
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-id.     template-id:      template-name< template-argument-list [opt]>     If TEMPLATE_KEYWORD_P is TRUE, then we have just seen the    `template' keyword.  In this case, a TEMPLATE_ID_EXPR will be    returned.  Otherwise, if the template-name names a function, or set    of functions, returns a TEMPLATE_ID_EXPR.  If the template-name    names a class, returns a TYPE_DECL for the specialization.     If CHECK_DEPENDENCY_P is FALSE, names are looked up in    uninstantiated templates.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_template_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|template_keyword_p
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
name|is_declaration
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|template
decl_stmt|;
name|tree
name|arguments
decl_stmt|;
name|tree
name|template_id
decl_stmt|;
name|cp_token_position
name|start_of_id
init|=
literal|0
decl_stmt|;
name|deferred_access_check
modifier|*
name|chk
decl_stmt|;
name|VEC
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|)
operator|*
name|access_check
expr_stmt|;
name|cp_token
modifier|*
name|next_token
decl_stmt|,
modifier|*
name|next_token_2
decl_stmt|;
name|bool
name|is_identifier
decl_stmt|;
comment|/* If the next token corresponds to a template-id, there is no need      to reparse it.  */
name|next_token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_token
operator|->
name|type
operator|==
name|CPP_TEMPLATE_ID
condition|)
block|{
name|struct
name|tree_check
modifier|*
name|check_value
decl_stmt|;
comment|/* Get the stored value.  */
name|check_value
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|u
operator|.
name|tree_check_value
expr_stmt|;
comment|/* Perform any access checks that were deferred.  */
name|access_check
operator|=
name|check_value
operator|->
name|checks
expr_stmt|;
if|if
condition|(
name|access_check
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|deferred_access_check
argument_list|,
name|access_check
argument_list|,
name|i
argument_list|,
name|chk
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|perform_or_defer_access_check
argument_list|(
name|chk
operator|->
name|binfo
argument_list|,
name|chk
operator|->
name|decl
argument_list|,
name|chk
operator|->
name|diag_decl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return the stored value.  */
return|return
name|check_value
operator|->
name|value
return|;
block|}
comment|/* Avoid performing name lookup if there is no possibility of      finding a template-id.  */
if|if
condition|(
operator|(
name|next_token
operator|->
name|type
operator|!=
name|CPP_NAME
operator|&&
name|next_token
operator|->
name|keyword
operator|!=
name|RID_OPERATOR
operator|)
operator|||
operator|(
name|next_token
operator|->
name|type
operator|==
name|CPP_NAME
operator|&&
operator|!
name|cp_parser_nth_token_starts_template_argument_list_p
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-id"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Remember where the template-id starts.  */
if|if
condition|(
name|cp_parser_uncommitted_to_tentative_parse_p
argument_list|(
name|parser
argument_list|)
condition|)
name|start_of_id
operator|=
name|cp_lexer_token_position
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|push_deferring_access_checks
argument_list|(
name|dk_deferred
argument_list|)
expr_stmt|;
comment|/* Parse the template-name.  */
name|is_identifier
operator|=
name|false
expr_stmt|;
name|template
operator|=
name|cp_parser_template_name
argument_list|(
name|parser
argument_list|,
name|template_keyword_p
argument_list|,
name|check_dependency_p
argument_list|,
name|is_declaration
argument_list|,
operator|&
name|is_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|template
operator|==
name|error_mark_node
operator|||
name|is_identifier
condition|)
block|{
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|template
return|;
block|}
comment|/* If we find the sequence `[:' after a template-name, it's probably      a digraph-typo for `< ::'. Substitute the tokens and check if we can      parse correctly the argument list.  */
name|next_token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|next_token_2
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_token
operator|->
name|type
operator|==
name|CPP_OPEN_SQUARE
operator|&&
name|next_token
operator|->
name|flags
operator|&
name|DIGRAPH
operator|&&
name|next_token_2
operator|->
name|type
operator|==
name|CPP_COLON
operator|&&
operator|!
operator|(
name|next_token_2
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|)
condition|)
block|{
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Change `:' into `::'.  */
name|next_token_2
operator|->
name|type
operator|=
name|CPP_SCOPE
expr_stmt|;
comment|/* Consume the first token (CPP_OPEN_SQUARE - which we pretend it is 	 CPP_LESS.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the arguments.  */
name|arguments
operator|=
name|cp_parser_enclosed_template_argument_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* If we couldn't parse an argument list, then we revert our changes 	     and return simply an error. Maybe this is not a template-id 	     after all.  */
name|next_token_2
operator|->
name|type
operator|=
name|CPP_COLON
expr_stmt|;
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<<%>"
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Otherwise, emit an error about the invalid digraph, but continue 	 parsing because we got our argument list.  */
name|pedwarn
argument_list|(
literal|"%<<::%> cannot begin a template-argument list"
argument_list|)
expr_stmt|;
name|inform
argument_list|(
literal|"%<<:%> is an alternate spelling for %<[%>. Insert whitespace "
literal|"between %<<%> and %<::%>"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_permissive
condition|)
block|{
specifier|static
name|bool
name|hint
decl_stmt|;
if|if
condition|(
operator|!
name|hint
condition|)
block|{
name|inform
argument_list|(
literal|"(if you use -fpermissive G++ will accept your code)"
argument_list|)
expr_stmt|;
name|hint
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Look for the `<' that starts the template-argument-list.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|,
literal|"`<'"
argument_list|)
condition|)
block|{
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Parse the arguments.  */
name|arguments
operator|=
name|cp_parser_enclosed_template_argument_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Build a representation of the specialization.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|template_id
operator|=
name|build_min_nt
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|template
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|template
argument_list|)
operator|||
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|template
argument_list|)
condition|)
block|{
name|bool
name|entering_scope
decl_stmt|;
comment|/* In "template<typename T> ... A<T>::", A<T> is the abstract A 	 template (rather than some instantiation thereof) only if 	 is not nested within some other construct.  For example, in 	 "template<typename T> void f(T) { A<T>::", A<T> is just an 	 instantiation of A.  */
name|entering_scope
operator|=
operator|(
name|template_parm_scope_p
argument_list|()
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
operator|)
expr_stmt|;
name|template_id
operator|=
name|finish_template_type
argument_list|(
name|template
argument_list|,
name|arguments
argument_list|,
name|entering_scope
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If it's not a class-template or a template-template, it should be 	 a function-template.  */
name|gcc_assert
argument_list|(
operator|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|template
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|==
name|OVERLOAD
operator|||
name|BASELINK_P
argument_list|(
name|template
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|template_id
operator|=
name|lookup_template_function
argument_list|(
name|template
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
block|}
comment|/* If parsing tentatively, replace the sequence of tokens that makes      up the template-id with a CPP_TEMPLATE_ID token.  That way,      should we re-parse the token stream, we will not have to repeat      the effort required to do the parse, nor will we issue duplicate      error messages about problems during instantiation of the      template.  */
if|if
condition|(
name|start_of_id
condition|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_token_at
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|start_of_id
argument_list|)
decl_stmt|;
comment|/* Reset the contents of the START_OF_ID token.  */
name|token
operator|->
name|type
operator|=
name|CPP_TEMPLATE_ID
expr_stmt|;
comment|/* Retrieve any deferred checks.  Do not pop this access checks yet 	 so the memory will not be reclaimed during token replacing below.  */
name|token
operator|->
name|u
operator|.
name|tree_check_value
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|tree_check
argument_list|)
expr_stmt|;
name|token
operator|->
name|u
operator|.
name|tree_check_value
operator|->
name|value
operator|=
name|template_id
expr_stmt|;
name|token
operator|->
name|u
operator|.
name|tree_check_value
operator|->
name|checks
operator|=
name|get_deferred_access_checks
argument_list|()
expr_stmt|;
name|token
operator|->
name|keyword
operator|=
name|RID_MAX
expr_stmt|;
comment|/* Purge all subsequent tokens.  */
name|cp_lexer_purge_tokens_after
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|start_of_id
argument_list|)
expr_stmt|;
comment|/* ??? Can we actually assume that, if template_id == 	 error_mark_node, we will have issued a diagnostic to the 	 user, as opposed to simply marking the tentative parse as 	 failed?  */
if|if
condition|(
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
operator|&&
name|template_id
operator|!=
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"parse error in template argument list"
argument_list|)
expr_stmt|;
block|}
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|template_id
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-name.     template-name:      identifier     The standard should actually say:     template-name:      identifier      operator-function-id     A defect report has been filed about this issue.     A conversion-function-id cannot be a template name because they cannot    be part of a template-id. In fact, looking at this code:     a.operator K<int>()     the conversion-function-id is "operator K<int>", and K<int> is a type-id.    It is impossible to call a templated conversion-function-id with an    explicit argument list, since the only allowed template parameter is    the type to which it is converting.     If TEMPLATE_KEYWORD_P is true, then we have just seen the    `template' keyword, in a construction like:       T::template f<3>()     In that case `f' is taken to be a template-name, even though there    is no way of knowing for sure.     Returns the TEMPLATE_DECL for the template, or an OVERLOAD if the    name refers to a set of overloaded functions, at least one of which    is a template, or an IDENTIFIER_NODE with the name of the template,    if TEMPLATE_KEYWORD_P is true.  If CHECK_DEPENDENCY_P is FALSE,    names are looked up inside uninstantiated templates.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_template_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|template_keyword_p
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
name|is_declaration
parameter_list|,
name|bool
modifier|*
name|is_identifier
parameter_list|)
block|{
name|tree
name|identifier
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|fns
decl_stmt|;
comment|/* If the next token is `operator', then we have either an      operator-function-id or a conversion-function-id.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_OPERATOR
argument_list|)
condition|)
block|{
comment|/* We don't know whether we're looking at an 	 operator-function-id or a conversion-function-id.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try an operator-function-id.  */
name|identifier
operator|=
name|cp_parser_operator_function_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If that didn't work, try a conversion-function-id.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-name"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Look for the identifier.  */
else|else
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If we didn't find an identifier, we don't have a template-id.  */
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* If the name immediately followed the `template' keyword, then it      is a template-name.  However, if the next token is not `<', then      we do not treat it as a template-name, since it is not being used      as part of a template-id.  This enables us to handle constructs      like:         template<typename T> struct S { S(); };        template<typename T> S<T>::S();       correctly.  We would treat `S' as a template -- if it were `S<T>'      -- but we do not if there is no `<'.  */
if|if
condition|(
name|processing_template_decl
operator|&&
name|cp_parser_nth_token_starts_template_argument_list_p
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* In a declaration, in a dependent context, we pretend that the 	 "template" keyword was present in order to improve error 	 recovery.  For example, given:  	   template<typename T> void f(T::X<int>);  	 we want to treat "X<int>" as a template-id.  */
if|if
condition|(
name|is_declaration
operator|&&
operator|!
name|template_keyword_p
operator|&&
name|parser
operator|->
name|scope
operator|&&
name|TYPE_P
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|&&
name|check_dependency_p
operator|&&
name|dependent_type_p
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
comment|/* Do not do this for dtors (or ctors), since they never 	     need the template keyword before their name.  */
operator|&&
operator|!
name|constructor_name_p
argument_list|(
name|identifier
argument_list|,
name|parser
operator|->
name|scope
argument_list|)
condition|)
block|{
name|cp_token_position
name|start
init|=
literal|0
decl_stmt|;
comment|/* Explain what went wrong.  */
name|error
argument_list|(
literal|"non-template %qD used as template"
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
name|inform
argument_list|(
literal|"use %<%T::template %D%> to indicate that it is a template"
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
comment|/* If parsing tentatively, find the location of the "<" token.  */
if|if
condition|(
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
condition|)
name|start
operator|=
name|cp_lexer_token_position
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Parse the template arguments so that we can issue error 	     messages about them.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|cp_parser_enclosed_template_argument_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Skip tokens until we find a good place from which to 	     continue parsing.  */
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
comment|/*recovering=*/
name|true
argument_list|,
comment|/*or_comma=*/
name|true
argument_list|,
comment|/*consume_paren=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If parsing tentatively, permanently remove the 	     template argument list.  That will prevent duplicate 	     error messages from being issued about the missing 	     "template" keyword.  */
if|if
condition|(
name|start
condition|)
name|cp_lexer_purge_tokens_after
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_identifier
condition|)
operator|*
name|is_identifier
operator|=
name|true
expr_stmt|;
return|return
name|identifier
return|;
block|}
comment|/* If the "template" keyword is present, then there is generally 	 no point in doing name-lookup, so we just return IDENTIFIER. 	 But, if the qualifying scope is non-dependent then we can 	 (and must) do name-lookup normally.  */
if|if
condition|(
name|template_keyword_p
operator|&&
operator|(
operator|!
name|parser
operator|->
name|scope
operator|||
operator|(
name|TYPE_P
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|)
operator|)
condition|)
return|return
name|identifier
return|;
block|}
comment|/* Look up the name.  */
name|decl
operator|=
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|,
name|none_type
argument_list|,
comment|/*is_template=*/
name|false
argument_list|,
comment|/*is_namespace=*/
name|false
argument_list|,
name|check_dependency_p
argument_list|,
comment|/*ambiguous_decls=*/
name|NULL
argument_list|)
expr_stmt|;
name|decl
operator|=
name|maybe_get_template_decl_from_type_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If DECL is a template, then the name was a template-name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
empty_stmt|;
else|else
block|{
name|tree
name|fn
init|=
name|NULL_TREE
decl_stmt|;
comment|/* The standard does not explicitly indicate whether a name that 	 names a set of overloaded declarations, some of which are 	 templates, is a template-name.  However, such a name should 	 be a template-name; otherwise, there is no way to form a 	 template-id for the overloaded templates.  */
name|fns
operator|=
name|BASELINK_P
argument_list|(
name|decl
argument_list|)
condition|?
name|BASELINK_FUNCTIONS
argument_list|(
name|decl
argument_list|)
else|:
name|decl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|OVERLOAD
condition|)
for|for
control|(
name|fn
operator|=
name|fns
init|;
name|fn
condition|;
name|fn
operator|=
name|OVL_NEXT
argument_list|(
name|fn
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
break|break;
if|if
condition|(
operator|!
name|fn
condition|)
block|{
comment|/* The name does not name a template.  */
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-name"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* If DECL is dependent, and refers to a function, then just return      its name; we will look it up again during template instantiation.  */
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|scope
init|=
name|CP_DECL_CONTEXT
argument_list|(
name|get_first_fn
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|scope
argument_list|)
condition|)
return|return
name|identifier
return|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-argument-list.     template-argument-list:      template-argument      template-argument-list , template-argument     Returns a TREE_VEC containing the arguments.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_template_argument_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|fixed_args
index|[
literal|10
index|]
decl_stmt|;
name|unsigned
name|n_args
init|=
literal|0
decl_stmt|;
name|unsigned
name|alloced
init|=
literal|10
decl_stmt|;
name|tree
modifier|*
name|arg_ary
init|=
name|fixed_args
decl_stmt|;
name|tree
name|vec
decl_stmt|;
name|bool
name|saved_in_template_argument_list_p
decl_stmt|;
name|bool
name|saved_ice_p
decl_stmt|;
name|bool
name|saved_non_ice_p
decl_stmt|;
name|saved_in_template_argument_list_p
operator|=
name|parser
operator|->
name|in_template_argument_list_p
expr_stmt|;
name|parser
operator|->
name|in_template_argument_list_p
operator|=
name|true
expr_stmt|;
comment|/* Even if the template-id appears in an integral      constant-expression, the contents of the argument list do      not.  */
name|saved_ice_p
operator|=
name|parser
operator|->
name|integral_constant_expression_p
expr_stmt|;
name|parser
operator|->
name|integral_constant_expression_p
operator|=
name|false
expr_stmt|;
name|saved_non_ice_p
operator|=
name|parser
operator|->
name|non_integral_constant_expression_p
expr_stmt|;
name|parser
operator|->
name|non_integral_constant_expression_p
operator|=
name|false
expr_stmt|;
comment|/* Parse the arguments.  */
do|do
block|{
name|tree
name|argument
decl_stmt|;
if|if
condition|(
name|n_args
condition|)
comment|/* Consume the comma.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the template-argument.  */
name|argument
operator|=
name|cp_parser_template_argument
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_args
operator|==
name|alloced
condition|)
block|{
name|alloced
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|arg_ary
operator|==
name|fixed_args
condition|)
block|{
name|arg_ary
operator|=
name|XNEWVEC
argument_list|(
name|tree
argument_list|,
name|alloced
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|arg_ary
argument_list|,
name|fixed_args
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|n_args
argument_list|)
expr_stmt|;
block|}
else|else
name|arg_ary
operator|=
name|XRESIZEVEC
argument_list|(
name|tree
argument_list|,
name|arg_ary
argument_list|,
name|alloced
argument_list|)
expr_stmt|;
block|}
name|arg_ary
index|[
name|n_args
operator|++
index|]
operator|=
name|argument
expr_stmt|;
block|}
do|while
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
do|;
name|vec
operator|=
name|make_tree_vec
argument_list|(
name|n_args
argument_list|)
expr_stmt|;
while|while
condition|(
name|n_args
operator|--
condition|)
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|n_args
argument_list|)
operator|=
name|arg_ary
index|[
name|n_args
index|]
expr_stmt|;
if|if
condition|(
name|arg_ary
operator|!=
name|fixed_args
condition|)
name|free
argument_list|(
name|arg_ary
argument_list|)
expr_stmt|;
name|parser
operator|->
name|non_integral_constant_expression_p
operator|=
name|saved_non_ice_p
expr_stmt|;
name|parser
operator|->
name|integral_constant_expression_p
operator|=
name|saved_ice_p
expr_stmt|;
name|parser
operator|->
name|in_template_argument_list_p
operator|=
name|saved_in_template_argument_list_p
expr_stmt|;
return|return
name|vec
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-argument.     template-argument:      assignment-expression      type-id      id-expression     The representation is that of an assignment-expression, type-id, or    id-expression -- except that the qualified id-expression is    evaluated, so that the value returned is either a DECL or an    OVERLOAD.     Although the standard says "assignment-expression", it forbids    throw-expressions or assignments in the template argument.    Therefore, we use "conditional-expression" instead.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_template_argument
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|argument
decl_stmt|;
name|bool
name|template_p
decl_stmt|;
name|bool
name|address_p
decl_stmt|;
name|bool
name|maybe_type_id
init|=
name|false
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|cp_id_kind
name|idk
decl_stmt|;
comment|/* There's really no way to know what we're looking at, so we just      try each alternative in order.         [temp.arg]         In a template-argument, an ambiguity between a type-id and an        expression is resolved to a type-id, regardless of the form of        the corresponding template-parameter.       Therefore, we try a type-id first.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|argument
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If there was no error parsing the type-id but the next token is a '>>',      we probably found a typo for '>>'. But there are type-id which are      also valid expressions. For instance:       struct X { int operator>> (int); };      template<int V> struct Foo {};      Foo<X ()>> 5> r;       Here 'X()' is a valid type-id of a function type, but the user just      wanted to write the expression "X()>> 5". Thus, we remember that we      found a valid type-id, but we still try to parse the argument as an      expression to see what happens.  */
if|if
condition|(
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_RSHIFT
argument_list|)
condition|)
block|{
name|maybe_type_id
operator|=
name|true
expr_stmt|;
name|cp_parser_abort_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the next token isn't a `,' or a `>', then this argument wasn't       really finished. This means that the argument is not a valid       type-id.  */
if|if
condition|(
operator|!
name|cp_parser_next_token_ends_template_argument_p
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-argument"
argument_list|)
expr_stmt|;
comment|/* If that worked, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|argument
return|;
block|}
comment|/* We're still not sure what the argument will be.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try a template.  */
name|argument
operator|=
name|cp_parser_id_expression
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
operator|&
name|template_p
argument_list|,
comment|/*declarator_p=*/
name|false
argument_list|,
comment|/*optional_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If the next token isn't a `,' or a `>', then this argument wasn't      really finished.  */
if|if
condition|(
operator|!
name|cp_parser_next_token_ends_template_argument_p
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-argument"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* Figure out what is being referred to.  If the id-expression 	 was for a class template specialization, then we will have a 	 TYPE_DECL at this point.  There is no need to do name lookup 	 at this point in that case.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|argument
operator|=
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|argument
argument_list|,
name|none_type
argument_list|,
comment|/*is_template=*/
name|template_p
argument_list|,
comment|/*is_namespace=*/
name|false
argument_list|,
comment|/*check_dependency=*/
name|true
argument_list|,
comment|/*ambiguous_decls=*/
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|!=
name|UNBOUND_CLASS_TEMPLATE
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-name"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|argument
return|;
comment|/* It must be a non-type argument.  There permitted cases are given      in [temp.arg.nontype]:       -- an integral constant-expression of integral or enumeration 	type; or       -- the name of a non-type template-parameter; or       -- the name of an object or function with external linkage...       -- the address of an object or function with external linkage...       -- a pointer to member...  */
comment|/* Look for a non-type template parameter.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|argument
operator|=
name|cp_parser_primary_expression
argument_list|(
name|parser
argument_list|,
comment|/*adress_p=*/
name|false
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|,
comment|/*template_arg_p=*/
name|true
argument_list|,
operator|&
name|idk
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|!=
name|TEMPLATE_PARM_INDEX
operator|||
operator|!
name|cp_parser_next_token_ends_template_argument_p
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|argument
return|;
block|}
comment|/* If the next token is "&", the argument must be the address of an      object or function with external linkage.  */
name|address_p
operator|=
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_AND
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_p
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* See if we might have an id-expression.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
operator|||
name|token
operator|->
name|keyword
operator|==
name|RID_OPERATOR
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_SCOPE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_TEMPLATE_ID
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_NESTED_NAME_SPECIFIER
condition|)
block|{
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|argument
operator|=
name|cp_parser_primary_expression
argument_list|(
name|parser
argument_list|,
name|address_p
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|,
comment|/*template_arg_p=*/
name|true
argument_list|,
operator|&
name|idk
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
operator|||
operator|!
name|cp_parser_next_token_ends_template_argument_p
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_abort_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|gcc_assert
argument_list|(
name|REFERENCE_REF_P
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
name|argument
operator|=
name|TREE_OPERAND
argument_list|(
name|argument
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* A variable without external linkage might still be a 		 valid constant-expression, so no error is issued here 		 if the external-linkage check fails.  */
if|if
condition|(
operator|!
name|address_p
operator|&&
operator|!
name|DECL_EXTERNAL_LINKAGE_P
argument_list|(
name|argument
argument_list|)
condition|)
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|argument
argument_list|)
condition|)
comment|/* All overloaded functions are allowed; if the external 	       linkage test does not pass, an error will be issued 	       later.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|address_p
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|==
name|OFFSET_REF
operator|||
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|==
name|SCOPE_REF
operator|)
condition|)
comment|/* A pointer-to-member.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
condition|)
empty_stmt|;
else|else
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
if|if
condition|(
name|address_p
condition|)
name|argument
operator|=
name|build_x_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|argument
argument_list|)
expr_stmt|;
return|return
name|argument
return|;
block|}
block|}
block|}
comment|/* If the argument started with "&", there are no other valid      alternatives at this point.  */
if|if
condition|(
name|address_p
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"invalid non-type template argument"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If the argument wasn't successfully parsed as a type-id followed      by '>>', the argument can only be a constant expression now.      Otherwise, we try parsing the constant-expression tentatively,      because the argument could really be a type-id.  */
if|if
condition|(
name|maybe_type_id
condition|)
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|argument
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant_p=*/
name|false
argument_list|,
comment|/*non_constant_p=*/
name|NULL
argument_list|)
expr_stmt|;
name|argument
operator|=
name|fold_non_dependent_expr
argument_list|(
name|argument
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|maybe_type_id
condition|)
return|return
name|argument
return|;
if|if
condition|(
operator|!
name|cp_parser_next_token_ends_template_argument_p
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-argument"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|argument
return|;
comment|/* We did our best to parse the argument as a non type-id, but that      was the only alternative that matched (albeit with a '>' after      it). We can assume it's just a typo from the user, and a      diagnostic will then be issued.  */
return|return
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an explicit-instantiation.     explicit-instantiation:      template declaration     Although the standard says `declaration', what it really means is:     explicit-instantiation:      template decl-specifier-seq [opt] declarator [opt] ;     Things like `template int S<int>::i = 5, int S<double>::j;' are not    supposed to be allowed.  A defect report has been filed about this    issue.     GNU Extension:     explicit-instantiation:      storage-class-specifier template        decl-specifier-seq [opt] declarator [opt] ;      function-specifier template        decl-specifier-seq [opt] declarator [opt] ;  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_explicit_instantiation
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|int
name|declares_class_or_enum
decl_stmt|;
name|cp_decl_specifier_seq
name|decl_specifiers
decl_stmt|;
name|tree
name|extension_specifier
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Look for an (optional) storage-class-specifier or      function-specifier.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|extension_specifier
operator|=
name|cp_parser_storage_class_specifier_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extension_specifier
condition|)
name|extension_specifier
operator|=
name|cp_parser_function_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*decl_specs=*/
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Look for the `template' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_TEMPLATE
argument_list|,
literal|"`template'"
argument_list|)
expr_stmt|;
comment|/* Let the front end know that we are processing an explicit      instantiation.  */
name|begin_explicit_instantiation
argument_list|()
expr_stmt|;
comment|/* [temp.explicit] says that we are supposed to ignore access      control while processing explicit instantiation directives.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
comment|/* Parse a decl-specifier-seq.  */
name|cp_parser_decl_specifier_seq
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_FLAGS_OPTIONAL
argument_list|,
operator|&
name|decl_specifiers
argument_list|,
operator|&
name|declares_class_or_enum
argument_list|)
expr_stmt|;
comment|/* If there was exactly one decl-specifier, and it declared a class,      and there's no declarator, then we have an explicit type      instantiation.  */
if|if
condition|(
name|declares_class_or_enum
operator|&&
name|cp_parser_declares_only_class_p
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|check_tag_decl
argument_list|(
operator|&
name|decl_specifiers
argument_list|)
expr_stmt|;
comment|/* Turn access control back on for names used during 	 template instantiation.  */
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|do_type_instantiation
argument_list|(
name|type
argument_list|,
name|extension_specifier
argument_list|,
comment|/*complain=*/
name|tf_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
name|tree
name|decl
decl_stmt|;
comment|/* Parse the declarator.  */
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_NAMED
argument_list|,
comment|/*ctor_dtor_or_conv_p=*/
name|NULL
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|,
comment|/*member_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|declares_class_or_enum
operator|&
literal|2
condition|)
name|cp_parser_check_for_definition_in_return_type
argument_list|(
name|declarator
argument_list|,
name|decl_specifiers
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|!=
name|cp_error_declarator
condition|)
block|{
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
operator|&
name|decl_specifiers
argument_list|,
name|NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|decl_specifiers
operator|.
name|attributes
argument_list|)
expr_stmt|;
comment|/* Turn access control back on for names used during 	     template instantiation.  */
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Do the explicit instantiation.  */
name|do_decl_instantiation
argument_list|(
name|decl
argument_list|,
name|extension_specifier
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Skip the body of the explicit instantiation.  */
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We're done with the instantiation.  */
name|end_explicit_instantiation
argument_list|()
expr_stmt|;
name|cp_parser_consume_semicolon_at_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an explicit-specialization.     explicit-specialization:      template<> declaration     Although the standard says `declaration', what it really means is:     explicit-specialization:      template<> decl-specifier [opt] init-declarator [opt] ;      template<> function-definition      template<> explicit-specialization      template<> template-declaration  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_explicit_specialization
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|bool
name|need_lang_pop
decl_stmt|;
comment|/* Look for the `template' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_TEMPLATE
argument_list|,
literal|"`template'"
argument_list|)
expr_stmt|;
comment|/* Look for the `<'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|,
literal|"`<'"
argument_list|)
expr_stmt|;
comment|/* Look for the `>'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_GREATER
argument_list|,
literal|"`>'"
argument_list|)
expr_stmt|;
comment|/* We have processed another parameter list.  */
operator|++
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
comment|/* [temp]       A template ... explicit specialization ... shall not have C      linkage.  */
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
block|{
name|error
argument_list|(
literal|"template specialization with C linkage"
argument_list|)
expr_stmt|;
comment|/* Give it C++ linkage to avoid confusing other parts of the 	 front end.  */
name|push_lang_context
argument_list|(
name|lang_name_cplusplus
argument_list|)
expr_stmt|;
name|need_lang_pop
operator|=
name|true
expr_stmt|;
block|}
else|else
name|need_lang_pop
operator|=
name|false
expr_stmt|;
comment|/* Let the front end know that we are beginning a specialization.  */
if|if
condition|(
operator|!
name|begin_specialization
argument_list|()
condition|)
block|{
name|end_specialization
argument_list|()
expr_stmt|;
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the next keyword is `template', we need to figure out whether      or not we're looking a template-declaration.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TEMPLATE
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|==
name|CPP_LESS
operator|&&
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|3
argument_list|)
operator|->
name|type
operator|!=
name|CPP_GREATER
condition|)
name|cp_parser_template_declaration_after_export
argument_list|(
name|parser
argument_list|,
comment|/*member_p=*/
name|false
argument_list|)
expr_stmt|;
else|else
name|cp_parser_explicit_specialization
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Parse the dependent declaration.  */
name|cp_parser_single_declaration
argument_list|(
name|parser
argument_list|,
comment|/*checks=*/
name|NULL
argument_list|,
comment|/*member_p=*/
name|false
argument_list|,
comment|/*friend_p=*/
name|NULL
argument_list|)
expr_stmt|;
comment|/* We're done with the specialization.  */
name|end_specialization
argument_list|()
expr_stmt|;
comment|/* For the erroneous case of a template with C linkage, we pushed an      implicit C++ linkage scope; exit that scope now.  */
if|if
condition|(
name|need_lang_pop
condition|)
name|pop_lang_context
argument_list|()
expr_stmt|;
comment|/* We're done with this parameter list.  */
operator|--
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a type-specifier.     type-specifier:      simple-type-specifier      class-specifier      enum-specifier      elaborated-type-specifier      cv-qualifier     GNU Extension:     type-specifier:      __complex__     Returns a representation of the type-specifier.  For a    class-specifier, enum-specifier, or elaborated-type-specifier, a    TREE_TYPE is returned; otherwise, a TYPE_DECL is returned.     The parser flags FLAGS is used to control type-specifier parsing.     If IS_DECLARATION is TRUE, then this type-specifier is appearing    in a decl-specifier-seq.     If DECLARES_CLASS_OR_ENUM is non-NULL, and the type-specifier is a    class-specifier, enum-specifier, or elaborated-type-specifier, then    *DECLARES_CLASS_OR_ENUM is set to a nonzero value.  The value is 1    if a type is declared; 2 if it is defined.  Otherwise, it is set to    zero.     If IS_CV_QUALIFIER is non-NULL, and the type-specifier is a    cv-qualifier, then IS_CV_QUALIFIER is set to TRUE.  Otherwise, it    is set to FALSE.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_type_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_parser_flags
name|flags
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
name|decl_specs
parameter_list|,
name|bool
name|is_declaration
parameter_list|,
name|int
modifier|*
name|declares_class_or_enum
parameter_list|,
name|bool
modifier|*
name|is_cv_qualifier
parameter_list|)
block|{
name|tree
name|type_spec
init|=
name|NULL_TREE
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|rid
name|keyword
decl_stmt|;
name|cp_decl_spec
name|ds
init|=
name|ds_last
decl_stmt|;
comment|/* Assume this type-specifier does not declare a new type.  */
if|if
condition|(
name|declares_class_or_enum
condition|)
operator|*
name|declares_class_or_enum
operator|=
literal|0
expr_stmt|;
comment|/* And that it does not specify a cv-qualifier.  */
if|if
condition|(
name|is_cv_qualifier
condition|)
operator|*
name|is_cv_qualifier
operator|=
name|false
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If we're looking at a keyword, we can use that to guide the      production we choose.  */
name|keyword
operator|=
name|token
operator|->
name|keyword
expr_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_ENUM
case|:
comment|/* Look for the enum-specifier.  */
name|type_spec
operator|=
name|cp_parser_enum_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If that worked, we're done.  */
if|if
condition|(
name|type_spec
condition|)
block|{
if|if
condition|(
name|declares_class_or_enum
condition|)
operator|*
name|declares_class_or_enum
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|decl_specs
condition|)
name|cp_parser_set_decl_spec_type
argument_list|(
name|decl_specs
argument_list|,
name|type_spec
argument_list|,
comment|/*user_defined_p=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|type_spec
return|;
block|}
else|else
goto|goto
name|elaborated_type_specifier
goto|;
comment|/* Any of these indicate either a class-specifier, or an 	 elaborated-type-specifier.  */
case|case
name|RID_CLASS
case|:
case|case
name|RID_STRUCT
case|:
case|case
name|RID_UNION
case|:
comment|/* Parse tentatively so that we can back up if we don't find a 	 class-specifier.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the class-specifier.  */
name|type_spec
operator|=
name|cp_parser_class_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If that worked, we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
if|if
condition|(
name|declares_class_or_enum
condition|)
operator|*
name|declares_class_or_enum
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|decl_specs
condition|)
name|cp_parser_set_decl_spec_type
argument_list|(
name|decl_specs
argument_list|,
name|type_spec
argument_list|,
comment|/*user_defined_p=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|type_spec
return|;
block|}
comment|/* Fall through.  */
name|elaborated_type_specifier
label|:
comment|/* We're declaring (not defining) a class or enum.  */
if|if
condition|(
name|declares_class_or_enum
condition|)
operator|*
name|declares_class_or_enum
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
name|RID_TYPENAME
case|:
comment|/* Look for an elaborated-type-specifier.  */
name|type_spec
operator|=
operator|(
name|cp_parser_elaborated_type_specifier
argument_list|(
name|parser
argument_list|,
name|decl_specs
operator|&&
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_friend
index|]
argument_list|,
name|is_declaration
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|decl_specs
condition|)
name|cp_parser_set_decl_spec_type
argument_list|(
name|decl_specs
argument_list|,
name|type_spec
argument_list|,
comment|/*user_defined_p=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|type_spec
return|;
case|case
name|RID_CONST
case|:
name|ds
operator|=
name|ds_const
expr_stmt|;
if|if
condition|(
name|is_cv_qualifier
condition|)
operator|*
name|is_cv_qualifier
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RID_VOLATILE
case|:
name|ds
operator|=
name|ds_volatile
expr_stmt|;
if|if
condition|(
name|is_cv_qualifier
condition|)
operator|*
name|is_cv_qualifier
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RID_RESTRICT
case|:
name|ds
operator|=
name|ds_restrict
expr_stmt|;
if|if
condition|(
name|is_cv_qualifier
condition|)
operator|*
name|is_cv_qualifier
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RID_COMPLEX
case|:
comment|/* The `__complex__' keyword is a GNU extension.  */
name|ds
operator|=
name|ds_complex
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Handle simple keywords.  */
if|if
condition|(
name|ds
operator|!=
name|ds_last
condition|)
block|{
if|if
condition|(
name|decl_specs
condition|)
block|{
operator|++
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds
index|]
expr_stmt|;
name|decl_specs
operator|->
name|any_specifiers_p
operator|=
name|true
expr_stmt|;
block|}
return|return
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|u
operator|.
name|value
return|;
block|}
comment|/* If we do not already have a type-specifier, assume we are looking      at a simple-type-specifier.  */
name|type_spec
operator|=
name|cp_parser_simple_type_specifier
argument_list|(
name|parser
argument_list|,
name|decl_specs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* If we didn't find a type-specifier, and a type-specifier was not      optional in this context, issue an error message.  */
if|if
condition|(
operator|!
name|type_spec
operator|&&
operator|!
operator|(
name|flags
operator|&
name|CP_PARSER_FLAGS_OPTIONAL
operator|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected type specifier"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|type_spec
return|;
block|}
end_function

begin_comment
comment|/* Parse a simple-type-specifier.     simple-type-specifier:      :: [opt] nested-name-specifier [opt] type-name      :: [opt] nested-name-specifier template template-id      char      wchar_t      bool      short      int      long      signed      unsigned      float      double      void     GNU Extension:     simple-type-specifier:      __typeof__ unary-expression      __typeof__ ( type-id )     Returns the indicated TYPE_DECL.  If DECL_SPECS is not NULL, it is    appropriately updated.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_simple_type_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
name|decl_specs
parameter_list|,
name|cp_parser_flags
name|flags
parameter_list|)
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If we're looking at a keyword, things are easy.  */
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_CHAR
case|:
if|if
condition|(
name|decl_specs
condition|)
name|decl_specs
operator|->
name|explicit_char_p
operator|=
name|true
expr_stmt|;
name|type
operator|=
name|char_type_node
expr_stmt|;
break|break;
case|case
name|RID_WCHAR
case|:
name|type
operator|=
name|wchar_type_node
expr_stmt|;
break|break;
case|case
name|RID_BOOL
case|:
name|type
operator|=
name|boolean_type_node
expr_stmt|;
break|break;
case|case
name|RID_SHORT
case|:
if|if
condition|(
name|decl_specs
condition|)
operator|++
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_short
index|]
expr_stmt|;
name|type
operator|=
name|short_integer_type_node
expr_stmt|;
break|break;
case|case
name|RID_INT
case|:
if|if
condition|(
name|decl_specs
condition|)
name|decl_specs
operator|->
name|explicit_int_p
operator|=
name|true
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
break|break;
case|case
name|RID_LONG
case|:
if|if
condition|(
name|decl_specs
condition|)
operator|++
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_long
index|]
expr_stmt|;
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
break|break;
case|case
name|RID_SIGNED
case|:
if|if
condition|(
name|decl_specs
condition|)
operator|++
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_signed
index|]
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
break|break;
case|case
name|RID_UNSIGNED
case|:
if|if
condition|(
name|decl_specs
condition|)
operator|++
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_unsigned
index|]
expr_stmt|;
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
break|break;
case|case
name|RID_FLOAT
case|:
name|type
operator|=
name|float_type_node
expr_stmt|;
break|break;
case|case
name|RID_DOUBLE
case|:
name|type
operator|=
name|double_type_node
expr_stmt|;
break|break;
case|case
name|RID_VOID
case|:
name|type
operator|=
name|void_type_node
expr_stmt|;
break|break;
case|case
name|RID_TYPEOF
case|:
comment|/* Consume the `typeof' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the operand to `typeof'.  */
name|type
operator|=
name|cp_parser_sizeof_operand
argument_list|(
name|parser
argument_list|,
name|RID_TYPEOF
argument_list|)
expr_stmt|;
comment|/* If it is not already a TYPE, take its type.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|finish_typeof
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_specs
condition|)
name|cp_parser_set_decl_spec_type
argument_list|(
name|decl_specs
argument_list|,
name|type
argument_list|,
comment|/*user_defined_p=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|type
return|;
default|default:
break|break;
block|}
comment|/* If the type-specifier was for a built-in type, we're done.  */
if|if
condition|(
name|type
condition|)
block|{
name|tree
name|id
decl_stmt|;
comment|/* Record the type.  */
if|if
condition|(
name|decl_specs
operator|&&
operator|(
name|token
operator|->
name|keyword
operator|!=
name|RID_SIGNED
operator|&&
name|token
operator|->
name|keyword
operator|!=
name|RID_UNSIGNED
operator|&&
name|token
operator|->
name|keyword
operator|!=
name|RID_SHORT
operator|&&
name|token
operator|->
name|keyword
operator|!=
name|RID_LONG
operator|)
condition|)
name|cp_parser_set_decl_spec_type
argument_list|(
name|decl_specs
argument_list|,
name|type
argument_list|,
comment|/*user_defined=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_specs
condition|)
name|decl_specs
operator|->
name|any_specifiers_p
operator|=
name|true
expr_stmt|;
comment|/* Consume the token.  */
name|id
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|u
operator|.
name|value
expr_stmt|;
comment|/* There is no valid C++ program where a non-template type is 	 followed by a "<".  That usually indicates that the user thought 	 that the type was a template.  */
name|cp_parser_check_for_invalid_template_id
argument_list|(
name|parser
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/* The type-specifier must be a user-defined type.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES
operator|)
condition|)
block|{
name|bool
name|qualified_p
decl_stmt|;
name|bool
name|global_p
decl_stmt|;
comment|/* Don't gobble tokens or issue error messages if this is an 	 optional type-specifier.  */
if|if
condition|(
name|flags
operator|&
name|CP_PARSER_FLAGS_OPTIONAL
condition|)
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the optional `::' operator.  */
name|global_p
operator|=
operator|(
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Look for the nested-name specifier.  */
name|qualified_p
operator|=
operator|(
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* If we have seen a nested-name-specifier, and the next token 	 is `template', then we are using the template-id production.  */
if|if
condition|(
name|parser
operator|->
name|scope
operator|&&
name|cp_parser_optional_template_keyword
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* Look for the template-id.  */
name|type
operator|=
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|true
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If the template-id did not name a type, we are out of 	     luck.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected template-id for type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* Otherwise, look for a type-name.  */
else|else
name|type
operator|=
name|cp_parser_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Keep track of all name-lookups performed in class scopes.  */
if|if
condition|(
name|type
operator|&&
operator|!
name|global_p
operator|&&
operator|!
name|qualified_p
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|maybe_note_name_used_in_class
argument_list|(
name|DECL_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If it didn't work out, we don't have a TYPE.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|CP_PARSER_FLAGS_OPTIONAL
operator|)
operator|&&
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|type
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|decl_specs
condition|)
name|cp_parser_set_decl_spec_type
argument_list|(
name|decl_specs
argument_list|,
name|type
argument_list|,
comment|/*user_defined=*/
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* If we didn't get a type-name, issue an error message.  */
if|if
condition|(
operator|!
name|type
operator|&&
operator|!
operator|(
name|flags
operator|&
name|CP_PARSER_FLAGS_OPTIONAL
operator|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected type-name"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* There is no valid C++ program where a non-template type is      followed by a "<".  That usually indicates that the user thought      that the type was a template.  */
if|if
condition|(
name|type
operator|&&
name|type
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* As a last-ditch effort, see if TYPE is an Objective-C type. 	 If it is, then the '<'...'>' enclose protocol names rather than 	 template arguments, and so everything is fine.  */
if|if
condition|(
name|c_dialect_objc
argument_list|()
operator|&&
operator|(
name|objc_is_id
argument_list|(
name|type
argument_list|)
operator|||
name|objc_is_class_name
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
name|tree
name|protos
init|=
name|cp_parser_objc_protocol_refs_opt
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|tree
name|qual_type
init|=
name|objc_get_protocol_qualified_type
argument_list|(
name|type
argument_list|,
name|protos
argument_list|)
decl_stmt|;
comment|/* Clobber the "unqualified" type previously entered into 	     DECL_SPECS with the new, improved protocol-qualified version.  */
if|if
condition|(
name|decl_specs
condition|)
name|decl_specs
operator|->
name|type
operator|=
name|qual_type
expr_stmt|;
return|return
name|qual_type
return|;
block|}
name|cp_parser_check_for_invalid_template_id
argument_list|(
name|parser
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Parse a type-name.     type-name:      class-name      enum-name      typedef-name     enum-name:      identifier     typedef-name:      identifier     Returns a TYPE_DECL for the type.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_type_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|type_decl
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
comment|/* We can't know yet whether it is a class-name or not.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Try a class-name.  */
name|type_decl
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
name|none_type
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If it's not a class-name, keep looking.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* It must be a typedef-name or an enum-name.  */
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Look up the type-name.  */
name|type_decl
operator|=
name|cp_parser_lookup_name_simple
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|(
name|objc_is_id
argument_list|(
name|identifier
argument_list|)
operator|||
name|objc_is_class_name
argument_list|(
name|identifier
argument_list|)
operator|)
condition|)
block|{
comment|/* See if this is an Objective-C type.  */
name|tree
name|protos
init|=
name|cp_parser_objc_protocol_refs_opt
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|objc_get_protocol_qualified_type
argument_list|(
name|identifier
argument_list|,
name|protos
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
condition|)
name|type_decl
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Issue an error if we did not find a type-name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
operator|!
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_name_lookup_error
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|,
name|type_decl
argument_list|,
literal|"is not a type"
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Remember that the name was used in the definition of the 	 current class so that we can check later to see if the 	 meaning would have been different after the class was 	 entirely defined.  */
elseif|else
if|if
condition|(
name|type_decl
operator|!=
name|error_mark_node
operator|&&
operator|!
name|parser
operator|->
name|scope
condition|)
name|maybe_note_name_used_in_class
argument_list|(
name|identifier
argument_list|,
name|type_decl
argument_list|)
expr_stmt|;
block|}
return|return
name|type_decl
return|;
block|}
end_function

begin_comment
comment|/* Parse an elaborated-type-specifier.  Note that the grammar given    here incorporates the resolution to DR68.     elaborated-type-specifier:      class-key :: [opt] nested-name-specifier [opt] identifier      class-key :: [opt] nested-name-specifier [opt] template [opt] template-id      enum :: [opt] nested-name-specifier [opt] identifier      typename :: [opt] nested-name-specifier identifier      typename :: [opt] nested-name-specifier template [opt]        template-id     GNU extension:     elaborated-type-specifier:      class-key attributes :: [opt] nested-name-specifier [opt] identifier      class-key attributes :: [opt] nested-name-specifier [opt] 	       template [opt] template-id      enum attributes :: [opt] nested-name-specifier [opt] identifier     If IS_FRIEND is TRUE, then this elaborated-type-specifier is being    declared `friend'.  If IS_DECLARATION is TRUE, then this    elaborated-type-specifier appears in a decl-specifiers-seq, i.e.,    something is being declared.     Returns the TYPE specified.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_elaborated_type_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|is_friend
parameter_list|,
name|bool
name|is_declaration
parameter_list|)
block|{
name|enum
name|tag_types
name|tag_type
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|attributes
init|=
name|NULL_TREE
decl_stmt|;
comment|/* See if we're looking at the `enum' keyword.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_ENUM
argument_list|)
condition|)
block|{
comment|/* Consume the `enum' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Remember that it's an enumeration type.  */
name|tag_type
operator|=
name|enum_type
expr_stmt|;
comment|/* Parse the attributes.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Or, it might be `typename'.  */
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TYPENAME
argument_list|)
condition|)
block|{
comment|/* Consume the `typename' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Remember that it's a `typename' type.  */
name|tag_type
operator|=
name|typename_type
expr_stmt|;
comment|/* The `typename' keyword is only allowed in templates.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|pedwarn
argument_list|(
literal|"using %<typename%> outside of template"
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise it must be a class-key.  */
else|else
block|{
name|tag_type
operator|=
name|cp_parser_class_key
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag_type
operator|==
name|none_type
condition|)
return|return
name|error_mark_node
return|;
comment|/* Parse the attributes.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Look for the `::' operator.  */
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the nested-name-specifier.  */
if|if
condition|(
name|tag_type
operator|==
name|typename_type
condition|)
block|{
if|if
condition|(
operator|!
name|cp_parser_nested_name_specifier
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|true
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|true
argument_list|,
name|is_declaration
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
else|else
comment|/* Even though `typename' is not present, the proposed resolution        to Core Issue 180 says that in `class A<T>::B', `B' should be        considered a type-name, even if `A<T>' is dependent.  */
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|true
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|true
argument_list|,
name|is_declaration
argument_list|)
expr_stmt|;
comment|/* For everything but enumeration types, consider a template-id.      For an enumeration type, consider only a plain identifier.  */
if|if
condition|(
name|tag_type
operator|!=
name|enum_type
condition|)
block|{
name|bool
name|template_p
init|=
name|false
decl_stmt|;
name|tree
name|decl
decl_stmt|;
comment|/* Allow the `template' keyword.  */
name|template_p
operator|=
name|cp_parser_optional_template_keyword
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If we didn't see `template', we don't know if there's a 	 template-id or not.  */
if|if
condition|(
operator|!
name|template_p
condition|)
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the template-id.  */
name|decl
operator|=
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
name|template_p
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
name|is_declaration
argument_list|)
expr_stmt|;
comment|/* If we didn't find a template-id, look for an ordinary 	 identifier.  */
if|if
condition|(
operator|!
name|template_p
operator|&&
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
empty_stmt|;
comment|/* If DECL is a TEMPLATE_ID_EXPR, and the `typename' keyword is 	 in effect, then we must assume that, upon instantiation, the 	 template will correspond to a class.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|&&
name|tag_type
operator|==
name|typename_type
condition|)
name|type
operator|=
name|make_typename_type
argument_list|(
name|parser
operator|->
name|scope
argument_list|,
name|decl
argument_list|,
name|typename_type
argument_list|,
comment|/*complain=*/
name|tf_error
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|type
condition|)
block|{
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
block|{
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* For a `typename', we needn't call xref_tag.  */
if|if
condition|(
name|tag_type
operator|==
name|typename_type
operator|&&
name|TREE_CODE
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
return|return
name|cp_parser_make_typename_type
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|identifier
argument_list|)
return|;
comment|/* Look up a qualified name in the usual way.  */
if|if
condition|(
name|parser
operator|->
name|scope
condition|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|ambiguous_decls
decl_stmt|;
name|decl
operator|=
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|,
name|tag_type
argument_list|,
comment|/*is_template=*/
name|false
argument_list|,
comment|/*is_namespace=*/
name|false
argument_list|,
comment|/*check_dependency=*/
name|true
argument_list|,
operator|&
name|ambiguous_decls
argument_list|)
expr_stmt|;
comment|/* If the lookup was ambiguous, an error will already have been 	     issued.  */
if|if
condition|(
name|ambiguous_decls
condition|)
return|return
name|error_mark_node
return|;
comment|/* If we are parsing friend declaration, DECL may be a 	     TEMPLATE_DECL tree node here.  However, we need to check 	     whether this TEMPLATE_DECL results in valid code.  Consider 	     the following example:  	       namespace N { 		 template<class T> class C {}; 	       } 	       class X { 		 template<class T> friend class N::C; // #1, valid code 	       }; 	       template<class T> class Y { 		 friend class N::C;		       // #2, invalid code 	       };  	     For both case #1 and #2, we arrive at a TEMPLATE_DECL after 	     name lookup of `N::C'.  We see that friend declaration must 	     be template for the code to be valid.  Note that 	     processing_template_decl does not work here since it is 	     always 1 for the above two cases.  */
name|decl
operator|=
operator|(
name|cp_parser_maybe_treat_template_as_class
argument_list|(
name|decl
argument_list|,
comment|/*tag_name_p=*/
name|is_friend
operator|&&
name|parser
operator|->
name|num_template_parameter_lists
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|cp_parser_diagnose_invalid_type_name
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|TYPENAME_TYPE
condition|)
block|{
name|bool
name|allow_template
init|=
operator|(
name|parser
operator|->
name|num_template_parameter_lists
operator|||
name|DECL_SELF_REFERENCE_P
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
name|type
operator|=
name|check_elaborated_type_specifier
argument_list|(
name|tag_type
argument_list|,
name|decl
argument_list|,
name|allow_template
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* An elaborated-type-specifier sometimes introduces a new type and 	     sometimes names an existing type.  Normally, the rule is that it 	     introduces a new type only if there is not an existing type of 	     the same name already in scope.  For example, given:  	       struct S {}; 	       void f() { struct S s; }  	     the `struct S' in the body of `f' is the same `struct S' as in 	     the global scope; the existing definition is used.  However, if 	     there were no global declaration, this would introduce a new 	     local class named `S'.  	     An exception to this rule applies to the following code:  	       namespace N { struct S; }  	     Here, the elaborated-type-specifier names a new type 	     unconditionally; even if there is already an `S' in the 	     containing scope this declaration names a new type. 	     This exception only applies if the elaborated-type-specifier 	     forms the complete declaration:  	       [class.name]  	       A declaration consisting solely of `class-key identifier ;' is 	       either a redeclaration of the name in the current scope or a 	       forward declaration of the identifier as a class name.  It 	       introduces the name into the current scope.  	     We are in this situation precisely when the next token is a `;'.  	     An exception to the exception is that a `friend' declaration does 	     *not* name a new type; i.e., given:  	       struct S { friend struct T; };  	     `T' is not a new type in the scope of `S'.  	     Also, `new struct S' or `sizeof (struct S)' never results in the 	     definition of a new type; a new type can only be declared in a 	     declaration context.  */
name|tag_scope
name|ts
decl_stmt|;
name|bool
name|template_p
decl_stmt|;
if|if
condition|(
name|is_friend
condition|)
comment|/* Friends have special name lookup rules.  */
name|ts
operator|=
name|ts_within_enclosing_non_class
expr_stmt|;
elseif|else
if|if
condition|(
name|is_declaration
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
comment|/* This is a `class-key identifier ;' */
name|ts
operator|=
name|ts_current
expr_stmt|;
else|else
name|ts
operator|=
name|ts_global
expr_stmt|;
name|template_p
operator|=
operator|(
name|parser
operator|->
name|num_template_parameter_lists
operator|&&
operator|(
name|cp_parser_next_token_starts_class_definition_p
argument_list|(
name|parser
argument_list|)
operator|||
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* An unqualified name was used to reference this type, so 	     there were no qualifying templates.  */
if|if
condition|(
operator|!
name|cp_parser_check_template_parameters
argument_list|(
name|parser
argument_list|,
comment|/*num_templates=*/
literal|0
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|xref_tag
argument_list|(
name|tag_type
argument_list|,
name|identifier
argument_list|,
name|ts
argument_list|,
name|template_p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Allow attributes on forward declarations of classes.  */
if|if
condition|(
name|attributes
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"attributes ignored on uninstantiated type"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tag_type
operator|!=
name|enum_type
operator|&&
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|processing_explicit_instantiation
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"attributes ignored on template instantiation"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_declaration
operator|&&
name|cp_parser_declares_only_class_p
argument_list|(
name|parser
argument_list|)
condition|)
name|cplus_decl_attributes
argument_list|(
operator|&
name|type
argument_list|,
name|attributes
argument_list|,
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"attributes ignored on elaborated-type-specifier that is not a forward declaration"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tag_type
operator|!=
name|enum_type
condition|)
name|cp_parser_check_class_key
argument_list|(
name|tag_type
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* A "<" cannot follow an elaborated type specifier.  If that      happens, the user was probably trying to form a template-id.  */
name|cp_parser_check_for_invalid_template_id
argument_list|(
name|parser
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Parse an enum-specifier.     enum-specifier:      enum identifier [opt] { enumerator-list [opt] }     GNU Extensions:      enum attributes[opt] identifier [opt] { enumerator-list [opt] }        attributes[opt]     Returns an ENUM_TYPE representing the enumeration, or NULL_TREE    if the token stream isn't an enum-specifier after all.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_enum_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|identifier
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
comment|/* Parse tentatively so that we can back up if we don't find a      enum-specifier.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Caller guarantees that the current token is 'enum', an identifier      possibly follows, and the token after that is an opening brace.      If we don't have an identifier, fabricate an anonymous name for      the enumeration being defined.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|identifier
operator|=
name|make_anon_name
argument_list|()
expr_stmt|;
comment|/* Look for the `{' but don't consume it yet.  */
if|if
condition|(
operator|!
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Issue an error message if type-definitions are forbidden here.  */
if|if
condition|(
operator|!
name|cp_parser_check_type_definition
argument_list|(
name|parser
argument_list|)
condition|)
name|type
operator|=
name|error_mark_node
expr_stmt|;
else|else
comment|/* Create the new type.  We do this before consuming the opening        brace so the enum will be recorded as being on the line of its        tag (or the 'enum' keyword, if there is no tag).  */
name|type
operator|=
name|start_enum
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
comment|/* Consume the opening brace.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If the next token is not '}', then there are some enumerators.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
name|cp_parser_enumerator_list
argument_list|(
name|parser
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Consume the final '}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
comment|/* Look for trailing attributes to apply to this enumeration, and      apply them if appropriate.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|tree
name|trailing_attr
init|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|cplus_decl_attributes
argument_list|(
operator|&
name|type
argument_list|,
name|trailing_attr
argument_list|,
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
argument_list|)
expr_stmt|;
block|}
comment|/* Finish up the enumeration.  */
name|finish_enum
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Parse an enumerator-list.  The enumerators all have the indicated    TYPE.     enumerator-list:      enumerator-definition      enumerator-list , enumerator-definition  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_enumerator_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
comment|/* Parse an enumerator-definition.  */
name|cp_parser_enumerator_definition
argument_list|(
name|parser
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If the next token is not a ',', we've reached the end of 	 the list.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
comment|/* Otherwise, consume the `,' and keep going.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token is a `}', there is a trailing comma.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"comma at end of enumerator list"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Parse an enumerator-definition.  The enumerator has the indicated    TYPE.     enumerator-definition:      enumerator      enumerator = constant-expression     enumerator:      identifier  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_enumerator_definition
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|identifier
decl_stmt|;
name|tree
name|value
decl_stmt|;
comment|/* Look for the identifier.  */
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* If the next token is an '=', then there is an explicit value.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EQ
argument_list|)
condition|)
block|{
comment|/* Consume the `=' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the value.  */
name|value
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant_p=*/
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|value
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Create the enumerator.  */
name|build_enumerator
argument_list|(
name|identifier
argument_list|,
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a namespace-name.     namespace-name:      original-namespace-name      namespace-alias     Returns the NAMESPACE_DECL for the namespace.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_namespace_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|identifier
decl_stmt|;
name|tree
name|namespace_decl
decl_stmt|;
comment|/* Get the name of the namespace.  */
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Look up the identifier in the currently active scope.  Look only      for namespaces, due to:         [basic.lookup.udir]         When looking up a namespace-name in a using-directive or alias        definition, only namespace names are considered.       And:         [basic.lookup.qual]         During the lookup of a name preceding the :: scope resolution        operator, object, function, and enumerator names are ignored.       (Note that cp_parser_class_or_namespace_name only calls this      function if the token after the name is the scope resolution      operator.)  */
name|namespace_decl
operator|=
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|,
name|none_type
argument_list|,
comment|/*is_template=*/
name|false
argument_list|,
comment|/*is_namespace=*/
name|true
argument_list|,
comment|/*check_dependency=*/
name|true
argument_list|,
comment|/*ambiguous_decls=*/
name|NULL
argument_list|)
expr_stmt|;
comment|/* If it's not a namespace, issue an error.  */
if|if
condition|(
name|namespace_decl
operator|==
name|error_mark_node
operator|||
name|TREE_CODE
argument_list|(
name|namespace_decl
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
block|{
if|if
condition|(
operator|!
name|cp_parser_uncommitted_to_tentative_parse_p
argument_list|(
name|parser
argument_list|)
condition|)
name|error
argument_list|(
literal|"%qD is not a namespace-name"
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected namespace-name"
argument_list|)
expr_stmt|;
name|namespace_decl
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|namespace_decl
return|;
block|}
end_function

begin_comment
comment|/* Parse a namespace-definition.     namespace-definition:      named-namespace-definition      unnamed-namespace-definition     named-namespace-definition:      original-namespace-definition      extension-namespace-definition     original-namespace-definition:      namespace identifier { namespace-body }     extension-namespace-definition:      namespace original-namespace-name { namespace-body }     unnamed-namespace-definition:      namespace { namespace-body } */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_namespace_definition
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|identifier
decl_stmt|,
name|attribs
decl_stmt|;
comment|/* Look for the `namespace' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_NAMESPACE
argument_list|,
literal|"`namespace'"
argument_list|)
expr_stmt|;
comment|/* Get the name of the namespace.  We do not attempt to distinguish      between an original-namespace-definition and an      extension-namespace-definition at this point.  The semantic      analysis routines are responsible for that.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|identifier
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Parse any specified attributes.  */
name|attribs
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the `{' to start the namespace.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|,
literal|"`{'"
argument_list|)
expr_stmt|;
comment|/* Start the namespace.  */
name|push_namespace_with_attribs
argument_list|(
name|identifier
argument_list|,
name|attribs
argument_list|)
expr_stmt|;
comment|/* Parse the body of the namespace.  */
name|cp_parser_namespace_body
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Finish the namespace.  */
name|pop_namespace
argument_list|()
expr_stmt|;
comment|/* Look for the final `}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a namespace-body.     namespace-body:      declaration-seq [opt]  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_namespace_body
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_parser_declaration_seq_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a namespace-alias-definition.     namespace-alias-definition:      namespace identifier = qualified-namespace-specifier ;  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_namespace_alias_definition
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|identifier
decl_stmt|;
name|tree
name|namespace_specifier
decl_stmt|;
comment|/* Look for the `namespace' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_NAMESPACE
argument_list|,
literal|"`namespace'"
argument_list|)
expr_stmt|;
comment|/* Look for the identifier.  */
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Look for the `=' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_EQ
argument_list|,
literal|"`='"
argument_list|)
expr_stmt|;
comment|/* Look for the qualified-namespace-specifier.  */
name|namespace_specifier
operator|=
name|cp_parser_qualified_namespace_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the `;' token.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
comment|/* Register the alias in the symbol table.  */
name|do_namespace_alias
argument_list|(
name|identifier
argument_list|,
name|namespace_specifier
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a qualified-namespace-specifier.     qualified-namespace-specifier:      :: [opt] nested-name-specifier [opt] namespace-name     Returns a NAMESPACE_DECL corresponding to the specified    namespace.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_qualified_namespace_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Look for the optional `::'.  */
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the optional nested-name-specifier.  */
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|cp_parser_namespace_name
argument_list|(
name|parser
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a using-declaration, or, if ACCESS_DECLARATION_P is true, an    access declaration.     using-declaration:      using typename [opt] :: [opt] nested-name-specifier unqualified-id ;      using :: unqualified-id ;       access-declaration:      qualified-id ;       */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_using_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|access_declaration_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|bool
name|typename_p
init|=
name|false
decl_stmt|;
name|bool
name|global_scope_p
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|tree
name|qscope
decl_stmt|;
if|if
condition|(
name|access_declaration_p
condition|)
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Look for the `using' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_USING
argument_list|,
literal|"`using'"
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* See if it's `typename'.  */
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_TYPENAME
condition|)
block|{
comment|/* Remember that we've seen it.  */
name|typename_p
operator|=
name|true
expr_stmt|;
comment|/* Consume the `typename' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Look for the optional global scope qualification.  */
name|global_scope_p
operator|=
operator|(
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* If we saw `typename', or didn't see `::', then there must be a      nested-name-specifier present.  */
if|if
condition|(
name|typename_p
operator|||
operator|!
name|global_scope_p
condition|)
name|qscope
operator|=
name|cp_parser_nested_name_specifier
argument_list|(
name|parser
argument_list|,
name|typename_p
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Otherwise, we could be in either of the two productions.  In that      case, treat the nested-name-specifier as optional.  */
else|else
name|qscope
operator|=
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qscope
condition|)
name|qscope
operator|=
name|global_namespace
expr_stmt|;
if|if
condition|(
name|access_declaration_p
operator|&&
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
comment|/* Something has already gone wrong; there's no need to parse        further.  Since an error has occurred, the return value of        cp_parser_parse_definitely will be false, as required.  */
return|return
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
return|;
comment|/* Parse the unqualified-id.  */
name|identifier
operator|=
name|cp_parser_unqualified_id
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*declarator_p=*/
name|true
argument_list|,
comment|/*optional_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_declaration_p
condition|)
block|{
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* The function we call to handle a using-declaration is different      depending on what scope we are in.  */
if|if
condition|(
name|qscope
operator|==
name|error_mark_node
operator|||
name|identifier
operator|==
name|error_mark_node
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|identifier
argument_list|)
operator|!=
name|IDENTIFIER_NODE
operator|&&
name|TREE_CODE
argument_list|(
name|identifier
argument_list|)
operator|!=
name|BIT_NOT_EXPR
condition|)
comment|/* [namespace.udecl]         A using declaration shall not name a template-id.  */
name|error
argument_list|(
literal|"a template-id may not appear in a using-declaration"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|at_class_scope_p
argument_list|()
condition|)
block|{
comment|/* Create the USING_DECL.  */
name|decl
operator|=
name|do_class_using_decl
argument_list|(
name|parser
operator|->
name|scope
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
comment|/* Add it to the list of members in this class.  */
name|finish_member_declaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|cp_parser_lookup_name_simple
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
name|cp_parser_name_lookup_error
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|,
name|decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|at_namespace_scope_p
argument_list|()
condition|)
name|do_local_using_decl
argument_list|(
name|decl
argument_list|,
name|qscope
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
else|else
name|do_toplevel_using_decl
argument_list|(
name|decl
argument_list|,
name|qscope
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Look for the final `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Parse a using-directive.     using-directive:      using namespace :: [opt] nested-name-specifier [opt]        namespace-name ;  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_using_directive
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|namespace_decl
decl_stmt|;
name|tree
name|attribs
decl_stmt|;
comment|/* Look for the `using' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_USING
argument_list|,
literal|"`using'"
argument_list|)
expr_stmt|;
comment|/* And the `namespace' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_NAMESPACE
argument_list|,
literal|"`namespace'"
argument_list|)
expr_stmt|;
comment|/* Look for the optional `::' operator.  */
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* And the optional nested-name-specifier.  */
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Get the namespace being used.  */
name|namespace_decl
operator|=
name|cp_parser_namespace_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* And any specified attributes.  */
name|attribs
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Update the symbol table.  */
name|parse_using_directive
argument_list|(
name|namespace_decl
argument_list|,
name|attribs
argument_list|)
expr_stmt|;
comment|/* Look for the final `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an asm-definition.     asm-definition:      asm ( string-literal ) ;     GNU Extension:     asm-definition:      asm volatile [opt] ( string-literal ) ;      asm volatile [opt] ( string-literal : asm-operand-list [opt] ) ;      asm volatile [opt] ( string-literal : asm-operand-list [opt] 			  : asm-operand-list [opt] ) ;      asm volatile [opt] ( string-literal : asm-operand-list [opt] 			  : asm-operand-list [opt] 			  : asm-operand-list [opt] ) ;  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_asm_definition
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|string
decl_stmt|;
name|tree
name|outputs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|inputs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|clobbers
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|asm_stmt
decl_stmt|;
name|bool
name|volatile_p
init|=
name|false
decl_stmt|;
name|bool
name|extended_p
init|=
name|false
decl_stmt|;
comment|/* Look for the `asm' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ASM
argument_list|,
literal|"`asm'"
argument_list|)
expr_stmt|;
comment|/* See if the next token is `volatile'.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_VOLATILE
argument_list|)
condition|)
block|{
comment|/* Remember that we saw the `volatile' keyword.  */
name|volatile_p
operator|=
name|true
expr_stmt|;
comment|/* Consume the token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* Look for the opening `('.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
condition|)
return|return;
comment|/* Look for the string.  */
name|string
operator|=
name|cp_parser_string_literal
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|error_mark_node
condition|)
block|{
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we're allowing GNU extensions, check for the extended assembly      syntax.  Unfortunately, the `:' tokens need not be separated by      a space in C, and so, for compatibility, we tolerate that here      too.  Doing that means that we have to treat the `::' operator as      two `:' tokens.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|parser
operator|->
name|in_function_body
operator|&&
operator|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
operator|||
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
operator|)
condition|)
block|{
name|bool
name|inputs_p
init|=
name|false
decl_stmt|;
name|bool
name|clobbers_p
init|=
name|false
decl_stmt|;
comment|/* The extended syntax was used.  */
name|extended_p
operator|=
name|true
expr_stmt|;
comment|/* Look for outputs.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
block|{
comment|/* Consume the `:'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the output-operands.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|outputs
operator|=
name|cp_parser_asm_operand_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* If the next token is `::', there are no outputs, and the 	 next token is the beginning of the inputs.  */
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
condition|)
comment|/* The inputs are coming next.  */
name|inputs_p
operator|=
name|true
expr_stmt|;
comment|/* Look for inputs.  */
if|if
condition|(
name|inputs_p
operator|||
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
block|{
comment|/* Consume the `:' or `::'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the output-operands.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|inputs
operator|=
name|cp_parser_asm_operand_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
condition|)
comment|/* The clobbers are coming next.  */
name|clobbers_p
operator|=
name|true
expr_stmt|;
comment|/* Look for clobbers.  */
if|if
condition|(
name|clobbers_p
operator|||
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
block|{
comment|/* Consume the `:' or `::'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the clobbers.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|clobbers
operator|=
name|cp_parser_asm_clobber_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Look for the closing `)'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
comment|/* Create the ASM_EXPR.  */
if|if
condition|(
name|parser
operator|->
name|in_function_body
condition|)
block|{
name|asm_stmt
operator|=
name|finish_asm_stmt
argument_list|(
name|volatile_p
argument_list|,
name|string
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|,
name|clobbers
argument_list|)
expr_stmt|;
comment|/* If the extended syntax was not used, mark the ASM_EXPR.  */
if|if
condition|(
operator|!
name|extended_p
condition|)
block|{
name|tree
name|temp
init|=
name|asm_stmt
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CLEANUP_POINT_EXPR
condition|)
name|temp
operator|=
name|TREE_OPERAND
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_INPUT_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|cgraph_add_asm_node
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Declarators [gram.dcl.decl] */
end_comment

begin_comment
comment|/* Parse an init-declarator.     init-declarator:      declarator initializer [opt]     GNU Extension:     init-declarator:      declarator asm-specification [opt] attributes [opt] initializer [opt]     function-definition:      decl-specifier-seq [opt] declarator ctor-initializer [opt]        function-body      decl-specifier-seq [opt] declarator function-try-block     GNU Extension:     function-definition:      __extension__ function-definition     The DECL_SPECIFIERS apply to this declarator.  Returns a    representation of the entity declared.  If MEMBER_P is TRUE, then    this declarator appears in a class scope.  The new DECL created by    this declarator is returned.     The CHECKS are access checks that should be performed once we know    what entity is being declared (and, therefore, what classes have    befriended it).     If FUNCTION_DEFINITION_ALLOWED_P then we handle the declarator and    for a function-definition here as well.  If the declarator is a    declarator for a function-definition, *FUNCTION_DEFINITION_P will    be TRUE upon return.  By that point, the function-definition will    have been completely parsed.     FUNCTION_DEFINITION_P may be NULL if FUNCTION_DEFINITION_ALLOWED_P    is FALSE.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|cp_parser_init_declarator
argument_list|(
name|cp_parser
operator|*
name|parser
argument_list|,
name|cp_decl_specifier_seq
operator|*
name|decl_specifiers
argument_list|,
name|VEC
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|)
operator|*
name|checks
argument_list|,
name|bool
name|function_definition_allowed_p
argument_list|,
name|bool
name|member_p
argument_list|,
name|int
name|declares_class_or_enum
argument_list|,
name|bool
operator|*
name|function_definition_p
argument_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
name|tree
name|prefix_attributes
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|tree
name|asm_specification
decl_stmt|;
name|tree
name|initializer
decl_stmt|;
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|bool
name|is_initialized
decl_stmt|;
comment|/* Only valid if IS_INITIALIZED is true.  In that case, CPP_EQ if      initialized with "= ..", CPP_OPEN_PAREN if initialized with      "(...)".  */
name|enum
name|cpp_ttype
name|initialization_kind
decl_stmt|;
name|bool
name|is_parenthesized_init
init|=
name|false
decl_stmt|;
name|bool
name|is_non_constant_init
decl_stmt|;
name|int
name|ctor_dtor_or_conv_p
decl_stmt|;
name|bool
name|friend_p
decl_stmt|;
name|tree
name|pushed_scope
init|=
name|NULL
decl_stmt|;
comment|/* Gather the attributes that were provided with the      decl-specifiers.  */
name|prefix_attributes
operator|=
name|decl_specifiers
operator|->
name|attributes
expr_stmt|;
comment|/* Assume that this is not the declarator for a function      definition.  */
if|if
condition|(
name|function_definition_p
condition|)
operator|*
name|function_definition_p
operator|=
name|false
expr_stmt|;
comment|/* Defer access checks while parsing the declarator; we cannot know      what names are accessible until we know what is being      declared.  */
name|resume_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Parse the declarator.  */
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_NAMED
argument_list|,
operator|&
name|ctor_dtor_or_conv_p
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|,
comment|/*member_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Gather up the deferred checks.  */
name|stop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* If the DECLARATOR was erroneous, there's no need to go      further.  */
if|if
condition|(
name|declarator
operator|==
name|cp_error_declarator
condition|)
return|return
name|error_mark_node
return|;
comment|/* Check that the number of template-parameter-lists is OK.  */
if|if
condition|(
operator|!
name|cp_parser_check_declarator_template_parameters
argument_list|(
name|parser
argument_list|,
name|declarator
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|declares_class_or_enum
operator|&
literal|2
condition|)
name|cp_parser_check_for_definition_in_return_type
argument_list|(
name|declarator
argument_list|,
name|decl_specifiers
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* Figure out what scope the entity declared by the DECLARATOR is      located in.  `grokdeclarator' sometimes changes the scope, so      we compute it now.  */
name|scope
operator|=
name|get_scope_of_declarator
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
comment|/* If we're allowing GNU extensions, look for an asm-specification      and attributes.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* Look for an asm-specification.  */
name|asm_specification
operator|=
name|cp_parser_asm_specification_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* And attributes.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asm_specification
operator|=
name|NULL_TREE
expr_stmt|;
name|attributes
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Check to see if the token indicates the start of a      function-definition.  */
if|if
condition|(
name|cp_parser_token_starts_function_definition_p
argument_list|(
name|token
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|function_definition_allowed_p
condition|)
block|{
comment|/* If a function-definition should not appear here, issue an 	     error message.  */
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"a function-definition is not allowed here"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
comment|/* Neither attributes nor an asm-specification are allowed 	     on a function-definition.  */
if|if
condition|(
name|asm_specification
condition|)
name|error
argument_list|(
literal|"an asm-specification is not allowed on a function-definition"
argument_list|)
expr_stmt|;
if|if
condition|(
name|attributes
condition|)
name|error
argument_list|(
literal|"attributes are not allowed on a function-definition"
argument_list|)
expr_stmt|;
comment|/* This is a function-definition.  */
operator|*
name|function_definition_p
operator|=
name|true
expr_stmt|;
comment|/* Parse the function definition.  */
if|if
condition|(
name|member_p
condition|)
name|decl
operator|=
name|cp_parser_save_member_function_body
argument_list|(
name|parser
argument_list|,
name|decl_specifiers
argument_list|,
name|declarator
argument_list|,
name|prefix_attributes
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
operator|(
name|cp_parser_function_definition_from_specifiers_and_declarator
argument_list|(
name|parser
argument_list|,
name|decl_specifiers
argument_list|,
name|prefix_attributes
argument_list|,
name|declarator
argument_list|)
operator|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
comment|/* [dcl.dcl]       Only in function declarations for constructors, destructors, and      type conversions can the decl-specifier-seq be omitted.       We explicitly postpone this check past the point where we handle      function-definitions because we tolerate function-definitions      that are missing their return types in some modes.  */
if|if
condition|(
operator|!
name|decl_specifiers
operator|->
name|any_specifiers_p
operator|&&
name|ctor_dtor_or_conv_p
operator|<=
literal|0
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected constructor, destructor, or type conversion"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* An `=' or an `(' indicates an initializer.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EQ
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
block|{
name|is_initialized
operator|=
name|true
expr_stmt|;
name|initialization_kind
operator|=
name|token
operator|->
name|type
expr_stmt|;
block|}
else|else
block|{
comment|/* If the init-declarator isn't initialized and isn't followed by a 	 `,' or `;', it's not a valid init-declarator.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_COMMA
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_SEMICOLON
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected initializer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|is_initialized
operator|=
name|false
expr_stmt|;
name|initialization_kind
operator|=
name|CPP_EOF
expr_stmt|;
block|}
comment|/* Because start_decl has side-effects, we should only call it if we      know we're going ahead.  By this point, we know that we cannot      possibly be looking at any other construct.  */
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the decl specifiers were bad, issue an error now that we're      sure this was intended to be a declarator.  Then continue      declaring the variable(s), as int, to try to cut down on further      errors.  */
if|if
condition|(
name|decl_specifiers
operator|->
name|any_specifiers_p
operator|&&
name|decl_specifiers
operator|->
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"invalid type in declaration"
argument_list|)
expr_stmt|;
name|decl_specifiers
operator|->
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Check to see whether or not this declaration is a friend.  */
name|friend_p
operator|=
name|cp_parser_friend_p
argument_list|(
name|decl_specifiers
argument_list|)
expr_stmt|;
comment|/* Enter the newly declared entry in the symbol table.  If we're      processing a declaration in a class-specifier, we wait until      after processing the initializer.  */
if|if
condition|(
operator|!
name|member_p
condition|)
block|{
if|if
condition|(
name|parser
operator|->
name|in_unbraced_linkage_specification_p
condition|)
name|decl_specifiers
operator|->
name|storage_class
operator|=
name|sc_extern
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|decl_specifiers
argument_list|,
name|is_initialized
argument_list|,
name|attributes
argument_list|,
name|prefix_attributes
argument_list|,
operator|&
name|pushed_scope
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scope
condition|)
comment|/* Enter the SCOPE.  That way unqualified names appearing in the        initializer will be looked up in SCOPE.  */
name|pushed_scope
operator|=
name|push_scope
argument_list|(
name|scope
argument_list|)
expr_stmt|;
comment|/* Perform deferred access control checks, now that we know in which      SCOPE the declared entity resides.  */
if|if
condition|(
operator|!
name|member_p
operator|&&
name|decl
condition|)
block|{
name|tree
name|saved_current_function_decl
init|=
name|NULL_TREE
decl_stmt|;
comment|/* If the entity being declared is a function, pretend that we 	 are in its scope.  If it is a `friend', it may have access to 	 things that would not otherwise be accessible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|saved_current_function_decl
operator|=
name|current_function_decl
expr_stmt|;
name|current_function_decl
operator|=
name|decl
expr_stmt|;
block|}
comment|/* Perform access checks for template parameters.  */
name|cp_parser_perform_template_parameter_access_checks
argument_list|(
name|checks
argument_list|)
expr_stmt|;
comment|/* Perform the access control checks for the declarator and the 	 the decl-specifiers.  */
name|perform_deferred_access_checks
argument_list|()
expr_stmt|;
comment|/* Restore the saved value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|current_function_decl
operator|=
name|saved_current_function_decl
expr_stmt|;
block|}
comment|/* Parse the initializer.  */
name|initializer
operator|=
name|NULL_TREE
expr_stmt|;
name|is_parenthesized_init
operator|=
name|false
expr_stmt|;
name|is_non_constant_init
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|is_initialized
condition|)
block|{
if|if
condition|(
name|function_declarator_p
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
if|if
condition|(
name|initialization_kind
operator|==
name|CPP_EQ
condition|)
name|initializer
operator|=
name|cp_parser_pure_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If the declaration was erroneous, we don't really 		  know what the user intended, so just silently 		  consume the initializer.  */
if|if
condition|(
name|decl
operator|!=
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"initializer provided for function"
argument_list|)
expr_stmt|;
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
comment|/*recovering=*/
name|true
argument_list|,
comment|/*or_comma=*/
name|false
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|initializer
operator|=
name|cp_parser_initializer
argument_list|(
name|parser
argument_list|,
operator|&
name|is_parenthesized_init
argument_list|,
operator|&
name|is_non_constant_init
argument_list|)
expr_stmt|;
block|}
comment|/* The old parser allows attributes to appear after a parenthesized      initializer.  Mark Mitchell proposed removing this functionality      on the GCC mailing lists on 2002-08-13.  This parser accepts the      attributes -- but ignores them.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|is_parenthesized_init
condition|)
if|if
condition|(
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"attributes after parenthesized initializer ignored"
argument_list|)
expr_stmt|;
comment|/* For an in-class declaration, use `grokfield' to create the      declaration.  */
if|if
condition|(
name|member_p
condition|)
block|{
if|if
condition|(
name|pushed_scope
condition|)
block|{
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
name|pushed_scope
operator|=
name|false
expr_stmt|;
block|}
name|decl
operator|=
name|grokfield
argument_list|(
name|declarator
argument_list|,
name|decl_specifiers
argument_list|,
name|initializer
argument_list|,
operator|!
name|is_non_constant_init
argument_list|,
comment|/*asmspec=*/
name|NULL_TREE
argument_list|,
name|prefix_attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|cp_parser_save_default_args
argument_list|(
name|parser
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Finish processing the declaration.  But, skip friend      declarations.  */
if|if
condition|(
operator|!
name|friend_p
operator|&&
name|decl
operator|&&
name|decl
operator|!=
name|error_mark_node
condition|)
block|{
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|initializer
argument_list|,
operator|!
name|is_non_constant_init
argument_list|,
name|asm_specification
argument_list|,
comment|/* If the initializer is in parentheses, then this is 			 a direct-initialization, which means that an 			 `explicit' constructor is OK.  Otherwise, an 			 `explicit' constructor cannot be used.  */
operator|(
operator|(
name|is_parenthesized_init
operator|||
operator|!
name|is_initialized
operator|)
condition|?
literal|0
else|:
name|LOOKUP_ONLYCONVERTING
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|friend_p
operator|&&
name|pushed_scope
condition|)
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Parse a declarator.     declarator:      direct-declarator      ptr-operator declarator     abstract-declarator:      ptr-operator abstract-declarator [opt]      direct-abstract-declarator     GNU Extensions:     declarator:      attributes [opt] direct-declarator      attributes [opt] ptr-operator declarator     abstract-declarator:      attributes [opt] ptr-operator abstract-declarator [opt]      attributes [opt] direct-abstract-declarator     If CTOR_DTOR_OR_CONV_P is not NULL, *CTOR_DTOR_OR_CONV_P is used to    detect constructor, destructor or conversion operators. It is set    to -1 if the declarator is a name, and +1 if it is a    function. Otherwise it is set to zero. Usually you just want to    test for>0, but internally the negative value is used.     (The reason for CTOR_DTOR_OR_CONV_P is that a declaration must have    a decl-specifier-seq unless it declares a constructor, destructor,    or conversion.  It might seem that we could check this condition in    semantic analysis, rather than parsing, but that makes it difficult    to handle something like `f()'.  We want to notice that there are    no decl-specifiers, and therefore realize that this is an    expression, not a declaration.)     If PARENTHESIZED_P is non-NULL, *PARENTHESIZED_P is set to true iff    the declarator is a direct-declarator of the form "(...)".     MEMBER_P is true iff this declarator is a member-declarator.  */
end_comment

begin_function
specifier|static
name|cp_declarator
modifier|*
name|cp_parser_declarator
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_parser_declarator_kind
name|dcl_kind
parameter_list|,
name|int
modifier|*
name|ctor_dtor_or_conv_p
parameter_list|,
name|bool
modifier|*
name|parenthesized_p
parameter_list|,
name|bool
name|member_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|cp_cv_quals
name|cv_quals
decl_stmt|;
name|tree
name|class_type
decl_stmt|;
name|tree
name|attributes
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Assume this is not a constructor, destructor, or type-conversion      operator.  */
if|if
condition|(
name|ctor_dtor_or_conv_p
condition|)
operator|*
name|ctor_dtor_or_conv_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
condition|)
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Check for the ptr-operator production.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the ptr-operator.  */
name|code
operator|=
name|cp_parser_ptr_operator
argument_list|(
name|parser
argument_list|,
operator|&
name|class_type
argument_list|,
operator|&
name|cv_quals
argument_list|)
expr_stmt|;
comment|/* If that worked, then we have a ptr-operator.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* If a ptr-operator was found, then this declarator was not 	 parenthesized.  */
if|if
condition|(
name|parenthesized_p
condition|)
operator|*
name|parenthesized_p
operator|=
name|true
expr_stmt|;
comment|/* The dependent declarator is optional if we are parsing an 	 abstract-declarator.  */
if|if
condition|(
name|dcl_kind
operator|!=
name|CP_PARSER_DECLARATOR_NAMED
condition|)
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the dependent declarator.  */
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|dcl_kind
argument_list|,
comment|/*ctor_dtor_or_conv_p=*/
name|NULL
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|,
comment|/*member_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If we are parsing an abstract-declarator, we must handle the 	 case where the dependent declarator is absent.  */
if|if
condition|(
name|dcl_kind
operator|!=
name|CP_PARSER_DECLARATOR_NAMED
operator|&&
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|declarator
operator|=
name|NULL
expr_stmt|;
comment|/* Build the representation of the ptr-operator.  */
if|if
condition|(
name|class_type
condition|)
name|declarator
operator|=
name|make_ptrmem_declarator
argument_list|(
name|cv_quals
argument_list|,
name|class_type
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|INDIRECT_REF
condition|)
name|declarator
operator|=
name|make_pointer_declarator
argument_list|(
name|cv_quals
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
else|else
name|declarator
operator|=
name|make_reference_declarator
argument_list|(
name|cv_quals
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
block|}
comment|/* Everything else is a direct-declarator.  */
else|else
block|{
if|if
condition|(
name|parenthesized_p
condition|)
operator|*
name|parenthesized_p
operator|=
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|cp_parser_direct_declarator
argument_list|(
name|parser
argument_list|,
name|dcl_kind
argument_list|,
name|ctor_dtor_or_conv_p
argument_list|,
name|member_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attributes
operator|&&
name|declarator
operator|&&
name|declarator
operator|!=
name|cp_error_declarator
condition|)
name|declarator
operator|->
name|attributes
operator|=
name|attributes
expr_stmt|;
return|return
name|declarator
return|;
block|}
end_function

begin_comment
comment|/* Parse a direct-declarator or direct-abstract-declarator.     direct-declarator:      declarator-id      direct-declarator ( parameter-declaration-clause )        cv-qualifier-seq [opt]        exception-specification [opt]      direct-declarator [ constant-expression [opt] ]      ( declarator )     direct-abstract-declarator:      direct-abstract-declarator [opt]        ( parameter-declaration-clause )        cv-qualifier-seq [opt]        exception-specification [opt]      direct-abstract-declarator [opt] [ constant-expression [opt] ]      ( abstract-declarator )     Returns a representation of the declarator.  DCL_KIND is    CP_PARSER_DECLARATOR_ABSTRACT, if we are parsing a    direct-abstract-declarator.  It is CP_PARSER_DECLARATOR_NAMED, if    we are parsing a direct-declarator.  It is    CP_PARSER_DECLARATOR_EITHER, if we can accept either - in the case    of ambiguity we prefer an abstract declarator, as per    [dcl.ambig.res].  CTOR_DTOR_OR_CONV_P and MEMBER_P are as for    cp_parser_declarator.  */
end_comment

begin_function
specifier|static
name|cp_declarator
modifier|*
name|cp_parser_direct_declarator
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_parser_declarator_kind
name|dcl_kind
parameter_list|,
name|int
modifier|*
name|ctor_dtor_or_conv_p
parameter_list|,
name|bool
name|member_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|cp_declarator
modifier|*
name|declarator
init|=
name|NULL
decl_stmt|;
name|tree
name|scope
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|saved_default_arg_ok_p
init|=
name|parser
operator|->
name|default_arg_ok_p
decl_stmt|;
name|bool
name|saved_in_declarator_p
init|=
name|parser
operator|->
name|in_declarator_p
decl_stmt|;
name|bool
name|first
init|=
name|true
decl_stmt|;
name|tree
name|pushed_scope
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
block|{
comment|/* This is either a parameter-declaration-clause, or a 	     parenthesized declarator. When we know we are parsing a 	     named declarator, it must be a parenthesized declarator 	     if FIRST is true. For instance, `(int)' is a 	     parameter-declaration-clause, with an omitted 	     direct-abstract-declarator. But `((*))', is a 	     parenthesized abstract declarator. Finally, when T is a 	     template parameter `(T)' is a 	     parameter-declaration-clause, and not a parenthesized 	     named declarator.  	     We first try and parse a parameter-declaration-clause, 	     and then try a nested declarator (if FIRST is true).  	     It is not an error for it not to be a 	     parameter-declaration-clause, even when FIRST is 	     false. Consider,  	       int i (int); 	       int i (3);  	     The first is the declaration of a function while the 	     second is a the definition of a variable, including its 	     initializer.  	     Having seen only the parenthesis, we cannot know which of 	     these two alternatives should be selected.  Even more 	     complex are examples like:  	       int i (int (a)); 	       int i (int (3));  	     The former is a function-declaration; the latter is a 	     variable initialization.  	     Thus again, we try a parameter-declaration-clause, and if 	     that fails, we back out and return.  */
if|if
condition|(
operator|!
name|first
operator|||
name|dcl_kind
operator|!=
name|CP_PARSER_DECLARATOR_NAMED
condition|)
block|{
name|cp_parameter_declarator
modifier|*
name|params
decl_stmt|;
name|unsigned
name|saved_num_template_parameter_lists
decl_stmt|;
comment|/* In a member-declarator, the only valid interpretation 		 of a parenthesis is the start of a 		 parameter-declaration-clause.  (It is invalid to 		 initialize a static data member with a parenthesized 		 initializer; only the "=" form of initialization is 		 permitted.)  */
if|if
condition|(
operator|!
name|member_p
condition|)
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
comment|/* If this is going to be an abstract declarator, we're 		     in a declarator and we can't have default args.  */
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|false
expr_stmt|;
name|parser
operator|->
name|in_declarator_p
operator|=
name|true
expr_stmt|;
block|}
comment|/* Inside the function parameter list, surrounding 		 template-parameter-lists do not apply.  */
name|saved_num_template_parameter_lists
operator|=
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
name|parser
operator|->
name|num_template_parameter_lists
operator|=
literal|0
expr_stmt|;
comment|/* Parse the parameter-declaration-clause.  */
name|params
operator|=
name|cp_parser_parameter_declaration_clause
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|num_template_parameter_lists
operator|=
name|saved_num_template_parameter_lists
expr_stmt|;
comment|/* If all went well, parse the cv-qualifier-seq and the 		 exception-specification.  */
if|if
condition|(
name|member_p
operator|||
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|cp_cv_quals
name|cv_quals
decl_stmt|;
name|tree
name|exception_specification
decl_stmt|;
if|if
condition|(
name|ctor_dtor_or_conv_p
condition|)
operator|*
name|ctor_dtor_or_conv_p
operator|=
operator|*
name|ctor_dtor_or_conv_p
operator|<
literal|0
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
comment|/* Consume the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Parse the cv-qualifier-seq.  */
name|cv_quals
operator|=
name|cp_parser_cv_qualifier_seq_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* And the exception-specification.  */
name|exception_specification
operator|=
name|cp_parser_exception_specification_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Create the function-declarator.  */
name|declarator
operator|=
name|make_call_declarator
argument_list|(
name|declarator
argument_list|,
name|params
argument_list|,
name|cv_quals
argument_list|,
name|exception_specification
argument_list|)
expr_stmt|;
comment|/* Any subsequent parameter lists are to do with 		     return type, so are not those of the declared 		     function.  */
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|false
expr_stmt|;
comment|/* Repeat the main loop.  */
continue|continue;
block|}
block|}
comment|/* If this is the first, we can try a parenthesized 	     declarator.  */
if|if
condition|(
name|first
condition|)
block|{
name|bool
name|saved_in_type_id_in_expr_p
decl_stmt|;
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|saved_default_arg_ok_p
expr_stmt|;
name|parser
operator|->
name|in_declarator_p
operator|=
name|saved_in_declarator_p
expr_stmt|;
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the nested declarator.  */
name|saved_in_type_id_in_expr_p
operator|=
name|parser
operator|->
name|in_type_id_in_expr_p
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|true
expr_stmt|;
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|dcl_kind
argument_list|,
name|ctor_dtor_or_conv_p
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|,
name|member_p
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|saved_in_type_id_in_expr_p
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
comment|/* Expect a `)'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
name|declarator
operator|=
name|cp_error_declarator
expr_stmt|;
if|if
condition|(
name|declarator
operator|==
name|cp_error_declarator
condition|)
break|break;
goto|goto
name|handle_declarator
goto|;
block|}
comment|/* Otherwise, we must be done.  */
else|else
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|first
operator|||
name|dcl_kind
operator|!=
name|CP_PARSER_DECLARATOR_NAMED
operator|)
operator|&&
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_SQUARE
condition|)
block|{
comment|/* Parse an array-declarator.  */
name|tree
name|bounds
decl_stmt|;
if|if
condition|(
name|ctor_dtor_or_conv_p
condition|)
operator|*
name|ctor_dtor_or_conv_p
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|false
expr_stmt|;
name|parser
operator|->
name|in_declarator_p
operator|=
name|true
expr_stmt|;
comment|/* Consume the `['.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token is `]', then there is no 	     constant-expression.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_CLOSE_SQUARE
condition|)
block|{
name|bool
name|non_constant_p
decl_stmt|;
name|bounds
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant=*/
name|true
argument_list|,
operator|&
name|non_constant_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|non_constant_p
condition|)
name|bounds
operator|=
name|fold_non_dependent_expr
argument_list|(
name|bounds
argument_list|)
expr_stmt|;
comment|/* Normally, the array bound must be an integral constant 		 expression.  However, as an extension, we allow VLAs 		 in function scopes.  */
elseif|else
if|if
condition|(
operator|!
name|parser
operator|->
name|in_function_body
condition|)
block|{
name|error
argument_list|(
literal|"array bound is not an integer constant"
argument_list|)
expr_stmt|;
name|bounds
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
else|else
name|bounds
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Look for the closing `]'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"`]'"
argument_list|)
condition|)
block|{
name|declarator
operator|=
name|cp_error_declarator
expr_stmt|;
break|break;
block|}
name|declarator
operator|=
name|make_array_declarator
argument_list|(
name|declarator
argument_list|,
name|bounds
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first
operator|&&
name|dcl_kind
operator|!=
name|CP_PARSER_DECLARATOR_ABSTRACT
condition|)
block|{
name|tree
name|qualifying_scope
decl_stmt|;
name|tree
name|unqualified_name
decl_stmt|;
name|special_function_kind
name|sfk
decl_stmt|;
name|bool
name|abstract_ok
decl_stmt|;
comment|/* Parse a declarator-id */
name|abstract_ok
operator|=
operator|(
name|dcl_kind
operator|==
name|CP_PARSER_DECLARATOR_EITHER
operator|)
expr_stmt|;
if|if
condition|(
name|abstract_ok
condition|)
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|unqualified_name
operator|=
name|cp_parser_declarator_id
argument_list|(
name|parser
argument_list|,
comment|/*optional_p=*/
name|abstract_ok
argument_list|)
expr_stmt|;
name|qualifying_scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
if|if
condition|(
name|abstract_ok
condition|)
block|{
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|unqualified_name
operator|=
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|unqualified_name
operator|&&
operator|(
name|qualifying_scope
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|unqualified_name
argument_list|)
operator|!=
name|IDENTIFIER_NODE
operator|)
operator|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected unqualified-id"
argument_list|)
expr_stmt|;
name|unqualified_name
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|unqualified_name
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|unqualified_name
operator|==
name|error_mark_node
condition|)
block|{
name|declarator
operator|=
name|cp_error_declarator
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|qualifying_scope
operator|&&
name|at_namespace_scope_p
argument_list|()
operator|&&
name|TREE_CODE
argument_list|(
name|qualifying_scope
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
comment|/* In the declaration of a member of a template class 		 outside of the class itself, the SCOPE will sometimes 		 be a TYPENAME_TYPE.  For example, given:  		 template<typename T> 		 int S<T>::R::i = 3;  		 the SCOPE will be a TYPENAME_TYPE for `S<T>::R'.  In 		 this context, we must resolve S<T>::R to an ordinary 		 type, rather than a typename type.  		 The reason we normally avoid resolving TYPENAME_TYPEs 		 is that a specialization of `S' might render 		 `S<T>::R' not a type.  However, if `S' is 		 specialized, then this `i' will not be used, so there 		 is no harm in resolving the types here.  */
name|tree
name|type
decl_stmt|;
comment|/* Resolve the TYPENAME_TYPE.  */
name|type
operator|=
name|resolve_typename_type
argument_list|(
name|qualifying_scope
argument_list|,
comment|/*only_current_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If that failed, the declarator is invalid.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"%<%T::%D%> is not a type"
argument_list|,
name|TYPE_CONTEXT
argument_list|(
name|qualifying_scope
argument_list|)
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|qualifying_scope
argument_list|)
argument_list|)
expr_stmt|;
name|qualifying_scope
operator|=
name|type
expr_stmt|;
block|}
name|sfk
operator|=
name|sfk_none
expr_stmt|;
if|if
condition|(
name|unqualified_name
condition|)
block|{
name|tree
name|class_type
decl_stmt|;
if|if
condition|(
name|qualifying_scope
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|qualifying_scope
argument_list|)
condition|)
name|class_type
operator|=
name|qualifying_scope
expr_stmt|;
else|else
name|class_type
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|unqualified_name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|name_type
init|=
name|TREE_TYPE
argument_list|(
name|unqualified_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|class_type
operator|&&
name|same_type_p
argument_list|(
name|name_type
argument_list|,
name|class_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|qualifying_scope
operator|&&
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|name_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of constructor as a template"
argument_list|)
expr_stmt|;
name|inform
argument_list|(
literal|"use %<%T::%D%> instead of %<%T::%D%> to "
literal|"name the constructor in a qualified name"
argument_list|,
name|class_type
argument_list|,
name|DECL_NAME
argument_list|(
name|TYPE_TI_TEMPLATE
argument_list|(
name|class_type
argument_list|)
argument_list|)
argument_list|,
name|class_type
argument_list|,
name|name_type
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|cp_error_declarator
expr_stmt|;
break|break;
block|}
else|else
name|unqualified_name
operator|=
name|constructor_name
argument_list|(
name|class_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We do not attempt to print the declarator 			 here because we do not have enough 			 information about its original syntactic 			 form.  */
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"invalid declarator"
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|cp_error_declarator
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|class_type
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|unqualified_name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|sfk
operator|=
name|sfk_destructor
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|unqualified_name
argument_list|)
condition|)
name|sfk
operator|=
name|sfk_conversion
expr_stmt|;
elseif|else
if|if
condition|(
comment|/* There's no way to declare a constructor 			      for an anonymous type, even if the type 			      got a name for linkage purposes.  */
operator|!
name|TYPE_WAS_ANONYMOUS
argument_list|(
name|class_type
argument_list|)
operator|&&
name|constructor_name_p
argument_list|(
name|unqualified_name
argument_list|,
name|class_type
argument_list|)
condition|)
block|{
name|unqualified_name
operator|=
name|constructor_name
argument_list|(
name|class_type
argument_list|)
expr_stmt|;
name|sfk
operator|=
name|sfk_constructor
expr_stmt|;
block|}
if|if
condition|(
name|ctor_dtor_or_conv_p
operator|&&
name|sfk
operator|!=
name|sfk_none
condition|)
operator|*
name|ctor_dtor_or_conv_p
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|declarator
operator|=
name|make_id_declarator
argument_list|(
name|qualifying_scope
argument_list|,
name|unqualified_name
argument_list|,
name|sfk
argument_list|)
expr_stmt|;
name|declarator
operator|->
name|id_loc
operator|=
name|token
operator|->
name|location
expr_stmt|;
name|handle_declarator
label|:
empty_stmt|;
name|scope
operator|=
name|get_scope_of_declarator
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
condition|)
comment|/* Any names that appear after the declarator-id for a 	       member are looked up in the containing scope.  */
name|pushed_scope
operator|=
name|push_scope
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_declarator_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|ctor_dtor_or_conv_p
operator|&&
operator|*
name|ctor_dtor_or_conv_p
operator|)
operator|||
operator|(
name|declarator
operator|&&
name|declarator
operator|->
name|kind
operator|==
name|cdk_id
operator|)
condition|)
comment|/* Default args are only allowed on function 	       declarations.  */
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|saved_default_arg_ok_p
expr_stmt|;
else|else
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|false
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
block|}
comment|/* We're done.  */
else|else
break|break;
block|}
comment|/* For an abstract declarator, we might wind up with nothing at this      point.  That's an error; the declarator is not optional.  */
if|if
condition|(
operator|!
name|declarator
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected declarator"
argument_list|)
expr_stmt|;
comment|/* If we entered a scope, we must exit it now.  */
if|if
condition|(
name|pushed_scope
condition|)
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|saved_default_arg_ok_p
expr_stmt|;
name|parser
operator|->
name|in_declarator_p
operator|=
name|saved_in_declarator_p
expr_stmt|;
return|return
name|declarator
return|;
block|}
end_function

begin_comment
comment|/* Parse a ptr-operator.     ptr-operator:      * cv-qualifier-seq [opt]&      :: [opt] nested-name-specifier * cv-qualifier-seq [opt]     GNU Extension:     ptr-operator:& cv-qualifier-seq [opt]     Returns INDIRECT_REF if a pointer, or pointer-to-member, was used.    Returns ADDR_EXPR if a reference was used.  In the case of a    pointer-to-member, *TYPE is filled in with the TYPE containing the    member.  *CV_QUALS is filled in with the cv-qualifier-seq, or    TYPE_UNQUALIFIED, if there are no cv-qualifiers.  Returns    ERROR_MARK if an error occurred.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|cp_parser_ptr_operator
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
modifier|*
name|type
parameter_list|,
name|cp_cv_quals
modifier|*
name|cv_quals
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|ERROR_MARK
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Assume that it's not a pointer-to-member.  */
operator|*
name|type
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* And that there are no cv-qualifiers.  */
operator|*
name|cv_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's a `*' or `&' we have a pointer or reference.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_MULT
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_AND
condition|)
block|{
comment|/* Remember which ptr-operator we were processing.  */
name|code
operator|=
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_AND
condition|?
name|ADDR_EXPR
else|:
name|INDIRECT_REF
operator|)
expr_stmt|;
comment|/* Consume the `*' or `&'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* A `*' can be followed by a cv-qualifier-seq, and so can a 	 `&', if we are allowing GNU extensions.  (The only qualifier 	 that can legally appear after `&' is `restrict', but that is 	 enforced during semantic analysis.  */
if|if
condition|(
name|code
operator|==
name|INDIRECT_REF
operator|||
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
condition|)
operator|*
name|cv_quals
operator|=
name|cp_parser_cv_qualifier_seq_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Try the pointer-to-member case.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the optional `::' operator.  */
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the nested-name specifier.  */
name|cp_parser_nested_name_specifier
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If we found it, and the next token is a `*', then we are 	 indeed looking at a pointer-to-member operator.  */
if|if
condition|(
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_MULT
argument_list|,
literal|"`*'"
argument_list|)
condition|)
block|{
comment|/* Indicate that the `*' operator was used.  */
name|code
operator|=
name|INDIRECT_REF
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|error
argument_list|(
literal|"%qD is a namespace"
argument_list|,
name|parser
operator|->
name|scope
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The type of which the member is a member is given by the 		 current SCOPE.  */
operator|*
name|type
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
comment|/* The next name will not be qualified.  */
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Look for the optional cv-qualifier-seq.  */
operator|*
name|cv_quals
operator|=
name|cp_parser_cv_qualifier_seq_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If that didn't work we don't have a ptr-operator.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected ptr-operator"
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) cv-qualifier-seq.     cv-qualifier-seq:      cv-qualifier cv-qualifier-seq [opt]     cv-qualifier:      const      volatile     GNU Extension:     cv-qualifier:      __restrict__     Returns a bitmask representing the cv-qualifiers.  */
end_comment

begin_function
specifier|static
name|cp_cv_quals
name|cp_parser_cv_qualifier_seq_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_cv_quals
name|cv_quals
init|=
name|TYPE_UNQUALIFIED
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|cp_cv_quals
name|cv_qualifier
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* See if it's a cv-qualifier.  */
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_CONST
case|:
name|cv_qualifier
operator|=
name|TYPE_QUAL_CONST
expr_stmt|;
break|break;
case|case
name|RID_VOLATILE
case|:
name|cv_qualifier
operator|=
name|TYPE_QUAL_VOLATILE
expr_stmt|;
break|break;
case|case
name|RID_RESTRICT
case|:
name|cv_qualifier
operator|=
name|TYPE_QUAL_RESTRICT
expr_stmt|;
break|break;
default|default:
name|cv_qualifier
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|cv_qualifier
condition|)
break|break;
if|if
condition|(
name|cv_quals
operator|&
name|cv_qualifier
condition|)
block|{
name|error
argument_list|(
literal|"duplicate cv-qualifier"
argument_list|)
expr_stmt|;
name|cp_lexer_purge_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|cv_quals
operator||=
name|cv_qualifier
expr_stmt|;
block|}
block|}
return|return
name|cv_quals
return|;
block|}
end_function

begin_comment
comment|/* Parse a declarator-id.     declarator-id:      id-expression      :: [opt] nested-name-specifier [opt] type-name     In the `id-expression' case, the value returned is as for    cp_parser_id_expression if the id-expression was an unqualified-id.    If the id-expression was a qualified-id, then a SCOPE_REF is    returned.  The first operand is the scope (either a NAMESPACE_DECL    or TREE_TYPE), but the second is still just a representation of an    unqualified-id.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_declarator_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|optional_p
parameter_list|)
block|{
name|tree
name|id
decl_stmt|;
comment|/* The expression must be an id-expression.  Assume that qualified      names are the names of types so that:         template<class T>        int S<T>::R::i = 3;       will work; we must treat `S<T>::R' as the name of a type.      Similarly, assume that qualified names are templates, where      required, so that:         template<class T>        int S<T>::R<T>::i = 3;       will work, too.  */
name|id
operator|=
name|cp_parser_id_expression
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|false
argument_list|,
comment|/*template_p=*/
name|NULL
argument_list|,
comment|/*declarator_p=*/
name|true
argument_list|,
name|optional_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|&&
name|BASELINK_P
argument_list|(
name|id
argument_list|)
condition|)
name|id
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_comment
comment|/* Parse a type-id.     type-id:      type-specifier-seq abstract-declarator [opt]     Returns the TYPE specified.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_type_id
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_decl_specifier_seq
name|type_specifier_seq
decl_stmt|;
name|cp_declarator
modifier|*
name|abstract_declarator
decl_stmt|;
comment|/* Parse the type-specifier-seq.  */
name|cp_parser_type_specifier_seq
argument_list|(
name|parser
argument_list|,
comment|/*is_condition=*/
name|false
argument_list|,
operator|&
name|type_specifier_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_specifier_seq
operator|.
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* There might or might not be an abstract declarator.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the declarator.  */
name|abstract_declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_ABSTRACT
argument_list|,
name|NULL
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|,
comment|/*member_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Check to see if there really was a declarator.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
name|abstract_declarator
operator|=
name|NULL
expr_stmt|;
return|return
name|groktypename
argument_list|(
operator|&
name|type_specifier_seq
argument_list|,
name|abstract_declarator
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a type-specifier-seq.     type-specifier-seq:      type-specifier type-specifier-seq [opt]     GNU extension:     type-specifier-seq:      attributes type-specifier-seq [opt]     If IS_CONDITION is true, we are at the start of a "condition",    e.g., we've just seen "if (".     Sets *TYPE_SPECIFIER_SEQ to represent the sequence.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_type_specifier_seq
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|is_condition
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
name|type_specifier_seq
parameter_list|)
block|{
name|bool
name|seen_type_specifier
init|=
name|false
decl_stmt|;
name|cp_parser_flags
name|flags
init|=
name|CP_PARSER_FLAGS_OPTIONAL
decl_stmt|;
comment|/* Clear the TYPE_SPECIFIER_SEQ.  */
name|clear_decl_specs
argument_list|(
name|type_specifier_seq
argument_list|)
expr_stmt|;
comment|/* Parse the type-specifiers and attributes.  */
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|type_specifier
decl_stmt|;
name|bool
name|is_cv_qualifier
decl_stmt|;
comment|/* Check for attributes first.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_ATTRIBUTE
argument_list|)
condition|)
block|{
name|type_specifier_seq
operator|->
name|attributes
operator|=
name|chainon
argument_list|(
name|type_specifier_seq
operator|->
name|attributes
argument_list|,
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Look for the type-specifier.  */
name|type_specifier
operator|=
name|cp_parser_type_specifier
argument_list|(
name|parser
argument_list|,
name|flags
argument_list|,
name|type_specifier_seq
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|,
name|NULL
argument_list|,
operator|&
name|is_cv_qualifier
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_specifier
condition|)
block|{
comment|/* If the first type-specifier could not be found, this is not a 	     type-specifier-seq at all.  */
if|if
condition|(
operator|!
name|seen_type_specifier
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected type-specifier"
argument_list|)
expr_stmt|;
name|type_specifier_seq
operator|->
name|type
operator|=
name|error_mark_node
expr_stmt|;
return|return;
block|}
comment|/* If subsequent type-specifiers could not be found, the 	     type-specifier-seq is complete.  */
break|break;
block|}
name|seen_type_specifier
operator|=
name|true
expr_stmt|;
comment|/* The standard says that a condition can be:  	    type-specifier-seq declarator = assignment-expression  	 However, given:  	   struct S {}; 	   if (int S = ...)  	 we should treat the "S" as a declarator, not as a 	 type-specifier.  The standard doesn't say that explicitly for 	 type-specifier-seq, but it does say that for 	 decl-specifier-seq in an ordinary declaration.  Perhaps it 	 would be clearer just to allow a decl-specifier-seq here, and 	 then add a semantic restriction that if any decl-specifiers 	 that are not type-specifiers appear, the program is invalid.  */
if|if
condition|(
name|is_condition
operator|&&
operator|!
name|is_cv_qualifier
condition|)
name|flags
operator||=
name|CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES
expr_stmt|;
block|}
name|cp_parser_check_decl_spec
argument_list|(
name|type_specifier_seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a parameter-declaration-clause.     parameter-declaration-clause:      parameter-declaration-list [opt] ... [opt]      parameter-declaration-list , ...     Returns a representation for the parameter declarations.  A return    value of NULL indicates a parameter-declaration-clause consisting    only of an ellipsis.  */
end_comment

begin_function
specifier|static
name|cp_parameter_declarator
modifier|*
name|cp_parser_parameter_declaration_clause
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_parameter_declarator
modifier|*
name|parameters
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|bool
name|ellipsis_p
decl_stmt|;
name|bool
name|is_error
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Check for trivial parameter-declaration-clauses.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_ELLIPSIS
condition|)
block|{
comment|/* Consume the `...' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
condition|)
comment|/* There are no parameters.  */
block|{
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
if|if
condition|(
name|in_system_header
operator|&&
name|current_class_type
operator|==
name|NULL
operator|&&
name|current_lang_name
operator|==
name|lang_name_c
condition|)
return|return
name|NULL
return|;
else|else
endif|#
directive|endif
return|return
name|no_parameters
return|;
block|}
comment|/* Check for `(void)', too, which is a special case.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_VOID
operator|&&
operator|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
operator|)
condition|)
block|{
comment|/* Consume the `void' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* There are no parameters.  */
return|return
name|no_parameters
return|;
block|}
comment|/* Parse the parameter-declaration-list.  */
name|parameters
operator|=
name|cp_parser_parameter_declaration_list
argument_list|(
name|parser
argument_list|,
operator|&
name|is_error
argument_list|)
expr_stmt|;
comment|/* If a parse error occurred while parsing the      parameter-declaration-list, then the entire      parameter-declaration-clause is erroneous.  */
if|if
condition|(
name|is_error
condition|)
return|return
name|NULL
return|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's a `,', the clause should terminate with an ellipsis.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
condition|)
block|{
comment|/* Consume the `,'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Expect an ellipsis.  */
name|ellipsis_p
operator|=
operator|(
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_ELLIPSIS
argument_list|,
literal|"`...'"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
comment|/* It might also be `...' if the optional trailing `,' was      omitted.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_ELLIPSIS
condition|)
block|{
comment|/* Consume the `...' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* And remember that we saw it.  */
name|ellipsis_p
operator|=
name|true
expr_stmt|;
block|}
else|else
name|ellipsis_p
operator|=
name|false
expr_stmt|;
comment|/* Finish the parameter list.  */
if|if
condition|(
name|parameters
operator|&&
name|ellipsis_p
condition|)
name|parameters
operator|->
name|ellipsis_p
operator|=
name|true
expr_stmt|;
return|return
name|parameters
return|;
block|}
end_function

begin_comment
comment|/* Parse a parameter-declaration-list.     parameter-declaration-list:      parameter-declaration      parameter-declaration-list , parameter-declaration     Returns a representation of the parameter-declaration-list, as for    cp_parser_parameter_declaration_clause.  However, the    `void_list_node' is never appended to the list.  Upon return,    *IS_ERROR will be true iff an error occurred.  */
end_comment

begin_function
specifier|static
name|cp_parameter_declarator
modifier|*
name|cp_parser_parameter_declaration_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
modifier|*
name|is_error
parameter_list|)
block|{
name|cp_parameter_declarator
modifier|*
name|parameters
init|=
name|NULL
decl_stmt|;
name|cp_parameter_declarator
modifier|*
modifier|*
name|tail
init|=
operator|&
name|parameters
decl_stmt|;
name|bool
name|saved_in_unbraced_linkage_specification_p
decl_stmt|;
comment|/* Assume all will go well.  */
operator|*
name|is_error
operator|=
name|false
expr_stmt|;
comment|/* The special considerations that apply to a function within an      unbraced linkage specifications do not apply to the parameters      to the function.  */
name|saved_in_unbraced_linkage_specification_p
operator|=
name|parser
operator|->
name|in_unbraced_linkage_specification_p
expr_stmt|;
name|parser
operator|->
name|in_unbraced_linkage_specification_p
operator|=
name|false
expr_stmt|;
comment|/* Look for more parameters.  */
while|while
condition|(
name|true
condition|)
block|{
name|cp_parameter_declarator
modifier|*
name|parameter
decl_stmt|;
name|bool
name|parenthesized_p
decl_stmt|;
comment|/* Parse the parameter.  */
name|parameter
operator|=
name|cp_parser_parameter_declaration
argument_list|(
name|parser
argument_list|,
comment|/*template_parm_p=*/
name|false
argument_list|,
operator|&
name|parenthesized_p
argument_list|)
expr_stmt|;
comment|/* If a parse error occurred parsing the parameter declaration, 	 then the entire parameter-declaration-list is erroneous.  */
if|if
condition|(
operator|!
name|parameter
condition|)
block|{
operator|*
name|is_error
operator|=
name|true
expr_stmt|;
name|parameters
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* Add the new parameter to the list.  */
operator|*
name|tail
operator|=
name|parameter
expr_stmt|;
name|tail
operator|=
operator|&
name|parameter
operator|->
name|next
expr_stmt|;
comment|/* Peek at the next token.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
operator|||
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_ELLIPSIS
argument_list|)
comment|/* These are for Objective-C++ */
operator|||
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
operator|||
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
comment|/* The parameter-declaration-list is complete.  */
break|break;
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If it's an ellipsis, then the list is complete.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_ELLIPSIS
condition|)
break|break;
comment|/* Otherwise, there must be more parameters.  Consume the 	     `,'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* When parsing something like:  		int i(float f, double d)  	     we can tell after seeing the declaration for "f" that we 	     are not looking at an initialization of a variable "i", 	     but rather at the declaration of a function "i".  	     Due to the fact that the parsing of template arguments 	     (as specified to a template-id) requires backtracking we 	     cannot use this technique when inside a template argument 	     list.  */
if|if
condition|(
operator|!
name|parser
operator|->
name|in_template_argument_list_p
operator|&&
operator|!
name|parser
operator|->
name|in_type_id_in_expr_p
operator|&&
name|cp_parser_uncommitted_to_tentative_parse_p
argument_list|(
name|parser
argument_list|)
comment|/* However, a parameter-declaration of the form 		 "foat(f)" (which is a valid declaration of a 		 parameter "f") can also be interpreted as an 		 expression (the conversion of "f" to "float").  */
operator|&&
operator|!
name|parenthesized_p
condition|)
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<,%> or %<...%>"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_uncommitted_to_tentative_parse_p
argument_list|(
name|parser
argument_list|)
condition|)
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
comment|/*recovering=*/
name|true
argument_list|,
comment|/*or_comma=*/
name|false
argument_list|,
comment|/*consume_paren=*/
name|false
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|parser
operator|->
name|in_unbraced_linkage_specification_p
operator|=
name|saved_in_unbraced_linkage_specification_p
expr_stmt|;
return|return
name|parameters
return|;
block|}
end_function

begin_comment
comment|/* Parse a parameter declaration.     parameter-declaration:      decl-specifier-seq declarator      decl-specifier-seq declarator = assignment-expression      decl-specifier-seq abstract-declarator [opt]      decl-specifier-seq abstract-declarator [opt] = assignment-expression     If TEMPLATE_PARM_P is TRUE, then this parameter-declaration    declares a template parameter.  (In that case, a non-nested `>'    token encountered during the parsing of the assignment-expression    is not interpreted as a greater-than operator.)     Returns a representation of the parameter, or NULL if an error    occurs.  If PARENTHESIZED_P is non-NULL, *PARENTHESIZED_P is set to    true iff the declarator is of the form "(p)".  */
end_comment

begin_function
specifier|static
name|cp_parameter_declarator
modifier|*
name|cp_parser_parameter_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|template_parm_p
parameter_list|,
name|bool
modifier|*
name|parenthesized_p
parameter_list|)
block|{
name|int
name|declares_class_or_enum
decl_stmt|;
name|bool
name|greater_than_is_operator_p
decl_stmt|;
name|cp_decl_specifier_seq
name|decl_specifiers
decl_stmt|;
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
name|tree
name|default_argument
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
comment|/* In a template parameter, `>' is not an operator.       [temp.param]       When parsing a default template-argument for a non-type      template-parameter, the first non-nested `>' is taken as the end      of the template parameter-list rather than a greater-than      operator.  */
name|greater_than_is_operator_p
operator|=
operator|!
name|template_parm_p
expr_stmt|;
comment|/* Type definitions may not appear in parameter types.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in parameter types"
expr_stmt|;
comment|/* Parse the declaration-specifiers.  */
name|cp_parser_decl_specifier_seq
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_FLAGS_NONE
argument_list|,
operator|&
name|decl_specifiers
argument_list|,
operator|&
name|declares_class_or_enum
argument_list|)
expr_stmt|;
comment|/* If an error occurred, there's no reason to attempt to parse the      rest of the declaration.  */
if|if
condition|(
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token is a `)', `,', `=', `>', or `...', then there      is no declarator.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_EQ
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_ELLIPSIS
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_GREATER
condition|)
block|{
name|declarator
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|parenthesized_p
condition|)
operator|*
name|parenthesized_p
operator|=
name|false
expr_stmt|;
block|}
comment|/* Otherwise, there should be a declarator.  */
else|else
block|{
name|bool
name|saved_default_arg_ok_p
init|=
name|parser
operator|->
name|default_arg_ok_p
decl_stmt|;
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|false
expr_stmt|;
comment|/* After seeing a decl-specifier-seq, if the next token is not a 	 "(", there is no possibility that the code is a valid 	 expression.  Therefore, if parsing tentatively, we commit at 	 this point.  */
if|if
condition|(
operator|!
name|parser
operator|->
name|in_template_argument_list_p
comment|/* In an expression context, having seen:  	       (int((char ...  	     we cannot be sure whether we are looking at a 	     function-type (taking a "char" as a parameter) or a cast 	     of some object of type "char" to "int".  */
operator|&&
operator|!
name|parser
operator|->
name|in_type_id_in_expr_p
operator|&&
name|cp_parser_uncommitted_to_tentative_parse_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the declarator.  */
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_EITHER
argument_list|,
comment|/*ctor_dtor_or_conv_p=*/
name|NULL
argument_list|,
name|parenthesized_p
argument_list|,
comment|/*member_p=*/
name|false
argument_list|)
expr_stmt|;
name|parser
operator|->
name|default_arg_ok_p
operator|=
name|saved_default_arg_ok_p
expr_stmt|;
comment|/* After the declarator, allow more attributes.  */
name|decl_specifiers
operator|.
name|attributes
operator|=
name|chainon
argument_list|(
name|decl_specifiers
operator|.
name|attributes
argument_list|,
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The restriction on defining new types applies only to the type      of the parameter, not to the default argument.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
comment|/* If the next token is `=', then process a default argument.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EQ
argument_list|)
condition|)
block|{
name|bool
name|saved_greater_than_is_operator_p
decl_stmt|;
comment|/* Consume the `='.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If we are defining a class, then the tokens that make up the 	 default argument must be saved and processed later.  */
if|if
condition|(
operator|!
name|template_parm_p
operator|&&
name|at_class_scope_p
argument_list|()
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|unsigned
name|depth
init|=
literal|0
decl_stmt|;
name|cp_token
modifier|*
name|first_token
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Add tokens until we have processed the entire default 	     argument.  We add the range [first_token, token).  */
name|first_token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|bool
name|done
init|=
name|false
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* What we do depends on what token we have.  */
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
comment|/* In valid code, a default argument must be 		     immediately followed by a `,' `)', or `...'.  */
case|case
name|CPP_COMMA
case|:
case|case
name|CPP_CLOSE_PAREN
case|:
case|case
name|CPP_ELLIPSIS
case|:
comment|/* If we run into a non-nested `;', `}', or `]', 		     then the code is invalid -- but the default 		     argument is certainly over.  */
case|case
name|CPP_SEMICOLON
case|:
case|case
name|CPP_CLOSE_BRACE
case|:
case|case
name|CPP_CLOSE_SQUARE
case|:
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
name|done
operator|=
name|true
expr_stmt|;
comment|/* Update DEPTH, if necessary.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_SQUARE
condition|)
operator|--
name|depth
expr_stmt|;
break|break;
case|case
name|CPP_OPEN_PAREN
case|:
case|case
name|CPP_OPEN_SQUARE
case|:
case|case
name|CPP_OPEN_BRACE
case|:
operator|++
name|depth
expr_stmt|;
break|break;
case|case
name|CPP_GREATER
case|:
comment|/* If we see a non-nested `>', and `>' is not an 		     operator, then it marks the end of the default 		     argument.  */
if|if
condition|(
operator|!
name|depth
operator|&&
operator|!
name|greater_than_is_operator_p
condition|)
name|done
operator|=
name|true
expr_stmt|;
break|break;
comment|/* If we run out of tokens, issue an error message.  */
case|case
name|CPP_EOF
case|:
case|case
name|CPP_PRAGMA_EOL
case|:
name|error
argument_list|(
literal|"file ends in default argument"
argument_list|)
expr_stmt|;
name|done
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|CPP_NAME
case|:
case|case
name|CPP_SCOPE
case|:
comment|/* In these cases, we should look for template-ids. 		     For example, if the default argument is 		     `X<int, double>()', we need to do name lookup to 		     figure out whether or not `X' is a template; if 		     so, the `,' does not end the default argument.  		     That is not yet done.  */
break|break;
default|default:
break|break;
block|}
comment|/* If we've reached the end, stop.  */
if|if
condition|(
name|done
condition|)
break|break;
comment|/* Add the token to the token block.  */
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* Create a DEFAULT_ARG to represented the unparsed default 	     argument.  */
name|default_argument
operator|=
name|make_node
argument_list|(
name|DEFAULT_ARG
argument_list|)
expr_stmt|;
name|DEFARG_TOKENS
argument_list|(
name|default_argument
argument_list|)
operator|=
name|cp_token_cache_new
argument_list|(
name|first_token
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|DEFARG_INSTANTIATIONS
argument_list|(
name|default_argument
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Outside of a class definition, we can just parse the 	 assignment-expression.  */
else|else
block|{
name|bool
name|saved_local_variables_forbidden_p
decl_stmt|;
comment|/* Make sure that PARSER->GREATER_THAN_IS_OPERATOR_P is 	     set correctly.  */
name|saved_greater_than_is_operator_p
operator|=
name|parser
operator|->
name|greater_than_is_operator_p
expr_stmt|;
name|parser
operator|->
name|greater_than_is_operator_p
operator|=
name|greater_than_is_operator_p
expr_stmt|;
comment|/* Local variable names (and the `this' keyword) may not 	     appear in a default argument.  */
name|saved_local_variables_forbidden_p
operator|=
name|parser
operator|->
name|local_variables_forbidden_p
expr_stmt|;
name|parser
operator|->
name|local_variables_forbidden_p
operator|=
name|true
expr_stmt|;
comment|/* The default argument expression may cause implicitly 	     defined member functions to be synthesized, which will 	     result in garbage collection.  We must treat this 	     situation as if we were within the body of function so as 	     to avoid collecting live data on the stack.  */
operator|++
name|function_depth
expr_stmt|;
comment|/* Parse the assignment-expression.  */
if|if
condition|(
name|template_parm_p
condition|)
name|push_deferring_access_checks
argument_list|(
name|dk_no_deferred
argument_list|)
expr_stmt|;
name|default_argument
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|template_parm_p
condition|)
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Restore saved state.  */
operator|--
name|function_depth
expr_stmt|;
name|parser
operator|->
name|greater_than_is_operator_p
operator|=
name|saved_greater_than_is_operator_p
expr_stmt|;
name|parser
operator|->
name|local_variables_forbidden_p
operator|=
name|saved_local_variables_forbidden_p
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parser
operator|->
name|default_arg_ok_p
condition|)
block|{
if|if
condition|(
operator|!
name|flag_pedantic_errors
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"deprecated use of default argument for parameter of non-function"
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"default arguments are only permitted for function parameters"
argument_list|)
expr_stmt|;
name|default_argument
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
else|else
name|default_argument
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|make_parameter_declarator
argument_list|(
operator|&
name|decl_specifiers
argument_list|,
name|declarator
argument_list|,
name|default_argument
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a function-body.     function-body:      compound_statement  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_function_body
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a ctor-initializer-opt followed by a function-body.  Return    true if a ctor-initializer was present.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_ctor_initializer_opt_and_function_body
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|body
decl_stmt|;
name|bool
name|ctor_initializer_p
decl_stmt|;
comment|/* Begin the function body.  */
name|body
operator|=
name|begin_function_body
argument_list|()
expr_stmt|;
comment|/* Parse the optional ctor-initializer.  */
name|ctor_initializer_p
operator|=
name|cp_parser_ctor_initializer_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the function-body.  */
name|cp_parser_function_body
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Finish the function body.  */
name|finish_function_body
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|ctor_initializer_p
return|;
block|}
end_function

begin_comment
comment|/* Parse an initializer.     initializer:      = initializer-clause      ( expression-list )     Returns an expression representing the initializer.  If no    initializer is present, NULL_TREE is returned.     *IS_PARENTHESIZED_INIT is set to TRUE if the `( expression-list )'    production is used, and zero otherwise.  *IS_PARENTHESIZED_INIT is    set to FALSE if there is no initializer present.  If there is an    initializer, and it is not a constant-expression, *NON_CONSTANT_P    is set to true; otherwise it is set to false.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_initializer
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
modifier|*
name|is_parenthesized_init
parameter_list|,
name|bool
modifier|*
name|non_constant_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|init
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Let our caller know whether or not this initializer was      parenthesized.  */
operator|*
name|is_parenthesized_init
operator|=
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
operator|)
expr_stmt|;
comment|/* Assume that the initializer is constant.  */
operator|*
name|non_constant_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EQ
condition|)
block|{
comment|/* Consume the `='.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the initializer-clause.  */
name|init
operator|=
name|cp_parser_initializer_clause
argument_list|(
name|parser
argument_list|,
name|non_constant_p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
name|init
operator|=
name|cp_parser_parenthesized_expression_list
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|,
name|non_constant_p
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Anything else is an error.  */
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected initializer"
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Parse an initializer-clause.     initializer-clause:      assignment-expression      { initializer-list , [opt] }      { }     Returns an expression representing the initializer.     If the `assignment-expression' production is used the value    returned is simply a representation for the expression.     Otherwise, a CONSTRUCTOR is returned.  The CONSTRUCTOR_ELTS will be    the elements of the initializer-list (or NULL, if the last    production is used).  The TREE_TYPE for the CONSTRUCTOR will be    NULL_TREE.  There is no way to detect whether or not the optional    trailing `,' was provided.  NON_CONSTANT_P is as for    cp_parser_initializer.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_initializer_clause
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
modifier|*
name|non_constant_p
parameter_list|)
block|{
name|tree
name|initializer
decl_stmt|;
comment|/* Assume the expression is constant.  */
operator|*
name|non_constant_p
operator|=
name|false
expr_stmt|;
comment|/* If it is not a `{', then we are looking at an      assignment-expression.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
block|{
name|initializer
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant_p=*/
name|true
argument_list|,
name|non_constant_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|non_constant_p
condition|)
name|initializer
operator|=
name|fold_non_dependent_expr
argument_list|(
name|initializer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Consume the `{' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Create a CONSTRUCTOR to represent the braced-initializer.  */
name|initializer
operator|=
name|make_node
argument_list|(
name|CONSTRUCTOR
argument_list|)
expr_stmt|;
comment|/* If it's not a `}', then there is a non-trivial initializer.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
block|{
comment|/* Parse the initializer list.  */
name|CONSTRUCTOR_ELTS
argument_list|(
name|initializer
argument_list|)
operator|=
name|cp_parser_initializer_list
argument_list|(
name|parser
argument_list|,
name|non_constant_p
argument_list|)
expr_stmt|;
comment|/* A trailing `,' token is allowed.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* Now, there should be a trailing `}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
block|}
return|return
name|initializer
return|;
block|}
end_function

begin_comment
comment|/* Parse an initializer-list.     initializer-list:      initializer-clause      initializer-list , initializer-clause     GNU Extension:     initializer-list:      identifier : initializer-clause      initializer-list, identifier : initializer-clause     Returns a VEC of constructor_elt.  The VALUE of each elt is an expression    for the initializer.  If the INDEX of the elt is non-NULL, it is the    IDENTIFIER_NODE naming the field to initialize.  NON_CONSTANT_P is    as for cp_parser_initializer.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|cp_parser_initializer_list
argument_list|(
argument|cp_parser* parser
argument_list|,
argument|bool* non_constant_p
argument_list|)
block|{
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
operator|=
name|NULL
block|;
comment|/* Assume all of the expressions are constant.  */
operator|*
name|non_constant_p
operator|=
name|false
block|;
comment|/* Parse the rest of the list.  */
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|tree
name|initializer
decl_stmt|;
name|bool
name|clause_non_constant_p
decl_stmt|;
comment|/* If the next token is an identifier and the following one is a 	 colon, we are looking at the GNU designated-initializer 	 syntax.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|==
name|CPP_COLON
condition|)
block|{
comment|/* Warn the user that they are using an extension.  */
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ does not allow designated initializers"
argument_list|)
expr_stmt|;
comment|/* Consume the identifier.  */
name|identifier
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|u
operator|.
name|value
expr_stmt|;
comment|/* Consume the `:'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
name|identifier
operator|=
name|NULL_TREE
expr_stmt|;
end_else

begin_comment
comment|/* Parse the initializer.  */
end_comment

begin_expr_stmt
name|initializer
operator|=
name|cp_parser_initializer_clause
argument_list|(
name|parser
argument_list|,
operator|&
name|clause_non_constant_p
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If any clause is non-constant, so is the entire initializer.  */
end_comment

begin_if
if|if
condition|(
name|clause_non_constant_p
condition|)
operator|*
name|non_constant_p
operator|=
name|true
expr_stmt|;
end_if

begin_comment
comment|/* Add it to the vector.  */
end_comment

begin_expr_stmt
name|CONSTRUCTOR_APPEND_ELT
argument_list|(
name|v
argument_list|,
name|identifier
argument_list|,
name|initializer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If the next token is not a comma, we have reached the end of 	 the list.  */
end_comment

begin_if
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
end_if

begin_comment
comment|/* Peek at the next token.  */
end_comment

begin_expr_stmt
name|token
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If the next token is a `}', then we're still done.  An 	 initializer-clause can have a trailing `,' after the 	 initializer-list and before the closing `}'.  */
end_comment

begin_if
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
condition|)
break|break;
end_if

begin_comment
comment|/* Consume the `,' token.  */
end_comment

begin_expr_stmt
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    return
name|v
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* Classes [gram.class] */
end_comment

begin_comment
comment|/* Parse a class-name.     class-name:      identifier      template-id     TYPENAME_KEYWORD_P is true iff the `typename' keyword has been used    to indicate that names looked up in dependent types should be    assumed to be types.  TEMPLATE_KEYWORD_P is true iff the `template'    keyword has been used to indicate that the name that appears next    is a template.  TAG_TYPE indicates the explicit tag given before    the type name, if any.  If CHECK_DEPENDENCY_P is FALSE, names are    looked up in dependent scopes.  If CLASS_HEAD_P is TRUE, this class    is the class being defined in a class-head.     Returns the TYPE_DECL representing the class.  */
end_comment

begin_function
unit|static
name|tree
name|cp_parser_class_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|typename_keyword_p
parameter_list|,
name|bool
name|template_keyword_p
parameter_list|,
name|enum
name|tag_types
name|tag_type
parameter_list|,
name|bool
name|check_dependency_p
parameter_list|,
name|bool
name|class_head_p
parameter_list|,
name|bool
name|is_declaration
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|bool
name|typename_p
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* All class-names start with an identifier.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NAME
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_TEMPLATE_ID
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected class-name"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* PARSER->SCOPE can be cleared when parsing the template-arguments      to a template-id, so we save it here.  */
name|scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
if|if
condition|(
name|scope
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Any name names a type if we're following the `typename' keyword      in a qualified name where the enclosing scope is type-dependent.  */
name|typename_p
operator|=
operator|(
name|typename_keyword_p
operator|&&
name|scope
operator|&&
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|scope
argument_list|)
operator|)
expr_stmt|;
comment|/* Handle the common case (an identifier, but not a template-id)      efficiently.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
operator|&&
operator|!
name|cp_parser_nth_token_starts_template_argument_list_p
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|cp_token
modifier|*
name|identifier_token
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|bool
name|ambiguous_p
decl_stmt|;
comment|/* Look for the identifier.  */
name|identifier_token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|ambiguous_p
operator|=
name|identifier_token
operator|->
name|ambiguous_p
expr_stmt|;
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token isn't an identifier, we are certainly not 	 looking at a class-name.  */
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
name|decl
operator|=
name|error_mark_node
expr_stmt|;
comment|/* If we know this is a type-name, there's no need to look it 	 up.  */
elseif|else
if|if
condition|(
name|typename_p
condition|)
name|decl
operator|=
name|identifier
expr_stmt|;
else|else
block|{
name|tree
name|ambiguous_decls
decl_stmt|;
comment|/* If we already know that this lookup is ambiguous, then 	     we've already issued an error message; there's no reason 	     to check again.  */
if|if
condition|(
name|ambiguous_p
condition|)
block|{
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If the next token is a `::', then the name must be a type 	     name.  	     [basic.lookup.qual]  	     During the lookup for a name preceding the :: scope 	     resolution operator, object, function, and enumerator 	     names are ignored.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
condition|)
name|tag_type
operator|=
name|typename_type
expr_stmt|;
comment|/* Look up the name.  */
name|decl
operator|=
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|identifier
argument_list|,
name|tag_type
argument_list|,
comment|/*is_template=*/
name|false
argument_list|,
comment|/*is_namespace=*/
name|false
argument_list|,
name|check_dependency_p
argument_list|,
operator|&
name|ambiguous_decls
argument_list|)
expr_stmt|;
if|if
condition|(
name|ambiguous_decls
condition|)
block|{
name|error
argument_list|(
literal|"reference to %qD is ambiguous"
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|ambiguous_decls
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parsing_tentatively
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|identifier_token
operator|->
name|ambiguous_p
operator|=
name|true
expr_stmt|;
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* Try a template-id.  */
name|decl
operator|=
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
name|template_keyword_p
argument_list|,
name|check_dependency_p
argument_list|,
name|is_declaration
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
name|decl
operator|=
name|cp_parser_maybe_treat_template_as_class
argument_list|(
name|decl
argument_list|,
name|class_head_p
argument_list|)
expr_stmt|;
comment|/* If this is a typename, create a TYPENAME_TYPE.  */
if|if
condition|(
name|typename_p
operator|&&
name|decl
operator|!=
name|error_mark_node
condition|)
block|{
name|decl
operator|=
name|make_typename_type
argument_list|(
name|scope
argument_list|,
name|decl
argument_list|,
name|typename_type
argument_list|,
comment|/*complain=*/
name|tf_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
name|error_mark_node
condition|)
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Check to see that it is really the name of a class.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
condition|)
comment|/* Situations like this:  	 template<typename T> struct A { 	   typename T::template X<int>::I i; 	 };         are problematic.  Is `T::template X<int>' a class-name?  The        standard does not seem to be definitive, but there is no other        valid interpretation of the following `::'.  Therefore, those        names are considered class-names.  */
block|{
name|decl
operator|=
name|make_typename_type
argument_list|(
name|scope
argument_list|,
name|decl
argument_list|,
name|tag_type
argument_list|,
name|tf_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
name|error_mark_node
condition|)
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|||
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|decl
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected class-name"
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Parse a class-specifier.     class-specifier:      class-head { member-specification [opt] }     Returns the TREE_TYPE representing the class.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_class_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|attributes
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|has_trailing_semicolon
decl_stmt|;
name|bool
name|nested_name_specifier_p
decl_stmt|;
name|unsigned
name|saved_num_template_parameter_lists
decl_stmt|;
name|bool
name|saved_in_function_body
decl_stmt|;
name|tree
name|old_scope
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|scope
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|bases
decl_stmt|;
name|push_deferring_access_checks
argument_list|(
name|dk_no_deferred
argument_list|)
expr_stmt|;
comment|/* Parse the class-head.  */
name|type
operator|=
name|cp_parser_class_head
argument_list|(
name|parser
argument_list|,
operator|&
name|nested_name_specifier_p
argument_list|,
operator|&
name|attributes
argument_list|,
operator|&
name|bases
argument_list|)
expr_stmt|;
comment|/* If the class-head was a semantic disaster, skip the entire body      of the class.  */
if|if
condition|(
operator|!
name|type
condition|)
block|{
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Look for the `{'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|,
literal|"`{'"
argument_list|)
condition|)
block|{
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Process the base classes. If they're invalid, skip the       entire class body.  */
if|if
condition|(
operator|!
name|xref_basetypes
argument_list|(
name|type
argument_list|,
name|bases
argument_list|)
condition|)
block|{
name|cp_parser_skip_to_closing_brace
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Consuming the closing brace yields better error messages          later on.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Issue an error message if type-definitions are forbidden here.  */
name|cp_parser_check_type_definition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Remember that we are defining one more class.  */
operator|++
name|parser
operator|->
name|num_classes_being_defined
expr_stmt|;
comment|/* Inside the class, surrounding template-parameter-lists do not      apply.  */
name|saved_num_template_parameter_lists
operator|=
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
name|parser
operator|->
name|num_template_parameter_lists
operator|=
literal|0
expr_stmt|;
comment|/* We are not in a function body.  */
name|saved_in_function_body
operator|=
name|parser
operator|->
name|in_function_body
expr_stmt|;
name|parser
operator|->
name|in_function_body
operator|=
name|false
expr_stmt|;
comment|/* Start the class.  */
if|if
condition|(
name|nested_name_specifier_p
condition|)
block|{
name|scope
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|old_scope
operator|=
name|push_inner_scope
argument_list|(
name|scope
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|begin_class_definition
argument_list|(
name|type
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
comment|/* If the type is erroneous, skip the entire body of the class.  */
name|cp_parser_skip_to_closing_brace
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
comment|/* Parse the member-specification.  */
name|cp_parser_member_specification_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the trailing `}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
comment|/* We get better error messages by noticing a common problem: a      missing trailing `;'.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|has_trailing_semicolon
operator|=
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_SEMICOLON
operator|)
expr_stmt|;
comment|/* Look for trailing attributes to apply to this class.  */
if|if
condition|(
name|cp_parser_allow_gnu_extensions_p
argument_list|(
name|parser
argument_list|)
condition|)
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
condition|)
name|type
operator|=
name|finish_struct
argument_list|(
name|type
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|nested_name_specifier_p
condition|)
name|pop_inner_scope
argument_list|(
name|old_scope
argument_list|,
name|scope
argument_list|)
expr_stmt|;
comment|/* If this class is not itself within the scope of another class,      then we need to parse the bodies of all of the queued function      definitions.  Note that the queued functions defined in a class      are not always processed immediately following the      class-specifier for that class.  Consider:         struct A { 	 struct B { void f() { sizeof (A); } };        };       If `f' were processed before the processing of `A' were      completed, there would be no way to compute the size of `A'.      Note that the nesting we are interested in here is lexical --      not the semantic nesting given by TYPE_CONTEXT.  In particular,      for:         struct A { struct B; };        struct A::B { void f() { } };       there is no need to delay the parsing of `A::B::f'.  */
if|if
condition|(
operator|--
name|parser
operator|->
name|num_classes_being_defined
operator|==
literal|0
condition|)
block|{
name|tree
name|queue_entry
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|tree
name|class_type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|pushed_scope
init|=
name|NULL_TREE
decl_stmt|;
comment|/* In a first pass, parse default arguments to the functions. 	 Then, in a second pass, parse the bodies of the functions. 	 This two-phased approach handles cases like:  	    struct S { 	      void f() { g(); } 	      void g(int i = 3); 	    };  	 */
for|for
control|(
name|TREE_PURPOSE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|=
name|nreverse
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
argument_list|)
init|;
operator|(
name|queue_entry
operator|=
name|TREE_PURPOSE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|)
condition|;
name|TREE_PURPOSE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
argument_list|)
control|)
block|{
name|fn
operator|=
name|TREE_VALUE
argument_list|(
name|queue_entry
argument_list|)
expr_stmt|;
comment|/* If there are default arguments that have not yet been processed, 	     take care of them now.  */
if|if
condition|(
name|class_type
operator|!=
name|TREE_PURPOSE
argument_list|(
name|queue_entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|pushed_scope
condition|)
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
name|class_type
operator|=
name|TREE_PURPOSE
argument_list|(
name|queue_entry
argument_list|)
expr_stmt|;
name|pushed_scope
operator|=
name|push_scope
argument_list|(
name|class_type
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure that any template parameters are in scope.  */
name|maybe_begin_member_template_processing
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Parse the default argument expressions.  */
name|cp_parser_late_parsing_default_args
argument_list|(
name|parser
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* Remove any template parameters from the symbol table.  */
name|maybe_end_member_template_processing
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pushed_scope
condition|)
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
comment|/* Now parse the body of the functions.  */
for|for
control|(
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|=
name|nreverse
argument_list|(
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
argument_list|)
init|;
operator|(
name|queue_entry
operator|=
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|)
condition|;
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
argument_list|)
control|)
block|{
comment|/* Figure out which function we need to process.  */
name|fn
operator|=
name|TREE_VALUE
argument_list|(
name|queue_entry
argument_list|)
expr_stmt|;
comment|/* Parse the function.  */
name|cp_parser_late_parsing_for_member
argument_list|(
name|parser
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Put back any saved access checks.  */
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Restore saved state.  */
name|parser
operator|->
name|in_function_body
operator|=
name|saved_in_function_body
expr_stmt|;
name|parser
operator|->
name|num_template_parameter_lists
operator|=
name|saved_num_template_parameter_lists
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Parse a class-head.     class-head:      class-key identifier [opt] base-clause [opt]      class-key nested-name-specifier identifier base-clause [opt]      class-key nested-name-specifier [opt] template-id        base-clause [opt]     GNU Extensions:      class-key attributes identifier [opt] base-clause [opt]      class-key attributes nested-name-specifier identifier base-clause [opt]      class-key attributes nested-name-specifier [opt] template-id        base-clause [opt]     Returns the TYPE of the indicated class.  Sets    *NESTED_NAME_SPECIFIER_P to TRUE iff one of the productions    involving a nested-name-specifier was used, and FALSE otherwise.     Returns error_mark_node if this is not a class-head.     Returns NULL_TREE if the class-head is syntactically valid, but    semantically invalid in a way that means we should skip the entire    body of the class.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_class_head
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
modifier|*
name|nested_name_specifier_p
parameter_list|,
name|tree
modifier|*
name|attributes_p
parameter_list|,
name|tree
modifier|*
name|bases
parameter_list|)
block|{
name|tree
name|nested_name_specifier
decl_stmt|;
name|enum
name|tag_types
name|class_key
decl_stmt|;
name|tree
name|id
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|bool
name|template_id_p
init|=
name|false
decl_stmt|;
name|bool
name|qualified_p
init|=
name|false
decl_stmt|;
name|bool
name|invalid_nested_name_p
init|=
name|false
decl_stmt|;
name|bool
name|invalid_explicit_specialization_p
init|=
name|false
decl_stmt|;
name|tree
name|pushed_scope
init|=
name|NULL_TREE
decl_stmt|;
name|unsigned
name|num_templates
decl_stmt|;
comment|/* Assume no nested-name-specifier will be present.  */
operator|*
name|nested_name_specifier_p
operator|=
name|false
expr_stmt|;
comment|/* Assume no template parameter lists will be used in defining the      type.  */
name|num_templates
operator|=
literal|0
expr_stmt|;
comment|/* Look for the class-key.  */
name|class_key
operator|=
name|cp_parser_class_key
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_key
operator|==
name|none_type
condition|)
return|return
name|error_mark_node
return|;
comment|/* Parse the attributes.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is `::', that is invalid -- but sometimes      people do try to write:         struct ::S {};       Handle this gracefully by accepting the extra qualifier, and then      issuing an error about it later if this really is a      class-head.  If it turns out just to be an elaborated type      specifier, remain silent.  */
if|if
condition|(
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
condition|)
name|qualified_p
operator|=
name|true
expr_stmt|;
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
comment|/* Determine the name of the class.  Begin by looking for an      optional nested-name-specifier.  */
name|nested_name_specifier
operator|=
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|false
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If there was a nested-name-specifier, then there *must* be an      identifier.  */
if|if
condition|(
name|nested_name_specifier
condition|)
block|{
comment|/* Although the grammar says `identifier', it really means 	 `class-name' or `template-name'.  You are only allowed to 	 define a class that has already been declared with this 	 syntax.  	 The proposed resolution for Core Issue 180 says that wherever 	 you see `class T::X' you should treat `X' as a type-name.  	 It is OK to define an inaccessible class; for example:  	   class A { class B; }; 	   class A::B {};  	 We do not know if we will see a class-name, or a 	 template-name.  We look for a class-name first, in case the 	 class-name is a template-id; if we looked for the 	 template-name first we would stop after the template-name.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|type
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
name|class_type
argument_list|,
comment|/*check_dependency_p=*/
name|false
argument_list|,
comment|/*class_head_p=*/
name|true
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If that didn't work, ignore the nested-name-specifier.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|invalid_nested_name_p
operator|=
name|true
expr_stmt|;
name|id
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|error_mark_node
condition|)
name|id
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* If we could not find a corresponding TYPE, treat this 	 declaration like an unqualified declaration.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|nested_name_specifier
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Otherwise, count the number of templates used in TYPE and its 	 containing scopes.  */
else|else
block|{
name|tree
name|scope
decl_stmt|;
for|for
control|(
name|scope
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
init|;
name|scope
operator|&&
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|;
name|scope
operator|=
operator|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|?
name|TYPE_CONTEXT
argument_list|(
name|scope
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|scope
argument_list|)
operator|)
control|)
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|scope
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|scope
argument_list|)
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|scope
argument_list|)
condition|)
operator|++
name|num_templates
expr_stmt|;
block|}
block|}
comment|/* Otherwise, the identifier is optional.  */
else|else
block|{
comment|/* We don't know whether what comes next is a template-id, 	 an identifier, or nothing at all.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Check for a template-id.  */
name|id
operator|=
name|cp_parser_template_id
argument_list|(
name|parser
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
comment|/* If that didn't work, it could still be an identifier.  */
if|if
condition|(
operator|!
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
name|id
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|id
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|template_id_p
operator|=
name|true
expr_stmt|;
operator|++
name|num_templates
expr_stmt|;
block|}
block|}
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|cp_parser_check_for_invalid_template_id
argument_list|(
name|parser
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* If it's not a `:' or a `{' then we can't really be looking at a      class-head, since a class-head only appears as part of a      class-specifier.  We have to detect this situation before calling      xref_tag, since that has irreversible side-effects.  */
if|if
condition|(
operator|!
name|cp_parser_next_token_starts_class_definition_p
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<{%> or %<:%>"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* At this point, we're going ahead with the class-specifier, even      if some other problem occurs.  */
name|cp_parser_commit_to_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Issue the error about the overly-qualified name now.  */
if|if
condition|(
name|qualified_p
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"global qualification of class name is invalid"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|invalid_nested_name_p
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"qualified name does not name a class"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nested_name_specifier
condition|)
block|{
name|tree
name|scope
decl_stmt|;
comment|/* Reject typedef-names in class heads.  */
if|if
condition|(
operator|!
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid class name in declaration of %qD"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL_TREE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Figure out in what scope the declaration is being placed.  */
name|scope
operator|=
name|current_scope
argument_list|()
expr_stmt|;
comment|/* If that scope does not contain the scope in which the 	 class was originally declared, the program is invalid.  */
if|if
condition|(
name|scope
operator|&&
operator|!
name|is_ancestor
argument_list|(
name|scope
argument_list|,
name|nested_name_specifier
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"declaration of %qD in %qD which does not enclose %qD"
argument_list|,
name|type
argument_list|,
name|scope
argument_list|,
name|nested_name_specifier
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL_TREE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* [dcl.meaning]  	 A declarator-id shall not be qualified exception of the 	 definition of a ... nested class outside of its class 	 ... [or] a the definition or explicit instantiation of a 	 class member of a namespace outside of its namespace.  */
if|if
condition|(
name|scope
operator|==
name|nested_name_specifier
condition|)
block|{
name|pedwarn
argument_list|(
literal|"extra qualification ignored"
argument_list|)
expr_stmt|;
name|nested_name_specifier
operator|=
name|NULL_TREE
expr_stmt|;
name|num_templates
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* An explicit-specialization must be preceded by "template<>".  If      it is not, try to recover gracefully.  */
if|if
condition|(
name|at_namespace_scope_p
argument_list|()
operator|&&
name|parser
operator|->
name|num_template_parameter_lists
operator|==
literal|0
operator|&&
name|template_id_p
condition|)
block|{
name|error
argument_list|(
literal|"an explicit specialization must be preceded by %<template<>%>"
argument_list|)
expr_stmt|;
name|invalid_explicit_specialization_p
operator|=
name|true
expr_stmt|;
comment|/* Take the same action that would have been taken by 	 cp_parser_explicit_specialization.  */
operator|++
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
name|begin_specialization
argument_list|()
expr_stmt|;
block|}
comment|/* There must be no "return" statements between this point and the      end of this function; set "type "to the correct return value and      use "goto done;" to return.  */
comment|/* Make sure that the right number of template parameters were      present.  */
if|if
condition|(
operator|!
name|cp_parser_check_template_parameters
argument_list|(
name|parser
argument_list|,
name|num_templates
argument_list|)
condition|)
block|{
comment|/* If something went wrong, there is no point in even trying to 	 process the class-definition.  */
name|type
operator|=
name|NULL_TREE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Look up the type.  */
if|if
condition|(
name|template_id_p
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|type
operator|=
name|maybe_process_partial_specialization
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|nested_name_specifier
condition|)
name|pushed_scope
operator|=
name|push_scope
argument_list|(
name|nested_name_specifier
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nested_name_specifier
condition|)
block|{
name|tree
name|class_type
decl_stmt|;
comment|/* Given:  	    template<typename T> struct S { struct T }; 	    template<typename T> struct S<T>::T { };  	 we will get a TYPENAME_TYPE when processing the definition of 	 `S::T'.  We need to resolve it to the actual type before we 	 try to define it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
name|class_type
operator|=
name|resolve_typename_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
comment|/*only_current_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_type
operator|!=
name|error_mark_node
condition|)
name|type
operator|=
name|TYPE_NAME
argument_list|(
name|class_type
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"could not resolve typename type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
name|maybe_process_partial_specialization
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|class_type
operator|=
name|current_class_type
expr_stmt|;
comment|/* Enter the scope indicated by the nested-name-specifier.  */
name|pushed_scope
operator|=
name|push_scope
argument_list|(
name|nested_name_specifier
argument_list|)
expr_stmt|;
comment|/* Get the canonical version of this type.  */
name|type
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
operator|&&
operator|!
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|=
name|push_template_decl
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|type
operator|=
name|NULL_TREE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
operator|*
name|nested_name_specifier_p
operator|=
name|true
expr_stmt|;
block|}
else|else
comment|/* The name is not a nested name.  */
block|{
comment|/* If the class was unnamed, create a dummy name.  */
if|if
condition|(
operator|!
name|id
condition|)
name|id
operator|=
name|make_anon_name
argument_list|()
expr_stmt|;
name|type
operator|=
name|xref_tag
argument_list|(
name|class_key
argument_list|,
name|id
argument_list|,
comment|/*tag_scope=*/
name|ts_current
argument_list|,
name|parser
operator|->
name|num_template_parameter_lists
argument_list|)
expr_stmt|;
block|}
comment|/* Indicate whether this class was declared as a `class' or as a      `struct'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|class_key
operator|==
name|class_type
operator|)
expr_stmt|;
name|cp_parser_check_class_key
argument_list|(
name|class_key
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If this type was already complete, and we see another definition,      that's an error.  */
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"redefinition of %q#T"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"previous definition of %q+#T"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL_TREE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* We will have entered the scope containing the class; the names of      base classes should be looked up in that context.  For example:         struct A { struct B {}; struct C; };        struct A::C : B {};       is valid.  */
operator|*
name|bases
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Get the list of base-classes, if there is one.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
operator|*
name|bases
operator|=
name|cp_parser_base_clause
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* Leave the scope given by the nested-name-specifier.  We will      enter the class scope itself while processing the members.  */
if|if
condition|(
name|pushed_scope
condition|)
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|invalid_explicit_specialization_p
condition|)
block|{
name|end_specialization
argument_list|()
expr_stmt|;
operator|--
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
block|}
operator|*
name|attributes_p
operator|=
name|attributes
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Parse a class-key.     class-key:      class      struct      union     Returns the kind of class-key specified, or none_type to indicate    error.  */
end_comment

begin_function
specifier|static
name|enum
name|tag_types
name|cp_parser_class_key
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|tag_types
name|tag_type
decl_stmt|;
comment|/* Look for the class-key.  */
name|token
operator|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|,
literal|"class-key"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
name|none_type
return|;
comment|/* Check to see if the TOKEN is a class-key.  */
name|tag_type
operator|=
name|cp_parser_token_is_class_key
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag_type
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected class-key"
argument_list|)
expr_stmt|;
return|return
name|tag_type
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) member-specification.     member-specification:      member-declaration member-specification [opt]      access-specifier : member-specification [opt]  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_member_specification_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|enum
name|rid
name|keyword
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's a `}', or EOF then we've seen all the members.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_EOF
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_PRAGMA_EOL
condition|)
break|break;
comment|/* See if this token is a keyword.  */
name|keyword
operator|=
name|token
operator|->
name|keyword
expr_stmt|;
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_PUBLIC
case|:
case|case
name|RID_PROTECTED
case|:
case|case
name|RID_PRIVATE
case|:
comment|/* Consume the access-specifier.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Remember which access-specifier is active.  */
name|current_access_specifier
operator|=
name|token
operator|->
name|u
operator|.
name|value
expr_stmt|;
comment|/* Look for the `:'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"`:'"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Accept #pragmas at class scope.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PRAGMA
condition|)
block|{
name|cp_parser_pragma
argument_list|(
name|parser
argument_list|,
name|pragma_external
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Otherwise, the next construction must be a 	     member-declaration.  */
name|cp_parser_member_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Parse a member-declaration.     member-declaration:      decl-specifier-seq [opt] member-declarator-list [opt] ;      function-definition ; [opt]      :: [opt] nested-name-specifier template [opt] unqualified-id ;      using-declaration      template-declaration     member-declarator-list:      member-declarator      member-declarator-list , member-declarator     member-declarator:      declarator pure-specifier [opt]      declarator constant-initializer [opt]      identifier [opt] : constant-expression     GNU Extensions:     member-declaration:      __extension__ member-declaration     member-declarator:      declarator attributes [opt] pure-specifier [opt]      declarator attributes [opt] constant-initializer [opt]      identifier [opt] attributes [opt] : constant-expression  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_member_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_decl_specifier_seq
name|decl_specifiers
decl_stmt|;
name|tree
name|prefix_attributes
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|declares_class_or_enum
decl_stmt|;
name|bool
name|friend_p
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|int
name|saved_pedantic
decl_stmt|;
comment|/* Check for the `__extension__' keyword.  */
if|if
condition|(
name|cp_parser_extension_opt
argument_list|(
name|parser
argument_list|,
operator|&
name|saved_pedantic
argument_list|)
condition|)
block|{
comment|/* Recurse.  */
name|cp_parser_member_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Restore the old value of the PEDANTIC flag.  */
name|pedantic
operator|=
name|saved_pedantic
expr_stmt|;
return|return;
block|}
comment|/* Check for a template-declaration.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TEMPLATE
argument_list|)
condition|)
block|{
comment|/* An explicit specialization here is an error condition, and we 	 expect the specialization handler to detect and report this.  */
if|if
condition|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|==
name|CPP_LESS
operator|&&
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|3
argument_list|)
operator|->
name|type
operator|==
name|CPP_GREATER
condition|)
name|cp_parser_explicit_specialization
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|cp_parser_template_declaration
argument_list|(
name|parser
argument_list|,
comment|/*member_p=*/
name|true
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for a using-declaration.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_USING
argument_list|)
condition|)
block|{
comment|/* Parse the using-declaration.  */
name|cp_parser_using_declaration
argument_list|(
name|parser
argument_list|,
comment|/*access_declaration_p=*/
name|false
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for @defs.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_AT_DEFS
argument_list|)
condition|)
block|{
name|tree
name|ivar
decl_stmt|,
name|member
decl_stmt|;
name|tree
name|ivar_chains
init|=
name|cp_parser_objc_defs_expression
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|ivar
operator|=
name|ivar_chains
expr_stmt|;
while|while
condition|(
name|ivar
condition|)
block|{
name|member
operator|=
name|ivar
expr_stmt|;
name|ivar
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|finish_member_declaration
argument_list|(
name|member
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|cp_parser_using_declaration
argument_list|(
name|parser
argument_list|,
comment|/*access_declaration=*/
name|true
argument_list|)
condition|)
return|return;
comment|/* Parse the decl-specifier-seq.  */
name|cp_parser_decl_specifier_seq
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_FLAGS_OPTIONAL
argument_list|,
operator|&
name|decl_specifiers
argument_list|,
operator|&
name|declares_class_or_enum
argument_list|)
expr_stmt|;
name|prefix_attributes
operator|=
name|decl_specifiers
operator|.
name|attributes
expr_stmt|;
name|decl_specifiers
operator|.
name|attributes
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Check for an invalid type-name.  */
if|if
condition|(
operator|!
name|decl_specifiers
operator|.
name|type
operator|&&
name|cp_parser_parse_and_diagnose_invalid_type_name
argument_list|(
name|parser
argument_list|)
condition|)
return|return;
comment|/* If there is no declarator, then the decl-specifier-seq should      specify a type.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
comment|/* If there was no decl-specifier-seq, and the next token is a 	 `;', then we have something like:  	   struct S { ; };  	 [class.mem]  	 Each member-declaration shall declare at least one member 	 name of the class.  */
if|if
condition|(
operator|!
name|decl_specifiers
operator|.
name|any_specifiers_p
condition|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|token
operator|->
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"%Hextra %<;%>"
argument_list|,
operator|&
name|token
operator|->
name|location
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|type
decl_stmt|;
comment|/* See if this declaration is a friend.  */
name|friend_p
operator|=
name|cp_parser_friend_p
argument_list|(
operator|&
name|decl_specifiers
argument_list|)
expr_stmt|;
comment|/* If there were decl-specifiers, check to see if there was 	     a class-declaration.  */
name|type
operator|=
name|check_tag_decl
argument_list|(
operator|&
name|decl_specifiers
argument_list|)
expr_stmt|;
comment|/* Nested classes have already been added to the class, but 	     a `friend' needs to be explicitly registered.  */
if|if
condition|(
name|friend_p
condition|)
block|{
comment|/* If the `friend' keyword was present, the friend must 		 be introduced with a class-key.  */
if|if
condition|(
operator|!
name|declares_class_or_enum
condition|)
name|error
argument_list|(
literal|"a class-key must be used when declaring a friend"
argument_list|)
expr_stmt|;
comment|/* In this case:  		    template<typename T> struct A { 		      friend struct A<T>::B; 		    };  		  A<T>::B will be represented by a TYPENAME_TYPE, and 		  therefore not recognized by check_tag_decl.  */
if|if
condition|(
operator|!
name|type
operator|&&
name|decl_specifiers
operator|.
name|type
operator|&&
name|TYPE_P
argument_list|(
name|decl_specifiers
operator|.
name|type
argument_list|)
condition|)
name|type
operator|=
name|decl_specifiers
operator|.
name|type
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"friend declaration does not name a class or "
literal|"function"
argument_list|)
expr_stmt|;
else|else
name|make_friend_class
argument_list|(
name|current_class_type
argument_list|,
name|type
argument_list|,
comment|/*complain=*/
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* If there is no TYPE, an error message will already have 	     been issued.  */
elseif|else
if|if
condition|(
operator|!
name|type
operator|||
name|type
operator|==
name|error_mark_node
condition|)
empty_stmt|;
comment|/* An anonymous aggregate has to be handled specially; such 	     a declaration really declares a data member (with a 	     particular type), as opposed to a nested class.  */
elseif|else
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Remove constructors and such from TYPE, now that we 		 know it is an anonymous aggregate.  */
name|fixup_anonymous_aggr
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* And make the corresponding data member.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Add it to the class.  */
name|finish_member_declaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|cp_parser_check_access_in_redeclaration
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* See if these declarations will be friends.  */
name|friend_p
operator|=
name|cp_parser_friend_p
argument_list|(
operator|&
name|decl_specifiers
argument_list|)
expr_stmt|;
comment|/* Keep going until we hit the `;' at the end of the 	 declaration.  */
while|while
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|tree
name|attributes
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|first_attribute
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Check for a bitfield declaration.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COLON
operator|||
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
operator|&&
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|==
name|CPP_COLON
operator|)
condition|)
block|{
name|tree
name|identifier
decl_stmt|;
name|tree
name|width
decl_stmt|;
comment|/* Get the name of the bitfield.  Note that we cannot just 		 check TOKEN here because it may have been invalidated by 		 the call to cp_lexer_peek_nth_token above.  */
if|if
condition|(
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|type
operator|!=
name|CPP_COLON
condition|)
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
name|identifier
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Consume the `:' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Get the width of the bitfield.  */
name|width
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant=*/
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Look for attributes that apply to the bitfield.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Remember which attributes are prefix attributes and 		 which are not.  */
name|first_attribute
operator|=
name|attributes
expr_stmt|;
comment|/* Combine the attributes.  */
name|attributes
operator|=
name|chainon
argument_list|(
name|prefix_attributes
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
comment|/* Create the bitfield declaration.  */
name|decl
operator|=
name|grokbitfield
argument_list|(
name|identifier
condition|?
name|make_id_declarator
argument_list|(
name|NULL_TREE
argument_list|,
name|identifier
argument_list|,
name|sfk_none
argument_list|)
else|:
name|NULL
argument_list|,
operator|&
name|decl_specifiers
argument_list|,
name|width
argument_list|)
expr_stmt|;
comment|/* Apply the attributes.  */
name|cplus_decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attributes
argument_list|,
comment|/*flags=*/
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
name|tree
name|initializer
decl_stmt|;
name|tree
name|asm_specification
decl_stmt|;
name|int
name|ctor_dtor_or_conv_p
decl_stmt|;
comment|/* Parse the declarator.  */
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_NAMED
argument_list|,
operator|&
name|ctor_dtor_or_conv_p
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|,
comment|/*member_p=*/
name|true
argument_list|)
expr_stmt|;
comment|/* If something went wrong parsing the declarator, make sure 		 that we at least consume some tokens.  */
if|if
condition|(
name|declarator
operator|==
name|cp_error_declarator
condition|)
block|{
comment|/* Skip to the end of the statement.  */
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If the next token is not a semicolon, that is 		     probably because we just skipped over the body of 		     a function.  So, we consume a semicolon if 		     present, but do not issue an error message if it 		     is not present.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|declares_class_or_enum
operator|&
literal|2
condition|)
name|cp_parser_check_for_definition_in_return_type
argument_list|(
name|declarator
argument_list|,
name|decl_specifiers
operator|.
name|type
argument_list|)
expr_stmt|;
comment|/* Look for an asm-specification.  */
name|asm_specification
operator|=
name|cp_parser_asm_specification_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for attributes that apply to the declaration.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Remember which attributes are prefix attributes and 		 which are not.  */
name|first_attribute
operator|=
name|attributes
expr_stmt|;
comment|/* Combine the attributes.  */
name|attributes
operator|=
name|chainon
argument_list|(
name|prefix_attributes
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
comment|/* If it's an `=', then we have a constant-initializer or a 		 pure-specifier.  It is not correct to parse the 		 initializer before registering the member declaration 		 since the member declaration should be in scope while 		 its initializer is processed.  However, the rest of the 		 front end does not yet provide an interface that allows 		 us to handle this correctly.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EQ
argument_list|)
condition|)
block|{
comment|/* In [class.mem]:  		     A pure-specifier shall be used only in the declaration of 		     a virtual function.  		     A member-declarator can contain a constant-initializer 		     only if it declares a static member of integral or 		     enumeration type.  		     Therefore, if the DECLARATOR is for a function, we look 		     for a pure-specifier; otherwise, we look for a 		     constant-initializer.  When we call `grokfield', it will 		     perform more stringent semantics checks.  */
if|if
condition|(
name|function_declarator_p
argument_list|(
name|declarator
argument_list|)
condition|)
name|initializer
operator|=
name|cp_parser_pure_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
comment|/* Parse the initializer.  */
name|initializer
operator|=
name|cp_parser_constant_initializer
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, there is no initializer.  */
else|else
name|initializer
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* See if we are probably looking at a function 		 definition.  We are certainly not looking at a 		 member-declarator.  Calling `grokfield' has 		 side-effects, so we must not do it unless we are sure 		 that we are looking at a member-declarator.  */
if|if
condition|(
name|cp_parser_token_starts_function_definition_p
argument_list|(
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The grammar does not allow a pure-specifier to be 		     used when a member function is defined.  (It is 		     possible that this fact is an oversight in the 		     standard, since a pure function may be defined 		     outside of the class-specifier.  */
if|if
condition|(
name|initializer
condition|)
name|error
argument_list|(
literal|"pure-specifier on function-definition"
argument_list|)
expr_stmt|;
name|decl
operator|=
name|cp_parser_save_member_function_body
argument_list|(
name|parser
argument_list|,
operator|&
name|decl_specifiers
argument_list|,
name|declarator
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
comment|/* If the member was not a friend, declare it here.  */
if|if
condition|(
operator|!
name|friend_p
condition|)
name|finish_member_declaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token is a semicolon, consume it.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_SEMICOLON
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
comment|/* Create the declaration.  */
name|decl
operator|=
name|grokfield
argument_list|(
name|declarator
argument_list|,
operator|&
name|decl_specifiers
argument_list|,
name|initializer
argument_list|,
comment|/*init_const_expr_p=*/
name|true
argument_list|,
name|asm_specification
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
block|}
comment|/* Reset PREFIX_ATTRIBUTES.  */
while|while
condition|(
name|attributes
operator|&&
name|TREE_CHAIN
argument_list|(
name|attributes
argument_list|)
operator|!=
name|first_attribute
condition|)
name|attributes
operator|=
name|TREE_CHAIN
argument_list|(
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|attributes
condition|)
name|TREE_CHAIN
argument_list|(
name|attributes
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If there is any qualification still in effect, clear it 	     now; we will be starting fresh with the next declarator.  */
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If it's a `,', then there are more declarators.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token isn't a `;', then we have a parse error.  */
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<;%>"
argument_list|)
expr_stmt|;
comment|/* Skip tokens until we find a `;'.  */
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|decl
condition|)
block|{
comment|/* Add DECL to the list of members.  */
if|if
condition|(
operator|!
name|friend_p
condition|)
name|finish_member_declaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|cp_parser_save_default_args
argument_list|(
name|parser
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a pure-specifier.     pure-specifier:      = 0     Returns INTEGER_ZERO_NODE if a pure specifier is found.    Otherwise, ERROR_MARK_NODE is returned.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_pure_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Look for the `=' token.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_EQ
argument_list|,
literal|"`='"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Look for the `0' token.  */
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* c_lex_with_flags marks a single digit '0' with PURE_ZERO.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NUMBER
operator|||
operator|!
operator|(
name|token
operator|->
name|flags
operator|&
name|PURE_ZERO
operator|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"invalid pure specifier (only `= 0' is allowed)"
argument_list|)
expr_stmt|;
name|cp_parser_skip_to_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"templates may not be %<virtual%>"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|integer_zero_node
return|;
block|}
end_function

begin_comment
comment|/* Parse a constant-initializer.     constant-initializer:      = constant-expression     Returns a representation of the constant-expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_constant_initializer
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Look for the `=' token.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_EQ
argument_list|,
literal|"`='"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* It is invalid to write:         struct S { static const int i = { 7 }; };       */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"a brace-enclosed initializer is not allowed here"
argument_list|)
expr_stmt|;
comment|/* Consume the opening brace.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Skip the initializer.  */
name|cp_parser_skip_to_closing_brace
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the trailing `}'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant=*/
name|false
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Derived classes [gram.class.derived] */
end_comment

begin_comment
comment|/* Parse a base-clause.     base-clause:      : base-specifier-list     base-specifier-list:      base-specifier      base-specifier-list , base-specifier     Returns a TREE_LIST representing the base-classes, in the order in    which they were declared.  The representation of each node is as    described by cp_parser_base_specifier.     In the case that no bases are specified, this function will return    NULL_TREE, not ERROR_MARK_NODE.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_base_clause
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|bases
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Look for the `:' that begins the list.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"`:'"
argument_list|)
expr_stmt|;
comment|/* Scan the base-specifier-list.  */
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|base
decl_stmt|;
comment|/* Look for the base-specifier.  */
name|base
operator|=
name|cp_parser_base_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Add BASE to the front of the list.  */
if|if
condition|(
name|base
operator|!=
name|error_mark_node
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|base
argument_list|)
operator|=
name|bases
expr_stmt|;
name|bases
operator|=
name|base
expr_stmt|;
block|}
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's not a comma, then the list is complete.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_COMMA
condition|)
break|break;
comment|/* Consume the `,'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* PARSER->SCOPE may still be non-NULL at this point, if the last      base class had a qualified name.  However, the next name that      appears is certainly not qualified.  */
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|nreverse
argument_list|(
name|bases
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a base-specifier.     base-specifier:      :: [opt] nested-name-specifier [opt] class-name      virtual access-specifier [opt] :: [opt] nested-name-specifier        [opt] class-name      access-specifier virtual [opt] :: [opt] nested-name-specifier        [opt] class-name     Returns a TREE_LIST.  The TREE_PURPOSE will be one of    ACCESS_{DEFAULT,PUBLIC,PROTECTED,PRIVATE}_[VIRTUAL]_NODE to    indicate the specifiers provided.  The TREE_VALUE will be a TYPE    (or the ERROR_MARK_NODE) indicating the type that was specified.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_base_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|bool
name|done
init|=
name|false
decl_stmt|;
name|bool
name|virtual_p
init|=
name|false
decl_stmt|;
name|bool
name|duplicate_virtual_error_issued_p
init|=
name|false
decl_stmt|;
name|bool
name|duplicate_access_error_issued_p
init|=
name|false
decl_stmt|;
name|bool
name|class_scope_p
decl_stmt|,
name|template_p
decl_stmt|;
name|tree
name|access
init|=
name|access_default_node
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* Process the optional `virtual' and `access-specifier'.  */
while|while
condition|(
operator|!
name|done
condition|)
block|{
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Process `virtual'.  */
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_VIRTUAL
case|:
comment|/* If `virtual' appears more than once, issue an error.  */
if|if
condition|(
name|virtual_p
operator|&&
operator|!
name|duplicate_virtual_error_issued_p
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"%<virtual%> specified more than once in base-specified"
argument_list|)
expr_stmt|;
name|duplicate_virtual_error_issued_p
operator|=
name|true
expr_stmt|;
block|}
name|virtual_p
operator|=
name|true
expr_stmt|;
comment|/* Consume the `virtual' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_PUBLIC
case|:
case|case
name|RID_PROTECTED
case|:
case|case
name|RID_PRIVATE
case|:
comment|/* If more than one access specifier appears, issue an 	     error.  */
if|if
condition|(
name|access
operator|!=
name|access_default_node
operator|&&
operator|!
name|duplicate_access_error_issued_p
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"more than one access specifier in base-specified"
argument_list|)
expr_stmt|;
name|duplicate_access_error_issued_p
operator|=
name|true
expr_stmt|;
block|}
name|access
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|token
operator|->
name|keyword
index|]
expr_stmt|;
comment|/* Consume the access-specifier.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
break|break;
default|default:
name|done
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|/* It is not uncommon to see programs mechanically, erroneously, use      the 'typename' keyword to denote (dependent) qualified types      as base classes.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TYPENAME
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|error
argument_list|(
literal|"keyword %<typename%> not allowed outside of templates"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"keyword %<typename%> not allowed in this context "
literal|"(the base class is implicitly a type)"
argument_list|)
expr_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* Look for the optional `::' operator.  */
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the nested-name-specifier.  The simplest way to      implement:         [temp.res]         The keyword `typename' is not permitted in a base-specifier or        mem-initializer; in these contexts a qualified name that        depends on a template-parameter is implicitly assumed to be a        type name.       is to pretend that we have seen the `typename' keyword at this      point.  */
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|true
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
name|typename_type
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
comment|/* If the base class is given by a qualified name, assume that names      we see are type names or templates, as appropriate.  */
name|class_scope_p
operator|=
operator|(
name|parser
operator|->
name|scope
operator|&&
name|TYPE_P
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|)
expr_stmt|;
name|template_p
operator|=
name|class_scope_p
operator|&&
name|cp_parser_optional_template_keyword
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Finally, look for the class-name.  */
name|type
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
name|class_scope_p
argument_list|,
name|template_p
argument_list|,
name|typename_type
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|finish_base_specifier
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|access
argument_list|,
name|virtual_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Exception handling [gram.exception] */
end_comment

begin_comment
comment|/* Parse an (optional) exception-specification.     exception-specification:      throw ( type-id-list [opt] )     Returns a TREE_LIST representing the exception-specification.  The    TREE_VALUE of each node is a type.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_exception_specification_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|type_id_list
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's not `throw', then there's no exception-specification.  */
if|if
condition|(
operator|!
name|cp_parser_is_keyword
argument_list|(
name|token
argument_list|,
name|RID_THROW
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Consume the `throw'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's not a `)', then there is a type-id-list.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_CLOSE_PAREN
condition|)
block|{
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
comment|/* Types may not be defined in an exception-specification.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in an exception-specification"
expr_stmt|;
comment|/* Parse the type-id-list.  */
name|type_id_list
operator|=
name|cp_parser_type_id_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Restore the saved message.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
block|}
else|else
name|type_id_list
operator|=
name|empty_except_spec
expr_stmt|;
comment|/* Look for the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
return|return
name|type_id_list
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) type-id-list.     type-id-list:      type-id      type-id-list , type-id     Returns a TREE_LIST.  The TREE_VALUE of each node is a TYPE,    in the order that the types were presented.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_type_id_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|types
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* Get the next type-id.  */
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Add it to the list.  */
name|types
operator|=
name|add_exception_specifier
argument_list|(
name|types
argument_list|,
name|type
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it is not a `,', we are done.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_COMMA
condition|)
break|break;
comment|/* Consume the `,'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
return|return
name|nreverse
argument_list|(
name|types
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a try-block.     try-block:      try compound-statement handler-seq  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_try_block
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|try_block
decl_stmt|;
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_TRY
argument_list|,
literal|"`try'"
argument_list|)
expr_stmt|;
name|try_block
operator|=
name|begin_try_block
argument_list|()
expr_stmt|;
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|finish_try_block
argument_list|(
name|try_block
argument_list|)
expr_stmt|;
name|cp_parser_handler_seq
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|finish_handler_sequence
argument_list|(
name|try_block
argument_list|)
expr_stmt|;
return|return
name|try_block
return|;
block|}
end_function

begin_comment
comment|/* Parse a function-try-block.     function-try-block:      try ctor-initializer [opt] function-body handler-seq  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_function_try_block
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|compound_stmt
decl_stmt|;
name|tree
name|try_block
decl_stmt|;
name|bool
name|ctor_initializer_p
decl_stmt|;
comment|/* Look for the `try' keyword.  */
if|if
condition|(
operator|!
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_TRY
argument_list|,
literal|"`try'"
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Let the rest of the front-end know where we are.  */
name|try_block
operator|=
name|begin_function_try_block
argument_list|(
operator|&
name|compound_stmt
argument_list|)
expr_stmt|;
comment|/* Parse the function-body.  */
name|ctor_initializer_p
operator|=
name|cp_parser_ctor_initializer_opt_and_function_body
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* We're done with the `try' part.  */
name|finish_function_try_block
argument_list|(
name|try_block
argument_list|)
expr_stmt|;
comment|/* Parse the handlers.  */
name|cp_parser_handler_seq
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* We're done with the handlers.  */
name|finish_function_handler_sequence
argument_list|(
name|try_block
argument_list|,
name|compound_stmt
argument_list|)
expr_stmt|;
return|return
name|ctor_initializer_p
return|;
block|}
end_function

begin_comment
comment|/* Parse a handler-seq.     handler-seq:      handler handler-seq [opt]  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_handler_seq
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Parse the handler.  */
name|cp_parser_handler
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's not `catch' then there are no more handlers.  */
if|if
condition|(
operator|!
name|cp_parser_is_keyword
argument_list|(
name|token
argument_list|,
name|RID_CATCH
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Parse a handler.     handler:      catch ( exception-declaration ) compound-statement  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_handler
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|handler
decl_stmt|;
name|tree
name|declaration
decl_stmt|;
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_CATCH
argument_list|,
literal|"`catch'"
argument_list|)
expr_stmt|;
name|handler
operator|=
name|begin_handler
argument_list|()
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
name|declaration
operator|=
name|cp_parser_exception_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|finish_handler_parms
argument_list|(
name|declaration
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|finish_handler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an exception-declaration.     exception-declaration:      type-specifier-seq declarator      type-specifier-seq abstract-declarator      type-specifier-seq      ...     Returns a VAR_DECL for the declaration, or NULL_TREE if the    ellipsis variant is used.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_exception_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_decl_specifier_seq
name|type_specifiers
decl_stmt|;
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
comment|/* If it's an ellipsis, it's easy to handle.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_ELLIPSIS
argument_list|)
condition|)
block|{
comment|/* Consume the `...' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Types may not be defined in exception-declarations.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
literal|"types may not be defined in exception-declarations"
expr_stmt|;
comment|/* Parse the type-specifier-seq.  */
name|cp_parser_type_specifier_seq
argument_list|(
name|parser
argument_list|,
comment|/*is_condition=*/
name|false
argument_list|,
operator|&
name|type_specifiers
argument_list|)
expr_stmt|;
comment|/* If it's a `)', then there is no declarator.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|declarator
operator|=
name|NULL
expr_stmt|;
else|else
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_EITHER
argument_list|,
comment|/*ctor_dtor_or_conv_p=*/
name|NULL
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|,
comment|/*member_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Restore the saved message.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
if|if
condition|(
operator|!
name|type_specifiers
operator|.
name|any_specifiers_p
condition|)
return|return
name|error_mark_node
return|;
return|return
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
operator|&
name|type_specifiers
argument_list|,
name|CATCHPARM
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a throw-expression.     throw-expression:      throw assignment-expression [opt]     Returns a THROW_EXPR representing the throw-expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_throw_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|expression
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_THROW
argument_list|,
literal|"`throw'"
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Figure out whether or not there is an assignment-expression      following the "throw" keyword.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_SEMICOLON
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_SQUARE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_COLON
condition|)
name|expression
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|expression
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
return|return
name|build_throw
argument_list|(
name|expression
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* GNU Extensions */
end_comment

begin_comment
comment|/* Parse an (optional) asm-specification.     asm-specification:      asm ( string-literal )     If the asm-specification is present, returns a STRING_CST    corresponding to the string-literal.  Otherwise, returns    NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_asm_specification_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|asm_specification
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If the next token isn't the `asm' keyword, then there's no      asm-specification.  */
if|if
condition|(
operator|!
name|cp_parser_is_keyword
argument_list|(
name|token
argument_list|,
name|RID_ASM
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Consume the `asm' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Look for the string-literal.  */
name|asm_specification
operator|=
name|cp_parser_string_literal
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
return|return
name|asm_specification
return|;
block|}
end_function

begin_comment
comment|/* Parse an asm-operand-list.     asm-operand-list:      asm-operand      asm-operand-list , asm-operand     asm-operand:      string-literal ( expression )      [ string-literal ] string-literal ( expression )     Returns a TREE_LIST representing the operands.  The TREE_VALUE of    each node is the expression.  The TREE_PURPOSE is itself a    TREE_LIST whose TREE_PURPOSE is a STRING_CST for the bracketed    string-literal (or NULL_TREE if not present) and whose TREE_VALUE    is a STRING_CST for the string literal before the parenthesis.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_asm_operand_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|asm_operands
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|string_literal
decl_stmt|;
name|tree
name|expression
decl_stmt|;
name|tree
name|name
decl_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|)
condition|)
block|{
comment|/* Consume the `[' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Read the operand name.  */
name|name
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|error_mark_node
condition|)
name|name
operator|=
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Look for the closing `]'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"`]'"
argument_list|)
expr_stmt|;
block|}
else|else
name|name
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Look for the string-literal.  */
name|string_literal
operator|=
name|cp_parser_string_literal
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the `('.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Parse the expression.  */
name|expression
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Add this operand to the list.  */
name|asm_operands
operator|=
name|tree_cons
argument_list|(
name|build_tree_list
argument_list|(
name|name
argument_list|,
name|string_literal
argument_list|)
argument_list|,
name|expression
argument_list|,
name|asm_operands
argument_list|)
expr_stmt|;
comment|/* If the next token is not a `,', there are no more 	 operands.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
comment|/* Consume the `,'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
return|return
name|nreverse
argument_list|(
name|asm_operands
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an asm-clobber-list.     asm-clobber-list:      string-literal      asm-clobber-list , string-literal     Returns a TREE_LIST, indicating the clobbers in the order that they    appeared.  The TREE_VALUE of each node is a STRING_CST.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_asm_clobber_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|clobbers
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|string_literal
decl_stmt|;
comment|/* Look for the string literal.  */
name|string_literal
operator|=
name|cp_parser_string_literal
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Add it to the list.  */
name|clobbers
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|string_literal
argument_list|,
name|clobbers
argument_list|)
expr_stmt|;
comment|/* If the next token is not a `,', then the list is 	 complete.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
comment|/* Consume the `,' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
return|return
name|clobbers
return|;
block|}
end_function

begin_comment
comment|/* Parse an (optional) series of attributes.     attributes:      attributes attribute     attribute:      __attribute__ (( attribute-list [opt] ))     The return value is as for cp_parser_attribute_list.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_attributes_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|attributes
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|attribute_list
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's not `__attribute__', then we're done.  */
if|if
condition|(
name|token
operator|->
name|keyword
operator|!=
name|RID_ATTRIBUTE
condition|)
break|break;
comment|/* Consume the `__attribute__' keyword.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the two `(' tokens.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_CLOSE_PAREN
condition|)
comment|/* Parse the attribute-list.  */
name|attribute_list
operator|=
name|cp_parser_attribute_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
comment|/* If the next token is a `)', then there is no attribute 	   list.  */
name|attribute_list
operator|=
name|NULL
expr_stmt|;
comment|/* Look for the two `)' tokens.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* Add these new attributes to the list.  */
name|attributes
operator|=
name|chainon
argument_list|(
name|attributes
argument_list|,
name|attribute_list
argument_list|)
expr_stmt|;
block|}
return|return
name|attributes
return|;
block|}
end_function

begin_comment
comment|/* Parse an attribute-list.     attribute-list:      attribute      attribute-list , attribute     attribute:      identifier      identifier ( identifier )      identifier ( identifier , expression-list )      identifier ( expression-list )     Returns a TREE_LIST, or NULL_TREE on error.  Each node corresponds    to an attribute.  The TREE_PURPOSE of each node is the identifier    indicating which attribute is in use.  The TREE_VALUE represents    the arguments, if any.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_attribute_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|attribute_list
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|save_translate_strings_p
init|=
name|parser
operator|->
name|translate_strings_p
decl_stmt|;
name|parser
operator|->
name|translate_strings_p
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|tree
name|attribute
decl_stmt|;
comment|/* Look for the identifier.  We also allow keywords here; for 	 example `__attribute__ ((const))' is legal.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_KEYWORD
condition|)
block|{
name|tree
name|arguments
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Consume the token.  */
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Save away the identifier that indicates which attribute 	     this is.  */
name|identifier
operator|=
name|token
operator|->
name|u
operator|.
name|value
expr_stmt|;
name|attribute
operator|=
name|build_tree_list
argument_list|(
name|identifier
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If it's an `(', then parse the attribute arguments.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
block|{
name|arguments
operator|=
name|cp_parser_parenthesized_expression_list
argument_list|(
name|parser
argument_list|,
name|true
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|,
comment|/*non_constant_p=*/
name|NULL
argument_list|)
expr_stmt|;
comment|/* Save the arguments away.  */
name|TREE_VALUE
argument_list|(
name|attribute
argument_list|)
operator|=
name|arguments
expr_stmt|;
block|}
if|if
condition|(
name|arguments
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Add this attribute to the list.  */
name|TREE_CHAIN
argument_list|(
name|attribute
argument_list|)
operator|=
name|attribute_list
expr_stmt|;
name|attribute_list
operator|=
name|attribute
expr_stmt|;
block|}
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* Now, look for more attributes.  If the next token isn't a 	 `,', we're done.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_COMMA
condition|)
break|break;
comment|/* Consume the comma and keep going.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
name|parser
operator|->
name|translate_strings_p
operator|=
name|save_translate_strings_p
expr_stmt|;
comment|/* We built up the list in reverse order.  */
return|return
name|nreverse
argument_list|(
name|attribute_list
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an optional `__extension__' keyword.  Returns TRUE if it is    present, and FALSE otherwise.  *SAVED_PEDANTIC is set to the    current value of the PEDANTIC flag, regardless of whether or not    the `__extension__' keyword is present.  The caller is responsible    for restoring the value of the PEDANTIC flag.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_extension_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|int
modifier|*
name|saved_pedantic
parameter_list|)
block|{
comment|/* Save the old value of the PEDANTIC flag.  */
operator|*
name|saved_pedantic
operator|=
name|pedantic
expr_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_EXTENSION
argument_list|)
condition|)
block|{
comment|/* Consume the `__extension__' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* We're not being pedantic while the `__extension__' keyword is 	 in effect.  */
name|pedantic
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Parse a label declaration.     label-declaration:      __label__ label-declarator-seq ;     label-declarator-seq:      identifier , label-declarator-seq      identifier  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_label_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Look for the `__label__' keyword.  */
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_LABEL
argument_list|,
literal|"`__label__'"
argument_list|)
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|identifier
decl_stmt|;
comment|/* Look for an identifier.  */
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If we failed, stop.  */
if|if
condition|(
name|identifier
operator|==
name|error_mark_node
condition|)
break|break;
comment|/* Declare it as a label.  */
name|finish_label_decl
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
comment|/* If the next token is a `;', stop.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
break|break;
comment|/* Look for the `,' separating the label declarations.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|,
literal|"`,'"
argument_list|)
expr_stmt|;
block|}
comment|/* Look for the final `;'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Support Functions */
end_comment

begin_comment
comment|/* Looks up NAME in the current scope, as given by PARSER->SCOPE.    NAME should have one of the representations used for an    id-expression.  If NAME is the ERROR_MARK_NODE, the ERROR_MARK_NODE    is returned.  If PARSER->SCOPE is a dependent type, then a    SCOPE_REF is returned.     If NAME is a TEMPLATE_ID_EXPR, then it will be immediately    returned; the name was already resolved when the TEMPLATE_ID_EXPR    was formed.  Abstractly, such entities should not be passed to this    function, because they do not need to be looked up, but it is    simpler to check for this special case here, rather than at the    call-sites.     In cases not explicitly covered above, this function returns a    DECL, OVERLOAD, or baselink representing the result of the lookup.    If there was no entity with the indicated NAME, the ERROR_MARK_NODE    is returned.     If TAG_TYPE is not NONE_TYPE, it indicates an explicit type keyword    (e.g., "struct") that was used.  In that case bindings that do not    refer to types are ignored.     If IS_TEMPLATE is TRUE, bindings that do not refer to templates are    ignored.     If IS_NAMESPACE is TRUE, bindings that do not refer to namespaces    are ignored.     If CHECK_DEPENDENCY is TRUE, names are not looked up in dependent    types.     If AMBIGUOUS_DECLS is non-NULL, *AMBIGUOUS_DECLS is set to a    TREE_LIST of candidates if name-lookup results in an ambiguity, and    NULL_TREE otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_lookup_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|name
parameter_list|,
name|enum
name|tag_types
name|tag_type
parameter_list|,
name|bool
name|is_template
parameter_list|,
name|bool
name|is_namespace
parameter_list|,
name|bool
name|check_dependency
parameter_list|,
name|tree
modifier|*
name|ambiguous_decls
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|object_type
init|=
name|parser
operator|->
name|context
operator|->
name|object_type
decl_stmt|;
if|if
condition|(
operator|!
name|cp_parser_uncommitted_to_tentative_parse_p
argument_list|(
name|parser
argument_list|)
condition|)
name|flags
operator||=
name|LOOKUP_COMPLAIN
expr_stmt|;
comment|/* Assume that the lookup will be unambiguous.  */
if|if
condition|(
name|ambiguous_decls
condition|)
operator|*
name|ambiguous_decls
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now that we have looked up the name, the OBJECT_TYPE (if any) is      no longer valid.  Note that if we are parsing tentatively, and      the parse fails, OBJECT_TYPE will be automatically restored.  */
name|parser
operator|->
name|context
operator|->
name|object_type
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* A template-id has already been resolved; there is no lookup to      do.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
return|return
name|name
return|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|BASELINK_FUNCTIONS
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
comment|/* A BIT_NOT_EXPR is used to represent a destructor.  By this point,      it should already have been checked to make sure that the name      used matches the type being destroyed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|tree
name|type
decl_stmt|;
comment|/* Figure out to which type this destructor applies.  */
if|if
condition|(
name|parser
operator|->
name|scope
condition|)
name|type
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
elseif|else
if|if
condition|(
name|object_type
condition|)
name|type
operator|=
name|object_type
expr_stmt|;
else|else
name|type
operator|=
name|current_class_type
expr_stmt|;
comment|/* If that's not a class type, there is no destructor.  */
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|CLASSTYPE_LAZY_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|lazily_declare_fn
argument_list|(
name|sfk_destructor
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLASSTYPE_DESTRUCTORS
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* If it was a class type, return the destructor.  */
return|return
name|CLASSTYPE_DESTRUCTORS
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/* By this point, the NAME should be an ordinary identifier.  If      the id-expression was a qualified name, the qualifying scope is      stored in PARSER->SCOPE at this point.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
comment|/* Perform the lookup.  */
if|if
condition|(
name|parser
operator|->
name|scope
condition|)
block|{
name|bool
name|dependent_p
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|scope
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* If the SCOPE is dependent, the lookup must be deferred until 	 the template is instantiated -- unless we are explicitly 	 looking up names in uninstantiated templates.  Even then, we 	 cannot look up the name if the scope is not a class type; it 	 might, for example, be a template type parameter.  */
name|dependent_p
operator|=
operator|(
name|TYPE_P
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|&&
operator|!
operator|(
name|parser
operator|->
name|in_declarator_p
operator|&&
name|currently_open_class
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|)
operator|&&
name|dependent_type_p
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|check_dependency
operator|||
operator|!
name|CLASS_TYPE_P
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
operator|)
operator|&&
name|dependent_p
condition|)
block|{
if|if
condition|(
name|tag_type
condition|)
block|{
name|tree
name|type
decl_stmt|;
comment|/* The resolution to Core Issue 180 says that `struct 		 A::B' should be considered a type-name, even if `A' 		 is dependent.  */
name|type
operator|=
name|make_typename_type
argument_list|(
name|parser
operator|->
name|scope
argument_list|,
name|name
argument_list|,
name|tag_type
argument_list|,
comment|/*complain=*/
name|tf_error
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_template
operator|&&
operator|(
name|cp_parser_next_token_ends_template_argument_p
argument_list|(
name|parser
argument_list|)
operator|||
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
operator|)
condition|)
name|decl
operator|=
name|make_unbound_class_template
argument_list|(
name|parser
operator|->
name|scope
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*complain=*/
name|tf_error
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|build_qualified_name
argument_list|(
comment|/*type=*/
name|NULL_TREE
argument_list|,
name|parser
operator|->
name|scope
argument_list|,
name|name
argument_list|,
name|is_template
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|pushed_scope
init|=
name|NULL_TREE
decl_stmt|;
comment|/* If PARSER->SCOPE is a dependent type, then it must be a 	     class type, and we must not be checking dependencies; 	     otherwise, we would have processed this lookup above.  So 	     that PARSER->SCOPE is not considered a dependent base by 	     lookup_member, we must enter the scope here.  */
if|if
condition|(
name|dependent_p
condition|)
name|pushed_scope
operator|=
name|push_scope
argument_list|(
name|parser
operator|->
name|scope
argument_list|)
expr_stmt|;
comment|/* If the PARSER->SCOPE is a template specialization, it 	     may be instantiated during name lookup.  In that case, 	     errors may be issued.  Even if we rollback the current 	     tentative parse, those errors are valid.  */
name|decl
operator|=
name|lookup_qualified_name
argument_list|(
name|parser
operator|->
name|scope
argument_list|,
name|name
argument_list|,
name|tag_type
operator|!=
name|none_type
argument_list|,
comment|/*complain=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|pushed_scope
condition|)
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
block|}
name|parser
operator|->
name|qualifying_scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|object_type
condition|)
block|{
name|tree
name|object_decl
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Look up the name in the scope of the OBJECT_TYPE, unless the 	 OBJECT_TYPE is not a class.  */
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|object_type
argument_list|)
condition|)
comment|/* If the OBJECT_TYPE is a template specialization, it may 	   be instantiated during name lookup.  In that case, errors 	   may be issued.  Even if we rollback the current tentative 	   parse, those errors are valid.  */
name|object_decl
operator|=
name|lookup_member
argument_list|(
name|object_type
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|0
argument_list|,
name|tag_type
operator|!=
name|none_type
argument_list|)
expr_stmt|;
comment|/* Look it up in the enclosing context, too.  */
name|decl
operator|=
name|lookup_name_real
argument_list|(
name|name
argument_list|,
name|tag_type
operator|!=
name|none_type
argument_list|,
comment|/*nonclass=*/
literal|0
argument_list|,
comment|/*block_p=*/
name|true
argument_list|,
name|is_namespace
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|object_type
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|object_decl
condition|)
name|decl
operator|=
name|object_decl
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|lookup_name_real
argument_list|(
name|name
argument_list|,
name|tag_type
operator|!=
name|none_type
argument_list|,
comment|/*nonclass=*/
literal|0
argument_list|,
comment|/*block_p=*/
name|true
argument_list|,
name|is_namespace
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* If the lookup failed, let our caller know.  */
if|if
condition|(
operator|!
name|decl
operator|||
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* If it's a TREE_LIST, the result of the lookup was ambiguous.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|ambiguous_decls
condition|)
operator|*
name|ambiguous_decls
operator|=
name|decl
expr_stmt|;
comment|/* The error message we have to print is too complicated for 	 cp_parser_error, so we incorporate its actions directly.  */
if|if
condition|(
operator|!
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"reference to %qD is ambiguous"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SCOPE_REF
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|UNBOUND_CLASS_TEMPLATE
operator|||
name|BASELINK_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have resolved the name of a member declaration, check to      see if the declaration is accessible.  When the name resolves to      set of overloaded functions, accessibility is checked when      overload resolution is done.       During an explicit instantiation, access is not checked at all,      as per [temp.explicit].  */
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|check_accessibility_of_qualified_id
argument_list|(
name|decl
argument_list|,
name|object_type
argument_list|,
name|parser
operator|->
name|scope
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Like cp_parser_lookup_name, but for use in the typical case where    CHECK_ACCESS is TRUE, IS_TYPE is FALSE, IS_TEMPLATE is FALSE,    IS_NAMESPACE is FALSE, and CHECK_DEPENDENCY is TRUE.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_lookup_name_simple
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
return|return
name|cp_parser_lookup_name
argument_list|(
name|parser
argument_list|,
name|name
argument_list|,
name|none_type
argument_list|,
comment|/*is_template=*/
name|false
argument_list|,
comment|/*is_namespace=*/
name|false
argument_list|,
comment|/*check_dependency=*/
name|true
argument_list|,
comment|/*ambiguous_decls=*/
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If DECL is a TEMPLATE_DECL that can be treated like a TYPE_DECL in    the current context, return the TYPE_DECL.  If TAG_NAME_P is    true, the DECL indicates the class being defined in a class-head,    or declared in an elaborated-type-specifier.     Otherwise, return DECL.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_maybe_treat_template_as_class
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
name|tag_name_p
parameter_list|)
block|{
comment|/* If the TEMPLATE_DECL is being declared as part of a class-head,      the translation from TEMPLATE_DECL to TYPE_DECL occurs:         struct A { 	 template<typename T> struct B;        };         template<typename T> struct A::B {};       Similarly, in an elaborated-type-specifier:         namespace N { struct X{}; }         struct A { 	 template<typename T> friend struct N::X;        };       However, if the DECL refers to a class type, and we are in      the scope of the class, then the name lookup automatically      finds the TYPE_DECL created by build_self_reference rather      than a TEMPLATE_DECL.  For example, in:         template<class T> struct S { 	 S s;        };       there is no need to handle such case.  */
if|if
condition|(
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|tag_name_p
condition|)
return|return
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
return|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* If too many, or too few, template-parameter lists apply to the    declarator, issue an error message.  Returns TRUE if all went well,    and FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_check_declarator_template_parameters
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_declarator
modifier|*
name|declarator
parameter_list|)
block|{
name|unsigned
name|num_templates
decl_stmt|;
comment|/* We haven't seen any classes that involve template parameters yet.  */
name|num_templates
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|declarator
operator|->
name|kind
condition|)
block|{
case|case
name|cdk_id
case|:
if|if
condition|(
name|declarator
operator|->
name|u
operator|.
name|id
operator|.
name|qualifying_scope
condition|)
block|{
name|tree
name|scope
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|scope
operator|=
name|declarator
operator|->
name|u
operator|.
name|id
operator|.
name|qualifying_scope
expr_stmt|;
name|member
operator|=
name|declarator
operator|->
name|u
operator|.
name|id
operator|.
name|unqualified_name
expr_stmt|;
while|while
condition|(
name|scope
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
comment|/* You're supposed to have one `template<...>' 		 for every template class, but you don't need one 		 for a full specialization.  For example:  		 template<class T> struct S{}; 		 template<> struct S<int> { void f(); }; 		 void S<int>::f () {}  		 is correct; there shouldn't be a `template<>' for 		 the definition of `S<int>::f'.  */
if|if
condition|(
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|scope
argument_list|)
condition|)
comment|/* If SCOPE does not have template information of any 		   kind, then it is not a template, nor is it nested 		   within a template.  */
break|break;
if|if
condition|(
name|explicit_class_specialization_p
argument_list|(
name|scope
argument_list|)
condition|)
break|break;
if|if
condition|(
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|scope
argument_list|)
argument_list|)
condition|)
operator|++
name|num_templates
expr_stmt|;
name|scope
operator|=
name|TYPE_CONTEXT
argument_list|(
name|scope
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
operator|->
name|u
operator|.
name|id
operator|.
name|unqualified_name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
comment|/* If the DECLARATOR has the form `X<y>' then it uses one 	   additional level of template parameters.  */
operator|++
name|num_templates
expr_stmt|;
return|return
name|cp_parser_check_template_parameters
argument_list|(
name|parser
argument_list|,
name|num_templates
argument_list|)
return|;
case|case
name|cdk_function
case|:
case|case
name|cdk_array
case|:
case|case
name|cdk_pointer
case|:
case|case
name|cdk_reference
case|:
case|case
name|cdk_ptrmem
case|:
return|return
operator|(
name|cp_parser_check_declarator_template_parameters
argument_list|(
name|parser
argument_list|,
name|declarator
operator|->
name|declarator
argument_list|)
operator|)
return|;
case|case
name|cdk_error
case|:
return|return
name|true
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* NUM_TEMPLATES were used in the current declaration.  If that is    invalid, return FALSE and issue an error messages.  Otherwise,    return TRUE.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_check_template_parameters
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|unsigned
name|num_templates
parameter_list|)
block|{
comment|/* If there are more template classes than parameter lists, we have      something like:         template<class T> void S<T>::R<T>::f ();  */
if|if
condition|(
name|parser
operator|->
name|num_template_parameter_lists
operator|<
name|num_templates
condition|)
block|{
name|error
argument_list|(
literal|"too few template-parameter-lists"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If there are the same number of template classes and parameter      lists, that's OK.  */
if|if
condition|(
name|parser
operator|->
name|num_template_parameter_lists
operator|==
name|num_templates
condition|)
return|return
name|true
return|;
comment|/* If there are more, but only one more, then we are referring to a      member template.  That's OK too.  */
if|if
condition|(
name|parser
operator|->
name|num_template_parameter_lists
operator|==
name|num_templates
operator|+
literal|1
condition|)
return|return
name|true
return|;
comment|/* Otherwise, there are too many template parameter lists.  We have      something like:       template<class T> template<class U> void S::f();  */
name|error
argument_list|(
literal|"too many template-parameter-lists"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Parse an optional `::' token indicating that the following name is    from the global namespace.  If so, PARSER->SCOPE is set to the    GLOBAL_NAMESPACE. Otherwise, PARSER->SCOPE is set to NULL_TREE,    unless CURRENT_SCOPE_VALID_P is TRUE, in which case it is left alone.    Returns the new value of PARSER->SCOPE, if the `::' token is    present, and NULL_TREE otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_global_scope_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|current_scope_valid_p
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* If we're looking at a `::' token then we're starting from the      global namespace, not our current location.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_SCOPE
condition|)
block|{
comment|/* Consume the `::' token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Set the SCOPE so that we know where to start the lookup.  */
name|parser
operator|->
name|scope
operator|=
name|global_namespace
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|global_namespace
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|parser
operator|->
name|scope
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|current_scope_valid_p
condition|)
block|{
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if the upcoming token sequence is the start of a    constructor declarator.  If FRIEND_P is true, the declarator is    preceded by the `friend' specifier.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_constructor_declarator_p
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|friend_p
parameter_list|)
block|{
name|bool
name|constructor_p
decl_stmt|;
name|tree
name|type_decl
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|nested_name_p
decl_stmt|;
name|cp_token
modifier|*
name|next_token
decl_stmt|;
comment|/* The common case is that this is not a constructor declarator, so      try to avoid doing lots of work if at all possible.  It's not      valid declare a constructor at function scope.  */
if|if
condition|(
name|parser
operator|->
name|in_function_body
condition|)
return|return
name|false
return|;
comment|/* And only certain tokens can begin a constructor declarator.  */
name|next_token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_token
operator|->
name|type
operator|!=
name|CPP_NAME
operator|&&
name|next_token
operator|->
name|type
operator|!=
name|CPP_SCOPE
operator|&&
name|next_token
operator|->
name|type
operator|!=
name|CPP_NESTED_NAME_SPECIFIER
operator|&&
name|next_token
operator|->
name|type
operator|!=
name|CPP_TEMPLATE_ID
condition|)
return|return
name|false
return|;
comment|/* Parse tentatively; we are going to roll back all of the tokens      consumed here.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Assume that we are looking at a constructor declarator.  */
name|constructor_p
operator|=
name|true
expr_stmt|;
comment|/* Look for the optional `::' operator.  */
name|cp_parser_global_scope_opt
argument_list|(
name|parser
argument_list|,
comment|/*current_scope_valid_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Look for the nested-name-specifier.  */
name|nested_name_p
operator|=
operator|(
name|cp_parser_nested_name_specifier_opt
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|false
argument_list|,
comment|/*type_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Outside of a class-specifier, there must be a      nested-name-specifier.  */
if|if
condition|(
operator|!
name|nested_name_p
operator|&&
operator|(
operator|!
name|at_class_scope_p
argument_list|()
operator|||
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
operator|||
name|friend_p
operator|)
condition|)
name|constructor_p
operator|=
name|false
expr_stmt|;
comment|/* If we still think that this might be a constructor-declarator,      look for a class-name.  */
if|if
condition|(
name|constructor_p
condition|)
block|{
comment|/* If we have:  	   template<typename T> struct S { S(); }; 	   template<typename T> S<T>::S ();  	 we must recognize that the nested `S' names a class. 	 Similarly, for:  	   template<typename T> S<T>::S<T> ();  	 we must recognize that the nested `S' names a template.  */
name|type_decl
operator|=
name|cp_parser_class_name
argument_list|(
name|parser
argument_list|,
comment|/*typename_keyword_p=*/
name|false
argument_list|,
comment|/*template_keyword_p=*/
name|false
argument_list|,
name|none_type
argument_list|,
comment|/*check_dependency_p=*/
name|false
argument_list|,
comment|/*class_head_p=*/
name|false
argument_list|,
comment|/*is_declaration=*/
name|false
argument_list|)
expr_stmt|;
comment|/* If there was no class-name, then this is not a constructor.  */
name|constructor_p
operator|=
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* If we're still considering a constructor, we have to see a `(',      to begin the parameter-declaration-clause, followed by either a      `)', an `...', or a decl-specifier.  We need to check for a      type-specifier to avoid being fooled into thinking that:         S::S (f) (int);       is a constructor.  (It is actually a function named `f' that      takes one parameter (of type `int') and returns a value of type      `S::S'.  */
if|if
condition|(
name|constructor_p
operator|&&
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_ELLIPSIS
argument_list|)
comment|/* A parameter declaration begins with a decl-specifier, 	     which is either the "attribute" keyword, a storage class 	     specifier, or (usually) a type-specifier.  */
operator|&&
operator|!
name|cp_lexer_next_token_is_decl_specifier_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|pushed_scope
init|=
name|NULL_TREE
decl_stmt|;
name|unsigned
name|saved_num_template_parameter_lists
decl_stmt|;
comment|/* Names appearing in the type-specifier should be looked up 	     in the scope of the class.  */
if|if
condition|(
name|current_class_type
condition|)
name|type
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
name|type
operator|=
name|resolve_typename_type
argument_list|(
name|type
argument_list|,
comment|/*only_current_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|cp_parser_abort_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|pushed_scope
operator|=
name|push_scope
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Inside the constructor parameter list, surrounding 	     template-parameter-lists do not apply.  */
name|saved_num_template_parameter_lists
operator|=
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
name|parser
operator|->
name|num_template_parameter_lists
operator|=
literal|0
expr_stmt|;
comment|/* Look for the type-specifier.  */
name|cp_parser_type_specifier
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_FLAGS_NONE
argument_list|,
comment|/*decl_specs=*/
name|NULL
argument_list|,
comment|/*is_declarator=*/
name|true
argument_list|,
comment|/*declares_class_or_enum=*/
name|NULL
argument_list|,
comment|/*is_cv_qualifier=*/
name|NULL
argument_list|)
expr_stmt|;
name|parser
operator|->
name|num_template_parameter_lists
operator|=
name|saved_num_template_parameter_lists
expr_stmt|;
comment|/* Leave the scope of the class.  */
if|if
condition|(
name|pushed_scope
condition|)
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
name|constructor_p
operator|=
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|constructor_p
operator|=
name|false
expr_stmt|;
comment|/* We did not really want to consume any tokens.  */
name|cp_parser_abort_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|constructor_p
return|;
block|}
end_function

begin_comment
comment|/* Parse the definition of the function given by the DECL_SPECIFIERS,    ATTRIBUTES, and DECLARATOR.  The access checks have been deferred;    they must be performed once we are in the scope of the function.     Returns the function defined.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_function_definition_from_specifiers_and_declarator
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
name|decl_specifiers
parameter_list|,
name|tree
name|attributes
parameter_list|,
specifier|const
name|cp_declarator
modifier|*
name|declarator
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|;
name|bool
name|success_p
decl_stmt|;
comment|/* Begin the function-definition.  */
name|success_p
operator|=
name|start_function
argument_list|(
name|decl_specifiers
argument_list|,
name|declarator
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
comment|/* The things we're about to see are not directly qualified by any      template headers we've seen thus far.  */
name|reset_specialization
argument_list|()
expr_stmt|;
comment|/* If there were names looked up in the decl-specifier-seq that we      did not check, check them now.  We must wait until we are in the      scope of the function to perform the checks, since the function      might be a friend.  */
name|perform_deferred_access_checks
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|success_p
condition|)
block|{
comment|/* Skip the entire function.  */
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|fn
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Seen already, skip it.  An error message has already been output.  */
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|fn
operator|=
name|current_function_decl
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If this is a function from a class, pop the nested class.  */
if|if
condition|(
name|current_class_name
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
block|}
else|else
name|fn
operator|=
name|cp_parser_function_definition_after_declarator
argument_list|(
name|parser
argument_list|,
comment|/*inline_p=*/
name|false
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Parse the part of a function-definition that follows the    declarator.  INLINE_P is TRUE iff this function is an inline    function defined with a class-specifier.     Returns the function defined.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_function_definition_after_declarator
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|inline_p
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|;
name|bool
name|ctor_initializer_p
init|=
name|false
decl_stmt|;
name|bool
name|saved_in_unbraced_linkage_specification_p
decl_stmt|;
name|bool
name|saved_in_function_body
decl_stmt|;
name|unsigned
name|saved_num_template_parameter_lists
decl_stmt|;
name|saved_in_function_body
operator|=
name|parser
operator|->
name|in_function_body
expr_stmt|;
name|parser
operator|->
name|in_function_body
operator|=
name|true
expr_stmt|;
comment|/* If the next token is `return', then the code may be trying to      make use of the "named return value" extension that G++ used to      support.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_RETURN
argument_list|)
condition|)
block|{
comment|/* Consume the `return' keyword.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Look for the identifier that indicates what value is to be 	 returned.  */
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Issue an error message.  */
name|error
argument_list|(
literal|"named return values are no longer supported"
argument_list|)
expr_stmt|;
comment|/* Skip tokens until we reach the start of the function body.  */
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_EOF
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_PRAGMA_EOL
condition|)
break|break;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The `extern' in `extern "C" void f () { ... }' does not apply to      anything declared inside `f'.  */
name|saved_in_unbraced_linkage_specification_p
operator|=
name|parser
operator|->
name|in_unbraced_linkage_specification_p
expr_stmt|;
name|parser
operator|->
name|in_unbraced_linkage_specification_p
operator|=
name|false
expr_stmt|;
comment|/* Inside the function, surrounding template-parameter-lists do not      apply.  */
name|saved_num_template_parameter_lists
operator|=
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
name|parser
operator|->
name|num_template_parameter_lists
operator|=
literal|0
expr_stmt|;
comment|/* If the next token is `try', then we are looking at a      function-try-block.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TRY
argument_list|)
condition|)
name|ctor_initializer_p
operator|=
name|cp_parser_function_try_block
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* A function-try-block includes the function-body, so we only do      this next part if we're not processing a function-try-block.  */
else|else
name|ctor_initializer_p
operator|=
name|cp_parser_ctor_initializer_opt_and_function_body
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Finish the function.  */
name|fn
operator|=
name|finish_function
argument_list|(
operator|(
name|ctor_initializer_p
condition|?
literal|1
else|:
literal|0
operator|)
operator||
operator|(
name|inline_p
condition|?
literal|2
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Generate code for it, if necessary.  */
name|expand_or_defer_fn
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Restore the saved values.  */
name|parser
operator|->
name|in_unbraced_linkage_specification_p
operator|=
name|saved_in_unbraced_linkage_specification_p
expr_stmt|;
name|parser
operator|->
name|num_template_parameter_lists
operator|=
name|saved_num_template_parameter_lists
expr_stmt|;
name|parser
operator|->
name|in_function_body
operator|=
name|saved_in_function_body
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-declaration, assuming that the `export' (and    `extern') keywords, if present, has already been scanned.  MEMBER_P    is as for cp_parser_template_declaration.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_template_declaration_after_export
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|member_p
parameter_list|)
block|{
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
name|VEC
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|)
operator|*
name|checks
expr_stmt|;
name|tree
name|parameter_list
decl_stmt|;
name|bool
name|friend_p
init|=
name|false
decl_stmt|;
name|bool
name|need_lang_pop
decl_stmt|;
comment|/* Look for the `template' keyword.  */
if|if
condition|(
operator|!
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_TEMPLATE
argument_list|,
literal|"`template'"
argument_list|)
condition|)
return|return;
comment|/* And the `<'.  */
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|,
literal|"`<'"
argument_list|)
condition|)
return|return;
if|if
condition|(
name|at_class_scope_p
argument_list|()
operator|&&
name|current_function_decl
condition|)
block|{
comment|/* 14.5.2.2 [temp.mem]           A local class shall not have member templates.  */
name|error
argument_list|(
literal|"invalid declaration of member template in local class"
argument_list|)
expr_stmt|;
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* [temp]       A template ... shall not have C linkage.  */
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
block|{
name|error
argument_list|(
literal|"template with C linkage"
argument_list|)
expr_stmt|;
comment|/* Give it C++ linkage to avoid confusing other parts of the 	 front end.  */
name|push_lang_context
argument_list|(
name|lang_name_cplusplus
argument_list|)
expr_stmt|;
name|need_lang_pop
operator|=
name|true
expr_stmt|;
block|}
else|else
name|need_lang_pop
operator|=
name|false
expr_stmt|;
comment|/* We cannot perform access checks on the template parameter      declarations until we know what is being declared, just as we      cannot check the decl-specifier list.  */
name|push_deferring_access_checks
argument_list|(
name|dk_deferred
argument_list|)
expr_stmt|;
comment|/* If the next token is `>', then we have an invalid      specialization.  Rather than complain about an invalid template      parameter, issue an error message here.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_GREATER
argument_list|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"invalid explicit specialization"
argument_list|)
expr_stmt|;
name|begin_specialization
argument_list|()
expr_stmt|;
name|parameter_list
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
comment|/* Parse the template parameters.  */
name|parameter_list
operator|=
name|cp_parser_template_parameter_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Get the deferred access checks from the parameter list.  These      will be checked once we know what is being declared, as for a      member template the checks must be performed in the scope of the      class containing the member.  */
name|checks
operator|=
name|get_deferred_access_checks
argument_list|()
expr_stmt|;
comment|/* Look for the `>'.  */
name|cp_parser_skip_to_end_of_template_parameter_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* We just processed one more parameter list.  */
operator|++
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
comment|/* If the next token is `template', there are more template      parameters.  */
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TEMPLATE
argument_list|)
condition|)
name|cp_parser_template_declaration_after_export
argument_list|(
name|parser
argument_list|,
name|member_p
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* There are no access checks when parsing a template, as we do not 	 know if a specialization will be a friend.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
name|decl
operator|=
name|cp_parser_single_declaration
argument_list|(
name|parser
argument_list|,
name|checks
argument_list|,
name|member_p
argument_list|,
operator|&
name|friend_p
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* If this is a member template declaration, let the front 	 end know.  */
if|if
condition|(
name|member_p
operator|&&
operator|!
name|friend_p
operator|&&
name|decl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|cp_parser_check_access_in_redeclaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|finish_member_template_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|friend_p
operator|&&
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|make_friend_class
argument_list|(
name|current_class_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
comment|/*complain=*/
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* We are done with the current parameter list.  */
operator|--
name|parser
operator|->
name|num_template_parameter_lists
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Finish up.  */
name|finish_template_decl
argument_list|(
name|parameter_list
argument_list|)
expr_stmt|;
comment|/* Register member declarations.  */
if|if
condition|(
name|member_p
operator|&&
operator|!
name|friend_p
operator|&&
name|decl
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|finish_member_declaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* For the erroneous case of a template with C linkage, we pushed an      implicit C++ linkage scope; exit that scope now.  */
if|if
condition|(
name|need_lang_pop
condition|)
name|pop_lang_context
argument_list|()
expr_stmt|;
comment|/* If DECL is a function template, we must return to parse it later.      (Even though there is no definition, there might be default      arguments that need handling.)  */
if|if
condition|(
name|member_p
operator|&&
name|decl
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform the deferred access checks from a template-parameter-list.    CHECKS is a TREE_LIST of access checks, as returned by    get_deferred_access_checks.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|cp_parser_perform_template_parameter_access_checks
argument_list|(
name|VEC
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|)
operator|*
name|checks
argument_list|)
block|{
operator|++
name|processing_template_parmlist
expr_stmt|;
name|perform_access_checks
argument_list|(
name|checks
argument_list|)
expr_stmt|;
operator|--
name|processing_template_parmlist
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Parse a `decl-specifier-seq [opt] init-declarator [opt] ;' or    `function-definition' sequence.  MEMBER_P is true, this declaration    appears in a class scope.     Returns the DECL for the declared entity.  If FRIEND_P is non-NULL,    *FRIEND_P is set to TRUE iff the declaration is a friend.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|cp_parser_single_declaration
argument_list|(
name|cp_parser
operator|*
name|parser
argument_list|,
name|VEC
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|)
operator|*
name|checks
argument_list|,
name|bool
name|member_p
argument_list|,
name|bool
operator|*
name|friend_p
argument_list|)
block|{
name|int
name|declares_class_or_enum
decl_stmt|;
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
name|cp_decl_specifier_seq
name|decl_specifiers
decl_stmt|;
name|bool
name|function_definition_p
init|=
name|false
decl_stmt|;
comment|/* This function is only used when processing a template      declaration.  */
name|gcc_assert
argument_list|(
name|innermost_scope_kind
argument_list|()
operator|==
name|sk_template_parms
operator|||
name|innermost_scope_kind
argument_list|()
operator|==
name|sk_template_spec
argument_list|)
expr_stmt|;
comment|/* Defer access checks until we know what is being declared.  */
name|push_deferring_access_checks
argument_list|(
name|dk_deferred
argument_list|)
expr_stmt|;
comment|/* Try the `decl-specifier-seq [opt] init-declarator [opt]'      alternative.  */
name|cp_parser_decl_specifier_seq
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_FLAGS_OPTIONAL
argument_list|,
operator|&
name|decl_specifiers
argument_list|,
operator|&
name|declares_class_or_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|friend_p
condition|)
operator|*
name|friend_p
operator|=
name|cp_parser_friend_p
argument_list|(
operator|&
name|decl_specifiers
argument_list|)
expr_stmt|;
comment|/* There are no template typedefs.  */
if|if
condition|(
name|decl_specifiers
operator|.
name|specs
index|[
operator|(
name|int
operator|)
name|ds_typedef
index|]
condition|)
block|{
name|error
argument_list|(
literal|"template declaration of %qs"
argument_list|,
literal|"typedef"
argument_list|)
expr_stmt|;
name|decl
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Gather up the access checks that occurred the      decl-specifier-seq.  */
name|stop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Check for the declaration of a template class.  */
if|if
condition|(
name|declares_class_or_enum
condition|)
block|{
if|if
condition|(
name|cp_parser_declares_only_class_p
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|decl
operator|=
name|shadow_tag
argument_list|(
operator|&
name|decl_specifiers
argument_list|)
expr_stmt|;
comment|/* In this case:  	       struct C { 		 friend template<typename T> struct A<T>::B; 	       };  	     A<T>::B will be represented by a TYPENAME_TYPE, and 	     therefore not recognized by shadow_tag.  */
if|if
condition|(
name|friend_p
operator|&&
operator|*
name|friend_p
operator|&&
operator|!
name|decl
operator|&&
name|decl_specifiers
operator|.
name|type
operator|&&
name|TYPE_P
argument_list|(
name|decl_specifiers
operator|.
name|type
argument_list|)
condition|)
name|decl
operator|=
name|decl_specifiers
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|decl
operator|!=
name|error_mark_node
condition|)
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Perform access checks for template parameters.  */
name|cp_parser_perform_template_parameter_access_checks
argument_list|(
name|checks
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If it's not a template class, try for a template function.  If      the next token is a `;', then this declaration does not declare      anything.  But, if there were errors in the decl-specifiers, then      the error might well have come from an attempted class-specifier.      In that case, there's no need to warn about a missing declarator.  */
if|if
condition|(
operator|!
name|decl
operator|&&
operator|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
operator|||
name|decl_specifiers
operator|.
name|type
operator|!=
name|error_mark_node
operator|)
condition|)
name|decl
operator|=
name|cp_parser_init_declarator
argument_list|(
name|parser
argument_list|,
operator|&
name|decl_specifiers
argument_list|,
name|checks
argument_list|,
comment|/*function_definition_allowed_p=*/
name|true
argument_list|,
name|member_p
argument_list|,
name|declares_class_or_enum
argument_list|,
operator|&
name|function_definition_p
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Clear any current qualification; whatever comes next is the start      of something new.  */
name|parser
operator|->
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|NULL_TREE
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Look for a trailing `;' after the declaration.  */
if|if
condition|(
operator|!
name|function_definition_p
operator|&&
operator|(
name|decl
operator|==
name|error_mark_node
operator|||
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
operator|)
condition|)
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Parse a cast-expression that is not the operand of a unary "&".  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_simple_cast_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
return|return
name|cp_parser_cast_expression
argument_list|(
name|parser
argument_list|,
comment|/*address_p=*/
name|false
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a functional cast to TYPE.  Returns an expression    representing the cast.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_functional_cast
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|expression_list
decl_stmt|;
name|tree
name|cast
decl_stmt|;
name|expression_list
operator|=
name|cp_parser_parenthesized_expression_list
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
comment|/*cast_p=*/
name|true
argument_list|,
comment|/*non_constant_p=*/
name|NULL
argument_list|)
expr_stmt|;
name|cast
operator|=
name|build_functional_cast
argument_list|(
name|type
argument_list|,
name|expression_list
argument_list|)
expr_stmt|;
comment|/* [expr.const]/1: In an integral constant expression "only type      conversions to integral or enumeration type can be used".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|cast
operator|!=
name|error_mark_node
operator|&&
operator|!
name|cast_valid_in_integral_constant_expression_p
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|cp_parser_non_integral_constant_expression
argument_list|(
name|parser
argument_list|,
literal|"a call to a constructor"
argument_list|)
operator|)
condition|)
return|return
name|error_mark_node
return|;
return|return
name|cast
return|;
block|}
end_function

begin_comment
comment|/* Save the tokens that make up the body of a member function defined    in a class-specifier.  The DECL_SPECIFIERS and DECLARATOR have    already been parsed.  The ATTRIBUTES are any GNU "__attribute__"    specifiers applied to the declaration.  Returns the FUNCTION_DECL    for the member function.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_save_member_function_body
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
name|decl_specifiers
parameter_list|,
name|cp_declarator
modifier|*
name|declarator
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
name|cp_token
modifier|*
name|first
decl_stmt|;
name|cp_token
modifier|*
name|last
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* Create the function-declaration.  */
name|fn
operator|=
name|start_method
argument_list|(
name|decl_specifiers
argument_list|,
name|declarator
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
comment|/* If something went badly wrong, bail out now.  */
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
block|{
comment|/* If there's a function-body, skip it.  */
if|if
condition|(
name|cp_parser_token_starts_function_definition_p
argument_list|(
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
argument_list|)
condition|)
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Remember it, if there default args to post process.  */
name|cp_parser_save_default_args
argument_list|(
name|parser
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* Save away the tokens that make up the body of the      function.  */
name|first
operator|=
name|parser
operator|->
name|lexer
operator|->
name|next_token
expr_stmt|;
name|cp_parser_cache_group
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
comment|/*depth=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle function try blocks.  */
while|while
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_CATCH
argument_list|)
condition|)
name|cp_parser_cache_group
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
comment|/*depth=*/
literal|0
argument_list|)
expr_stmt|;
name|last
operator|=
name|parser
operator|->
name|lexer
operator|->
name|next_token
expr_stmt|;
comment|/* Save away the inline definition; we will process it when the      class is complete.  */
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|fn
argument_list|)
operator|=
name|cp_token_cache_new
argument_list|(
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|DECL_PENDING_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We need to know that this was defined in the class, so that      friend templates are handled correctly.  */
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We're done with the inline definition.  */
name|finish_method
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Add FN to the queue of functions to be parsed later.  */
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|TREE_VALUE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Parse a template-argument-list, as well as the trailing ">" (but    not the opening ">").  See cp_parser_template_argument_list for the    return value.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_enclosed_template_argument_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|arguments
decl_stmt|;
name|tree
name|saved_scope
decl_stmt|;
name|tree
name|saved_qualifying_scope
decl_stmt|;
name|tree
name|saved_object_scope
decl_stmt|;
name|bool
name|saved_greater_than_is_operator_p
decl_stmt|;
name|bool
name|saved_skip_evaluation
decl_stmt|;
comment|/* [temp.names]       When parsing a template-id, the first non-nested `>' is taken as      the end of the template-argument-list rather than a greater-than      operator.  */
name|saved_greater_than_is_operator_p
operator|=
name|parser
operator|->
name|greater_than_is_operator_p
expr_stmt|;
name|parser
operator|->
name|greater_than_is_operator_p
operator|=
name|false
expr_stmt|;
comment|/* Parsing the argument list may modify SCOPE, so we save it      here.  */
name|saved_scope
operator|=
name|parser
operator|->
name|scope
expr_stmt|;
name|saved_qualifying_scope
operator|=
name|parser
operator|->
name|qualifying_scope
expr_stmt|;
name|saved_object_scope
operator|=
name|parser
operator|->
name|object_scope
expr_stmt|;
comment|/* We need to evaluate the template arguments, even though this      template-id may be nested within a "sizeof".  */
name|saved_skip_evaluation
operator|=
name|skip_evaluation
expr_stmt|;
name|skip_evaluation
operator|=
name|false
expr_stmt|;
comment|/* Parse the template-argument-list itself.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_GREATER
argument_list|)
condition|)
name|arguments
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|arguments
operator|=
name|cp_parser_template_argument_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Look for the `>' that ends the template-argument-list. If we find      a '>>' instead, it's probably just a typo.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_RSHIFT
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|saved_greater_than_is_operator_p
condition|)
block|{
comment|/* If we're in a nested template argument list, the '>>' has 	    to be a typo for '>>'. We emit the error message, but we 	    continue parsing and we push a '>' as next token, so that 	    the argument list will be parsed correctly.  Note that the 	    global source location is still on the token before the 	    '>>', so we need to say explicitly where we want it.  */
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|"%H%<>>%> should be %<>>%> "
literal|"within a nested template argument list"
argument_list|,
operator|&
name|token
operator|->
name|location
argument_list|)
expr_stmt|;
comment|/* ??? Proper recovery should terminate two levels of 	     template argument list here.  */
name|token
operator|->
name|type
operator|=
name|CPP_GREATER
expr_stmt|;
block|}
else|else
block|{
comment|/* If this is not a nested template argument list, the '>>' 	    is a typo for '>'. Emit an error message and continue. 	    Same deal about the token location, but here we can get it 	    right by consuming the '>>' before issuing the diagnostic.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"spurious %<>>%>, use %<>%> to terminate "
literal|"a template argument list"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|cp_parser_skip_to_end_of_template_parameter_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* The `>' token might be a greater-than operator again now.  */
name|parser
operator|->
name|greater_than_is_operator_p
operator|=
name|saved_greater_than_is_operator_p
expr_stmt|;
comment|/* Restore the SAVED_SCOPE.  */
name|parser
operator|->
name|scope
operator|=
name|saved_scope
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|saved_qualifying_scope
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|saved_object_scope
expr_stmt|;
name|skip_evaluation
operator|=
name|saved_skip_evaluation
expr_stmt|;
return|return
name|arguments
return|;
block|}
end_function

begin_comment
comment|/* MEMBER_FUNCTION is a member function, or a friend.  If default    arguments, or the body of the function have not yet been parsed,    parse them now.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_late_parsing_for_member
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|member_function
parameter_list|)
block|{
comment|/* If this member is a template, get the underlying      FUNCTION_DECL.  */
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|member_function
argument_list|)
condition|)
name|member_function
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|member_function
argument_list|)
expr_stmt|;
comment|/* There should not be any class definitions in progress at this      point; the bodies of members are only parsed outside of all class      definitions.  */
name|gcc_assert
argument_list|(
name|parser
operator|->
name|num_classes_being_defined
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* While we're parsing the member functions we might encounter more      classes.  We want to handle them right away, but we don't want      them getting mixed up with functions that are currently in the      queue.  */
name|parser
operator|->
name|unparsed_functions_queues
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
expr_stmt|;
comment|/* Make sure that any template parameters are in scope.  */
name|maybe_begin_member_template_processing
argument_list|(
name|member_function
argument_list|)
expr_stmt|;
comment|/* If the body of the function has not yet been parsed, parse it      now.  */
if|if
condition|(
name|DECL_PENDING_INLINE_P
argument_list|(
name|member_function
argument_list|)
condition|)
block|{
name|tree
name|function_scope
decl_stmt|;
name|cp_token_cache
modifier|*
name|tokens
decl_stmt|;
comment|/* The function is no longer pending; we are processing it.  */
name|tokens
operator|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|member_function
argument_list|)
expr_stmt|;
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|member_function
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_PENDING_INLINE_P
argument_list|(
name|member_function
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If this is a local class, enter the scope of the containing 	 function.  */
name|function_scope
operator|=
name|current_function_decl
expr_stmt|;
if|if
condition|(
name|function_scope
condition|)
name|push_function_context_to
argument_list|(
name|function_scope
argument_list|)
expr_stmt|;
comment|/* Push the body of the function onto the lexer stack.  */
name|cp_parser_push_lexer_for_tokens
argument_list|(
name|parser
argument_list|,
name|tokens
argument_list|)
expr_stmt|;
comment|/* Let the front end know that we going to be defining this 	 function.  */
name|start_preparsed_function
argument_list|(
name|member_function
argument_list|,
name|NULL_TREE
argument_list|,
name|SF_PRE_PARSED
operator||
name|SF_INCLASS_INLINE
argument_list|)
expr_stmt|;
comment|/* Don't do access checking if it is a templated function.  */
if|if
condition|(
name|processing_template_decl
condition|)
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
comment|/* Now, parse the body of the function.  */
name|cp_parser_function_definition_after_declarator
argument_list|(
name|parser
argument_list|,
comment|/*inline_p=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Leave the scope of the containing function.  */
if|if
condition|(
name|function_scope
condition|)
name|pop_function_context_from
argument_list|(
name|function_scope
argument_list|)
expr_stmt|;
name|cp_parser_pop_lexer
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Remove any template parameters from the symbol table.  */
name|maybe_end_member_template_processing
argument_list|()
expr_stmt|;
comment|/* Restore the queue.  */
name|parser
operator|->
name|unparsed_functions_queues
operator|=
name|TREE_CHAIN
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If DECL contains any default args, remember it on the unparsed    functions queue.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_save_default_args
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|probe
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
init|;
name|probe
condition|;
name|probe
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|probe
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* FN is a FUNCTION_DECL which may contains a parameter with an    unparsed DEFAULT_ARG.  Parse the default args now.  This function    assumes that the current scope is the scope in which the default    argument should be processed.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_late_parsing_default_args
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|fn
parameter_list|)
block|{
name|bool
name|saved_local_variables_forbidden_p
decl_stmt|;
name|tree
name|parm
decl_stmt|;
comment|/* While we're parsing the default args, we might (due to the      statement expression extension) encounter more classes.  We want      to handle them right away, but we don't want them getting mixed      up with default args that are currently in the queue.  */
name|parser
operator|->
name|unparsed_functions_queues
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
expr_stmt|;
comment|/* Local variable names (and the `this' keyword) may not appear      in a default argument.  */
name|saved_local_variables_forbidden_p
operator|=
name|parser
operator|->
name|local_variables_forbidden_p
expr_stmt|;
name|parser
operator|->
name|local_variables_forbidden_p
operator|=
name|true
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|cp_token_cache
modifier|*
name|tokens
decl_stmt|;
name|tree
name|default_arg
init|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|parsed_arg
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|insts
expr_stmt|;
name|tree
name|copy
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
if|if
condition|(
operator|!
name|default_arg
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|default_arg
argument_list|)
operator|!=
name|DEFAULT_ARG
condition|)
comment|/* This can happen for a friend declaration for a function 	   already declared with default arguments.  */
continue|continue;
comment|/* Push the saved tokens for the default argument onto the parser's 	  lexer stack.  */
name|tokens
operator|=
name|DEFARG_TOKENS
argument_list|(
name|default_arg
argument_list|)
expr_stmt|;
name|cp_parser_push_lexer_for_tokens
argument_list|(
name|parser
argument_list|,
name|tokens
argument_list|)
expr_stmt|;
comment|/* Parse the assignment-expression.  */
name|parsed_arg
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|parsed_arg
operator|=
name|check_default_argument
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|parsed_arg
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
name|parsed_arg
expr_stmt|;
comment|/* Update any instantiations we've already created.  */
for|for
control|(
name|insts
operator|=
name|DEFARG_INSTANTIATIONS
argument_list|(
name|default_arg
argument_list|)
operator|,
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|insts
argument_list|,
name|ix
argument_list|,
name|copy
argument_list|)
condition|;
name|ix
operator|++
control|)
name|TREE_PURPOSE
argument_list|(
name|copy
argument_list|)
operator|=
name|parsed_arg
expr_stmt|;
comment|/* If the token stream has not been completely used up, then 	 there was extra junk after the end of the default 	 argument.  */
if|if
condition|(
operator|!
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EOF
argument_list|)
condition|)
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<,%>"
argument_list|)
expr_stmt|;
comment|/* Revert to the main lexer.  */
name|cp_parser_pop_lexer
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure no default arg is missing.  */
name|check_default_args
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Restore the state of local_variables_forbidden_p.  */
name|parser
operator|->
name|local_variables_forbidden_p
operator|=
name|saved_local_variables_forbidden_p
expr_stmt|;
comment|/* Restore the queue.  */
name|parser
operator|->
name|unparsed_functions_queues
operator|=
name|TREE_CHAIN
argument_list|(
name|parser
operator|->
name|unparsed_functions_queues
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the operand of `sizeof' (or a similar operator).  Returns    either a TYPE or an expression, depending on the form of the    input.  The KEYWORD indicates which kind of expression we have    encountered.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_sizeof_operand
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|rid
name|keyword
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|tree
name|expr
init|=
name|NULL_TREE
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_message
decl_stmt|;
name|bool
name|saved_integral_constant_expression_p
decl_stmt|;
name|bool
name|saved_non_integral_constant_expression_p
decl_stmt|;
comment|/* Initialize FORMAT the first time we get here.  */
if|if
condition|(
operator|!
name|format
condition|)
name|format
operator|=
literal|"types may not be defined in '%s' expressions"
expr_stmt|;
comment|/* Types cannot be defined in a `sizeof' expression.  Save away the      old message.  */
name|saved_message
operator|=
name|parser
operator|->
name|type_definition_forbidden_message
expr_stmt|;
comment|/* And create the new one.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|XNEWVEC
argument_list|(
specifier|const
name|char
argument_list|,
name|strlen
argument_list|(
name|format
argument_list|)
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|ridpointers
index|[
name|keyword
index|]
argument_list|)
argument_list|)
operator|+
literal|1
comment|/* `\0' */
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parser
operator|->
name|type_definition_forbidden_message
argument_list|,
name|format
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ridpointers
index|[
name|keyword
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The restrictions on constant-expressions do not apply inside      sizeof expressions.  */
name|saved_integral_constant_expression_p
operator|=
name|parser
operator|->
name|integral_constant_expression_p
expr_stmt|;
name|saved_non_integral_constant_expression_p
operator|=
name|parser
operator|->
name|non_integral_constant_expression_p
expr_stmt|;
name|parser
operator|->
name|integral_constant_expression_p
operator|=
name|false
expr_stmt|;
comment|/* Do not actually evaluate the expression.  */
operator|++
name|skip_evaluation
expr_stmt|;
comment|/* If it's a `(', then we might be looking at the type-id      construction.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|bool
name|saved_in_type_id_in_expr_p
decl_stmt|;
comment|/* We can't be sure yet whether we're looking at a type-id or an 	 expression.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Consume the `('.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Parse the type-id.  */
name|saved_in_type_id_in_expr_p
operator|=
name|parser
operator|->
name|in_type_id_in_expr_p
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|true
expr_stmt|;
name|type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_type_id_in_expr_p
operator|=
name|saved_in_type_id_in_expr_p
expr_stmt|;
comment|/* Now, look for the trailing `)'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"%<)%>"
argument_list|)
expr_stmt|;
comment|/* If all went well, then we're done.  */
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|cp_decl_specifier_seq
name|decl_specs
decl_stmt|;
comment|/* Build a trivial decl-specifier-seq.  */
name|clear_decl_specs
argument_list|(
operator|&
name|decl_specs
argument_list|)
expr_stmt|;
name|decl_specs
operator|.
name|type
operator|=
name|type
expr_stmt|;
comment|/* Call grokdeclarator to figure out what type this is.  */
name|expr
operator|=
name|grokdeclarator
argument_list|(
name|NULL
argument_list|,
operator|&
name|decl_specs
argument_list|,
name|TYPENAME
argument_list|,
comment|/*initialized=*/
literal|0
argument_list|,
comment|/*attrlist=*/
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the type-id production did not work out, then we must be      looking at the unary-expression production.  */
if|if
condition|(
operator|!
name|expr
condition|)
name|expr
operator|=
name|cp_parser_unary_expression
argument_list|(
name|parser
argument_list|,
comment|/*address_p=*/
name|false
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Go back to evaluating expressions.  */
operator|--
name|skip_evaluation
expr_stmt|;
comment|/* Free the message we created.  */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parser
operator|->
name|type_definition_forbidden_message
argument_list|)
expr_stmt|;
comment|/* And restore the old one.  */
name|parser
operator|->
name|type_definition_forbidden_message
operator|=
name|saved_message
expr_stmt|;
name|parser
operator|->
name|integral_constant_expression_p
operator|=
name|saved_integral_constant_expression_p
expr_stmt|;
name|parser
operator|->
name|non_integral_constant_expression_p
operator|=
name|saved_non_integral_constant_expression_p
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* If the current declaration has no declarator, return true.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_declares_only_class_p
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* If the next token is a `;' or a `,' then there is no      declarator.  */
return|return
operator|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
operator|||
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Update the DECL_SPECS to reflect the storage class indicated by    KEYWORD.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_set_storage_class
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
name|decl_specs
parameter_list|,
name|enum
name|rid
name|keyword
parameter_list|)
block|{
name|cp_storage_class
name|storage_class
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|in_unbraced_linkage_specification_p
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of %qD in linkage specification"
argument_list|,
name|ridpointers
index|[
name|keyword
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|decl_specs
operator|->
name|storage_class
operator|!=
name|sc_none
condition|)
block|{
name|decl_specs
operator|->
name|conflicting_specifiers_p
operator|=
name|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|keyword
operator|==
name|RID_EXTERN
operator|||
name|keyword
operator|==
name|RID_STATIC
operator|)
operator|&&
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_thread
index|]
condition|)
block|{
name|error
argument_list|(
literal|"%<__thread%> before %qD"
argument_list|,
name|ridpointers
index|[
name|keyword
index|]
argument_list|)
expr_stmt|;
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_thread
index|]
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|keyword
condition|)
block|{
case|case
name|RID_AUTO
case|:
name|storage_class
operator|=
name|sc_auto
expr_stmt|;
break|break;
case|case
name|RID_REGISTER
case|:
name|storage_class
operator|=
name|sc_register
expr_stmt|;
break|break;
case|case
name|RID_STATIC
case|:
name|storage_class
operator|=
name|sc_static
expr_stmt|;
break|break;
case|case
name|RID_EXTERN
case|:
name|storage_class
operator|=
name|sc_extern
expr_stmt|;
break|break;
case|case
name|RID_MUTABLE
case|:
name|storage_class
operator|=
name|sc_mutable
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|decl_specs
operator|->
name|storage_class
operator|=
name|storage_class
expr_stmt|;
comment|/* A storage class specifier cannot be applied alongside a typedef       specifier. If there is a typedef specifier present then set       conflicting_specifiers_p which will trigger an error later      on in grokdeclarator. */
if|if
condition|(
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_typedef
index|]
condition|)
name|decl_specs
operator|->
name|conflicting_specifiers_p
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the DECL_SPECS to reflect the TYPE_SPEC.  If USER_DEFINED_P    is true, the type is a user-defined type; otherwise it is a    built-in type specified by a keyword.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_set_decl_spec_type
parameter_list|(
name|cp_decl_specifier_seq
modifier|*
name|decl_specs
parameter_list|,
name|tree
name|type_spec
parameter_list|,
name|bool
name|user_defined_p
parameter_list|)
block|{
name|decl_specs
operator|->
name|any_specifiers_p
operator|=
name|true
expr_stmt|;
comment|/* If the user tries to redeclare bool or wchar_t (with, for      example, in "typedef int wchar_t;") we remember that this is what      happened.  In system headers, we ignore these declarations so      that G++ can work with system headers that are not C++-safe.  */
if|if
condition|(
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_typedef
index|]
operator|&&
operator|!
name|user_defined_p
operator|&&
operator|(
name|type_spec
operator|==
name|boolean_type_node
operator|||
name|type_spec
operator|==
name|wchar_type_node
operator|)
operator|&&
operator|(
name|decl_specs
operator|->
name|type
operator|||
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_long
index|]
operator|||
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_short
index|]
operator|||
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_unsigned
index|]
operator|||
name|decl_specs
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_signed
index|]
operator|)
condition|)
block|{
name|decl_specs
operator|->
name|redefined_builtin_type
operator|=
name|type_spec
expr_stmt|;
if|if
condition|(
operator|!
name|decl_specs
operator|->
name|type
condition|)
block|{
name|decl_specs
operator|->
name|type
operator|=
name|type_spec
expr_stmt|;
name|decl_specs
operator|->
name|user_defined_type_p
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|decl_specs
operator|->
name|type
condition|)
name|decl_specs
operator|->
name|multiple_types_p
operator|=
name|true
expr_stmt|;
else|else
block|{
name|decl_specs
operator|->
name|type
operator|=
name|type_spec
expr_stmt|;
name|decl_specs
operator|->
name|user_defined_type_p
operator|=
name|user_defined_p
expr_stmt|;
name|decl_specs
operator|->
name|redefined_builtin_type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* DECL_SPECIFIERS is the representation of a decl-specifier-seq.    Returns TRUE iff `friend' appears among the DECL_SPECIFIERS.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_friend_p
parameter_list|(
specifier|const
name|cp_decl_specifier_seq
modifier|*
name|decl_specifiers
parameter_list|)
block|{
return|return
name|decl_specifiers
operator|->
name|specs
index|[
operator|(
name|int
operator|)
name|ds_friend
index|]
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If the next token is of the indicated TYPE, consume it.  Otherwise,    issue an error message indicating that TOKEN_DESC was expected.     Returns the token consumed, if the token had the appropriate type.    Otherwise, returns NULL.  */
end_comment

begin_function
specifier|static
name|cp_token
modifier|*
name|cp_parser_require
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|cpp_ttype
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|token_desc
parameter_list|)
block|{
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
return|;
else|else
block|{
comment|/* Output the MESSAGE -- unless we're parsing tentatively.  */
if|if
condition|(
operator|!
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|char
modifier|*
name|message
init|=
name|concat
argument_list|(
literal|"expected "
argument_list|,
name|token_desc
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* An error message is produced if the next token is not '>'.    All further tokens are skipped until the desired token is    found or '{', '}', ';' or an unbalanced ')' or ']'.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_skip_to_end_of_template_parameter_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Current level of '< ...>'.  */
name|unsigned
name|level
init|=
literal|0
decl_stmt|;
comment|/* Ignore '<' and '>' nested inside '( ... )' or '[ ... ]'.  */
name|unsigned
name|nesting_depth
init|=
literal|0
decl_stmt|;
comment|/* Are we ready, yet?  If not, issue error message.  */
if|if
condition|(
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_GREATER
argument_list|,
literal|"%<>%>"
argument_list|)
condition|)
return|return;
comment|/* Skip tokens until the desired token is found.  */
while|while
condition|(
name|true
condition|)
block|{
comment|/* Peek at the next token.  */
switch|switch
condition|(
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|type
condition|)
block|{
case|case
name|CPP_LESS
case|:
if|if
condition|(
operator|!
name|nesting_depth
condition|)
operator|++
name|level
expr_stmt|;
break|break;
case|case
name|CPP_GREATER
case|:
if|if
condition|(
operator|!
name|nesting_depth
operator|&&
name|level
operator|--
operator|==
literal|0
condition|)
block|{
comment|/* We've reached the token we want, consume it and stop.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|CPP_OPEN_PAREN
case|:
case|case
name|CPP_OPEN_SQUARE
case|:
operator|++
name|nesting_depth
expr_stmt|;
break|break;
case|case
name|CPP_CLOSE_PAREN
case|:
case|case
name|CPP_CLOSE_SQUARE
case|:
if|if
condition|(
name|nesting_depth
operator|--
operator|==
literal|0
condition|)
return|return;
break|break;
case|case
name|CPP_EOF
case|:
case|case
name|CPP_PRAGMA_EOL
case|:
case|case
name|CPP_SEMICOLON
case|:
case|case
name|CPP_OPEN_BRACE
case|:
case|case
name|CPP_CLOSE_BRACE
case|:
comment|/* The '>' was probably forgotten, don't look further.  */
return|return;
default|default:
break|break;
block|}
comment|/* Consume this token.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If the next token is the indicated keyword, consume it.  Otherwise,    issue an error message indicating that TOKEN_DESC was expected.     Returns the token consumed, if the token had the appropriate type.    Otherwise, returns NULL.  */
end_comment

begin_function
specifier|static
name|cp_token
modifier|*
name|cp_parser_require_keyword
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|rid
name|keyword
parameter_list|,
specifier|const
name|char
modifier|*
name|token_desc
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|,
name|token_desc
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|&&
name|token
operator|->
name|keyword
operator|!=
name|keyword
condition|)
block|{
name|dyn_string_t
name|error_msg
decl_stmt|;
comment|/* Format the error message.  */
name|error_msg
operator|=
name|dyn_string_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dyn_string_append_cstr
argument_list|(
name|error_msg
argument_list|,
literal|"expected "
argument_list|)
expr_stmt|;
name|dyn_string_append_cstr
argument_list|(
name|error_msg
argument_list|,
name|token_desc
argument_list|)
expr_stmt|;
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
name|error_msg
operator|->
name|s
argument_list|)
expr_stmt|;
name|dyn_string_delete
argument_list|(
name|error_msg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|token
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE iff TOKEN is a token that can begin the body of a    function-definition.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_token_starts_function_definition_p
parameter_list|(
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
return|return
operator|(
comment|/* An ordinary function-body begins with an `{'.  */
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
comment|/* A ctor-initializer begins with a `:'.  */
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_COLON
comment|/* A function-try-block begins with `try'.  */
operator|||
name|token
operator|->
name|keyword
operator|==
name|RID_TRY
comment|/* The named return value extension begins with `return'.  */
operator|||
name|token
operator|->
name|keyword
operator|==
name|RID_RETURN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE iff the next token is the ":" or "{" beginning a class    definition.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_next_token_starts_class_definition_p
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_COLON
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE iff the next token is the "," or ">" ending a    template-argument.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_next_token_ends_template_argument_p
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_GREATER
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE iff the n-th token is a "<", or the n-th is a "[" and the    (n+1)-th is a ":" (which is a possible digraph typo for "< ::").  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_nth_token_starts_template_argument_list_p
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_LESS
condition|)
return|return
name|true
return|;
comment|/* Check for the sequence `<::' in the original code. It would be lexed as      `[:', where `[' is a digraph, and there is no whitespace before      `:'.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_SQUARE
operator|&&
name|token
operator|->
name|flags
operator|&
name|DIGRAPH
condition|)
block|{
name|cp_token
modifier|*
name|token2
decl_stmt|;
name|token2
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|token2
operator|->
name|type
operator|==
name|CPP_COLON
operator|&&
operator|!
operator|(
name|token2
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns the kind of tag indicated by TOKEN, if it is a class-key,    or none_type otherwise.  */
end_comment

begin_function
specifier|static
name|enum
name|tag_types
name|cp_parser_token_is_class_key
parameter_list|(
name|cp_token
modifier|*
name|token
parameter_list|)
block|{
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_CLASS
case|:
return|return
name|class_type
return|;
case|case
name|RID_STRUCT
case|:
return|return
name|record_type
return|;
case|case
name|RID_UNION
case|:
return|return
name|union_type
return|;
default|default:
return|return
name|none_type
return|;
block|}
block|}
end_function

begin_comment
comment|/* Issue an error message if the CLASS_KEY does not match the TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_check_class_key
parameter_list|(
name|enum
name|tag_types
name|class_key
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|!=
operator|(
name|class_key
operator|==
name|union_type
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"%qs tag used in naming %q#T"
argument_list|,
name|class_key
operator|==
name|union_type
condition|?
literal|"union"
else|:
name|class_key
operator|==
name|record_type
condition|?
literal|"struct"
else|:
literal|"class"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue an error message if DECL is redeclared with different    access than its original declaration [class.access.spec/3].    This applies to nested classes and nested class templates.    [class.mem/1].  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_check_access_in_redeclaration
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
operator|!=
operator|(
name|current_access_specifier
operator|==
name|access_private_node
operator|)
operator|)
operator|||
operator|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
operator|!=
operator|(
name|current_access_specifier
operator|==
name|access_protected_node
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|"%qD redeclared with different access"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look for the `template' keyword, as a syntactic disambiguator.    Return TRUE iff it is present, in which case it will be    consumed.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_optional_template_keyword
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_TEMPLATE
argument_list|)
condition|)
block|{
comment|/* The `template' keyword can only be used within templates; 	 outside templates the parser can always figure out what is a 	 template and what is not.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|error
argument_list|(
literal|"%<template%> (as a disambiguator) is only allowed "
literal|"within templates"
argument_list|)
expr_stmt|;
comment|/* If this part of the token stream is rescanned, the same 	     error message would be generated.  So, we purge the token 	     from the stream.  */
name|cp_lexer_purge_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* Consume the `template' keyword.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* The next token is a CPP_NESTED_NAME_SPECIFIER.  Consume the token,    set PARSER->SCOPE, and perform other related actions.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_pre_parsed_nested_name_specifier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|tree_check
modifier|*
name|check_value
decl_stmt|;
name|deferred_access_check
modifier|*
name|chk
decl_stmt|;
name|VEC
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|)
operator|*
name|checks
expr_stmt|;
comment|/* Get the stored value.  */
name|check_value
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|u
operator|.
name|tree_check_value
expr_stmt|;
comment|/* Perform any access checks that were deferred.  */
name|checks
operator|=
name|check_value
operator|->
name|checks
expr_stmt|;
if|if
condition|(
name|checks
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|deferred_access_check
argument_list|,
name|checks
argument_list|,
name|i
argument_list|,
name|chk
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|perform_or_defer_access_check
argument_list|(
name|chk
operator|->
name|binfo
argument_list|,
name|chk
operator|->
name|decl
argument_list|,
name|chk
operator|->
name|diag_decl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set the scope from the stored value.  */
name|parser
operator|->
name|scope
operator|=
name|check_value
operator|->
name|value
expr_stmt|;
name|parser
operator|->
name|qualifying_scope
operator|=
name|check_value
operator|->
name|qualifying_scope
expr_stmt|;
name|parser
operator|->
name|object_scope
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Consume tokens up through a non-nested END token.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_cache_group
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|cpp_ttype
name|end
parameter_list|,
name|unsigned
name|depth
parameter_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
name|cp_token
modifier|*
name|token
decl_stmt|;
comment|/* Abort a parenthesized expression if we encounter a brace.  */
if|if
condition|(
operator|(
name|end
operator|==
name|CPP_CLOSE_PAREN
operator|||
name|depth
operator|==
literal|0
operator|)
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
return|return;
comment|/* If we've reached the end of the file, stop.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_EOF
argument_list|)
operator|||
operator|(
name|end
operator|!=
name|CPP_PRAGMA_EOL
operator|&&
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_PRAGMA_EOL
argument_list|)
operator|)
condition|)
return|return;
comment|/* Consume the next token.  */
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* See if it starts a new group.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
condition|)
block|{
name|cp_parser_cache_group
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
name|cp_parser_cache_group
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PRAGMA
condition|)
name|cp_parser_cache_group
argument_list|(
name|parser
argument_list|,
name|CPP_PRAGMA_EOL
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|end
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Begin parsing tentatively.  We always save tokens while parsing    tentatively so that if the tentative parsing fails we can restore the    tokens.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_parse_tentatively
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Enter a new parsing context.  */
name|parser
operator|->
name|context
operator|=
name|cp_parser_context_new
argument_list|(
name|parser
operator|->
name|context
argument_list|)
expr_stmt|;
comment|/* Begin saving tokens.  */
name|cp_lexer_save_tokens
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* In order to avoid repetitive access control error messages,      access checks are queued up until we are no longer parsing      tentatively.  */
name|push_deferring_access_checks
argument_list|(
name|dk_deferred
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Commit to the currently active tentative parse.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_commit_to_tentative_parse
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_parser_context
modifier|*
name|context
decl_stmt|;
name|cp_lexer
modifier|*
name|lexer
decl_stmt|;
comment|/* Mark all of the levels as committed.  */
name|lexer
operator|=
name|parser
operator|->
name|lexer
expr_stmt|;
for|for
control|(
name|context
operator|=
name|parser
operator|->
name|context
init|;
name|context
operator|->
name|next
condition|;
name|context
operator|=
name|context
operator|->
name|next
control|)
block|{
if|if
condition|(
name|context
operator|->
name|status
operator|==
name|CP_PARSER_STATUS_KIND_COMMITTED
condition|)
break|break;
name|context
operator|->
name|status
operator|=
name|CP_PARSER_STATUS_KIND_COMMITTED
expr_stmt|;
while|while
condition|(
operator|!
name|cp_lexer_saving_tokens
argument_list|(
name|lexer
argument_list|)
condition|)
name|lexer
operator|=
name|lexer
operator|->
name|next
expr_stmt|;
name|cp_lexer_commit_tokens
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Abort the currently active tentative parse.  All consumed tokens    will be rolled back, and no diagnostics will be issued.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_abort_tentative_parse
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_parser_simulate_error
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Now, pretend that we want to see if the construct was      successfully parsed.  */
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop parsing tentatively.  If a parse error has occurred, restore the    token stream.  Otherwise, commit to the tokens we have consumed.    Returns true if no error occurred; false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_parse_definitely
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|bool
name|error_occurred
decl_stmt|;
name|cp_parser_context
modifier|*
name|context
decl_stmt|;
comment|/* Remember whether or not an error occurred, since we are about to      destroy that information.  */
name|error_occurred
operator|=
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Remove the topmost context from the stack.  */
name|context
operator|=
name|parser
operator|->
name|context
expr_stmt|;
name|parser
operator|->
name|context
operator|=
name|context
operator|->
name|next
expr_stmt|;
comment|/* If no parse errors occurred, commit to the tentative parse.  */
if|if
condition|(
operator|!
name|error_occurred
condition|)
block|{
comment|/* Commit to the tokens read tentatively, unless that was 	 already done.  */
if|if
condition|(
name|context
operator|->
name|status
operator|!=
name|CP_PARSER_STATUS_KIND_COMMITTED
condition|)
name|cp_lexer_commit_tokens
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|pop_to_parent_deferring_access_checks
argument_list|()
expr_stmt|;
block|}
comment|/* Otherwise, if errors occurred, roll back our state so that things      are just as they were before we began the tentative parse.  */
else|else
block|{
name|cp_lexer_rollback_tokens
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
block|}
comment|/* Add the context to the front of the free list.  */
name|context
operator|->
name|next
operator|=
name|cp_parser_context_free_list
expr_stmt|;
name|cp_parser_context_free_list
operator|=
name|context
expr_stmt|;
return|return
operator|!
name|error_occurred
return|;
block|}
end_function

begin_comment
comment|/* Returns true if we are parsing tentatively and are not committed to    this tentative parse.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_uncommitted_to_tentative_parse_p
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
return|return
operator|(
name|cp_parser_parsing_tentatively
argument_list|(
name|parser
argument_list|)
operator|&&
name|parser
operator|->
name|context
operator|->
name|status
operator|!=
name|CP_PARSER_STATUS_KIND_COMMITTED
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero iff an error has occurred during the most recent    tentative parse.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_error_occurred
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
return|return
operator|(
name|cp_parser_parsing_tentatively
argument_list|(
name|parser
argument_list|)
operator|&&
name|parser
operator|->
name|context
operator|->
name|status
operator|==
name|CP_PARSER_STATUS_KIND_ERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if GNU extensions are allowed.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_allow_gnu_extensions_p
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
return|return
name|parser
operator|->
name|allow_gnu_extensions_p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Objective-C++ Productions */
end_comment

begin_comment
comment|/* Parse an Objective-C expression, which feeds into a primary-expression    above.     objc-expression:      objc-message-expression      objc-string-literal      objc-encode-expression      objc-protocol-expression      objc-selector-expression    Returns a tree representation of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Try to figure out what kind of declaration is present.  */
name|cp_token
modifier|*
name|kwd
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|kwd
operator|->
name|type
condition|)
block|{
case|case
name|CPP_OPEN_SQUARE
case|:
return|return
name|cp_parser_objc_message_expression
argument_list|(
name|parser
argument_list|)
return|;
case|case
name|CPP_OBJC_STRING
case|:
name|kwd
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|objc_build_string_object
argument_list|(
name|kwd
operator|->
name|u
operator|.
name|value
argument_list|)
return|;
case|case
name|CPP_KEYWORD
case|:
switch|switch
condition|(
name|kwd
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_AT_ENCODE
case|:
return|return
name|cp_parser_objc_encode_expression
argument_list|(
name|parser
argument_list|)
return|;
case|case
name|RID_AT_PROTOCOL
case|:
return|return
name|cp_parser_objc_protocol_expression
argument_list|(
name|parser
argument_list|)
return|;
case|case
name|RID_AT_SELECTOR
case|:
return|return
name|cp_parser_objc_selector_expression
argument_list|(
name|parser
argument_list|)
return|;
default|default:
break|break;
block|}
default|default:
name|error
argument_list|(
literal|"misplaced %<@%D%> Objective-C++ construct"
argument_list|,
name|kwd
operator|->
name|u
operator|.
name|value
argument_list|)
expr_stmt|;
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C message expression.     objc-message-expression:      [ objc-message-receiver objc-message-args ]     Returns a representation of an Objective-C message.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_message_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|receiver
decl_stmt|,
name|messageargs
decl_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '['.  */
name|receiver
operator|=
name|cp_parser_objc_message_receiver
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|messageargs
operator|=
name|cp_parser_objc_message_args
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"`]'"
argument_list|)
expr_stmt|;
return|return
name|objc_build_message_expr
argument_list|(
name|build_tree_list
argument_list|(
name|receiver
argument_list|,
name|messageargs
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an objc-message-receiver.     objc-message-receiver:      expression      simple-type-specifier    Returns a representation of the type or expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_message_receiver
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|rcv
decl_stmt|;
comment|/* An Objective-C message receiver may be either (1) a type      or (2) an expression.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|rcv
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|rcv
return|;
name|rcv
operator|=
name|cp_parser_simple_type_specifier
argument_list|(
name|parser
argument_list|,
comment|/*decl_specs=*/
name|NULL
argument_list|,
name|CP_PARSER_FLAGS_NONE
argument_list|)
expr_stmt|;
return|return
name|objc_get_class_reference
argument_list|(
name|rcv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse the arguments and selectors comprising an Objective-C message.     objc-message-args:      objc-selector      objc-selector-args      objc-selector-args , objc-comma-args     objc-selector-args:      objc-selector [opt] : assignment-expression      objc-selector-args objc-selector [opt] : assignment-expression     objc-comma-args:      assignment-expression      objc-comma-args , assignment-expression     Returns a TREE_LIST, with TREE_PURPOSE containing a list of    selector arguments and TREE_VALUE containing a list of comma    arguments.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_message_args
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|sel_args
init|=
name|NULL_TREE
decl_stmt|,
name|addl_args
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|maybe_unary_selector_p
init|=
name|true
decl_stmt|;
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
while|while
condition|(
name|cp_parser_objc_selector_p
argument_list|(
name|token
operator|->
name|type
argument_list|)
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_COLON
condition|)
block|{
name|tree
name|selector
init|=
name|NULL_TREE
decl_stmt|,
name|arg
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_COLON
condition|)
name|selector
operator|=
name|cp_parser_objc_selector
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Detect if we have a unary selector.  */
if|if
condition|(
name|maybe_unary_selector_p
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
return|return
name|build_tree_list
argument_list|(
name|selector
argument_list|,
name|NULL_TREE
argument_list|)
return|;
name|maybe_unary_selector_p
operator|=
name|false
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"`:'"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|sel_args
operator|=
name|chainon
argument_list|(
name|sel_args
argument_list|,
name|build_tree_list
argument_list|(
name|selector
argument_list|,
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
comment|/* Handle non-selector arguments, if any. */
while|while
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
condition|)
block|{
name|tree
name|arg
decl_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|arg
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|addl_args
operator|=
name|chainon
argument_list|(
name|addl_args
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
return|return
name|build_tree_list
argument_list|(
name|sel_args
argument_list|,
name|addl_args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C encode expression.     objc-encode-expression:      @encode objc-typename     Returns an encoded representation of the type argument.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_encode_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '@encode'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
name|type
operator|=
name|complete_type
argument_list|(
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
block|{
name|error
argument_list|(
literal|"%<@encode%> must specify a type as an argument"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|objc_build_encode_expr
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C @defs expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_defs_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '@defs'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
name|name
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
return|return
name|objc_get_class_ivars
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C protocol expression.    objc-protocol-expression:     @protocol ( identifier )    Returns a representation of the protocol expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_protocol_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|proto
decl_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '@protocol'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
name|proto
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
return|return
name|objc_build_protocol_expr
argument_list|(
name|proto
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C selector expression.     objc-selector-expression:      @selector ( objc-method-signature )     objc-method-signature:      objc-selector      objc-selector-seq     objc-selector-seq:      objc-selector :      objc-selector-seq objc-selector :    Returns a representation of the method selector.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_selector_expression
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|sel_seq
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|maybe_unary_selector_p
init|=
name|true
decl_stmt|;
name|cp_token
modifier|*
name|token
decl_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '@selector'.  */
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp_parser_objc_selector_p
argument_list|(
name|token
operator|->
name|type
argument_list|)
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_COLON
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_SCOPE
condition|)
block|{
name|tree
name|selector
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_COLON
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_SCOPE
condition|)
name|selector
operator|=
name|cp_parser_objc_selector
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SCOPE
argument_list|)
condition|)
block|{
comment|/* Detect if we have a unary selector.  */
if|if
condition|(
name|maybe_unary_selector_p
condition|)
block|{
name|sel_seq
operator|=
name|selector
expr_stmt|;
goto|goto
name|finish_selector
goto|;
block|}
else|else
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<:%>"
argument_list|)
expr_stmt|;
block|}
block|}
name|maybe_unary_selector_p
operator|=
name|false
expr_stmt|;
name|token
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_SCOPE
condition|)
block|{
name|sel_seq
operator|=
name|chainon
argument_list|(
name|sel_seq
argument_list|,
name|build_tree_list
argument_list|(
name|selector
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|sel_seq
operator|=
name|chainon
argument_list|(
name|sel_seq
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|sel_seq
operator|=
name|chainon
argument_list|(
name|sel_seq
argument_list|,
name|build_tree_list
argument_list|(
name|selector
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
name|finish_selector
label|:
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
return|return
name|objc_build_selector_expr
argument_list|(
name|sel_seq
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a list of identifiers.     objc-identifier-list:      identifier      objc-identifier-list , identifier     Returns a TREE_LIST of identifier nodes.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_identifier_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|list
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
argument_list|)
decl_stmt|;
name|cp_token
modifier|*
name|sep
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
while|while
condition|(
name|sep
operator|->
name|type
operator|==
name|CPP_COMMA
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat ','.  */
name|list
operator|=
name|chainon
argument_list|(
name|list
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sep
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C alias declaration.     objc-alias-declaration:      @compatibility_alias identifier identifier ;     This function registers the alias mapping with the Objective-C front-end.    It returns nothing.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_objc_alias_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|alias
decl_stmt|,
name|orig
decl_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '@compatibility_alias'.  */
name|alias
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|orig
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|objc_declare_alias
argument_list|(
name|alias
argument_list|,
name|orig
argument_list|)
expr_stmt|;
name|cp_parser_consume_semicolon_at_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C class forward-declaration.     objc-class-declaration:      @class objc-identifier-list ;     The function registers the forward declarations with the Objective-C    front-end.  It returns nothing.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_objc_class_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '@class'.  */
name|objc_declare_class
argument_list|(
name|cp_parser_objc_identifier_list
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
name|cp_parser_consume_semicolon_at_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a list of Objective-C protocol references.     objc-protocol-refs-opt:      objc-protocol-refs [opt]     objc-protocol-refs:< objc-identifier-list>     Returns a TREE_LIST of identifiers, if any.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_protocol_refs_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|protorefs
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_LESS
argument_list|)
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '<'.  */
name|protorefs
operator|=
name|cp_parser_objc_identifier_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_GREATER
argument_list|,
literal|"`>'"
argument_list|)
expr_stmt|;
block|}
return|return
name|protorefs
return|;
block|}
end_function

begin_comment
comment|/* Parse a Objective-C visibility specification.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_objc_visibility_spec
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|vis
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|vis
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_AT_PRIVATE
case|:
name|objc_set_visibility
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_AT_PROTECTED
case|:
name|objc_set_visibility
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_AT_PUBLIC
case|:
name|objc_set_visibility
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return;
block|}
comment|/* Eat '@private'/'@protected'/'@public'.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C method type.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_objc_method_type
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|objc_set_method_type
argument_list|(
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|type
operator|==
name|CPP_PLUS
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C protocol qualifier.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_protocol_qualifiers
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|quals
init|=
name|NULL_TREE
decl_stmt|,
name|node
decl_stmt|;
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
name|node
operator|=
name|token
operator|->
name|u
operator|.
name|value
expr_stmt|;
while|while
condition|(
name|node
operator|&&
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
operator|(
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_IN
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_OUT
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INOUT
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_BYCOPY
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_BYREF
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_ONEWAY
index|]
operator|)
condition|)
block|{
name|quals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|node
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|node
operator|=
name|token
operator|->
name|u
operator|.
name|value
expr_stmt|;
block|}
return|return
name|quals
return|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C typename.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_typename
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|typename
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|tree
name|proto_quals
decl_stmt|,
name|cp_type
init|=
name|NULL_TREE
decl_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '('.  */
name|proto_quals
operator|=
name|cp_parser_objc_protocol_qualifiers
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* An ObjC type name may consist of just protocol qualifiers, in which 	 case the type shall default to 'id'.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|cp_type
operator|=
name|cp_parser_type_id
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
name|typename
operator|=
name|build_tree_list
argument_list|(
name|proto_quals
argument_list|,
name|cp_type
argument_list|)
expr_stmt|;
block|}
return|return
name|typename
return|;
block|}
end_function

begin_comment
comment|/* Check to see if TYPE refers to an Objective-C selector name.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_objc_selector_p
parameter_list|(
name|enum
name|cpp_ttype
name|type
parameter_list|)
block|{
return|return
operator|(
name|type
operator|==
name|CPP_NAME
operator|||
name|type
operator|==
name|CPP_KEYWORD
operator|||
name|type
operator|==
name|CPP_AND_AND
operator|||
name|type
operator|==
name|CPP_AND_EQ
operator|||
name|type
operator|==
name|CPP_AND
operator|||
name|type
operator|==
name|CPP_OR
operator|||
name|type
operator|==
name|CPP_COMPL
operator|||
name|type
operator|==
name|CPP_NOT
operator|||
name|type
operator|==
name|CPP_NOT_EQ
operator|||
name|type
operator|==
name|CPP_OR_OR
operator|||
name|type
operator|==
name|CPP_OR_EQ
operator|||
name|type
operator|==
name|CPP_XOR
operator|||
name|type
operator|==
name|CPP_XOR_EQ
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C selector.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_selector
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cp_parser_objc_selector_p
argument_list|(
name|token
operator|->
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid Objective-C++ selector name"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* C++ operator names are allowed to appear in ObjC selectors.  */
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_AND_AND
case|:
return|return
name|get_identifier
argument_list|(
literal|"and"
argument_list|)
return|;
case|case
name|CPP_AND_EQ
case|:
return|return
name|get_identifier
argument_list|(
literal|"and_eq"
argument_list|)
return|;
case|case
name|CPP_AND
case|:
return|return
name|get_identifier
argument_list|(
literal|"bitand"
argument_list|)
return|;
case|case
name|CPP_OR
case|:
return|return
name|get_identifier
argument_list|(
literal|"bitor"
argument_list|)
return|;
case|case
name|CPP_COMPL
case|:
return|return
name|get_identifier
argument_list|(
literal|"compl"
argument_list|)
return|;
case|case
name|CPP_NOT
case|:
return|return
name|get_identifier
argument_list|(
literal|"not"
argument_list|)
return|;
case|case
name|CPP_NOT_EQ
case|:
return|return
name|get_identifier
argument_list|(
literal|"not_eq"
argument_list|)
return|;
case|case
name|CPP_OR_OR
case|:
return|return
name|get_identifier
argument_list|(
literal|"or"
argument_list|)
return|;
case|case
name|CPP_OR_EQ
case|:
return|return
name|get_identifier
argument_list|(
literal|"or_eq"
argument_list|)
return|;
case|case
name|CPP_XOR
case|:
return|return
name|get_identifier
argument_list|(
literal|"xor"
argument_list|)
return|;
case|case
name|CPP_XOR_EQ
case|:
return|return
name|get_identifier
argument_list|(
literal|"xor_eq"
argument_list|)
return|;
default|default:
return|return
name|token
operator|->
name|u
operator|.
name|value
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an Objective-C params list.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_method_keyword_params
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|params
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|maybe_unary_selector_p
init|=
name|true
decl_stmt|;
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
while|while
condition|(
name|cp_parser_objc_selector_p
argument_list|(
name|token
operator|->
name|type
argument_list|)
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_COLON
condition|)
block|{
name|tree
name|selector
init|=
name|NULL_TREE
decl_stmt|,
name|typename
decl_stmt|,
name|identifier
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_COLON
condition|)
name|selector
operator|=
name|cp_parser_objc_selector
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Detect if we have a unary selector.  */
if|if
condition|(
name|maybe_unary_selector_p
operator|&&
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
return|return
name|selector
return|;
name|maybe_unary_selector_p
operator|=
name|false
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"`:'"
argument_list|)
expr_stmt|;
name|typename
operator|=
name|cp_parser_objc_typename
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|identifier
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|params
operator|=
name|chainon
argument_list|(
name|params
argument_list|,
name|objc_build_keyword_decl
argument_list|(
name|selector
argument_list|,
name|typename
argument_list|,
name|identifier
argument_list|)
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
return|return
name|params
return|;
block|}
end_function

begin_comment
comment|/* Parse the non-keyword Objective-C params.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_method_tail_params_opt
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|bool
modifier|*
name|ellipsisp
parameter_list|)
block|{
name|tree
name|params
init|=
name|make_node
argument_list|(
name|TREE_LIST
argument_list|)
decl_stmt|;
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
operator|*
name|ellipsisp
operator|=
name|false
expr_stmt|;
comment|/* Initially, assume no ellipsis.  */
while|while
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
condition|)
block|{
name|cp_parameter_declarator
modifier|*
name|parmdecl
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat ','.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_ELLIPSIS
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '...'.  */
operator|*
name|ellipsisp
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|parmdecl
operator|=
name|cp_parser_parameter_declaration
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parm
operator|=
name|grokdeclarator
argument_list|(
name|parmdecl
operator|->
name|declarator
argument_list|,
operator|&
name|parmdecl
operator|->
name|decl_specifiers
argument_list|,
name|PARM
argument_list|,
comment|/*initialized=*/
literal|0
argument_list|,
comment|/*attrlist=*/
name|NULL
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|params
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
return|return
name|params
return|;
block|}
end_function

begin_comment
comment|/* Parse a linkage specification, a pragma, an extra semicolon or a block.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_objc_interstitial_code
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
comment|/* If the next token is `extern' and the following token is a string      literal, then we have a linkage specification.  */
if|if
condition|(
name|token
operator|->
name|keyword
operator|==
name|RID_EXTERN
operator|&&
name|cp_parser_is_string_literal
argument_list|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
name|cp_parser_linkage_specification
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Handle #pragma, if any.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PRAGMA
condition|)
name|cp_parser_pragma
argument_list|(
name|parser
argument_list|,
name|pragma_external
argument_list|)
expr_stmt|;
comment|/* Allow stray semicolons.  */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_SEMICOLON
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Finally, try to parse a block-declaration, or a function-definition.  */
else|else
name|cp_parser_block_declaration
argument_list|(
name|parser
argument_list|,
comment|/*statement_p=*/
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a method signature.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_method_signature
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|rettype
decl_stmt|,
name|kwdparms
decl_stmt|,
name|optparms
decl_stmt|;
name|bool
name|ellipsis
init|=
name|false
decl_stmt|;
name|cp_parser_objc_method_type
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|rettype
operator|=
name|cp_parser_objc_typename
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|kwdparms
operator|=
name|cp_parser_objc_method_keyword_params
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|optparms
operator|=
name|cp_parser_objc_method_tail_params_opt
argument_list|(
name|parser
argument_list|,
operator|&
name|ellipsis
argument_list|)
expr_stmt|;
return|return
name|objc_build_method_signature
argument_list|(
name|rettype
argument_list|,
name|kwdparms
argument_list|,
name|optparms
argument_list|,
name|ellipsis
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Pars an Objective-C method prototype list.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_objc_method_prototype_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
while|while
condition|(
name|token
operator|->
name|keyword
operator|!=
name|RID_AT_END
condition|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PLUS
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_MINUS
condition|)
block|{
name|objc_add_method_declaration
argument_list|(
name|cp_parser_objc_method_signature
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
name|cp_parser_consume_semicolon_at_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Allow for interspersed non-ObjC++ code.  */
name|cp_parser_objc_interstitial_code
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '@end'.  */
name|objc_finish_interface
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C method definition list.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_objc_method_definition_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
while|while
condition|(
name|token
operator|->
name|keyword
operator|!=
name|RID_AT_END
condition|)
block|{
name|tree
name|meth
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PLUS
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_MINUS
condition|)
block|{
name|push_deferring_access_checks
argument_list|(
name|dk_deferred
argument_list|)
expr_stmt|;
name|objc_start_method_definition
argument_list|(
name|cp_parser_objc_method_signature
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For historical reasons, we accept an optional semicolon.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|perform_deferred_access_checks
argument_list|()
expr_stmt|;
name|stop_deferring_access_checks
argument_list|()
expr_stmt|;
name|meth
operator|=
name|cp_parser_function_definition_after_declarator
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
name|objc_finish_method_definition
argument_list|(
name|meth
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Allow for interspersed non-ObjC++ code.  */
name|cp_parser_objc_interstitial_code
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '@end'.  */
name|objc_finish_implementation
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse Objective-C ivars.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_objc_class_ivars
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_token
modifier|*
name|token
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_OPEN_BRACE
condition|)
return|return;
comment|/* No ivars specified.  */
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '{'.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
while|while
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_CLOSE_BRACE
condition|)
block|{
name|cp_decl_specifier_seq
name|declspecs
decl_stmt|;
name|int
name|decl_class_or_enum_p
decl_stmt|;
name|tree
name|prefix_attributes
decl_stmt|;
name|cp_parser_objc_visibility_spec
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
break|break;
name|cp_parser_decl_specifier_seq
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_FLAGS_OPTIONAL
argument_list|,
operator|&
name|declspecs
argument_list|,
operator|&
name|decl_class_or_enum_p
argument_list|)
expr_stmt|;
name|prefix_attributes
operator|=
name|declspecs
operator|.
name|attributes
expr_stmt|;
name|declspecs
operator|.
name|attributes
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Keep going until we hit the `;' at the end of the 	 declaration.  */
while|while
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|tree
name|width
init|=
name|NULL_TREE
decl_stmt|,
name|attributes
decl_stmt|,
name|first_attribute
decl_stmt|,
name|decl
decl_stmt|;
name|cp_declarator
modifier|*
name|declarator
init|=
name|NULL
decl_stmt|;
name|int
name|ctor_dtor_or_conv_p
decl_stmt|;
comment|/* Check for a (possibly unnamed) bitfield declaration.  */
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COLON
condition|)
goto|goto
name|eat_colon
goto|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
operator|&&
operator|(
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
operator|->
name|type
operator|==
name|CPP_COLON
operator|)
condition|)
block|{
comment|/* Get the name of the bitfield.  */
name|declarator
operator|=
name|make_id_declarator
argument_list|(
name|NULL_TREE
argument_list|,
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
argument_list|,
name|sfk_none
argument_list|)
expr_stmt|;
name|eat_colon
label|:
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat ':'.  */
comment|/* Get the width of the bitfield.  */
name|width
operator|=
name|cp_parser_constant_expression
argument_list|(
name|parser
argument_list|,
comment|/*allow_non_constant=*/
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Parse the declarator.  */
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_NAMED
argument_list|,
operator|&
name|ctor_dtor_or_conv_p
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|,
comment|/*member_p=*/
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* Look for attributes that apply to the ivar.  */
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Remember which attributes are prefix attributes and 	     which are not.  */
name|first_attribute
operator|=
name|attributes
expr_stmt|;
comment|/* Combine the attributes.  */
name|attributes
operator|=
name|chainon
argument_list|(
name|prefix_attributes
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
condition|)
block|{
comment|/* Create the bitfield declaration.  */
name|decl
operator|=
name|grokbitfield
argument_list|(
name|declarator
argument_list|,
operator|&
name|declspecs
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|cplus_decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attributes
argument_list|,
comment|/*flags=*/
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|decl
operator|=
name|grokfield
argument_list|(
name|declarator
argument_list|,
operator|&
name|declspecs
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*init_const_expr_p=*/
name|false
argument_list|,
name|NULL_TREE
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
comment|/* Add the instance variable.  */
name|objc_add_instance_variable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Reset PREFIX_ATTRIBUTES.  */
while|while
condition|(
name|attributes
operator|&&
name|TREE_CHAIN
argument_list|(
name|attributes
argument_list|)
operator|!=
name|first_attribute
condition|)
name|attributes
operator|=
name|TREE_CHAIN
argument_list|(
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|attributes
condition|)
name|TREE_CHAIN
argument_list|(
name|attributes
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat ','.  */
continue|continue;
block|}
break|break;
block|}
name|cp_parser_consume_semicolon_at_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '}'.  */
comment|/* For historical reasons, we accept an optional semicolon.  */
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C protocol declaration.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_objc_protocol_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|proto
decl_stmt|,
name|protorefs
decl_stmt|;
name|cp_token
modifier|*
name|tok
decl_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '@protocol'.  */
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"identifier expected after %<@protocol%>"
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* See if we have a forward declaration or a definition.  */
name|tok
operator|=
name|cp_lexer_peek_nth_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Try a forward declaration first.  */
if|if
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_COMMA
operator|||
name|tok
operator|->
name|type
operator|==
name|CPP_SEMICOLON
condition|)
block|{
name|objc_declare_protocols
argument_list|(
name|cp_parser_objc_identifier_list
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
name|finish
label|:
name|cp_parser_consume_semicolon_at_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Ok, we got a full-fledged definition (or at least should).  */
else|else
block|{
name|proto
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|protorefs
operator|=
name|cp_parser_objc_protocol_refs_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|objc_start_protocol
argument_list|(
name|proto
argument_list|,
name|protorefs
argument_list|)
expr_stmt|;
name|cp_parser_objc_method_prototype_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an Objective-C superclass or category.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_objc_superclass_or_category
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
modifier|*
name|super
parameter_list|,
name|tree
modifier|*
name|categ
parameter_list|)
block|{
name|cp_token
modifier|*
name|next
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
operator|*
name|super
operator|=
operator|*
name|categ
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|type
operator|==
name|CPP_COLON
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat ':'.  */
operator|*
name|super
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '('.  */
operator|*
name|categ
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an Objective-C class interface.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_objc_class_interface
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|name
decl_stmt|,
name|super
decl_stmt|,
name|categ
decl_stmt|,
name|protos
decl_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '@interface'.  */
name|name
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_objc_superclass_or_category
argument_list|(
name|parser
argument_list|,
operator|&
name|super
argument_list|,
operator|&
name|categ
argument_list|)
expr_stmt|;
name|protos
operator|=
name|cp_parser_objc_protocol_refs_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* We have either a class or a category on our hands.  */
if|if
condition|(
name|categ
condition|)
name|objc_start_category_interface
argument_list|(
name|name
argument_list|,
name|categ
argument_list|,
name|protos
argument_list|)
expr_stmt|;
else|else
block|{
name|objc_start_class_interface
argument_list|(
name|name
argument_list|,
name|super
argument_list|,
name|protos
argument_list|)
expr_stmt|;
comment|/* Handle instance variable declarations, if any.  */
name|cp_parser_objc_class_ivars
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|objc_continue_interface
argument_list|()
expr_stmt|;
block|}
name|cp_parser_objc_method_prototype_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C class implementation.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_objc_class_implementation
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|name
decl_stmt|,
name|super
decl_stmt|,
name|categ
decl_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '@implementation'.  */
name|name
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_objc_superclass_or_category
argument_list|(
name|parser
argument_list|,
operator|&
name|super
argument_list|,
operator|&
name|categ
argument_list|)
expr_stmt|;
comment|/* We have either a class or a category on our hands.  */
if|if
condition|(
name|categ
condition|)
name|objc_start_category_implementation
argument_list|(
name|name
argument_list|,
name|categ
argument_list|)
expr_stmt|;
else|else
block|{
name|objc_start_class_implementation
argument_list|(
name|name
argument_list|,
name|super
argument_list|)
expr_stmt|;
comment|/* Handle instance variable declarations, if any.  */
name|cp_parser_objc_class_ivars
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|objc_continue_implementation
argument_list|()
expr_stmt|;
block|}
name|cp_parser_objc_method_definition_list
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Consume the @end token and finish off the implementation.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_objc_end_implementation
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* Eat '@end'.  */
name|objc_finish_implementation
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C declaration.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_objc_declaration
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Try to figure out what kind of declaration is present.  */
name|cp_token
modifier|*
name|kwd
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|kwd
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_AT_ALIAS
case|:
name|cp_parser_objc_alias_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_AT_CLASS
case|:
name|cp_parser_objc_class_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_AT_PROTOCOL
case|:
name|cp_parser_objc_protocol_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_AT_INTERFACE
case|:
name|cp_parser_objc_class_interface
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_AT_IMPLEMENTATION
case|:
name|cp_parser_objc_class_implementation
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_AT_END
case|:
name|cp_parser_objc_end_implementation
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"misplaced %<@%D%> Objective-C++ construct"
argument_list|,
name|kwd
operator|->
name|u
operator|.
name|value
argument_list|)
expr_stmt|;
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an Objective-C try-catch-finally statement.     objc-try-catch-finally-stmt:      @try compound-statement objc-catch-clause-seq [opt]        objc-finally-clause [opt]     objc-catch-clause-seq:      objc-catch-clause objc-catch-clause-seq [opt]     objc-catch-clause:      @catch ( exception-declaration ) compound-statement     objc-finally-clause      @finally compound-statement     Returns NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_try_catch_finally_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|location_t
name|location
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_TRY
argument_list|,
literal|"`@try'"
argument_list|)
expr_stmt|;
name|location
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|location
expr_stmt|;
comment|/* NB: The @try block needs to be wrapped in its own STATEMENT_LIST      node, lest it get absorbed into the surrounding block.  */
name|stmt
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|objc_begin_try_stmt
argument_list|(
name|location
argument_list|,
name|pop_stmt_list
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_AT_CATCH
argument_list|)
condition|)
block|{
name|cp_parameter_declarator
modifier|*
name|parmdecl
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
name|parmdecl
operator|=
name|cp_parser_parameter_declaration
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parm
operator|=
name|grokdeclarator
argument_list|(
name|parmdecl
operator|->
name|declarator
argument_list|,
operator|&
name|parmdecl
operator|->
name|decl_specifiers
argument_list|,
name|PARM
argument_list|,
comment|/*initialized=*/
literal|0
argument_list|,
comment|/*attrlist=*/
name|NULL
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
name|objc_begin_catch_clause
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|objc_finish_catch_clause
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_AT_FINALLY
argument_list|)
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|location
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|location
expr_stmt|;
comment|/* NB: The @finally block needs to be wrapped in its own STATEMENT_LIST 	 node, lest it get absorbed into the surrounding block.  */
name|stmt
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|objc_build_finally_clause
argument_list|(
name|location
argument_list|,
name|pop_stmt_list
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|objc_finish_try_stmt
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C synchronized statement.     objc-synchronized-stmt:      @synchronized ( expression ) compound-statement     Returns NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_synchronized_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|location_t
name|location
decl_stmt|;
name|tree
name|lock
decl_stmt|,
name|stmt
decl_stmt|;
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_SYNCHRONIZED
argument_list|,
literal|"`@synchronized'"
argument_list|)
expr_stmt|;
name|location
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|location
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
expr_stmt|;
name|lock
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
expr_stmt|;
comment|/* NB: The @synchronized block needs to be wrapped in its own STATEMENT_LIST      node, lest it get absorbed into the surrounding block.  */
name|stmt
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
name|cp_parser_compound_statement
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|objc_build_synchronized
argument_list|(
name|location
argument_list|,
name|lock
argument_list|,
name|pop_stmt_list
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C throw statement.     objc-throw-stmt:      @throw assignment-expression [opt] ;     Returns a constructed '@throw' statement.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_throw_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|expr
init|=
name|NULL_TREE
decl_stmt|;
name|cp_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_THROW
argument_list|,
literal|"`@throw'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|expr
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|cp_parser_consume_semicolon_at_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|objc_build_throw_stmt
argument_list|(
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an Objective-C statement.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_objc_statement
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Try to figure out what kind of declaration is present.  */
name|cp_token
modifier|*
name|kwd
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|kwd
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_AT_TRY
case|:
return|return
name|cp_parser_objc_try_catch_finally_statement
argument_list|(
name|parser
argument_list|)
return|;
case|case
name|RID_AT_SYNCHRONIZED
case|:
return|return
name|cp_parser_objc_synchronized_statement
argument_list|(
name|parser
argument_list|)
return|;
case|case
name|RID_AT_THROW
case|:
return|return
name|cp_parser_objc_throw_statement
argument_list|(
name|parser
argument_list|)
return|;
default|default:
name|error
argument_list|(
literal|"misplaced %<@%D%> Objective-C++ construct"
argument_list|,
name|kwd
operator|->
name|u
operator|.
name|value
argument_list|)
expr_stmt|;
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* OpenMP 2.5 parsing routines.  */
end_comment

begin_comment
comment|/* All OpenMP clauses.  OpenMP 2.5.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|pragma_omp_clause
block|{
name|PRAGMA_OMP_CLAUSE_NONE
init|=
literal|0
block|,
name|PRAGMA_OMP_CLAUSE_COPYIN
block|,
name|PRAGMA_OMP_CLAUSE_COPYPRIVATE
block|,
name|PRAGMA_OMP_CLAUSE_DEFAULT
block|,
name|PRAGMA_OMP_CLAUSE_FIRSTPRIVATE
block|,
name|PRAGMA_OMP_CLAUSE_IF
block|,
name|PRAGMA_OMP_CLAUSE_LASTPRIVATE
block|,
name|PRAGMA_OMP_CLAUSE_NOWAIT
block|,
name|PRAGMA_OMP_CLAUSE_NUM_THREADS
block|,
name|PRAGMA_OMP_CLAUSE_ORDERED
block|,
name|PRAGMA_OMP_CLAUSE_PRIVATE
block|,
name|PRAGMA_OMP_CLAUSE_REDUCTION
block|,
name|PRAGMA_OMP_CLAUSE_SCHEDULE
block|,
name|PRAGMA_OMP_CLAUSE_SHARED
block|}
name|pragma_omp_clause
typedef|;
end_typedef

begin_comment
comment|/* Returns name of the next clause.    If the clause is not recognized PRAGMA_OMP_CLAUSE_NONE is returned and    the token is not consumed.  Otherwise appropriate pragma_omp_clause is    returned and the token is consumed.  */
end_comment

begin_function
specifier|static
name|pragma_omp_clause
name|cp_parser_omp_clause_name
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|pragma_omp_clause
name|result
init|=
name|PRAGMA_OMP_CLAUSE_NONE
decl_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_IF
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_IF
expr_stmt|;
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_DEFAULT
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_DEFAULT
expr_stmt|;
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_PRIVATE
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_PRIVATE
expr_stmt|;
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|tree
name|id
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|u
operator|.
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'c'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"copyin"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_COPYIN
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"copyprivate"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_COPYPRIVATE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"firstprivate"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_FIRSTPRIVATE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"lastprivate"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_LASTPRIVATE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"nowait"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_NOWAIT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"num_threads"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_NUM_THREADS
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"ordered"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_ORDERED
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"reduction"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_REDUCTION
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"schedule"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_SCHEDULE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"shared"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_SHARED
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|result
operator|!=
name|PRAGMA_OMP_CLAUSE_NONE
condition|)
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Validate that a clause of the given type does not already exist.  */
end_comment

begin_function
specifier|static
name|void
name|check_no_duplicate_clause
parameter_list|(
name|tree
name|clauses
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|tree
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|clauses
init|;
name|c
condition|;
name|c
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
if|if
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|code
condition|)
block|{
name|error
argument_list|(
literal|"too many %qs clauses"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    variable-list:      identifier      variable-list , identifier     In addition, we match a closing parenthesis.  An opening parenthesis    will have been consumed by the caller.     If KIND is nonzero, create the appropriate node and install the decl    in OMP_CLAUSE_DECL and add the node to the head of the list.     If KIND is zero, create a TREE_LIST with the decl in TREE_PURPOSE;    return the list created.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_omp_var_list_no_open
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|omp_clause_code
name|kind
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|name
decl_stmt|,
name|decl
decl_stmt|;
name|name
operator|=
name|cp_parser_id_expression
argument_list|(
name|parser
argument_list|,
comment|/*template_p=*/
name|false
argument_list|,
comment|/*check_dependency_p=*/
name|true
argument_list|,
comment|/*template_p=*/
name|NULL
argument_list|,
comment|/*declarator_p=*/
name|false
argument_list|,
comment|/*optional_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
goto|goto
name|skip_comma
goto|;
name|decl
operator|=
name|cp_parser_lookup_name_simple
argument_list|(
name|parser
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
name|cp_parser_name_lookup_error
argument_list|(
name|parser
argument_list|,
name|name
argument_list|,
name|decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|!=
literal|0
condition|)
block|{
name|tree
name|u
init|=
name|build_omp_clause
argument_list|(
name|kind
argument_list|)
decl_stmt|;
name|OMP_CLAUSE_DECL
argument_list|(
name|u
argument_list|)
operator|=
name|decl
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|u
argument_list|)
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|u
expr_stmt|;
block|}
else|else
name|list
operator|=
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|get_comma
label|:
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
block|{
name|int
name|ending
decl_stmt|;
comment|/* Try to resync to an unnested comma.  Copied from 	 cp_parser_parenthesized_expression_list.  */
name|skip_comma
label|:
name|ending
operator|=
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
comment|/*recovering=*/
name|true
argument_list|,
comment|/*or_comma=*/
name|true
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ending
operator|<
literal|0
condition|)
goto|goto
name|get_comma
goto|;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Similarly, but expect leading and trailing parenthesis.  This is a very    common case for omp clauses.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_omp_var_list
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|omp_clause_code
name|kind
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
if|if
condition|(
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
condition|)
return|return
name|cp_parser_omp_var_list_no_open
argument_list|(
name|parser
argument_list|,
name|kind
argument_list|,
name|list
argument_list|)
return|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    default ( shared | none ) */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_omp_clause_default
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|enum
name|omp_clause_default_kind
name|kind
init|=
name|OMP_CLAUSE_DEFAULT_UNSPECIFIED
decl_stmt|;
name|tree
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
condition|)
return|return
name|list
return|;
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|tree
name|id
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|u
operator|.
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'n'
case|:
if|if
condition|(
name|strcmp
argument_list|(
literal|"none"
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|invalid_kind
goto|;
name|kind
operator|=
name|OMP_CLAUSE_DEFAULT_NONE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
literal|"shared"
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|invalid_kind
goto|;
name|kind
operator|=
name|OMP_CLAUSE_DEFAULT_SHARED
expr_stmt|;
break|break;
default|default:
goto|goto
name|invalid_kind
goto|;
block|}
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|invalid_kind
label|:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<none%> or %<shared%>"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
comment|/*recovering=*/
name|true
argument_list|,
comment|/*or_comma=*/
name|false
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|OMP_CLAUSE_DEFAULT_UNSPECIFIED
condition|)
return|return
name|list
return|;
name|check_no_duplicate_clause
argument_list|(
name|list
argument_list|,
name|OMP_CLAUSE_DEFAULT
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
name|c
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_DEFAULT
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
operator|=
name|list
expr_stmt|;
name|OMP_CLAUSE_DEFAULT_KIND
argument_list|(
name|c
argument_list|)
operator|=
name|kind
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    if ( expression ) */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_omp_clause_if
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
condition|)
return|return
name|list
return|;
name|t
operator|=
name|cp_parser_condition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
operator|||
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
comment|/*recovering=*/
name|true
argument_list|,
comment|/*or_comma=*/
name|false
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
name|check_no_duplicate_clause
argument_list|(
name|list
argument_list|,
name|OMP_CLAUSE_IF
argument_list|,
literal|"if"
argument_list|)
expr_stmt|;
name|c
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_IF
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_IF_EXPR
argument_list|(
name|c
argument_list|)
operator|=
name|t
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
operator|=
name|list
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    nowait */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_omp_clause_nowait
parameter_list|(
name|cp_parser
modifier|*
name|parser
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|c
decl_stmt|;
name|check_no_duplicate_clause
argument_list|(
name|list
argument_list|,
name|OMP_CLAUSE_NOWAIT
argument_list|,
literal|"nowait"
argument_list|)
expr_stmt|;
name|c
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_NOWAIT
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
operator|=
name|list
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    num_threads ( expression ) */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_omp_clause_num_threads
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
condition|)
return|return
name|list
return|;
name|t
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
operator|||
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
comment|/*recovering=*/
name|true
argument_list|,
comment|/*or_comma=*/
name|false
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
name|check_no_duplicate_clause
argument_list|(
name|list
argument_list|,
name|OMP_CLAUSE_NUM_THREADS
argument_list|,
literal|"num_threads"
argument_list|)
expr_stmt|;
name|c
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_NUM_THREADS
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_NUM_THREADS_EXPR
argument_list|(
name|c
argument_list|)
operator|=
name|t
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
operator|=
name|list
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    ordered */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_omp_clause_ordered
parameter_list|(
name|cp_parser
modifier|*
name|parser
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|c
decl_stmt|;
name|check_no_duplicate_clause
argument_list|(
name|list
argument_list|,
name|OMP_CLAUSE_ORDERED
argument_list|,
literal|"ordered"
argument_list|)
expr_stmt|;
name|c
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_ORDERED
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
operator|=
name|list
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    reduction ( reduction-operator : variable-list )     reduction-operator:      One of: + * -& ^ |&& || */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_omp_clause_reduction
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|nlist
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
condition|)
return|return
name|list
return|;
switch|switch
condition|(
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|type
condition|)
block|{
case|case
name|CPP_PLUS
case|:
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MULT
case|:
name|code
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MINUS
case|:
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_AND
case|:
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_XOR
case|:
name|code
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_OR
case|:
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_AND_AND
case|:
name|code
operator|=
name|TRUTH_ANDIF_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_OR_OR
case|:
name|code
operator|=
name|TRUTH_ORIF_EXPR
expr_stmt|;
break|break;
default|default:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"`+', `*', `-', `&', `^', `|', `&&', or `||'"
argument_list|)
expr_stmt|;
name|resync_fail
label|:
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
comment|/*recovering=*/
name|true
argument_list|,
comment|/*or_comma=*/
name|false
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"`:'"
argument_list|)
condition|)
goto|goto
name|resync_fail
goto|;
name|nlist
operator|=
name|cp_parser_omp_var_list_no_open
argument_list|(
name|parser
argument_list|,
name|OMP_CLAUSE_REDUCTION
argument_list|,
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|nlist
init|;
name|c
operator|!=
name|list
condition|;
name|c
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
name|OMP_CLAUSE_REDUCTION_CODE
argument_list|(
name|c
argument_list|)
operator|=
name|code
expr_stmt|;
return|return
name|nlist
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    schedule ( schedule-kind )    schedule ( schedule-kind , expression )     schedule-kind:      static | dynamic | guided | runtime  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_omp_clause_schedule
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|c
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
return|return
name|list
return|;
name|c
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_SCHEDULE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|tree
name|id
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|u
operator|.
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'d'
case|:
if|if
condition|(
name|strcmp
argument_list|(
literal|"dynamic"
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|invalid_kind
goto|;
name|OMP_CLAUSE_SCHEDULE_KIND
argument_list|(
name|c
argument_list|)
operator|=
name|OMP_CLAUSE_SCHEDULE_DYNAMIC
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|strcmp
argument_list|(
literal|"guided"
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|invalid_kind
goto|;
name|OMP_CLAUSE_SCHEDULE_KIND
argument_list|(
name|c
argument_list|)
operator|=
name|OMP_CLAUSE_SCHEDULE_GUIDED
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strcmp
argument_list|(
literal|"runtime"
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|invalid_kind
goto|;
name|OMP_CLAUSE_SCHEDULE_KIND
argument_list|(
name|c
argument_list|)
operator|=
name|OMP_CLAUSE_SCHEDULE_RUNTIME
expr_stmt|;
break|break;
default|default:
goto|goto
name|invalid_kind
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_STATIC
argument_list|)
condition|)
name|OMP_CLAUSE_SCHEDULE_KIND
argument_list|(
name|c
argument_list|)
operator|=
name|OMP_CLAUSE_SCHEDULE_STATIC
expr_stmt|;
else|else
goto|goto
name|invalid_kind
goto|;
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|t
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
goto|goto
name|resync_fail
goto|;
elseif|else
if|if
condition|(
name|OMP_CLAUSE_SCHEDULE_KIND
argument_list|(
name|c
argument_list|)
operator|==
name|OMP_CLAUSE_SCHEDULE_RUNTIME
condition|)
name|error
argument_list|(
literal|"schedule %<runtime%> does not take "
literal|"a %<chunk_size%> parameter"
argument_list|)
expr_stmt|;
else|else
name|OMP_CLAUSE_SCHEDULE_CHUNK_EXPR
argument_list|(
name|c
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
goto|goto
name|resync_fail
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`,' or `)'"
argument_list|)
condition|)
goto|goto
name|resync_fail
goto|;
name|check_no_duplicate_clause
argument_list|(
name|list
argument_list|,
name|OMP_CLAUSE_SCHEDULE
argument_list|,
literal|"schedule"
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
operator|=
name|list
expr_stmt|;
return|return
name|c
return|;
name|invalid_kind
label|:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"invalid schedule kind"
argument_list|)
expr_stmt|;
name|resync_fail
label|:
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
comment|/*recovering=*/
name|true
argument_list|,
comment|/*or_comma=*/
name|false
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Parse all OpenMP clauses.  The set clauses allowed by the directive    is a bitmask in MASK.  Return the list of clauses found; the result    of clause default goes in *pdefault.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_omp_all_clauses
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|unsigned
name|int
name|mask
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|,
name|cp_token
modifier|*
name|pragma_tok
parameter_list|)
block|{
name|tree
name|clauses
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_PRAGMA_EOL
argument_list|)
condition|)
block|{
name|pragma_omp_clause
name|c_kind
init|=
name|cp_parser_omp_clause_name
argument_list|(
name|parser
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_name
decl_stmt|;
name|tree
name|prev
init|=
name|clauses
decl_stmt|;
switch|switch
condition|(
name|c_kind
condition|)
block|{
case|case
name|PRAGMA_OMP_CLAUSE_COPYIN
case|:
name|clauses
operator|=
name|cp_parser_omp_var_list
argument_list|(
name|parser
argument_list|,
name|OMP_CLAUSE_COPYIN
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"copyin"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_COPYPRIVATE
case|:
name|clauses
operator|=
name|cp_parser_omp_var_list
argument_list|(
name|parser
argument_list|,
name|OMP_CLAUSE_COPYPRIVATE
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"copyprivate"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_DEFAULT
case|:
name|clauses
operator|=
name|cp_parser_omp_clause_default
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"default"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_FIRSTPRIVATE
case|:
name|clauses
operator|=
name|cp_parser_omp_var_list
argument_list|(
name|parser
argument_list|,
name|OMP_CLAUSE_FIRSTPRIVATE
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"firstprivate"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_IF
case|:
name|clauses
operator|=
name|cp_parser_omp_clause_if
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"if"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_LASTPRIVATE
case|:
name|clauses
operator|=
name|cp_parser_omp_var_list
argument_list|(
name|parser
argument_list|,
name|OMP_CLAUSE_LASTPRIVATE
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"lastprivate"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_NOWAIT
case|:
name|clauses
operator|=
name|cp_parser_omp_clause_nowait
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"nowait"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_NUM_THREADS
case|:
name|clauses
operator|=
name|cp_parser_omp_clause_num_threads
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"num_threads"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_ORDERED
case|:
name|clauses
operator|=
name|cp_parser_omp_clause_ordered
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"ordered"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_PRIVATE
case|:
name|clauses
operator|=
name|cp_parser_omp_var_list
argument_list|(
name|parser
argument_list|,
name|OMP_CLAUSE_PRIVATE
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"private"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_REDUCTION
case|:
name|clauses
operator|=
name|cp_parser_omp_clause_reduction
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"reduction"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_SCHEDULE
case|:
name|clauses
operator|=
name|cp_parser_omp_clause_schedule
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"schedule"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_SHARED
case|:
name|clauses
operator|=
name|cp_parser_omp_var_list
argument_list|(
name|parser
argument_list|,
name|OMP_CLAUSE_SHARED
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"shared"
expr_stmt|;
break|break;
default|default:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<#pragma omp%> clause"
argument_list|)
expr_stmt|;
goto|goto
name|saw_error
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|mask
operator|>>
name|c_kind
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Remove the invalid clause(s) from the list to avoid 	     confusing the rest of the compiler.  */
name|clauses
operator|=
name|prev
expr_stmt|;
name|error
argument_list|(
literal|"%qs is not valid for %qs"
argument_list|,
name|c_name
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
block|}
name|saw_error
label|:
name|cp_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
return|return
name|finish_omp_clauses
argument_list|(
name|clauses
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    structured-block:      statement     In practice, we're also interested in adding the statement to an    outer node.  So it is convenient if we work around the fact that    cp_parser_statement calls add_stmt.  */
end_comment

begin_function
specifier|static
name|unsigned
name|cp_parser_begin_omp_structured_block
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|unsigned
name|save
init|=
name|parser
operator|->
name|in_statement
decl_stmt|;
comment|/* Only move the values to IN_OMP_BLOCK if they weren't false.      This preserves the "not within loop or switch" style error messages      for nonsense cases like 	void foo() { 	#pragma omp single 	  break; 	}   */
if|if
condition|(
name|parser
operator|->
name|in_statement
condition|)
name|parser
operator|->
name|in_statement
operator|=
name|IN_OMP_BLOCK
expr_stmt|;
return|return
name|save
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cp_parser_end_omp_structured_block
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|unsigned
name|save
parameter_list|)
block|{
name|parser
operator|->
name|in_statement
operator|=
name|save
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|cp_parser_omp_structured_block
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|begin_omp_structured_block
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|save
init|=
name|cp_parser_begin_omp_structured_block
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|cp_parser_statement
argument_list|(
name|parser
argument_list|,
name|NULL_TREE
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cp_parser_end_omp_structured_block
argument_list|(
name|parser
argument_list|,
name|save
argument_list|)
expr_stmt|;
return|return
name|finish_omp_structured_block
argument_list|(
name|stmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp atomic new-line      expression-stmt     expression-stmt:      x binop= expr | x++ | ++x | x-- | --x    binop:      +, *, -, /,&, ^, |,<<,>>    where x is an lvalue expression with scalar type.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_omp_atomic
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token
modifier|*
name|pragma_tok
parameter_list|)
block|{
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|cp_parser_require_pragma_eol
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|cp_parser_unary_expression
argument_list|(
name|parser
argument_list|,
comment|/*address_p=*/
name|false
argument_list|,
comment|/*cast_p=*/
name|false
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
goto|goto
name|saw_error
goto|;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
name|rhs
operator|=
name|integer_one_node
expr_stmt|;
break|break;
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
name|rhs
operator|=
name|integer_one_node
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|type
condition|)
block|{
case|case
name|CPP_MULT_EQ
case|:
name|code
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_DIV_EQ
case|:
name|code
operator|=
name|TRUNC_DIV_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_PLUS_EQ
case|:
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MINUS_EQ
case|:
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_LSHIFT_EQ
case|:
name|code
operator|=
name|LSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_RSHIFT_EQ
case|:
name|code
operator|=
name|RSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_AND_EQ
case|:
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_OR_EQ
case|:
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_XOR_EQ
case|:
name|code
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
break|break;
default|default:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"invalid operator for %<#pragma omp atomic%>"
argument_list|)
expr_stmt|;
goto|goto
name|saw_error
goto|;
block|}
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
condition|)
goto|goto
name|saw_error
goto|;
break|break;
block|}
name|finish_omp_atomic
argument_list|(
name|code
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|cp_parser_consume_semicolon_at_end_of_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return;
name|saw_error
label|:
name|cp_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp barrier new-line  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_omp_barrier
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token
modifier|*
name|pragma_tok
parameter_list|)
block|{
name|cp_parser_require_pragma_eol
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
name|finish_omp_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp critical [(name)] new-line      structured-block  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_omp_critical
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token
modifier|*
name|pragma_tok
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|name
operator|=
name|cp_parser_identifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|error_mark_node
operator|||
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
comment|/*recovering=*/
name|true
argument_list|,
comment|/*or_comma=*/
name|false
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
name|name
operator|=
name|NULL
expr_stmt|;
block|}
name|cp_parser_require_pragma_eol
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|cp_parser_omp_structured_block
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|c_finish_omp_critical
argument_list|(
name|stmt
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp flush flush-vars[opt] new-line     flush-vars:      ( variable-list ) */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_omp_flush
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token
modifier|*
name|pragma_tok
parameter_list|)
block|{
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
operator|(
name|void
operator|)
name|cp_parser_omp_var_list
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cp_parser_require_pragma_eol
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
name|finish_omp_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the restricted form of the for statment allowed by OpenMP.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_omp_for_loop
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|init
decl_stmt|,
name|cond
decl_stmt|,
name|incr
decl_stmt|,
name|body
decl_stmt|,
name|decl
decl_stmt|,
name|pre_body
decl_stmt|;
name|location_t
name|loc
decl_stmt|;
if|if
condition|(
operator|!
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_FOR
argument_list|)
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"for statement expected"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|loc
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|location
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"`('"
argument_list|)
condition|)
return|return
name|NULL
return|;
name|init
operator|=
name|decl
operator|=
name|NULL
expr_stmt|;
name|pre_body
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|cp_decl_specifier_seq
name|type_specifiers
decl_stmt|;
comment|/* First, try to parse as an initialized declaration.  See 	 cp_parser_condition, from whence the bulk of this is copied.  */
name|cp_parser_parse_tentatively
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_type_specifier_seq
argument_list|(
name|parser
argument_list|,
comment|/*is_condition=*/
name|false
argument_list|,
operator|&
name|type_specifiers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_error_occurred
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|tree
name|asm_specification
decl_stmt|,
name|attributes
decl_stmt|;
name|cp_declarator
modifier|*
name|declarator
decl_stmt|;
name|declarator
operator|=
name|cp_parser_declarator
argument_list|(
name|parser
argument_list|,
name|CP_PARSER_DECLARATOR_NAMED
argument_list|,
comment|/*ctor_dtor_or_conv_p=*/
name|NULL
argument_list|,
comment|/*parenthesized_p=*/
name|NULL
argument_list|,
comment|/*member_p=*/
name|false
argument_list|)
expr_stmt|;
name|attributes
operator|=
name|cp_parser_attributes_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|asm_specification
operator|=
name|cp_parser_asm_specification_opt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_EQ
argument_list|,
literal|"`='"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_parser_parse_definitely
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|tree
name|pushed_scope
decl_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
operator|&
name|type_specifiers
argument_list|,
comment|/*initialized_p=*/
name|false
argument_list|,
name|attributes
argument_list|,
comment|/*prefix_attributes=*/
name|NULL_TREE
argument_list|,
operator|&
name|pushed_scope
argument_list|)
expr_stmt|;
name|init
operator|=
name|cp_parser_assignment_expression
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*init_const_expr_p=*/
name|false
argument_list|,
name|asm_specification
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
if|if
condition|(
name|pushed_scope
condition|)
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|cp_parser_abort_tentative_parse
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If parsing as an initialized declaration failed, try again as 	 a simple expression.  */
if|if
condition|(
name|decl
operator|==
name|NULL
condition|)
name|init
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
name|pre_body
operator|=
name|pop_stmt_list
argument_list|(
name|pre_body
argument_list|)
expr_stmt|;
name|cond
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|cond
operator|=
name|cp_parser_condition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"`;'"
argument_list|)
expr_stmt|;
name|incr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is_not
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|incr
operator|=
name|cp_parser_expression
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"`)'"
argument_list|)
condition|)
name|cp_parser_skip_to_closing_parenthesis
argument_list|(
name|parser
argument_list|,
comment|/*recovering=*/
name|true
argument_list|,
comment|/*or_comma=*/
name|false
argument_list|,
comment|/*consume_paren=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Note that we saved the original contents of this flag when we entered      the structured block, and so we don't need to re-save it here.  */
name|parser
operator|->
name|in_statement
operator|=
name|IN_OMP_FOR
expr_stmt|;
comment|/* Note that the grammar doesn't call for a structured block here,      though the loop as a whole is a structured block.  */
name|body
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
name|cp_parser_statement
argument_list|(
name|parser
argument_list|,
name|NULL_TREE
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|body
operator|=
name|pop_stmt_list
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|finish_omp_for
argument_list|(
name|loc
argument_list|,
name|decl
argument_list|,
name|init
argument_list|,
name|cond
argument_list|,
name|incr
argument_list|,
name|body
argument_list|,
name|pre_body
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    #pragma omp for for-clause[optseq] new-line      for-loop  */
end_comment

begin_define
define|#
directive|define
name|OMP_FOR_CLAUSE_MASK
define|\
value|( (1u<< PRAGMA_OMP_CLAUSE_PRIVATE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)	\ 	| (1u<< PRAGMA_OMP_CLAUSE_LASTPRIVATE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_REDUCTION)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_ORDERED)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_SCHEDULE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_NOWAIT))
end_define

begin_function
specifier|static
name|tree
name|cp_parser_omp_for
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token
modifier|*
name|pragma_tok
parameter_list|)
block|{
name|tree
name|clauses
decl_stmt|,
name|sb
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|int
name|save
decl_stmt|;
name|clauses
operator|=
name|cp_parser_omp_all_clauses
argument_list|(
name|parser
argument_list|,
name|OMP_FOR_CLAUSE_MASK
argument_list|,
literal|"#pragma omp for"
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
name|sb
operator|=
name|begin_omp_structured_block
argument_list|()
expr_stmt|;
name|save
operator|=
name|cp_parser_begin_omp_structured_block
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cp_parser_omp_for_loop
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|OMP_FOR_CLAUSES
argument_list|(
name|ret
argument_list|)
operator|=
name|clauses
expr_stmt|;
name|cp_parser_end_omp_structured_block
argument_list|(
name|parser
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|finish_omp_structured_block
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp master new-line      structured-block  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_omp_master
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token
modifier|*
name|pragma_tok
parameter_list|)
block|{
name|cp_parser_require_pragma_eol
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
return|return
name|c_finish_omp_master
argument_list|(
name|cp_parser_omp_structured_block
argument_list|(
name|parser
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp ordered new-line      structured-block  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_omp_ordered
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token
modifier|*
name|pragma_tok
parameter_list|)
block|{
name|cp_parser_require_pragma_eol
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
return|return
name|c_finish_omp_ordered
argument_list|(
name|cp_parser_omp_structured_block
argument_list|(
name|parser
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:     section-scope:      { section-sequence }     section-sequence:      section-directive[opt] structured-block      section-sequence section-directive structured-block  */
end_comment

begin_function
specifier|static
name|tree
name|cp_parser_omp_sections_scope
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|substmt
decl_stmt|;
name|bool
name|error_suppress
init|=
name|false
decl_stmt|;
name|cp_token
modifier|*
name|tok
decl_stmt|;
if|if
condition|(
operator|!
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|,
literal|"`{'"
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|stmt
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|pragma_kind
operator|!=
name|PRAGMA_OMP_SECTION
condition|)
block|{
name|unsigned
name|save
decl_stmt|;
name|substmt
operator|=
name|begin_omp_structured_block
argument_list|()
expr_stmt|;
name|save
operator|=
name|cp_parser_begin_omp_structured_block
argument_list|(
name|parser
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|cp_parser_statement
argument_list|(
name|parser
argument_list|,
name|NULL_TREE
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tok
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|->
name|pragma_kind
operator|==
name|PRAGMA_OMP_SECTION
condition|)
break|break;
if|if
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
condition|)
break|break;
if|if
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
block|}
name|cp_parser_end_omp_structured_block
argument_list|(
name|parser
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|substmt
operator|=
name|finish_omp_structured_block
argument_list|(
name|substmt
argument_list|)
expr_stmt|;
name|substmt
operator|=
name|build1
argument_list|(
name|OMP_SECTION
argument_list|,
name|void_type_node
argument_list|,
name|substmt
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|substmt
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|tok
operator|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
condition|)
break|break;
if|if
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
if|if
condition|(
name|tok
operator|->
name|pragma_kind
operator|==
name|PRAGMA_OMP_SECTION
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|cp_parser_require_pragma_eol
argument_list|(
name|parser
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|error_suppress
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|error_suppress
condition|)
block|{
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<#pragma omp section%> or %<}%>"
argument_list|)
expr_stmt|;
name|error_suppress
operator|=
name|true
expr_stmt|;
block|}
name|substmt
operator|=
name|cp_parser_omp_structured_block
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|substmt
operator|=
name|build1
argument_list|(
name|OMP_SECTION
argument_list|,
name|void_type_node
argument_list|,
name|substmt
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|substmt
argument_list|)
expr_stmt|;
block|}
name|cp_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"`}'"
argument_list|)
expr_stmt|;
name|substmt
operator|=
name|pop_stmt_list
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|make_node
argument_list|(
name|OMP_SECTIONS
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|OMP_SECTIONS_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|substmt
expr_stmt|;
name|add_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
return|return
name|stmt
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp sections sections-clause[optseq] newline      sections-scope  */
end_comment

begin_define
define|#
directive|define
name|OMP_SECTIONS_CLAUSE_MASK
define|\
value|( (1u<< PRAGMA_OMP_CLAUSE_PRIVATE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)	\ 	| (1u<< PRAGMA_OMP_CLAUSE_LASTPRIVATE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_REDUCTION)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_NOWAIT))
end_define

begin_function
specifier|static
name|tree
name|cp_parser_omp_sections
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token
modifier|*
name|pragma_tok
parameter_list|)
block|{
name|tree
name|clauses
decl_stmt|,
name|ret
decl_stmt|;
name|clauses
operator|=
name|cp_parser_omp_all_clauses
argument_list|(
name|parser
argument_list|,
name|OMP_SECTIONS_CLAUSE_MASK
argument_list|,
literal|"#pragma omp sections"
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cp_parser_omp_sections_scope
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|OMP_SECTIONS_CLAUSES
argument_list|(
name|ret
argument_list|)
operator|=
name|clauses
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma parallel parallel-clause new-line    # pragma parallel for parallel-for-clause new-line    # pragma parallel sections parallel-sections-clause new-line  */
end_comment

begin_define
define|#
directive|define
name|OMP_PARALLEL_CLAUSE_MASK
define|\
value|( (1u<< PRAGMA_OMP_CLAUSE_IF)			\ 	| (1u<< PRAGMA_OMP_CLAUSE_PRIVATE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)	\ 	| (1u<< PRAGMA_OMP_CLAUSE_DEFAULT)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_SHARED)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_COPYIN)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_REDUCTION)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_NUM_THREADS))
end_define

begin_function
specifier|static
name|tree
name|cp_parser_omp_parallel
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token
modifier|*
name|pragma_tok
parameter_list|)
block|{
name|enum
name|pragma_kind
name|p_kind
init|=
name|PRAGMA_OMP_PARALLEL
decl_stmt|;
specifier|const
name|char
modifier|*
name|p_name
init|=
literal|"#pragma omp parallel"
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|clauses
decl_stmt|,
name|par_clause
decl_stmt|,
name|ws_clause
decl_stmt|,
name|block
decl_stmt|;
name|unsigned
name|int
name|mask
init|=
name|OMP_PARALLEL_CLAUSE_MASK
decl_stmt|;
name|unsigned
name|int
name|save
decl_stmt|;
if|if
condition|(
name|cp_lexer_next_token_is_keyword
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|RID_FOR
argument_list|)
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|p_kind
operator|=
name|PRAGMA_OMP_PARALLEL_FOR
expr_stmt|;
name|p_name
operator|=
literal|"#pragma omp parallel for"
expr_stmt|;
name|mask
operator||=
name|OMP_FOR_CLAUSE_MASK
expr_stmt|;
name|mask
operator|&=
operator|~
operator|(
literal|1u
operator|<<
name|PRAGMA_OMP_CLAUSE_NOWAIT
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp_lexer_next_token_is
argument_list|(
name|parser
operator|->
name|lexer
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|tree
name|id
init|=
name|cp_lexer_peek_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
operator|->
name|u
operator|.
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"sections"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|p_kind
operator|=
name|PRAGMA_OMP_PARALLEL_SECTIONS
expr_stmt|;
name|p_name
operator|=
literal|"#pragma omp parallel sections"
expr_stmt|;
name|mask
operator||=
name|OMP_SECTIONS_CLAUSE_MASK
expr_stmt|;
name|mask
operator|&=
operator|~
operator|(
literal|1u
operator|<<
name|PRAGMA_OMP_CLAUSE_NOWAIT
operator|)
expr_stmt|;
block|}
block|}
name|clauses
operator|=
name|cp_parser_omp_all_clauses
argument_list|(
name|parser
argument_list|,
name|mask
argument_list|,
name|p_name
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
name|block
operator|=
name|begin_omp_parallel
argument_list|()
expr_stmt|;
name|save
operator|=
name|cp_parser_begin_omp_structured_block
argument_list|(
name|parser
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_kind
condition|)
block|{
case|case
name|PRAGMA_OMP_PARALLEL
case|:
name|cp_parser_already_scoped_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|par_clause
operator|=
name|clauses
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_PARALLEL_FOR
case|:
name|c_split_parallel_clauses
argument_list|(
name|clauses
argument_list|,
operator|&
name|par_clause
argument_list|,
operator|&
name|ws_clause
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|cp_parser_omp_for_loop
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
condition|)
name|OMP_FOR_CLAUSES
argument_list|(
name|stmt
argument_list|)
operator|=
name|ws_clause
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_PARALLEL_SECTIONS
case|:
name|c_split_parallel_clauses
argument_list|(
name|clauses
argument_list|,
operator|&
name|par_clause
argument_list|,
operator|&
name|ws_clause
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|cp_parser_omp_sections_scope
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
condition|)
name|OMP_SECTIONS_CLAUSES
argument_list|(
name|stmt
argument_list|)
operator|=
name|ws_clause
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|cp_parser_end_omp_structured_block
argument_list|(
name|parser
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|finish_omp_parallel
argument_list|(
name|par_clause
argument_list|,
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_kind
operator|!=
name|PRAGMA_OMP_PARALLEL
condition|)
name|OMP_PARALLEL_COMBINED
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|stmt
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp single single-clause[optseq] new-line      structured-block  */
end_comment

begin_define
define|#
directive|define
name|OMP_SINGLE_CLAUSE_MASK
define|\
value|( (1u<< PRAGMA_OMP_CLAUSE_PRIVATE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)	\ 	| (1u<< PRAGMA_OMP_CLAUSE_COPYPRIVATE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_NOWAIT))
end_define

begin_function
specifier|static
name|tree
name|cp_parser_omp_single
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token
modifier|*
name|pragma_tok
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|make_node
argument_list|(
name|OMP_SINGLE
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|OMP_SINGLE_CLAUSES
argument_list|(
name|stmt
argument_list|)
operator|=
name|cp_parser_omp_all_clauses
argument_list|(
name|parser
argument_list|,
name|OMP_SINGLE_CLAUSE_MASK
argument_list|,
literal|"#pragma omp single"
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
name|OMP_SINGLE_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|cp_parser_omp_structured_block
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|stmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp threadprivate (variable-list) */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_omp_threadprivate
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token
modifier|*
name|pragma_tok
parameter_list|)
block|{
name|tree
name|vars
decl_stmt|;
name|vars
operator|=
name|cp_parser_omp_var_list
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cp_parser_require_pragma_eol
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targetm
operator|.
name|have_tls
condition|)
name|sorry
argument_list|(
literal|"threadprivate variables not supported in this target"
argument_list|)
expr_stmt|;
name|finish_omp_threadprivate
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Main entry point to OpenMP statement pragmas.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_omp_construct
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|cp_token
modifier|*
name|pragma_tok
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
switch|switch
condition|(
name|pragma_tok
operator|->
name|pragma_kind
condition|)
block|{
case|case
name|PRAGMA_OMP_ATOMIC
case|:
name|cp_parser_omp_atomic
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
return|return;
case|case
name|PRAGMA_OMP_CRITICAL
case|:
name|stmt
operator|=
name|cp_parser_omp_critical
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_FOR
case|:
name|stmt
operator|=
name|cp_parser_omp_for
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_MASTER
case|:
name|stmt
operator|=
name|cp_parser_omp_master
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_ORDERED
case|:
name|stmt
operator|=
name|cp_parser_omp_ordered
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_PARALLEL
case|:
name|stmt
operator|=
name|cp_parser_omp_parallel
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_SECTIONS
case|:
name|stmt
operator|=
name|cp_parser_omp_sections
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_SINGLE
case|:
name|stmt
operator|=
name|cp_parser_omp_single
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|stmt
condition|)
name|SET_EXPR_LOCATION
argument_list|(
name|stmt
argument_list|,
name|pragma_tok
operator|->
name|location
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The parser.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|cp_parser
operator|*
name|the_parser
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/* Special handling for the first token or line in the file.  The first    thing in the file might be #pragma GCC pch_preprocess, which loads a    PCH file, which is a GC collection point.  So we need to handle this    first pragma without benefit of an existing lexer structure.     Always returns one token to the caller in *FIRST_TOKEN.  This is    either the true first token of the file, or the first token after    the initial pragma.  */
end_comment

begin_function
specifier|static
name|void
name|cp_parser_initial_pragma
parameter_list|(
name|cp_token
modifier|*
name|first_token
parameter_list|)
block|{
name|tree
name|name
init|=
name|NULL
decl_stmt|;
name|cp_lexer_get_preprocessor_token
argument_list|(
name|NULL
argument_list|,
name|first_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_token
operator|->
name|pragma_kind
operator|!=
name|PRAGMA_GCC_PCH_PREPROCESS
condition|)
return|return;
name|cp_lexer_get_preprocessor_token
argument_list|(
name|NULL
argument_list|,
name|first_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_token
operator|->
name|type
operator|==
name|CPP_STRING
condition|)
block|{
name|name
operator|=
name|first_token
operator|->
name|u
operator|.
name|value
expr_stmt|;
name|cp_lexer_get_preprocessor_token
argument_list|(
name|NULL
argument_list|,
name|first_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_token
operator|->
name|type
operator|!=
name|CPP_PRAGMA_EOL
condition|)
name|error
argument_list|(
literal|"junk at end of %<#pragma GCC pch_preprocess%>"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"expected string literal"
argument_list|)
expr_stmt|;
comment|/* Skip to the end of the pragma.  */
while|while
condition|(
name|first_token
operator|->
name|type
operator|!=
name|CPP_PRAGMA_EOL
operator|&&
name|first_token
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
name|cp_lexer_get_preprocessor_token
argument_list|(
name|NULL
argument_list|,
name|first_token
argument_list|)
expr_stmt|;
comment|/* Now actually load the PCH file.  */
if|if
condition|(
name|name
condition|)
name|c_common_pch_pragma
argument_list|(
name|parse_in
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read one more token to return to our caller.  We have to do this      after reading the PCH file in, since its pointers have to be      live.  */
name|cp_lexer_get_preprocessor_token
argument_list|(
name|NULL
argument_list|,
name|first_token
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Normal parsing of a pragma token.  Here we can (and must) use the    regular lexer.  */
end_comment

begin_function
specifier|static
name|bool
name|cp_parser_pragma
parameter_list|(
name|cp_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|pragma_context
name|context
parameter_list|)
block|{
name|cp_token
modifier|*
name|pragma_tok
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|pragma_tok
operator|=
name|cp_lexer_consume_token
argument_list|(
name|parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|pragma_tok
operator|->
name|type
operator|==
name|CPP_PRAGMA
argument_list|)
expr_stmt|;
name|parser
operator|->
name|lexer
operator|->
name|in_pragma
operator|=
name|true
expr_stmt|;
name|id
operator|=
name|pragma_tok
operator|->
name|pragma_kind
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|PRAGMA_GCC_PCH_PREPROCESS
case|:
name|error
argument_list|(
literal|"%<#pragma GCC pch_preprocess%> must be first"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_BARRIER
case|:
switch|switch
condition|(
name|context
condition|)
block|{
case|case
name|pragma_compound
case|:
name|cp_parser_omp_barrier
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|pragma_stmt
case|:
name|error
argument_list|(
literal|"%<#pragma omp barrier%> may only be "
literal|"used in compound statements"
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad_stmt
goto|;
block|}
break|break;
case|case
name|PRAGMA_OMP_FLUSH
case|:
switch|switch
condition|(
name|context
condition|)
block|{
case|case
name|pragma_compound
case|:
name|cp_parser_omp_flush
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|pragma_stmt
case|:
name|error
argument_list|(
literal|"%<#pragma omp flush%> may only be "
literal|"used in compound statements"
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad_stmt
goto|;
block|}
break|break;
case|case
name|PRAGMA_OMP_THREADPRIVATE
case|:
name|cp_parser_omp_threadprivate
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|PRAGMA_OMP_ATOMIC
case|:
case|case
name|PRAGMA_OMP_CRITICAL
case|:
case|case
name|PRAGMA_OMP_FOR
case|:
case|case
name|PRAGMA_OMP_MASTER
case|:
case|case
name|PRAGMA_OMP_ORDERED
case|:
case|case
name|PRAGMA_OMP_PARALLEL
case|:
case|case
name|PRAGMA_OMP_SECTIONS
case|:
case|case
name|PRAGMA_OMP_SINGLE
case|:
if|if
condition|(
name|context
operator|==
name|pragma_external
condition|)
goto|goto
name|bad_stmt
goto|;
name|cp_parser_omp_construct
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PRAGMA_OMP_SECTION
case|:
name|error
argument_list|(
literal|"%<#pragma omp section%> may only be used in "
literal|"%<#pragma omp sections%> construct"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_assert
argument_list|(
name|id
operator|>=
name|PRAGMA_FIRST_EXTERNAL
argument_list|)
expr_stmt|;
name|c_invoke_pragma_handler
argument_list|(
name|id
argument_list|)
expr_stmt|;
break|break;
name|bad_stmt
label|:
name|cp_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected declaration specifiers"
argument_list|)
expr_stmt|;
break|break;
block|}
name|cp_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|,
name|pragma_tok
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* The interface the pragma parsers have to the lexer.  */
end_comment

begin_function
name|enum
name|cpp_ttype
name|pragma_lex
parameter_list|(
name|tree
modifier|*
name|value
parameter_list|)
block|{
name|cp_token
modifier|*
name|tok
decl_stmt|;
name|enum
name|cpp_ttype
name|ret
decl_stmt|;
name|tok
operator|=
name|cp_lexer_peek_token
argument_list|(
name|the_parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|ret
operator|=
name|tok
operator|->
name|type
expr_stmt|;
operator|*
name|value
operator|=
name|tok
operator|->
name|u
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|CPP_PRAGMA_EOL
operator|||
name|ret
operator|==
name|CPP_EOF
condition|)
name|ret
operator|=
name|CPP_EOF
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
name|CPP_STRING
condition|)
operator|*
name|value
operator|=
name|cp_parser_string_literal
argument_list|(
name|the_parser
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_lexer_consume_token
argument_list|(
name|the_parser
operator|->
name|lexer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|CPP_KEYWORD
condition|)
name|ret
operator|=
name|CPP_NAME
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* External interface.  */
end_comment

begin_comment
comment|/* Parse one entire translation unit.  */
end_comment

begin_function
name|void
name|c_parse_file
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|error_occurred
decl_stmt|;
specifier|static
name|bool
name|already_called
init|=
name|false
decl_stmt|;
if|if
condition|(
name|already_called
condition|)
block|{
name|sorry
argument_list|(
literal|"inter-module optimizations not implemented for C++"
argument_list|)
expr_stmt|;
return|return;
block|}
name|already_called
operator|=
name|true
expr_stmt|;
name|the_parser
operator|=
name|cp_parser_new
argument_list|()
expr_stmt|;
name|push_deferring_access_checks
argument_list|(
name|flag_access_control
condition|?
name|dk_no_deferred
else|:
name|dk_no_check
argument_list|)
expr_stmt|;
name|error_occurred
operator|=
name|cp_parser_translation_unit
argument_list|(
name|the_parser
argument_list|)
expr_stmt|;
name|the_parser
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This variable must be provided by every front end.  */
end_comment

begin_decl_stmt
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"gt-cp-parser.h"
end_include

end_unit

