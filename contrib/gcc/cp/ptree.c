begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Prints out trees in human readable form.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998,    1999 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_PTR_PRINTF_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|HOST_PTR_PRINTF_FORMAT
value|HOST_PTR_PRINTF
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_PTR_PRINTF_TYPE
end_ifndef

begin_define
define|#
directive|define
name|HOST_PTR_PRINTF_TYPE
value|(void *)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|cxx_print_decl
parameter_list|(
name|file
parameter_list|,
name|node
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|node
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|DECL_MUTABLE_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|indent_to
argument_list|(
name|file
argument_list|,
name|indent
operator|+
literal|3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" mutable "
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
condition|)
return|return;
name|indent_to
argument_list|(
name|file
argument_list|,
name|indent
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" pending-inline-info "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
argument|file
argument_list|,
argument|HOST_PTR_PRINTF_FORMAT
argument_list|,
argument|HOST_PTR_PRINTF_TYPE DECL_PENDING_INLINE_INFO (node)
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_SORTED_FIELDS
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" sorted-fields "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
argument|file
argument_list|,
argument|HOST_PTR_PRINTF_FORMAT
argument_list|,
argument|HOST_PTR_PRINTF_TYPE DECL_SORTED_FIELDS (node)
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" template-info "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
argument|file
argument_list|,
argument|HOST_PTR_PRINTF_FORMAT
argument_list|,
argument|HOST_PTR_PRINTF_TYPE DECL_TEMPLATE_INFO (node)
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cxx_print_type
parameter_list|(
name|file
parameter_list|,
name|node
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|register
name|tree
name|node
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
name|indent_to
argument_list|(
name|file
argument_list|,
name|indent
operator|+
literal|3
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"index "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|TEMPLATE_TYPE_IDX
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" level "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" orig_level "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|TEMPLATE_TYPE_ORIG_LEVEL
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|node
argument_list|)
condition|)
name|print_node
argument_list|(
name|file
argument_list|,
literal|"throws"
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
return|return;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
break|break;
default|default:
return|return;
block|}
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|node
argument_list|)
condition|)
name|print_node
argument_list|(
name|file
argument_list|,
literal|"ptrmemfunc fn type"
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
return|return;
name|indent_to
argument_list|(
name|file
argument_list|,
name|indent
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"needs-constructor"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" needs-destructor"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" ~X()"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" X()"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" has-type-conversion"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" X(constX&)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|" X(X&)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_NEW_OPERATOR
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" new"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_ARRAY_NEW_OPERATOR
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" new[]"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_GETS_DELETE
argument_list|(
name|node
argument_list|)
operator|&
literal|1
condition|)
name|fputs
argument_list|(
literal|" delete"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_GETS_DELETE
argument_list|(
name|node
argument_list|)
operator|&
literal|2
condition|)
name|fputs
argument_list|(
literal|" delete[]"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" this=(X&)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" op()"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" op[]"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" op->"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" uses-multiple-inheritance"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" n_parents %d"
argument_list|,
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" use_template=%d"
argument_list|,
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|node
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" interface-only"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|node
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" interface-unknown"
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"member-functions"
argument_list|,
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cxx_print_binding
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|cxx_binding
modifier|*
name|binding
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s<"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
argument|stream
argument_list|,
argument|HOST_PTR_PRINTF_FORMAT
argument_list|,
argument|HOST_PTR_PRINTF_TYPE binding
argument_list|)
empty_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxx_print_identifier
parameter_list|(
name|file
parameter_list|,
name|node
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|node
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
name|cxx_print_binding
argument_list|(
name|file
argument_list|,
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|node
argument_list|)
argument_list|,
literal|"bindings"
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"class"
argument_list|,
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|cxx_print_binding
argument_list|(
name|file
argument_list|,
name|IDENTIFIER_BINDING
argument_list|(
name|node
argument_list|)
argument_list|,
literal|"local bindings"
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"label"
argument_list|,
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"template"
argument_list|,
name|IDENTIFIER_TEMPLATE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"implicit"
argument_list|,
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"error locus"
argument_list|,
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxx_print_xnode
parameter_list|(
name|file
parameter_list|,
name|node
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|node
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
condition|)
block|{
case|case
name|OVERLOAD
case|:
name|print_node
argument_list|(
name|file
argument_list|,
literal|"function"
argument_list|,
name|OVL_FUNCTION
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"chain"
argument_list|,
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|indent_to
argument_list|(
name|file
argument_list|,
name|indent
operator|+
literal|3
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"index "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|TEMPLATE_PARM_IDX
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" level "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" orig_level "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|TEMPLATE_PARM_ORIG_LEVEL
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

end_unit

