begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Iterator routines for manipulating GENERIC and GIMPLE tree statements.    Copyright (C) 2003, 2004 Free Software Foundation, Inc.    Contributed by Andrew MacLeod<amacleod@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_comment
comment|/* This is a cache of STATEMENT_LIST nodes.  We create and destroy them    fairly often during gimplification.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable (
literal|""
argument|))
argument_list|)
name|tree
name|stmt_list_cache
expr_stmt|;
end_expr_stmt

begin_function
name|tree
name|alloc_stmt_list
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|list
init|=
name|stmt_list_cache
decl_stmt|;
if|if
condition|(
name|list
condition|)
block|{
name|stmt_list_cache
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stmt_list_cache
operator|!=
name|list
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|list
argument_list|,
name|STATEMENT_LIST
argument_list|)
expr_stmt|;
block|}
else|else
name|list
operator|=
name|make_node
argument_list|(
name|STATEMENT_LIST
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|list
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
name|void
name|free_stmt_list
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|STATEMENT_LIST_HEAD
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|STATEMENT_LIST_TAIL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this triggers, it's a sign that the same list is being freed      twice.  */
name|gcc_assert
argument_list|(
name|t
operator|!=
name|stmt_list_cache
operator|||
name|stmt_list_cache
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|stmt_list_cache
expr_stmt|;
name|stmt_list_cache
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Links a statement, or a chain of statements, before the current stmt.  */
end_comment

begin_function
name|void
name|tsi_link_before
parameter_list|(
name|tree_stmt_iterator
modifier|*
name|i
parameter_list|,
name|tree
name|t
parameter_list|,
name|enum
name|tsi_iterator_update
name|mode
parameter_list|)
block|{
name|struct
name|tree_statement_list_node
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
comment|/* Die on looping.  */
name|gcc_assert
argument_list|(
name|t
operator|!=
name|i
operator|->
name|container
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
block|{
name|head
operator|=
name|STATEMENT_LIST_HEAD
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tail
operator|=
name|STATEMENT_LIST_TAIL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|STATEMENT_LIST_HEAD
argument_list|(
name|t
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|STATEMENT_LIST_TAIL
argument_list|(
name|t
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|free_stmt_list
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Empty statement lists need no work.  */
if|if
condition|(
operator|!
name|head
operator|||
operator|!
name|tail
condition|)
block|{
name|gcc_assert
argument_list|(
name|head
operator|==
name|tail
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|head
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|head
operator|->
name|stmt
operator|=
name|t
expr_stmt|;
name|tail
operator|=
name|head
expr_stmt|;
block|}
name|TREE_SIDE_EFFECTS
argument_list|(
name|i
operator|->
name|container
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cur
operator|=
name|i
operator|->
name|ptr
expr_stmt|;
comment|/* Link it into the list.  */
if|if
condition|(
name|cur
condition|)
block|{
name|head
operator|->
name|prev
operator|=
name|cur
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|prev
condition|)
name|head
operator|->
name|prev
operator|->
name|next
operator|=
name|head
expr_stmt|;
else|else
name|STATEMENT_LIST_HEAD
argument_list|(
name|i
operator|->
name|container
argument_list|)
operator|=
name|head
expr_stmt|;
name|tail
operator|->
name|next
operator|=
name|cur
expr_stmt|;
name|cur
operator|->
name|prev
operator|=
name|tail
expr_stmt|;
block|}
else|else
block|{
name|head
operator|->
name|prev
operator|=
name|STATEMENT_LIST_TAIL
argument_list|(
name|i
operator|->
name|container
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|prev
condition|)
name|head
operator|->
name|prev
operator|->
name|next
operator|=
name|head
expr_stmt|;
else|else
name|STATEMENT_LIST_HEAD
argument_list|(
name|i
operator|->
name|container
argument_list|)
operator|=
name|head
expr_stmt|;
name|STATEMENT_LIST_TAIL
argument_list|(
name|i
operator|->
name|container
argument_list|)
operator|=
name|tail
expr_stmt|;
block|}
comment|/* Update the iterator, if requested.  */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|TSI_NEW_STMT
case|:
case|case
name|TSI_CONTINUE_LINKING
case|:
case|case
name|TSI_CHAIN_START
case|:
name|i
operator|->
name|ptr
operator|=
name|head
expr_stmt|;
break|break;
case|case
name|TSI_CHAIN_END
case|:
name|i
operator|->
name|ptr
operator|=
name|tail
expr_stmt|;
break|break;
case|case
name|TSI_SAME_STMT
case|:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Links a statement, or a chain of statements, after the current stmt.  */
end_comment

begin_function
name|void
name|tsi_link_after
parameter_list|(
name|tree_stmt_iterator
modifier|*
name|i
parameter_list|,
name|tree
name|t
parameter_list|,
name|enum
name|tsi_iterator_update
name|mode
parameter_list|)
block|{
name|struct
name|tree_statement_list_node
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
comment|/* Die on looping.  */
name|gcc_assert
argument_list|(
name|t
operator|!=
name|i
operator|->
name|container
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
block|{
name|head
operator|=
name|STATEMENT_LIST_HEAD
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tail
operator|=
name|STATEMENT_LIST_TAIL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|STATEMENT_LIST_HEAD
argument_list|(
name|t
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|STATEMENT_LIST_TAIL
argument_list|(
name|t
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|free_stmt_list
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Empty statement lists need no work.  */
if|if
condition|(
operator|!
name|head
operator|||
operator|!
name|tail
condition|)
block|{
name|gcc_assert
argument_list|(
name|head
operator|==
name|tail
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|head
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|head
operator|->
name|stmt
operator|=
name|t
expr_stmt|;
name|tail
operator|=
name|head
expr_stmt|;
block|}
name|TREE_SIDE_EFFECTS
argument_list|(
name|i
operator|->
name|container
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cur
operator|=
name|i
operator|->
name|ptr
expr_stmt|;
comment|/* Link it into the list.  */
if|if
condition|(
name|cur
condition|)
block|{
name|tail
operator|->
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tail
operator|->
name|next
condition|)
name|tail
operator|->
name|next
operator|->
name|prev
operator|=
name|tail
expr_stmt|;
else|else
name|STATEMENT_LIST_TAIL
argument_list|(
name|i
operator|->
name|container
argument_list|)
operator|=
name|tail
expr_stmt|;
name|head
operator|->
name|prev
operator|=
name|cur
expr_stmt|;
name|cur
operator|->
name|next
operator|=
name|head
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
operator|!
name|STATEMENT_LIST_TAIL
argument_list|(
name|i
operator|->
name|container
argument_list|)
argument_list|)
expr_stmt|;
name|STATEMENT_LIST_HEAD
argument_list|(
name|i
operator|->
name|container
argument_list|)
operator|=
name|head
expr_stmt|;
name|STATEMENT_LIST_TAIL
argument_list|(
name|i
operator|->
name|container
argument_list|)
operator|=
name|tail
expr_stmt|;
block|}
comment|/* Update the iterator, if requested.  */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|TSI_NEW_STMT
case|:
case|case
name|TSI_CHAIN_START
case|:
name|i
operator|->
name|ptr
operator|=
name|head
expr_stmt|;
break|break;
case|case
name|TSI_CONTINUE_LINKING
case|:
case|case
name|TSI_CHAIN_END
case|:
name|i
operator|->
name|ptr
operator|=
name|tail
expr_stmt|;
break|break;
case|case
name|TSI_SAME_STMT
case|:
name|gcc_assert
argument_list|(
name|cur
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Remove a stmt from the tree list.  The iterator is updated to point to    the next stmt.  */
end_comment

begin_function
name|void
name|tsi_delink
parameter_list|(
name|tree_stmt_iterator
modifier|*
name|i
parameter_list|)
block|{
name|struct
name|tree_statement_list_node
modifier|*
name|cur
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|cur
operator|=
name|i
operator|->
name|ptr
expr_stmt|;
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|prev
operator|=
name|cur
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
else|else
name|STATEMENT_LIST_HEAD
argument_list|(
name|i
operator|->
name|container
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
else|else
name|STATEMENT_LIST_TAIL
argument_list|(
name|i
operator|->
name|container
argument_list|)
operator|=
name|prev
expr_stmt|;
if|if
condition|(
operator|!
name|next
operator|&&
operator|!
name|prev
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|i
operator|->
name|container
argument_list|)
operator|=
literal|0
expr_stmt|;
name|i
operator|->
name|ptr
operator|=
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move all statements in the statement list after I to a new    statement list.  I itself is unchanged.  */
end_comment

begin_function
name|tree
name|tsi_split_statement_list_after
parameter_list|(
specifier|const
name|tree_stmt_iterator
modifier|*
name|i
parameter_list|)
block|{
name|struct
name|tree_statement_list_node
modifier|*
name|cur
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|tree
name|old_sl
decl_stmt|,
name|new_sl
decl_stmt|;
name|cur
operator|=
name|i
operator|->
name|ptr
expr_stmt|;
comment|/* How can we possibly split after the end, or before the beginning?  */
name|gcc_assert
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|old_sl
operator|=
name|i
operator|->
name|container
expr_stmt|;
name|new_sl
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|new_sl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|STATEMENT_LIST_HEAD
argument_list|(
name|new_sl
argument_list|)
operator|=
name|next
expr_stmt|;
name|STATEMENT_LIST_TAIL
argument_list|(
name|new_sl
argument_list|)
operator|=
name|STATEMENT_LIST_TAIL
argument_list|(
name|old_sl
argument_list|)
expr_stmt|;
name|STATEMENT_LIST_TAIL
argument_list|(
name|old_sl
argument_list|)
operator|=
name|cur
expr_stmt|;
name|cur
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
return|return
name|new_sl
return|;
block|}
end_function

begin_comment
comment|/* Move all statements in the statement list before I to a new    statement list.  I is set to the head of the new list.  */
end_comment

begin_function
name|tree
name|tsi_split_statement_list_before
parameter_list|(
name|tree_stmt_iterator
modifier|*
name|i
parameter_list|)
block|{
name|struct
name|tree_statement_list_node
modifier|*
name|cur
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|tree
name|old_sl
decl_stmt|,
name|new_sl
decl_stmt|;
name|cur
operator|=
name|i
operator|->
name|ptr
expr_stmt|;
comment|/* How can we possibly split after the end, or before the beginning?  */
name|gcc_assert
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|prev
operator|=
name|cur
operator|->
name|prev
expr_stmt|;
name|old_sl
operator|=
name|i
operator|->
name|container
expr_stmt|;
name|new_sl
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|new_sl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|i
operator|->
name|container
operator|=
name|new_sl
expr_stmt|;
name|STATEMENT_LIST_HEAD
argument_list|(
name|new_sl
argument_list|)
operator|=
name|cur
expr_stmt|;
name|STATEMENT_LIST_TAIL
argument_list|(
name|new_sl
argument_list|)
operator|=
name|STATEMENT_LIST_TAIL
argument_list|(
name|old_sl
argument_list|)
expr_stmt|;
name|STATEMENT_LIST_TAIL
argument_list|(
name|old_sl
argument_list|)
operator|=
name|prev
expr_stmt|;
name|cur
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|new_sl
return|;
block|}
end_function

begin_comment
comment|/* Return the first expression in a sequence of COMPOUND_EXPRs,    or in a STATEMENT_LIST.  */
end_comment

begin_function
name|tree
name|expr_first
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|==
name|NULL_TREE
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
block|{
name|struct
name|tree_statement_list_node
modifier|*
name|n
init|=
name|STATEMENT_LIST_HEAD
argument_list|(
name|expr
argument_list|)
decl_stmt|;
return|return
name|n
condition|?
name|n
operator|->
name|stmt
else|:
name|NULL_TREE
return|;
block|}
while|while
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Return the last expression in a sequence of COMPOUND_EXPRs,    or in a STATEMENT_LIST.  */
end_comment

begin_function
name|tree
name|expr_last
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|==
name|NULL_TREE
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
block|{
name|struct
name|tree_statement_list_node
modifier|*
name|n
init|=
name|STATEMENT_LIST_TAIL
argument_list|(
name|expr
argument_list|)
decl_stmt|;
return|return
name|n
condition|?
name|n
operator|->
name|stmt
else|:
name|NULL_TREE
return|;
block|}
while|while
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* If EXPR is a single statement return it.  If EXPR is a    STATEMENT_LIST containing exactly one statement S, return S.    Otherwise, return NULL.  */
end_comment

begin_function
name|tree
name|expr_only
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
block|{
name|struct
name|tree_statement_list_node
modifier|*
name|n
init|=
name|STATEMENT_LIST_TAIL
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|&&
name|STATEMENT_LIST_HEAD
argument_list|(
name|expr
argument_list|)
operator|==
name|n
condition|)
return|return
name|n
operator|->
name|stmt
return|;
else|else
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|expr
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-tree-iterator.h"
end_include

end_unit

