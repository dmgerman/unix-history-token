begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines needed for unwinding stack frames for exception handling.  */
end_comment

begin_comment
comment|/* Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.    Contributed by Jason Merrill<jason@cygnus.com>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file into combinations with other programs, and to distribute those combinations without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into a combine executable.)  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_Unwind_Find_FDE
end_ifndef

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"tsystem.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"unwind.h"
end_include

begin_define
define|#
directive|define
name|NO_BASE_OF_ENCODED_VALUE
end_define

begin_include
include|#
directive|include
file|"unwind-pe.h"
end_include

begin_include
include|#
directive|include
file|"unwind-dw2-fde.h"
end_include

begin_include
include|#
directive|include
file|"gthr.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The unseen_objects list contains objects that have been registered    but not yet categorized in any way.  The seen_objects list has had    it's pc_begin and count fields initialized at minimum, and is sorted    by decreasing value of pc_begin.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|object
modifier|*
name|unseen_objects
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|object
modifier|*
name|seen_objects
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GTHREAD_MUTEX_INIT
end_ifdef

begin_decl_stmt
specifier|static
name|__gthread_mutex_t
name|object_mutex
init|=
name|__GTHREAD_MUTEX_INIT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|__gthread_mutex_t
name|object_mutex
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__GTHREAD_MUTEX_INIT_FUNCTION
end_ifdef

begin_function
specifier|static
name|void
name|init_object_mutex
parameter_list|(
name|void
parameter_list|)
block|{
name|__GTHREAD_MUTEX_INIT_FUNCTION
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_object_mutex_once
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|__gthread_once_t
name|once
init|=
name|__GTHREAD_ONCE_INIT
decl_stmt|;
name|__gthread_once
argument_list|(
operator|&
name|once
argument_list|,
name|init_object_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|init_object_mutex_once
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Called from crtbegin.o to register the unwind info for an object.  */
end_comment

begin_function
name|void
name|__register_frame_info_bases
parameter_list|(
name|void
modifier|*
name|begin
parameter_list|,
name|struct
name|object
modifier|*
name|ob
parameter_list|,
name|void
modifier|*
name|tbase
parameter_list|,
name|void
modifier|*
name|dbase
parameter_list|)
block|{
comment|/* If .eh_frame is empty, don't register at all.  */
if|if
condition|(
operator|*
operator|(
name|uword
operator|*
operator|)
name|begin
operator|==
literal|0
condition|)
return|return;
name|ob
operator|->
name|pc_begin
operator|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|ob
operator|->
name|tbase
operator|=
name|tbase
expr_stmt|;
name|ob
operator|->
name|dbase
operator|=
name|dbase
expr_stmt|;
name|ob
operator|->
name|u
operator|.
name|single
operator|=
name|begin
expr_stmt|;
name|ob
operator|->
name|s
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|init_object_mutex_once
argument_list|()
expr_stmt|;
name|__gthread_mutex_lock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
name|ob
operator|->
name|next
operator|=
name|unseen_objects
expr_stmt|;
name|unseen_objects
operator|=
name|ob
expr_stmt|;
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__register_frame_info
parameter_list|(
name|void
modifier|*
name|begin
parameter_list|,
name|struct
name|object
modifier|*
name|ob
parameter_list|)
block|{
name|__register_frame_info_bases
argument_list|(
name|begin
argument_list|,
name|ob
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__register_frame
parameter_list|(
name|void
modifier|*
name|begin
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|ob
decl_stmt|;
comment|/* If .eh_frame is empty, don't register at all.  */
if|if
condition|(
operator|*
operator|(
name|uword
operator|*
operator|)
name|begin
operator|==
literal|0
condition|)
return|return;
name|ob
operator|=
operator|(
expr|struct
name|object
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|object
argument_list|)
argument_list|)
expr_stmt|;
name|__register_frame_info
argument_list|(
name|begin
argument_list|,
name|ob
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar, but BEGIN is actually a pointer to a table of unwind entries    for different translation units.  Called from the file generated by    collect2.  */
end_comment

begin_function
name|void
name|__register_frame_info_table_bases
parameter_list|(
name|void
modifier|*
name|begin
parameter_list|,
name|struct
name|object
modifier|*
name|ob
parameter_list|,
name|void
modifier|*
name|tbase
parameter_list|,
name|void
modifier|*
name|dbase
parameter_list|)
block|{
name|ob
operator|->
name|pc_begin
operator|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|ob
operator|->
name|tbase
operator|=
name|tbase
expr_stmt|;
name|ob
operator|->
name|dbase
operator|=
name|dbase
expr_stmt|;
name|ob
operator|->
name|u
operator|.
name|array
operator|=
name|begin
expr_stmt|;
name|ob
operator|->
name|s
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|from_array
operator|=
literal|1
expr_stmt|;
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|init_object_mutex_once
argument_list|()
expr_stmt|;
name|__gthread_mutex_lock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
name|ob
operator|->
name|next
operator|=
name|unseen_objects
expr_stmt|;
name|unseen_objects
operator|=
name|ob
expr_stmt|;
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__register_frame_info_table
parameter_list|(
name|void
modifier|*
name|begin
parameter_list|,
name|struct
name|object
modifier|*
name|ob
parameter_list|)
block|{
name|__register_frame_info_table_bases
argument_list|(
name|begin
argument_list|,
name|ob
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__register_frame_table
parameter_list|(
name|void
modifier|*
name|begin
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|ob
init|=
operator|(
expr|struct
name|object
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|object
argument_list|)
argument_list|)
decl_stmt|;
name|__register_frame_info_table
argument_list|(
name|begin
argument_list|,
name|ob
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from crtbegin.o to deregister the unwind info for an object.  */
end_comment

begin_comment
comment|/* ??? Glibc has for a while now exported __register_frame_info and    __deregister_frame_info.  If we call __register_frame_info_bases    from crtbegin (wherein it is declared weak), and this object does    not get pulled from libgcc.a for other reasons, then the    invocation of __deregister_frame_info will be resolved from glibc.    Since the registration did not happen there, we'll abort.     Therefore, declare a new deregistration entry point that does the    exact same thing, but will resolve to the same library as     implements __register_frame_info_bases.  */
end_comment

begin_function
name|void
modifier|*
name|__deregister_frame_info_bases
parameter_list|(
name|void
modifier|*
name|begin
parameter_list|)
block|{
name|struct
name|object
modifier|*
modifier|*
name|p
decl_stmt|;
name|struct
name|object
modifier|*
name|ob
init|=
literal|0
decl_stmt|;
comment|/* If .eh_frame is empty, we haven't registered.  */
if|if
condition|(
operator|*
operator|(
name|uword
operator|*
operator|)
name|begin
operator|==
literal|0
condition|)
return|return
name|ob
return|;
name|init_object_mutex_once
argument_list|()
expr_stmt|;
name|__gthread_mutex_lock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|unseen_objects
init|;
operator|*
name|p
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|u
operator|.
name|single
operator|==
name|begin
condition|)
block|{
name|ob
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
name|ob
operator|->
name|next
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|p
operator|=
operator|&
name|seen_objects
init|;
operator|*
name|p
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|s
operator|.
name|b
operator|.
name|sorted
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|u
operator|.
name|sort
operator|->
name|orig_data
operator|==
name|begin
condition|)
block|{
name|ob
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
name|ob
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ob
operator|->
name|u
operator|.
name|sort
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|u
operator|.
name|single
operator|==
name|begin
condition|)
block|{
name|ob
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
name|ob
operator|->
name|next
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|out
label|:
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|ob
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|__deregister_frame_info
parameter_list|(
name|void
modifier|*
name|begin
parameter_list|)
block|{
return|return
name|__deregister_frame_info_bases
argument_list|(
name|begin
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|__deregister_frame
parameter_list|(
name|void
modifier|*
name|begin
parameter_list|)
block|{
comment|/* If .eh_frame is empty, we haven't registered.  */
if|if
condition|(
operator|*
operator|(
name|uword
operator|*
operator|)
name|begin
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|__deregister_frame_info
argument_list|(
name|begin
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like base_of_encoded_value, but take the base from a struct object    instead of an _Unwind_Context.  */
end_comment

begin_function
specifier|static
name|_Unwind_Ptr
name|base_from_object
parameter_list|(
name|unsigned
name|char
name|encoding
parameter_list|,
name|struct
name|object
modifier|*
name|ob
parameter_list|)
block|{
if|if
condition|(
name|encoding
operator|==
name|DW_EH_PE_omit
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|encoding
operator|&
literal|0x70
condition|)
block|{
case|case
name|DW_EH_PE_absptr
case|:
case|case
name|DW_EH_PE_pcrel
case|:
case|case
name|DW_EH_PE_aligned
case|:
return|return
literal|0
return|;
case|case
name|DW_EH_PE_textrel
case|:
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|ob
operator|->
name|tbase
return|;
case|case
name|DW_EH_PE_datarel
case|:
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|ob
operator|->
name|dbase
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the FDE pointer encoding from the CIE.  */
end_comment

begin_comment
comment|/* ??? This is a subset of extract_cie_info from unwind-dw2.c.  */
end_comment

begin_function
specifier|static
name|int
name|get_cie_encoding
parameter_list|(
name|struct
name|dwarf_cie
modifier|*
name|cie
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|aug
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|_Unwind_Ptr
name|dummy
decl_stmt|;
name|_Unwind_Word
name|utmp
decl_stmt|;
name|_Unwind_Sword
name|stmp
decl_stmt|;
name|aug
operator|=
name|cie
operator|->
name|augmentation
expr_stmt|;
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|!=
literal|'z'
condition|)
return|return
name|DW_EH_PE_absptr
return|;
name|p
operator|=
name|aug
operator|+
name|strlen
argument_list|(
name|aug
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Skip the augmentation string.  */
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
comment|/* Skip code alignment.  */
name|p
operator|=
name|read_sleb128
argument_list|(
name|p
argument_list|,
operator|&
name|stmp
argument_list|)
expr_stmt|;
comment|/* Skip data alignment.  */
name|p
operator|++
expr_stmt|;
comment|/* Skip return address column.  */
name|aug
operator|++
expr_stmt|;
comment|/* Skip 'z' */
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
comment|/* Skip augmentation length.  */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* This is what we're looking for.  */
if|if
condition|(
operator|*
name|aug
operator|==
literal|'R'
condition|)
return|return
operator|*
name|p
return|;
comment|/* Personality encoding and pointer.  */
elseif|else
if|if
condition|(
operator|*
name|aug
operator|==
literal|'P'
condition|)
block|{
comment|/* ??? Avoid dereferencing indirect pointers, since we're 	     faking the base address.  Gotta keep DW_EH_PE_aligned 	     intact, however.  */
name|p
operator|=
name|read_encoded_value_with_base
argument_list|(
operator|*
name|p
operator|&
literal|0x7F
argument_list|,
literal|0
argument_list|,
name|p
operator|+
literal|1
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
block|}
comment|/* LSDA encoding.  */
elseif|else
if|if
condition|(
operator|*
name|aug
operator|==
literal|'L'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Otherwise end of string, or unknown augmentation.  */
else|else
return|return
name|DW_EH_PE_absptr
return|;
name|aug
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|get_fde_encoding
parameter_list|(
name|struct
name|dwarf_fde
modifier|*
name|f
parameter_list|)
block|{
return|return
name|get_cie_encoding
argument_list|(
name|get_cie
argument_list|(
name|f
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sorting an array of FDEs by address.    (Ideally we would have the linker sort the FDEs so we don't have to do    it at run time. But the linkers are not yet prepared for this.)  */
end_comment

begin_comment
comment|/* Comparison routines.  Three variants of increasing complexity.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fde_unencoded_compare
argument_list|(
expr|struct
name|object
operator|*
name|ob
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
name|fde
operator|*
name|x
argument_list|,
name|fde
operator|*
name|y
argument_list|)
block|{
name|_Unwind_Ptr
name|x_ptr
init|=
operator|*
operator|(
name|_Unwind_Ptr
operator|*
operator|)
name|x
operator|->
name|pc_begin
decl_stmt|;
name|_Unwind_Ptr
name|y_ptr
init|=
operator|*
operator|(
name|_Unwind_Ptr
operator|*
operator|)
name|y
operator|->
name|pc_begin
decl_stmt|;
if|if
condition|(
name|x_ptr
operator|>
name|y_ptr
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x_ptr
operator|<
name|y_ptr
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|fde_single_encoding_compare
parameter_list|(
name|struct
name|object
modifier|*
name|ob
parameter_list|,
name|fde
modifier|*
name|x
parameter_list|,
name|fde
modifier|*
name|y
parameter_list|)
block|{
name|_Unwind_Ptr
name|base
decl_stmt|,
name|x_ptr
decl_stmt|,
name|y_ptr
decl_stmt|;
name|base
operator|=
name|base_from_object
argument_list|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
argument_list|,
name|ob
argument_list|)
expr_stmt|;
name|read_encoded_value_with_base
argument_list|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
argument_list|,
name|base
argument_list|,
name|x
operator|->
name|pc_begin
argument_list|,
operator|&
name|x_ptr
argument_list|)
expr_stmt|;
name|read_encoded_value_with_base
argument_list|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
argument_list|,
name|base
argument_list|,
name|y
operator|->
name|pc_begin
argument_list|,
operator|&
name|y_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_ptr
operator|>
name|y_ptr
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x_ptr
operator|<
name|y_ptr
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fde_mixed_encoding_compare
parameter_list|(
name|struct
name|object
modifier|*
name|ob
parameter_list|,
name|fde
modifier|*
name|x
parameter_list|,
name|fde
modifier|*
name|y
parameter_list|)
block|{
name|int
name|x_encoding
decl_stmt|,
name|y_encoding
decl_stmt|;
name|_Unwind_Ptr
name|x_ptr
decl_stmt|,
name|y_ptr
decl_stmt|;
name|x_encoding
operator|=
name|get_fde_encoding
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|read_encoded_value_with_base
argument_list|(
name|x_encoding
argument_list|,
name|base_from_object
argument_list|(
name|x_encoding
argument_list|,
name|ob
argument_list|)
argument_list|,
name|x
operator|->
name|pc_begin
argument_list|,
operator|&
name|x_ptr
argument_list|)
expr_stmt|;
name|y_encoding
operator|=
name|get_fde_encoding
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|read_encoded_value_with_base
argument_list|(
name|y_encoding
argument_list|,
name|base_from_object
argument_list|(
name|y_encoding
argument_list|,
name|ob
argument_list|)
argument_list|,
name|y
operator|->
name|pc_begin
argument_list|,
operator|&
name|y_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_ptr
operator|>
name|y_ptr
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x_ptr
operator|<
name|y_ptr
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|fde_compare_t
function_decl|)
parameter_list|(
name|struct
name|object
modifier|*
parameter_list|,
name|fde
modifier|*
parameter_list|,
name|fde
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* This is a special mix of insertion sort and heap sort, optimized for    the data sets that actually occur. They look like    101 102 103 127 128 105 108 110 190 111 115 119 125 160 126 129 130.    I.e. a linearly increasing sequence (coming from functions in the text    section), with additionally a few unordered elements (coming from functions    in gnu_linkonce sections) whose values are higher than the values in the    surrounding linear sequence (but not necessarily higher than the values    at the end of the linear sequence!).    The worst-case total run time is O(N) + O(n log (n)), where N is the    total number of FDEs and n is the number of erratic ones.  */
end_comment

begin_struct
struct|struct
name|fde_accumulator
block|{
name|struct
name|fde_vector
modifier|*
name|linear
decl_stmt|;
name|struct
name|fde_vector
modifier|*
name|erratic
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|int
name|start_fde_sort
parameter_list|(
name|struct
name|fde_accumulator
modifier|*
name|accu
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
return|return
literal|0
return|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|fde_vector
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|fde
operator|*
argument_list|)
operator|*
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|accu
operator|->
name|linear
operator|=
operator|(
expr|struct
name|fde_vector
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
condition|)
block|{
name|accu
operator|->
name|linear
operator|->
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|accu
operator|->
name|erratic
operator|=
operator|(
expr|struct
name|fde_vector
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
condition|)
name|accu
operator|->
name|erratic
operator|->
name|count
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fde_insert
parameter_list|(
name|struct
name|fde_accumulator
modifier|*
name|accu
parameter_list|,
name|fde
modifier|*
name|this_fde
parameter_list|)
block|{
if|if
condition|(
name|accu
operator|->
name|linear
condition|)
name|accu
operator|->
name|linear
operator|->
name|array
index|[
name|accu
operator|->
name|linear
operator|->
name|count
operator|++
index|]
operator|=
name|this_fde
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Split LINEAR into a linear sequence with low values and an erratic    sequence with high values, put the linear one (of longest possible    length) into LINEAR and the erratic one into ERRATIC. This is O(N).        Because the longest linear sequence we are trying to locate within the    incoming LINEAR array can be interspersed with (high valued) erratic    entries.  We construct a chain indicating the sequenced entries.    To avoid having to allocate this chain, we overlay it onto the space of    the ERRATIC array during construction.  A final pass iterates over the    chain to determine what should be placed in the ERRATIC array, and    what is the linear sequence.  This overlay is safe from aliasing.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|fde_split
parameter_list|(
name|struct
name|object
modifier|*
name|ob
parameter_list|,
name|fde_compare_t
name|fde_compare
parameter_list|,
name|struct
name|fde_vector
modifier|*
name|linear
parameter_list|,
name|struct
name|fde_vector
modifier|*
name|erratic
parameter_list|)
block|{
specifier|static
name|fde
modifier|*
name|marker
decl_stmt|;
name|size_t
name|count
init|=
name|linear
operator|->
name|count
decl_stmt|;
name|fde
modifier|*
modifier|*
name|chain_end
init|=
operator|&
name|marker
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* This should optimize out, but it is wise to make sure this assumption      is correct. Should these have different sizes, we cannot cast between      them and the overlaying onto ERRATIC will not work.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|fde
operator|*
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|fde
operator|*
operator|*
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|fde
modifier|*
modifier|*
name|probe
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|chain_end
init|;
name|probe
operator|!=
operator|&
name|marker
operator|&&
name|fde_compare
argument_list|(
name|ob
argument_list|,
name|linear
operator|->
name|array
index|[
name|i
index|]
argument_list|,
operator|*
name|probe
argument_list|)
operator|<
literal|0
condition|;
name|probe
operator|=
name|chain_end
control|)
block|{
name|chain_end
operator|=
operator|(
name|fde
operator|*
operator|*
operator|)
name|erratic
operator|->
name|array
index|[
name|probe
operator|-
name|linear
operator|->
name|array
index|]
expr_stmt|;
name|erratic
operator|->
name|array
index|[
name|probe
operator|-
name|linear
operator|->
name|array
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|erratic
operator|->
name|array
index|[
name|i
index|]
operator|=
operator|(
name|fde
operator|*
operator|)
name|chain_end
expr_stmt|;
name|chain_end
operator|=
operator|&
name|linear
operator|->
name|array
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Each entry in LINEAR which is part of the linear sequence we have      discovered will correspond to a non-NULL entry in the chain we built in      the ERRATIC array.  */
for|for
control|(
name|i
operator|=
name|j
operator|=
name|k
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|erratic
operator|->
name|array
index|[
name|i
index|]
condition|)
name|linear
operator|->
name|array
index|[
name|j
operator|++
index|]
operator|=
name|linear
operator|->
name|array
index|[
name|i
index|]
expr_stmt|;
else|else
name|erratic
operator|->
name|array
index|[
name|k
operator|++
index|]
operator|=
name|linear
operator|->
name|array
index|[
name|i
index|]
expr_stmt|;
name|linear
operator|->
name|count
operator|=
name|j
expr_stmt|;
name|erratic
operator|->
name|count
operator|=
name|k
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is O(n log(n)).  BSD/OS defines heapsort in stdlib.h, so we must    use a name that does not conflict.  */
end_comment

begin_function
specifier|static
name|void
name|frame_heapsort
parameter_list|(
name|struct
name|object
modifier|*
name|ob
parameter_list|,
name|fde_compare_t
name|fde_compare
parameter_list|,
name|struct
name|fde_vector
modifier|*
name|erratic
parameter_list|)
block|{
comment|/* For a description of this algorithm, see:      Samuel P. Harbison, Guy L. Steele Jr.: C, a reference manual, 2nd ed.,      p. 60-61.  */
name|fde
modifier|*
modifier|*
name|a
init|=
name|erratic
operator|->
name|array
decl_stmt|;
comment|/* A portion of the array is called a "heap" if for all i>=0:      If i and 2i+1 are valid indices, then a[i]>= a[2i+1].      If i and 2i+2 are valid indices, then a[i]>= a[2i+2].  */
define|#
directive|define
name|SWAP
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|do { fde * tmp = x; x = y; y = tmp; } while (0)
name|size_t
name|n
init|=
name|erratic
operator|->
name|count
decl_stmt|;
name|size_t
name|m
init|=
name|n
decl_stmt|;
name|size_t
name|i
decl_stmt|;
while|while
condition|(
name|m
operator|>
literal|0
condition|)
block|{
comment|/* Invariant: a[m..n-1] is a heap.  */
name|m
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
init|;
literal|2
operator|*
name|i
operator|+
literal|1
operator|<
name|n
condition|;
control|)
block|{
if|if
condition|(
literal|2
operator|*
name|i
operator|+
literal|2
operator|<
name|n
operator|&&
name|fde_compare
argument_list|(
name|ob
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|2
index|]
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
operator|>
literal|0
operator|&&
name|fde_compare
argument_list|(
name|ob
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|2
index|]
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|SWAP
argument_list|(
name|a
index|[
name|i
index|]
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|2
operator|*
name|i
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fde_compare
argument_list|(
name|ob
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|SWAP
argument_list|(
name|a
index|[
name|i
index|]
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|2
operator|*
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
while|while
condition|(
name|n
operator|>
literal|1
condition|)
block|{
comment|/* Invariant: a[0..n-1] is a heap.  */
name|n
operator|--
expr_stmt|;
name|SWAP
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
name|n
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
literal|2
operator|*
name|i
operator|+
literal|1
operator|<
name|n
condition|;
control|)
block|{
if|if
condition|(
literal|2
operator|*
name|i
operator|+
literal|2
operator|<
name|n
operator|&&
name|fde_compare
argument_list|(
name|ob
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|2
index|]
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
operator|>
literal|0
operator|&&
name|fde_compare
argument_list|(
name|ob
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|2
index|]
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|SWAP
argument_list|(
name|a
index|[
name|i
index|]
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|2
operator|*
name|i
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fde_compare
argument_list|(
name|ob
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|SWAP
argument_list|(
name|a
index|[
name|i
index|]
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|2
operator|*
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
undef|#
directive|undef
name|SWAP
block|}
end_function

begin_comment
comment|/* Merge V1 and V2, both sorted, and put the result into V1.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|fde_merge
parameter_list|(
name|struct
name|object
modifier|*
name|ob
parameter_list|,
name|fde_compare_t
name|fde_compare
parameter_list|,
name|struct
name|fde_vector
modifier|*
name|v1
parameter_list|,
name|struct
name|fde_vector
modifier|*
name|v2
parameter_list|)
block|{
name|size_t
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|fde
modifier|*
name|fde2
decl_stmt|;
name|i2
operator|=
name|v2
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|i2
operator|>
literal|0
condition|)
block|{
name|i1
operator|=
name|v1
operator|->
name|count
expr_stmt|;
do|do
block|{
name|i2
operator|--
expr_stmt|;
name|fde2
operator|=
name|v2
operator|->
name|array
index|[
name|i2
index|]
expr_stmt|;
while|while
condition|(
name|i1
operator|>
literal|0
operator|&&
name|fde_compare
argument_list|(
name|ob
argument_list|,
name|v1
operator|->
name|array
index|[
name|i1
operator|-
literal|1
index|]
argument_list|,
name|fde2
argument_list|)
operator|>
literal|0
condition|)
block|{
name|v1
operator|->
name|array
index|[
name|i1
operator|+
name|i2
index|]
operator|=
name|v1
operator|->
name|array
index|[
name|i1
operator|-
literal|1
index|]
expr_stmt|;
name|i1
operator|--
expr_stmt|;
block|}
name|v1
operator|->
name|array
index|[
name|i1
operator|+
name|i2
index|]
operator|=
name|fde2
expr_stmt|;
block|}
do|while
condition|(
name|i2
operator|>
literal|0
condition|)
do|;
name|v1
operator|->
name|count
operator|+=
name|v2
operator|->
name|count
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|end_fde_sort
parameter_list|(
name|struct
name|object
modifier|*
name|ob
parameter_list|,
name|struct
name|fde_accumulator
modifier|*
name|accu
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|fde_compare_t
name|fde_compare
decl_stmt|;
if|if
condition|(
name|accu
operator|->
name|linear
operator|&&
name|accu
operator|->
name|linear
operator|->
name|count
operator|!=
name|count
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|mixed_encoding
condition|)
name|fde_compare
operator|=
name|fde_mixed_encoding_compare
expr_stmt|;
elseif|else
if|if
condition|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
operator|==
name|DW_EH_PE_absptr
condition|)
name|fde_compare
operator|=
name|fde_unencoded_compare
expr_stmt|;
else|else
name|fde_compare
operator|=
name|fde_single_encoding_compare
expr_stmt|;
if|if
condition|(
name|accu
operator|->
name|erratic
condition|)
block|{
name|fde_split
argument_list|(
name|ob
argument_list|,
name|fde_compare
argument_list|,
name|accu
operator|->
name|linear
argument_list|,
name|accu
operator|->
name|erratic
argument_list|)
expr_stmt|;
if|if
condition|(
name|accu
operator|->
name|linear
operator|->
name|count
operator|+
name|accu
operator|->
name|erratic
operator|->
name|count
operator|!=
name|count
condition|)
name|abort
argument_list|()
expr_stmt|;
name|frame_heapsort
argument_list|(
name|ob
argument_list|,
name|fde_compare
argument_list|,
name|accu
operator|->
name|erratic
argument_list|)
expr_stmt|;
name|fde_merge
argument_list|(
name|ob
argument_list|,
name|fde_compare
argument_list|,
name|accu
operator|->
name|linear
argument_list|,
name|accu
operator|->
name|erratic
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|accu
operator|->
name|erratic
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We've not managed to malloc an erratic array, 	 so heap sort in the linear one.  */
name|frame_heapsort
argument_list|(
name|ob
argument_list|,
name|fde_compare
argument_list|,
name|accu
operator|->
name|linear
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update encoding, mixed_encoding, and pc_begin for OB for the     fde array beginning at THIS_FDE.  Return the number of fdes    encountered along the way.  */
end_comment

begin_function
specifier|static
name|size_t
name|classify_object_over_fdes
parameter_list|(
name|struct
name|object
modifier|*
name|ob
parameter_list|,
name|fde
modifier|*
name|this_fde
parameter_list|)
block|{
name|struct
name|dwarf_cie
modifier|*
name|last_cie
init|=
literal|0
decl_stmt|;
name|size_t
name|count
init|=
literal|0
decl_stmt|;
name|int
name|encoding
init|=
name|DW_EH_PE_absptr
decl_stmt|;
name|_Unwind_Ptr
name|base
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|this_fde
operator|->
name|length
operator|!=
literal|0
condition|;
name|this_fde
operator|=
name|next_fde
argument_list|(
name|this_fde
argument_list|)
control|)
block|{
name|struct
name|dwarf_cie
modifier|*
name|this_cie
decl_stmt|;
name|_Unwind_Ptr
name|mask
decl_stmt|,
name|pc_begin
decl_stmt|;
comment|/* Skip CIEs.  */
if|if
condition|(
name|this_fde
operator|->
name|CIE_delta
operator|==
literal|0
condition|)
continue|continue;
comment|/* Determine the encoding for this FDE.  Note mixed encoded 	 objects for later.  */
name|this_cie
operator|=
name|get_cie
argument_list|(
name|this_fde
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_cie
operator|!=
name|last_cie
condition|)
block|{
name|last_cie
operator|=
name|this_cie
expr_stmt|;
name|encoding
operator|=
name|get_cie_encoding
argument_list|(
name|this_cie
argument_list|)
expr_stmt|;
name|base
operator|=
name|base_from_object
argument_list|(
name|encoding
argument_list|,
name|ob
argument_list|)
expr_stmt|;
if|if
condition|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
operator|==
name|DW_EH_PE_omit
condition|)
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
operator|=
name|encoding
expr_stmt|;
elseif|else
if|if
condition|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
operator|!=
name|encoding
condition|)
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|mixed_encoding
operator|=
literal|1
expr_stmt|;
block|}
name|read_encoded_value_with_base
argument_list|(
name|encoding
argument_list|,
name|base
argument_list|,
name|this_fde
operator|->
name|pc_begin
argument_list|,
operator|&
name|pc_begin
argument_list|)
expr_stmt|;
comment|/* Take care to ignore link-once functions that were removed. 	 In these cases, the function address will be NULL, but if 	 the encoding is smaller than a pointer a true NULL may not 	 be representable.  Assume 0 in the representable bits is NULL.  */
name|mask
operator|=
name|size_of_encoded_value
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|<
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
condition|)
name|mask
operator|=
operator|(
literal|1L
operator|<<
operator|(
name|mask
operator|<<
literal|3
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|mask
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|pc_begin
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|pc_begin
operator|<
name|ob
operator|->
name|pc_begin
condition|)
name|ob
operator|->
name|pc_begin
operator|=
operator|(
name|void
operator|*
operator|)
name|pc_begin
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_fdes
parameter_list|(
name|struct
name|object
modifier|*
name|ob
parameter_list|,
name|struct
name|fde_accumulator
modifier|*
name|accu
parameter_list|,
name|fde
modifier|*
name|this_fde
parameter_list|)
block|{
name|struct
name|dwarf_cie
modifier|*
name|last_cie
init|=
literal|0
decl_stmt|;
name|int
name|encoding
init|=
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
decl_stmt|;
name|_Unwind_Ptr
name|base
init|=
name|base_from_object
argument_list|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
argument_list|,
name|ob
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|this_fde
operator|->
name|length
operator|!=
literal|0
condition|;
name|this_fde
operator|=
name|next_fde
argument_list|(
name|this_fde
argument_list|)
control|)
block|{
name|struct
name|dwarf_cie
modifier|*
name|this_cie
decl_stmt|;
comment|/* Skip CIEs.  */
if|if
condition|(
name|this_fde
operator|->
name|CIE_delta
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|mixed_encoding
condition|)
block|{
comment|/* Determine the encoding for this FDE.  Note mixed encoded 	     objects for later.  */
name|this_cie
operator|=
name|get_cie
argument_list|(
name|this_fde
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_cie
operator|!=
name|last_cie
condition|)
block|{
name|last_cie
operator|=
name|this_cie
expr_stmt|;
name|encoding
operator|=
name|get_cie_encoding
argument_list|(
name|this_cie
argument_list|)
expr_stmt|;
name|base
operator|=
name|base_from_object
argument_list|(
name|encoding
argument_list|,
name|ob
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|encoding
operator|==
name|DW_EH_PE_absptr
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|_Unwind_Ptr
operator|*
operator|)
name|this_fde
operator|->
name|pc_begin
operator|==
literal|0
condition|)
continue|continue;
block|}
else|else
block|{
name|_Unwind_Ptr
name|pc_begin
decl_stmt|,
name|mask
decl_stmt|;
name|read_encoded_value_with_base
argument_list|(
name|encoding
argument_list|,
name|base
argument_list|,
name|this_fde
operator|->
name|pc_begin
argument_list|,
operator|&
name|pc_begin
argument_list|)
expr_stmt|;
comment|/* Take care to ignore link-once functions that were removed. 	     In these cases, the function address will be NULL, but if 	     the encoding is smaller than a pointer a true NULL may not 	     be representable.  Assume 0 in the representable bits is NULL.  */
name|mask
operator|=
name|size_of_encoded_value
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|<
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
condition|)
name|mask
operator|=
operator|(
literal|1L
operator|<<
operator|(
name|mask
operator|<<
literal|3
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|mask
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|pc_begin
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
continue|continue;
block|}
name|fde_insert
argument_list|(
name|accu
argument_list|,
name|this_fde
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set up a sorted array of pointers to FDEs for a loaded object.  We    count up the entries before allocating the array because it's likely to    be faster.  We can be called multiple times, should we have failed to    allocate a sorted fde array on a previous occasion.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|init_object
parameter_list|(
name|struct
name|object
modifier|*
name|ob
parameter_list|)
block|{
name|struct
name|fde_accumulator
name|accu
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|count
operator|=
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|from_array
condition|)
block|{
name|fde
modifier|*
modifier|*
name|p
init|=
name|ob
operator|->
name|u
operator|.
name|array
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
name|count
operator|+=
name|classify_object_over_fdes
argument_list|(
name|ob
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|count
operator|=
name|classify_object_over_fdes
argument_list|(
name|ob
argument_list|,
name|ob
operator|->
name|u
operator|.
name|single
argument_list|)
expr_stmt|;
comment|/* The count field we have in the main struct object is somewhat 	 limited, but should suffice for virtually all cases.  If the 	 counted value doesn't fit, re-write a zero.  The worst that 	 happens is that we re-count next time -- admittedly non-trivial 	 in that this implies some 2M fdes, but at least we function.  */
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|count
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|count
operator|!=
name|count
condition|)
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|start_fde_sort
argument_list|(
operator|&
name|accu
argument_list|,
name|count
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|from_array
condition|)
block|{
name|fde
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|ob
operator|->
name|u
operator|.
name|array
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
name|add_fdes
argument_list|(
name|ob
argument_list|,
operator|&
name|accu
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|add_fdes
argument_list|(
name|ob
argument_list|,
operator|&
name|accu
argument_list|,
name|ob
operator|->
name|u
operator|.
name|single
argument_list|)
expr_stmt|;
name|end_fde_sort
argument_list|(
name|ob
argument_list|,
operator|&
name|accu
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Save the original fde pointer, since this is the key by which the      DSO will deregister the object.  */
name|accu
operator|.
name|linear
operator|->
name|orig_data
operator|=
name|ob
operator|->
name|u
operator|.
name|single
expr_stmt|;
name|ob
operator|->
name|u
operator|.
name|sort
operator|=
name|accu
operator|.
name|linear
expr_stmt|;
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|sorted
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A linear search through a set of FDEs for the given PC.  This is    used when there was insufficient memory to allocate and sort an    array.  */
end_comment

begin_function
specifier|static
name|fde
modifier|*
name|linear_search_fdes
parameter_list|(
name|struct
name|object
modifier|*
name|ob
parameter_list|,
name|fde
modifier|*
name|this_fde
parameter_list|,
name|void
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|dwarf_cie
modifier|*
name|last_cie
init|=
literal|0
decl_stmt|;
name|int
name|encoding
init|=
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
decl_stmt|;
name|_Unwind_Ptr
name|base
init|=
name|base_from_object
argument_list|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
argument_list|,
name|ob
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|this_fde
operator|->
name|length
operator|!=
literal|0
condition|;
name|this_fde
operator|=
name|next_fde
argument_list|(
name|this_fde
argument_list|)
control|)
block|{
name|struct
name|dwarf_cie
modifier|*
name|this_cie
decl_stmt|;
name|_Unwind_Ptr
name|pc_begin
decl_stmt|,
name|pc_range
decl_stmt|;
comment|/* Skip CIEs.  */
if|if
condition|(
name|this_fde
operator|->
name|CIE_delta
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|mixed_encoding
condition|)
block|{
comment|/* Determine the encoding for this FDE.  Note mixed encoded 	     objects for later.  */
name|this_cie
operator|=
name|get_cie
argument_list|(
name|this_fde
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_cie
operator|!=
name|last_cie
condition|)
block|{
name|last_cie
operator|=
name|this_cie
expr_stmt|;
name|encoding
operator|=
name|get_cie_encoding
argument_list|(
name|this_cie
argument_list|)
expr_stmt|;
name|base
operator|=
name|base_from_object
argument_list|(
name|encoding
argument_list|,
name|ob
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|encoding
operator|==
name|DW_EH_PE_absptr
condition|)
block|{
name|pc_begin
operator|=
operator|(
operator|(
name|_Unwind_Ptr
operator|*
operator|)
name|this_fde
operator|->
name|pc_begin
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|pc_range
operator|=
operator|(
operator|(
name|_Unwind_Ptr
operator|*
operator|)
name|this_fde
operator|->
name|pc_begin
operator|)
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|pc_begin
operator|==
literal|0
condition|)
continue|continue;
block|}
else|else
block|{
name|_Unwind_Ptr
name|mask
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|read_encoded_value_with_base
argument_list|(
name|encoding
argument_list|,
name|base
argument_list|,
name|this_fde
operator|->
name|pc_begin
argument_list|,
operator|&
name|pc_begin
argument_list|)
expr_stmt|;
name|read_encoded_value_with_base
argument_list|(
name|encoding
operator|&
literal|0x0F
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
operator|&
name|pc_range
argument_list|)
expr_stmt|;
comment|/* Take care to ignore link-once functions that were removed. 	     In these cases, the function address will be NULL, but if 	     the encoding is smaller than a pointer a true NULL may not 	     be representable.  Assume 0 in the representable bits is NULL.  */
name|mask
operator|=
name|size_of_encoded_value
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|<
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
condition|)
name|mask
operator|=
operator|(
literal|1L
operator|<<
operator|(
name|mask
operator|<<
literal|3
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|mask
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|pc_begin
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
continue|continue;
block|}
if|if
condition|(
operator|(
name|_Unwind_Ptr
operator|)
name|pc
operator|-
name|pc_begin
operator|<
name|pc_range
condition|)
return|return
name|this_fde
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Binary search for an FDE containing the given PC.  Here are three    implementations of increasing complexity.  */
end_comment

begin_function
specifier|static
specifier|inline
name|fde
modifier|*
name|binary_search_unencoded_fdes
parameter_list|(
name|struct
name|object
modifier|*
name|ob
parameter_list|,
name|void
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|fde_vector
modifier|*
name|vec
init|=
name|ob
operator|->
name|u
operator|.
name|sort
decl_stmt|;
name|size_t
name|lo
decl_stmt|,
name|hi
decl_stmt|;
for|for
control|(
name|lo
operator|=
literal|0
operator|,
name|hi
operator|=
name|vec
operator|->
name|count
init|;
name|lo
operator|<
name|hi
condition|;
control|)
block|{
name|size_t
name|i
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
decl_stmt|;
name|fde
modifier|*
name|f
init|=
name|vec
operator|->
name|array
index|[
name|i
index|]
decl_stmt|;
name|void
modifier|*
name|pc_begin
decl_stmt|;
name|uaddr
name|pc_range
decl_stmt|;
name|pc_begin
operator|=
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|f
operator|->
name|pc_begin
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|pc_range
operator|=
operator|(
operator|(
name|uaddr
operator|*
operator|)
name|f
operator|->
name|pc_begin
operator|)
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|pc
operator|<
name|pc_begin
condition|)
name|hi
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|pc
operator|>=
name|pc_begin
operator|+
name|pc_range
condition|)
name|lo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|f
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|fde
modifier|*
name|binary_search_single_encoding_fdes
parameter_list|(
name|struct
name|object
modifier|*
name|ob
parameter_list|,
name|void
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|fde_vector
modifier|*
name|vec
init|=
name|ob
operator|->
name|u
operator|.
name|sort
decl_stmt|;
name|int
name|encoding
init|=
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
decl_stmt|;
name|_Unwind_Ptr
name|base
init|=
name|base_from_object
argument_list|(
name|encoding
argument_list|,
name|ob
argument_list|)
decl_stmt|;
name|size_t
name|lo
decl_stmt|,
name|hi
decl_stmt|;
for|for
control|(
name|lo
operator|=
literal|0
operator|,
name|hi
operator|=
name|vec
operator|->
name|count
init|;
name|lo
operator|<
name|hi
condition|;
control|)
block|{
name|size_t
name|i
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
decl_stmt|;
name|fde
modifier|*
name|f
init|=
name|vec
operator|->
name|array
index|[
name|i
index|]
decl_stmt|;
name|_Unwind_Ptr
name|pc_begin
decl_stmt|,
name|pc_range
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|read_encoded_value_with_base
argument_list|(
name|encoding
argument_list|,
name|base
argument_list|,
name|f
operator|->
name|pc_begin
argument_list|,
operator|&
name|pc_begin
argument_list|)
expr_stmt|;
name|read_encoded_value_with_base
argument_list|(
name|encoding
operator|&
literal|0x0F
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
operator|&
name|pc_range
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|_Unwind_Ptr
operator|)
name|pc
operator|<
name|pc_begin
condition|)
name|hi
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|_Unwind_Ptr
operator|)
name|pc
operator|>=
name|pc_begin
operator|+
name|pc_range
condition|)
name|lo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|f
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|fde
modifier|*
name|binary_search_mixed_encoding_fdes
parameter_list|(
name|struct
name|object
modifier|*
name|ob
parameter_list|,
name|void
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|fde_vector
modifier|*
name|vec
init|=
name|ob
operator|->
name|u
operator|.
name|sort
decl_stmt|;
name|size_t
name|lo
decl_stmt|,
name|hi
decl_stmt|;
for|for
control|(
name|lo
operator|=
literal|0
operator|,
name|hi
operator|=
name|vec
operator|->
name|count
init|;
name|lo
operator|<
name|hi
condition|;
control|)
block|{
name|size_t
name|i
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
decl_stmt|;
name|fde
modifier|*
name|f
init|=
name|vec
operator|->
name|array
index|[
name|i
index|]
decl_stmt|;
name|_Unwind_Ptr
name|pc_begin
decl_stmt|,
name|pc_range
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|encoding
decl_stmt|;
name|encoding
operator|=
name|get_fde_encoding
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|p
operator|=
name|read_encoded_value_with_base
argument_list|(
name|encoding
argument_list|,
name|base_from_object
argument_list|(
name|encoding
argument_list|,
name|ob
argument_list|)
argument_list|,
name|f
operator|->
name|pc_begin
argument_list|,
operator|&
name|pc_begin
argument_list|)
expr_stmt|;
name|read_encoded_value_with_base
argument_list|(
name|encoding
operator|&
literal|0x0F
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
operator|&
name|pc_range
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|_Unwind_Ptr
operator|)
name|pc
operator|<
name|pc_begin
condition|)
name|hi
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|_Unwind_Ptr
operator|)
name|pc
operator|>=
name|pc_begin
operator|+
name|pc_range
condition|)
name|lo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|f
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|fde
modifier|*
name|search_object
parameter_list|(
name|struct
name|object
modifier|*
name|ob
parameter_list|,
name|void
modifier|*
name|pc
parameter_list|)
block|{
comment|/* If the data hasn't been sorted, try to do this now.  We may have      more memory available than last time we tried.  */
if|if
condition|(
operator|!
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|sorted
condition|)
block|{
name|init_object
argument_list|(
name|ob
argument_list|)
expr_stmt|;
comment|/* Despite the above comment, the normal reason to get here is 	 that we've not processed this object before.  A quick range 	 check is in order.  */
if|if
condition|(
name|pc
operator|<
name|ob
operator|->
name|pc_begin
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|sorted
condition|)
block|{
if|if
condition|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|mixed_encoding
condition|)
return|return
name|binary_search_mixed_encoding_fdes
argument_list|(
name|ob
argument_list|,
name|pc
argument_list|)
return|;
elseif|else
if|if
condition|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
operator|==
name|DW_EH_PE_absptr
condition|)
return|return
name|binary_search_unencoded_fdes
argument_list|(
name|ob
argument_list|,
name|pc
argument_list|)
return|;
else|else
return|return
name|binary_search_single_encoding_fdes
argument_list|(
name|ob
argument_list|,
name|pc
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Long slow labourious linear search, cos we've no memory.  */
if|if
condition|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|from_array
condition|)
block|{
name|fde
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|ob
operator|->
name|u
operator|.
name|array
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|fde
modifier|*
name|f
init|=
name|linear_search_fdes
argument_list|(
name|ob
argument_list|,
operator|*
name|p
argument_list|,
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
condition|)
return|return
name|f
return|;
block|}
return|return
name|NULL
return|;
block|}
else|else
return|return
name|linear_search_fdes
argument_list|(
name|ob
argument_list|,
name|ob
operator|->
name|u
operator|.
name|single
argument_list|,
name|pc
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|fde
modifier|*
name|_Unwind_Find_FDE
parameter_list|(
name|void
modifier|*
name|pc
parameter_list|,
name|struct
name|dwarf_eh_bases
modifier|*
name|bases
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|ob
decl_stmt|;
name|fde
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
name|init_object_mutex_once
argument_list|()
expr_stmt|;
name|__gthread_mutex_lock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
comment|/* Linear search through the classified objects, to find the one      containing the pc.  Note that pc_begin is sorted descending, and      we expect objects to be non-overlapping.  */
for|for
control|(
name|ob
operator|=
name|seen_objects
init|;
name|ob
condition|;
name|ob
operator|=
name|ob
operator|->
name|next
control|)
if|if
condition|(
name|pc
operator|>=
name|ob
operator|->
name|pc_begin
condition|)
block|{
name|f
operator|=
name|search_object
argument_list|(
name|ob
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
goto|goto
name|fini
goto|;
break|break;
block|}
comment|/* Classify and search the objects we've not yet processed.  */
while|while
condition|(
operator|(
name|ob
operator|=
name|unseen_objects
operator|)
condition|)
block|{
name|struct
name|object
modifier|*
modifier|*
name|p
decl_stmt|;
name|unseen_objects
operator|=
name|ob
operator|->
name|next
expr_stmt|;
name|f
operator|=
name|search_object
argument_list|(
name|ob
argument_list|,
name|pc
argument_list|)
expr_stmt|;
comment|/* Insert the object into the classified list.  */
for|for
control|(
name|p
operator|=
operator|&
name|seen_objects
init|;
operator|*
name|p
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|pc_begin
operator|<
name|ob
operator|->
name|pc_begin
condition|)
break|break;
name|ob
operator|->
name|next
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
name|ob
expr_stmt|;
if|if
condition|(
name|f
condition|)
goto|goto
name|fini
goto|;
block|}
name|fini
label|:
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|int
name|encoding
decl_stmt|;
name|bases
operator|->
name|tbase
operator|=
name|ob
operator|->
name|tbase
expr_stmt|;
name|bases
operator|->
name|dbase
operator|=
name|ob
operator|->
name|dbase
expr_stmt|;
name|encoding
operator|=
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|encoding
expr_stmt|;
if|if
condition|(
name|ob
operator|->
name|s
operator|.
name|b
operator|.
name|mixed_encoding
condition|)
name|encoding
operator|=
name|get_fde_encoding
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|read_encoded_value_with_base
argument_list|(
name|encoding
argument_list|,
name|base_from_object
argument_list|(
name|encoding
argument_list|,
name|ob
argument_list|)
argument_list|,
name|f
operator|->
name|pc_begin
argument_list|,
operator|(
name|_Unwind_Ptr
operator|*
operator|)
operator|&
name|bases
operator|->
name|func
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

end_unit

