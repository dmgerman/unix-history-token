begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Top level of GCC compilers (cc1, cc1plus, etc.)    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* This is the top level of cc1/c++.    It parses command args, opens files, invokes the various passes    in the proper order, and counts the time used by each.    Error messages and low-level interface to malloc also handled here.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_undef
undef|#
directive|undef
name|FLOAT
end_undef

begin_comment
comment|/* This is for hpux. They should change hpux.  */
end_comment

begin_undef
undef|#
directive|undef
name|FFS
end_undef

begin_comment
comment|/* Some systems define this in param.h.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_RESOURCE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIMES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"graph.h"
end_include

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2asm.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"hosthooks.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"opts.h"
end_include

begin_include
include|#
directive|include
file|"coverage.h"
end_include

begin_include
include|#
directive|include
file|"value-prof.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
end_if

begin_include
include|#
directive|include
file|"dwarf2out.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
end_if

begin_include
include|#
directive|include
file|"dbxout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"sdbout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_comment
comment|/* Needed for external data 				   declarations for e.g. AIX 4.x.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_conditional_execution
end_ifndef

begin_define
define|#
directive|define
name|HAVE_conditional_execution
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Carry information from ASM_DECLARE_OBJECT_NAME    to ASM_FINISH_DECLARE_OBJECT.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|size_directive_output
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|last_assemble_variable_decl
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|reg_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|general_init
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_compile
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_options
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|backend_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lang_dependent_init
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_asm_output
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finalize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|crash_signal
argument_list|(
name|int
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|setup_core_dumping
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compile_file
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_single_switch
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_switch_values
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Rest of compilation helper functions.  */
end_comment

begin_function_decl
specifier|static
name|bool
name|rest_of_handle_inlining
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_cse
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_cse2
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_gcse
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_life
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_loop_optimize
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_loop2
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_jump_bypass
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_sibling_calls
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_null_pointer
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_addressof
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_cfg
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_branch_prob
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_value_profile_transformations
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_if_conversion
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_if_after_combine
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_tracer
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_combine
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_regmove
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
end_ifdef

begin_function_decl
specifier|static
name|void
name|rest_of_handle_sched
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_sched2
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|bool
name|rest_of_handle_new_regalloc
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rest_of_handle_old_regalloc
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_regrename
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rest_of_handle_reorder_blocks
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_REGS
end_ifdef

begin_function_decl
specifier|static
name|void
name|rest_of_handle_stack_regs
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|rest_of_handle_machine_reorg
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DELAY_SLOTS
end_ifdef

begin_function_decl
specifier|static
name|void
name|rest_of_handle_delay_slots
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|rest_of_handle_final
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Nonzero to dump debug info whilst parsing (-dy option).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|set_yydebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we don't need a backend (e.g. preprocessing only).  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|no_backend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of line when printing switch values.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LINE
value|75
end_define

begin_comment
comment|/* Name of program invoked, sans directories.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy of argument vector to toplev_main.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|save_argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of top-level original source file (what was input to cpp).    This comes from the #-command at the beginning of the actual input.    If there isn't any there, then this is the cc1 input file name.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|main_input_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current position in real source file.  */
end_comment

begin_decl_stmt
name|location_t
name|input_location
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if it is unsafe to create any new pseudo registers.  */
end_comment

begin_decl_stmt
name|int
name|no_new_pseudos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of currently pending input files.  */
end_comment

begin_decl_stmt
name|struct
name|file_stack
modifier|*
name|input_file_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incremented on each change to input_file_stack.  */
end_comment

begin_decl_stmt
name|int
name|input_file_stack_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name to use as base of names for dump output files.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|dump_base_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name to use as a base for auxiliary output files.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|aux_base_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Format to use to print dumpfile index value */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DUMPFILE_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|DUMPFILE_FORMAT
value|".%02d."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Bit flags that specify the machine subtype we are compiling for.    Bits are tested using macros TARGET_... defined in the tm.h file    and set by `-m...' switches.  Must be defined in rtlanal.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|target_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A mask of target_flags that includes bit X if X was set or cleared    on the command line.  */
end_comment

begin_decl_stmt
name|int
name|target_flags_explicit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debug hooks - dependent upon command line options.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|gcc_debug_hooks
modifier|*
name|debug_hooks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describes a dump file.  */
end_comment

begin_struct
struct|struct
name|dump_file_info
block|{
comment|/* The unique extension to apply, e.g. ".jump".  */
specifier|const
name|char
modifier|*
specifier|const
name|extension
decl_stmt|;
comment|/* The -d<c> character that enables this dump file.  */
name|char
specifier|const
name|debug_switch
decl_stmt|;
comment|/* True if there is a corresponding graph dump file.  */
name|char
specifier|const
name|graph_dump_p
decl_stmt|;
comment|/* True if the user selected this dump.  */
name|char
name|enabled
decl_stmt|;
comment|/* True if the files have been initialized (ie truncated).  */
name|char
name|initialized
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Enumerate the extant dump files.  */
end_comment

begin_enum
enum|enum
name|dump_file_index
block|{
name|DFI_cgraph
block|,
name|DFI_rtl
block|,
name|DFI_sibling
block|,
name|DFI_eh
block|,
name|DFI_jump
block|,
name|DFI_null
block|,
name|DFI_cse
block|,
name|DFI_addressof
block|,
name|DFI_gcse
block|,
name|DFI_loop
block|,
name|DFI_bypass
block|,
name|DFI_cfg
block|,
name|DFI_bp
block|,
name|DFI_vpt
block|,
name|DFI_ce1
block|,
name|DFI_tracer
block|,
name|DFI_loop2
block|,
name|DFI_web
block|,
name|DFI_cse2
block|,
name|DFI_life
block|,
name|DFI_combine
block|,
name|DFI_ce2
block|,
name|DFI_regmove
block|,
name|DFI_sched
block|,
name|DFI_lreg
block|,
name|DFI_greg
block|,
name|DFI_postreload
block|,
name|DFI_flow2
block|,
name|DFI_peephole2
block|,
name|DFI_ce3
block|,
name|DFI_rnreg
block|,
name|DFI_bbro
block|,
name|DFI_branch_target_load
block|,
name|DFI_sched2
block|,
name|DFI_stack
block|,
name|DFI_mach
block|,
name|DFI_dbr
block|,
name|DFI_MAX
block|}
enum|;
end_enum

begin_comment
comment|/* Describes all the dump files.  Should be kept in order of the    pass and in sync with dump_file_index above.     Remaining -d letters:  	"   e        m   q         " 	"         JK   O Q     WXY " */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dump_file_info
name|dump_file
index|[
name|DFI_MAX
index|]
init|=
block|{
block|{
literal|"cgraph"
block|,
literal|'U'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"rtl"
block|,
literal|'r'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sibling"
block|,
literal|'i'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"eh"
block|,
literal|'h'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"jump"
block|,
literal|'j'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"null"
block|,
literal|'u'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"cse"
block|,
literal|'s'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"addressof"
block|,
literal|'F'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"gcse"
block|,
literal|'G'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"loop"
block|,
literal|'L'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"bypass"
block|,
literal|'G'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Yes, duplicate enable switch.  */
block|{
literal|"cfg"
block|,
literal|'f'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"bp"
block|,
literal|'b'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"vpt"
block|,
literal|'V'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ce1"
block|,
literal|'C'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"tracer"
block|,
literal|'T'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"loop2"
block|,
literal|'L'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"web"
block|,
literal|'Z'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"cse2"
block|,
literal|'t'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"life"
block|,
literal|'f'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Yes, duplicate enable switch.  */
block|{
literal|"combine"
block|,
literal|'c'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ce2"
block|,
literal|'C'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"regmove"
block|,
literal|'N'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sched"
block|,
literal|'S'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"lreg"
block|,
literal|'l'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"greg"
block|,
literal|'g'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"postreload"
block|,
literal|'o'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"flow2"
block|,
literal|'w'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"peephole2"
block|,
literal|'z'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ce3"
block|,
literal|'E'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"rnreg"
block|,
literal|'n'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"bbro"
block|,
literal|'B'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"btl"
block|,
literal|'d'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Yes, duplicate enable switch.  */
block|{
literal|"sched2"
block|,
literal|'R'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"stack"
block|,
literal|'k'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"mach"
block|,
literal|'M'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"dbr"
block|,
literal|'d'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|open_dump_file
parameter_list|(
name|enum
name|dump_file_index
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|close_dump_file
argument_list|(
expr|enum
name|dump_file_index
argument_list|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|FILE
operator|*
argument_list|,
name|rtx
argument_list|)
argument_list|,
name|rtx
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Other flags saying which kinds of debugging dump have been requested.  */
end_comment

begin_decl_stmt
name|int
name|rtl_dump_and_exit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_print_asm_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|graph_dump_types
name|graph_dump_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name for output file of assembly code, specified with -o.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|asm_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do optimizations.  -O.    Particular numeric values stand for particular amounts of optimization;    thus, -O2 stores 2 here.  However, the optimizations beyond the basic    ones are not controlled directly by this variable.  Instead, they are    controlled by individual `flag_...' variables that are defaulted    based on this variable.  */
end_comment

begin_decl_stmt
name|int
name|optimize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means optimize for size.  -Os.    The only valid values are zero and nonzero. When optimize_size is    nonzero, optimize defaults to 2, but certain individual code    bloating optimizations are disabled.  */
end_comment

begin_decl_stmt
name|int
name|optimize_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The FUNCTION_DECL for the function currently being compiled,    or 0 if between functions.  */
end_comment

begin_decl_stmt
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to the FUNC_BEGIN label of the current function, or NULL_TREE    if none.  */
end_comment

begin_decl_stmt
name|tree
name|current_function_func_begin_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if doing dwarf2 duplicate elimination.  */
end_comment

begin_decl_stmt
name|int
name|flag_eliminate_dwarf2_dups
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if doing unused type elimination.  */
end_comment

begin_decl_stmt
name|int
name|flag_eliminate_unused_debug_types
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means emit debugging information only for symbols which are used.  */
end_comment

begin_decl_stmt
name|int
name|flag_debug_only_used_symbols
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if generating code to do profiling.  */
end_comment

begin_decl_stmt
name|int
name|profile_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if generating code to profile program flow graph arcs.  */
end_comment

begin_decl_stmt
name|int
name|profile_arc_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if value histograms should be measured.  */
end_comment

begin_decl_stmt
name|int
name|flag_profile_values
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if value histograms should be used to optimize code.  */
end_comment

begin_decl_stmt
name|int
name|flag_value_profile_transformations
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if generating info for gcov to calculate line test coverage.  */
end_comment

begin_decl_stmt
name|int
name|flag_test_coverage
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero indicates that branch taken probabilities should be calculated.  */
end_comment

begin_decl_stmt
name|int
name|flag_branch_probabilities
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if basic blocks should be reordered.  */
end_comment

begin_decl_stmt
name|int
name|flag_reorder_blocks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if functions should be reordered.  */
end_comment

begin_decl_stmt
name|int
name|flag_reorder_functions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if registers should be renamed.  */
end_comment

begin_decl_stmt
name|int
name|flag_rename_registers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_cprop_registers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -pedantic switch: warn about anything    that standard spec forbids.  */
end_comment

begin_decl_stmt
name|int
name|pedantic
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporarily suppress certain warnings.    This is set while reading code from a system header file.  */
end_comment

begin_decl_stmt
name|int
name|in_system_header
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't print functions as they are compiled.  -quiet.  */
end_comment

begin_decl_stmt
name|int
name|quiet_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print times taken by the various passes.  -ftime-report.  */
end_comment

begin_decl_stmt
name|int
name|time_report
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print memory still in use at end of compilation (which may have little    to do with peak memory consumption).  -fmem-report.  */
end_comment

begin_decl_stmt
name|int
name|mem_report
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to collect statistics which might be expensive    and to print them when we are done.  */
end_comment

begin_decl_stmt
name|int
name|flag_detailed_statistics
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A random sequence of characters, unless overridden by user.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|flag_random_seed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A local time stamp derived from the time of compilation. It will be    zero if the system cannot provide a time.  It will be -1u, if the    user has specified a particular random seed.  */
end_comment

begin_decl_stmt
name|unsigned
name|local_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -f flags.  */
end_comment

begin_comment
comment|/* Nonzero means `char' should be signed.  */
end_comment

begin_decl_stmt
name|int
name|flag_signed_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give an enum type only as many bytes as it needs.  */
end_comment

begin_decl_stmt
name|int
name|flag_short_enums
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fcaller-saves: allocate values in regs that need to    be saved across function calls, if that produces overall better code.    Optional now, so people can test it.  */
end_comment

begin_decl_stmt
name|int
name|flag_caller_saves
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if structures and unions should be returned in memory.     This should only be defined if compatibility with another compiler or    with an ABI is needed, because it results in slower code.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_PCC_STRUCT_RETURN
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_PCC_STRUCT_RETURN
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero for -fpcc-struct-return: return values the same way PCC does.  */
end_comment

begin_decl_stmt
name|int
name|flag_pcc_struct_return
init|=
name|DEFAULT_PCC_STRUCT_RETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fforce-mem: load memory value into a register    before arithmetic on it.  This makes better cse but slower compilation.  */
end_comment

begin_decl_stmt
name|int
name|flag_force_mem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fforce-addr: load memory address into a register before    reference to memory.  This makes better cse but slower compilation.  */
end_comment

begin_decl_stmt
name|int
name|flag_force_addr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fdefer-pop: don't pop args after each function call;    instead save them up to pop many calls' args with one insns.  */
end_comment

begin_decl_stmt
name|int
name|flag_defer_pop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -ffloat-store: don't allocate floats and doubles    in extended-precision registers.  */
end_comment

begin_decl_stmt
name|int
name|flag_float_store
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fcse-follow-jumps:    have cse follow jumps to do a more extensive job.  */
end_comment

begin_decl_stmt
name|int
name|flag_cse_follow_jumps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fcse-skip-blocks:    have cse follow a branch around a block.  */
end_comment

begin_decl_stmt
name|int
name|flag_cse_skip_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fexpensive-optimizations:    perform miscellaneous relatively-expensive optimizations.  */
end_comment

begin_decl_stmt
name|int
name|flag_expensive_optimizations
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fthread-jumps:    have jump optimize output of loop.  */
end_comment

begin_decl_stmt
name|int
name|flag_thread_jumps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables strength-reduction in loop.c.  */
end_comment

begin_decl_stmt
name|int
name|flag_strength_reduce
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables loop unrolling in unroll.c.  Only loops for which the    number of iterations can be calculated at compile-time (UNROLL_COMPLETELY,    UNROLL_MODULO) or at run-time (preconditioned to be UNROLL_MODULO) are    unrolled.  */
end_comment

begin_decl_stmt
name|int
name|flag_old_unroll_loops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables loop unrolling in unroll.c.  All loops are unrolled.    This is generally not a win.  */
end_comment

begin_decl_stmt
name|int
name|flag_old_unroll_all_loops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enables unrolling of simple loops in loop-unroll.c.  */
end_comment

begin_decl_stmt
name|int
name|flag_unroll_loops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enables unrolling of all loops in loop-unroll.c.  */
end_comment

begin_decl_stmt
name|int
name|flag_unroll_all_loops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables loop peeling.  */
end_comment

begin_decl_stmt
name|int
name|flag_peel_loops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables loop unswitching.  */
end_comment

begin_decl_stmt
name|int
name|flag_unswitch_loops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables prefetch optimizations for arrays in loops.  */
end_comment

begin_decl_stmt
name|int
name|flag_prefetch_loop_arrays
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero forces all invariant computations in loops to be moved    outside the loop.  */
end_comment

begin_decl_stmt
name|int
name|flag_move_all_movables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero forces all general induction variables in loops to be    strength reduced.  */
end_comment

begin_decl_stmt
name|int
name|flag_reduce_all_givs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to perform full register move optimization passes.  This is the    default for -O2.  */
end_comment

begin_decl_stmt
name|int
name|flag_regmove
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fwritable-strings:    store string constants in data segment and don't uniquize them.  */
end_comment

begin_decl_stmt
name|int
name|flag_writable_strings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't put addresses of constant functions in registers.    Used for compiling the Unix kernel, where strange substitutions are    done on the assembly output.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_function_cse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fomit-frame-pointer:    don't make a frame pointer in simple functions that don't require one.  */
end_comment

begin_decl_stmt
name|int
name|flag_omit_frame_pointer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means place each function into its own section on those platforms    which support arbitrary section names and unlimited numbers of sections.  */
end_comment

begin_decl_stmt
name|int
name|flag_function_sections
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ... and similar for data.  */
end_comment

begin_decl_stmt
name|int
name|flag_data_sections
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to inhibit use of define_optimization peephole opts.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_peephole
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero allows GCC to optimize sibling and tail recursive calls.  */
end_comment

begin_decl_stmt
name|int
name|flag_optimize_sibling_calls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means the front end generally wants `errno' maintained by math    operations, like built-in SQRT.  */
end_comment

begin_decl_stmt
name|int
name|flag_errno_math
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that unsafe floating-point math optimizations are allowed    for the sake of speed.  IEEE compliance is not guaranteed, and operations    are allowed to assume that their arguments and results are "normal"    (e.g., nonnegative for SQRT).  */
end_comment

begin_decl_stmt
name|int
name|flag_unsafe_math_optimizations
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that no NaNs or +-Infs are expected.  */
end_comment

begin_decl_stmt
name|int
name|flag_finite_math_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero means that floating-point math operations cannot generate a    (user-visible) trap.  This is the case, for example, in nonstop    IEEE 754 arithmetic.  Trapping conditions include division by zero,    overflow, underflow, invalid and inexact, but does not include    operations on signaling NaNs (see below).  */
end_comment

begin_decl_stmt
name|int
name|flag_trapping_math
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means disable transformations that assume default floating    point rounding behavior.  */
end_comment

begin_decl_stmt
name|int
name|flag_rounding_math
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means disable transformations observable by signaling NaNs.    This option implies that any operation on an IEEE signaling NaN can    generate a (user-visible) trap.  */
end_comment

begin_decl_stmt
name|int
name|flag_signaling_nans
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 means straightforward implementation of complex divide acceptable.    1 means wide ranges of inputs must work for complex divide.    2 means C99-like requirements for complex divide (not yet implemented).  */
end_comment

begin_decl_stmt
name|int
name|flag_complex_divide_method
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means just do syntax checking; don't output anything.  */
end_comment

begin_decl_stmt
name|int
name|flag_syntax_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means performs web construction pass.  */
end_comment

begin_decl_stmt
name|int
name|flag_web
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means perform loop optimizer.  */
end_comment

begin_decl_stmt
name|int
name|flag_loop_optimize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means perform crossjumping.  */
end_comment

begin_decl_stmt
name|int
name|flag_crossjumping
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means perform if conversion.  */
end_comment

begin_decl_stmt
name|int
name|flag_if_conversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means perform if conversion after reload.  */
end_comment

begin_decl_stmt
name|int
name|flag_if_conversion2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to use global dataflow analysis to eliminate    useless null pointer tests.  */
end_comment

begin_decl_stmt
name|int
name|flag_delete_null_pointer_checks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means perform global CSE.  */
end_comment

begin_decl_stmt
name|int
name|flag_gcse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to do the enhanced load motion during gcse, which trys    to hoist loads by not killing them when a store to the same location    is seen.  */
end_comment

begin_decl_stmt
name|int
name|flag_gcse_lm
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to perform store motion after gcse, which will try to    move stores closer to the exit block.  Its not very effective without    flag_gcse_lm.  */
end_comment

begin_decl_stmt
name|int
name|flag_gcse_sm
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to perfrom redundant load after store elimination    in gcse.  */
end_comment

begin_decl_stmt
name|int
name|flag_gcse_las
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Perform target register optimization before prologue / epilogue    threading.  */
end_comment

begin_decl_stmt
name|int
name|flag_branch_target_load_optimize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Perform target register optimization after prologue / epilogue    threading and jump2.  */
end_comment

begin_decl_stmt
name|int
name|flag_branch_target_load_optimize2
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to rerun cse after loop optimization.  This increases    compilation time about 20% and picks up a few more common expressions.  */
end_comment

begin_decl_stmt
name|int
name|flag_rerun_cse_after_loop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to run loop optimizations twice.  */
end_comment

begin_decl_stmt
name|int
name|flag_rerun_loop_opt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -finline-functions: ok to inline functions that look like    good inline candidates.  */
end_comment

begin_decl_stmt
name|int
name|flag_inline_functions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fkeep-inline-functions: even if we make a function    go inline everywhere, keep its definition around for debugging    purposes.  */
end_comment

begin_decl_stmt
name|int
name|flag_keep_inline_functions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that functions will not be inlined.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_inline
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that we don't want inlining by virtue of -fno-inline,    not just because the tree inliner turned us off.  */
end_comment

begin_decl_stmt
name|int
name|flag_really_no_inline
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that we should emit static const variables    regardless of whether or not optimization is turned on.  */
end_comment

begin_decl_stmt
name|int
name|flag_keep_static_consts
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we should be saving declaration info into a .X file.  */
end_comment

begin_decl_stmt
name|int
name|flag_gen_aux_info
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specified name of aux-info file.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|aux_info_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means make the text shared if supported.  */
end_comment

begin_decl_stmt
name|int
name|flag_shared_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means schedule into delayed branch slots if supported.  */
end_comment

begin_decl_stmt
name|int
name|flag_delayed_branch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are compiling pure (sharable) code.    Value is 1 if we are doing "small" pic; value is 2 if we're doing    "large" pic.  */
end_comment

begin_decl_stmt
name|int
name|flag_pic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are compiling position independent code for executable.    The value is 1 if we are doing "small" pic; value is 2 if we're doing    "large" pic.  */
end_comment

begin_decl_stmt
name|int
name|flag_pie
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are compiling code for a shared library, zero for    executable.  */
end_comment

begin_decl_stmt
name|int
name|flag_shlib
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to the default thread-local storage (tls) model to use.  */
end_comment

begin_decl_stmt
name|enum
name|tls_model
name|flag_tls_default
init|=
name|TLS_MODEL_GLOBAL_DYNAMIC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means generate extra code for exception handling and enable    exception handling.  */
end_comment

begin_decl_stmt
name|int
name|flag_exceptions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means generate frame unwind info table when supported.  */
end_comment

begin_decl_stmt
name|int
name|flag_unwind_tables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means generate frame unwind info table exact at each insn    boundary.  */
end_comment

begin_decl_stmt
name|int
name|flag_asynchronous_unwind_tables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't place uninitialized global data in common storage    by default.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_common
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means change certain warnings into errors.    Usually these are warnings about failure to conform to some standard.  */
end_comment

begin_decl_stmt
name|int
name|flag_pedantic_errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag_schedule_insns means schedule insns within basic blocks (before    local_alloc).    flag_schedule_insns_after_reload means schedule insns after    global_alloc.  */
end_comment

begin_decl_stmt
name|int
name|flag_schedule_insns
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_schedule_insns_after_reload
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When flag_schedule_insns_after_reload is set, use EBB scheduler.  */
end_comment

begin_decl_stmt
name|int
name|flag_sched2_use_superblocks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When flag_schedule_insns_after_reload is set, construct traces and EBB    scheduler.  */
end_comment

begin_decl_stmt
name|int
name|flag_sched2_use_traces
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following flags have effect only for scheduling before register    allocation:     flag_schedule_interblock means schedule insns across basic blocks.    flag_schedule_speculative means allow speculative motion of non-load insns.    flag_schedule_speculative_load means allow speculative motion of some    load insns.    flag_schedule_speculative_load_dangerous allows speculative motion of more    load insns.  */
end_comment

begin_decl_stmt
name|int
name|flag_schedule_interblock
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_schedule_speculative
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_schedule_speculative_load
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_schedule_speculative_load_dangerous
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following flags have an effect during scheduling after register    allocation:     flag_sched_stalled_insns means that insns can be moved prematurely from the queue    of stalled insns into the ready list.     flag_sched_stalled_insns_dep controls how many insn groups will be examined    for a dependency on a stalled insn that is candidate for premature removal    from the queue of stalled insns into the ready list (has an effect only if    the flag 'sched_stalled_insns' is set).  */
end_comment

begin_decl_stmt
name|int
name|flag_sched_stalled_insns
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_sched_stalled_insns_dep
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_single_precision_constant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag_branch_on_count_reg means try to replace add-1,compare,branch tupple    by a cheaper branch on a count register.  */
end_comment

begin_decl_stmt
name|int
name|flag_branch_on_count_reg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -finhibit-size-directive inhibits output of .size for ELF.    This is used only for compiling crtstuff.c,    and it may be extended to other effects    needed for crtstuff.c on other systems.  */
end_comment

begin_decl_stmt
name|int
name|flag_inhibit_size_directive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -fverbose-asm causes extra commentary information to be produced in    the generated assembly code (to make it more readable).  This option    is generally only of use to those who actually need to read the    generated assembly code (perhaps while debugging the compiler itself).    -fno-verbose-asm, the default, causes the extra information    to be omitted and is useful when comparing two assembler files.  */
end_comment

begin_decl_stmt
name|int
name|flag_verbose_asm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -dA causes debug commentary information to be produced in    the generated assembly code (to make it more readable).  This option    is generally only of use to those who actually need to read the    generated assembly code (perhaps while debugging the compiler itself).    Currently, this switch is only used by dwarfout.c; however, it is intended    to be a catchall for printing debug information in the assembler file.  */
end_comment

begin_decl_stmt
name|int
name|flag_debug_asm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -dP causes the rtl to be emitted as a comment in assembly.  */
end_comment

begin_decl_stmt
name|int
name|flag_dump_rtl_in_asm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means put zero initialized data in the bss section.  */
end_comment

begin_decl_stmt
name|int
name|flag_zero_initialized_in_bss
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tag all structures with __attribute__(packed).  */
end_comment

begin_decl_stmt
name|int
name|flag_pack_struct
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that -Wformat accepts certain system-dependent formats.  */
end_comment

begin_decl_stmt
name|int
name|flag_format_extensions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Emit code to check for stack overflow; also may cause large objects    to be allocated dynamically.  */
end_comment

begin_decl_stmt
name|int
name|flag_stack_check
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When non-NULL, indicates that whenever space is allocated on the    stack, the resulting stack pointer must not pass this    address---that is, for stacks that grow downward, the stack pointer    must always be greater than or equal to this address; for stacks    that grow upward, the stack pointer must be less than this address.    At present, the rtx may be either a REG or a SYMBOL_REF, although    the support provided depends on the backend.  */
end_comment

begin_decl_stmt
name|rtx
name|stack_limit_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 if pointer arguments may alias each other.  True in C.    1 if pointer arguments may not alias each other but may alias    global variables.    2 if pointer arguments may not alias each other and may not    alias global variables.  True in Fortran.    This defaults to 0 for C.  */
end_comment

begin_decl_stmt
name|int
name|flag_argument_noalias
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should do (language-dependent) alias analysis.    Typically, this analysis will assume that expressions of certain    types do not alias expressions of certain other types.  Only used    if alias analysis (in general) is enabled.  */
end_comment

begin_decl_stmt
name|int
name|flag_strict_aliasing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instrument functions with calls at entry and exit, for profiling.  */
end_comment

begin_decl_stmt
name|int
name|flag_instrument_function_entry_exit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means ignore `#ident' directives.  0 means handle them.    On SVR4 targets, it also controls whether or not to emit a    string identifying the compiler.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_ident
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This will perform a peephole pass before sched2.  */
end_comment

begin_decl_stmt
name|int
name|flag_peephole2
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This will try to guess branch probabilities.  */
end_comment

begin_decl_stmt
name|int
name|flag_guess_branch_prob
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -fcheck-bounds causes gcc to generate array bounds checks.    For C, C++, ObjC: defaults to off.    For Java: defaults to on.    For Fortran: defaults to off.  */
end_comment

begin_decl_stmt
name|int
name|flag_bounds_check
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This will attempt to merge constant section constants, if 1 only    string constants and constants from constant pool, if 2 also constant    variables.  */
end_comment

begin_decl_stmt
name|int
name|flag_merge_constants
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If one, renumber instruction UIDs to reduce the number of    unused UIDs if there are a lot of instructions.  If greater than    one, unconditionally renumber instruction UIDs.  */
end_comment

begin_decl_stmt
name|int
name|flag_renumber_insns
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, use the graph coloring register allocator.  */
end_comment

begin_decl_stmt
name|int
name|flag_new_regalloc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we perform superblock formation.  */
end_comment

begin_decl_stmt
name|int
name|flag_tracer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we perform whole unit at a time compilation.  */
end_comment

begin_decl_stmt
name|int
name|flag_unit_at_a_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Values of the -falign-* flags: how much to align labels in code.    0 means `use default', 1 means `don't align'.    For each variable, there is an _log variant which is the power    of two not less than the variable, for .align output.  */
end_comment

begin_decl_stmt
name|int
name|align_loops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_loops_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_loops_max_skip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_jumps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_jumps_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_jumps_max_skip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_labels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_labels_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_labels_max_skip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_functions
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_functions_log
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Like align_functions_log above, but used by front-ends to force the    minimum function alignment.  Zero means no alignment is forced.  */
end_comment

begin_decl_stmt
name|int
name|force_align_functions_log
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|string
decl_stmt|;
name|int
modifier|*
specifier|const
name|variable
decl_stmt|;
specifier|const
name|int
name|on_value
decl_stmt|;
block|}
name|lang_independent_options
typedef|;
end_typedef

begin_comment
comment|/* Nonzero if signed arithmetic overflow should trap.  */
end_comment

begin_decl_stmt
name|int
name|flag_trapv
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if signed arithmetic overflow should wrap around.  */
end_comment

begin_decl_stmt
name|int
name|flag_wrapv
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if subexpressions must be evaluated from left-to-right.  */
end_comment

begin_decl_stmt
name|int
name|flag_evaluation_order
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add or remove a leading underscore from user symbols.  */
end_comment

begin_decl_stmt
name|int
name|flag_leading_underscore
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  The version of the C++ ABI in use.  The following values are     allowed:      0: The version of the ABI believed most conformant with the        C++ ABI specification.  This ABI may change as bugs are        discovered and fixed.  Therefore, 0 will not necessarily        indicate the same ABI in different versions of G++.      1: The version of the ABI first used in G++ 3.2.      2: The version of the ABI first used in G++ 3.4.      Additional positive integers will be assigned as new versions of     the ABI become the default version of the ABI.  */
end_comment

begin_decl_stmt
name|int
name|flag_abi_version
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The user symbol prefix after having resolved same.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|user_label_prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|param_info
name|lang_independent_params
index|[]
init|=
block|{
define|#
directive|define
name|DEFPARAM
parameter_list|(
name|ENUM
parameter_list|,
name|OPTION
parameter_list|,
name|HELP
parameter_list|,
name|DEFAULT
parameter_list|)
define|\
value|{ OPTION, DEFAULT, HELP },
include|#
directive|include
file|"params.def"
undef|#
directive|undef
name|DEFPARAM
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of language-independent -f options.    STRING is the option name.  VARIABLE is the address of the variable.    ON_VALUE is the value to store in VARIABLE     if `-fSTRING' is seen as an option.    (If `-fno-STRING' is seen as an option, the opposite value is stored.)  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|lang_independent_options
name|f_options
index|[]
init|=
block|{
block|{
literal|"format-extensions"
block|,
operator|&
name|flag_format_extensions
block|,
literal|1
block|}
block|,
block|{
literal|"eliminate-dwarf2-dups"
block|,
operator|&
name|flag_eliminate_dwarf2_dups
block|,
literal|1
block|}
block|,
block|{
literal|"eliminate-unused-debug-symbols"
block|,
operator|&
name|flag_debug_only_used_symbols
block|,
literal|1
block|}
block|,
block|{
literal|"eliminate-unused-debug-types"
block|,
operator|&
name|flag_eliminate_unused_debug_types
block|,
literal|1
block|}
block|,
block|{
literal|"float-store"
block|,
operator|&
name|flag_float_store
block|,
literal|1
block|}
block|,
block|{
literal|"defer-pop"
block|,
operator|&
name|flag_defer_pop
block|,
literal|1
block|}
block|,
block|{
literal|"omit-frame-pointer"
block|,
operator|&
name|flag_omit_frame_pointer
block|,
literal|1
block|}
block|,
block|{
literal|"optimize-sibling-calls"
block|,
operator|&
name|flag_optimize_sibling_calls
block|,
literal|1
block|}
block|,
block|{
literal|"tracer"
block|,
operator|&
name|flag_tracer
block|,
literal|1
block|}
block|,
block|{
literal|"unit-at-a-time"
block|,
operator|&
name|flag_unit_at_a_time
block|,
literal|1
block|}
block|,
block|{
literal|"cse-follow-jumps"
block|,
operator|&
name|flag_cse_follow_jumps
block|,
literal|1
block|}
block|,
block|{
literal|"cse-skip-blocks"
block|,
operator|&
name|flag_cse_skip_blocks
block|,
literal|1
block|}
block|,
block|{
literal|"expensive-optimizations"
block|,
operator|&
name|flag_expensive_optimizations
block|,
literal|1
block|}
block|,
block|{
literal|"thread-jumps"
block|,
operator|&
name|flag_thread_jumps
block|,
literal|1
block|}
block|,
block|{
literal|"strength-reduce"
block|,
operator|&
name|flag_strength_reduce
block|,
literal|1
block|}
block|,
block|{
literal|"unroll-loops"
block|,
operator|&
name|flag_unroll_loops
block|,
literal|1
block|}
block|,
block|{
literal|"unroll-all-loops"
block|,
operator|&
name|flag_unroll_all_loops
block|,
literal|1
block|}
block|,
block|{
literal|"old-unroll-loops"
block|,
operator|&
name|flag_old_unroll_loops
block|,
literal|1
block|}
block|,
block|{
literal|"old-unroll-all-loops"
block|,
operator|&
name|flag_old_unroll_all_loops
block|,
literal|1
block|}
block|,
block|{
literal|"peel-loops"
block|,
operator|&
name|flag_peel_loops
block|,
literal|1
block|}
block|,
block|{
literal|"unswitch-loops"
block|,
operator|&
name|flag_unswitch_loops
block|,
literal|1
block|}
block|,
block|{
literal|"prefetch-loop-arrays"
block|,
operator|&
name|flag_prefetch_loop_arrays
block|,
literal|1
block|}
block|,
block|{
literal|"move-all-movables"
block|,
operator|&
name|flag_move_all_movables
block|,
literal|1
block|}
block|,
block|{
literal|"reduce-all-givs"
block|,
operator|&
name|flag_reduce_all_givs
block|,
literal|1
block|}
block|,
block|{
literal|"writable-strings"
block|,
operator|&
name|flag_writable_strings
block|,
literal|1
block|}
block|,
block|{
literal|"peephole"
block|,
operator|&
name|flag_no_peephole
block|,
literal|0
block|}
block|,
block|{
literal|"force-mem"
block|,
operator|&
name|flag_force_mem
block|,
literal|1
block|}
block|,
block|{
literal|"force-addr"
block|,
operator|&
name|flag_force_addr
block|,
literal|1
block|}
block|,
block|{
literal|"function-cse"
block|,
operator|&
name|flag_no_function_cse
block|,
literal|0
block|}
block|,
block|{
literal|"inline-functions"
block|,
operator|&
name|flag_inline_functions
block|,
literal|1
block|}
block|,
block|{
literal|"keep-inline-functions"
block|,
operator|&
name|flag_keep_inline_functions
block|,
literal|1
block|}
block|,
block|{
literal|"inline"
block|,
operator|&
name|flag_no_inline
block|,
literal|0
block|}
block|,
block|{
literal|"keep-static-consts"
block|,
operator|&
name|flag_keep_static_consts
block|,
literal|1
block|}
block|,
block|{
literal|"syntax-only"
block|,
operator|&
name|flag_syntax_only
block|,
literal|1
block|}
block|,
block|{
literal|"shared-data"
block|,
operator|&
name|flag_shared_data
block|,
literal|1
block|}
block|,
block|{
literal|"caller-saves"
block|,
operator|&
name|flag_caller_saves
block|,
literal|1
block|}
block|,
block|{
literal|"pcc-struct-return"
block|,
operator|&
name|flag_pcc_struct_return
block|,
literal|1
block|}
block|,
block|{
literal|"reg-struct-return"
block|,
operator|&
name|flag_pcc_struct_return
block|,
literal|0
block|}
block|,
block|{
literal|"delayed-branch"
block|,
operator|&
name|flag_delayed_branch
block|,
literal|1
block|}
block|,
block|{
literal|"web"
block|,
operator|&
name|flag_web
block|,
literal|1
block|}
block|,
block|{
literal|"gcse"
block|,
operator|&
name|flag_gcse
block|,
literal|1
block|}
block|,
block|{
literal|"gcse-lm"
block|,
operator|&
name|flag_gcse_lm
block|,
literal|1
block|}
block|,
block|{
literal|"gcse-sm"
block|,
operator|&
name|flag_gcse_sm
block|,
literal|1
block|}
block|,
block|{
literal|"gcse-las"
block|,
operator|&
name|flag_gcse_las
block|,
literal|1
block|}
block|,
block|{
literal|"branch-target-load-optimize"
block|,
operator|&
name|flag_branch_target_load_optimize
block|,
literal|1
block|}
block|,
block|{
literal|"branch-target-load-optimize2"
block|,
operator|&
name|flag_branch_target_load_optimize2
block|,
literal|1
block|}
block|,
block|{
literal|"loop-optimize"
block|,
operator|&
name|flag_loop_optimize
block|,
literal|1
block|}
block|,
block|{
literal|"crossjumping"
block|,
operator|&
name|flag_crossjumping
block|,
literal|1
block|}
block|,
block|{
literal|"if-conversion"
block|,
operator|&
name|flag_if_conversion
block|,
literal|1
block|}
block|,
block|{
literal|"if-conversion2"
block|,
operator|&
name|flag_if_conversion2
block|,
literal|1
block|}
block|,
block|{
literal|"rerun-cse-after-loop"
block|,
operator|&
name|flag_rerun_cse_after_loop
block|,
literal|1
block|}
block|,
block|{
literal|"rerun-loop-opt"
block|,
operator|&
name|flag_rerun_loop_opt
block|,
literal|1
block|}
block|,
block|{
literal|"delete-null-pointer-checks"
block|,
operator|&
name|flag_delete_null_pointer_checks
block|,
literal|1
block|}
block|,
block|{
literal|"schedule-insns"
block|,
operator|&
name|flag_schedule_insns
block|,
literal|1
block|}
block|,
block|{
literal|"schedule-insns2"
block|,
operator|&
name|flag_schedule_insns_after_reload
block|,
literal|1
block|}
block|,
block|{
literal|"sched-interblock"
block|,
operator|&
name|flag_schedule_interblock
block|,
literal|1
block|}
block|,
block|{
literal|"sched-spec"
block|,
operator|&
name|flag_schedule_speculative
block|,
literal|1
block|}
block|,
block|{
literal|"sched-spec-load"
block|,
operator|&
name|flag_schedule_speculative_load
block|,
literal|1
block|}
block|,
block|{
literal|"sched-spec-load-dangerous"
block|,
operator|&
name|flag_schedule_speculative_load_dangerous
block|,
literal|1
block|}
block|,
block|{
literal|"sched-stalled-insns"
block|,
operator|&
name|flag_sched_stalled_insns
block|,
literal|0
block|}
block|,
block|{
literal|"sched-stalled-insns-dep"
block|,
operator|&
name|flag_sched_stalled_insns_dep
block|,
literal|1
block|}
block|,
block|{
literal|"sched2-use-superblocks"
block|,
operator|&
name|flag_sched2_use_superblocks
block|,
literal|1
block|}
block|,
block|{
literal|"sched2-use-traces"
block|,
operator|&
name|flag_sched2_use_traces
block|,
literal|1
block|}
block|,
block|{
literal|"branch-count-reg"
block|,
operator|&
name|flag_branch_on_count_reg
block|,
literal|1
block|}
block|,
block|{
literal|"pic"
block|,
operator|&
name|flag_pic
block|,
literal|1
block|}
block|,
block|{
literal|"PIC"
block|,
operator|&
name|flag_pic
block|,
literal|2
block|}
block|,
block|{
literal|"pie"
block|,
operator|&
name|flag_pie
block|,
literal|1
block|}
block|,
block|{
literal|"PIE"
block|,
operator|&
name|flag_pie
block|,
literal|2
block|}
block|,
block|{
literal|"exceptions"
block|,
operator|&
name|flag_exceptions
block|,
literal|1
block|}
block|,
block|{
literal|"unwind-tables"
block|,
operator|&
name|flag_unwind_tables
block|,
literal|1
block|}
block|,
block|{
literal|"asynchronous-unwind-tables"
block|,
operator|&
name|flag_asynchronous_unwind_tables
block|,
literal|1
block|}
block|,
block|{
literal|"non-call-exceptions"
block|,
operator|&
name|flag_non_call_exceptions
block|,
literal|1
block|}
block|,
block|{
literal|"profile-arcs"
block|,
operator|&
name|profile_arc_flag
block|,
literal|1
block|}
block|,
block|{
literal|"profile-values"
block|,
operator|&
name|flag_profile_values
block|,
literal|1
block|}
block|,
block|{
literal|"vpt"
block|,
operator|&
name|flag_value_profile_transformations
block|,
literal|1
block|}
block|,
block|{
literal|"test-coverage"
block|,
operator|&
name|flag_test_coverage
block|,
literal|1
block|}
block|,
block|{
literal|"branch-probabilities"
block|,
operator|&
name|flag_branch_probabilities
block|,
literal|1
block|}
block|,
block|{
literal|"profile"
block|,
operator|&
name|profile_flag
block|,
literal|1
block|}
block|,
block|{
literal|"reorder-blocks"
block|,
operator|&
name|flag_reorder_blocks
block|,
literal|1
block|}
block|,
block|{
literal|"reorder-functions"
block|,
operator|&
name|flag_reorder_functions
block|,
literal|1
block|}
block|,
block|{
literal|"rename-registers"
block|,
operator|&
name|flag_rename_registers
block|,
literal|1
block|}
block|,
block|{
literal|"cprop-registers"
block|,
operator|&
name|flag_cprop_registers
block|,
literal|1
block|}
block|,
block|{
literal|"common"
block|,
operator|&
name|flag_no_common
block|,
literal|0
block|}
block|,
block|{
literal|"inhibit-size-directive"
block|,
operator|&
name|flag_inhibit_size_directive
block|,
literal|1
block|}
block|,
block|{
literal|"function-sections"
block|,
operator|&
name|flag_function_sections
block|,
literal|1
block|}
block|,
block|{
literal|"data-sections"
block|,
operator|&
name|flag_data_sections
block|,
literal|1
block|}
block|,
block|{
literal|"verbose-asm"
block|,
operator|&
name|flag_verbose_asm
block|,
literal|1
block|}
block|,
block|{
literal|"regmove"
block|,
operator|&
name|flag_regmove
block|,
literal|1
block|}
block|,
block|{
literal|"optimize-register-move"
block|,
operator|&
name|flag_regmove
block|,
literal|1
block|}
block|,
block|{
literal|"pack-struct"
block|,
operator|&
name|flag_pack_struct
block|,
literal|1
block|}
block|,
block|{
literal|"stack-check"
block|,
operator|&
name|flag_stack_check
block|,
literal|1
block|}
block|,
block|{
literal|"argument-alias"
block|,
operator|&
name|flag_argument_noalias
block|,
literal|0
block|}
block|,
block|{
literal|"argument-noalias"
block|,
operator|&
name|flag_argument_noalias
block|,
literal|1
block|}
block|,
block|{
literal|"argument-noalias-global"
block|,
operator|&
name|flag_argument_noalias
block|,
literal|2
block|}
block|,
block|{
literal|"strict-aliasing"
block|,
operator|&
name|flag_strict_aliasing
block|,
literal|1
block|}
block|,
block|{
literal|"align-loops"
block|,
operator|&
name|align_loops
block|,
literal|0
block|}
block|,
block|{
literal|"align-jumps"
block|,
operator|&
name|align_jumps
block|,
literal|0
block|}
block|,
block|{
literal|"align-labels"
block|,
operator|&
name|align_labels
block|,
literal|0
block|}
block|,
block|{
literal|"align-functions"
block|,
operator|&
name|align_functions
block|,
literal|0
block|}
block|,
block|{
literal|"merge-constants"
block|,
operator|&
name|flag_merge_constants
block|,
literal|1
block|}
block|,
block|{
literal|"merge-all-constants"
block|,
operator|&
name|flag_merge_constants
block|,
literal|2
block|}
block|,
block|{
literal|"dump-unnumbered"
block|,
operator|&
name|flag_dump_unnumbered
block|,
literal|1
block|}
block|,
block|{
literal|"instrument-functions"
block|,
operator|&
name|flag_instrument_function_entry_exit
block|,
literal|1
block|}
block|,
block|{
literal|"zero-initialized-in-bss"
block|,
operator|&
name|flag_zero_initialized_in_bss
block|,
literal|1
block|}
block|,
block|{
literal|"leading-underscore"
block|,
operator|&
name|flag_leading_underscore
block|,
literal|1
block|}
block|,
block|{
literal|"ident"
block|,
operator|&
name|flag_no_ident
block|,
literal|0
block|}
block|,
block|{
literal|"peephole2"
block|,
operator|&
name|flag_peephole2
block|,
literal|1
block|}
block|,
block|{
literal|"finite-math-only"
block|,
operator|&
name|flag_finite_math_only
block|,
literal|1
block|}
block|,
block|{
literal|"guess-branch-probability"
block|,
operator|&
name|flag_guess_branch_prob
block|,
literal|1
block|}
block|,
block|{
literal|"math-errno"
block|,
operator|&
name|flag_errno_math
block|,
literal|1
block|}
block|,
block|{
literal|"trapping-math"
block|,
operator|&
name|flag_trapping_math
block|,
literal|1
block|}
block|,
block|{
literal|"rounding-math"
block|,
operator|&
name|flag_rounding_math
block|,
literal|1
block|}
block|,
block|{
literal|"unsafe-math-optimizations"
block|,
operator|&
name|flag_unsafe_math_optimizations
block|,
literal|1
block|}
block|,
block|{
literal|"signaling-nans"
block|,
operator|&
name|flag_signaling_nans
block|,
literal|1
block|}
block|,
block|{
literal|"bounds-check"
block|,
operator|&
name|flag_bounds_check
block|,
literal|1
block|}
block|,
block|{
literal|"single-precision-constant"
block|,
operator|&
name|flag_single_precision_constant
block|,
literal|1
block|}
block|,
block|{
literal|"time-report"
block|,
operator|&
name|time_report
block|,
literal|1
block|}
block|,
block|{
literal|"mem-report"
block|,
operator|&
name|mem_report
block|,
literal|1
block|}
block|,
block|{
literal|"trapv"
block|,
operator|&
name|flag_trapv
block|,
literal|1
block|}
block|,
block|{
literal|"wrapv"
block|,
operator|&
name|flag_wrapv
block|,
literal|1
block|}
block|,
block|{
literal|"new-ra"
block|,
operator|&
name|flag_new_regalloc
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is a table, controlled by the tm.h file, listing each -m switch    and which bits in `target_switches' it should set or clear.    If VALUE is positive, it is bits to set.    If VALUE is negative, -VALUE is bits to clear.    (The sign bit is not used so there is no confusion.)  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|int
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|description
decl_stmt|;
block|}
name|target_switches
index|[]
init|=
name|TARGET_SWITCHES
struct|;
end_struct

begin_comment
comment|/* This table is similar, but allows the switch to have a value.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
end_ifdef

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
specifier|const
name|variable
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|description
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|value
decl_stmt|;
block|}
name|target_options
index|[]
init|=
name|TARGET_OPTIONS
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero means warn about function definitions that default the return type    or that use a null return and have a return-type other than void.  */
end_comment

begin_decl_stmt
name|int
name|warn_return_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output files for assembler code (real compiler output)    and debugging dumps.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|aux_info_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|rtl_dump_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|cgraph_dump_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current working directory of a translation.  It's generally the    directory from which compilation was initiated, but a preprocessed    file may specify the original directory in which it was    created.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|src_pwd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize src_pwd with the given string, and return true.  If it    was already initialized, return false.  As a special case, it may    be called with a NULL argument to test whether src_pwd has NOT been    initialized yet.  */
end_comment

begin_function
name|bool
name|set_src_pwd
parameter_list|(
specifier|const
name|char
modifier|*
name|pwd
parameter_list|)
block|{
if|if
condition|(
name|src_pwd
condition|)
return|return
name|false
return|;
name|src_pwd
operator|=
name|xstrdup
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the directory from which the translation unit was initiated,    in case set_src_pwd() was not called before to assign it a    different value.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_src_pwd
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|src_pwd
condition|)
name|src_pwd
operator|=
name|getpwd
argument_list|()
expr_stmt|;
return|return
name|src_pwd
return|;
block|}
end_function

begin_comment
comment|/* Called when the start of a function definition is parsed,    this function prints on stderr the name of the function.  */
end_comment

begin_function
name|void
name|announce_function
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
if|if
condition|(
name|rtl_dump_and_exit
condition|)
name|verbatim
argument_list|(
literal|"%s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|verbatim
argument_list|(
literal|" %s"
argument_list|,
call|(
modifier|*
name|lang_hooks
operator|.
name|decl_printable_name
call|)
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|global_dc
operator|->
name|printer
argument_list|)
operator|=
name|true
expr_stmt|;
name|diagnostic_set_last_function
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set up a default flag_random_seed and local_tick, unless the user    already specified one.  */
end_comment

begin_function
specifier|static
name|void
name|randomize
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flag_random_seed
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
decl_stmt|;
specifier|static
name|char
name|random_seed
index|[
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|4
operator|+
literal|3
index|]
decl_stmt|;
comment|/* Get some more or less random data.  */
ifdef|#
directive|ifdef
name|HAVE_GETTIMEOFDAY
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|local_tick
operator|=
name|tv
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
block|}
else|#
directive|else
block|{
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|now
operator|!=
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|local_tick
operator|=
operator|(
name|unsigned
operator|)
name|now
expr_stmt|;
block|}
endif|#
directive|endif
name|value
operator|=
name|local_tick
operator|^
name|getpid
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|random_seed
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|flag_random_seed
operator|=
name|random_seed
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|local_tick
condition|)
name|local_tick
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decode the string P as an integral parameter.    If the string is indeed an integer return its numeric value else    issue an Invalid Option error for the option PNAME and return DEFVAL.    If PNAME is zero just return DEFVAL, do not call error.  */
end_comment

begin_function
name|int
name|read_integral_parameter
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|pname
parameter_list|,
specifier|const
name|int
name|defval
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|endp
init|=
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|endp
condition|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|endp
argument_list|)
condition|)
name|endp
operator|++
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|endp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pname
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"invalid option argument `%s'"
argument_list|,
name|pname
argument_list|)
expr_stmt|;
return|return
name|defval
return|;
block|}
return|return
name|atoi
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the logarithm of X, base 2, considering X unsigned,    if X is a power of 2.  Otherwise, returns -1.     This should be used via the `exact_log2' macro.  */
end_comment

begin_function
name|int
name|exact_log2_wide
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|x
parameter_list|)
block|{
name|int
name|log
init|=
literal|0
decl_stmt|;
comment|/* Test for 0 or a power of 2.  */
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|x
operator|!=
operator|(
name|x
operator|&
operator|-
name|x
operator|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
name|x
operator|>>=
literal|1
operator|)
operator|!=
literal|0
condition|)
name|log
operator|++
expr_stmt|;
return|return
name|log
return|;
block|}
end_function

begin_comment
comment|/* Given X, an unsigned number, return the largest int Y such that 2**Y<= X.    If X is 0, return -1.     This should be used via the floor_log2 macro.  */
end_comment

begin_function
name|int
name|floor_log2_wide
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|x
parameter_list|)
block|{
name|int
name|log
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
name|log
operator|++
operator|,
name|x
operator|>>=
literal|1
expr_stmt|;
return|return
name|log
return|;
block|}
end_function

begin_comment
comment|/* Handler for fatal signals, such as SIGSEGV.  These are transformed    into ICE messages, which is much more user friendly.  In case the    error printer crashes, reset the signal to prevent infinite recursion.  */
end_comment

begin_function
specifier|static
name|void
name|crash_signal
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|signal
argument_list|(
name|signo
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"%s"
argument_list|,
name|strsignal
argument_list|(
name|signo
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Arrange to dump core on error.  (The regular error message is still    printed first, except in the case of abort().)  */
end_comment

begin_function
specifier|static
name|void
name|setup_core_dumping
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SIGABRT
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETRLIMIT
argument_list|)
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_CORE
argument_list|,
operator|&
name|rlim
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"getting core file size maximum limit: %m"
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|RLIMIT_CORE
argument_list|,
operator|&
name|rlim
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"setting core file size limit to maximum: %m"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|diagnostic_abort_on_error
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Strip off a legitimate source ending from the input string NAME of    length LEN.  Rather than having to know the names used by all of    our front ends, we strip off an ending of a period followed by    up to five characters.  (Java uses ".class".)  */
end_comment

begin_function
name|void
name|strip_off_ending
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|6
operator|&&
name|len
operator|>
name|i
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name
index|[
name|len
operator|-
name|i
index|]
operator|==
literal|'.'
condition|)
block|{
name|name
index|[
name|len
operator|-
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output a quoted string.  */
end_comment

begin_function
name|void
name|output_quoted_string
parameter_list|(
name|FILE
modifier|*
name|asm_file
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OUTPUT_QUOTED_STRING
name|OUTPUT_QUOTED_STRING
argument_list|(
name|asm_file
argument_list|,
name|string
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
name|c
decl_stmt|;
name|putc
argument_list|(
literal|'\"'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\"'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output a file name in the form wanted by System V.  */
end_comment

begin_function
name|void
name|output_file_directive
parameter_list|(
name|FILE
modifier|*
name|asm_file
parameter_list|,
specifier|const
name|char
modifier|*
name|input_name
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|na
decl_stmt|;
if|if
condition|(
name|input_name
operator|==
name|NULL
condition|)
name|input_name
operator|=
literal|"<stdin>"
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|input_name
argument_list|)
expr_stmt|;
name|na
operator|=
name|input_name
operator|+
name|len
expr_stmt|;
comment|/* NA gets INPUT_NAME sans directory names.  */
while|while
condition|(
name|na
operator|>
name|input_name
condition|)
block|{
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|na
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
name|na
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_FILENAME
name|ASM_OUTPUT_SOURCE_FILENAME
argument_list|(
name|asm_file
argument_list|,
name|na
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\t.file\t"
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|asm_file
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Routine to open a dump file.  Return true if the dump file is enabled.  */
end_comment

begin_function
specifier|static
name|int
name|open_dump_file
parameter_list|(
name|enum
name|dump_file_index
name|index
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|char
modifier|*
name|dump_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|open_arg
decl_stmt|;
name|char
name|seq
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|dump_file
index|[
name|index
index|]
operator|.
name|enabled
condition|)
return|return
literal|0
return|;
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|seq
argument_list|,
name|DUMPFILE_FORMAT
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dump_file
index|[
name|index
index|]
operator|.
name|initialized
condition|)
block|{
comment|/* If we've not initialized the files, do so now.  */
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
operator|&&
name|dump_file
index|[
name|index
index|]
operator|.
name|graph_dump_p
condition|)
block|{
name|dump_name
operator|=
name|concat
argument_list|(
name|seq
argument_list|,
name|dump_file
index|[
name|index
index|]
operator|.
name|extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
name|dump_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dump_name
argument_list|)
expr_stmt|;
block|}
name|dump_file
index|[
name|index
index|]
operator|.
name|initialized
operator|=
literal|1
expr_stmt|;
name|open_arg
operator|=
literal|"w"
expr_stmt|;
block|}
else|else
name|open_arg
operator|=
literal|"a"
expr_stmt|;
name|dump_name
operator|=
name|concat
argument_list|(
name|dump_base_name
argument_list|,
name|seq
argument_list|,
name|dump_file
index|[
name|index
index|]
operator|.
name|extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rtl_dump_file
operator|=
name|fopen
argument_list|(
name|dump_name
argument_list|,
name|open_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
operator|==
name|NULL
condition|)
name|fatal_error
argument_list|(
literal|"can't open %s: %m"
argument_list|,
name|dump_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dump_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n;; Function %s%s\n\n"
argument_list|,
call|(
modifier|*
name|lang_hooks
operator|.
name|decl_printable_name
call|)
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|,
name|cfun
operator|->
name|function_frequency
operator|==
name|FUNCTION_FREQUENCY_HOT
condition|?
literal|" (hot)"
else|:
name|cfun
operator|->
name|function_frequency
operator|==
name|FUNCTION_FREQUENCY_UNLIKELY_EXECUTED
condition|?
literal|" (unlikely executed)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Routine to close a dump file.  */
end_comment

begin_function
specifier|static
name|void
name|close_dump_file
parameter_list|(
name|enum
name|dump_file_index
name|index
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|)
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rtl_dump_file
condition|)
return|return;
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|insns
operator|&&
name|graph_dump_format
operator|!=
name|no_graph
operator|&&
name|dump_file
index|[
name|index
index|]
operator|.
name|graph_dump_p
condition|)
block|{
name|char
name|seq
index|[
literal|16
index|]
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
name|sprintf
argument_list|(
name|seq
argument_list|,
name|DUMPFILE_FORMAT
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|concat
argument_list|(
name|seq
argument_list|,
name|dump_file
index|[
name|index
index|]
operator|.
name|extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
name|suffix
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|func
operator|&&
name|insns
condition|)
name|func
argument_list|(
name|rtl_dump_file
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|rtl_dump_file
operator|=
name|NULL
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do any final processing required for the declarations in VEC, of    which there are LEN.  We write out inline functions and variables    that have been deferred until this point, but which are required.    Returns nonzero if anything was put out.  */
end_comment

begin_function
name|int
name|wrapup_global_declarations
parameter_list|(
name|tree
modifier|*
name|vec
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|reconsider
decl_stmt|;
name|int
name|output_something
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|vec
index|[
name|i
index|]
expr_stmt|;
comment|/* We're not deferring this any longer.  Assignment is 	 conditional to avoid needlessly dirtying PCH pages.  */
if|if
condition|(
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|lang_hooks
operator|.
name|finish_incomplete_decl
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Now emit any global variables or functions that we have been      putting off.  We need to loop in case one of the things emitted      here references another one which comes earlier in the list.  */
do|do
block|{
name|reconsider
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|vec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
continue|continue;
comment|/* Don't write out static consts, unless we still need them.  	     We also keep static consts if not optimizing (for debugging), 	     unless the user specified -fno-keep-static-consts. 	     ??? They might be better written into the debug information. 	     This is possible when using DWARF.  	     A language processor that wants static constants to be always 	     written out (even if it is not used) is responsible for 	     calling rest_of_decl_compilation itself.  E.g. the C front-end 	     calls rest_of_decl_compilation from finish_decl. 	     One motivation for this is that is conventional in some 	     environments to write things like: 	     static const char rcsid[] = "... version string ..."; 	     intending to force the string to be in the executable.  	     A language processor that would prefer to have unneeded 	     static constants "optimized away" would just defer writing 	     them out until here.  E.g. C++ does this, because static 	     constants are often defined in header files.  	     ??? A tempting alternative (for both C and C++) would be 	     to force a constant to be written if and only if it is 	     defined in a main file, as opposed to an include file.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|bool
name|needed
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|flag_unit_at_a_time
operator|&&
name|cgraph_varpool_node
argument_list|(
name|decl
argument_list|)
operator|->
name|finalized
condition|)
name|needed
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flag_unit_at_a_time
operator|&&
operator|!
name|cgraph_global_info_ready
operator|)
operator|&&
operator|(
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_USED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* needed */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
comment|/* needed */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
condition|)
name|needed
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|optimize
operator|||
operator|!
name|flag_keep_static_consts
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|needed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needed
condition|)
block|{
name|reconsider
operator|=
literal|1
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|->
name|saved_for_inline
operator|&&
operator|(
name|flag_keep_inline_functions
operator|||
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|reconsider
operator|=
literal|1
expr_stmt|;
name|output_inline_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reconsider
condition|)
name|output_something
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|reconsider
condition|)
do|;
return|return
name|output_something
return|;
block|}
end_function

begin_comment
comment|/* Issue appropriate warnings for the global declarations in VEC (of    which there are LEN).  Output debugging information for them.  */
end_comment

begin_function
name|void
name|check_global_declarations
parameter_list|(
name|tree
modifier|*
name|vec
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|vec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Cancel the RTL for this decl so that, if debugging info 	   output for global variables is still to come, 	   this one will be omitted.  */
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Warn about any function 	 declared static but not defined. 	 We don't warn about variables, 	 because many programs have static variables 	 that exist only to get some text into the object file.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|warn_unused_function
operator|||
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"%J'%F' used but never defined"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"%J'%F' declared `static' but never defined"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* This symbol is effectively an "extern" declaration now.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|assemble_external
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about static fns or vars defined but not used.  */
if|if
condition|(
operator|(
operator|(
name|warn_unused_function
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
comment|/* We don't warn about "static const" variables because the 	      "rcs_id" idiom uses that construction.  */
operator|||
operator|(
name|warn_unused_variable
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
comment|/* The TREE_USED bit for file-scope decls is kept in the identifier, 	     to handle multiple external decls in different scopes.  */
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
comment|/* A volatile variable might be used in some non-obvious way.  */
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
comment|/* Global register variables must be declared to reserve them.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|)
comment|/* Otherwise, ask the language.  */
operator|&&
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|warn_unused_global
call|)
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%J'%D' defined but not used"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Avoid confusing the debug information machinery when there are 	 errors.  */
if|if
condition|(
name|errorcount
operator|==
literal|0
operator|&&
name|sorrycount
operator|==
literal|0
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|global_decl
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Warn about a use of an identifier which was marked deprecated.  */
end_comment

begin_function
name|void
name|warn_deprecated_use
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|0
operator|||
operator|!
name|warn_deprecated_decl
condition|)
return|return;
if|if
condition|(
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`%s' is deprecated (declared at %s:%d)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|node
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|what
init|=
name|NULL
decl_stmt|;
name|tree
name|decl
init|=
name|TYPE_STUB_DECL
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|what
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
name|what
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
condition|)
block|{
if|if
condition|(
name|decl
condition|)
name|warning
argument_list|(
literal|"`%s' is deprecated (declared at %s:%d)"
argument_list|,
name|what
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' is deprecated"
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
condition|)
name|warning
argument_list|(
literal|"type is deprecated (declared at %s:%d)"
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"type is deprecated"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Save the current INPUT_LOCATION on the top entry in the    INPUT_FILE_STACK.  Push a new entry for FILE and LINE, and set the    INPUT_LOCATION accordingly.  */
end_comment

begin_function
name|void
name|push_srcloc
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|struct
name|file_stack
modifier|*
name|fs
decl_stmt|;
name|fs
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_stack
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|->
name|location
operator|=
name|input_location
expr_stmt|;
name|fs
operator|->
name|next
operator|=
name|input_file_stack
expr_stmt|;
name|input_filename
operator|=
name|file
expr_stmt|;
name|input_line
operator|=
name|line
expr_stmt|;
name|input_file_stack
operator|=
name|fs
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the top entry off the stack of presently open source files.    Restore the INPUT_LOCATION from the new topmost entry on the    stack.  */
end_comment

begin_function
name|void
name|pop_srcloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|file_stack
modifier|*
name|fs
decl_stmt|;
name|fs
operator|=
name|input_file_stack
expr_stmt|;
name|input_location
operator|=
name|fs
operator|->
name|location
expr_stmt|;
name|input_file_stack
operator|=
name|fs
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compile an entire translation unit.  Write a file of assembly    output and various debugging dumps.  */
end_comment

begin_function
specifier|static
name|void
name|compile_file
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize yet another pass.  */
name|init_final
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
name|coverage_init
argument_list|(
name|aux_base_name
argument_list|)
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_PARSE
argument_list|)
expr_stmt|;
comment|/* Call the parser, which parses the entire file (calling      rest_of_compilation for each function).  */
call|(
modifier|*
name|lang_hooks
operator|.
name|parse_file
call|)
argument_list|(
name|set_yydebug
argument_list|)
expr_stmt|;
comment|/* In case there were missing block closers,      get us back to the global binding level.  */
call|(
modifier|*
name|lang_hooks
operator|.
name|clear_binding_stack
call|)
argument_list|()
expr_stmt|;
comment|/* Compilation is now finished except for writing      what's left of the symbol table output.  */
name|timevar_pop
argument_list|(
name|TV_PARSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|final_write_globals
call|)
argument_list|()
expr_stmt|;
name|cgraph_varpool_assemble_pending_decls
argument_list|()
expr_stmt|;
comment|/* This must occur after the loop to output deferred functions.      Else the coverage initializer would not be emitted if all the      functions in this compilation unit were deferred.  */
name|coverage_finish
argument_list|()
expr_stmt|;
comment|/* Write out any pending weak symbol declarations.  */
name|weak_finish
argument_list|()
expr_stmt|;
comment|/* Do dbx symbols.  */
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_finish
argument_list|()
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|debug_hooks
operator|->
name|finish
call|)
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
comment|/* Output some stuff at end of file if nec.  */
name|dw2_output_indirect_constants
argument_list|()
expr_stmt|;
comment|/* Flush any pending equate directives.  */
name|process_pending_assemble_output_defs
argument_list|()
expr_stmt|;
if|if
condition|(
name|profile_arc_flag
operator|||
name|flag_test_coverage
operator|||
name|flag_branch_probabilities
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|end_branch_prob
argument_list|()
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_bp
argument_list|,
name|NULL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
block|}
name|targetm
operator|.
name|asm_out
operator|.
name|file_end
argument_list|()
expr_stmt|;
comment|/* Attach a special .ident directive to the end of the file to identify      the version of GCC which compiled this code.  The format of the .ident      string is patterned after the ones produced by native SVR4 compilers.  */
ifdef|#
directive|ifdef
name|IDENT_ASM_OP
if|if
condition|(
operator|!
name|flag_no_ident
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\"GCC: (GNU) %s\"\n"
argument_list|,
name|IDENT_ASM_OP
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|open_dump_file
argument_list|(
name|DFI_combine
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
name|dump_combine_total_stats
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_combine
argument_list|,
name|NULL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is called from various places for FUNCTION_DECL, VAR_DECL,    and TYPE_DECL nodes.     This does nothing for local (non-static) variables, unless the    variable is a register variable with an ASMSPEC.  In that case, or    if the variable is not an automatic, it sets up the RTL and    outputs any assembler code (label definition, storage allocation    and initialization).     DECL is the declaration.  If ASMSPEC is nonzero, it specifies    the assembler symbol name to be used.  TOP_LEVEL is nonzero    if this declaration is not within a function.  */
end_comment

begin_function
name|void
name|rest_of_decl_compilation
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|asmspec
parameter_list|,
name|int
name|top_level
parameter_list|,
name|int
name|at_end
parameter_list|)
block|{
comment|/* We deferred calling assemble_alias so that we could collect      other attributes such as visibility.  Emit the alias now.  */
block|{
name|tree
name|alias
decl_stmt|;
name|alias
operator|=
name|lookup_attribute
argument_list|(
literal|"alias"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias
condition|)
block|{
name|alias
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
name|alias
operator|=
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_alias
argument_list|(
name|decl
argument_list|,
name|alias
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Forward declarations for nested functions are not "external",      but we need to treat them as if they were.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_VARCONST
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec
condition|)
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
comment|/* Don't output anything when a tentative file-scope definition 	 is seen.  But at end of compilation, do output code for them.  	 We do output all variables when unit-at-a-time is active and rely on 	 callgraph code to defer them except for forward declarations 	 (see gcc.c-torture/compile/920624-1.c) */
if|if
condition|(
operator|(
name|at_end
operator|||
operator|!
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|flag_unit_at_a_time
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_unit_at_a_time
operator|&&
operator|!
name|cgraph_global_info_ready
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|top_level
condition|)
name|cgraph_varpool_finalize_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|assemble_variable
argument_list|(
name|decl
argument_list|,
name|top_level
argument_list|,
name|at_end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_FINISH_DECLARE_OBJECT
if|if
condition|(
name|decl
operator|==
name|last_assemble_variable_decl
condition|)
block|{
name|ASM_FINISH_DECLARE_OBJECT
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|top_level
argument_list|,
name|at_end
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|timevar_pop
argument_list|(
name|TV_VARCONST
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
name|asmspec
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|decode_reg_name
argument_list|(
name|asmspec
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"invalid register name `%s' for register variable"
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|top_level
condition|)
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
elseif|else
if|if
condition|(
operator|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|top_level
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
elseif|else
if|if
condition|(
operator|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
operator|)
operator|&&
name|top_level
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
name|dwarf2out_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Called after finishing a record, union or enumeral type.  */
end_comment

begin_function
name|void
name|rest_of_type_compilation
parameter_list|(
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|SDB_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
name|tree
name|type
parameter_list|,
name|int
name|toplev
else|#
directive|else
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|toplev
name|ATTRIBUTE_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
comment|/* Avoid confusing the debug information machinery when there are      errors.  */
if|if
condition|(
name|errorcount
operator|!=
literal|0
operator|||
name|sorrycount
operator|!=
literal|0
condition|)
return|return;
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|dbxout_symbol
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|,
operator|!
name|toplev
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_symbol
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|,
operator|!
name|toplev
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
operator|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
operator|)
operator|&&
name|toplev
condition|)
name|dwarf2out_decl
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn the RTL into assembly.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_final
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_FINAL
argument_list|)
expr_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
comment|/* Get the function's name, as described by its RTL.  This may be        different from the DECL_NAME name used in the source file.  */
name|x
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fnname
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_start_function
argument_list|(
name|decl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|final_start_function
argument_list|(
name|insns
argument_list|,
name|asm_out_file
argument_list|,
name|optimize
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|insns
argument_list|,
name|asm_out_file
argument_list|,
name|optimize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|final_end_function
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|IA64_UNWIND_INFO
comment|/* ??? The IA-64 ".handlerdata" directive must be issued before        the ".endp" directive that closes the procedure descriptor.  */
name|output_function_exception_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|assemble_end_function
argument_list|(
name|decl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IA64_UNWIND_INFO
comment|/* Otherwise, it feels unclean to switch sections in the middle.  */
name|output_function_exception_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fflush
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Release all memory allocated by flow.  */
name|free_basic_block_vars
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Release all memory held by regsets now.  */
name|regset_release_memory
argument_list|()
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_FINAL
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DELAY_SLOTS
end_ifdef

begin_comment
comment|/* Run delay slot optimization.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_delay_slots
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_DBR_SCHED
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_dbr
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|dbr_schedule
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_dbr
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DBR_SCHED
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_REGS
end_ifdef

begin_comment
comment|/* Convert register usage from flat register file usage to a stack    register file.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_stack_regs
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ATTR_length
argument_list|)
comment|/* If flow2 creates new instructions which need splitting      and scheduling after reload is not done, they might not be      split until final which doesn't allow splitting      if HAVE_ATTR_length.  */
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
if|if
condition|(
name|optimize
operator|&&
operator|!
name|flag_schedule_insns_after_reload
condition|)
else|#
directive|else
if|if
condition|(
name|optimize
condition|)
endif|#
directive|endif
block|{
name|timevar_push
argument_list|(
name|TV_SHORTEN_BRANCH
argument_list|)
expr_stmt|;
name|split_all_insns
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SHORTEN_BRANCH
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|timevar_push
argument_list|(
name|TV_REG_STACK
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_stack
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_to_stack
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|)
operator|&&
name|optimize
condition|)
block|{
if|if
condition|(
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_POST_REGSTACK
operator||
operator|(
name|flag_crossjumping
condition|?
name|CLEANUP_CROSSJUMP
else|:
literal|0
operator|)
argument_list|)
operator|&&
name|flag_reorder_blocks
condition|)
block|{
name|reorder_basic_blocks
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_POST_REGSTACK
argument_list|)
expr_stmt|;
block|}
block|}
name|close_dump_file
argument_list|(
name|DFI_stack
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_REG_STACK
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Machine independent reorg pass.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_machine_reorg
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_MACH_DEP
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_mach
argument_list|,
name|decl
argument_list|)
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|machine_dependent_reorg
call|)
argument_list|()
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_mach
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_MACH_DEP
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Run new register allocator.  Return TRUE if we must exit    rest_of_compilation upon return.  */
end_comment

begin_function
specifier|static
name|bool
name|rest_of_handle_new_regalloc
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|int
name|failure
decl_stmt|;
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
name|reg_alloc
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_LOCAL_ALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
index|[
name|DFI_lreg
index|]
operator|.
name|enabled
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_lreg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
block|}
comment|/* XXX clean up the whole mess to bring live info in shape again.  */
name|timevar_push
argument_list|(
name|TV_GLOBAL_ALLOC
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_greg
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|build_insn_chain
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|failure
operator|=
name|reload
argument_list|(
name|insns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_GLOBAL_ALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
index|[
name|DFI_greg
index|]
operator|.
name|enabled
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
name|dump_global_regs
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_greg
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|failure
condition|)
return|return
name|true
return|;
name|reload_completed
operator|=
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Run old register allocator.  Return TRUE if we must exit    rest_of_compilation upon return.  */
end_comment

begin_function
specifier|static
name|bool
name|rest_of_handle_old_regalloc
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|int
name|failure
decl_stmt|;
name|int
name|rebuild_notes
decl_stmt|;
comment|/* Allocate the reg_renumber array.  */
name|allocate_reg_info
argument_list|(
name|max_regno
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* And the reg_equiv_memory_loc array.  */
name|reg_equiv_memory_loc
operator|=
name|xcalloc
argument_list|(
name|max_regno
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|allocate_initial_values
argument_list|(
name|reg_equiv_memory_loc
argument_list|)
expr_stmt|;
name|regclass
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|rebuild_notes
operator|=
name|local_alloc
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_LOCAL_ALLOC
argument_list|)
expr_stmt|;
comment|/* Local allocation may have turned an indirect jump into a direct      jump.  If so, we must rebuild the JUMP_LABEL fields of jumping      instructions.  */
if|if
condition|(
name|rebuild_notes
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|purge_all_dead_edges
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
index|[
name|DFI_lreg
index|]
operator|.
name|enabled
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|dump_local_alloc
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_lreg
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
block|}
name|ggc_collect
argument_list|()
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_GLOBAL_ALLOC
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_greg
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If optimizing, allocate remaining pseudo-regs.  Do the reload      pass fixing up any insns that are invalid.  */
if|if
condition|(
name|optimize
condition|)
name|failure
operator|=
name|global_alloc
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
else|else
block|{
name|build_insn_chain
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|failure
operator|=
name|reload
argument_list|(
name|insns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_GLOBAL_ALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
index|[
name|DFI_greg
index|]
operator|.
name|enabled
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
name|dump_global_regs
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_greg
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
block|}
return|return
name|failure
return|;
block|}
end_function

begin_comment
comment|/* Run the regrename and cprop passes.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_regrename
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_RENAME_REGISTERS
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_rnreg
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_rename_registers
condition|)
name|regrename_optimize
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_cprop_registers
condition|)
name|copyprop_hardreg_forward
argument_list|()
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_rnreg
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_RENAME_REGISTERS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reorder basic blocks.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_reorder_blocks
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|bool
name|changed
decl_stmt|;
name|unsigned
name|int
name|liveness_flags
decl_stmt|;
name|open_dump_file
argument_list|(
name|DFI_bbro
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Last attempt to optimize CFG, as scheduling, peepholing and insn      splitting possibly introduced more crossjumping opportunities.  */
name|liveness_flags
operator|=
operator|(
operator|!
name|HAVE_conditional_execution
condition|?
name|CLEANUP_UPDATE_LIFE
else|:
literal|0
operator|)
expr_stmt|;
name|changed
operator|=
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|liveness_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_sched2_use_traces
operator|&&
name|flag_schedule_insns_after_reload
condition|)
name|tracer
argument_list|(
name|liveness_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_reorder_blocks
condition|)
name|reorder_basic_blocks
argument_list|(
name|liveness_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_reorder_blocks
operator|||
operator|(
name|flag_sched2_use_traces
operator|&&
name|flag_schedule_insns_after_reload
operator|)
condition|)
name|changed
operator||=
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|liveness_flags
argument_list|)
expr_stmt|;
comment|/* On conditional execution targets we can not update the life cheaply, so      we deffer the updating to after both cleanups.  This may lose some cases      but should not be terribly bad.  */
if|if
condition|(
name|changed
operator|&&
name|HAVE_conditional_execution
condition|)
name|update_life_info
argument_list|(
name|NULL
argument_list|,
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
name|PROP_DEATH_NOTES
operator||
name|PROP_REG_INFO
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_bbro
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
end_ifdef

begin_comment
comment|/* Run instruction scheduler.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_sched
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_SCHED
argument_list|)
expr_stmt|;
comment|/* Print function header into sched dump now      because doing the sched analysis makes some of the dump.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_schedule_insns
condition|)
block|{
name|open_dump_file
argument_list|(
name|DFI_sched
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Do control and data sched analysis, 	 and write some of the results to dump file.  */
name|schedule_insns
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_sched
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_SCHED
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Run second scheduling pass after reload.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_sched2
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_SCHED2
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_sched2
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Do control and data sched analysis again,      and write some more of the results to dump file.  */
name|split_all_insns
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_sched2_use_superblocks
operator|||
name|flag_sched2_use_traces
condition|)
block|{
name|schedule_ebbs
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
comment|/* No liveness updating code yet, but it should be easy to do. 	 reg-stack recompute the liveness when needed for now.  */
name|count_or_remove_death_notes
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
block|}
else|else
name|schedule_insns
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_sched2
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SCHED2
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Register allocation pre-pass, to reduce number of moves necessary    for two-address machines.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_regmove
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_REGMOVE
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_regmove
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|regmove_optimize
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_UPDATE_LIFE
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_regmove
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_REGMOVE
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Run tracer.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_tracer
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|open_dump_file
argument_list|(
name|DFI_tracer
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|tracer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_tracer
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If-conversion and CFG cleanup.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_if_conversion
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|open_dump_file
argument_list|(
name|DFI_ce1
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_if_conversion
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_IFCVT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_convert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_IFCVT
argument_list|)
expr_stmt|;
block|}
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_ce1
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rerun if-conversion, as combine may have simplified things enough    to now meet sequence length restrictions.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_if_after_combine
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_IFCVT
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_ce2
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
name|if_convert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_ce2
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_IFCVT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rest_of_handle_web
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|open_dump_file
argument_list|(
name|DFI_web
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_WEB
argument_list|)
expr_stmt|;
name|web_main
argument_list|()
expr_stmt|;
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_WEB
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_web
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do branch profiling and static profile estimation passes.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_branch_prob
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|struct
name|loops
name|loops
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_BRANCH_PROB
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_bp
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_arc_flag
operator|||
name|flag_test_coverage
operator|||
name|flag_branch_probabilities
condition|)
name|branch_prob
argument_list|()
expr_stmt|;
comment|/* Discover and record the loop depth at the head of each basic      block.  The loop infrastructure does the real job for us.  */
name|flow_loops_find
argument_list|(
operator|&
name|loops
argument_list|,
name|LOOP_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|flow_loops_dump
argument_list|(
operator|&
name|loops
argument_list|,
name|rtl_dump_file
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Estimate using heuristics if no profiling info is available.  */
if|if
condition|(
name|flag_guess_branch_prob
condition|)
name|estimate_probability
argument_list|(
operator|&
name|loops
argument_list|)
expr_stmt|;
name|flow_loops_free
argument_list|(
operator|&
name|loops
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_bp
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_BRANCH_PROB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do optimizations based on expression value profiles.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_value_profile_transformations
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|open_dump_file
argument_list|(
name|DFI_vpt
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_VPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_profile_transformations
argument_list|()
condition|)
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_VPT
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_vpt
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do control and data flow analysis; write some of the results to the    dump file.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_cfg
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|open_dump_file
argument_list|(
name|DFI_cfg
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
operator|(
name|flag_thread_jumps
condition|?
name|CLEANUP_THREADING
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* It may make more sense to mark constant functions after dead code is      eliminated by life_analysis, but we need to do it early, as -fprofile-arcs      may insert code making function non-constant, but we still must consider      it as constant, otherwise -fbranch-probabilities will not read data back.       life_analysis rarely eliminates modification of external memory.    */
if|if
condition|(
name|optimize
condition|)
block|{
comment|/* Alias analysis depends on this information and mark_constant_function        depends on alias analysis.  */
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_constant_function
argument_list|()
expr_stmt|;
block|}
name|close_dump_file
argument_list|(
name|DFI_cfg
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Purge addressofs.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_addressof
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|open_dump_file
argument_list|(
name|DFI_addressof
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|purge_addressof
argument_list|(
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|&&
name|purge_all_dead_edges
argument_list|(
literal|0
argument_list|)
condition|)
name|delete_unreachable_blocks
argument_list|()
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_addressof
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We may have potential sibling or tail recursion sites.  Select one    (of possibly multiple) methods of performing the call.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_sibling_calls
parameter_list|(
name|rtx
name|insns
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|optimize_sibling_and_tail_recursive_calls
argument_list|()
expr_stmt|;
comment|/* Recompute the CFG as sibling optimization clobbers it randomly.  */
name|free_bb_for_insn
argument_list|()
expr_stmt|;
name|find_exception_handler_labels
argument_list|()
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
comment|/* There is pass ordering problem - we must lower NOTE_INSN_PREDICTION      notes before simplifying cfg and we must do lowering after sibcall      that unhides parts of RTL chain and cleans up the CFG.       Until sibcall is replaced by tree-level optimizer, lets just      sweep away the NOTE_INSN_PREDICTION notes that leaked out.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_PREDICTION
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_sibling
argument_list|,
name|print_rtl
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform jump bypassing and control flow optimizations.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_jump_bypass
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_BYPASS
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_bypass
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_jumps
argument_list|(
name|rtl_dump_file
argument_list|)
condition|)
block|{
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|close_dump_file
argument_list|(
name|DFI_bypass
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_BYPASS
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Handle inlining of functions in rest_of_compilation.  Return TRUE    if we must exit rest_of_compilation upon return.  */
end_comment

begin_function
specifier|static
name|bool
name|rest_of_handle_inlining
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|rtx
name|insns
decl_stmt|;
name|int
name|inlinable
init|=
literal|0
decl_stmt|;
name|tree
name|parent
decl_stmt|;
specifier|const
name|char
modifier|*
name|lose
decl_stmt|;
comment|/* If we are reconsidering an inline function at the end of      compilation, skip the stuff for making it inline.  */
if|if
condition|(
name|cfun
operator|->
name|rtl_inline_init
condition|)
return|return
literal|0
return|;
name|cfun
operator|->
name|rtl_inline_init
operator|=
literal|1
expr_stmt|;
comment|/* If this is nested inside an inlined external function, pretend      it was only declared.  Since we cannot inline such functions,      generating code for this one is not only not necessary but will      confuse some debugging output writers.  */
for|for
control|(
name|parent
operator|=
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|parent
operator|!=
name|NULL_TREE
condition|;
name|parent
operator|=
name|get_containing_scope
argument_list|(
name|parent
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INLINE
argument_list|(
name|parent
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|parent
argument_list|)
condition|)
comment|/* A function in a local class should be treated normally.  */
break|break;
comment|/* If requested, consider whether to make this function inline.  */
if|if
condition|(
operator|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|flag_no_inline
operator|)
operator|||
name|flag_inline_functions
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
name|lose
operator|=
name|function_cannot_inline_p
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|lose
operator|||
operator|!
name|optimize
condition|)
block|{
if|if
condition|(
name|warn_inline
operator|&&
name|lose
operator|&&
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|concat
argument_list|(
literal|"%J"
argument_list|,
name|lose
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|warning
argument_list|(
name|msg
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Don't really compile an extern inline function. 	     If we can't make it inline, pretend 	     it was only declared.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
else|else
name|inlinable
operator|=
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
comment|/* Dump the rtl code if we are dumping rtl.  */
if|if
condition|(
name|open_dump_file
argument_list|(
name|DFI_rtl
argument_list|,
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|->
name|saved_for_inline
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; (integrable)\n\n"
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_rtl
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
comment|/* Convert from NOTE_INSN_EH_REGION style notes, and do other      sorts of eh initialization.  Delay this until after the      initial rtl dump so that we can see the original nesting.  */
name|convert_from_eh_region_ranges
argument_list|()
expr_stmt|;
comment|/* If function is inline, and we don't yet know whether to      compile it by itself, defer decision till end of compilation.      wrapup_global_declarations will (indirectly) call      rest_of_compilation again for those functions that need to      be output.  Also defer those functions that we are supposed      to defer.  */
if|if
condition|(
name|inlinable
operator|||
operator|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
comment|/* Egad.  This RTL deferral test conflicts with Fortran assumptions 	     for unreferenced symbols.  See g77.f-torture/execute/980520-1.f. 	     But removing this line from the check breaks all languages that 	     use the call graph to output symbols.  This hard-coded check is 	     the least invasive work-around.  Nested functions need to be 	     deferred too.  */
operator|&&
operator|(
name|flag_inline_functions
operator|||
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU F77"
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|cgraph_n_nodes
operator|>
literal|0
operator|&&
name|cgraph_node
argument_list|(
name|decl
argument_list|)
operator|->
name|origin
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|!
name|flag_keep_inline_functions
operator|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
condition|)
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* DWARF wants separate debugging info for abstract and        concrete instances of all inline functions, including those        declared inline but not inlined, and those inlined even        though they weren't declared inline.  Conveniently, that's        what DECL_INLINE means at this point.  */
call|(
modifier|*
name|debug_hooks
operator|->
name|deferred_inline_function
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If -Wreturn-type, we have to do a bit of compilation.  We just 	 want to call cleanup the cfg to figure out whether or not we can 	 fall off the end of the function; we do the minimum amount of 	 work necessary to make that safe.  */
if|if
condition|(
name|warn_return_type
condition|)
block|{
name|int
name|saved_optimize
init|=
name|optimize
decl_stmt|;
name|optimize
operator|=
literal|0
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|find_exception_handler_labels
argument_list|()
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_PRE_SIBCALL
operator||
name|CLEANUP_PRE_LOOP
argument_list|)
expr_stmt|;
name|optimize
operator|=
name|saved_optimize
expr_stmt|;
comment|/* CFG is no longer maintained up-to-date.  */
name|free_bb_for_insn
argument_list|()
expr_stmt|;
block|}
name|set_nothrow_function_flags
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_function_nothrow
condition|)
comment|/* Now we know that this can't throw; set the flag for the benefit 	   of other functions later in this translation unit.  */
name|TREE_NOTHROW
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
name|save_for_inline
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|->
name|inlinable
operator|=
name|inlinable
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If specified extern inline but we aren't inlining it, we are      done.  This goes for anything that gets here with DECL_EXTERNAL      set, not just things with DECL_INLINE.  */
return|return
operator|(
name|bool
operator|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Try to identify useless null pointer tests and delete them.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_null_pointer
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|open_dump_file
argument_list|(
name|DFI_null
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_null_pointer_checks
argument_list|(
name|insns
argument_list|)
condition|)
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_PRE_LOOP
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_null
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try combining insns through substitution.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_combine
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|int
name|rebuild_jump_labels_after_combine
init|=
literal|0
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_COMBINE
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_combine
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|rebuild_jump_labels_after_combine
operator|=
name|combine_instructions
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Combining insns may have turned an indirect jump into a      direct jump.  Rebuild the JUMP_LABEL fields of jumping      instructions.  */
if|if
condition|(
name|rebuild_jump_labels_after_combine
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_UPDATE_LIFE
argument_list|)
expr_stmt|;
block|}
name|close_dump_file
argument_list|(
name|DFI_combine
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_COMBINE
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform life analysis.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_life
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|open_dump_file
argument_list|(
name|DFI_life
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|regclass_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|life_analysis
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|,
name|PROP_FINAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
name|cleanup_cfg
argument_list|(
operator|(
name|optimize
condition|?
name|CLEANUP_EXPENSIVE
else|:
literal|0
operator|)
operator||
name|CLEANUP_UPDATE_LIFE
operator||
name|CLEANUP_LOG_LINKS
operator||
operator|(
name|flag_thread_jumps
condition|?
name|CLEANUP_THREADING
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_FLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_uninitialized
condition|)
block|{
name|uninitialized_vars_warning
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|setjmp_args_warning
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|optimize
condition|)
block|{
if|if
condition|(
operator|!
name|flag_new_regalloc
operator|&&
name|initialize_uninitialized_subregs
argument_list|()
condition|)
block|{
comment|/* Insns were inserted, and possibly pseudos created, so 	     things might look a bit different.  */
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|allocate_reg_life_data
argument_list|()
expr_stmt|;
name|update_life_info
argument_list|(
name|NULL
argument_list|,
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
name|PROP_LOG_LINKS
operator||
name|PROP_REG_INFO
operator||
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
block|}
block|}
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_life
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform common subexpression elimination.  Nonzero value from    `cse_main' means that jumps were simplified and some code may now    be unreachable, so do jump optimization again.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_cse
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|int
name|tem
decl_stmt|;
name|open_dump_file
argument_list|(
name|DFI_cse
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_CSE
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|cse_main
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|purge_all_dead_edges
argument_list|(
literal|0
argument_list|)
condition|)
name|delete_unreachable_blocks
argument_list|()
expr_stmt|;
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If we are not running more CSE passes, then we are no longer      expecting CSE to be run.  But always rerun it in a cheap mode.  */
name|cse_not_expected
operator|=
operator|!
name|flag_rerun_cse_after_loop
operator|&&
operator|!
name|flag_gcse
expr_stmt|;
if|if
condition|(
name|tem
operator|||
name|optimize
operator|>
literal|1
condition|)
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_PRE_LOOP
argument_list|)
expr_stmt|;
comment|/* Try to identify useless null pointer tests and delete them.  */
if|if
condition|(
name|flag_delete_null_pointer_checks
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_null_pointer_checks
argument_list|(
name|insns
argument_list|)
condition|)
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_PRE_LOOP
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
block|}
comment|/* The second pass of jump optimization is likely to have      removed a bunch more instructions.  */
name|renumber_insns
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_CSE
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_cse
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Run second CSE pass after loop optimizations.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_cse2
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|int
name|tem
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_CSE2
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_cse2
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
comment|/* CFG is no longer maintained up-to-date.  */
name|tem
operator|=
name|cse_main
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
comment|/* Run a pass to eliminate duplicated assignments to condition code      registers.  We have to run this after bypass_jumps, because it      makes it harder for that pass to determine whether a jump can be      bypassed safely.  */
name|cse_condition_code_reg
argument_list|()
expr_stmt|;
name|purge_all_dead_edges
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
block|}
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_cse2
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_CSE2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform global cse.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_gcse
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|int
name|save_csb
decl_stmt|,
name|save_cfj
decl_stmt|;
name|int
name|tem2
init|=
literal|0
decl_stmt|,
name|tem
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_GCSE
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_gcse
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gcse_main
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
name|save_csb
operator|=
name|flag_cse_skip_blocks
expr_stmt|;
name|save_cfj
operator|=
name|flag_cse_follow_jumps
expr_stmt|;
name|flag_cse_skip_blocks
operator|=
name|flag_cse_follow_jumps
operator|=
literal|0
expr_stmt|;
comment|/* Instantiate any remaining CONSTANT_P_RTX nodes.  */
if|if
condition|(
name|current_function_calls_constant_p
condition|)
name|purge_builtin_constant_p
argument_list|()
expr_stmt|;
comment|/* If -fexpensive-optimizations, re-run CSE to clean up things done      by gcse.  */
if|if
condition|(
name|flag_expensive_optimizations
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_CSE
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tem2
operator|=
name|cse_main
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|purge_all_dead_edges
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_CSE
argument_list|)
expr_stmt|;
name|cse_not_expected
operator|=
operator|!
name|flag_rerun_cse_after_loop
expr_stmt|;
block|}
comment|/* If gcse or cse altered any jumps, rerun jump optimizations to clean      things up.  Then possibly re-run CSE again.  */
while|while
condition|(
name|tem
operator|||
name|tem2
condition|)
block|{
name|tem
operator|=
name|tem2
operator|=
literal|0
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_PRE_LOOP
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_expensive_optimizations
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_CSE
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tem2
operator|=
name|cse_main
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|purge_all_dead_edges
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_CSE
argument_list|)
expr_stmt|;
block|}
block|}
name|close_dump_file
argument_list|(
name|DFI_gcse
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_GCSE
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
name|flag_cse_skip_blocks
operator|=
name|save_csb
expr_stmt|;
name|flag_cse_follow_jumps
operator|=
name|save_cfj
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Move constant computations out of loops.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_loop_optimize
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|int
name|do_unroll
decl_stmt|,
name|do_prefetch
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_LOOP
argument_list|)
expr_stmt|;
name|delete_dead_jumptables
argument_list|()
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_PRE_LOOP
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_loop
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* CFG is no longer maintained up-to-date.  */
name|free_bb_for_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_unroll_loops
condition|)
name|do_unroll
operator|=
name|LOOP_AUTO_UNROLL
expr_stmt|;
comment|/* Having two unrollers is useless.  */
else|else
name|do_unroll
operator|=
name|flag_old_unroll_loops
condition|?
name|LOOP_UNROLL
else|:
name|LOOP_AUTO_UNROLL
expr_stmt|;
name|do_prefetch
operator|=
name|flag_prefetch_loop_arrays
condition|?
name|LOOP_PREFETCH
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|flag_rerun_loop_opt
condition|)
block|{
name|cleanup_barriers
argument_list|()
expr_stmt|;
comment|/* We only want to perform unrolling once.  */
name|loop_optimize
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|,
name|do_unroll
argument_list|)
expr_stmt|;
name|do_unroll
operator|=
literal|0
expr_stmt|;
comment|/* The first call to loop_optimize makes some instructions 	 trivially dead.  We delete those instructions now in the 	 hope that doing so will make the heuristics in loop work 	 better and possibly speed up compilation.  */
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
comment|/* The regscan pass is currently necessary as the alias 	 analysis code depends on this information.  */
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|cleanup_barriers
argument_list|()
expr_stmt|;
name|loop_optimize
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|,
name|do_unroll
operator||
name|LOOP_BCT
operator||
name|do_prefetch
argument_list|)
expr_stmt|;
comment|/* Loop can create trivially dead instructions.  */
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_loop
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_LOOP
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform loop optimizations.  It might be better to do them a bit    sooner, but we want the profile feedback to work more    efficiently.  */
end_comment

begin_function
specifier|static
name|void
name|rest_of_handle_loop2
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|struct
name|loops
modifier|*
name|loops
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_LOOP
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_loop2
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|loops
operator|=
name|loop_optimizer_init
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|loops
condition|)
block|{
comment|/* The optimizations:  */
if|if
condition|(
name|flag_unswitch_loops
condition|)
name|unswitch_loops
argument_list|(
name|loops
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_peel_loops
operator|||
name|flag_unroll_loops
condition|)
name|unroll_and_peel_loops
argument_list|(
name|loops
argument_list|,
operator|(
name|flag_peel_loops
condition|?
name|UAP_PEEL
else|:
literal|0
operator|)
operator||
operator|(
name|flag_unroll_loops
condition|?
name|UAP_UNROLL
else|:
literal|0
operator|)
operator||
operator|(
name|flag_unroll_all_loops
condition|?
name|UAP_UNROLL_ALL
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|loop_optimizer_finalize
argument_list|(
name|loops
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_loop2
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_LOOP
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called from finish_function (within langhooks.parse_file)    after each top-level definition is parsed.    It is supposed to compile that function or variable    and output the assembler code for it.    After we return, the tree storage is freed.  */
end_comment

begin_function
name|void
name|rest_of_compilation
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|rtx
name|insns
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_REST_OF_COMPILATION
argument_list|)
expr_stmt|;
comment|/* Register rtl specific functions for cfg.  */
name|rtl_register_cfg_hooks
argument_list|()
expr_stmt|;
comment|/* Now that we're out of the frontend, we shouldn't have any more      CONCATs anywhere.  */
name|generating_concat_p
operator|=
literal|0
expr_stmt|;
comment|/* When processing delayed functions, prepare_function_start() won't      have been run to re-initialize it.  */
name|cse_not_expected
operator|=
operator|!
name|optimize
expr_stmt|;
comment|/* First, make sure that NOTE_BLOCK is set correctly for each      NOTE_INSN_BLOCK_BEG/NOTE_INSN_BLOCK_END note.  */
if|if
condition|(
operator|!
name|cfun
operator|->
name|x_whole_function_mode_p
condition|)
name|identify_blocks
argument_list|()
expr_stmt|;
comment|/* In function-at-a-time mode, we do not attempt to keep the BLOCK      tree in sensible shape.  So, we just recalculate it here.  */
if|if
condition|(
name|cfun
operator|->
name|x_whole_function_mode_p
condition|)
name|reorder_blocks
argument_list|()
expr_stmt|;
name|init_flow
argument_list|()
expr_stmt|;
if|if
condition|(
name|rest_of_handle_inlining
argument_list|(
name|decl
argument_list|)
condition|)
goto|goto
name|exit_rest_of_compilation
goto|;
comment|/* If we're emitting a nested function, make sure its parent gets      emitted as well.  Doing otherwise confuses debug info.  */
block|{
name|tree
name|parent
decl_stmt|;
for|for
control|(
name|parent
operator|=
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|parent
operator|!=
name|NULL_TREE
condition|;
name|parent
operator|=
name|get_containing_scope
argument_list|(
name|parent
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|parent
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We are now committed to emitting code for this function.  Do any      preparation, such as emitting abstract debug info for the inline      before it gets mangled by optimization.  */
if|if
condition|(
name|cgraph_function_possibly_inlined_p
argument_list|(
name|decl
argument_list|)
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|outlining_inline_function
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Remove any notes we don't need.  That will make iterating      over the instruction sequence faster, and allow the garbage      collector to reclaim the memory used by the notes.  */
name|remove_unnecessary_notes
argument_list|()
expr_stmt|;
name|reorder_blocks
argument_list|()
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
comment|/* Initialize some variables used by the optimizers.  */
name|init_function_for_compilation
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Now that integrate will no longer see our rtl, we need not      distinguish between the return value of this function and the      return value of called functions.  Also, we can remove all SETs      of subregs of hard registers; they are only here because of      integrate.  Also, we can now initialize pseudos intended to      carry magic hard reg data throughout the function.  */
name|rtx_equal_function_value_matters
operator|=
literal|0
expr_stmt|;
name|purge_hard_subreg_sets
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Early return if there were errors.  We can run afoul of our      consistency checks, and there's not really much point in fixing them.      Don't return yet if -Wreturn-type; we need to do cleanup_cfg.  */
if|if
condition|(
operator|(
operator|(
name|rtl_dump_and_exit
operator|||
name|flag_syntax_only
operator|)
operator|&&
operator|!
name|warn_return_type
operator|)
operator|||
name|errorcount
operator|||
name|sorrycount
condition|)
goto|goto
name|exit_rest_of_compilation
goto|;
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_sibling
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|find_exception_handler_labels
argument_list|()
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|delete_unreachable_blocks
argument_list|()
expr_stmt|;
comment|/* Turn NOTE_INSN_PREDICTIONs into branch predictions.  */
if|if
condition|(
name|flag_guess_branch_prob
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_BRANCH_PROB
argument_list|)
expr_stmt|;
name|note_prediction_to_br_prob
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_BRANCH_PROB
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_optimize_sibling_calls
condition|)
name|rest_of_handle_sibling_calls
argument_list|(
name|insns
argument_list|)
expr_stmt|;
comment|/* We have to issue these warnings now already, because CFG cleanups      further down may destroy the required information.  However, this      must be done after the sibcall optimization pass because the barrier      emitted for noreturn calls that are candidate for the optimization      is folded into the CALL_PLACEHOLDER until after this pass, so the      CFG is inaccurate.  */
name|check_function_return_warnings
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|insn_locators_initialize
argument_list|()
expr_stmt|;
comment|/* Complete generation of exception handling code.  */
if|if
condition|(
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_eh
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|finish_eh_generation
argument_list|()
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_eh
argument_list|,
name|print_rtl
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
block|}
comment|/* Delay emitting hard_reg_initial_value sets until after EH landing pad      generation, which might create new sets.  */
name|emit_initial_value_sets
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FINALIZE_PIC
comment|/* If we are doing position-independent code generation, now      is the time to output special prologues and epilogues.      We do not want to do this earlier, because it just clutters      up inline functions with meaningless insns.  */
if|if
condition|(
name|flag_pic
condition|)
name|FINALIZE_PIC
expr_stmt|;
endif|#
directive|endif
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
comment|/* Copy any shared structure that should not be shared.  */
name|unshare_all_rtl
argument_list|(
name|current_function_decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SETJMP_VIA_SAVE_AREA
comment|/* This must be performed before virtual register instantiation.      Please be aware the everything in the compiler that can look      at the RTL up to this point must understand that REG_SAVE_AREA      is just like a use of the REG contained inside.  */
if|if
condition|(
name|current_function_calls_alloca
condition|)
name|optimize_save_area_alloca
argument_list|(
name|insns
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Instantiate all virtual registers.  */
name|instantiate_virtual_regs
argument_list|(
name|current_function_decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_jump
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Always do one jump optimization pass to ensure that JUMP_LABEL fields      are initialized and to compute whether control can drop off the end      of the function.  */
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
comment|/* Turn NOTE_INSN_EXPECTED_VALUE into REG_BR_PROB.  Do this      before jump optimization switches branch directions.  */
if|if
condition|(
name|flag_guess_branch_prob
condition|)
name|expected_value_to_br_prob
argument_list|()
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
operator|(
name|optimize
condition|?
name|CLEANUP_EXPENSIVE
else|:
literal|0
operator|)
operator||
name|CLEANUP_PRE_LOOP
operator||
operator|(
name|flag_thread_jumps
condition|?
name|CLEANUP_THREADING
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
block|{
name|free_bb_for_insn
argument_list|()
expr_stmt|;
name|copy_loop_headers
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
name|purge_line_number_notes
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_jump
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
comment|/* Now is when we stop if -fsyntax-only and -Wreturn-type.  */
if|if
condition|(
name|rtl_dump_and_exit
operator|||
name|flag_syntax_only
operator|||
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
condition|)
goto|goto
name|exit_rest_of_compilation
goto|;
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_PRE_LOOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_delete_null_pointer_checks
condition|)
name|rest_of_handle_null_pointer
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
comment|/* Jump optimization, and the removal of NULL pointer checks, may      have reduced the number of instructions substantially.  CSE, and      future passes, allocate arrays whose dimensions involve the      maximum instruction UID, so if we can reduce the maximum UID      we'll save big on memory.  */
name|renumber_insns
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_jump
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
name|rest_of_handle_cse
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|rest_of_handle_addressof
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|flag_gcse
condition|)
name|rest_of_handle_gcse
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_loop_optimize
condition|)
name|rest_of_handle_loop_optimize
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_gcse
condition|)
name|rest_of_handle_jump_bypass
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
name|timevar_push
argument_list|(
name|TV_FLOW
argument_list|)
expr_stmt|;
name|rest_of_handle_cfg
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|>
literal|0
operator|||
name|profile_arc_flag
operator|||
name|flag_test_coverage
operator|||
name|flag_branch_probabilities
condition|)
block|{
name|rest_of_handle_branch_prob
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_branch_probabilities
operator|&&
name|flag_profile_values
operator|&&
name|flag_value_profile_transformations
condition|)
name|rest_of_handle_value_profile_transformations
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
comment|/* Remove the death notes created for vpt.  */
if|if
condition|(
name|flag_profile_values
condition|)
name|count_or_remove_death_notes
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
name|rest_of_handle_if_conversion
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_tracer
condition|)
name|rest_of_handle_tracer
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
operator|(
name|flag_unswitch_loops
operator|||
name|flag_peel_loops
operator|||
name|flag_unroll_loops
operator|)
condition|)
name|rest_of_handle_loop2
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_web
condition|)
name|rest_of_handle_web
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_rerun_cse_after_loop
condition|)
name|rest_of_handle_cse2
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|cse_not_expected
operator|=
literal|1
expr_stmt|;
name|rest_of_handle_life
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
name|rest_of_handle_combine
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_if_conversion
condition|)
name|rest_of_handle_if_after_combine
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
operator|(
name|flag_regmove
operator|||
name|flag_expensive_optimizations
operator|)
condition|)
name|rest_of_handle_regmove
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
comment|/* Do unconditional splitting before register allocation to allow machine      description to add extra information not needed previously.  */
name|split_all_insns
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPTIMIZE_MODE_SWITCHING
name|timevar_push
argument_list|(
name|TV_MODE_SWITCH
argument_list|)
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
name|optimize_mode_switching
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_MODE_SWITCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Any of the several passes since flow1 will have munged register      lifetime data a bit.  We need it to be up to date for scheduling      (see handling of reg_known_equiv in init_alias_analysis).  */
name|recompute_reg_usage
argument_list|(
name|insns
argument_list|,
operator|!
name|optimize_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
name|rest_of_handle_sched
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Determine if the current function is a leaf before running reload      since this can impact optimizations done by the prologue and      epilogue thus changing register elimination offsets.  */
name|current_function_is_leaf
operator|=
name|leaf_function_p
argument_list|()
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_LOCAL_ALLOC
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_lreg
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_new_regalloc
condition|)
block|{
if|if
condition|(
name|rest_of_handle_new_regalloc
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
condition|)
goto|goto
name|exit_rest_of_compilation
goto|;
block|}
else|else
block|{
if|if
condition|(
name|rest_of_handle_old_regalloc
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
condition|)
goto|goto
name|exit_rest_of_compilation
goto|;
block|}
name|ggc_collect
argument_list|()
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_postreload
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Do a very simple CSE pass over just the hard registers.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_RELOAD_CSE_REGS
argument_list|)
expr_stmt|;
name|reload_cse_regs
argument_list|(
name|insns
argument_list|)
expr_stmt|;
comment|/* reload_cse_regs can eliminate potentially-trapping MEMs. 	 Remove any EH edges associated with them.  */
if|if
condition|(
name|flag_non_call_exceptions
condition|)
name|purge_all_dead_edges
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_RELOAD_CSE_REGS
argument_list|)
expr_stmt|;
block|}
name|close_dump_file
argument_list|(
name|DFI_postreload
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
comment|/* Re-create the death notes which were deleted during reload.  */
name|timevar_push
argument_list|(
name|TV_FLOW2
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_flow2
argument_list|,
name|decl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* If optimizing, then go ahead and split insns now.  */
ifndef|#
directive|ifndef
name|STACK_REGS
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
endif|#
directive|endif
name|split_all_insns
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_branch_target_load_optimize
condition|)
block|{
name|open_dump_file
argument_list|(
name|DFI_branch_target_load
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|branch_target_load_optimize
argument_list|(
name|insns
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_branch_target_load
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|optimize
condition|)
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
comment|/* On some machines, the prologue and epilogue code, or parts thereof,      can be represented as RTL.  Doing so lets us schedule insns between      it and the rest of the code and also allows delayed branch      scheduling to operate in the epilogue.  */
name|thread_prologue_and_epilogue_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|epilogue_completed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
block|{
name|life_analysis
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|,
name|PROP_POSTRELOAD
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_UPDATE_LIFE
operator||
operator|(
name|flag_crossjumping
condition|?
name|CLEANUP_CROSSJUMP
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* This is kind of a heuristic.  We need to run combine_stack_adjustments          even for machines with possibly nonzero RETURN_POPS_ARGS          and ACCUMULATE_OUTGOING_ARGS.  We expect that only ports having          push instructions will have popping returns.  */
ifndef|#
directive|ifndef
name|PUSH_ROUNDING
if|if
condition|(
operator|!
name|ACCUMULATE_OUTGOING_ARGS
condition|)
endif|#
directive|endif
name|combine_stack_adjustments
argument_list|()
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
name|flow2_completed
operator|=
literal|1
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_flow2
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_FLOW2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_peephole2
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_peephole2
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_PEEPHOLE2
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_peephole2
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|peephole2_optimize
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_peephole2
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_PEEPHOLE2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|open_dump_file
argument_list|(
name|DFI_ce3
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
comment|/* Last attempt to optimize CFG, as scheduling, peepholing and insn        splitting possibly introduced more crossjumping opportunities.  */
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_UPDATE_LIFE
operator||
operator|(
name|flag_crossjumping
condition|?
name|CLEANUP_CROSSJUMP
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_if_conversion2
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_IFCVT2
argument_list|)
expr_stmt|;
name|if_convert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_IFCVT2
argument_list|)
expr_stmt|;
block|}
name|close_dump_file
argument_list|(
name|DFI_ce3
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|flag_rename_registers
operator|||
name|flag_cprop_registers
condition|)
name|rest_of_handle_regrename
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|rest_of_handle_reorder_blocks
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_branch_target_load_optimize2
condition|)
block|{
comment|/* Leave this a warning for now so that it is possible to experiment 	 with running this pass twice.  In 3.6, we should either make this 	 an error, or use separate dump files.  */
if|if
condition|(
name|flag_branch_target_load_optimize
condition|)
name|warning
argument_list|(
literal|"branch target register load optimization is not intended "
literal|"to be run twice"
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_branch_target_load
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|branch_target_load_optimize
argument_list|(
name|insns
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_branch_target_load
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_schedule_insns_after_reload
condition|)
name|rest_of_handle_sched2
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
name|current_function_uses_only_leaf_regs
operator|=
name|optimize
operator|>
literal|0
operator|&&
name|only_leaf_regs_used
argument_list|()
operator|&&
name|leaf_function_p
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STACK_REGS
name|rest_of_handle_stack_regs
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|compute_alignments
argument_list|()
expr_stmt|;
comment|/* CFG is no longer maintained up-to-date.  */
name|free_bb_for_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|machine_dependent_reorg
operator|!=
literal|0
condition|)
name|rest_of_handle_machine_reorg
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|purge_line_number_notes
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|cleanup_barriers
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DELAY_SLOTS
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_delayed_branch
condition|)
name|rest_of_handle_delay_slots
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ATTR_length
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|STACK_REGS
argument_list|)
name|timevar_push
argument_list|(
name|TV_SHORTEN_BRANCH
argument_list|)
expr_stmt|;
name|split_all_insns_noflow
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SHORTEN_BRANCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|convert_to_eh_region_ranges
argument_list|()
expr_stmt|;
comment|/* Shorten branches.  */
name|timevar_push
argument_list|(
name|TV_SHORTEN_BRANCH
argument_list|)
expr_stmt|;
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SHORTEN_BRANCH
argument_list|)
expr_stmt|;
name|set_nothrow_function_flags
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_function_nothrow
condition|)
comment|/* Now we know that this can't throw; set the flag for the benefit        of other functions later in this translation unit.  */
name|TREE_NOTHROW
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rest_of_handle_final
argument_list|(
name|decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
comment|/* Write DBX symbols if requested.  */
comment|/* Note that for those inline functions where we don't initially      know for certain that we will be generating an out-of-line copy,      the first invocation of this routine (rest_of_compilation) will      skip over this code by doing a `goto exit_rest_of_compilation;'.      Later on, wrapup_global_declarations will (indirectly) call      rest_of_compilation again for those inline functions that need      to have out-of-line copies generated.  During that call, we      *will* be routed past here.  */
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|function_decl
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
name|exit_rest_of_compilation
label|:
name|coverage_end_function
argument_list|()
expr_stmt|;
comment|/* In case the function was not output,      don't leave any temporary anonymous types      queued up for sdb output.  */
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_types
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reload_completed
operator|=
literal|0
expr_stmt|;
name|epilogue_completed
operator|=
literal|0
expr_stmt|;
name|flow2_completed
operator|=
literal|0
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_FINAL
argument_list|)
expr_stmt|;
comment|/* Clear out the insn_length contents now that they are no      longer valid.  */
name|init_insn_lengths
argument_list|()
expr_stmt|;
comment|/* Show no temporary slots allocated.  */
name|init_temp_slots
argument_list|()
expr_stmt|;
name|free_basic_block_vars
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|free_bb_for_insn
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_FINAL
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|int
name|pref
init|=
name|cfun
operator|->
name|preferred_stack_boundary
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|stack_alignment_needed
operator|>
name|cfun
operator|->
name|preferred_stack_boundary
condition|)
name|pref
operator|=
name|cfun
operator|->
name|stack_alignment_needed
expr_stmt|;
name|cgraph_rtl_info
argument_list|(
name|current_function_decl
argument_list|)
operator|->
name|preferred_incoming_stack_boundary
operator|=
name|pref
expr_stmt|;
block|}
comment|/* Make sure volatile mem refs aren't considered valid operands for      arithmetic insns.  We must call this here if this is a nested inline      function, since the above code leaves us in the init_recog state      (from final.c), and the function context push/pop code does not      save/restore volatile_ok.       ??? Maybe it isn't necessary for expand_start_function to call this      anymore if we do it here?  */
name|init_recog_no_volatile
argument_list|()
expr_stmt|;
comment|/* We're done with this function.  Free up memory if we can.  */
name|free_after_parsing
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|free_after_compilation
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|cfun
operator|=
literal|0
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_REST_OF_COMPILATION
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display help for target options.  */
end_comment

begin_function
name|void
name|display_target_options
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|undoc
decl_stmt|,
name|i
decl_stmt|;
specifier|static
name|bool
name|displayed
init|=
name|false
decl_stmt|;
comment|/* Avoid double printing for --help --target-help.  */
if|if
condition|(
name|displayed
condition|)
return|return;
name|displayed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|ARRAY_SIZE
argument_list|(
name|target_switches
argument_list|)
operator|>
literal|1
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
operator|||
name|ARRAY_SIZE
argument_list|(
name|target_options
argument_list|)
operator|>
literal|1
endif|#
directive|endif
condition|)
block|{
name|int
name|doc
init|=
literal|0
decl_stmt|;
name|undoc
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nTarget specific options:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|target_switches
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|option
init|=
name|target_switches
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
init|=
name|target_switches
index|[
name|i
index|]
operator|.
name|description
decl_stmt|;
if|if
condition|(
name|option
operator|==
name|NULL
operator|||
operator|*
name|option
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|description
operator|==
name|NULL
condition|)
block|{
name|undoc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -m%-23s [undocumented]\n"
argument_list|)
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|description
operator|!=
literal|0
condition|)
name|doc
operator|+=
name|printf
argument_list|(
literal|"  -m%-23s %s\n"
argument_list|,
name|option
argument_list|,
name|_
argument_list|(
name|description
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|target_options
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|option
init|=
name|target_options
index|[
name|i
index|]
operator|.
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
init|=
name|target_options
index|[
name|i
index|]
operator|.
name|description
decl_stmt|;
if|if
condition|(
name|option
operator|==
name|NULL
operator|||
operator|*
name|option
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|description
operator|==
name|NULL
condition|)
block|{
name|undoc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -m%-23s [undocumented]\n"
argument_list|)
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|description
operator|!=
literal|0
condition|)
name|doc
operator|+=
name|printf
argument_list|(
literal|"  -m%-23s %s\n"
argument_list|,
name|option
argument_list|,
name|_
argument_list|(
name|description
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|undoc
condition|)
block|{
if|if
condition|(
name|doc
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are undocumented target specific options as well.\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  They exist, but they are not documented.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Parse a -d... command line switch.  */
end_comment

begin_function
name|void
name|decode_d_option
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|matched
decl_stmt|;
while|while
condition|(
operator|*
name|arg
condition|)
switch|switch
condition|(
name|c
operator|=
operator|*
name|arg
operator|++
condition|)
block|{
case|case
literal|'a'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|DFI_MAX
condition|;
operator|++
name|i
control|)
name|dump_file
index|[
name|i
index|]
operator|.
name|enabled
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|flag_debug_asm
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|flag_print_asm_name
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|flag_dump_rtl_in_asm
operator|=
literal|1
expr_stmt|;
name|flag_print_asm_name
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|graph_dump_format
operator|=
name|vcg
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|rtl_dump_and_exit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|set_yydebug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* These are handled by the preprocessor.  */
case|case
literal|'I'
case|:
break|break;
case|case
literal|'H'
case|:
name|setup_core_dumping
argument_list|()
expr_stmt|;
break|break;
default|default:
name|matched
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|DFI_MAX
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|c
operator|==
name|dump_file
index|[
name|i
index|]
operator|.
name|debug_switch
condition|)
block|{
name|dump_file
index|[
name|i
index|]
operator|.
name|enabled
operator|=
literal|1
expr_stmt|;
name|matched
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matched
condition|)
name|warning
argument_list|(
literal|"unrecognized gcc debugging option: %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Indexed by enum debug_info_type.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|debug_type_names
index|[]
init|=
block|{
literal|"none"
block|,
literal|"stabs"
block|,
literal|"coff"
block|,
literal|"dwarf-1"
block|,
literal|"dwarf-2"
block|,
literal|"xcoff"
block|,
literal|"vms"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Decode -m switches.  */
end_comment

begin_comment
comment|/* Decode the switch -mNAME.  */
end_comment

begin_function
name|void
name|set_target_switch
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|j
decl_stmt|;
name|int
name|valid_target_option
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|target_switches
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|target_switches
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|<
literal|0
condition|)
name|target_flags
operator|&=
operator|~
operator|-
name|target_switches
index|[
name|j
index|]
operator|.
name|value
expr_stmt|;
else|else
name|target_flags
operator||=
name|target_switches
index|[
name|j
index|]
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|<
literal|0
condition|)
name|target_flags_explicit
operator||=
operator|-
name|target_switches
index|[
name|j
index|]
operator|.
name|value
expr_stmt|;
else|else
name|target_flags_explicit
operator||=
name|target_switches
index|[
name|j
index|]
operator|.
name|value
expr_stmt|;
block|}
name|valid_target_option
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
if|if
condition|(
operator|!
name|valid_target_option
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|target_options
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|target_options
index|[
name|j
index|]
operator|.
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|target_options
index|[
name|j
index|]
operator|.
name|value
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|target_options
index|[
name|j
index|]
operator|.
name|prefix
argument_list|,
name|name
argument_list|)
condition|)
block|{
operator|*
name|target_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
name|target_options
index|[
name|j
index|]
operator|.
name|value
expr_stmt|;
name|valid_target_option
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|target_options
index|[
name|j
index|]
operator|.
name|prefix
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|target_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
name|name
operator|+
name|len
expr_stmt|;
name|valid_target_option
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|valid_target_option
condition|)
name|error
argument_list|(
literal|"invalid option `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print version information to FILE.    Each line begins with INDENT (for the case where FILE is the    assembler output file).  */
end_comment

begin_function
name|void
name|print_version
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|__VERSION__
define|#
directive|define
name|__VERSION__
value|"[?]"
endif|#
directive|endif
name|fnotice
argument_list|(
name|file
argument_list|,
ifdef|#
directive|ifdef
name|__GNUC__
literal|"%s%s%s version %s (%s)\n%s\tcompiled by GNU C version %s.\n"
else|#
directive|else
literal|"%s%s%s version %s (%s) compiled by CC.\n"
endif|#
directive|endif
argument_list|,
name|indent
argument_list|,
operator|*
name|indent
operator|!=
literal|0
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|lang_hooks
operator|.
name|name
argument_list|,
name|version_string
argument_list|,
name|TARGET_NAME
argument_list|,
name|indent
argument_list|,
name|__VERSION__
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"%s%sGGC heuristics: --param ggc-min-expand=%d --param ggc-min-heapsize=%d\n"
argument_list|,
name|indent
argument_list|,
operator|*
name|indent
operator|!=
literal|0
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|PARAM_VALUE
argument_list|(
name|GGC_MIN_EXPAND
argument_list|)
argument_list|,
name|PARAM_VALUE
argument_list|(
name|GGC_MIN_HEAPSIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an option value and return the adjusted position in the line.    ??? We don't handle error returns from fprintf (disk full); presumably    other code will catch a disk full though.  */
end_comment

begin_function
specifier|static
name|int
name|print_single_switch
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|max
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
specifier|const
name|char
modifier|*
name|sep
parameter_list|,
specifier|const
name|char
modifier|*
name|term
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* The ultrix fprintf returns 0 on success, so compute the result we want      here since we need it for the following test.  */
name|int
name|len
init|=
name|strlen
argument_list|(
name|sep
argument_list|)
operator|+
name|strlen
argument_list|(
name|type
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
literal|0
operator|&&
name|pos
operator|+
name|len
operator|>
name|max
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|pos
operator|=
name|strlen
argument_list|(
name|indent
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%s"
argument_list|,
name|sep
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|len
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function

begin_comment
comment|/* Print active target switches to FILE.    POS is the current cursor position and MAX is the size of a "line".    Each line begins with INDENT and ends with TERM.    Each switch is separated from the next by SEP.  */
end_comment

begin_function
specifier|static
name|void
name|print_switch_values
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|max
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
specifier|const
name|char
modifier|*
name|sep
parameter_list|,
specifier|const
name|char
modifier|*
name|term
parameter_list|)
block|{
name|size_t
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
comment|/* Fill in the -frandom-seed option, if the user didn't pass it, so      that it can be printed below.  This helps reproducibility.  */
name|randomize
argument_list|()
expr_stmt|;
comment|/* Print the options as passed.  */
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
operator|*
name|indent
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|term
argument_list|,
name|_
argument_list|(
literal|"options passed: "
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|save_argv
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
comment|/* Ignore these.  */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
literal|"-o"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
literal|"-quiet"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
literal|"-version"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|*
name|p
operator|)
index|[
literal|1
index|]
operator|==
literal|'d'
condition|)
continue|continue;
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
name|sep
argument_list|,
name|term
argument_list|,
operator|*
name|p
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|term
argument_list|)
expr_stmt|;
comment|/* Print the -f and -m options that have been enabled.      We don't handle language specific options but printing argv      should suffice.  */
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
operator|*
name|indent
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|term
argument_list|,
name|_
argument_list|(
literal|"options enabled: "
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|f_options
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|*
name|f_options
index|[
name|j
index|]
operator|.
name|variable
operator|==
name|f_options
index|[
name|j
index|]
operator|.
name|on_value
condition|)
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
name|sep
argument_list|,
name|term
argument_list|,
literal|"-f"
argument_list|,
name|f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
comment|/* Print target specific options.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|target_switches
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|target_switches
index|[
name|j
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|>
literal|0
operator|&&
operator|(
operator|(
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|&
name|target_flags
operator|)
operator|==
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|)
condition|)
block|{
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
name|sep
argument_list|,
name|term
argument_list|,
literal|"-m"
argument_list|,
name|target_switches
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|target_options
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|*
name|target_options
index|[
name|j
index|]
operator|.
name|variable
operator|!=
name|NULL
condition|)
block|{
name|char
name|prefix
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|prefix
argument_list|,
literal|"-m%s"
argument_list|,
name|target_options
index|[
name|j
index|]
operator|.
name|prefix
argument_list|)
expr_stmt|;
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
name|sep
argument_list|,
name|term
argument_list|,
name|prefix
argument_list|,
operator|*
name|target_options
index|[
name|j
index|]
operator|.
name|variable
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open assembly code output file.  Do this even if -fsyntax-only is    on, because then the driver will have provided the name of a    temporary file or bit bucket for us.  NAME is the file specified on    the command line, possibly NULL.  */
end_comment

begin_function
specifier|static
name|void
name|init_asm_output
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
name|NULL
operator|&&
name|asm_file_name
operator|==
literal|0
condition|)
name|asm_out_file
operator|=
name|stdout
expr_stmt|;
else|else
block|{
if|if
condition|(
name|asm_file_name
operator|==
literal|0
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|dump_base_name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dumpname
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|6
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strip_off_ending
argument_list|(
name|dumpname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".s"
argument_list|)
expr_stmt|;
name|asm_file_name
operator|=
name|dumpname
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asm_file_name
argument_list|,
literal|"-"
argument_list|)
condition|)
name|asm_out_file
operator|=
name|stdout
expr_stmt|;
else|else
name|asm_out_file
operator|=
name|fopen
argument_list|(
name|asm_file_name
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_out_file
operator|==
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"can't open %s for writing: %m"
argument_list|,
name|asm_file_name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IO_BUFFER_SIZE
name|setvbuf
argument_list|(
name|asm_out_file
argument_list|,
name|xmalloc
argument_list|(
name|IO_BUFFER_SIZE
argument_list|)
argument_list|,
name|_IOFBF
argument_list|,
name|IO_BUFFER_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|flag_syntax_only
condition|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|file_start
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_COMMENT_START
if|if
condition|(
name|flag_verbose_asm
condition|)
block|{
comment|/* Print the list of options in effect.  */
name|print_version
argument_list|(
name|asm_out_file
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|print_switch_values
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|,
name|MAX_LINE
argument_list|,
name|ASM_COMMENT_START
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Add a blank line here so it appears in assembler output but not 	     screen output.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Default version of get_pch_validity.    By default, every flag difference is fatal; that will be mostly right for    most targets, but completely right for very few.  */
end_comment

begin_function
name|void
modifier|*
name|default_get_pch_validity
parameter_list|(
name|size_t
modifier|*
name|len
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
name|size_t
name|i
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|result
decl_stmt|,
modifier|*
name|r
decl_stmt|;
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
name|target_flags
argument_list|)
operator|+
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|target_options
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|len
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|target_options
index|[
name|i
index|]
operator|.
name|variable
condition|)
operator|*
name|len
operator|+=
name|strlen
argument_list|(
operator|*
name|target_options
index|[
name|i
index|]
operator|.
name|variable
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|result
operator|=
name|r
operator|=
name|xmalloc
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
name|r
index|[
literal|0
index|]
operator|=
name|flag_pic
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
name|flag_pie
expr_stmt|;
name|r
operator|+=
literal|2
expr_stmt|;
name|memcpy
argument_list|(
name|r
argument_list|,
operator|&
name|target_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|target_flags
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|+=
sizeof|sizeof
argument_list|(
name|target_flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|target_options
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
operator|*
name|target_options
index|[
name|i
index|]
operator|.
name|variable
decl_stmt|;
name|size_t
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
name|str
operator|=
literal|""
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|r
argument_list|,
name|str
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|r
operator|+=
name|l
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Default version of pch_valid_p.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|default_pch_valid_p
parameter_list|(
specifier|const
name|void
modifier|*
name|data_p
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|data
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|flag_that_differs
init|=
name|NULL
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* -fpic and -fpie also usually make a PCH invalid.  */
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|!=
name|flag_pic
condition|)
return|return
name|_
argument_list|(
literal|"created and used with different settings of -fpic"
argument_list|)
return|;
if|if
condition|(
name|data
index|[
literal|1
index|]
operator|!=
name|flag_pie
condition|)
return|return
name|_
argument_list|(
literal|"created and used with different settings of -fpie"
argument_list|)
return|;
name|data
operator|+=
literal|2
expr_stmt|;
comment|/* Check target_flags.  */
if|if
condition|(
name|memcmp
argument_list|(
name|data
argument_list|,
operator|&
name|target_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|target_flags
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|target_switches
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bits
decl_stmt|;
name|int
name|tf
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|tf
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|target_flags
argument_list|)
argument_list|)
expr_stmt|;
name|bits
operator|=
name|target_switches
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|bits
operator|<
literal|0
condition|)
name|bits
operator|=
operator|-
name|bits
expr_stmt|;
if|if
condition|(
operator|(
name|target_flags
operator|&
name|bits
operator|)
operator|!=
operator|(
name|tf
operator|&
name|bits
operator|)
condition|)
block|{
name|flag_that_differs
operator|=
name|target_switches
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
goto|goto
name|make_message
goto|;
block|}
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|target_flags
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|target_flags
argument_list|)
expr_stmt|;
comment|/* Check string options.  */
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|target_options
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
operator|*
name|target_options
index|[
name|i
index|]
operator|.
name|variable
decl_stmt|;
name|size_t
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
name|str
operator|=
literal|""
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|l
operator|||
name|memcmp
argument_list|(
name|data
argument_list|,
name|str
argument_list|,
name|l
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|flag_that_differs
operator|=
name|target_options
index|[
name|i
index|]
operator|.
name|prefix
expr_stmt|;
goto|goto
name|make_message
goto|;
block|}
name|data
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|NULL
return|;
name|make_message
label|:
block|{
name|char
modifier|*
name|r
decl_stmt|;
name|asprintf
argument_list|(
operator|&
name|r
argument_list|,
name|_
argument_list|(
literal|"created and used with differing settings of `-m%s'"
argument_list|)
argument_list|,
name|flag_that_differs
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|_
argument_list|(
literal|"out of memory"
argument_list|)
return|;
return|return
name|r
return|;
block|}
block|}
end_function

begin_comment
comment|/* Default tree printer.   Handles declarations only.  */
end_comment

begin_function
specifier|static
name|bool
name|default_tree_printer
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
name|text_info
modifier|*
name|text
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|text
operator|->
name|format_spec
condition|)
block|{
case|case
literal|'D'
case|:
case|case
literal|'F'
case|:
case|case
literal|'T'
case|:
block|{
name|tree
name|t
init|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|tree
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|n
init|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|?
call|(
modifier|*
name|lang_hooks
operator|.
name|decl_printable_name
call|)
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
else|:
literal|"<anonymous>"
decl_stmt|;
name|pp_string
argument_list|(
name|pp
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Initialization of the front end environment, before command line    options are parsed.  Signal handlers, internationalization etc.    ARGV0 is main's argv[0].  */
end_comment

begin_function
specifier|static
name|void
name|general_init
parameter_list|(
specifier|const
name|char
modifier|*
name|argv0
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|argv0
operator|+
name|strlen
argument_list|(
name|argv0
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|argv0
operator|&&
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|p
expr_stmt|;
name|progname
operator|=
name|p
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|progname
argument_list|)
expr_stmt|;
name|hex_init
argument_list|()
expr_stmt|;
name|gcc_init_libintl
argument_list|()
expr_stmt|;
comment|/* Initialize the diagnostics reporting machinery, so option parsing      can give warnings and errors.  */
name|diagnostic_initialize
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
comment|/* Set a default printer.  Language specific initializations will      override it later.  */
name|pp_format_decoder
argument_list|(
name|global_dc
operator|->
name|printer
argument_list|)
operator|=
operator|&
name|default_tree_printer
expr_stmt|;
comment|/* Trap fatal signals, e.g. SIGSEGV, and convert them to ICE messages.  */
ifdef|#
directive|ifdef
name|SIGSEGV
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGILL
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGBUS
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGABRT
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
name|SIGIOT
operator|&&
operator|(
operator|!
name|defined
name|SIGABRT
operator|||
name|SIGABRT
operator|!=
name|SIGIOT
operator|)
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGFPE
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Other host-specific signal setup.  */
call|(
modifier|*
name|host_hooks
operator|.
name|extra_signals
call|)
argument_list|()
expr_stmt|;
comment|/* Initialize the garbage-collector, string pools and tree type hash      table.  */
name|init_ggc
argument_list|()
expr_stmt|;
name|init_stringpool
argument_list|()
expr_stmt|;
name|init_ttree
argument_list|()
expr_stmt|;
comment|/* Initialize register usage now so switches may override.  */
name|init_reg_sets
argument_list|()
expr_stmt|;
comment|/* Register the language-independent parameters.  */
name|add_params
argument_list|(
name|lang_independent_params
argument_list|,
name|LAST_PARAM
argument_list|)
expr_stmt|;
comment|/* This must be done after add_params but before argument processing.  */
name|init_ggc_heuristics
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process the options that have been parsed.  */
end_comment

begin_function
specifier|static
name|void
name|process_options
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Allow the front end to perform consistency checks and do further      initialization based on the command line options.  This hook also      sets the original filename if appropriate (e.g. foo.i -> foo.c)      so we can correctly initialize debug output.  */
name|no_backend
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|post_options
call|)
argument_list|(
operator|&
name|main_input_filename
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|main_input_filename
expr_stmt|;
ifdef|#
directive|ifdef
name|OVERRIDE_OPTIONS
comment|/* Some machines may reject certain combinations of options.  */
name|OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
comment|/* Set aux_base_name if not already set.  */
if|if
condition|(
name|aux_base_name
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|main_input_filename
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|xstrdup
argument_list|(
name|lbasename
argument_list|(
name|main_input_filename
argument_list|)
argument_list|)
decl_stmt|;
name|strip_off_ending
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|aux_base_name
operator|=
name|name
expr_stmt|;
block|}
else|else
name|aux_base_name
operator|=
literal|"gccaux"
expr_stmt|;
comment|/* Set up the align_*_log variables, defaulting them to 1 if they      were still unset.  */
if|if
condition|(
name|align_loops
operator|<=
literal|0
condition|)
name|align_loops
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|align_loops_max_skip
operator|>
name|align_loops
operator|||
operator|!
name|align_loops
condition|)
name|align_loops_max_skip
operator|=
name|align_loops
operator|-
literal|1
expr_stmt|;
name|align_loops_log
operator|=
name|floor_log2
argument_list|(
name|align_loops
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_jumps
operator|<=
literal|0
condition|)
name|align_jumps
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|align_jumps_max_skip
operator|>
name|align_jumps
operator|||
operator|!
name|align_jumps
condition|)
name|align_jumps_max_skip
operator|=
name|align_jumps
operator|-
literal|1
expr_stmt|;
name|align_jumps_log
operator|=
name|floor_log2
argument_list|(
name|align_jumps
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_labels
operator|<=
literal|0
condition|)
name|align_labels
operator|=
literal|1
expr_stmt|;
name|align_labels_log
operator|=
name|floor_log2
argument_list|(
name|align_labels
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_labels_max_skip
operator|>
name|align_labels
operator|||
operator|!
name|align_labels
condition|)
name|align_labels_max_skip
operator|=
name|align_labels
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|align_functions
operator|<=
literal|0
condition|)
name|align_functions
operator|=
literal|1
expr_stmt|;
name|align_functions_log
operator|=
name|floor_log2
argument_list|(
name|align_functions
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Unrolling all loops implies that standard loop unrolling must also      be done.  */
if|if
condition|(
name|flag_unroll_all_loops
condition|)
name|flag_unroll_loops
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_unroll_loops
condition|)
block|{
name|flag_old_unroll_loops
operator|=
literal|0
expr_stmt|;
name|flag_old_unroll_all_loops
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag_old_unroll_all_loops
condition|)
name|flag_old_unroll_loops
operator|=
literal|1
expr_stmt|;
comment|/* Old loop unrolling requires that strength_reduction be on also.  Silently      turn on strength reduction here if it isn't already on.  Also, the loop      unrolling code assumes that cse will be run after loop, so that must      be turned on also.  */
if|if
condition|(
name|flag_old_unroll_loops
condition|)
block|{
name|flag_strength_reduce
operator|=
literal|1
expr_stmt|;
name|flag_rerun_cse_after_loop
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flag_unroll_loops
operator|||
name|flag_peel_loops
condition|)
name|flag_rerun_cse_after_loop
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_non_call_exceptions
condition|)
name|flag_asynchronous_unwind_tables
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_asynchronous_unwind_tables
condition|)
name|flag_unwind_tables
operator|=
literal|1
expr_stmt|;
comment|/* Disable unit-at-a-time mode for frontends not supporting callgraph      interface.  */
if|if
condition|(
name|flag_unit_at_a_time
operator|&&
operator|!
name|lang_hooks
operator|.
name|callgraph
operator|.
name|expand_function
condition|)
name|flag_unit_at_a_time
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_value_profile_transformations
condition|)
name|flag_profile_values
operator|=
literal|1
expr_stmt|;
comment|/* Warn about options that are not supported on this machine.  */
ifndef|#
directive|ifndef
name|INSN_SCHEDULING
if|if
condition|(
name|flag_schedule_insns
operator|||
name|flag_schedule_insns_after_reload
condition|)
name|warning
argument_list|(
literal|"instruction scheduling not supported on this target machine"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|DELAY_SLOTS
if|if
condition|(
name|flag_delayed_branch
condition|)
name|warning
argument_list|(
literal|"this target machine does not have delayed branches"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|user_label_prefix
operator|=
name|USER_LABEL_PREFIX
expr_stmt|;
if|if
condition|(
name|flag_leading_underscore
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* If the default prefix is more complicated than "" or "_", 	 issue a warning and ignore this option.  */
if|if
condition|(
name|user_label_prefix
index|[
literal|0
index|]
operator|==
literal|0
operator|||
operator|(
name|user_label_prefix
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|user_label_prefix
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|user_label_prefix
operator|=
name|flag_leading_underscore
condition|?
literal|"_"
else|:
literal|""
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"-f%sleading-underscore not supported on this target machine"
argument_list|,
name|flag_leading_underscore
condition|?
literal|""
else|:
literal|"no-"
argument_list|)
expr_stmt|;
block|}
comment|/* If we are in verbose mode, write out the version and maybe all the      option flags in use.  */
if|if
condition|(
name|version_flag
condition|)
block|{
name|print_version
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|print_switch_values
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|,
name|MAX_LINE
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_syntax_only
condition|)
block|{
name|write_symbols
operator|=
name|NO_DEBUG
expr_stmt|;
name|profile_flag
operator|=
literal|0
expr_stmt|;
block|}
comment|/* A lot of code assumes write_symbols == NO_DEBUG if the debugging      level is 0.  */
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NONE
condition|)
name|write_symbols
operator|=
name|NO_DEBUG
expr_stmt|;
comment|/* Now we know write_symbols, set up the debug hooks based on it.      By default we do nothing for debug output.  */
if|if
condition|(
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|do_nothing_debug_hooks
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|dbx_debug_hooks
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|xcoff_debug_hooks
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|sdb_debug_hooks
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|dwarf2_debug_hooks
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|VMS_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|vmsdbg_debug_hooks
expr_stmt|;
endif|#
directive|endif
else|else
name|error
argument_list|(
literal|"target system does not support the \"%s\" debug format"
argument_list|,
name|debug_type_names
index|[
name|write_symbols
index|]
argument_list|)
expr_stmt|;
comment|/* If auxiliary info generation is desired, open the output file.      This goes in the same directory as the source file--unlike      all the other output files.  */
if|if
condition|(
name|flag_gen_aux_info
condition|)
block|{
name|aux_info_file
operator|=
name|fopen
argument_list|(
name|aux_info_file_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux_info_file
operator|==
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"can't open %s: %m"
argument_list|,
name|aux_info_file_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|targetm
operator|.
name|have_named_sections
condition|)
block|{
if|if
condition|(
name|flag_function_sections
condition|)
block|{
name|warning
argument_list|(
literal|"-ffunction-sections not supported for this target"
argument_list|)
expr_stmt|;
name|flag_function_sections
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag_data_sections
condition|)
block|{
name|warning
argument_list|(
literal|"-fdata-sections not supported for this target"
argument_list|)
expr_stmt|;
name|flag_data_sections
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_function_sections
operator|&&
name|profile_flag
condition|)
block|{
name|warning
argument_list|(
literal|"-ffunction-sections disabled; it makes profiling impossible"
argument_list|)
expr_stmt|;
name|flag_function_sections
operator|=
literal|0
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|HAVE_prefetch
if|if
condition|(
name|flag_prefetch_loop_arrays
condition|)
block|{
name|warning
argument_list|(
literal|"-fprefetch-loop-arrays not supported for this target"
argument_list|)
expr_stmt|;
name|flag_prefetch_loop_arrays
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|flag_prefetch_loop_arrays
operator|&&
operator|!
name|HAVE_prefetch
condition|)
block|{
name|warning
argument_list|(
literal|"-fprefetch-loop-arrays not supported for this target (try -march switches)"
argument_list|)
expr_stmt|;
name|flag_prefetch_loop_arrays
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* This combination of options isn't handled for i386 targets and doesn't      make much sense anyway, so don't allow it.  */
if|if
condition|(
name|flag_prefetch_loop_arrays
operator|&&
name|optimize_size
condition|)
block|{
name|warning
argument_list|(
literal|"-fprefetch-loop-arrays is not supported with -Os"
argument_list|)
expr_stmt|;
name|flag_prefetch_loop_arrays
operator|=
literal|0
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OBJECT_FORMAT_ELF
if|if
condition|(
name|flag_function_sections
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|warning
argument_list|(
literal|"-ffunction-sections may affect debugging on some targets"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The presence of IEEE signaling NaNs, implies all math can trap.  */
if|if
condition|(
name|flag_signaling_nans
condition|)
name|flag_trapping_math
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the compiler back end.  */
end_comment

begin_function
specifier|static
name|void
name|backend_init
parameter_list|(
name|void
parameter_list|)
block|{
name|init_emit_once
argument_list|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NORMAL
operator|||
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
ifdef|#
directive|ifdef
name|VMS_DEBUGGING_INFO
comment|/* Enable line number info for traceback.  */
operator|||
name|debug_info_level
operator|>
name|DINFO_LEVEL_NONE
endif|#
directive|endif
operator|||
name|flag_test_coverage
operator|||
name|warn_notreached
argument_list|)
expr_stmt|;
name|init_regs
argument_list|()
expr_stmt|;
name|init_fake_stack_mems
argument_list|()
expr_stmt|;
name|init_alias_once
argument_list|()
expr_stmt|;
name|init_loop
argument_list|()
expr_stmt|;
name|init_reload
argument_list|()
expr_stmt|;
name|init_function_once
argument_list|()
expr_stmt|;
name|init_varasm_once
argument_list|()
expr_stmt|;
comment|/* The following initialization functions need to generate rtl, so      provide a dummy function context for them.  */
name|init_dummy_function_start
argument_list|()
expr_stmt|;
name|init_expmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_caller_saves
condition|)
name|init_caller_save
argument_list|()
expr_stmt|;
name|expand_dummy_function_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Language-dependent initialization.  Returns nonzero on success.  */
end_comment

begin_function
specifier|static
name|int
name|lang_dependent_init
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|dump_base_name
operator|==
literal|0
condition|)
name|dump_base_name
operator|=
name|name
condition|?
name|name
else|:
literal|"gccdump"
expr_stmt|;
comment|/* Other front-end initialization.  */
if|if
condition|(
call|(
modifier|*
name|lang_hooks
operator|.
name|init
call|)
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|init_asm_output
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* These create various _DECL nodes, so need to be called after the      front end is initialized.  */
name|init_eh
argument_list|()
expr_stmt|;
name|init_optabs
argument_list|()
expr_stmt|;
comment|/* The following initialization functions need to generate rtl, so      provide a dummy function context for them.  */
name|init_dummy_function_start
argument_list|()
expr_stmt|;
name|init_expr_once
argument_list|()
expr_stmt|;
name|expand_dummy_function_end
argument_list|()
expr_stmt|;
comment|/* If dbx symbol table desired, initialize writing it and output the      predefined types.  */
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Now we have the correct original filename, we can initialize      debug output.  */
call|(
modifier|*
name|debug_hooks
operator|->
name|init
call|)
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Clean up: close opened files, etc.  */
end_comment

begin_function
specifier|static
name|void
name|finalize
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Close the dump files.  */
if|if
condition|(
name|flag_gen_aux_info
condition|)
block|{
name|fclose
argument_list|(
name|aux_info_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorcount
condition|)
name|unlink
argument_list|(
name|aux_info_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* Close non-debugging input and output files.  Take special care to note      whether fclose returns an error, since the pages might still be on the      buffer chain while the file is open.  */
if|if
condition|(
name|asm_out_file
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|asm_out_file
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"error writing to %s: %m"
argument_list|,
name|asm_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|asm_out_file
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"error closing %s: %m"
argument_list|,
name|asm_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* Do whatever is necessary to finish printing the graphs.  */
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|DFI_MAX
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|dump_file
index|[
name|i
index|]
operator|.
name|initialized
operator|&&
name|dump_file
index|[
name|i
index|]
operator|.
name|graph_dump_p
condition|)
block|{
name|char
name|seq
index|[
literal|16
index|]
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
name|sprintf
argument_list|(
name|seq
argument_list|,
name|DUMPFILE_FORMAT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|concat
argument_list|(
name|seq
argument_list|,
name|dump_file
index|[
name|i
index|]
operator|.
name|extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mem_report
condition|)
block|{
name|ggc_print_statistics
argument_list|()
expr_stmt|;
name|stringpool_statistics
argument_list|()
expr_stmt|;
name|dump_tree_statistics
argument_list|()
expr_stmt|;
name|dump_rtx_statistics
argument_list|()
expr_stmt|;
name|dump_varray_statistics
argument_list|()
expr_stmt|;
name|dump_alloc_pool_statistics
argument_list|()
expr_stmt|;
block|}
comment|/* Free up memory for the benefit of leak detectors.  */
name|free_reg_info
argument_list|()
expr_stmt|;
comment|/* Language-specific end of compilation actions.  */
call|(
modifier|*
name|lang_hooks
operator|.
name|finish
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the compiler, and compile the input file.  */
end_comment

begin_function
specifier|static
name|void
name|do_compile
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize timing first.  The C front ends read the main file in      the post_options hook, and C++ does file timings.  */
if|if
condition|(
name|time_report
operator|||
operator|!
name|quiet_flag
operator|||
name|flag_detailed_statistics
condition|)
name|timevar_init
argument_list|()
expr_stmt|;
name|timevar_start
argument_list|(
name|TV_TOTAL
argument_list|)
expr_stmt|;
name|process_options
argument_list|()
expr_stmt|;
comment|/* Don't do any more if an error has already occurred.  */
if|if
condition|(
operator|!
name|errorcount
condition|)
block|{
comment|/* This must be run always, because it is needed to compute the FP 	 predefined macros, such as __LDBL_MAX__, for targets using non 	 default FP formats.  */
name|init_adjust_machine_modes
argument_list|()
expr_stmt|;
comment|/* Set up the back-end if requested.  */
if|if
condition|(
operator|!
name|no_backend
condition|)
name|backend_init
argument_list|()
expr_stmt|;
comment|/* Language-dependent initialization.  Returns true on success.  */
if|if
condition|(
name|lang_dependent_init
argument_list|(
name|main_input_filename
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_unit_at_a_time
condition|)
block|{
name|open_dump_file
argument_list|(
name|DFI_cgraph
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cgraph_dump_file
operator|=
name|rtl_dump_file
expr_stmt|;
name|rtl_dump_file
operator|=
name|NULL
expr_stmt|;
block|}
name|compile_file
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_unit_at_a_time
condition|)
block|{
name|rtl_dump_file
operator|=
name|cgraph_dump_file
expr_stmt|;
name|cgraph_dump_file
operator|=
name|NULL
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_cgraph
argument_list|,
name|NULL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
block|}
name|finalize
argument_list|()
expr_stmt|;
block|}
comment|/* Stop timing and print the times.  */
name|timevar_stop
argument_list|(
name|TV_TOTAL
argument_list|)
expr_stmt|;
name|timevar_print
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Entry point of cc1, cc1plus, jc1, f771, etc.    Exit code is FATAL_EXIT_CODE if can't open files or if there were    any errors, or SUCCESS_EXIT_CODE if compilation succeeded.     It is not safe to call this function more than once.  */
end_comment

begin_function
name|int
name|toplev_main
parameter_list|(
name|unsigned
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|save_argv
operator|=
name|argv
expr_stmt|;
comment|/* Initialization of GCC's environment, and diagnostics.  */
name|general_init
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Parse the options and do minimal processing; basically just      enough to default flags appropriately.  */
name|decode_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|randomize
argument_list|()
expr_stmt|;
comment|/* Exit early if we can (e.g. -help).  */
if|if
condition|(
operator|!
name|exit_after_options
condition|)
name|do_compile
argument_list|()
expr_stmt|;
if|if
condition|(
name|errorcount
operator|||
name|sorrycount
condition|)
return|return
operator|(
name|FATAL_EXIT_CODE
operator|)
return|;
return|return
operator|(
name|SUCCESS_EXIT_CODE
operator|)
return|;
block|}
end_function

end_unit

