begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Top level of GNU C compiler    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* This is the top level of cc1/c++.    It parses command args, opens files, invokes the various passes    in the proper order, and counts the time used by each.    Error messages and low-level interface to malloc also handled here.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_undef
undef|#
directive|undef
name|FLOAT
end_undef

begin_comment
comment|/* This is for hpux. They should change hpux.  */
end_comment

begin_undef
undef|#
directive|undef
name|FFS
end_undef

begin_comment
comment|/* Some systems define this in param.h.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_RESOURCE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIMES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"graph.h"
end_include

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"ssa.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2asm.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
end_if

begin_include
include|#
directive|include
file|"dwarf2out.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
end_if

begin_include
include|#
directive|include
file|"dbxout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"sdbout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_comment
comment|/* Needed for external data 				   declarations for e.g. AIX 4.x.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HALF_PIC_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|"halfpic.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Carry information from ASM_DECLARE_OBJECT_NAME    to ASM_FINISH_DECLARE_OBJECT.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|size_directive_output
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|last_assemble_variable_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|general_init
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_options_and_default_flags
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_compile
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_options
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_independent_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lang_dependent_init
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_asm_output
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finalize
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_target_switch
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|decl_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|float_signal
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|crash_signal
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_float_handler
name|PARAMS
argument_list|(
operator|(
name|jmp_buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compile_file
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_help
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_target_options
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decode_d_option
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|decode_f_option
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|decode_W_option
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|decode_g_option
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|independent_decode_option
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_version
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_single_switch
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_switch_values
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of line when printing switch values.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LINE
value|75
end_define

begin_comment
comment|/* Name of program invoked, sans directories.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy of arguments to toplev_main.  */
end_comment

begin_decl_stmt
name|int
name|save_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|save_argv
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Name of current original source file (what was input to cpp).    This comes from each #-command in the actual input.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of top-level original source file (what was input to cpp).    This comes from the #-command at the beginning of the actual input.    If there isn't any there, then this is the cc1 input file name.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|main_input_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current line number in real source file.  */
end_comment

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if it is unsafe to create any new pseudo registers.  */
end_comment

begin_decl_stmt
name|int
name|no_new_pseudos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of currently pending input files.  */
end_comment

begin_decl_stmt
name|struct
name|file_stack
modifier|*
name|input_file_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incremented on each change to input_file_stack.  */
end_comment

begin_decl_stmt
name|int
name|input_file_stack_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name to use as base of names for dump output files.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|dump_base_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Format to use to print dumpfile index value */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DUMPFILE_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|DUMPFILE_FORMAT
value|".%02d."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Bit flags that specify the machine subtype we are compiling for.    Bits are tested using macros TARGET_... defined in the tm.h file    and set by `-m...' switches.  Must be defined in rtlanal.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|target_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debug hooks - dependent upon command line options.  */
end_comment

begin_decl_stmt
name|struct
name|gcc_debug_hooks
modifier|*
name|debug_hooks
init|=
operator|&
name|do_nothing_debug_hooks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describes a dump file.  */
end_comment

begin_struct
struct|struct
name|dump_file_info
block|{
comment|/* The unique extension to apply, e.g. ".jump".  */
specifier|const
name|char
modifier|*
specifier|const
name|extension
decl_stmt|;
comment|/* The -d<c> character that enables this dump file.  */
name|char
specifier|const
name|debug_switch
decl_stmt|;
comment|/* True if there is a corresponding graph dump file.  */
name|char
specifier|const
name|graph_dump_p
decl_stmt|;
comment|/* True if the user selected this dump.  */
name|char
name|enabled
decl_stmt|;
comment|/* True if the files have been initialized (ie truncated).  */
name|char
name|initialized
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Enumerate the extant dump files.  */
end_comment

begin_enum
enum|enum
name|dump_file_index
block|{
name|DFI_rtl
block|,
name|DFI_sibling
block|,
name|DFI_eh
block|,
name|DFI_jump
block|,
name|DFI_ssa
block|,
name|DFI_ssa_ccp
block|,
name|DFI_ssa_dce
block|,
name|DFI_ussa
block|,
name|DFI_cse
block|,
name|DFI_addressof
block|,
name|DFI_gcse
block|,
name|DFI_loop
block|,
name|DFI_cse2
block|,
name|DFI_cfg
block|,
name|DFI_bp
block|,
name|DFI_life
block|,
name|DFI_combine
block|,
name|DFI_ce
block|,
name|DFI_regmove
block|,
name|DFI_sched
block|,
name|DFI_lreg
block|,
name|DFI_greg
block|,
name|DFI_postreload
block|,
name|DFI_flow2
block|,
name|DFI_peephole2
block|,
name|DFI_rnreg
block|,
name|DFI_ce2
block|,
name|DFI_sched2
block|,
name|DFI_stack
block|,
name|DFI_bbro
block|,
name|DFI_mach
block|,
name|DFI_dbr
block|,
name|DFI_MAX
block|}
enum|;
end_enum

begin_comment
comment|/* Describes all the dump files.  Should be kept in order of the    pass and in sync with dump_file_index above.     Remaining -d letters:  	"              o q   u     " 	"       H JK   OPQ  TUV  YZ" */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dump_file_info
name|dump_file
index|[
name|DFI_MAX
index|]
init|=
block|{
block|{
literal|"rtl"
block|,
literal|'r'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sibling"
block|,
literal|'i'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"eh"
block|,
literal|'h'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"jump"
block|,
literal|'j'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ssa"
block|,
literal|'e'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ssaccp"
block|,
literal|'W'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ssadce"
block|,
literal|'X'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ussa"
block|,
literal|'e'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Yes, duplicate enable switch.  */
block|{
literal|"cse"
block|,
literal|'s'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"addressof"
block|,
literal|'F'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"gcse"
block|,
literal|'G'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"loop"
block|,
literal|'L'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"cse2"
block|,
literal|'t'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"cfg"
block|,
literal|'f'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"bp"
block|,
literal|'b'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"life"
block|,
literal|'f'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Yes, duplicate enable switch.  */
block|{
literal|"combine"
block|,
literal|'c'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ce"
block|,
literal|'C'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"regmove"
block|,
literal|'N'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sched"
block|,
literal|'S'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"lreg"
block|,
literal|'l'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"greg"
block|,
literal|'g'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"postreload"
block|,
literal|'o'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"flow2"
block|,
literal|'w'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"peephole2"
block|,
literal|'z'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"rnreg"
block|,
literal|'n'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ce2"
block|,
literal|'E'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sched2"
block|,
literal|'R'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"stack"
block|,
literal|'k'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"bbro"
block|,
literal|'B'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"mach"
block|,
literal|'M'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"dbr"
block|,
literal|'d'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|open_dump_file
name|PARAMS
argument_list|(
operator|(
expr|enum
name|dump_file_index
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|close_dump_file
name|PARAMS
argument_list|(
operator|(
expr|enum
name|dump_file_index
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|FILE
operator|*
argument_list|,
name|rtx
argument_list|)
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Other flags saying which kinds of debugging dump have been requested.  */
end_comment

begin_decl_stmt
name|int
name|rtl_dump_and_exit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_print_asm_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|version_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|graph_dump_types
name|graph_dump_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name for output file of assembly code, specified with -o.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|asm_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of the -G xx switch, and whether it was passed or not.  */
end_comment

begin_decl_stmt
name|int
name|g_switch_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|g_switch_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type(s) of debugging information we are producing (if any).    See flags.h for the definitions of the different possible    types of debugging information.  */
end_comment

begin_decl_stmt
name|enum
name|debug_info_type
name|write_symbols
init|=
name|NO_DEBUG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Level of debugging information we are producing.  See flags.h    for the definitions of the different possible levels.  */
end_comment

begin_decl_stmt
name|enum
name|debug_info_level
name|debug_info_level
init|=
name|DINFO_LEVEL_NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means use GNU-only extensions in the generated symbolic    debugging information.  */
end_comment

begin_comment
comment|/* Currently, this only has an effect when write_symbols is set to    DBX_DEBUG, XCOFF_DEBUG, or DWARF_DEBUG.  */
end_comment

begin_decl_stmt
name|int
name|use_gnu_debug_info_extensions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do optimizations.  -O.    Particular numeric values stand for particular amounts of optimization;    thus, -O2 stores 2 here.  However, the optimizations beyond the basic    ones are not controlled directly by this variable.  Instead, they are    controlled by individual `flag_...' variables that are defaulted    based on this variable.  */
end_comment

begin_decl_stmt
name|int
name|optimize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means optimize for size.  -Os.    The only valid values are zero and non-zero. When optimize_size is    non-zero, optimize defaults to 2, but certain individual code    bloating optimizations are disabled.  */
end_comment

begin_decl_stmt
name|int
name|optimize_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should exit after parsing options.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exit_after_options
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The FUNCTION_DECL for the function currently being compiled,    or 0 if between functions.  */
end_comment

begin_decl_stmt
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to the FUNC_BEGIN label of the current function, or NULL_TREE    if none.  */
end_comment

begin_decl_stmt
name|tree
name|current_function_func_begin_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to function to compute the name to use to print a declaration.    DECL is the declaration in question.    VERBOSITY determines what information will be printed:      0: DECL_NAME, demangled as necessary.      1: and scope information.      2: and any other information that might be interesting, such as function         parameter types in C++.  */
end_comment

begin_expr_stmt
specifier|const
name|char
operator|*
operator|(
operator|*
name|decl_printable_name
operator|)
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Pointer to function to compute rtl for a language-specific tree code.  */
end_comment

begin_typedef
typedef|typedef
name|rtx
argument_list|(
argument|*lang_expand_expr_t
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|union
name|tree_node
operator|*
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|expand_modifier
name|modifier
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_decl_stmt
name|lang_expand_expr_t
name|lang_expand_expr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to function to finish handling an incomplete decl at the    end of compilation.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*incomplete_decl_finalize_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Nonzero if doing dwarf2 duplicate elimination.  */
end_comment

begin_decl_stmt
name|int
name|flag_eliminate_dwarf2_dups
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if generating code to do profiling.  */
end_comment

begin_decl_stmt
name|int
name|profile_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if generating code to profile program flow graph arcs.  */
end_comment

begin_decl_stmt
name|int
name|profile_arc_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if generating info for gcov to calculate line test coverage.  */
end_comment

begin_decl_stmt
name|int
name|flag_test_coverage
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero indicates that branch taken probabilities should be calculated.  */
end_comment

begin_decl_stmt
name|int
name|flag_branch_probabilities
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if basic blocks should be reordered.  */
end_comment

begin_decl_stmt
name|int
name|flag_reorder_blocks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if registers should be renamed.  */
end_comment

begin_decl_stmt
name|int
name|flag_rename_registers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_cprop_registers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -pedantic switch: warn about anything    that standard spec forbids.  */
end_comment

begin_decl_stmt
name|int
name|pedantic
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporarily suppress certain warnings.    This is set while reading code from a system header file.  */
end_comment

begin_decl_stmt
name|int
name|in_system_header
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't print functions as they are compiled.  -quiet.  */
end_comment

begin_decl_stmt
name|int
name|quiet_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print times taken by the various passes.  -ftime-report.  */
end_comment

begin_decl_stmt
name|int
name|time_report
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print memory still in use at end of compilation (which may have little    to do with peak memory consumption).  -fmem-report.  */
end_comment

begin_decl_stmt
name|int
name|mem_report
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to collect statistics which might be expensive    and to print them when we are done.  */
end_comment

begin_decl_stmt
name|int
name|flag_detailed_statistics
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* -f flags.  */
end_comment

begin_comment
comment|/* Nonzero means `char' should be signed.  */
end_comment

begin_decl_stmt
name|int
name|flag_signed_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give an enum type only as many bytes as it needs.  */
end_comment

begin_decl_stmt
name|int
name|flag_short_enums
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fcaller-saves: allocate values in regs that need to    be saved across function calls, if that produces overall better code.    Optional now, so people can test it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_CALLER_SAVES
end_ifdef

begin_decl_stmt
name|int
name|flag_caller_saves
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|flag_caller_saves
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero if structures and unions should be returned in memory.     This should only be defined if compatibility with another compiler or    with an ABI is needed, because it results in slower code.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_PCC_STRUCT_RETURN
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_PCC_STRUCT_RETURN
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero for -fpcc-struct-return: return values the same way PCC does.  */
end_comment

begin_decl_stmt
name|int
name|flag_pcc_struct_return
init|=
name|DEFAULT_PCC_STRUCT_RETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fforce-mem: load memory value into a register    before arithmetic on it.  This makes better cse but slower compilation.  */
end_comment

begin_decl_stmt
name|int
name|flag_force_mem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fforce-addr: load memory address into a register before    reference to memory.  This makes better cse but slower compilation.  */
end_comment

begin_decl_stmt
name|int
name|flag_force_addr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fdefer-pop: don't pop args after each function call;    instead save them up to pop many calls' args with one insns.  */
end_comment

begin_decl_stmt
name|int
name|flag_defer_pop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -ffloat-store: don't allocate floats and doubles    in extended-precision registers.  */
end_comment

begin_decl_stmt
name|int
name|flag_float_store
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fcse-follow-jumps:    have cse follow jumps to do a more extensive job.  */
end_comment

begin_decl_stmt
name|int
name|flag_cse_follow_jumps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fcse-skip-blocks:    have cse follow a branch around a block.  */
end_comment

begin_decl_stmt
name|int
name|flag_cse_skip_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fexpensive-optimizations:    perform miscellaneous relatively-expensive optimizations.  */
end_comment

begin_decl_stmt
name|int
name|flag_expensive_optimizations
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fthread-jumps:    have jump optimize output of loop.  */
end_comment

begin_decl_stmt
name|int
name|flag_thread_jumps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables strength-reduction in loop.c.  */
end_comment

begin_decl_stmt
name|int
name|flag_strength_reduce
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables loop unrolling in unroll.c.  Only loops for which the    number of iterations can be calculated at compile-time (UNROLL_COMPLETELY,    UNROLL_MODULO) or at run-time (preconditioned to be UNROLL_MODULO) are    unrolled.  */
end_comment

begin_decl_stmt
name|int
name|flag_unroll_loops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables loop unrolling in unroll.c.  All loops are unrolled.    This is generally not a win.  */
end_comment

begin_decl_stmt
name|int
name|flag_unroll_all_loops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables prefetch optimizations for arrays in loops.  */
end_comment

begin_decl_stmt
name|int
name|flag_prefetch_loop_arrays
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero forces all invariant computations in loops to be moved    outside the loop.  */
end_comment

begin_decl_stmt
name|int
name|flag_move_all_movables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero forces all general induction variables in loops to be    strength reduced.  */
end_comment

begin_decl_stmt
name|int
name|flag_reduce_all_givs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to perform full register move optimization passes.  This is the    default for -O2.  */
end_comment

begin_decl_stmt
name|int
name|flag_regmove
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fwritable-strings:    store string constants in data segment and don't uniquize them.  */
end_comment

begin_decl_stmt
name|int
name|flag_writable_strings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't put addresses of constant functions in registers.    Used for compiling the Unix kernel, where strange substitutions are    done on the assembly output.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_function_cse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fomit-frame-pointer:    don't make a frame pointer in simple functions that don't require one.  */
end_comment

begin_decl_stmt
name|int
name|flag_omit_frame_pointer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means place each function into its own section on those platforms    which support arbitrary section names and unlimited numbers of sections.  */
end_comment

begin_decl_stmt
name|int
name|flag_function_sections
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ... and similar for data.  */
end_comment

begin_decl_stmt
name|int
name|flag_data_sections
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to inhibit use of define_optimization peephole opts.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_peephole
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero allows GCC to optimize sibling and tail recursive calls.  */
end_comment

begin_decl_stmt
name|int
name|flag_optimize_sibling_calls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means the front end generally wants `errno' maintained by math    operations, like built-in SQRT.  */
end_comment

begin_decl_stmt
name|int
name|flag_errno_math
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that unsafe floating-point math optimizations are allowed    for the sake of speed.  IEEE compliance is not guaranteed, and operations    are allowed to assume that their arguments and results are "normal"    (e.g., nonnegative for SQRT).  */
end_comment

begin_decl_stmt
name|int
name|flag_unsafe_math_optimizations
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero means that floating-point math operations cannot generate a    (user-visible) trap.  This is the case, for example, in nonstop    IEEE 754 arithmetic.  */
end_comment

begin_decl_stmt
name|int
name|flag_trapping_math
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 means straightforward implementation of complex divide acceptable.    1 means wide ranges of inputs must work for complex divide.    2 means C99-like requirements for complex divide (not yet implemented).  */
end_comment

begin_decl_stmt
name|int
name|flag_complex_divide_method
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means all references through pointers are volatile.  */
end_comment

begin_decl_stmt
name|int
name|flag_volatile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means treat all global and extern variables as volatile.  */
end_comment

begin_decl_stmt
name|int
name|flag_volatile_global
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means treat all static variables as volatile.  */
end_comment

begin_decl_stmt
name|int
name|flag_volatile_static
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means just do syntax checking; don't output anything.  */
end_comment

begin_decl_stmt
name|int
name|flag_syntax_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means perform global cse.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_gcse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to use global dataflow analysis to eliminate    useless null pointer tests.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_delete_null_pointer_checks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to do the enhanced load motion during gcse, which trys    to hoist loads by not killing them when a store to the same location    is seen.  */
end_comment

begin_decl_stmt
name|int
name|flag_gcse_lm
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to perform store motion after gcse, which will try to    move stores closer to the exit block.  Its not very effective without    flag_gcse_lm.  */
end_comment

begin_decl_stmt
name|int
name|flag_gcse_sm
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to rerun cse after loop optimization.  This increases    compilation time about 20% and picks up a few more common expressions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_rerun_cse_after_loop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to run loop optimizations twice.  */
end_comment

begin_decl_stmt
name|int
name|flag_rerun_loop_opt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -finline-functions: ok to inline functions that look like    good inline candidates.  */
end_comment

begin_decl_stmt
name|int
name|flag_inline_functions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fkeep-inline-functions: even if we make a function    go inline everywhere, keep its definition around for debugging    purposes.  */
end_comment

begin_decl_stmt
name|int
name|flag_keep_inline_functions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that functions will not be inlined.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_inline
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that we don't want inlining by virtue of -fno-inline,    not just because the tree inliner turned us off.  */
end_comment

begin_decl_stmt
name|int
name|flag_really_no_inline
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that we should emit static const variables    regardless of whether or not optimization is turned on.  */
end_comment

begin_decl_stmt
name|int
name|flag_keep_static_consts
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we should be saving declaration info into a .X file.  */
end_comment

begin_decl_stmt
name|int
name|flag_gen_aux_info
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specified name of aux-info file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|aux_info_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means make the text shared if supported.  */
end_comment

begin_decl_stmt
name|int
name|flag_shared_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means schedule into delayed branch slots if supported.  */
end_comment

begin_decl_stmt
name|int
name|flag_delayed_branch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are compiling pure (sharable) code.    Value is 1 if we are doing reasonable (i.e. simple    offset into offset table) pic.  Value is 2 if we can    only perform register offsets.  */
end_comment

begin_decl_stmt
name|int
name|flag_pic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means generate extra code for exception handling and enable    exception handling.  */
end_comment

begin_decl_stmt
name|int
name|flag_exceptions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means generate frame unwind info table when supported.  */
end_comment

begin_decl_stmt
name|int
name|flag_unwind_tables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means generate frame unwind info table exact at each insn boundary */
end_comment

begin_decl_stmt
name|int
name|flag_asynchronous_unwind_tables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't place uninitialized global data in common storage    by default.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_common
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means pretend it is OK to examine bits of target floats,    even if that isn't true.  The resulting code will have incorrect constants,    but the same series of instructions that the native compiler would make.  */
end_comment

begin_decl_stmt
name|int
name|flag_pretend_float
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means change certain warnings into errors.    Usually these are warnings about failure to conform to some standard.  */
end_comment

begin_decl_stmt
name|int
name|flag_pedantic_errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag_schedule_insns means schedule insns within basic blocks (before    local_alloc).    flag_schedule_insns_after_reload means schedule insns after    global_alloc.  */
end_comment

begin_decl_stmt
name|int
name|flag_schedule_insns
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_schedule_insns_after_reload
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following flags have effect only for scheduling before register    allocation:     flag_schedule_interblock means schedule insns accross basic blocks.    flag_schedule_speculative means allow speculative motion of non-load insns.    flag_schedule_speculative_load means allow speculative motion of some    load insns.    flag_schedule_speculative_load_dangerous allows speculative motion of more    load insns.  */
end_comment

begin_decl_stmt
name|int
name|flag_schedule_interblock
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_schedule_speculative
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_schedule_speculative_load
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_schedule_speculative_load_dangerous
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_single_precision_constant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag_branch_on_count_reg means try to replace add-1,compare,branch tupple    by a cheaper branch on a count register.  */
end_comment

begin_decl_stmt
name|int
name|flag_branch_on_count_reg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -finhibit-size-directive inhibits output of .size for ELF.    This is used only for compiling crtstuff.c,    and it may be extended to other effects    needed for crtstuff.c on other systems.  */
end_comment

begin_decl_stmt
name|int
name|flag_inhibit_size_directive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -fverbose-asm causes extra commentary information to be produced in    the generated assembly code (to make it more readable).  This option    is generally only of use to those who actually need to read the    generated assembly code (perhaps while debugging the compiler itself).    -fno-verbose-asm, the default, causes the extra information    to be omitted and is useful when comparing two assembler files.  */
end_comment

begin_decl_stmt
name|int
name|flag_verbose_asm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -dA causes debug commentary information to be produced in    the generated assembly code (to make it more readable).  This option    is generally only of use to those who actually need to read the    generated assembly code (perhaps while debugging the compiler itself).    Currently, this switch is only used by dwarfout.c; however, it is intended    to be a catchall for printing debug information in the assembler file.  */
end_comment

begin_decl_stmt
name|int
name|flag_debug_asm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -dP causes the rtl to be emitted as a comment in assembly.  */
end_comment

begin_decl_stmt
name|int
name|flag_dump_rtl_in_asm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -fgnu-linker specifies use of the GNU linker for initializations.    (Or, more generally, a linker that handles initializations.)    -fno-gnu-linker says that collect2 will be used.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_COLLECT2
end_ifdef

begin_decl_stmt
name|int
name|flag_gnu_linker
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|flag_gnu_linker
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Enable SSA.  */
end_comment

begin_decl_stmt
name|int
name|flag_ssa
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enable ssa conditional constant propagation.  */
end_comment

begin_decl_stmt
name|int
name|flag_ssa_ccp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enable ssa aggressive dead code elimination.  */
end_comment

begin_decl_stmt
name|int
name|flag_ssa_dce
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tag all structures with __attribute__(packed).  */
end_comment

begin_decl_stmt
name|int
name|flag_pack_struct
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that -Wformat accepts certain system-dependent formats.  */
end_comment

begin_decl_stmt
name|int
name|flag_format_extensions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Emit code to check for stack overflow; also may cause large objects    to be allocated dynamically.  */
end_comment

begin_decl_stmt
name|int
name|flag_stack_check
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When non-NULL, indicates that whenever space is allocated on the    stack, the resulting stack pointer must not pass this    address---that is, for stacks that grow downward, the stack pointer    must always be greater than or equal to this address; for stacks    that grow upward, the stack pointer must be less than this address.    At present, the rtx may be either a REG or a SYMBOL_REF, although    the support provided depends on the backend.  */
end_comment

begin_decl_stmt
name|rtx
name|stack_limit_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 if pointer arguments may alias each other.  True in C.    1 if pointer arguments may not alias each other but may alias    global variables.    2 if pointer arguments may not alias each other and may not    alias global variables.  True in Fortran.    This defaults to 0 for C.  */
end_comment

begin_decl_stmt
name|int
name|flag_argument_noalias
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should do (language-dependent) alias analysis.    Typically, this analysis will assume that expressions of certain    types do not alias expressions of certain other types.  Only used    if alias analysis (in general) is enabled.  */
end_comment

begin_decl_stmt
name|int
name|flag_strict_aliasing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instrument functions with calls at entry and exit, for profiling.  */
end_comment

begin_decl_stmt
name|int
name|flag_instrument_function_entry_exit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means ignore `#ident' directives.  0 means handle them.    On SVR4 targets, it also controls whether or not to emit a    string identifying the compiler.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_ident
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This will perform a peephole pass before sched2.  */
end_comment

begin_decl_stmt
name|int
name|flag_peephole2
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This will try to guess branch probabilities.  */
end_comment

begin_decl_stmt
name|int
name|flag_guess_branch_prob
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -fbounded-pointers causes gcc to compile pointers as composite    objects occupying three words: the pointer value, the base address    of the referent object, and the address immediately beyond the end    of the referent object.  The base and extent allow us to perform    runtime bounds checking.  -fbounded-pointers implies -fcheck-bounds.  */
end_comment

begin_decl_stmt
name|int
name|flag_bounded_pointers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -fcheck-bounds causes gcc to generate array bounds checks.    For C, C++: defaults to value of flag_bounded_pointers.    For ObjC: defaults to off.    For Java: defaults to on.    For Fortran: defaults to off.    For CHILL: defaults to off.  */
end_comment

begin_decl_stmt
name|int
name|flag_bounds_check
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This will attempt to merge constant section constants, if 1 only    string constants and constants from constant pool, if 2 also constant    variables.  */
end_comment

begin_decl_stmt
name|int
name|flag_merge_constants
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If one, renumber instruction UIDs to reduce the number of    unused UIDs if there are a lot of instructions.  If greater than    one, unconditionally renumber instruction UIDs.  */
end_comment

begin_decl_stmt
name|int
name|flag_renumber_insns
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Values of the -falign-* flags: how much to align labels in code.    0 means `use default', 1 means `don't align'.    For each variable, there is an _log variant which is the power    of two not less than the variable, for .align output.  */
end_comment

begin_decl_stmt
name|int
name|align_loops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_loops_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_loops_max_skip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_jumps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_jumps_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_jumps_max_skip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_labels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_labels_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_labels_max_skip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_functions
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_functions_log
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Like align_functions_log above, but used by front-ends to force the    minimum function alignment.  Zero means no alignment is forced.  */
end_comment

begin_decl_stmt
name|int
name|force_align_functions_log
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of supported debugging formats.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|arg
decl_stmt|;
comment|/* Since PREFERRED_DEBUGGING_TYPE isn't necessarily a      constant expression, we use NO_DEBUG in its place.  */
specifier|const
name|enum
name|debug_info_type
name|debug_type
decl_stmt|;
specifier|const
name|int
name|use_extensions_p
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|description
decl_stmt|;
block|}
modifier|*
name|da
struct|,
name|debug_args
index|[]
init|=
block|{
block|{
literal|""
block|,
name|NO_DEBUG
block|,
name|DEFAULT_GDB_EXTENSIONS
block|,
name|N_
argument_list|(
literal|"Generate debugging info in default format"
argument_list|)
block|}
block|,
block|{
literal|"gdb"
block|,
name|NO_DEBUG
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Generate debugging info in default extended format"
argument_list|)
block|}
block|,
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
block|{
literal|"stabs"
block|,
name|DBX_DEBUG
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Generate STABS format debug info"
argument_list|)
block|}
block|,
block|{
literal|"stabs+"
block|,
name|DBX_DEBUG
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Generate extended STABS format debug info"
argument_list|)
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
block|{
literal|"dwarf"
block|,
name|DWARF_DEBUG
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Generate DWARF-1 format debug info"
argument_list|)
block|}
block|,
block|{
literal|"dwarf+"
block|,
name|DWARF_DEBUG
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Generate extended DWARF-1 format debug info"
argument_list|)
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
block|{
literal|"dwarf-2"
block|,
name|DWARF2_DEBUG
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Generate DWARF-2 debug info"
argument_list|)
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
block|{
literal|"xcoff"
block|,
name|XCOFF_DEBUG
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Generate XCOFF format debug info"
argument_list|)
block|}
block|,
block|{
literal|"xcoff+"
block|,
name|XCOFF_DEBUG
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Generate extended XCOFF format debug info"
argument_list|)
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
block|{
literal|"coff"
block|,
name|SDB_DEBUG
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Generate COFF format debug info"
argument_list|)
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS_DEBUGGING_INFO
block|{
literal|"vms"
block|,
name|VMS_DEBUG
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Generate VMS format debug info"
argument_list|)
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|string
decl_stmt|;
name|int
modifier|*
specifier|const
name|variable
decl_stmt|;
specifier|const
name|int
name|on_value
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|description
decl_stmt|;
block|}
name|lang_independent_options
typedef|;
end_typedef

begin_decl_stmt
name|int
name|flag_trapv
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add or remove a leading underscore from user symbols.  */
end_comment

begin_decl_stmt
name|int
name|flag_leading_underscore
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The user symbol prefix after having resolved same.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|user_label_prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|param_info
name|lang_independent_params
index|[]
init|=
block|{
define|#
directive|define
name|DEFPARAM
parameter_list|(
name|ENUM
parameter_list|,
name|OPTION
parameter_list|,
name|HELP
parameter_list|,
name|DEFAULT
parameter_list|)
define|\
value|{ OPTION, DEFAULT, HELP },
include|#
directive|include
file|"params.def"
undef|#
directive|undef
name|DEFPARAM
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A default for same.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USER_LABEL_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|USER_LABEL_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Table of language-independent -f options.    STRING is the option name.  VARIABLE is the address of the variable.    ON_VALUE is the value to store in VARIABLE     if `-fSTRING' is seen as an option.    (If `-fno-STRING' is seen as an option, the opposite value is stored.)  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|lang_independent_options
name|f_options
index|[]
init|=
block|{
block|{
literal|"format-extensions"
block|,
operator|&
name|flag_format_extensions
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"-Wformat accepts certain FreeBSD system-dependent formats"
argument_list|)
block|}
block|,
block|{
literal|"eliminate-dwarf2-dups"
block|,
operator|&
name|flag_eliminate_dwarf2_dups
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Perform DWARF2 duplicate elimination"
argument_list|)
block|}
block|,
block|{
literal|"float-store"
block|,
operator|&
name|flag_float_store
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Do not store floats in registers"
argument_list|)
block|}
block|,
block|{
literal|"volatile"
block|,
operator|&
name|flag_volatile
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Consider all mem refs through pointers as volatile"
argument_list|)
block|}
block|,
block|{
literal|"volatile-global"
block|,
operator|&
name|flag_volatile_global
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Consider all mem refs to global data to be volatile"
argument_list|)
block|}
block|,
block|{
literal|"volatile-static"
block|,
operator|&
name|flag_volatile_static
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Consider all mem refs to static data to be volatile"
argument_list|)
block|}
block|,
block|{
literal|"defer-pop"
block|,
operator|&
name|flag_defer_pop
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Defer popping functions args from stack until later"
argument_list|)
block|}
block|,
block|{
literal|"omit-frame-pointer"
block|,
operator|&
name|flag_omit_frame_pointer
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"When possible do not generate stack frames"
argument_list|)
block|}
block|,
block|{
literal|"optimize-sibling-calls"
block|,
operator|&
name|flag_optimize_sibling_calls
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Optimize sibling and tail recursive calls"
argument_list|)
block|}
block|,
block|{
literal|"cse-follow-jumps"
block|,
operator|&
name|flag_cse_follow_jumps
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"When running CSE, follow jumps to their targets"
argument_list|)
block|}
block|,
block|{
literal|"cse-skip-blocks"
block|,
operator|&
name|flag_cse_skip_blocks
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"When running CSE, follow conditional jumps"
argument_list|)
block|}
block|,
block|{
literal|"expensive-optimizations"
block|,
operator|&
name|flag_expensive_optimizations
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Perform a number of minor, expensive optimizations"
argument_list|)
block|}
block|,
block|{
literal|"thread-jumps"
block|,
operator|&
name|flag_thread_jumps
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Perform jump threading optimizations"
argument_list|)
block|}
block|,
block|{
literal|"strength-reduce"
block|,
operator|&
name|flag_strength_reduce
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Perform strength reduction optimizations"
argument_list|)
block|}
block|,
block|{
literal|"unroll-loops"
block|,
operator|&
name|flag_unroll_loops
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Perform loop unrolling when iteration count is known"
argument_list|)
block|}
block|,
block|{
literal|"unroll-all-loops"
block|,
operator|&
name|flag_unroll_all_loops
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Perform loop unrolling for all loops"
argument_list|)
block|}
block|,
block|{
literal|"prefetch-loop-arrays"
block|,
operator|&
name|flag_prefetch_loop_arrays
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Generate prefetch instructions, if available, for arrays in loops"
argument_list|)
block|}
block|,
block|{
literal|"move-all-movables"
block|,
operator|&
name|flag_move_all_movables
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Force all loop invariant computations out of loops"
argument_list|)
block|}
block|,
block|{
literal|"reduce-all-givs"
block|,
operator|&
name|flag_reduce_all_givs
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Strength reduce all loop general induction variables"
argument_list|)
block|}
block|,
block|{
literal|"writable-strings"
block|,
operator|&
name|flag_writable_strings
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Store strings in writable data section"
argument_list|)
block|}
block|,
block|{
literal|"peephole"
block|,
operator|&
name|flag_no_peephole
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Enable machine specific peephole optimizations"
argument_list|)
block|}
block|,
block|{
literal|"force-mem"
block|,
operator|&
name|flag_force_mem
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Copy memory operands into registers before using"
argument_list|)
block|}
block|,
block|{
literal|"force-addr"
block|,
operator|&
name|flag_force_addr
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Copy memory address constants into regs before using"
argument_list|)
block|}
block|,
block|{
literal|"function-cse"
block|,
operator|&
name|flag_no_function_cse
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Allow function addresses to be held in registers"
argument_list|)
block|}
block|,
block|{
literal|"inline-functions"
block|,
operator|&
name|flag_inline_functions
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Integrate simple functions into their callers"
argument_list|)
block|}
block|,
block|{
literal|"keep-inline-functions"
block|,
operator|&
name|flag_keep_inline_functions
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Generate code for funcs even if they are fully inlined"
argument_list|)
block|}
block|,
block|{
literal|"inline"
block|,
operator|&
name|flag_no_inline
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Pay attention to the 'inline' keyword"
argument_list|)
block|}
block|,
block|{
literal|"keep-static-consts"
block|,
operator|&
name|flag_keep_static_consts
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Emit static const variables even if they are not used"
argument_list|)
block|}
block|,
block|{
literal|"syntax-only"
block|,
operator|&
name|flag_syntax_only
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Check for syntax errors, then stop"
argument_list|)
block|}
block|,
block|{
literal|"shared-data"
block|,
operator|&
name|flag_shared_data
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Mark data as shared rather than private"
argument_list|)
block|}
block|,
block|{
literal|"caller-saves"
block|,
operator|&
name|flag_caller_saves
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Enable saving registers around function calls"
argument_list|)
block|}
block|,
block|{
literal|"pcc-struct-return"
block|,
operator|&
name|flag_pcc_struct_return
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Return 'short' aggregates in memory, not registers"
argument_list|)
block|}
block|,
block|{
literal|"reg-struct-return"
block|,
operator|&
name|flag_pcc_struct_return
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Return 'short' aggregates in registers"
argument_list|)
block|}
block|,
block|{
literal|"delayed-branch"
block|,
operator|&
name|flag_delayed_branch
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Attempt to fill delay slots of branch instructions"
argument_list|)
block|}
block|,
block|{
literal|"gcse"
block|,
operator|&
name|flag_gcse
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Perform the global common subexpression elimination"
argument_list|)
block|}
block|,
block|{
literal|"gcse-lm"
block|,
operator|&
name|flag_gcse_lm
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Perform enhanced load motion during global subexpression elimination"
argument_list|)
block|}
block|,
block|{
literal|"gcse-sm"
block|,
operator|&
name|flag_gcse_sm
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Perform store motion after global subexpression elimination"
argument_list|)
block|}
block|,
block|{
literal|"rerun-cse-after-loop"
block|,
operator|&
name|flag_rerun_cse_after_loop
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Run CSE pass after loop optimizations"
argument_list|)
block|}
block|,
block|{
literal|"rerun-loop-opt"
block|,
operator|&
name|flag_rerun_loop_opt
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Run the loop optimizer twice"
argument_list|)
block|}
block|,
block|{
literal|"delete-null-pointer-checks"
block|,
operator|&
name|flag_delete_null_pointer_checks
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Delete useless null pointer checks"
argument_list|)
block|}
block|,
block|{
literal|"pretend-float"
block|,
operator|&
name|flag_pretend_float
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Pretend that host and target use the same FP format"
argument_list|)
block|}
block|,
block|{
literal|"schedule-insns"
block|,
operator|&
name|flag_schedule_insns
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Reschedule instructions before register allocation"
argument_list|)
block|}
block|,
block|{
literal|"schedule-insns2"
block|,
operator|&
name|flag_schedule_insns_after_reload
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Reschedule instructions after register allocation"
argument_list|)
block|}
block|,
block|{
literal|"sched-interblock"
block|,
operator|&
name|flag_schedule_interblock
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Enable scheduling across basic blocks"
argument_list|)
block|}
block|,
block|{
literal|"sched-spec"
block|,
operator|&
name|flag_schedule_speculative
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Allow speculative motion of non-loads"
argument_list|)
block|}
block|,
block|{
literal|"sched-spec-load"
block|,
operator|&
name|flag_schedule_speculative_load
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Allow speculative motion of some loads"
argument_list|)
block|}
block|,
block|{
literal|"sched-spec-load-dangerous"
block|,
operator|&
name|flag_schedule_speculative_load_dangerous
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Allow speculative motion of more loads"
argument_list|)
block|}
block|,
block|{
literal|"branch-count-reg"
block|,
operator|&
name|flag_branch_on_count_reg
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Replace add,compare,branch with branch on count reg"
argument_list|)
block|}
block|,
block|{
literal|"pic"
block|,
operator|&
name|flag_pic
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Generate position independent code, if possible"
argument_list|)
block|}
block|,
block|{
literal|"PIC"
block|,
operator|&
name|flag_pic
block|,
literal|2
block|,
literal|""
block|}
block|,
block|{
literal|"exceptions"
block|,
operator|&
name|flag_exceptions
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Enable exception handling"
argument_list|)
block|}
block|,
block|{
literal|"unwind-tables"
block|,
operator|&
name|flag_unwind_tables
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Just generate unwind tables for exception handling"
argument_list|)
block|}
block|,
block|{
literal|"asynchronous-unwind-tables"
block|,
operator|&
name|flag_asynchronous_unwind_tables
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Generate unwind tables exact at each instruction boundary"
argument_list|)
block|}
block|,
block|{
literal|"non-call-exceptions"
block|,
operator|&
name|flag_non_call_exceptions
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Support synchronous non-call exceptions"
argument_list|)
block|}
block|,
block|{
literal|"profile-arcs"
block|,
operator|&
name|profile_arc_flag
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Insert arc based program profiling code"
argument_list|)
block|}
block|,
block|{
literal|"test-coverage"
block|,
operator|&
name|flag_test_coverage
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Create data files needed by gcov"
argument_list|)
block|}
block|,
block|{
literal|"branch-probabilities"
block|,
operator|&
name|flag_branch_probabilities
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Use profiling information for branch probabilities"
argument_list|)
block|}
block|,
block|{
literal|"reorder-blocks"
block|,
operator|&
name|flag_reorder_blocks
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Reorder basic blocks to improve code placement"
argument_list|)
block|}
block|,
block|{
literal|"rename-registers"
block|,
operator|&
name|flag_rename_registers
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Do the register renaming optimization pass"
argument_list|)
block|}
block|,
block|{
literal|"cprop-registers"
block|,
operator|&
name|flag_cprop_registers
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Do the register copy-propagation optimization pass"
argument_list|)
block|}
block|,
block|{
literal|"common"
block|,
operator|&
name|flag_no_common
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Do not put uninitialized globals in the common section"
argument_list|)
block|}
block|,
block|{
literal|"inhibit-size-directive"
block|,
operator|&
name|flag_inhibit_size_directive
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Do not generate .size directives"
argument_list|)
block|}
block|,
block|{
literal|"function-sections"
block|,
operator|&
name|flag_function_sections
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"place each function into its own section"
argument_list|)
block|}
block|,
block|{
literal|"data-sections"
block|,
operator|&
name|flag_data_sections
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"place data items into their own section"
argument_list|)
block|}
block|,
block|{
literal|"verbose-asm"
block|,
operator|&
name|flag_verbose_asm
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Add extra commentry to assembler output"
argument_list|)
block|}
block|,
block|{
literal|"gnu-linker"
block|,
operator|&
name|flag_gnu_linker
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Output GNU ld formatted global initializers"
argument_list|)
block|}
block|,
block|{
literal|"regmove"
block|,
operator|&
name|flag_regmove
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Enables a register move optimization"
argument_list|)
block|}
block|,
block|{
literal|"optimize-register-move"
block|,
operator|&
name|flag_regmove
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Do the full regmove optimization pass"
argument_list|)
block|}
block|,
block|{
literal|"pack-struct"
block|,
operator|&
name|flag_pack_struct
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Pack structure members together without holes"
argument_list|)
block|}
block|,
block|{
literal|"stack-check"
block|,
operator|&
name|flag_stack_check
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Insert stack checking code into the program"
argument_list|)
block|}
block|,
block|{
literal|"argument-alias"
block|,
operator|&
name|flag_argument_noalias
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Specify that arguments may alias each other& globals"
argument_list|)
block|}
block|,
block|{
literal|"argument-noalias"
block|,
operator|&
name|flag_argument_noalias
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Assume arguments may alias globals but not each other"
argument_list|)
block|}
block|,
block|{
literal|"argument-noalias-global"
block|,
operator|&
name|flag_argument_noalias
block|,
literal|2
block|,
name|N_
argument_list|(
literal|"Assume arguments do not alias each other or globals"
argument_list|)
block|}
block|,
block|{
literal|"strict-aliasing"
block|,
operator|&
name|flag_strict_aliasing
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Assume strict aliasing rules apply"
argument_list|)
block|}
block|,
block|{
literal|"align-loops"
block|,
operator|&
name|align_loops
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Align the start of loops"
argument_list|)
block|}
block|,
block|{
literal|"align-jumps"
block|,
operator|&
name|align_jumps
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Align labels which are only reached by jumping"
argument_list|)
block|}
block|,
block|{
literal|"align-labels"
block|,
operator|&
name|align_labels
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Align all labels"
argument_list|)
block|}
block|,
block|{
literal|"align-functions"
block|,
operator|&
name|align_functions
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Align the start of functions"
argument_list|)
block|}
block|,
block|{
literal|"merge-constants"
block|,
operator|&
name|flag_merge_constants
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Attempt to merge identical constants accross compilation units"
argument_list|)
block|}
block|,
block|{
literal|"merge-all-constants"
block|,
operator|&
name|flag_merge_constants
block|,
literal|2
block|,
name|N_
argument_list|(
literal|"Attempt to merge identical constants and constant variables"
argument_list|)
block|}
block|,
block|{
literal|"dump-unnumbered"
block|,
operator|&
name|flag_dump_unnumbered
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Suppress output of instruction numbers and line number notes in debugging dumps"
argument_list|)
block|}
block|,
block|{
literal|"instrument-functions"
block|,
operator|&
name|flag_instrument_function_entry_exit
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Instrument function entry/exit with profiling calls"
argument_list|)
block|}
block|,
block|{
literal|"ssa"
block|,
operator|&
name|flag_ssa
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Enable SSA optimizations"
argument_list|)
block|}
block|,
block|{
literal|"ssa-ccp"
block|,
operator|&
name|flag_ssa_ccp
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Enable SSA conditional constant propagation"
argument_list|)
block|}
block|,
block|{
literal|"ssa-dce"
block|,
operator|&
name|flag_ssa_dce
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Enable aggressive SSA dead code elimination"
argument_list|)
block|}
block|,
block|{
literal|"leading-underscore"
block|,
operator|&
name|flag_leading_underscore
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"External symbols have a leading underscore"
argument_list|)
block|}
block|,
block|{
literal|"ident"
block|,
operator|&
name|flag_no_ident
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Process #ident directives"
argument_list|)
block|}
block|,
block|{
literal|"peephole2"
block|,
operator|&
name|flag_peephole2
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Enables an rtl peephole pass run before sched2"
argument_list|)
block|}
block|,
block|{
literal|"guess-branch-probability"
block|,
operator|&
name|flag_guess_branch_prob
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Enables guessing of branch probabilities"
argument_list|)
block|}
block|,
block|{
literal|"math-errno"
block|,
operator|&
name|flag_errno_math
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Set errno after built-in math functions"
argument_list|)
block|}
block|,
block|{
literal|"trapping-math"
block|,
operator|&
name|flag_trapping_math
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Floating-point operations can trap"
argument_list|)
block|}
block|,
block|{
literal|"unsafe-math-optimizations"
block|,
operator|&
name|flag_unsafe_math_optimizations
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Allow math optimizations that may violate IEEE or ANSI standards"
argument_list|)
block|}
block|,
block|{
literal|"bounded-pointers"
block|,
operator|&
name|flag_bounded_pointers
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Compile pointers as triples: value, base& end"
argument_list|)
block|}
block|,
block|{
literal|"bounds-check"
block|,
operator|&
name|flag_bounds_check
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Generate code to check bounds before dereferencing pointers and arrays"
argument_list|)
block|}
block|,
block|{
literal|"single-precision-constant"
block|,
operator|&
name|flag_single_precision_constant
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Convert floating point constant to single precision constant"
argument_list|)
block|}
block|,
block|{
literal|"time-report"
block|,
operator|&
name|time_report
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Report time taken by each compiler pass at end of run"
argument_list|)
block|}
block|,
block|{
literal|"mem-report"
block|,
operator|&
name|mem_report
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Report on permanent memory allocation at end of run"
argument_list|)
block|}
block|,
block|{
literal|"trapv"
block|,
operator|&
name|flag_trapv
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Trap for signed overflow in addition / subtraction / multiplication"
argument_list|)
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of language-specific options.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|lang_opt
block|{
specifier|const
name|char
modifier|*
specifier|const
name|option
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|description
decl_stmt|;
block|}
name|documented_lang_options
index|[]
init|=
block|{
comment|/* In order not to overload the --help output, the convention      used here is to only describe those options which are not      enabled by default.  */
block|{
literal|"-ansi"
block|,
name|N_
argument_list|(
literal|"Compile just for ISO C89"
argument_list|)
block|}
block|,
block|{
literal|"-fallow-single-precision"
block|,
name|N_
argument_list|(
literal|"Do not promote floats to double if using -traditional"
argument_list|)
block|}
block|,
block|{
literal|"-std= "
block|,
name|N_
argument_list|(
literal|"Determine language standard"
argument_list|)
block|}
block|,
block|{
literal|"-fsigned-bitfields"
block|,
literal|""
block|}
block|,
block|{
literal|"-funsigned-bitfields"
block|,
name|N_
argument_list|(
literal|"Make bit-fields by unsigned by default"
argument_list|)
block|}
block|,
block|{
literal|"-fno-signed-bitfields"
block|,
literal|""
block|}
block|,
block|{
literal|"-fno-unsigned-bitfields"
block|,
literal|""
block|}
block|,
block|{
literal|"-fsigned-char"
block|,
name|N_
argument_list|(
literal|"Make 'char' be signed by default"
argument_list|)
block|}
block|,
block|{
literal|"-funsigned-char"
block|,
name|N_
argument_list|(
literal|"Make 'char' be unsigned by default"
argument_list|)
block|}
block|,
block|{
literal|"-fno-signed-char"
block|,
literal|""
block|}
block|,
block|{
literal|"-fno-unsigned-char"
block|,
literal|""
block|}
block|,
block|{
literal|"-ftraditional"
block|,
literal|""
block|}
block|,
block|{
literal|"-traditional"
block|,
name|N_
argument_list|(
literal|"Attempt to support traditional K&R style C"
argument_list|)
block|}
block|,
block|{
literal|"-fnotraditional"
block|,
literal|""
block|}
block|,
block|{
literal|"-fno-traditional"
block|,
literal|""
block|}
block|,
block|{
literal|"-fasm"
block|,
literal|""
block|}
block|,
block|{
literal|"-fno-asm"
block|,
name|N_
argument_list|(
literal|"Do not recognize the 'asm' keyword"
argument_list|)
block|}
block|,
block|{
literal|"-fbuiltin"
block|,
literal|""
block|}
block|,
block|{
literal|"-fno-builtin"
block|,
name|N_
argument_list|(
literal|"Do not recognize any built in functions"
argument_list|)
block|}
block|,
block|{
literal|"-fhosted"
block|,
name|N_
argument_list|(
literal|"Assume normal C execution environment"
argument_list|)
block|}
block|,
block|{
literal|"-fno-hosted"
block|,
literal|""
block|}
block|,
block|{
literal|"-ffreestanding"
block|,
name|N_
argument_list|(
literal|"Assume that standard libraries& main might not exist"
argument_list|)
block|}
block|,
block|{
literal|"-fno-freestanding"
block|,
literal|""
block|}
block|,
block|{
literal|"-fcond-mismatch"
block|,
name|N_
argument_list|(
literal|"Allow different types as args of ? operator"
argument_list|)
block|}
block|,
block|{
literal|"-fno-cond-mismatch"
block|,
literal|""
block|}
block|,
block|{
literal|"-fdollars-in-identifiers"
block|,
name|N_
argument_list|(
literal|"Allow the use of $ inside identifiers"
argument_list|)
block|}
block|,
block|{
literal|"-fno-dollars-in-identifiers"
block|,
literal|""
block|}
block|,
block|{
literal|"-fpreprocessed"
block|,
literal|""
block|}
block|,
block|{
literal|"-fno-preprocessed"
block|,
literal|""
block|}
block|,
block|{
literal|"-fshort-double"
block|,
name|N_
argument_list|(
literal|"Use the same size for double as for float"
argument_list|)
block|}
block|,
block|{
literal|"-fno-short-double"
block|,
literal|""
block|}
block|,
block|{
literal|"-fshort-enums"
block|,
name|N_
argument_list|(
literal|"Use the smallest fitting integer to hold enums"
argument_list|)
block|}
block|,
block|{
literal|"-fno-short-enums"
block|,
literal|""
block|}
block|,
block|{
literal|"-fshort-wchar"
block|,
name|N_
argument_list|(
literal|"Override the underlying type for wchar_t to `unsigned short'"
argument_list|)
block|}
block|,
block|{
literal|"-fno-short-wchar"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wall"
block|,
name|N_
argument_list|(
literal|"Enable most warning messages"
argument_list|)
block|}
block|,
block|{
literal|"-Wbad-function-cast"
block|,
name|N_
argument_list|(
literal|"Warn about casting functions to incompatible types"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-bad-function-cast"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wno-missing-noreturn"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wmissing-format-attribute"
block|,
name|N_
argument_list|(
literal|"Warn about functions which might be candidates for format attributes"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-missing-format-attribute"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wcast-qual"
block|,
name|N_
argument_list|(
literal|"Warn about casts which discard qualifiers"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-cast-qual"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wchar-subscripts"
block|,
name|N_
argument_list|(
literal|"Warn about subscripts whose type is 'char'"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-char-subscripts"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wcomment"
block|,
name|N_
argument_list|(
literal|"Warn if nested comments are detected"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-comment"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wcomments"
block|,
name|N_
argument_list|(
literal|"Warn if nested comments are detected"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-comments"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wconversion"
block|,
name|N_
argument_list|(
literal|"Warn about possibly confusing type conversions"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-conversion"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wformat"
block|,
name|N_
argument_list|(
literal|"Warn about printf/scanf/strftime/strfmon format anomalies"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-format"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wformat-y2k"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wno-format-y2k"
block|,
name|N_
argument_list|(
literal|"Don't warn about strftime formats yielding 2 digit years"
argument_list|)
block|}
block|,
block|{
literal|"-Wformat-extra-args"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wno-format-extra-args"
block|,
name|N_
argument_list|(
literal|"Don't warn about too many arguments to format functions"
argument_list|)
block|}
block|,
block|{
literal|"-Wformat-nonliteral"
block|,
name|N_
argument_list|(
literal|"Warn about non-string-literal format strings"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-format-nonliteral"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wformat-security"
block|,
name|N_
argument_list|(
literal|"Warn about possible security problems with format functions"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-format-security"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wimplicit-function-declaration"
block|,
name|N_
argument_list|(
literal|"Warn about implicit function declarations"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-implicit-function-declaration"
block|,
literal|""
block|}
block|,
block|{
literal|"-Werror-implicit-function-declaration"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wimplicit-int"
block|,
name|N_
argument_list|(
literal|"Warn when a declaration does not specify a type"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-implicit-int"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wimplicit"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wno-implicit"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wimport"
block|,
name|N_
argument_list|(
literal|"Warn about the use of the #import directive"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-import"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wlong-long"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wno-long-long"
block|,
name|N_
argument_list|(
literal|"Do not warn about using 'long long' when -pedantic"
argument_list|)
block|}
block|,
block|{
literal|"-Wmain"
block|,
name|N_
argument_list|(
literal|"Warn about suspicious declarations of main"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-main"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wmissing-braces"
block|,
name|N_
argument_list|(
literal|"Warn about possibly missing braces around initializers"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-missing-braces"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wmissing-declarations"
block|,
name|N_
argument_list|(
literal|"Warn about global funcs without previous declarations"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-missing-declarations"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wmissing-prototypes"
block|,
name|N_
argument_list|(
literal|"Warn about global funcs without prototypes"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-missing-prototypes"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wmultichar"
block|,
name|N_
argument_list|(
literal|"Warn about use of multicharacter literals"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-multichar"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wnested-externs"
block|,
name|N_
argument_list|(
literal|"Warn about externs not at file scope level"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-nested-externs"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wparentheses"
block|,
name|N_
argument_list|(
literal|"Warn about possible missing parentheses"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-parentheses"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wsequence-point"
block|,
name|N_
argument_list|(
literal|"Warn about possible violations of sequence point rules"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-sequence-point"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wpointer-arith"
block|,
name|N_
argument_list|(
literal|"Warn about function pointer arithmetic"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-pointer-arith"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wredundant-decls"
block|,
name|N_
argument_list|(
literal|"Warn about multiple declarations of the same object"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-redundant-decls"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wsign-compare"
block|,
name|N_
argument_list|(
literal|"Warn about signed/unsigned comparisons"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-sign-compare"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wfloat-equal"
block|,
name|N_
argument_list|(
literal|"Warn about testing equality of floating point numbers"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-float-equal"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wunknown-pragmas"
block|,
name|N_
argument_list|(
literal|"Warn about unrecognized pragmas"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-unknown-pragmas"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wstrict-prototypes"
block|,
name|N_
argument_list|(
literal|"Warn about non-prototyped function decls"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-strict-prototypes"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wtraditional"
block|,
name|N_
argument_list|(
literal|"Warn about constructs whose meaning change in ISO C"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-traditional"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wtrigraphs"
block|,
name|N_
argument_list|(
literal|"Warn when trigraphs are encountered"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-trigraphs"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wundef"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wno-undef"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wwrite-strings"
block|,
name|N_
argument_list|(
literal|"Mark strings as 'const char *'"
argument_list|)
block|}
block|,
block|{
literal|"-Wno-write-strings"
block|,
literal|""
block|}
block|,
define|#
directive|define
name|DEFINE_LANG_NAME
parameter_list|(
name|NAME
parameter_list|)
value|{ NULL, NAME },
include|#
directive|include
file|"options.h"
block|}
struct|;
end_struct

begin_comment
comment|/* Here is a table, controlled by the tm.h file, listing each -m switch    and which bits in `target_switches' it should set or clear.    If VALUE is positive, it is bits to set.    If VALUE is negative, -VALUE is bits to clear.    (The sign bit is not used so there is no confusion.)  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|int
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|description
decl_stmt|;
block|}
name|target_switches
index|[]
init|=
name|TARGET_SWITCHES
struct|;
end_struct

begin_comment
comment|/* This table is similar, but allows the switch to have a value.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
end_ifdef

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
specifier|const
name|variable
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|description
decl_stmt|;
block|}
name|target_options
index|[]
init|=
name|TARGET_OPTIONS
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Options controlling warnings.  */
end_comment

begin_comment
comment|/* Don't print warning messages.  -w.  */
end_comment

begin_decl_stmt
name|int
name|inhibit_warnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't suppress warnings from system headers.  -Wsystem-headers.  */
end_comment

begin_decl_stmt
name|int
name|warn_system_headers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print various extra warnings.  -W.  */
end_comment

begin_decl_stmt
name|int
name|extra_warnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Treat warnings as errors.  -Werror.  */
end_comment

begin_decl_stmt
name|int
name|warnings_are_errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to warn about unused variables, functions et.al.  */
end_comment

begin_decl_stmt
name|int
name|warn_unused_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warn_unused_label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warn_unused_parameter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warn_unused_variable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warn_unused_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to warn about code which is never reached.  */
end_comment

begin_decl_stmt
name|int
name|warn_notreached
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to warn about variables used before they are initialized.  */
end_comment

begin_decl_stmt
name|int
name|warn_uninitialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about all declarations which shadow others.  */
end_comment

begin_decl_stmt
name|int
name|warn_shadow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if a switch on an enum fails to have a case for every enum value.  */
end_comment

begin_decl_stmt
name|int
name|warn_switch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about function definitions that default the return type    or that use a null return and have a return-type other than void.  */
end_comment

begin_decl_stmt
name|int
name|warn_return_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about pointer casts that increase the required    alignment of the target type (and might therefore lead to a crash    due to a misaligned access).  */
end_comment

begin_decl_stmt
name|int
name|warn_cast_align
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about any objects definitions whose size is larger    than N bytes.  Also want about function definitions whose returned    values are larger than N bytes. The value N is in `larger_than_size'.  */
end_comment

begin_decl_stmt
name|int
name|warn_larger_than
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HOST_WIDE_INT
name|larger_than_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if inline function is too large.  */
end_comment

begin_decl_stmt
name|int
name|warn_inline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if a function returns an aggregate,    since there are often incompatible calling conventions for doing this.  */
end_comment

begin_decl_stmt
name|int
name|warn_aggregate_return
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if packed attribute on struct is unnecessary and inefficient.  */
end_comment

begin_decl_stmt
name|int
name|warn_packed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn when gcc pads a structure to an alignment boundary.  */
end_comment

begin_decl_stmt
name|int
name|warn_padded
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn when an optimization pass is disabled.  */
end_comment

begin_decl_stmt
name|int
name|warn_disabled_optimization
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about functions which might be candidates for attribute noreturn.  */
end_comment

begin_decl_stmt
name|int
name|warn_missing_noreturn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about uses of __attribute__((deprecated))     declarations.  */
end_comment

begin_decl_stmt
name|int
name|warn_deprecated_decl
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise for -W.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|lang_independent_options
name|W_options
index|[]
init|=
block|{
block|{
literal|"unused-function"
block|,
operator|&
name|warn_unused_function
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn when a function is unused"
argument_list|)
block|}
block|,
block|{
literal|"unused-label"
block|,
operator|&
name|warn_unused_label
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn when a label is unused"
argument_list|)
block|}
block|,
block|{
literal|"unused-parameter"
block|,
operator|&
name|warn_unused_parameter
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn when a function parameter is unused"
argument_list|)
block|}
block|,
block|{
literal|"unused-variable"
block|,
operator|&
name|warn_unused_variable
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn when a variable is unused"
argument_list|)
block|}
block|,
block|{
literal|"unused-value"
block|,
operator|&
name|warn_unused_value
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn when an expression value is unused"
argument_list|)
block|}
block|,
block|{
literal|"system-headers"
block|,
operator|&
name|warn_system_headers
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Do not suppress warnings from system headers"
argument_list|)
block|}
block|,
block|{
literal|"error"
block|,
operator|&
name|warnings_are_errors
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Treat all warnings as errors"
argument_list|)
block|}
block|,
block|{
literal|"shadow"
block|,
operator|&
name|warn_shadow
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn when one local variable shadows another"
argument_list|)
block|}
block|,
block|{
literal|"switch"
block|,
operator|&
name|warn_switch
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn about enumerated switches missing a specific case"
argument_list|)
block|}
block|,
block|{
literal|"aggregate-return"
block|,
operator|&
name|warn_aggregate_return
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn about returning structures, unions or arrays"
argument_list|)
block|}
block|,
block|{
literal|"cast-align"
block|,
operator|&
name|warn_cast_align
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn about pointer casts which increase alignment"
argument_list|)
block|}
block|,
block|{
literal|"unreachable-code"
block|,
operator|&
name|warn_notreached
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn about code that will never be executed"
argument_list|)
block|}
block|,
block|{
literal|"uninitialized"
block|,
operator|&
name|warn_uninitialized
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn about uninitialized automatic variables"
argument_list|)
block|}
block|,
block|{
literal|"inline"
block|,
operator|&
name|warn_inline
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn when an inlined function cannot be inlined"
argument_list|)
block|}
block|,
block|{
literal|"packed"
block|,
operator|&
name|warn_packed
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn when the packed attribute has no effect on struct layout"
argument_list|)
block|}
block|,
block|{
literal|"padded"
block|,
operator|&
name|warn_padded
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn when padding is required to align struct members"
argument_list|)
block|}
block|,
block|{
literal|"disabled-optimization"
block|,
operator|&
name|warn_disabled_optimization
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn when an optimization pass is disabled"
argument_list|)
block|}
block|,
block|{
literal|"deprecated-declarations"
block|,
operator|&
name|warn_deprecated_decl
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn about uses of __attribute__((deprecated)) declarations"
argument_list|)
block|}
block|,
block|{
literal|"missing-noreturn"
block|,
operator|&
name|warn_missing_noreturn
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Warn about functions which might be candidates for attribute noreturn"
argument_list|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|set_Wunused
parameter_list|(
name|setting
parameter_list|)
name|int
name|setting
decl_stmt|;
block|{
name|warn_unused_function
operator|=
name|setting
expr_stmt|;
name|warn_unused_label
operator|=
name|setting
expr_stmt|;
comment|/* Unused function parameter warnings are reported when either ``-W      -Wunused'' or ``-Wunused-parameter'' is specified.  Differentiate      -Wunused by setting WARN_UNUSED_PARAMETER to -1.  */
if|if
condition|(
operator|!
name|setting
condition|)
name|warn_unused_parameter
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|warn_unused_parameter
condition|)
name|warn_unused_parameter
operator|=
operator|-
literal|1
expr_stmt|;
name|warn_unused_variable
operator|=
name|setting
expr_stmt|;
name|warn_unused_value
operator|=
name|setting
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following routines are useful in setting all the flags that    -ffast-math and -fno-fast-math imply.  */
end_comment

begin_function
name|void
name|set_fast_math_flags
parameter_list|()
block|{
name|flag_trapping_math
operator|=
literal|0
expr_stmt|;
name|flag_unsafe_math_optimizations
operator|=
literal|1
expr_stmt|;
name|flag_errno_math
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_no_fast_math_flags
parameter_list|()
block|{
name|flag_trapping_math
operator|=
literal|1
expr_stmt|;
name|flag_unsafe_math_optimizations
operator|=
literal|0
expr_stmt|;
name|flag_errno_math
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output files for assembler code (real compiler output)    and debugging dumps.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|aux_info_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|rtl_dump_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Decode the string P as an integral parameter.    If the string is indeed an integer return its numeric value else    issue an Invalid Option error for the option PNAME and return DEFVAL.    If PNAME is zero just return DEFVAL, do not call error.  */
end_comment

begin_function
name|int
name|read_integral_parameter
parameter_list|(
name|p
parameter_list|,
name|pname
parameter_list|,
name|defval
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|pname
decl_stmt|;
specifier|const
name|int
name|defval
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|endp
init|=
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|endp
condition|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|endp
argument_list|)
condition|)
name|endp
operator|++
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|endp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pname
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"invalid option `%s'"
argument_list|,
name|pname
argument_list|)
expr_stmt|;
return|return
name|defval
return|;
block|}
return|return
name|atoi
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the default decl_printable_name function.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|decl_name
parameter_list|(
name|decl
parameter_list|,
name|verbosity
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|verbosity
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This calls abort and is used to avoid problems when abort if a macro.    It is used when we need to pass the address of abort.  */
end_comment

begin_function
name|void
name|do_abort
parameter_list|()
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When `malloc.c' is compiled with `rcheck' defined,    it calls this function to report clobberage.  */
end_comment

begin_function
name|void
name|botch
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the logarithm of X, base 2, considering X unsigned,    if X is a power of 2.  Otherwise, returns -1.     This should be used via the `exact_log2' macro.  */
end_comment

begin_function
name|int
name|exact_log2_wide
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|x
decl_stmt|;
block|{
name|int
name|log
init|=
literal|0
decl_stmt|;
comment|/* Test for 0 or a power of 2.  */
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|x
operator|!=
operator|(
name|x
operator|&
operator|-
name|x
operator|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
name|x
operator|>>=
literal|1
operator|)
operator|!=
literal|0
condition|)
name|log
operator|++
expr_stmt|;
return|return
name|log
return|;
block|}
end_function

begin_comment
comment|/* Given X, an unsigned number, return the largest int Y such that 2**Y<= X.    If X is 0, return -1.     This should be used via the floor_log2 macro.  */
end_comment

begin_function
name|int
name|floor_log2_wide
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|x
decl_stmt|;
block|{
name|int
name|log
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
name|log
operator|++
operator|,
name|x
operator|>>=
literal|1
expr_stmt|;
return|return
name|log
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|float_handler_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|float_handled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|float_handler
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Signals actually come here.  */
end_comment

begin_function
specifier|static
name|void
name|float_signal
parameter_list|(
name|signo
parameter_list|)
comment|/* If this is missing, some compilers complain.  */
name|int
name|signo
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|float_handled
operator|==
literal|0
condition|)
name|crash_signal
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|float_handled
operator|=
literal|0
expr_stmt|;
comment|/* On System-V derived systems, we must reinstall the signal handler.      This is harmless on BSD-derived systems.  */
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_signal
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|float_handler
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Specify where to longjmp to when a floating arithmetic error happens.    If HANDLER is 0, it means don't handle the errors any more.  */
end_comment

begin_function
specifier|static
name|void
name|set_float_handler
parameter_list|(
name|handler
parameter_list|)
name|jmp_buf
name|handler
decl_stmt|;
block|{
name|float_handled
operator|=
operator|(
name|handler
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|handler
condition|)
name|memcpy
argument_list|(
name|float_handler
argument_list|,
name|handler
argument_list|,
sizeof|sizeof
argument_list|(
name|float_handler
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|float_handled
operator|&&
operator|!
name|float_handler_set
condition|)
block|{
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_signal
argument_list|)
expr_stmt|;
name|float_handler_set
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is a wrapper function for code which might elicit an    arithmetic exception.  That code should be passed in as a function    pointer FN, and one argument DATA.  DATA is usually a struct which    contains the real input and output for function FN.  This function    returns 0 (failure) if longjmp was called (i.e. an exception    occurred.)  It returns 1 (success) otherwise.  */
end_comment

begin_function_decl
name|int
name|do_float_handler
parameter_list|(
name|fn
parameter_list|,
name|data
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*fn
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|jmp_buf
name|buf
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|buf
argument_list|)
condition|)
block|{
comment|/* We got here via longjmp () caused by an exception in function          fn ().  */
name|set_float_handler
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|set_float_handler
argument_list|(
name|buf
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fn
call|)
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|set_float_handler
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Handler for fatal signals, such as SIGSEGV.  These are transformed    into ICE messages, which is much more user friendly.  */
end_comment

begin_function
specifier|static
name|void
name|crash_signal
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|internal_error
argument_list|(
literal|"internal error: %s"
argument_list|,
name|strsignal
argument_list|(
name|signo
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Strip off a legitimate source ending from the input string NAME of    length LEN.  Rather than having to know the names used by all of    our front ends, we strip off an ending of a period followed by    up to five characters.  (Java uses ".class".)  */
end_comment

begin_function
name|void
name|strip_off_ending
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|6
operator|&&
name|len
operator|>
name|i
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name
index|[
name|len
operator|-
name|i
index|]
operator|==
literal|'.'
condition|)
block|{
name|name
index|[
name|len
operator|-
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output a quoted string.  */
end_comment

begin_function
name|void
name|output_quoted_string
parameter_list|(
name|asm_file
parameter_list|,
name|string
parameter_list|)
name|FILE
modifier|*
name|asm_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OUTPUT_QUOTED_STRING
name|OUTPUT_QUOTED_STRING
argument_list|(
name|asm_file
argument_list|,
name|string
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
name|c
decl_stmt|;
name|putc
argument_list|(
literal|'\"'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\"'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output a file name in the form wanted by System V.  */
end_comment

begin_function
name|void
name|output_file_directive
parameter_list|(
name|asm_file
parameter_list|,
name|input_name
parameter_list|)
name|FILE
modifier|*
name|asm_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|input_name
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|input_name
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|na
init|=
name|input_name
operator|+
name|len
decl_stmt|;
comment|/* NA gets INPUT_NAME sans directory names.  */
while|while
condition|(
name|na
operator|>
name|input_name
condition|)
block|{
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|na
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
name|na
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MAIN_SOURCE_FILENAME
name|ASM_OUTPUT_MAIN_SOURCE_FILENAME
argument_list|(
name|asm_file
argument_list|,
name|na
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_FILENAME
name|ASM_OUTPUT_SOURCE_FILENAME
argument_list|(
name|asm_file
argument_list|,
name|na
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\t.file\t"
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|asm_file
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routine to open a dump file.  Return true if the dump file is enabled.  */
end_comment

begin_function
specifier|static
name|int
name|open_dump_file
parameter_list|(
name|index
parameter_list|,
name|decl
parameter_list|)
name|enum
name|dump_file_index
name|index
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|char
modifier|*
name|dump_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|open_arg
decl_stmt|;
name|char
name|seq
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|dump_file
index|[
name|index
index|]
operator|.
name|enabled
condition|)
return|return
literal|0
return|;
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|seq
argument_list|,
name|DUMPFILE_FORMAT
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dump_file
index|[
name|index
index|]
operator|.
name|initialized
condition|)
block|{
comment|/* If we've not initialized the files, do so now.  */
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
operator|&&
name|dump_file
index|[
name|index
index|]
operator|.
name|graph_dump_p
condition|)
block|{
name|dump_name
operator|=
name|concat
argument_list|(
name|seq
argument_list|,
name|dump_file
index|[
name|index
index|]
operator|.
name|extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
name|dump_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dump_name
argument_list|)
expr_stmt|;
block|}
name|dump_file
index|[
name|index
index|]
operator|.
name|initialized
operator|=
literal|1
expr_stmt|;
name|open_arg
operator|=
literal|"w"
expr_stmt|;
block|}
else|else
name|open_arg
operator|=
literal|"a"
expr_stmt|;
name|dump_name
operator|=
name|concat
argument_list|(
name|dump_base_name
argument_list|,
name|seq
argument_list|,
name|dump_file
index|[
name|index
index|]
operator|.
name|extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rtl_dump_file
operator|=
name|fopen
argument_list|(
name|dump_name
argument_list|,
name|open_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
operator|==
name|NULL
condition|)
name|fatal_io_error
argument_list|(
literal|"can't open %s"
argument_list|,
name|dump_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dump_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n;; Function %s\n\n"
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Routine to close a dump file.  */
end_comment

begin_function_decl
specifier|static
name|void
name|close_dump_file
parameter_list|(
name|index
parameter_list|,
name|func
parameter_list|,
name|insns
parameter_list|)
name|enum
name|dump_file_index
name|index
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|rtx
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|rtx
name|insns
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|rtl_dump_file
condition|)
return|return;
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|insns
operator|&&
name|graph_dump_format
operator|!=
name|no_graph
operator|&&
name|dump_file
index|[
name|index
index|]
operator|.
name|graph_dump_p
condition|)
block|{
name|char
name|seq
index|[
literal|16
index|]
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
name|sprintf
argument_list|(
name|seq
argument_list|,
name|DUMPFILE_FORMAT
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|concat
argument_list|(
name|seq
argument_list|,
name|dump_file
index|[
name|index
index|]
operator|.
name|extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
name|suffix
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|func
operator|&&
name|insns
condition|)
name|func
argument_list|(
name|rtl_dump_file
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|rtl_dump_file
operator|=
name|NULL
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Do any final processing required for the declarations in VEC, of    which there are LEN.  We write out inline functions and variables    that have been deferred until this point, but which are required.    Returns non-zero if anything was put out.  */
end_comment

begin_function
name|int
name|wrapup_global_declarations
parameter_list|(
name|vec
parameter_list|,
name|len
parameter_list|)
name|tree
modifier|*
name|vec
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|reconsider
decl_stmt|;
name|int
name|output_something
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|vec
index|[
name|i
index|]
expr_stmt|;
comment|/* We're not deferring this any longer.  */
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|incomplete_decl_finalize_hook
operator|!=
literal|0
condition|)
call|(
modifier|*
name|incomplete_decl_finalize_hook
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Now emit any global variables or functions that we have been      putting off.  We need to loop in case one of the things emitted      here references another one which comes earlier in the list.  */
do|do
block|{
name|reconsider
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|vec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
continue|continue;
comment|/* Don't write out static consts, unless we still need them.  	     We also keep static consts if not optimizing (for debugging), 	     unless the user specified -fno-keep-static-consts. 	     ??? They might be better written into the debug information. 	     This is possible when using DWARF.  	     A language processor that wants static constants to be always 	     written out (even if it is not used) is responsible for 	     calling rest_of_decl_compilation itself.  E.g. the C front-end 	     calls rest_of_decl_compilation from finish_decl. 	     One motivation for this is that is conventional in some 	     environments to write things like: 	     static const char rcsid[] = "... version string ..."; 	     intending to force the string to be in the executable.  	     A language processor that would prefer to have unneeded 	     static constants "optimized away" would just defer writing 	     them out until here.  E.g. C++ does this, because static 	     constants are often defined in header files.  	     ??? A tempting alternative (for both C and C++) would be 	     to force a constant to be written if and only if it is 	     defined in a main file, as opposed to an include file.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|bool
name|needed
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
comment|/* needed */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
condition|)
name|needed
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|optimize
operator|||
operator|!
name|flag_keep_static_consts
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|needed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needed
condition|)
block|{
name|reconsider
operator|=
literal|1
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|flag_keep_inline_functions
operator|||
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|reconsider
operator|=
literal|1
expr_stmt|;
name|output_inline_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reconsider
condition|)
name|output_something
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|reconsider
condition|)
do|;
return|return
name|output_something
return|;
block|}
end_function

begin_comment
comment|/* Issue appropriate warnings for the global declarations in VEC (of    which there are LEN).  Output debugging information for them.  */
end_comment

begin_function
name|void
name|check_global_declarations
parameter_list|(
name|vec
parameter_list|,
name|len
parameter_list|)
name|tree
modifier|*
name|vec
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|vec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Cancel the RTL for this decl so that, if debugging info 	   output for global variables is still to come, 	   this one will be omitted.  */
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Warn about any function 	 declared static but not defined. 	 We don't warn about variables, 	 because many programs have static variables 	 that exist only to get some text into the object file.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|warn_unused_function
operator|||
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|pedwarn_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' used but never defined"
argument_list|)
expr_stmt|;
else|else
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' declared `static' but never defined"
argument_list|)
expr_stmt|;
comment|/* This symbol is effectively an "extern" declaration now.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|assemble_external
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about static fns or vars defined but not used, 	 but not about inline functions or static consts 	 since defining those in header files is normal practice.  */
if|if
condition|(
operator|(
operator|(
name|warn_unused_function
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
operator|(
name|warn_unused_variable
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|)
comment|/* The TREE_USED bit for file-scope decls 	     is kept in the identifier, to handle multiple 	     external decls in different scopes.  */
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' defined but not used"
argument_list|)
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|global_decl
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Save the current INPUT_FILENAME and LINENO on the top entry in the    INPUT_FILE_STACK.  Push a new entry for FILE and LINE, and set the    INPUT_FILENAME and LINENO accordingly.  */
end_comment

begin_function
name|void
name|push_srcloc
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|struct
name|file_stack
modifier|*
name|fs
decl_stmt|;
if|if
condition|(
name|input_file_stack
condition|)
block|{
name|input_file_stack
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
name|input_file_stack
operator|->
name|line
operator|=
name|lineno
expr_stmt|;
block|}
name|fs
operator|=
operator|(
expr|struct
name|file_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_stack
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|->
name|name
operator|=
name|input_filename
operator|=
name|file
expr_stmt|;
name|fs
operator|->
name|line
operator|=
name|lineno
operator|=
name|line
expr_stmt|;
name|fs
operator|->
name|indent_level
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|next
operator|=
name|input_file_stack
expr_stmt|;
name|input_file_stack
operator|=
name|fs
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the top entry off the stack of presently open source files.    Restore the INPUT_FILENAME and LINENO from the new topmost entry on    the stack.  */
end_comment

begin_function
name|void
name|pop_srcloc
parameter_list|()
block|{
name|struct
name|file_stack
modifier|*
name|fs
decl_stmt|;
name|fs
operator|=
name|input_file_stack
expr_stmt|;
name|input_file_stack
operator|=
name|fs
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
comment|/* The initial source file is never popped.  */
if|if
condition|(
operator|!
name|input_file_stack
condition|)
name|abort
argument_list|()
expr_stmt|;
name|input_filename
operator|=
name|input_file_stack
operator|->
name|name
expr_stmt|;
name|lineno
operator|=
name|input_file_stack
operator|->
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compile an entire translation unit.  Write a file of assembly    output and various debugging dumps.  */
end_comment

begin_function
specifier|static
name|void
name|compile_file
parameter_list|()
block|{
name|tree
name|globals
decl_stmt|;
comment|/* Initialize yet another pass.  */
name|init_final
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
name|init_branch_prob
argument_list|(
name|dump_base_name
argument_list|)
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_PARSE
argument_list|)
expr_stmt|;
comment|/* Call the parser, which parses the entire file      (calling rest_of_compilation for each function).  */
name|yyparse
argument_list|()
expr_stmt|;
comment|/* In case there were missing block closers,      get us back to the global binding level.  */
call|(
modifier|*
name|lang_hooks
operator|.
name|clear_binding_stack
call|)
argument_list|()
expr_stmt|;
comment|/* Compilation is now finished except for writing      what's left of the symbol table output.  */
name|timevar_pop
argument_list|(
name|TV_PARSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
name|globals
operator|=
name|getdecls
argument_list|()
expr_stmt|;
comment|/* Really define vars that have had only a tentative definition.      Really output inline functions that must actually be callable      and have not been output so far.  */
block|{
name|int
name|len
init|=
name|list_length
argument_list|(
name|globals
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|vec
init|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|len
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|decl
decl_stmt|;
comment|/* Process the decls in reverse order--earliest first.        Put them into VEC from back to front, then take out from front.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|decl
operator|=
name|globals
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|vec
index|[
name|len
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|decl
expr_stmt|;
name|wrapup_global_declarations
argument_list|(
name|vec
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* This must occur after the loop to output deferred functions.  Else        the profiler initializer would not be emitted if all the functions        in this compilation unit were deferred.         output_func_start_profiler can not cause any additional functions or        data to need to be output, so it need not be in the deferred function        loop above.  */
name|output_func_start_profiler
argument_list|()
expr_stmt|;
name|check_global_declarations
argument_list|(
name|vec
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|free
argument_list|(
name|vec
argument_list|)
expr_stmt|;
block|}
comment|/* Write out any pending weak symbol declarations.  */
name|weak_finish
argument_list|()
expr_stmt|;
comment|/* Do dbx symbols.  */
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_finish
argument_list|()
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|debug_hooks
operator|->
name|finish
call|)
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
comment|/* Output some stuff at end of file if nec.  */
name|dw2_output_indirect_constants
argument_list|()
expr_stmt|;
name|end_final
argument_list|(
name|dump_base_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_arc_flag
operator|||
name|flag_test_coverage
operator|||
name|flag_branch_probabilities
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|end_branch_prob
argument_list|()
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_bp
argument_list|,
name|NULL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_FILE_END
name|ASM_FILE_END
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Attach a special .ident directive to the end of the file to identify      the version of GCC which compiled this code.  The format of the .ident      string is patterned after the ones produced by native SVR4 compilers.  */
ifdef|#
directive|ifdef
name|IDENT_ASM_OP
if|if
condition|(
operator|!
name|flag_no_ident
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\"GCC: (GNU) %s\"\n"
argument_list|,
name|IDENT_ASM_OP
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|open_dump_file
argument_list|(
name|DFI_combine
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
name|dump_combine_total_stats
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_combine
argument_list|,
name|NULL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is called from various places for FUNCTION_DECL, VAR_DECL,    and TYPE_DECL nodes.     This does nothing for local (non-static) variables, unless the    variable is a register variable with an ASMSPEC.  In that case, or    if the variable is not an automatic, it sets up the RTL and    outputs any assembler code (label definition, storage allocation    and initialization).     DECL is the declaration.  If ASMSPEC is nonzero, it specifies    the assembler symbol name to be used.  TOP_LEVEL is nonzero    if this declaration is not within a function.  */
end_comment

begin_function
name|void
name|rest_of_decl_compilation
parameter_list|(
name|decl
parameter_list|,
name|asmspec
parameter_list|,
name|top_level
parameter_list|,
name|at_end
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|asmspec
decl_stmt|;
name|int
name|top_level
decl_stmt|;
name|int
name|at_end
decl_stmt|;
block|{
comment|/* Declarations of variables, and of functions defined elsewhere.  */
comment|/* The most obvious approach, to put an #ifndef around where    this macro is used, doesn't work since it's inside a macro call.  */
ifndef|#
directive|ifndef
name|ASM_FINISH_DECLARE_OBJECT
define|#
directive|define
name|ASM_FINISH_DECLARE_OBJECT
parameter_list|(
name|FILE
parameter_list|,
name|DECL
parameter_list|,
name|TOP
parameter_list|,
name|END
parameter_list|)
endif|#
directive|endif
comment|/* We deferred calling assemble_alias so that we could collect      other attributes such as visibility.  Emit the alias now.  */
block|{
name|tree
name|alias
decl_stmt|;
name|alias
operator|=
name|lookup_attribute
argument_list|(
literal|"alias"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias
condition|)
block|{
name|alias
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
name|alias
operator|=
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_alias
argument_list|(
name|decl
argument_list|,
name|alias
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Forward declarations for nested functions are not "external",      but we need to treat them as if they were.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_VARCONST
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec
condition|)
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
comment|/* Don't output anything 	 when a tentative file-scope definition is seen. 	 But at end of compilation, do output code for them.  */
if|if
condition|(
name|at_end
operator|||
operator|!
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
condition|)
name|assemble_variable
argument_list|(
name|decl
argument_list|,
name|top_level
argument_list|,
name|at_end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|last_assemble_variable_decl
condition|)
block|{
name|ASM_FINISH_DECLARE_OBJECT
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|top_level
argument_list|,
name|at_end
argument_list|)
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_VARCONST
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
name|asmspec
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|decode_reg_name
argument_list|(
name|asmspec
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"invalid register name `%s' for register variable"
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|top_level
condition|)
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
elseif|else
if|if
condition|(
operator|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|top_level
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Called after finishing a record, union or enumeral type.  */
end_comment

begin_function
name|void
name|rest_of_type_compilation
parameter_list|(
name|type
parameter_list|,
name|toplev
parameter_list|)
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|SDB_DEBUGGING_INFO
argument_list|)
name|tree
name|type
decl_stmt|;
name|int
name|toplev
decl_stmt|;
else|#
directive|else
name|tree
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|toplev
name|ATTRIBUTE_UNUSED
decl_stmt|;
endif|#
directive|endif
block|{
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|dbxout_symbol
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|,
operator|!
name|toplev
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_symbol
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|,
operator|!
name|toplev
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
operator|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
operator|)
operator|&&
name|toplev
condition|)
name|dwarf2out_decl
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called from finish_function (within yyparse)    after each top-level definition is parsed.    It is supposed to compile that function or variable    and output the assembler code for it.    After we return, the tree storage is freed.  */
end_comment

begin_function
name|void
name|rest_of_compilation
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|rtx
name|insns
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|int
name|failure
init|=
literal|0
decl_stmt|;
name|int
name|rebuild_label_notes_after_reload
decl_stmt|;
name|int
name|register_life_up_to_date
decl_stmt|;
name|int
name|cleanup_crossjump
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_REST_OF_COMPILATION
argument_list|)
expr_stmt|;
comment|/* Now that we're out of the frontend, we shouldn't have any more      CONCATs anywhere.  */
name|generating_concat_p
operator|=
literal|0
expr_stmt|;
comment|/* When processing delayed functions, prepare_function_start() won't      have been run to re-initialize it.  */
name|cse_not_expected
operator|=
operator|!
name|optimize
expr_stmt|;
comment|/* First, make sure that NOTE_BLOCK is set correctly for each      NOTE_INSN_BLOCK_BEG/NOTE_INSN_BLOCK_END note.  */
if|if
condition|(
operator|!
name|cfun
operator|->
name|x_whole_function_mode_p
condition|)
name|identify_blocks
argument_list|()
expr_stmt|;
comment|/* In function-at-a-time mode, we do not attempt to keep the BLOCK      tree in sensible shape.  So, we just recalculate it here.  */
if|if
condition|(
name|cfun
operator|->
name|x_whole_function_mode_p
condition|)
name|reorder_blocks
argument_list|()
expr_stmt|;
name|init_flow
argument_list|()
expr_stmt|;
comment|/* If we are reconsidering an inline function      at the end of compilation, skip the stuff for making it inline.  */
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|inlinable
init|=
literal|0
decl_stmt|;
name|tree
name|parent
decl_stmt|;
specifier|const
name|char
modifier|*
name|lose
decl_stmt|;
comment|/* If this is nested inside an inlined external function, pretend 	 it was only declared.  Since we cannot inline such functions, 	 generating code for this one is not only not necessary but will 	 confuse some debugging output writers.  */
for|for
control|(
name|parent
operator|=
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|parent
operator|!=
name|NULL_TREE
condition|;
name|parent
operator|=
name|get_containing_scope
argument_list|(
name|parent
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INLINE
argument_list|(
name|parent
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
goto|goto
name|exit_rest_of_compilation
goto|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|parent
argument_list|)
condition|)
comment|/* A function in a local class should be treated normally.  */
break|break;
comment|/* If requested, consider whether to make this function inline.  */
if|if
condition|(
operator|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|flag_no_inline
operator|)
operator|||
name|flag_inline_functions
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
name|lose
operator|=
name|function_cannot_inline_p
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|lose
operator|||
operator|!
name|optimize
condition|)
block|{
if|if
condition|(
name|warn_inline
operator|&&
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
name|lose
argument_list|)
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Don't really compile an extern inline function. 		 If we can't make it inline, pretend 		 it was only declared.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
goto|goto
name|exit_rest_of_compilation
goto|;
block|}
block|}
else|else
comment|/* ??? Note that this has the effect of making it look 		 like "inline" was specified for a function if we choose 		 to inline it.  This isn't quite right, but it's 		 probably not worth the trouble to fix.  */
name|inlinable
operator|=
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
comment|/* Dump the rtl code if we are dumping rtl.  */
if|if
condition|(
name|open_dump_file
argument_list|(
name|DFI_rtl
argument_list|,
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; (integrable)\n\n"
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_rtl
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
comment|/* Convert from NOTE_INSN_EH_REGION style notes, and do other 	 sorts of eh initialization.  Delay this until after the          initial rtl dump so that we can see the original nesting.  */
name|convert_from_eh_region_ranges
argument_list|()
expr_stmt|;
comment|/* If function is inline, and we don't yet know whether to 	 compile it by itself, defer decision till end of compilation. 	 finish_compilation will call rest_of_compilation again 	 for those functions that need to be output.  Also defer those 	 functions that we are supposed to defer.  */
if|if
condition|(
name|inlinable
operator|||
operator|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|!
name|flag_keep_inline_functions
operator|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
condition|)
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* DWARF wants separate debugging info for abstract and 	   concrete instances of all inline functions, including those 	   declared inline but not inlined, and those inlined even 	   though they weren't declared inline.  Conveniently, that's 	   what DECL_INLINE means at this point.  */
call|(
modifier|*
name|debug_hooks
operator|->
name|deferred_inline_function
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If -Wreturn-type, we have to do a bit of compilation.  We just 	     want to call cleanup the cfg to figure out whether or not we can 	     fall off the end of the function; we do the minimum amount of 	     work necessary to make that safe.  */
if|if
condition|(
name|warn_return_type
condition|)
block|{
name|int
name|saved_optimize
init|=
name|optimize
decl_stmt|;
name|optimize
operator|=
literal|0
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|find_exception_handler_labels
argument_list|()
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_PRE_SIBCALL
operator||
name|CLEANUP_PRE_LOOP
argument_list|)
expr_stmt|;
name|optimize
operator|=
name|saved_optimize
expr_stmt|;
comment|/* CFG is no longer maintained up-to-date.  */
name|free_bb_for_insn
argument_list|()
expr_stmt|;
block|}
name|current_function_nothrow
operator|=
name|nothrow_function_p
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_function_nothrow
condition|)
comment|/* Now we know that this can't throw; set the flag for the benefit 	       of other functions later in this translation unit.  */
name|TREE_NOTHROW
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
name|save_for_inline
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|->
name|inlinable
operator|=
name|inlinable
expr_stmt|;
goto|goto
name|exit_rest_of_compilation
goto|;
block|}
comment|/* If specified extern inline but we aren't inlining it, we are 	 done.  This goes for anything that gets here with DECL_EXTERNAL 	 set, not just things with DECL_INLINE.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
goto|goto
name|exit_rest_of_compilation
goto|;
block|}
comment|/* If we're emitting a nested function, make sure its parent gets      emitted as well.  Doing otherwise confuses debug info.  */
block|{
name|tree
name|parent
decl_stmt|;
for|for
control|(
name|parent
operator|=
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|parent
operator|!=
name|NULL_TREE
condition|;
name|parent
operator|=
name|get_containing_scope
argument_list|(
name|parent
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|parent
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We are now committed to emitting code for this function.  Do any      preparation, such as emitting abstract debug info for the inline      before it gets mangled by optimization.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|outlining_inline_function
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Remove any notes we don't need.  That will make iterating      over the instruction sequence faster, and allow the garbage      collector to reclaim the memory used by the notes.  */
name|remove_unnecessary_notes
argument_list|()
expr_stmt|;
name|reorder_blocks
argument_list|()
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
comment|/* Initialize some variables used by the optimizers.  */
name|init_function_for_compilation
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Now that integrate will no longer see our rtl, we need not      distinguish between the return value of this function and the      return value of called functions.  Also, we can remove all SETs      of subregs of hard registers; they are only here because of      integrate.  Also, we can now initialize pseudos intended to       carry magic hard reg data throughout the function.  */
name|rtx_equal_function_value_matters
operator|=
literal|0
expr_stmt|;
name|purge_hard_subreg_sets
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Early return if there were errors.  We can run afoul of our      consistency checks, and there's not really much point in fixing them.      Don't return yet if -Wreturn-type; we need to do cleanup_cfg.  */
if|if
condition|(
operator|(
operator|(
name|rtl_dump_and_exit
operator|||
name|flag_syntax_only
operator|)
operator|&&
operator|!
name|warn_return_type
operator|)
operator|||
name|errorcount
operator|||
name|sorrycount
condition|)
goto|goto
name|exit_rest_of_compilation
goto|;
comment|/* We may have potential sibling or tail recursion sites.  Select one      (of possibly multiple) methods of performing the call.  */
if|if
condition|(
name|flag_optimize_sibling_calls
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_sibling
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|optimize_sibling_and_tail_recursive_calls
argument_list|()
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_sibling
argument_list|,
name|print_rtl
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
block|}
comment|/* Complete generation of exception handling code.  */
name|find_exception_handler_labels
argument_list|()
expr_stmt|;
if|if
condition|(
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_eh
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|finish_eh_generation
argument_list|()
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_eh
argument_list|,
name|print_rtl
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
block|}
comment|/* Delay emitting hard_reg_initial_value sets until after EH landing pad      generation, which might create new sets.  */
name|emit_initial_value_sets
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FINALIZE_PIC
comment|/* If we are doing position-independent code generation, now      is the time to output special prologues and epilogues.      We do not want to do this earlier, because it just clutters      up inline functions with meaningless insns.  */
if|if
condition|(
name|flag_pic
condition|)
name|FINALIZE_PIC
expr_stmt|;
endif|#
directive|endif
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
comment|/* Copy any shared structure that should not be shared.  */
name|unshare_all_rtl
argument_list|(
name|current_function_decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SETJMP_VIA_SAVE_AREA
comment|/* This must be performed before virtual register instantiation.  */
if|if
condition|(
name|current_function_calls_alloca
condition|)
name|optimize_save_area_alloca
argument_list|(
name|insns
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Instantiate all virtual registers.  */
name|instantiate_virtual_regs
argument_list|(
name|current_function_decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_jump
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Always do one jump optimization pass to ensure that JUMP_LABEL fields      are initialized and to compute whether control can drop off the end      of the function.  */
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
comment|/* Turn NOTE_INSN_EXPECTED_VALUE into REG_BR_PROB.  Do this      before jump optimization switches branch directions.  */
name|expected_value_to_br_prob
argument_list|()
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
operator|(
name|optimize
condition|?
name|CLEANUP_EXPENSIVE
else|:
literal|0
operator|)
operator||
name|CLEANUP_PRE_LOOP
argument_list|)
expr_stmt|;
comment|/* CFG is no longer maintained up-to-date.  */
name|free_bb_for_insn
argument_list|()
expr_stmt|;
name|copy_loop_headers
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|purge_line_number_notes
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
comment|/* Now is when we stop if -fsyntax-only and -Wreturn-type.  */
if|if
condition|(
name|rtl_dump_and_exit
operator|||
name|flag_syntax_only
operator|||
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|close_dump_file
argument_list|(
name|DFI_jump
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
goto|goto
name|exit_rest_of_compilation
goto|;
block|}
comment|/* Long term, this should probably move before the jump optimizer too,      but I didn't want to disturb the rtl_dump_and_exit and related      stuff at this time.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_ssa
condition|)
block|{
comment|/* Convert to SSA form.  */
name|timevar_push
argument_list|(
name|TV_TO_SSA
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_ssa
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_PRE_LOOP
argument_list|)
expr_stmt|;
name|convert_to_ssa
argument_list|()
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_ssa
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_TO_SSA
argument_list|)
expr_stmt|;
comment|/* Perform sparse conditional constant propagation, if requested.  */
if|if
condition|(
name|flag_ssa_ccp
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_SSA_CCP
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_ssa_ccp
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|ssa_const_prop
argument_list|()
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_ssa_ccp
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SSA_CCP
argument_list|)
expr_stmt|;
block|}
comment|/* It would be useful to cleanup the CFG at this point, but block 	 merging and possibly other transformations might leave a PHI 	 node in the middle of a basic block, which is a strict no-no.  */
comment|/* The SSA implementation uses basic block numbers in its phi 	 nodes.  Thus, changing the control-flow graph or the basic 	 blocks, e.g., calling find_basic_blocks () or cleanup_cfg (), 	 may cause problems.  */
if|if
condition|(
name|flag_ssa_dce
condition|)
block|{
comment|/* Remove dead code.  */
name|timevar_push
argument_list|(
name|TV_SSA_DCE
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_ssa_dce
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|ssa_eliminate_dead_code
argument_list|()
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_ssa_dce
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SSA_DCE
argument_list|)
expr_stmt|;
block|}
comment|/* Convert from SSA form.  */
name|timevar_push
argument_list|(
name|TV_FROM_SSA
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_ussa
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|convert_from_ssa
argument_list|()
expr_stmt|;
comment|/* New registers have been created.  Rescan their usage.  */
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_ussa
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_FROM_SSA
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
comment|/* CFG is no longer maintained up-to-date.  */
name|free_bb_for_insn
argument_list|()
expr_stmt|;
block|}
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_PRE_LOOP
operator||
operator|(
name|flag_thread_jumps
condition|?
name|CLEANUP_THREADING
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* ??? Run if-conversion before delete_null_pointer_checks,          since the later does not preserve the CFG.  This should 	 be changed -- no since converting if's that are going to 	 be deleted.  */
name|timevar_push
argument_list|(
name|TV_IFCVT
argument_list|)
expr_stmt|;
name|if_convert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_IFCVT
argument_list|)
expr_stmt|;
comment|/* CFG is no longer maintained up-to-date.  */
name|free_bb_for_insn
argument_list|()
expr_stmt|;
comment|/* Try to identify useless null pointer tests and delete them.  */
if|if
condition|(
name|flag_delete_null_pointer_checks
condition|)
name|delete_null_pointer_checks
argument_list|(
name|insns
argument_list|)
expr_stmt|;
block|}
comment|/* Jump optimization, and the removal of NULL pointer checks, may      have reduced the number of instructions substantially.  CSE, and      future passes, allocate arrays whose dimensions involve the      maximum instruction UID, so if we can reduce the maximum UID      we'll save big on memory.  */
name|renumber_insns
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_jump
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
comment|/* Perform common subexpression elimination.      Nonzero value from `cse_main' means that jumps were simplified      and some code may now be unreachable, so do      jump optimization again.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|open_dump_file
argument_list|(
name|DFI_cse
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_CSE
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|cse_main
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
comment|/* If we are not running more CSE passes, then we are no longer 	 expecting CSE to be run.  But always rerun it in a cheap mode.  */
name|cse_not_expected
operator|=
operator|!
name|flag_rerun_cse_after_loop
operator|&&
operator|!
name|flag_gcse
expr_stmt|;
if|if
condition|(
name|tem
operator|||
name|optimize
operator|>
literal|1
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_PRE_LOOP
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
comment|/* CFG is no longer maintained up-to-date.  */
name|free_bb_for_insn
argument_list|()
expr_stmt|;
block|}
comment|/* Run this after jump optmizations remove all the unreachable code 	 so that unreachable code will not keep values live.  */
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Try to identify useless null pointer tests and delete them.  */
if|if
condition|(
name|flag_delete_null_pointer_checks
operator|||
name|flag_thread_jumps
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_PRE_LOOP
operator||
operator|(
name|flag_thread_jumps
condition|?
name|CLEANUP_THREADING
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_delete_null_pointer_checks
condition|)
name|delete_null_pointer_checks
argument_list|(
name|insns
argument_list|)
expr_stmt|;
comment|/* CFG is no longer maintained up-to-date.  */
name|free_bb_for_insn
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
block|}
comment|/* The second pass of jump optimization is likely to have          removed a bunch more instructions.  */
name|renumber_insns
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_CSE
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_cse
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
name|open_dump_file
argument_list|(
name|DFI_addressof
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|purge_addressof
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_addressof
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
comment|/* Perform global cse.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_gcse
condition|)
block|{
name|int
name|save_csb
decl_stmt|,
name|save_cfj
decl_stmt|;
name|int
name|tem2
init|=
literal|0
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_GCSE
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_gcse
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_PRE_LOOP
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gcse_main
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|save_csb
operator|=
name|flag_cse_skip_blocks
expr_stmt|;
name|save_cfj
operator|=
name|flag_cse_follow_jumps
expr_stmt|;
name|flag_cse_skip_blocks
operator|=
name|flag_cse_follow_jumps
operator|=
literal|0
expr_stmt|;
comment|/* CFG is no longer maintained up-to-date.  */
name|free_bb_for_insn
argument_list|()
expr_stmt|;
comment|/* If -fexpensive-optimizations, re-run CSE to clean up things done 	 by gcse.  */
if|if
condition|(
name|flag_expensive_optimizations
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_CSE
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tem2
operator|=
name|cse_main
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_CSE
argument_list|)
expr_stmt|;
name|cse_not_expected
operator|=
operator|!
name|flag_rerun_cse_after_loop
expr_stmt|;
block|}
comment|/* If gcse or cse altered any jumps, rerun jump optimizations to clean 	 things up.  Then possibly re-run CSE again.  */
while|while
condition|(
name|tem
operator|||
name|tem2
condition|)
block|{
name|tem
operator|=
name|tem2
operator|=
literal|0
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_PRE_LOOP
argument_list|)
expr_stmt|;
comment|/* CFG is no longer maintained up-to-date.  */
name|free_bb_for_insn
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_expensive_optimizations
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_CSE
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tem2
operator|=
name|cse_main
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_CSE
argument_list|)
expr_stmt|;
block|}
block|}
name|close_dump_file
argument_list|(
name|DFI_gcse
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_GCSE
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
name|flag_cse_skip_blocks
operator|=
name|save_csb
expr_stmt|;
name|flag_cse_follow_jumps
operator|=
name|save_cfj
expr_stmt|;
block|}
comment|/* Move constant computations out of loops.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_LOOP
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_loop
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|free_bb_for_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_rerun_loop_opt
condition|)
block|{
name|cleanup_barriers
argument_list|()
expr_stmt|;
comment|/* We only want to perform unrolling once.  */
name|loop_optimize
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|,
name|LOOP_FIRST_PASS
argument_list|)
expr_stmt|;
comment|/* The first call to loop_optimize makes some instructions 	     trivially dead.  We delete those instructions now in the 	     hope that doing so will make the heuristics in loop work 	     better and possibly speed up compilation.  */
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The regscan pass is currently necessary as the alias 		  analysis code depends on this information.  */
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|cleanup_barriers
argument_list|()
expr_stmt|;
name|loop_optimize
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|,
operator|(
name|flag_unroll_loops
condition|?
name|LOOP_UNROLL
else|:
literal|0
operator|)
operator||
name|LOOP_BCT
operator||
operator|(
name|flag_prefetch_loop_arrays
condition|?
name|LOOP_PREFETCH
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_loop
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_LOOP
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_CSE2
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_cse2
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_rerun_cse_after_loop
condition|)
block|{
comment|/* Running another jump optimization pass before the second 	     cse pass sometimes simplifies the RTL enough to allow 	     the second CSE pass to do a better job.  Jump_optimize can change 	     max_reg_num so we must rerun reg_scan afterwards. 	     ??? Rework to not call reg_scan so often.  */
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
comment|/* The previous call to loop_optimize makes some instructions 	     trivially dead.  We delete those instructions now in the 	     hope that doing so will make the heuristics in jump work 	     better and possibly speed up compilation.  */
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_IFCVT
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
name|if_convert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_IFCVT
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
comment|/* CFG is no longer maintained up-to-date.  */
name|free_bb_for_insn
argument_list|()
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|cse_main
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
comment|/* CFG is no longer maintained up-to-date.  */
name|free_bb_for_insn
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
block|}
block|}
name|close_dump_file
argument_list|(
name|DFI_cse2
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_CSE2
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
name|cse_not_expected
operator|=
literal|1
expr_stmt|;
name|regclass_init
argument_list|()
expr_stmt|;
comment|/* Do control and data flow analysis; wrote some of the results to      the dump file.  */
name|timevar_push
argument_list|(
name|TV_FLOW
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_cfg
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
operator|(
name|optimize
condition|?
name|CLEANUP_EXPENSIVE
else|:
literal|0
operator|)
operator||
operator|(
name|flag_thread_jumps
condition|?
name|CLEANUP_THREADING
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|check_function_return_warnings
argument_list|()
expr_stmt|;
comment|/* It may make more sense to mark constant functions after dead code is      eliminated by life_analyzis, but we need to do it early, as -fprofile-arcs      may insert code making function non-constant, but we still must consider      it as constant, otherwise -fbranch-probabilities will not read data back.       life_analyzis rarely eliminates modification of external memory.    */
name|mark_constant_function
argument_list|()
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_cfg
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_arc_flag
operator|||
name|flag_test_coverage
operator|||
name|flag_branch_probabilities
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_BRANCH_PROB
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_bp
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|branch_prob
argument_list|()
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_bp
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_BRANCH_PROB
argument_list|)
expr_stmt|;
block|}
name|open_dump_file
argument_list|(
name|DFI_life
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
block|{
name|struct
name|loops
name|loops
decl_stmt|;
comment|/* Discover and record the loop depth at the head of each basic 	 block.  The loop infrastructure does the real job for us.  */
name|flow_loops_find
argument_list|(
operator|&
name|loops
argument_list|,
name|LOOP_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|flow_loops_dump
argument_list|(
operator|&
name|loops
argument_list|,
name|rtl_dump_file
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Estimate using heuristics if no profiling info is available.  */
if|if
condition|(
name|flag_guess_branch_prob
condition|)
name|estimate_probability
argument_list|(
operator|&
name|loops
argument_list|)
expr_stmt|;
name|flow_loops_free
argument_list|(
operator|&
name|loops
argument_list|)
expr_stmt|;
block|}
name|life_analysis
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|,
name|PROP_FINAL
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_FLOW
argument_list|)
expr_stmt|;
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|warn_uninitialized
operator|||
name|extra_warnings
condition|)
block|{
name|uninitialized_vars_warning
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|setjmp_args_warning
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|optimize
condition|)
block|{
if|if
condition|(
name|initialize_uninitialized_subregs
argument_list|()
condition|)
block|{
comment|/* Insns were inserted, so things might look a bit different.  */
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|life_analysis
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|,
operator|(
name|PROP_LOG_LINKS
operator||
name|PROP_REG_INFO
operator||
name|PROP_DEATH_NOTES
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|close_dump_file
argument_list|(
name|DFI_life
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
comment|/* If -opt, try combining insns through substitution.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|int
name|rebuild_jump_labels_after_combine
init|=
literal|0
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_COMBINE
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_combine
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|rebuild_jump_labels_after_combine
operator|=
name|combine_instructions
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Always purge dead edges, as we may eliminate an insn throwing          exception.  */
name|rebuild_jump_labels_after_combine
operator||=
name|purge_all_dead_edges
argument_list|(
name|true
argument_list|)
expr_stmt|;
comment|/* Combining insns may have turned an indirect jump into a 	 direct jump.  Rebuid the JUMP_LABEL fields of jumping 	 instructions.  */
if|if
condition|(
name|rebuild_jump_labels_after_combine
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_UPDATE_LIFE
argument_list|)
expr_stmt|;
block|}
name|close_dump_file
argument_list|(
name|DFI_combine
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_COMBINE
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
comment|/* Rerun if-conversion, as combine may have simplified things enough to      now meet sequence length restrictions.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_IFCVT
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_ce
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
name|if_convert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_ce
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_IFCVT
argument_list|)
expr_stmt|;
block|}
comment|/* Register allocation pre-pass, to reduce number of moves      necessary for two-address machines.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
operator|(
name|flag_regmove
operator|||
name|flag_expensive_optimizations
operator|)
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_REGMOVE
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_regmove
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|regmove_optimize
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_regmove
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_REGMOVE
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
comment|/* Do unconditional splitting before register allocation to allow machine      description to add extra information not needed previously.  */
name|split_all_insns
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Any of the several passes since flow1 will have munged register      lifetime data a bit.  */
name|register_life_up_to_date
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|OPTIMIZE_MODE_SWITCHING
name|timevar_push
argument_list|(
name|TV_MODE_SWITCH
argument_list|)
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|optimize_mode_switching
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
comment|/* We did work, and so had to regenerate global life information. 	 Take advantage of this and don't re-recompute register life 	 information below.  */
name|register_life_up_to_date
operator|=
literal|1
expr_stmt|;
block|}
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_MODE_SWITCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|timevar_push
argument_list|(
name|TV_SCHED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* Print function header into sched dump now      because doing the sched analysis makes some of the dump.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_schedule_insns
condition|)
block|{
name|open_dump_file
argument_list|(
name|DFI_sched
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Do control and data sched analysis, 	 and write some of the results to dump file.  */
name|schedule_insns
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_sched
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
comment|/* Register lifetime information was updated as part of verifying 	 the schedule.  */
name|register_life_up_to_date
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|timevar_pop
argument_list|(
name|TV_SCHED
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
comment|/* Determine if the current function is a leaf before running reload      since this can impact optimizations done by the prologue and      epilogue thus changing register elimination offsets.  */
name|current_function_is_leaf
operator|=
name|leaf_function_p
argument_list|()
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_LOCAL_ALLOC
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_lreg
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Allocate pseudo-regs that are used only within 1 basic block.       RUN_JUMP_AFTER_RELOAD records whether or not we need to rerun the      jump optimizer after register allocation and reloading are finished.  */
if|if
condition|(
operator|!
name|register_life_up_to_date
condition|)
name|recompute_reg_usage
argument_list|(
name|insns
argument_list|,
operator|!
name|optimize_size
argument_list|)
expr_stmt|;
comment|/* Allocate the reg_renumber array.  */
name|allocate_reg_info
argument_list|(
name|max_regno
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* And the reg_equiv_memory_loc array.  */
name|reg_equiv_memory_loc
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_regno
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|allocate_initial_values
argument_list|(
name|reg_equiv_memory_loc
argument_list|)
expr_stmt|;
name|regclass
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|rebuild_label_notes_after_reload
operator|=
name|local_alloc
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_LOCAL_ALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
index|[
name|DFI_lreg
index|]
operator|.
name|enabled
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|dump_local_alloc
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_lreg
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
block|}
name|ggc_collect
argument_list|()
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_GLOBAL_ALLOC
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_greg
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If optimizing, allocate remaining pseudo-regs.  Do the reload      pass fixing up any insns that are invalid.  */
if|if
condition|(
name|optimize
condition|)
name|failure
operator|=
name|global_alloc
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
else|else
block|{
name|build_insn_chain
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|failure
operator|=
name|reload
argument_list|(
name|insns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_GLOBAL_ALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
index|[
name|DFI_greg
index|]
operator|.
name|enabled
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
name|dump_global_regs
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_greg
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|failure
condition|)
goto|goto
name|exit_rest_of_compilation
goto|;
name|ggc_collect
argument_list|()
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_postreload
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Do a very simple CSE pass over just the hard registers.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_RELOAD_CSE_REGS
argument_list|)
expr_stmt|;
name|reload_cse_regs
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_RELOAD_CSE_REGS
argument_list|)
expr_stmt|;
block|}
comment|/* Register allocation and reloading may have turned an indirect jump into      a direct jump.  If so, we must rebuild the JUMP_LABEL fields of      jumping instructions.  */
if|if
condition|(
name|rebuild_label_notes_after_reload
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
block|}
name|close_dump_file
argument_list|(
name|DFI_postreload
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
comment|/* Re-create the death notes which were deleted during reload.  */
name|timevar_push
argument_list|(
name|TV_FLOW2
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_flow2
argument_list|,
name|decl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* If optimizing, then go ahead and split insns now.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
name|split_all_insns
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|optimize
condition|?
name|CLEANUP_EXPENSIVE
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* On some machines, the prologue and epilogue code, or parts thereof,      can be represented as RTL.  Doing so lets us schedule insns between      it and the rest of the code and also allows delayed branch      scheduling to operate in the epilogue.  */
name|thread_prologue_and_epilogue_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
comment|/* Cross-jumping is O(N^3) on the number of edges, thus trying to      perform cross-jumping on flow graphs which have a high connectivity      will take a long time.  This is similar to the test to disable GCSE.  */
name|cleanup_crossjump
operator|=
name|CLEANUP_CROSSJUMP
expr_stmt|;
if|if
condition|(
name|n_basic_blocks
operator|>
literal|1000
operator|&&
name|n_edges
operator|/
name|n_basic_blocks
operator|>=
literal|20
condition|)
block|{
if|if
condition|(
name|optimize
operator|&&
name|warn_disabled_optimization
condition|)
name|warning
argument_list|(
literal|"crossjump disabled: %d> 1000 basic blocks and %d>= 20 edges/basic block"
argument_list|,
name|n_basic_blocks
argument_list|,
name|n_edges
operator|/
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|cleanup_crossjump
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|optimize
condition|)
block|{
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|cleanup_crossjump
argument_list|)
expr_stmt|;
name|life_analysis
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|,
name|PROP_FINAL
argument_list|)
expr_stmt|;
comment|/* This is kind of a heuristic.  We need to run combine_stack_adjustments          even for machines with possibly nonzero RETURN_POPS_ARGS          and ACCUMULATE_OUTGOING_ARGS.  We expect that only ports having          push instructions will have popping returns.  */
ifndef|#
directive|ifndef
name|PUSH_ROUNDING
if|if
condition|(
operator|!
name|ACCUMULATE_OUTGOING_ARGS
condition|)
endif|#
directive|endif
name|combine_stack_adjustments
argument_list|()
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
name|flow2_completed
operator|=
literal|1
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_flow2
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_FLOW2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_peephole2
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_peephole2
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_PEEPHOLE2
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_peephole2
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|peephole2_optimize
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_peephole2
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_PEEPHOLE2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
operator|(
name|flag_rename_registers
operator|||
name|flag_cprop_registers
operator|)
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_RENAME_REGISTERS
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_rnreg
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_rename_registers
condition|)
name|regrename_optimize
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_cprop_registers
condition|)
name|copyprop_hardreg_forward
argument_list|()
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_rnreg
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_RENAME_REGISTERS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_IFCVT2
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_ce2
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|if_convert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_ce2
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_IFCVT2
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STACK_REGS
if|if
condition|(
name|optimize
condition|)
name|split_all_insns
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_schedule_insns_after_reload
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_SCHED2
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_sched2
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Do control and data sched analysis again, 	 and write some more of the results to dump file.  */
name|split_all_insns
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|schedule_insns
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_sched2
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SCHED2
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
name|current_function_uses_only_leaf_regs
operator|=
name|optimize
operator|>
literal|0
operator|&&
name|only_leaf_regs_used
argument_list|()
operator|&&
name|leaf_function_p
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STACK_REGS
name|timevar_push
argument_list|(
name|TV_REG_STACK
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_stack
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|reg_to_stack
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_stack
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_REG_STACK
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_REORDER_BLOCKS
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_bbro
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Last attempt to optimize CFG, as life analysis possibly removed 	 some instructions.  Note that we can't rerun crossjump at this 	 point, because it can turn a switch into a direct branch, which 	 can leave the tablejump address calculation in the code, which 	 can lead to referencing an undefined label.  */
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_POST_REGSTACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_reorder_blocks
condition|)
block|{
name|reorder_basic_blocks
argument_list|()
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_POST_REGSTACK
argument_list|)
expr_stmt|;
block|}
name|close_dump_file
argument_list|(
name|DFI_bbro
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_REORDER_BLOCKS
argument_list|)
expr_stmt|;
block|}
name|compute_alignments
argument_list|()
expr_stmt|;
comment|/* CFG is no longer maintained up-to-date.  */
name|free_bb_for_insn
argument_list|()
expr_stmt|;
comment|/* If a machine dependent reorganization is needed, call it.  */
ifdef|#
directive|ifdef
name|MACHINE_DEPENDENT_REORG
name|timevar_push
argument_list|(
name|TV_MACH_DEP
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_mach
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|MACHINE_DEPENDENT_REORG
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_mach
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_MACH_DEP
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|purge_line_number_notes
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|cleanup_barriers
argument_list|()
expr_stmt|;
comment|/* If a scheduling pass for delayed branches is to be done,      call the scheduling code.  */
ifdef|#
directive|ifdef
name|DELAY_SLOTS
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_delayed_branch
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_DBR_SCHED
argument_list|)
expr_stmt|;
name|open_dump_file
argument_list|(
name|DFI_dbr
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|dbr_schedule
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|DFI_dbr
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DBR_SCHED
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ATTR_length
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|STACK_REGS
argument_list|)
name|timevar_push
argument_list|(
name|TV_SHORTEN_BRANCH
argument_list|)
expr_stmt|;
name|split_all_insns_noflow
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SHORTEN_BRANCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|convert_to_eh_region_ranges
argument_list|()
expr_stmt|;
comment|/* Shorten branches.  */
name|timevar_push
argument_list|(
name|TV_SHORTEN_BRANCH
argument_list|)
expr_stmt|;
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SHORTEN_BRANCH
argument_list|)
expr_stmt|;
name|current_function_nothrow
operator|=
name|nothrow_function_p
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_function_nothrow
condition|)
comment|/* Now we know that this can't throw; set the flag for the benefit        of other functions later in this translation unit.  */
name|TREE_NOTHROW
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Now turn the rtl into assembler code.  */
name|timevar_push
argument_list|(
name|TV_FINAL
argument_list|)
expr_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
comment|/* Get the function's name, as described by its RTL.  This may be        different from the DECL_NAME name used in the source file.  */
name|x
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fnname
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_start_function
argument_list|(
name|decl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|final_start_function
argument_list|(
name|insns
argument_list|,
name|asm_out_file
argument_list|,
name|optimize
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|insns
argument_list|,
name|asm_out_file
argument_list|,
name|optimize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|final_end_function
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|IA64_UNWIND_INFO
comment|/* ??? The IA-64 ".handlerdata" directive must be issued before        the ".endp" directive that closes the procedure descriptor.  */
name|output_function_exception_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|assemble_end_function
argument_list|(
name|decl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IA64_UNWIND_INFO
comment|/* Otherwise, it feels unclean to switch sections in the middle.  */
name|output_function_exception_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fflush
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Release all memory allocated by flow.  */
name|free_basic_block_vars
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Release all memory held by regsets now.  */
name|regset_release_memory
argument_list|()
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_FINAL
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
comment|/* Write DBX symbols if requested.  */
comment|/* Note that for those inline functions where we don't initially      know for certain that we will be generating an out-of-line copy,      the first invocation of this routine (rest_of_compilation) will      skip over this code by doing a `goto exit_rest_of_compilation;'.      Later on, finish_compilation will call rest_of_compilation again      for those inline functions that need to have out-of-line copies      generated.  During that call, we *will* be routed past here.  */
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|function_decl
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
name|exit_rest_of_compilation
label|:
comment|/* In case the function was not output,      don't leave any temporary anonymous types      queued up for sdb output.  */
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_types
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reload_completed
operator|=
literal|0
expr_stmt|;
name|flow2_completed
operator|=
literal|0
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_FINAL
argument_list|)
expr_stmt|;
comment|/* Clear out the insn_length contents now that they are no      longer valid.  */
name|init_insn_lengths
argument_list|()
expr_stmt|;
comment|/* Clear out the real_constant_chain before some of the rtx's      it runs through become garbage.  */
name|clear_const_double_mem
argument_list|()
expr_stmt|;
comment|/* Show no temporary slots allocated.  */
name|init_temp_slots
argument_list|()
expr_stmt|;
name|free_basic_block_vars
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|free_bb_for_insn
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_FINAL
argument_list|)
expr_stmt|;
comment|/* Make sure volatile mem refs aren't considered valid operands for      arithmetic insns.  We must call this here if this is a nested inline      function, since the above code leaves us in the init_recog state      (from final.c), and the function context push/pop code does not      save/restore volatile_ok.       ??? Maybe it isn't necessary for expand_start_function to call this      anymore if we do it here?  */
name|init_recog_no_volatile
argument_list|()
expr_stmt|;
comment|/* We're done with this function.  Free up memory if we can.  */
name|free_after_parsing
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|free_after_compilation
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
comment|/* Clear integrate.c's pointer to the cfun structure we just 	 destroyed.  */
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|cfun
operator|=
literal|0
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_REST_OF_COMPILATION
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|display_help
parameter_list|()
block|{
name|int
name|undoc
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|lang
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -ffixed-<register>      Mark<register> as being unavailable to the compiler\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -fcall-used-<register>  Mark<register> as being corrupted by function calls\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -fcall-saved-<register> Mark<register> as being preserved across functions\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -finline-limit=<number> Limits the size of inlined functions to<number>\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -fmessage-length=<number> Limits diagnostics messages lengths to<number> characters per line.  0 suppresses line-wrapping\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -fdiagnostics-show-location=[once | every-line] Indicates how often source location information should be emitted, as prefix, at the beginning of diagnostics when line-wrapping\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|f_options
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|description
init|=
name|f_options
index|[
name|i
index|]
operator|.
name|description
decl_stmt|;
if|if
condition|(
name|description
operator|!=
name|NULL
operator|&&
operator|*
name|description
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"  -f%-21s %s\n"
argument_list|,
name|f_options
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|_
argument_list|(
name|description
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -O[number]              Set optimization level to [number]\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -Os                     Optimize for space rather than speed\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|LAST_PARAM
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|description
init|=
name|compiler_params
index|[
name|i
index|]
operator|.
name|help
decl_stmt|;
specifier|const
name|int
name|length
init|=
literal|21
operator|-
name|strlen
argument_list|(
name|compiler_params
index|[
name|i
index|]
operator|.
name|option
argument_list|)
decl_stmt|;
if|if
condition|(
name|description
operator|!=
name|NULL
operator|&&
operator|*
name|description
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"  --param %s=<value>%.*s%s\n"
argument_list|,
name|compiler_params
index|[
name|i
index|]
operator|.
name|option
argument_list|,
name|length
operator|>
literal|0
condition|?
name|length
else|:
literal|1
argument_list|,
literal|"                     "
argument_list|,
name|_
argument_list|(
name|description
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -pedantic               Issue warnings needed by strict compliance to ISO C\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -pedantic-errors        Like -pedantic except that errors are produced\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -w                      Suppress warnings\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -W                      Enable extra warnings\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|W_options
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|description
init|=
name|W_options
index|[
name|i
index|]
operator|.
name|description
decl_stmt|;
if|if
condition|(
name|description
operator|!=
name|NULL
operator|&&
operator|*
name|description
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"  -W%-21s %s\n"
argument_list|,
name|W_options
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|_
argument_list|(
name|description
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -Wunused                Enable unused warnings\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -Wlarger-than-<number>  Warn if an object is larger than<number> bytes\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -p                      Enable function profiling\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -o<file>               Place output into<file> \n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\   -G<number>             Put global and static data smaller than<number>\n\                           bytes into a special section (on some targets)\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|debug_args
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
if|if
condition|(
name|debug_args
index|[
name|i
index|]
operator|.
name|description
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"  -g%-21s %s\n"
argument_list|,
name|debug_args
index|[
name|i
index|]
operator|.
name|arg
argument_list|,
name|_
argument_list|(
name|debug_args
index|[
name|i
index|]
operator|.
name|description
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -aux-info<file>        Emit declaration info into<file>\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -quiet                  Do not display functions compiled or elapsed time\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -version                Display the compiler's version\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -d[letters]             Enable dumps from specific passes of the compiler\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -dumpbase<file>        Base name to be used for dumps from specific passes\n"
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|INSN_SCHEDULING
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -fsched-verbose=<number> Set the verbosity level of the scheduler\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
name|_
argument_list|(
literal|"  --help                  Display this information\n"
argument_list|)
argument_list|)
expr_stmt|;
name|undoc
operator|=
literal|0
expr_stmt|;
name|lang
operator|=
literal|"language"
expr_stmt|;
comment|/* Display descriptions of language specific options.      If there is no description, note that there is an undocumented option.      If the description is empty, do not display anything.  (This allows      options to be deliberately undocumented, for whatever reason).      If the option string is missing, then this is a marker, indicating      that the description string is in fact the name of a language, whose      language specific options are to follow.  */
if|if
condition|(
name|ARRAY_SIZE
argument_list|(
name|documented_lang_options
argument_list|)
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nLanguage specific options:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|documented_lang_options
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|description
init|=
name|documented_lang_options
index|[
name|i
index|]
operator|.
name|description
decl_stmt|;
specifier|const
name|char
modifier|*
name|option
init|=
name|documented_lang_options
index|[
name|i
index|]
operator|.
name|option
decl_stmt|;
if|if
condition|(
name|description
operator|==
name|NULL
condition|)
block|{
name|undoc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %-23.23s [undocumented]\n"
argument_list|)
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|description
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|option
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|undoc
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are undocumented %s specific options as well.\n"
argument_list|)
argument_list|,
name|lang
argument_list|)
expr_stmt|;
name|undoc
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n Options for %s:\n"
argument_list|)
argument_list|,
name|description
argument_list|)
expr_stmt|;
name|lang
operator|=
name|description
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"  %-23.23s %s\n"
argument_list|,
name|option
argument_list|,
name|_
argument_list|(
name|description
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|undoc
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are undocumented %s specific options as well.\n"
argument_list|)
argument_list|,
name|lang
argument_list|)
expr_stmt|;
name|display_target_options
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|display_target_options
parameter_list|()
block|{
name|int
name|undoc
decl_stmt|,
name|i
decl_stmt|;
specifier|static
name|bool
name|displayed
init|=
name|false
decl_stmt|;
comment|/* Avoid double printing for --help --target-help.  */
if|if
condition|(
name|displayed
condition|)
return|return;
name|displayed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|ARRAY_SIZE
argument_list|(
name|target_switches
argument_list|)
operator|>
literal|1
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
operator|||
name|ARRAY_SIZE
argument_list|(
name|target_options
argument_list|)
operator|>
literal|1
endif|#
directive|endif
condition|)
block|{
name|int
name|doc
init|=
literal|0
decl_stmt|;
name|undoc
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nTarget specific options:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|target_switches
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|option
init|=
name|target_switches
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
init|=
name|target_switches
index|[
name|i
index|]
operator|.
name|description
decl_stmt|;
if|if
condition|(
name|option
operator|==
name|NULL
operator|||
operator|*
name|option
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|description
operator|==
name|NULL
condition|)
block|{
name|undoc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -m%-23.23s [undocumented]\n"
argument_list|)
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|description
operator|!=
literal|0
condition|)
name|doc
operator|+=
name|printf
argument_list|(
literal|"  -m%-23.23s %s\n"
argument_list|,
name|option
argument_list|,
name|_
argument_list|(
name|description
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|target_options
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|option
init|=
name|target_options
index|[
name|i
index|]
operator|.
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
init|=
name|target_options
index|[
name|i
index|]
operator|.
name|description
decl_stmt|;
if|if
condition|(
name|option
operator|==
name|NULL
operator|||
operator|*
name|option
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|description
operator|==
name|NULL
condition|)
block|{
name|undoc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  -m%-23.23s [undocumented]\n"
argument_list|)
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|description
operator|!=
literal|0
condition|)
name|doc
operator|+=
name|printf
argument_list|(
literal|"  -m%-23.23s %s\n"
argument_list|,
name|option
argument_list|,
name|_
argument_list|(
name|description
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|undoc
condition|)
block|{
if|if
condition|(
name|doc
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are undocumented target specific options as well.\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  They exist, but they are not documented.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse a -d... command line switch.  */
end_comment

begin_function
specifier|static
name|void
name|decode_d_option
parameter_list|(
name|arg
parameter_list|)
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|matched
decl_stmt|;
while|while
condition|(
operator|*
name|arg
condition|)
switch|switch
condition|(
name|c
operator|=
operator|*
name|arg
operator|++
condition|)
block|{
case|case
literal|'a'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|DFI_MAX
condition|;
operator|++
name|i
control|)
name|dump_file
index|[
name|i
index|]
operator|.
name|enabled
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|flag_debug_asm
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|flag_print_asm_name
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|flag_dump_rtl_in_asm
operator|=
literal|1
expr_stmt|;
name|flag_print_asm_name
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|graph_dump_format
operator|=
name|vcg
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|rtl_dump_and_exit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
call|(
modifier|*
name|lang_hooks
operator|.
name|set_yydebug
call|)
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* These are handled by the preprocessor.  */
case|case
literal|'I'
case|:
break|break;
default|default:
name|matched
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|DFI_MAX
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|c
operator|==
name|dump_file
index|[
name|i
index|]
operator|.
name|debug_switch
condition|)
block|{
name|dump_file
index|[
name|i
index|]
operator|.
name|enabled
operator|=
literal|1
expr_stmt|;
name|matched
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matched
condition|)
name|warning
argument_list|(
literal|"unrecognized gcc debugging option: %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Parse a -f... command line switch.  ARG is the value after the -f.    It is safe to access 'ARG - 2' to generate the full switch name.    Return the number of strings consumed.  */
end_comment

begin_function
specifier|static
name|int
name|decode_f_option
parameter_list|(
name|arg
parameter_list|)
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|option_value
init|=
name|NULL
decl_stmt|;
comment|/* Search for the option in the table of binary f options.  */
for|for
control|(
name|j
operator|=
name|ARRAY_SIZE
argument_list|(
name|f_options
argument_list|)
init|;
name|j
operator|--
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
name|f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|f_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
name|f_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|arg
index|[
literal|2
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|strcmp
argument_list|(
name|arg
operator|+
literal|3
argument_list|,
name|f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|f_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
operator|!
name|f_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"fast-math"
argument_list|)
condition|)
name|set_fast_math_flags
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"no-fast-math"
argument_list|)
condition|)
name|set_no_fast_math_flags
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"inline-limit-"
argument_list|)
operator|)
operator|||
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"inline-limit="
argument_list|)
operator|)
condition|)
block|{
name|int
name|val
init|=
name|read_integral_parameter
argument_list|(
name|option_value
argument_list|,
name|arg
operator|-
literal|2
argument_list|,
name|MAX_INLINE_INSNS
argument_list|)
decl_stmt|;
name|set_param_value
argument_list|(
literal|"max-inline-insns"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
elseif|else
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"sched-verbose="
argument_list|)
operator|)
condition|)
name|fix_sched_param
argument_list|(
literal|"verbose"
argument_list|,
name|option_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"fixed-"
argument_list|)
operator|)
condition|)
name|fix_register
argument_list|(
name|option_value
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"call-used-"
argument_list|)
operator|)
condition|)
name|fix_register
argument_list|(
name|option_value
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"call-saved-"
argument_list|)
operator|)
condition|)
name|fix_register
argument_list|(
name|option_value
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"align-loops="
argument_list|)
operator|)
condition|)
name|align_loops
operator|=
name|read_integral_parameter
argument_list|(
name|option_value
argument_list|,
name|arg
operator|-
literal|2
argument_list|,
name|align_loops
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"align-functions="
argument_list|)
operator|)
condition|)
name|align_functions
operator|=
name|read_integral_parameter
argument_list|(
name|option_value
argument_list|,
name|arg
operator|-
literal|2
argument_list|,
name|align_functions
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"align-jumps="
argument_list|)
operator|)
condition|)
name|align_jumps
operator|=
name|read_integral_parameter
argument_list|(
name|option_value
argument_list|,
name|arg
operator|-
literal|2
argument_list|,
name|align_jumps
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"align-labels="
argument_list|)
operator|)
condition|)
name|align_labels
operator|=
name|read_integral_parameter
argument_list|(
name|option_value
argument_list|,
name|arg
operator|-
literal|2
argument_list|,
name|align_labels
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"stack-limit-register="
argument_list|)
operator|)
condition|)
block|{
name|int
name|reg
init|=
name|decode_reg_name
argument_list|(
name|option_value
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"unrecognized register name `%s'"
argument_list|,
name|option_value
argument_list|)
expr_stmt|;
else|else
name|stack_limit_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"stack-limit-symbol="
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|nm
decl_stmt|;
name|nm
operator|=
name|ggc_strdup
argument_list|(
name|option_value
argument_list|)
expr_stmt|;
name|stack_limit_rtx
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|nm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"message-length="
argument_list|)
operator|)
condition|)
name|output_set_maximum_length
argument_list|(
operator|&
name|global_dc
operator|->
name|buffer
argument_list|,
name|read_integral_parameter
argument_list|(
name|option_value
argument_list|,
name|arg
operator|-
literal|2
argument_list|,
name|diagnostic_line_cutoff
argument_list|(
name|global_dc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"diagnostics-show-location="
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option_value
argument_list|,
literal|"once"
argument_list|)
condition|)
name|diagnostic_prefixing_rule
argument_list|(
name|global_dc
argument_list|)
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option_value
argument_list|,
literal|"every-line"
argument_list|)
condition|)
name|diagnostic_prefixing_rule
argument_list|(
name|global_dc
argument_list|)
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unrecognized option `%s'"
argument_list|,
name|arg
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"no-stack-limit"
argument_list|)
condition|)
name|stack_limit_rtx
operator|=
name|NULL_RTX
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"preprocessed"
argument_list|)
condition|)
comment|/* Recognise this switch but do nothing.  This prevents warnings        about an unrecognized switch if cpplib has not been linked in.  */
empty_stmt|;
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse a -W... command line switch.  ARG is the value after the -W.    It is safe to access 'ARG - 2' to generate the full switch name.    Return the number of strings consumed.  */
end_comment

begin_function
specifier|static
name|int
name|decode_W_option
parameter_list|(
name|arg
parameter_list|)
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|option_value
init|=
name|NULL
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Search for the option in the table of binary W options.  */
for|for
control|(
name|j
operator|=
name|ARRAY_SIZE
argument_list|(
name|W_options
argument_list|)
init|;
name|j
operator|--
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
name|W_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|W_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
name|W_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|arg
index|[
literal|2
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|strcmp
argument_list|(
name|arg
operator|+
literal|3
argument_list|,
name|W_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|W_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
operator|!
name|W_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"id-clash-"
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"-Wid-clash-LEN is no longer supported"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
literal|"larger-than-"
argument_list|)
operator|)
condition|)
block|{
name|larger_than_size
operator|=
name|read_integral_parameter
argument_list|(
name|option_value
argument_list|,
name|arg
operator|-
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|warn_larger_than
operator|=
name|larger_than_size
operator|!=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"unused"
argument_list|)
condition|)
block|{
name|set_Wunused
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"no-unused"
argument_list|)
condition|)
block|{
name|set_Wunused
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse a -g... command line switch.  ARG is the value after the -g.    It is safe to access 'ARG - 2' to generate the full switch name.    Return the number of strings consumed.  */
end_comment

begin_function
specifier|static
name|int
name|decode_g_option
parameter_list|(
name|arg
parameter_list|)
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|unsigned
name|level
init|=
literal|0
decl_stmt|;
comment|/* A lot of code assumes write_symbols == NO_DEBUG if the      debugging level is 0 (thus -gstabs1 -gstabs0 would lose track      of what debugging type has been selected).  This records the      selected type.  It is an error to specify more than one      debugging type.  */
specifier|static
name|enum
name|debug_info_type
name|selected_debug_type
init|=
name|NO_DEBUG
decl_stmt|;
comment|/* Non-zero if debugging format has been explicitly set.      -g and -ggdb don't explicitly set the debugging format so      -gdwarf -g3 is equivalent to -gdwarf3.  */
specifier|static
name|int
name|type_explicitly_set_p
init|=
literal|0
decl_stmt|;
comment|/* Indexed by enum debug_info_type.  */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|debug_type_names
index|[]
init|=
block|{
literal|"none"
block|,
literal|"stabs"
block|,
literal|"coff"
block|,
literal|"dwarf-1"
block|,
literal|"dwarf-2"
block|,
literal|"xcoff"
block|,
literal|"vms"
block|}
decl_stmt|;
comment|/* The maximum admissible debug level value.  */
specifier|static
specifier|const
name|unsigned
name|max_debug_level
init|=
literal|3
decl_stmt|;
comment|/* Look up ARG in the table.  */
for|for
control|(
name|da
operator|=
name|debug_args
init|;
name|da
operator|->
name|arg
condition|;
name|da
operator|++
control|)
block|{
specifier|const
name|int
name|da_len
init|=
name|strlen
argument_list|(
name|da
operator|->
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|da_len
operator|==
literal|0
operator|||
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
name|da
operator|->
name|arg
argument_list|,
name|da_len
argument_list|)
condition|)
block|{
name|enum
name|debug_info_type
name|type
init|=
name|da
operator|->
name|debug_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|arg
operator|+
name|da_len
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|&&
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
continue|continue;
comment|/* A debug flag without a level defaults to level 2. 	     Note we do not want to call read_integral_parameter 	     for that case since it will call atoi which 	     will return zero.  	     ??? We may want to generalize the interface to 	     read_integral_parameter to better handle this case 	     if this case shows up often.  */
if|if
condition|(
operator|*
name|p
condition|)
name|level
operator|=
name|read_integral_parameter
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|max_debug_level
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|level
operator|=
operator|(
name|level
operator|==
literal|0
operator|)
condition|?
literal|2
else|:
name|level
expr_stmt|;
if|if
condition|(
name|da_len
operator|>
literal|1
operator|&&
operator|*
name|p
operator|&&
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"dwarf"
argument_list|,
name|da_len
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"use -gdwarf -g%d for DWARF v1, level %d"
argument_list|,
name|level
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"use -gdwarf-2   for DWARF v2"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|>
name|max_debug_level
condition|)
block|{
name|warning
argument_list|(
literal|"\ ignoring option `%s' due to invalid debug level specification"
argument_list|,
name|arg
operator|-
literal|2
argument_list|)
expr_stmt|;
name|level
operator|=
name|debug_info_level
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|NO_DEBUG
condition|)
block|{
name|type
operator|=
name|PREFERRED_DEBUGGING_TYPE
expr_stmt|;
if|if
condition|(
name|da_len
operator|>
literal|1
operator|&&
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"gdb"
argument_list|,
name|da_len
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
name|type
operator|=
name|DWARF2_DEBUG
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
name|type
operator|=
name|DBX_DEBUG
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|type
operator|==
name|NO_DEBUG
condition|)
name|warning
argument_list|(
literal|"`%s': unknown or unsupported -g option"
argument_list|,
name|arg
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Does it conflict with an already selected type?  */
if|if
condition|(
name|type_explicitly_set_p
comment|/* -g/-ggdb don't conflict with anything.  */
operator|&&
name|da
operator|->
name|debug_type
operator|!=
name|NO_DEBUG
operator|&&
name|type
operator|!=
name|selected_debug_type
condition|)
name|warning
argument_list|(
literal|"`%s' ignored, conflicts with `-g%s'"
argument_list|,
name|arg
operator|-
literal|2
argument_list|,
name|debug_type_names
index|[
operator|(
name|int
operator|)
name|selected_debug_type
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If the format has already been set, -g/-ggdb 		 only change the debug level.  */
if|if
condition|(
name|type_explicitly_set_p
operator|&&
name|da
operator|->
name|debug_type
operator|==
name|NO_DEBUG
condition|)
comment|/* Don't change debugging type.  */
empty_stmt|;
else|else
block|{
name|selected_debug_type
operator|=
name|type
expr_stmt|;
name|type_explicitly_set_p
operator|=
name|da
operator|->
name|debug_type
operator|!=
name|NO_DEBUG
expr_stmt|;
block|}
name|write_symbols
operator|=
operator|(
name|level
operator|==
literal|0
condition|?
name|NO_DEBUG
else|:
name|selected_debug_type
operator|)
expr_stmt|;
name|use_gnu_debug_info_extensions
operator|=
name|da
operator|->
name|use_extensions_p
expr_stmt|;
name|debug_info_level
operator|=
operator|(
expr|enum
name|debug_info_level
operator|)
name|level
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|da
operator|->
name|arg
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Decode the first argument in the argv as a language-independent option.    Return the number of strings consumed.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|independent_decode_option
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|arg
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|arg
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
return|return
literal|0
return|;
name|filename
operator|=
name|arg
expr_stmt|;
return|return
literal|1
return|;
block|}
name|arg
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-help"
argument_list|)
condition|)
block|{
name|display_help
argument_list|()
expr_stmt|;
name|exit_after_options
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-target-help"
argument_list|)
condition|)
block|{
name|display_target_options
argument_list|()
expr_stmt|;
name|exit_after_options
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-version"
argument_list|)
condition|)
block|{
name|print_version
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit_after_options
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Handle '--param<name>=<value>'.  */
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-param"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|equal
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"-param option missing argument"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Get the '<name>=<value>' parameter.  */
name|arg
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
comment|/* Look for the `='.  */
name|equal
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|equal
condition|)
name|error
argument_list|(
literal|"invalid --param option: %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|val
decl_stmt|;
comment|/* Zero out the `=' sign so that we get two separate strings.  */
operator|*
name|equal
operator|=
literal|'\0'
expr_stmt|;
comment|/* Figure out what value is specified.  */
name|val
operator|=
name|read_integral_parameter
argument_list|(
name|equal
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|INVALID_PARAM_VAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|INVALID_PARAM_VAL
condition|)
name|set_param_value
argument_list|(
name|arg
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid parameter value `%s'"
argument_list|,
name|equal
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
if|if
condition|(
operator|*
name|arg
operator|==
literal|'Y'
condition|)
name|arg
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|arg
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
literal|'O'
case|:
comment|/* Already been treated in main (). Do nothing.  */
break|break;
case|case
literal|'m'
case|:
name|set_target_switch
argument_list|(
name|arg
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
return|return
name|decode_f_option
argument_list|(
name|arg
operator|+
literal|1
argument_list|)
return|;
case|case
literal|'g'
case|:
return|return
name|decode_g_option
argument_list|(
name|arg
operator|+
literal|1
argument_list|)
return|;
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"dumpbase"
argument_list|)
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
return|return
literal|0
return|;
name|dump_base_name
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
return|return
literal|2
return|;
block|}
else|else
name|decode_d_option
argument_list|(
name|arg
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"pedantic"
argument_list|)
condition|)
name|pedantic
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"pedantic-errors"
argument_list|)
condition|)
name|flag_pedantic_errors
operator|=
name|pedantic
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|profile_flag
operator|=
literal|1
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"quiet"
argument_list|)
condition|)
name|quiet_flag
operator|=
literal|1
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"version"
argument_list|)
condition|)
name|version_flag
operator|=
literal|1
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|extra_warnings
operator|=
literal|1
expr_stmt|;
comment|/* We save the value of warn_uninitialized, since if they put 	     -Wuninitialized on the command line, we need to generate a 	     warning about not using it without also specifying -O.  */
if|if
condition|(
name|warn_uninitialized
operator|!=
literal|1
condition|)
name|warn_uninitialized
operator|=
literal|2
expr_stmt|;
block|}
else|else
return|return
name|decode_W_option
argument_list|(
name|arg
operator|+
literal|1
argument_list|)
return|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"aux-info"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|8
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
return|return
literal|0
return|;
name|aux_info_file_name
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|flag_gen_aux_info
operator|=
literal|1
expr_stmt|;
return|return
literal|2
return|;
block|}
elseif|else
if|if
condition|(
name|arg
index|[
literal|8
index|]
operator|==
literal|'='
condition|)
block|{
name|aux_info_file_name
operator|=
name|arg
operator|+
literal|9
expr_stmt|;
name|flag_gen_aux_info
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
return|return
literal|0
return|;
name|asm_file_name
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
return|return
literal|2
return|;
block|}
return|return
literal|0
return|;
case|case
literal|'G'
case|:
block|{
name|int
name|g_switch_val
decl_stmt|;
name|int
name|return_val
decl_stmt|;
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
return|return
literal|0
return|;
name|g_switch_val
operator|=
name|read_integral_parameter
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|return_val
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|g_switch_val
operator|=
name|read_integral_parameter
argument_list|(
name|arg
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|return_val
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|g_switch_val
operator|==
operator|-
literal|1
condition|)
name|return_val
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|g_switch_set
operator|=
name|TRUE
expr_stmt|;
name|g_switch_value
operator|=
name|g_switch_val
expr_stmt|;
block|}
return|return
name|return_val
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode -m switches.  */
end_comment

begin_comment
comment|/* Decode the switch -mNAME.  */
end_comment

begin_function
specifier|static
name|void
name|set_target_switch
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|size_t
name|j
decl_stmt|;
name|int
name|valid_target_option
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|target_switches
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|target_switches
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|<
literal|0
condition|)
name|target_flags
operator|&=
operator|~
operator|-
name|target_switches
index|[
name|j
index|]
operator|.
name|value
expr_stmt|;
else|else
name|target_flags
operator||=
name|target_switches
index|[
name|j
index|]
operator|.
name|value
expr_stmt|;
name|valid_target_option
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
if|if
condition|(
operator|!
name|valid_target_option
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|target_options
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|target_options
index|[
name|j
index|]
operator|.
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|target_options
index|[
name|j
index|]
operator|.
name|prefix
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|target_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
name|name
operator|+
name|len
expr_stmt|;
name|valid_target_option
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|valid_target_option
condition|)
name|error
argument_list|(
literal|"invalid option `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print version information to FILE.    Each line begins with INDENT (for the case where FILE is the    assembler output file).  */
end_comment

begin_function
specifier|static
name|void
name|print_version
parameter_list|(
name|file
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|indent
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|__VERSION__
define|#
directive|define
name|__VERSION__
value|"[?]"
endif|#
directive|endif
name|fnotice
argument_list|(
name|file
argument_list|,
ifdef|#
directive|ifdef
name|__GNUC__
literal|"%s%s%s version %s (%s)\n%s\tcompiled by GNU C version %s.\n"
else|#
directive|else
literal|"%s%s%s version %s (%s) compiled by CC.\n"
endif|#
directive|endif
argument_list|,
name|indent
argument_list|,
operator|*
name|indent
operator|!=
literal|0
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|lang_hooks
operator|.
name|name
argument_list|,
name|version_string
argument_list|,
name|TARGET_NAME
argument_list|,
name|indent
argument_list|,
name|__VERSION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an option value and return the adjusted position in the line.    ??? We don't handle error returns from fprintf (disk full); presumably    other code will catch a disk full though.  */
end_comment

begin_function
specifier|static
name|int
name|print_single_switch
parameter_list|(
name|file
parameter_list|,
name|pos
parameter_list|,
name|max
parameter_list|,
name|indent
parameter_list|,
name|sep
parameter_list|,
name|term
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|max
decl_stmt|;
specifier|const
name|char
modifier|*
name|indent
decl_stmt|,
decl|*
name|sep
decl_stmt|,
modifier|*
name|term
decl_stmt|,
modifier|*
name|type
decl_stmt|,
modifier|*
name|name
decl_stmt|;
end_function

begin_block
block|{
comment|/* The ultrix fprintf returns 0 on success, so compute the result we want      here since we need it for the following test.  */
name|int
name|len
init|=
name|strlen
argument_list|(
name|sep
argument_list|)
operator|+
name|strlen
argument_list|(
name|type
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
literal|0
operator|&&
name|pos
operator|+
name|len
operator|>
name|max
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|pos
operator|=
name|strlen
argument_list|(
name|indent
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%s"
argument_list|,
name|sep
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|len
expr_stmt|;
return|return
name|pos
return|;
block|}
end_block

begin_comment
comment|/* Print active target switches to FILE.    POS is the current cursor position and MAX is the size of a "line".    Each line begins with INDENT and ends with TERM.    Each switch is separated from the next by SEP.  */
end_comment

begin_function
specifier|static
name|void
name|print_switch_values
parameter_list|(
name|file
parameter_list|,
name|pos
parameter_list|,
name|max
parameter_list|,
name|indent
parameter_list|,
name|sep
parameter_list|,
name|term
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|max
decl_stmt|;
specifier|const
name|char
modifier|*
name|indent
decl_stmt|,
decl|*
name|sep
decl_stmt|,
modifier|*
name|term
decl_stmt|;
end_function

begin_block
block|{
name|size_t
name|j
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
comment|/* Print the options as passed.  */
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
operator|*
name|indent
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|term
argument_list|,
name|_
argument_list|(
literal|"options passed: "
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|save_argv
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
comment|/* Ignore these.  */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
literal|"-o"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
literal|"-quiet"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
literal|"-version"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|*
name|p
operator|)
index|[
literal|1
index|]
operator|==
literal|'d'
condition|)
continue|continue;
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
name|sep
argument_list|,
name|term
argument_list|,
operator|*
name|p
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|term
argument_list|)
expr_stmt|;
comment|/* Print the -f and -m options that have been enabled.      We don't handle language specific options but printing argv      should suffice.  */
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
operator|*
name|indent
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|term
argument_list|,
name|_
argument_list|(
literal|"options enabled: "
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|f_options
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|*
name|f_options
index|[
name|j
index|]
operator|.
name|variable
operator|==
name|f_options
index|[
name|j
index|]
operator|.
name|on_value
condition|)
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
name|sep
argument_list|,
name|term
argument_list|,
literal|"-f"
argument_list|,
name|f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
comment|/* Print target specific options.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|target_switches
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|target_switches
index|[
name|j
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|>
literal|0
operator|&&
operator|(
operator|(
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|&
name|target_flags
operator|)
operator|==
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|)
condition|)
block|{
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
name|sep
argument_list|,
name|term
argument_list|,
literal|"-m"
argument_list|,
name|target_switches
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|target_options
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|*
name|target_options
index|[
name|j
index|]
operator|.
name|variable
operator|!=
name|NULL
condition|)
block|{
name|char
name|prefix
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|prefix
argument_list|,
literal|"-m%s"
argument_list|,
name|target_options
index|[
name|j
index|]
operator|.
name|prefix
argument_list|)
expr_stmt|;
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
name|sep
argument_list|,
name|term
argument_list|,
name|prefix
argument_list|,
operator|*
name|target_options
index|[
name|j
index|]
operator|.
name|variable
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Open assembly code output file.  Do this even if -fsyntax-only is    on, because then the driver will have provided the name of a    temporary file or bit bucket for us.  NAME is the file specified on    the command line, possibly NULL.  */
end_comment

begin_function
specifier|static
name|void
name|init_asm_output
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
operator|==
name|NULL
operator|&&
name|asm_file_name
operator|==
literal|0
condition|)
name|asm_out_file
operator|=
name|stdout
expr_stmt|;
else|else
block|{
if|if
condition|(
name|asm_file_name
operator|==
literal|0
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|dump_base_name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|6
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strip_off_ending
argument_list|(
name|dumpname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".s"
argument_list|)
expr_stmt|;
name|asm_file_name
operator|=
name|dumpname
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asm_file_name
argument_list|,
literal|"-"
argument_list|)
condition|)
name|asm_out_file
operator|=
name|stdout
expr_stmt|;
else|else
name|asm_out_file
operator|=
name|fopen
argument_list|(
name|asm_file_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_out_file
operator|==
literal|0
condition|)
name|fatal_io_error
argument_list|(
literal|"can't open %s for writing"
argument_list|,
name|asm_file_name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IO_BUFFER_SIZE
name|setvbuf
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|IO_BUFFER_SIZE
argument_list|)
argument_list|,
name|_IOFBF
argument_list|,
name|IO_BUFFER_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|flag_syntax_only
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_FILE_START
name|ASM_FILE_START
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_COMMENT_START
if|if
condition|(
name|flag_verbose_asm
condition|)
block|{
comment|/* Print the list of options in effect.  */
name|print_version
argument_list|(
name|asm_out_file
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|print_switch_values
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|,
name|MAX_LINE
argument_list|,
name|ASM_COMMENT_START
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Add a blank line here so it appears in assembler output but not 	     screen output.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialization of the front end environment, before command line    options are parsed.  Signal handlers, internationalization etc.    ARGV0 is main's argv[0].  */
end_comment

begin_function
specifier|static
name|void
name|general_init
parameter_list|(
name|argv0
parameter_list|)
name|char
modifier|*
name|argv0
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|argv0
operator|+
name|strlen
argument_list|(
name|argv0
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|argv0
operator|&&
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|p
expr_stmt|;
name|progname
operator|=
name|p
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|progname
argument_list|)
expr_stmt|;
name|gcc_init_libintl
argument_list|()
expr_stmt|;
comment|/* Install handler for SIGFPE, which may be received while we do      compile-time floating point arithmetic.  */
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_signal
argument_list|)
expr_stmt|;
comment|/* Trap fatal signals, e.g. SIGSEGV, and convert them to ICE messages.  */
ifdef|#
directive|ifdef
name|SIGSEGV
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGILL
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGBUS
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGABRT
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
name|SIGIOT
operator|&&
operator|(
operator|!
name|defined
name|SIGABRT
operator|||
name|SIGABRT
operator|!=
name|SIGIOT
operator|)
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize the diagnostics reporting machinery, so option parsing      can give warnings and errors.  */
name|diagnostic_initialize
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse command line options and set default flag values, called    after language-independent option-independent initialization.  Do    minimal options processing.  Outputting diagnostics is OK, but GC    and identifier hashtables etc. are not initialized yet.  */
end_comment

begin_function
specifier|static
name|void
name|parse_options_and_default_flags
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Save in case md file wants to emit args as a comment.  */
name|save_argc
operator|=
name|argc
expr_stmt|;
name|save_argv
operator|=
name|argv
expr_stmt|;
comment|/* Initialize register usage now so switches may override.  */
name|init_reg_sets
argument_list|()
expr_stmt|;
comment|/* Register the language-independent parameters.  */
name|add_params
argument_list|(
name|lang_independent_params
argument_list|,
name|LAST_PARAM
argument_list|)
expr_stmt|;
comment|/* Perform language-specific options initialization.  */
call|(
modifier|*
name|lang_hooks
operator|.
name|init_options
call|)
argument_list|()
expr_stmt|;
comment|/* Scan to see what optimization level has been specified.  That will      determine the default value of many flags.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-O"
argument_list|)
condition|)
block|{
name|optimize
operator|=
literal|1
expr_stmt|;
name|optimize_size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'O'
condition|)
block|{
comment|/* Handle -Os, -O2, -O3, -O69, ...  */
name|char
modifier|*
name|p
init|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|optimize_size
operator|=
literal|1
expr_stmt|;
comment|/* Optimizing for size forces optimize to be 2.  */
name|optimize
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|optimize_val
init|=
name|read_integral_parameter
argument_list|(
name|p
argument_list|,
name|p
operator|-
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|optimize_val
operator|!=
operator|-
literal|1
condition|)
block|{
name|optimize
operator|=
name|optimize_val
expr_stmt|;
ifdef|#
directive|ifdef
name|FORCE_OPTIMIZATION_DOWNGRADE
warning|#
directive|warning
warning|FORCE_OPTIMIZATION_DOWNGRADE
if|if
condition|(
name|optimize
operator|>
name|FORCE_OPTIMIZATION_DOWNGRADE
condition|)
block|{
name|optimize
operator|=
name|FORCE_OPTIMIZATION_DOWNGRADE
expr_stmt|;
name|warning
argument_list|(
literal|"\n***\n***\t-O%d converted to \"-O%d\" due to optimizer bugs on this platform\n***"
argument_list|,
name|optimize_val
argument_list|,
name|FORCE_OPTIMIZATION_DOWNGRADE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*FORCE_OPTIMIZATION_DOWNGRADE*/
if|#
directive|if
name|defined
argument_list|(
name|TRY_WITHOUT_THIS__alpha__
argument_list|)
if|if
condition|(
name|optimize
operator|>
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"\n***\n***\tThe -O%d flag TRIGGERS KNOWN OPTIMIZER BUGS ON THIS PLATFORM\n***"
argument_list|,
name|optimize_val
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*__alpha__*/
name|optimize_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|optimize
condition|)
block|{
name|flag_merge_constants
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|>=
literal|1
condition|)
block|{
name|flag_defer_pop
operator|=
literal|1
expr_stmt|;
name|flag_thread_jumps
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DELAY_SLOTS
name|flag_delayed_branch
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CAN_DEBUG_WITHOUT_FP
name|flag_omit_frame_pointer
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|flag_guess_branch_prob
operator|=
literal|1
expr_stmt|;
name|flag_cprop_registers
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|>=
literal|2
condition|)
block|{
name|flag_optimize_sibling_calls
operator|=
literal|1
expr_stmt|;
name|flag_cse_follow_jumps
operator|=
literal|1
expr_stmt|;
name|flag_cse_skip_blocks
operator|=
literal|1
expr_stmt|;
name|flag_gcse
operator|=
literal|1
expr_stmt|;
name|flag_expensive_optimizations
operator|=
literal|1
expr_stmt|;
name|flag_strength_reduce
operator|=
literal|1
expr_stmt|;
name|flag_rerun_cse_after_loop
operator|=
literal|1
expr_stmt|;
name|flag_rerun_loop_opt
operator|=
literal|1
expr_stmt|;
name|flag_caller_saves
operator|=
literal|1
expr_stmt|;
name|flag_force_mem
operator|=
literal|1
expr_stmt|;
name|flag_peephole2
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
name|flag_schedule_insns
operator|=
literal|1
expr_stmt|;
name|flag_schedule_insns_after_reload
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|flag_regmove
operator|=
literal|1
expr_stmt|;
name|flag_strict_aliasing
operator|=
literal|1
expr_stmt|;
name|flag_delete_null_pointer_checks
operator|=
literal|1
expr_stmt|;
name|flag_reorder_blocks
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|>=
literal|3
condition|)
block|{
name|flag_inline_functions
operator|=
literal|1
expr_stmt|;
name|flag_rename_registers
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|optimize_size
condition|)
block|{
name|align_loops
operator|=
literal|1
expr_stmt|;
name|align_jumps
operator|=
literal|1
expr_stmt|;
name|align_labels
operator|=
literal|1
expr_stmt|;
name|align_functions
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Initialize whether `char' is signed.  */
name|flag_signed_char
operator|=
name|DEFAULT_SIGNED_CHAR
expr_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_SHORT_ENUMS
comment|/* Initialize how much space enums occupy, by default.  */
name|flag_short_enums
operator|=
name|DEFAULT_SHORT_ENUMS
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize target_flags before OPTIMIZATION_OPTIONS so the latter can      modify it.  */
name|target_flags
operator|=
literal|0
expr_stmt|;
name|set_target_switch
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Unwind tables are always present in an ABI-conformant IA-64      object file, so the default should be ON.  */
ifdef|#
directive|ifdef
name|IA64_UNWIND_INFO
name|flag_unwind_tables
operator|=
name|IA64_UNWIND_INFO
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPTIMIZATION_OPTIONS
comment|/* Allow default optimizations to be specified on a per-machine basis.  */
name|OPTIMIZATION_OPTIONS
argument_list|(
name|optimize
argument_list|,
name|optimize_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Perform normal command line switch decoding.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
control|)
block|{
name|int
name|lang_processed
decl_stmt|;
name|int
name|indep_processed
decl_stmt|;
comment|/* Give the language a chance to decode the option for itself.  */
name|lang_processed
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|decode_option
call|)
argument_list|(
name|argc
operator|-
name|i
argument_list|,
name|argv
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|lang_processed
operator|>=
literal|0
condition|)
comment|/* Now see if the option also has a language independent meaning. 	   Some options are both language specific and language independent, 	   eg --help.  */
name|indep_processed
operator|=
name|independent_decode_option
argument_list|(
name|argc
operator|-
name|i
argument_list|,
name|argv
operator|+
name|i
argument_list|)
expr_stmt|;
else|else
block|{
name|lang_processed
operator|=
operator|-
name|lang_processed
expr_stmt|;
name|indep_processed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lang_processed
operator|||
name|indep_processed
condition|)
name|i
operator|+=
name|MAX
argument_list|(
name|lang_processed
argument_list|,
name|indep_processed
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|option
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|lang
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
comment|/* It is possible that the command line switch is not valid for the 	     current language, but it is valid for another language.  In order 	     to be compatible with previous versions of the compiler (which 	     did not issue an error message in this case) we check for this 	     possibility here.  If we do find a match, then if extra_warnings 	     is set we generate a warning message, otherwise we will just 	     ignore the option.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|documented_lang_options
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|option
operator|=
name|documented_lang_options
index|[
name|j
index|]
operator|.
name|option
expr_stmt|;
if|if
condition|(
name|option
operator|==
name|NULL
condition|)
name|lang
operator|=
name|documented_lang_options
index|[
name|j
index|]
operator|.
name|description
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|option
argument_list|,
name|strlen
argument_list|(
name|option
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|!=
name|ARRAY_SIZE
argument_list|(
name|documented_lang_options
argument_list|)
condition|)
block|{
if|if
condition|(
name|extra_warnings
condition|)
block|{
name|warning
argument_list|(
literal|"ignoring command line option '%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|lang
condition|)
name|warning
argument_list|(
literal|"(it is valid for %s but not the selected language)"
argument_list|,
name|lang
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'g'
condition|)
name|warning
argument_list|(
literal|"`%s': unknown or unsupported -g option"
argument_list|,
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unrecognized option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_no_inline
operator|==
literal|2
condition|)
name|flag_no_inline
operator|=
literal|0
expr_stmt|;
else|else
name|flag_really_no_inline
operator|=
name|flag_no_inline
expr_stmt|;
comment|/* Set flag_no_inline before the post_options () hook.  The C front      ends use it to determine tree inlining defaults.  FIXME: such      code should be lang-independent when all front ends use tree      inlining, in which case it, and this condition, should be moved      to the top of process_options() instead.  */
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
block|{
comment|/* Inlining does not work if not optimizing, 	 so force it not to be done.  */
name|flag_no_inline
operator|=
literal|1
expr_stmt|;
name|warn_inline
operator|=
literal|0
expr_stmt|;
comment|/* The c_decode_option function and decode_option hook set 	 this to `2' if -Wall is used, so we can avoid giving out 	 lots of errors for people who don't realize what -Wall does.  */
if|if
condition|(
name|warn_uninitialized
operator|==
literal|1
condition|)
name|warning
argument_list|(
literal|"-Wuninitialized is not supported without -O"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_really_no_inline
operator|==
literal|2
condition|)
name|flag_really_no_inline
operator|=
name|flag_no_inline
expr_stmt|;
comment|/* All command line options have been parsed; allow the front end to      perform consistency checks, etc.  */
call|(
modifier|*
name|lang_hooks
operator|.
name|post_options
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process the options that have been parsed.  */
end_comment

begin_function
specifier|static
name|void
name|process_options
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|OVERRIDE_OPTIONS
comment|/* Some machines may reject certain combinations of options.  */
name|OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
comment|/* Set up the align_*_log variables, defaulting them to 1 if they      were still unset.  */
if|if
condition|(
name|align_loops
operator|<=
literal|0
condition|)
name|align_loops
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|align_loops_max_skip
operator|>
name|align_loops
operator|||
operator|!
name|align_loops
condition|)
name|align_loops_max_skip
operator|=
name|align_loops
operator|-
literal|1
expr_stmt|;
name|align_loops_log
operator|=
name|floor_log2
argument_list|(
name|align_loops
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_jumps
operator|<=
literal|0
condition|)
name|align_jumps
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|align_jumps_max_skip
operator|>
name|align_jumps
operator|||
operator|!
name|align_jumps
condition|)
name|align_jumps_max_skip
operator|=
name|align_jumps
operator|-
literal|1
expr_stmt|;
name|align_jumps_log
operator|=
name|floor_log2
argument_list|(
name|align_jumps
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_labels
operator|<=
literal|0
condition|)
name|align_labels
operator|=
literal|1
expr_stmt|;
name|align_labels_log
operator|=
name|floor_log2
argument_list|(
name|align_labels
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_labels_max_skip
operator|>
name|align_labels
operator|||
operator|!
name|align_labels
condition|)
name|align_labels_max_skip
operator|=
name|align_labels
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|align_functions
operator|<=
literal|0
condition|)
name|align_functions
operator|=
literal|1
expr_stmt|;
name|align_functions_log
operator|=
name|floor_log2
argument_list|(
name|align_functions
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Unrolling all loops implies that standard loop unrolling must also      be done.  */
if|if
condition|(
name|flag_unroll_all_loops
condition|)
name|flag_unroll_loops
operator|=
literal|1
expr_stmt|;
comment|/* Loop unrolling requires that strength_reduction be on also.  Silently      turn on strength reduction here if it isn't already on.  Also, the loop      unrolling code assumes that cse will be run after loop, so that must      be turned on also.  */
if|if
condition|(
name|flag_unroll_loops
condition|)
block|{
name|flag_strength_reduce
operator|=
literal|1
expr_stmt|;
name|flag_rerun_cse_after_loop
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flag_non_call_exceptions
condition|)
name|flag_asynchronous_unwind_tables
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_asynchronous_unwind_tables
condition|)
name|flag_unwind_tables
operator|=
literal|1
expr_stmt|;
comment|/* Warn about options that are not supported on this machine.  */
ifndef|#
directive|ifndef
name|INSN_SCHEDULING
if|if
condition|(
name|flag_schedule_insns
operator|||
name|flag_schedule_insns_after_reload
condition|)
name|warning
argument_list|(
literal|"instruction scheduling not supported on this target machine"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|DELAY_SLOTS
if|if
condition|(
name|flag_delayed_branch
condition|)
name|warning
argument_list|(
literal|"this target machine does not have delayed branches"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Some operating systems do not allow profiling without a frame      pointer.  */
if|if
condition|(
operator|!
name|TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER
operator|&&
name|profile_flag
operator|&&
name|flag_omit_frame_pointer
condition|)
block|{
name|error
argument_list|(
literal|"profiling does not work without a frame pointer"
argument_list|)
expr_stmt|;
name|flag_omit_frame_pointer
operator|=
literal|0
expr_stmt|;
block|}
name|user_label_prefix
operator|=
name|USER_LABEL_PREFIX
expr_stmt|;
if|if
condition|(
name|flag_leading_underscore
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* If the default prefix is more complicated than "" or "_", 	 issue a warning and ignore this option.  */
if|if
condition|(
name|user_label_prefix
index|[
literal|0
index|]
operator|==
literal|0
operator|||
operator|(
name|user_label_prefix
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|user_label_prefix
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|user_label_prefix
operator|=
name|flag_leading_underscore
condition|?
literal|"_"
else|:
literal|""
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"-f%sleading-underscore not supported on this target machine"
argument_list|,
name|flag_leading_underscore
condition|?
literal|""
else|:
literal|"no-"
argument_list|)
expr_stmt|;
block|}
comment|/* If we are in verbose mode, write out the version and maybe all the      option flags in use.  */
if|if
condition|(
name|version_flag
condition|)
block|{
name|print_version
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|print_switch_values
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|,
name|MAX_LINE
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|time_report
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_syntax_only
condition|)
block|{
name|write_symbols
operator|=
name|NO_DEBUG
expr_stmt|;
name|profile_flag
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now we know write_symbols, set up the debug hooks based on it.      By default we do nothing for debug output.  */
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|dbx_debug_hooks
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|xcoff_debug_hooks
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|sdb_debug_hooks
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|dwarf_debug_hooks
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|dwarf2_debug_hooks
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|VMS_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|vmsdbg_debug_hooks
expr_stmt|;
endif|#
directive|endif
comment|/* If auxiliary info generation is desired, open the output file.      This goes in the same directory as the source file--unlike      all the other output files.  */
if|if
condition|(
name|flag_gen_aux_info
condition|)
block|{
name|aux_info_file
operator|=
name|fopen
argument_list|(
name|aux_info_file_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux_info_file
operator|==
literal|0
condition|)
name|fatal_io_error
argument_list|(
literal|"can't open %s"
argument_list|,
name|aux_info_file_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|targetm
operator|.
name|have_named_sections
condition|)
block|{
if|if
condition|(
name|flag_function_sections
condition|)
block|{
name|warning
argument_list|(
literal|"-ffunction-sections not supported for this target"
argument_list|)
expr_stmt|;
name|flag_function_sections
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag_data_sections
condition|)
block|{
name|warning
argument_list|(
literal|"-fdata-sections not supported for this target"
argument_list|)
expr_stmt|;
name|flag_data_sections
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_function_sections
operator|&&
name|profile_flag
condition|)
block|{
name|warning
argument_list|(
literal|"-ffunction-sections disabled; it makes profiling impossible"
argument_list|)
expr_stmt|;
name|flag_function_sections
operator|=
literal|0
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|HAVE_prefetch
if|if
condition|(
name|flag_prefetch_loop_arrays
condition|)
block|{
name|warning
argument_list|(
literal|"-fprefetch-loop-arrays not supported for this target"
argument_list|)
expr_stmt|;
name|flag_prefetch_loop_arrays
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|flag_prefetch_loop_arrays
operator|&&
operator|!
name|HAVE_prefetch
condition|)
block|{
name|warning
argument_list|(
literal|"-fprefetch-loop-arrays not supported for this target (try -march switches)"
argument_list|)
expr_stmt|;
name|flag_prefetch_loop_arrays
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* This combination of options isn't handled for i386 targets and doesn't      make much sense anyway, so don't allow it.  */
if|if
condition|(
name|flag_prefetch_loop_arrays
operator|&&
name|optimize_size
condition|)
block|{
name|warning
argument_list|(
literal|"-fprefetch-loop-arrays is not supported with -Os"
argument_list|)
expr_stmt|;
name|flag_prefetch_loop_arrays
operator|=
literal|0
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OBJECT_FORMAT_ELF
if|if
condition|(
name|flag_function_sections
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|warning
argument_list|(
literal|"-ffunction-sections may affect debugging on some targets"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Language-independent initialization, before language-dependent    initialization.  */
end_comment

begin_function
specifier|static
name|void
name|lang_independent_init
parameter_list|()
block|{
name|decl_printable_name
operator|=
name|decl_name
expr_stmt|;
name|lang_expand_expr
operator|=
operator|(
name|lang_expand_expr_t
operator|)
name|do_abort
expr_stmt|;
comment|/* Set the language-dependent identifier size.  */
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|IDENTIFIER_NODE
index|]
operator|=
operator|(
operator|(
name|lang_hooks
operator|.
name|identifier_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|)
expr_stmt|;
comment|/* Initialize the garbage-collector, and string pools.  */
name|init_ggc
argument_list|()
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|stack_limit_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|current_function_decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|current_function_func_begin_label
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|init_stringpool
argument_list|()
expr_stmt|;
name|init_obstacks
argument_list|()
expr_stmt|;
name|init_emit_once
argument_list|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NORMAL
operator|||
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
ifdef|#
directive|ifdef
name|VMS_DEBUGGING_INFO
comment|/* Enable line number info for traceback */
operator|||
name|debug_info_level
operator|>
name|DINFO_LEVEL_NONE
endif|#
directive|endif
operator|||
name|flag_test_coverage
operator|||
name|warn_notreached
argument_list|)
expr_stmt|;
name|init_regs
argument_list|()
expr_stmt|;
name|init_alias_once
argument_list|()
expr_stmt|;
name|init_stmt
argument_list|()
expr_stmt|;
name|init_loop
argument_list|()
expr_stmt|;
name|init_reload
argument_list|()
expr_stmt|;
name|init_function_once
argument_list|()
expr_stmt|;
name|init_stor_layout_once
argument_list|()
expr_stmt|;
name|init_varasm_once
argument_list|()
expr_stmt|;
name|init_EXPR_INSN_LIST_cache
argument_list|()
expr_stmt|;
comment|/* The following initialization functions need to generate rtl, so      provide a dummy function context for them.  */
name|init_dummy_function_start
argument_list|()
expr_stmt|;
name|init_expmed
argument_list|()
expr_stmt|;
name|init_expr_once
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_caller_saves
condition|)
name|init_caller_save
argument_list|()
expr_stmt|;
name|expand_dummy_function_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Language-dependent initialization.  Returns non-zero on success.  */
end_comment

begin_function
specifier|static
name|int
name|lang_dependent_init
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|dump_base_name
operator|==
literal|0
condition|)
name|dump_base_name
operator|=
name|name
condition|?
name|name
else|:
literal|"gccdump"
expr_stmt|;
comment|/* Front-end initialization.  This hook can assume that GC,      identifier hashes etc. are set up, but debug initialization is      not done yet.  This routine must return the original filename      (e.g. foo.i -> foo.c) so can correctly initialize debug output.  */
name|name
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|init
call|)
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Is this duplication necessary?  */
name|name
operator|=
name|ggc_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|main_input_filename
operator|=
name|input_filename
operator|=
name|name
expr_stmt|;
name|init_asm_output
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* These create various _DECL nodes, so need to be called after the      front end is initialized.  */
name|init_eh
argument_list|()
expr_stmt|;
name|init_optabs
argument_list|()
expr_stmt|;
comment|/* Put an entry on the input file stack for the main input file.  */
name|push_srcloc
argument_list|(
name|input_filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If dbx symbol table desired, initialize writing it and output the      predefined types.  */
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Now we have the correct original filename, we can initialize      debug output.  */
call|(
modifier|*
name|debug_hooks
operator|->
name|init
call|)
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clean up: close opened files, etc.  */
end_comment

begin_function
specifier|static
name|void
name|finalize
parameter_list|()
block|{
comment|/* Close the dump files.  */
if|if
condition|(
name|flag_gen_aux_info
condition|)
block|{
name|fclose
argument_list|(
name|aux_info_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorcount
condition|)
name|unlink
argument_list|(
name|aux_info_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* Close non-debugging input and output files.  Take special care to note      whether fclose returns an error, since the pages might still be on the      buffer chain while the file is open.  */
if|if
condition|(
name|asm_out_file
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|asm_out_file
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_io_error
argument_list|(
literal|"error writing to %s"
argument_list|,
name|asm_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|asm_out_file
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_io_error
argument_list|(
literal|"error closing %s"
argument_list|,
name|asm_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* Do whatever is necessary to finish printing the graphs.  */
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|DFI_MAX
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|dump_file
index|[
name|i
index|]
operator|.
name|initialized
operator|&&
name|dump_file
index|[
name|i
index|]
operator|.
name|graph_dump_p
condition|)
block|{
name|char
name|seq
index|[
literal|16
index|]
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
name|sprintf
argument_list|(
name|seq
argument_list|,
name|DUMPFILE_FORMAT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|concat
argument_list|(
name|seq
argument_list|,
name|dump_file
index|[
name|i
index|]
operator|.
name|extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mem_report
condition|)
block|{
name|ggc_print_statistics
argument_list|()
expr_stmt|;
name|stringpool_statistics
argument_list|()
expr_stmt|;
name|dump_tree_statistics
argument_list|()
expr_stmt|;
block|}
comment|/* Free up memory for the benefit of leak detectors.  */
name|free_reg_info
argument_list|()
expr_stmt|;
comment|/* Language-specific end of compilation actions.  */
call|(
modifier|*
name|lang_hooks
operator|.
name|finish
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the compiler, and compile the input file.  */
end_comment

begin_function
specifier|static
name|void
name|do_compile
parameter_list|()
block|{
comment|/* The bulk of command line switch processing.  */
name|process_options
argument_list|()
expr_stmt|;
comment|/* We cannot start timing until after options are processed since that      says if we run timers or not.  */
name|init_timevar
argument_list|()
expr_stmt|;
name|timevar_start
argument_list|(
name|TV_TOTAL
argument_list|)
expr_stmt|;
comment|/* Language-independent initialization.  Also sets up GC, identifier      hashes etc.  */
name|lang_independent_init
argument_list|()
expr_stmt|;
comment|/* Language-dependent initialization.  Returns true on success.  */
if|if
condition|(
name|lang_dependent_init
argument_list|(
name|filename
argument_list|)
condition|)
name|compile_file
argument_list|()
expr_stmt|;
name|finalize
argument_list|()
expr_stmt|;
comment|/* Stop timing and print the times.  */
name|timevar_stop
argument_list|(
name|TV_TOTAL
argument_list|)
expr_stmt|;
name|timevar_print
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Entry point of cc1, cc1plus, jc1, f771, etc.    Decode command args, then call compile_file.    Exit code is FATAL_EXIT_CODE if can't open files or if there were    any errors, or SUCCESS_EXIT_CODE if compilation succeeded.     It is not safe to call this function more than once.  */
end_comment

begin_function
name|int
name|toplev_main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|hex_init
argument_list|()
expr_stmt|;
comment|/* Initialization of GCC's environment, and diagnostics.  */
name|general_init
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Parse the options and do minimal processing; basically just      enough to default flags appropriately.  */
name|parse_options_and_default_flags
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* Exit early if we can (e.g. -help).  */
if|if
condition|(
operator|!
name|errorcount
operator|&&
operator|!
name|exit_after_options
condition|)
name|do_compile
argument_list|()
expr_stmt|;
if|if
condition|(
name|errorcount
operator|||
name|sorrycount
condition|)
return|return
operator|(
name|FATAL_EXIT_CODE
operator|)
return|;
return|return
operator|(
name|SUCCESS_EXIT_CODE
operator|)
return|;
block|}
end_function

end_unit

