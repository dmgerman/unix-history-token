begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Top level of GNU C compiler    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* This is the top level of cc1/c++.    It parses command args, opens files, invokes the various passes    in the proper order, and counts the time used by each.    Error messages and low-level interface to malloc also handled here.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_undef
undef|#
directive|undef
name|FLOAT
end_undef

begin_comment
comment|/* This is for hpux. They should change hpux.  */
end_comment

begin_undef
undef|#
directive|undef
name|FFS
end_undef

begin_comment
comment|/* Some systems define this in param.h.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_RESOURCE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIMES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"dwarfout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
end_if

begin_include
include|#
directive|include
file|"dwarf2out.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
end_if

begin_include
include|#
directive|include
file|"dbxout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"sdbout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* The extra parameters substantially improve the I/O performance.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|vms_fopen
parameter_list|(
name|fname
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
block|{
comment|/* The<stdio.h> in the gcc-vms-1.42 distribution prototypes fopen with two      fixed arguments, which matches ANSI's specification but not VAXCRTL's      pre-ANSI implementation.  This hack circumvents the mismatch problem.  */
name|FILE
modifier|*
function_decl|(
modifier|*
name|vmslib_fopen
function_decl|)
parameter_list|()
init|=
operator|(
name|FILE
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|fopen
function_decl|;
if|if
condition|(
operator|*
name|type
operator|==
literal|'w'
condition|)
return|return
call|(
modifier|*
name|vmslib_fopen
call|)
argument_list|(
name|fname
argument_list|,
name|type
argument_list|,
literal|"mbc=32"
argument_list|,
literal|"deq=64"
argument_list|,
literal|"fop=tef"
argument_list|,
literal|"shr=nil"
argument_list|)
return|;
else|else
return|return
call|(
modifier|*
name|vmslib_fopen
call|)
argument_list|(
name|fname
argument_list|,
name|type
argument_list|,
literal|"mbc=32"
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|fopen
value|vms_fopen
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_GDB_EXTENSIONS
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_GDB_EXTENSIONS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If more than one debugging type is supported, you must define    PREFERRED_DEBUGGING_TYPE to choose a format in a system-dependent way.      This is one long line cause VAXC can't handle a \-newline.  */
end_comment

begin_if
if|#
directive|if
literal|1
operator|<
operator|(
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|+
name|defined
argument_list|(
name|SDB_DEBUGGING_INFO
argument_list|)
operator|+
name|defined
argument_list|(
name|DWARF_DEBUGGING_INFO
argument_list|)
operator|+
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
operator|+
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
operator|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|PREFERRED_DEBUGGING_TYPE
end_ifndef

begin_expr_stmt
name|You
name|Lose
operator|!
name|You
name|must
name|define
name|PREFERRED_DEBUGGING_TYPE
operator|!
endif|#
directive|endif
comment|/* no PREFERRED_DEBUGGING_TYPE */
else|#
directive|else
comment|/* Only one debugging format supported.  Define PREFERRED_DEBUGGING_TYPE 	 so the following code needn't care.  */
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
define|#
directive|define
name|PREFERRED_DEBUGGING_TYPE
value|DBX_DEBUG
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
define|#
directive|define
name|PREFERRED_DEBUGGING_TYPE
value|SDB_DEBUG
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
define|#
directive|define
name|PREFERRED_DEBUGGING_TYPE
value|DWARF_DEBUG
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
define|#
directive|define
name|PREFERRED_DEBUGGING_TYPE
value|DWARF2_DEBUG
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
define|#
directive|define
name|PREFERRED_DEBUGGING_TYPE
value|XCOFF_DEBUG
endif|#
directive|endif
endif|#
directive|endif
comment|/* More than one debugger format enabled.  */
comment|/* If still not defined, must have been because no debugging formats    are supported.  */
ifndef|#
directive|ifndef
name|PREFERRED_DEBUGGING_TYPE
define|#
directive|define
name|PREFERRED_DEBUGGING_TYPE
value|NO_DEBUG
endif|#
directive|endif
ifndef|#
directive|ifndef
name|DIR_SEPARATOR
define|#
directive|define
name|DIR_SEPARATOR
value|'/'
endif|#
directive|endif
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|VMS
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|)
specifier|extern
name|char
operator|*
operator|*
name|environ
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|,
modifier|*
name|language_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Carry information from ASM_DECLARE_OBJECT_NAME    to ASM_FINISH_DECLARE_OBJECT.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|size_directive_output
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|last_assemble_variable_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|init_parse
name|PVPROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|finish_parse
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_decl_processing
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_obstacks
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_tree_codes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_rtl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_regs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_optabs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_stmt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_reg_sets
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dump_flow_info
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dump_sched_info
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dump_local_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|regset_release_memory
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_rtl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_rtl_with_bb
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rest_of_decl_compilation
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|error_with_file_and_line
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|s
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|error_with_decl
name|PVPROTO
argument_list|(
operator|(
name|tree
name|decl
operator|,
specifier|const
name|char
operator|*
name|s
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|error_for_asm
name|PVPROTO
argument_list|(
operator|(
name|rtx
name|insn
operator|,
specifier|const
name|char
operator|*
name|s
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|notice
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|s
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|error
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|s
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fatal
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|s
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|warning_with_file_and_line
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|s
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|warning_with_decl
name|PVPROTO
argument_list|(
operator|(
name|tree
name|decl
operator|,
specifier|const
name|char
operator|*
name|s
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|warning
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|s
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pedwarn
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|s
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pedwarn_with_decl
name|PVPROTO
argument_list|(
operator|(
name|tree
name|decl
operator|,
specifier|const
name|char
operator|*
name|s
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pedwarn_with_file_and_line
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|s
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sorry
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|s
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_target_switch
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|decl_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmessage
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|v_message_with_file_and_line
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|v_message_with_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|file_and_line_for_asm
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|v_error_with_file_and_line
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|v_error_with_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|v_error_for_asm
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|verror
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vfatal
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|v_warning_with_file_and_line
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|v_warning_with_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|v_warning_for_asm
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vwarning
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vpedwarn
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|v_pedwarn_with_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|v_pedwarn_with_file_and_line
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vsorry
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|float_signal
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pipe_closed
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_IDENTIFY_LANGUAGE
end_ifdef

begin_comment
comment|/* This might or might not be used in ASM_IDENTIFY_LANGUAGE. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|output_lang_identify
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|open_dump_file
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|close_dump_file
name|PROTO
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|FILE
operator|*
argument_list|,
name|rtx
argument_list|)
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_rtl
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|FILE
operator|*
argument_list|,
name|rtx
argument_list|)
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clean_dump_file
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compile_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_help
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_version
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_single_switch
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_switch_values
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_rtl_graph_with_bb
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|clean_graph_dump_file
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|finish_graph_dump_file
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of line when printing switch values.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LINE
value|75
end_define

begin_comment
comment|/* Name of program invoked, sans directories.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy of arguments to main.  */
end_comment

begin_decl_stmt
name|int
name|save_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|save_argv
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Name of current original source file (what was input to cpp).    This comes from each #-command in the actual input.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of top-level original source file (what was input to cpp).    This comes from the #-command at the beginning of the actual input.    If there isn't any there, then this is the cc1 input file name.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|main_input_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current line number in real source file.  */
end_comment

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if it is unsafe to create any new pseudo registers.  */
end_comment

begin_decl_stmt
name|int
name|no_new_pseudos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of currently pending input files.  */
end_comment

begin_decl_stmt
name|struct
name|file_stack
modifier|*
name|input_file_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incremented on each change to input_file_stack.  */
end_comment

begin_decl_stmt
name|int
name|input_file_stack_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FUNCTION_DECL for function now being parsed or compiled.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name to use as base of names for dump output files.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|dump_base_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bit flags that specify the machine subtype we are compiling for.    Bits are tested using macros TARGET_... defined in the tm.h file    and set by `-m...' switches.  Must be defined in rtlanal.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|target_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags saying which kinds of debugging dump have been requested.  */
end_comment

begin_decl_stmt
name|int
name|rtl_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rtl_dump_and_exit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|jump_opt_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|addressof_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cse_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gcse_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|loop_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cse2_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|branch_prob_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flow_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|combine_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|regmove_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sched_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|local_reg_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|global_reg_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flow2_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sched2_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|jump2_opt_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DELAY_SLOTS
end_ifdef

begin_decl_stmt
name|int
name|dbr_sched_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|flag_print_asm_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_REGS
end_ifdef

begin_decl_stmt
name|int
name|stack_reg_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MACHINE_DEPENDENT_REORG
end_ifdef

begin_decl_stmt
name|int
name|mach_dep_reorg_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|enum
name|graph_dump_types
name|graph_dump_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name for output file of assembly code, specified with -o.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|asm_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of the -G xx switch, and whether it was passed or not.  */
end_comment

begin_decl_stmt
name|int
name|g_switch_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|g_switch_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type(s) of debugging information we are producing (if any).    See flags.h for the definitions of the different possible    types of debugging information.  */
end_comment

begin_decl_stmt
name|enum
name|debug_info_type
name|write_symbols
init|=
name|NO_DEBUG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Level of debugging information we are producing.  See flags.h    for the definitions of the different possible levels.  */
end_comment

begin_decl_stmt
name|enum
name|debug_info_level
name|debug_info_level
init|=
name|DINFO_LEVEL_NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means use GNU-only extensions in the generated symbolic    debugging information.  */
end_comment

begin_comment
comment|/* Currently, this only has an effect when write_symbols is set to    DBX_DEBUG, XCOFF_DEBUG, or DWARF_DEBUG.  */
end_comment

begin_decl_stmt
name|int
name|use_gnu_debug_info_extensions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do optimizations.  -O.    Particular numeric values stand for particular amounts of optimization;    thus, -O2 stores 2 here.  However, the optimizations beyond the basic    ones are not controlled directly by this variable.  Instead, they are    controlled by individual `flag_...' variables that are defaulted    based on this variable.  */
end_comment

begin_decl_stmt
name|int
name|optimize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means optimize for size.  -Os.    The only valid values are zero and non-zero. When optimize_size is    non-zero, optimize defaults to 2, but certain individual code    bloating optimizations are disabled.  */
end_comment

begin_decl_stmt
name|int
name|optimize_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of error messages and warning messages so far.  */
end_comment

begin_decl_stmt
name|int
name|errorcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warningcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sorrycount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to function to compute the name to use to print a declaration.    DECL is the declaration in question.    VERBOSITY determines what information will be printed:      0: DECL_NAME, demangled as necessary.      1: and scope information.      2: and any other information that might be interesting, such as function         parameter types in C++.  */
end_comment

begin_macro
name|char
end_macro

begin_expr_stmt
operator|*
operator|(
operator|*
name|decl_printable_name
operator|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Pointer to function to compute rtl for a language-specific tree code.  */
end_comment

begin_typedef
typedef|typedef
name|rtx
argument_list|(
argument|*lang_expand_expr_t
argument_list|)
name|PROTO
argument_list|(
operator|(
expr|union
name|tree_node
operator|*
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|expand_modifier
name|modifier
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_decl_stmt
name|lang_expand_expr_t
name|lang_expand_expr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|tree
argument_list|(
argument|*lang_expand_constant
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Pointer to function to finish handling an incomplete decl at the    end of compilation.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*incomplete_decl_finalize_hook
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Nonzero if generating code to do profiling.  */
end_comment

begin_decl_stmt
name|int
name|profile_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if generating code to do profiling on a line-by-line basis.  */
end_comment

begin_decl_stmt
name|int
name|profile_block_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if generating code to profile program flow graph arcs.  */
end_comment

begin_decl_stmt
name|int
name|profile_arc_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if generating info for gcov to calculate line test coverage.  */
end_comment

begin_decl_stmt
name|int
name|flag_test_coverage
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero indicates that branch taken probabilities should be calculated.  */
end_comment

begin_decl_stmt
name|int
name|flag_branch_probabilities
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -pedantic switch: warn about anything    that standard spec forbids.  */
end_comment

begin_decl_stmt
name|int
name|pedantic
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporarily suppress certain warnings.    This is set while reading code from a system header file.  */
end_comment

begin_decl_stmt
name|int
name|in_system_header
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do stupid register allocation.    Currently, this is 1 if `optimize' is 0.  */
end_comment

begin_decl_stmt
name|int
name|obey_regdecls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't print functions as they are compiled and don't print    times taken by the various passes.  -quiet.  */
end_comment

begin_decl_stmt
name|int
name|quiet_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* -f flags.  */
end_comment

begin_comment
comment|/* Nonzero means `char' should be signed.  */
end_comment

begin_decl_stmt
name|int
name|flag_signed_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give an enum type only as many bytes as it needs.  */
end_comment

begin_decl_stmt
name|int
name|flag_short_enums
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fcaller-saves: allocate values in regs that need to    be saved across function calls, if that produces overall better code.    Optional now, so people can test it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_CALLER_SAVES
end_ifdef

begin_decl_stmt
name|int
name|flag_caller_saves
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|flag_caller_saves
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero if structures and unions should be returned in memory.     This should only be defined if compatibility with another compiler or    with an ABI is needed, because it results in slower code.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_PCC_STRUCT_RETURN
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_PCC_STRUCT_RETURN
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero for -fpcc-struct-return: return values the same way PCC does.  */
end_comment

begin_decl_stmt
name|int
name|flag_pcc_struct_return
init|=
name|DEFAULT_PCC_STRUCT_RETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fforce-mem: load memory value into a register    before arithmetic on it.  This makes better cse but slower compilation.  */
end_comment

begin_decl_stmt
name|int
name|flag_force_mem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fforce-addr: load memory address into a register before    reference to memory.  This makes better cse but slower compilation.  */
end_comment

begin_decl_stmt
name|int
name|flag_force_addr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fdefer-pop: don't pop args after each function call;    instead save them up to pop many calls' args with one insns.  */
end_comment

begin_decl_stmt
name|int
name|flag_defer_pop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -ffloat-store: don't allocate floats and doubles    in extended-precision registers.  */
end_comment

begin_decl_stmt
name|int
name|flag_float_store
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fcse-follow-jumps:    have cse follow jumps to do a more extensive job.  */
end_comment

begin_decl_stmt
name|int
name|flag_cse_follow_jumps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fcse-skip-blocks:    have cse follow a branch around a block.  */
end_comment

begin_decl_stmt
name|int
name|flag_cse_skip_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fexpensive-optimizations:    perform miscellaneous relatively-expensive optimizations.  */
end_comment

begin_decl_stmt
name|int
name|flag_expensive_optimizations
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fthread-jumps:    have jump optimize output of loop.  */
end_comment

begin_decl_stmt
name|int
name|flag_thread_jumps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables strength-reduction in loop.c.  */
end_comment

begin_decl_stmt
name|int
name|flag_strength_reduce
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables loop unrolling in unroll.c.  Only loops for which the    number of iterations can be calculated at compile-time (UNROLL_COMPLETELY,    UNROLL_MODULO) or at run-time (preconditioned to be UNROLL_MODULO) are    unrolled.  */
end_comment

begin_decl_stmt
name|int
name|flag_unroll_loops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables loop unrolling in unroll.c.  All loops are unrolled.    This is generally not a win.  */
end_comment

begin_decl_stmt
name|int
name|flag_unroll_all_loops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero forces all invariant computations in loops to be moved    outside the loop. */
end_comment

begin_decl_stmt
name|int
name|flag_move_all_movables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero forces all general induction variables in loops to be    strength reduced. */
end_comment

begin_decl_stmt
name|int
name|flag_reduce_all_givs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to perform full register move optimization passes.  This is the    default for -O2.  */
end_comment

begin_decl_stmt
name|int
name|flag_regmove
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fwritable-strings:    store string constants in data segment and don't uniquize them.  */
end_comment

begin_decl_stmt
name|int
name|flag_writable_strings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't put addresses of constant functions in registers.    Used for compiling the Unix kernel, where strange substitutions are    done on the assembly output.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_function_cse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fomit-frame-pointer:    don't make a frame pointer in simple functions that don't require one.  */
end_comment

begin_decl_stmt
name|int
name|flag_omit_frame_pointer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means place each function into its own section on those platforms    which support arbitrary section names and unlimited numbers of sections.  */
end_comment

begin_decl_stmt
name|int
name|flag_function_sections
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ... and similar for data.  */
end_comment

begin_decl_stmt
name|int
name|flag_data_sections
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to inhibit use of define_optimization peephole opts.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_peephole
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero allows GCC to violate some IEEE or ANSI rules regarding math    operations in the interest of optimization.  For example it allows    GCC to assume arguments to sqrt are nonnegative numbers, allowing    faster code for sqrt to be generated.  */
end_comment

begin_decl_stmt
name|int
name|flag_fast_math
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means the front end generally wants `errno' maintained by math    operations, like built-in SQRT, unless overridden by flag_fast_math.  */
end_comment

begin_decl_stmt
name|int
name|flag_errno_math
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 means straightforward implementation of complex divide acceptable.    1 means wide ranges of inputs must work for complex divide.    2 means C9X-like requirements for complex divide (not yet implemented).  */
end_comment

begin_decl_stmt
name|int
name|flag_complex_divide_method
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means all references through pointers are volatile.  */
end_comment

begin_decl_stmt
name|int
name|flag_volatile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means treat all global and extern variables as volatile.  */
end_comment

begin_decl_stmt
name|int
name|flag_volatile_global
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means treat all static variables as volatile.  */
end_comment

begin_decl_stmt
name|int
name|flag_volatile_static
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means just do syntax checking; don't output anything.  */
end_comment

begin_decl_stmt
name|int
name|flag_syntax_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means perform global cse.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_gcse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to rerun cse after loop optimization.  This increases    compilation time about 20% and picks up a few more common expressions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_rerun_cse_after_loop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to run loop optimizations twice.  */
end_comment

begin_decl_stmt
name|int
name|flag_rerun_loop_opt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -finline-functions: ok to inline functions that look like    good inline candidates.  */
end_comment

begin_decl_stmt
name|int
name|flag_inline_functions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fkeep-inline-functions: even if we make a function    go inline everywhere, keep its definition around for debugging    purposes.  */
end_comment

begin_decl_stmt
name|int
name|flag_keep_inline_functions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that functions will not be inlined.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_inline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that we should emit static const variables    regardless of whether or not optimization is turned on.  */
end_comment

begin_decl_stmt
name|int
name|flag_keep_static_consts
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we should be saving declaration info into a .X file.  */
end_comment

begin_decl_stmt
name|int
name|flag_gen_aux_info
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specified name of aux-info file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|aux_info_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means make the text shared if supported.  */
end_comment

begin_decl_stmt
name|int
name|flag_shared_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means schedule into delayed branch slots if supported.  */
end_comment

begin_decl_stmt
name|int
name|flag_delayed_branch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are compiling pure (sharable) code.    Value is 1 if we are doing reasonable (i.e. simple    offset into offset table) pic.  Value is 2 if we can    only perform register offsets.  */
end_comment

begin_decl_stmt
name|int
name|flag_pic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means generate extra code for exception handling and enable    exception handling.  */
end_comment

begin_decl_stmt
name|int
name|flag_exceptions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means use the new model for exception handling. Replaces     -DNEW_EH_MODEL as a compile option. */
end_comment

begin_decl_stmt
name|int
name|flag_new_exceptions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't place uninitialized global data in common storage    by default.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_common
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means pretend it is OK to examine bits of target floats,    even if that isn't true.  The resulting code will have incorrect constants,    but the same series of instructions that the native compiler would make.  */
end_comment

begin_decl_stmt
name|int
name|flag_pretend_float
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means change certain warnings into errors.    Usually these are warnings about failure to conform to some standard.  */
end_comment

begin_decl_stmt
name|int
name|flag_pedantic_errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag_schedule_insns means schedule insns within basic blocks (before    local_alloc).    flag_schedule_insns_after_reload means schedule insns after    global_alloc.  */
end_comment

begin_decl_stmt
name|int
name|flag_schedule_insns
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_schedule_insns_after_reload
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAIFA
end_ifdef

begin_comment
comment|/* The following flags have effect only for scheduling before register    allocation:     flag_schedule_interblock means schedule insns accross basic blocks.    flag_schedule_speculative means allow speculative motion of non-load insns.    flag_schedule_speculative_load means allow speculative motion of some    load insns.    flag_schedule_speculative_load_dangerous allows speculative motion of more    load insns.  */
end_comment

begin_decl_stmt
name|int
name|flag_schedule_interblock
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_schedule_speculative
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_schedule_speculative_load
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_schedule_speculative_load_dangerous
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAIFA */
end_comment

begin_comment
comment|/* flag_on_branch_count_reg means try to replace add-1,compare,branch tupple    by a cheaper branch, on a count register. */
end_comment

begin_decl_stmt
name|int
name|flag_branch_on_count_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -finhibit-size-directive inhibits output of .size for ELF.    This is used only for compiling crtstuff.c,     and it may be extended to other effects    needed for crtstuff.c on other systems.  */
end_comment

begin_decl_stmt
name|int
name|flag_inhibit_size_directive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -fverbose-asm causes extra commentary information to be produced in    the generated assembly code (to make it more readable).  This option    is generally only of use to those who actually need to read the    generated assembly code (perhaps while debugging the compiler itself).    -fno-verbose-asm, the default, causes the extra information    to be omitted and is useful when comparing two assembler files.  */
end_comment

begin_decl_stmt
name|int
name|flag_verbose_asm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -dA causes debug commentary information to be produced in    the generated assembly code (to make it more readable).  This option    is generally only of use to those who actually need to read the    generated assembly code (perhaps while debugging the compiler itself).    Currently, this switch is only used by dwarfout.c; however, it is intended    to be a catchall for printing debug information in the assembler file.  */
end_comment

begin_decl_stmt
name|int
name|flag_debug_asm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -fgnu-linker specifies use of the GNU linker for initializations.    (Or, more generally, a linker that handles initializations.)    -fno-gnu-linker says that collect2 will be used.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_COLLECT2
end_ifdef

begin_decl_stmt
name|int
name|flag_gnu_linker
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|flag_gnu_linker
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Tag all structures with __attribute__(packed) */
end_comment

begin_decl_stmt
name|int
name|flag_pack_struct
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that -Wformat accepts certain system-dependent formats.  */
end_comment

begin_decl_stmt
name|int
name|flag_format_extensions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Emit code to check for stack overflow; also may cause large objects    to be allocated dynamically.  */
end_comment

begin_decl_stmt
name|int
name|flag_stack_check
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -fcheck-memory-usage causes extra code to be generated in order to check    memory accesses.  This is used by a detector of bad memory accesses such    as Checker.  */
end_comment

begin_decl_stmt
name|int
name|flag_check_memory_usage
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -fprefix-function-name causes function name to be prefixed.  This    can be used with -fcheck-memory-usage to isolate code compiled with    -fcheck-memory-usage.  */
end_comment

begin_decl_stmt
name|int
name|flag_prefix_function_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 if pointer arguments may alias each other.  True in C.    1 if pointer arguments may not alias each other but may alias    global variables.    2 if pointer arguments may not alias each other and may not    alias global variables.  True in Fortran.    This defaults to 0 for C.  */
end_comment

begin_decl_stmt
name|int
name|flag_argument_noalias
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should do (language-dependent) alias analysis.    Typically, this analysis will assume that expressions of certain    types do not alias expressions of certain other types.  Only used    if alias analysis (in general) is enabled.  */
end_comment

begin_decl_stmt
name|int
name|flag_strict_aliasing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instrument functions with calls at entry and exit, for profiling.  */
end_comment

begin_decl_stmt
name|int
name|flag_instrument_function_entry_exit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means ignore `#ident' directives.  0 means handle them.    On SVR4 targets, it also controls whether or not to emit a    string identifying the compiler.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_ident
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of supported debugging formats.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
comment|/* Since PREFERRED_DEBUGGING_TYPE isn't necessarily a      constant expression, we use NO_DEBUG in its place.  */
name|enum
name|debug_info_type
name|debug_type
decl_stmt|;
name|int
name|use_extensions_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
decl_stmt|;
block|}
modifier|*
name|da
struct|,
name|debug_args
index|[]
init|=
block|{
block|{
literal|"g"
block|,
name|NO_DEBUG
block|,
name|DEFAULT_GDB_EXTENSIONS
block|,
literal|"Generate default debug format output"
block|}
block|,
block|{
literal|"ggdb"
block|,
name|NO_DEBUG
block|,
literal|1
block|,
literal|"Generate default extended debug format output"
block|}
block|,
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
block|{
literal|"gstabs"
block|,
name|DBX_DEBUG
block|,
literal|0
block|,
literal|"Generate STABS format debug output"
block|}
block|,
block|{
literal|"gstabs+"
block|,
name|DBX_DEBUG
block|,
literal|1
block|,
literal|"Generate extended STABS format debug output"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
block|{
literal|"gdwarf"
block|,
name|DWARF_DEBUG
block|,
literal|0
block|,
literal|"Generate DWARF-1 format debug output"
block|}
block|,
block|{
literal|"gdwarf+"
block|,
name|DWARF_DEBUG
block|,
literal|1
block|,
literal|"Generated extended DWARF-1 format debug output"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
block|{
literal|"gdwarf-2"
block|,
name|DWARF2_DEBUG
block|,
literal|0
block|,
literal|"Enable DWARF-2 debug output"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
block|{
literal|"gxcoff"
block|,
name|XCOFF_DEBUG
block|,
literal|0
block|,
literal|"Generate XCOFF format debug output"
block|}
block|,
block|{
literal|"gxcoff+"
block|,
name|XCOFF_DEBUG
block|,
literal|1
block|,
literal|"Generate extended XCOFF format debug output"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
block|{
literal|"gcoff"
block|,
name|SDB_DEBUG
block|,
literal|0
block|,
literal|"Generate COFF format debug output"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|variable
decl_stmt|;
name|int
name|on_value
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
decl_stmt|;
block|}
name|lang_independent_options
typedef|;
end_typedef

begin_comment
comment|/* Add or remove a leading underscore from user symbols.  */
end_comment

begin_decl_stmt
name|int
name|flag_leading_underscore
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The user symbol prefix after having resolved same.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|user_label_prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A default for same.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USER_LABEL_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|USER_LABEL_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Table of language-independent -f options.    STRING is the option name.  VARIABLE is the address of the variable.    ON_VALUE is the value to store in VARIABLE     if `-fSTRING' is seen as an option.    (If `-fno-STRING' is seen as an option, the opposite value is stored.)  */
end_comment

begin_decl_stmt
name|lang_independent_options
name|f_options
index|[]
init|=
block|{
block|{
literal|"float-store"
block|,
operator|&
name|flag_float_store
block|,
literal|1
block|,
literal|"Do not store floats in registers"
block|}
block|,
block|{
literal|"volatile"
block|,
operator|&
name|flag_volatile
block|,
literal|1
block|,
literal|"Consider all mem refs through pointers as volatile"
block|}
block|,
block|{
literal|"volatile-global"
block|,
operator|&
name|flag_volatile_global
block|,
literal|1
block|,
literal|"Consider all mem refs to global data to be volatile"
block|}
block|,
block|{
literal|"volatile-static"
block|,
operator|&
name|flag_volatile_static
block|,
literal|1
block|,
literal|"Consider all mem refs to static data to be volatile"
block|}
block|,
block|{
literal|"defer-pop"
block|,
operator|&
name|flag_defer_pop
block|,
literal|1
block|,
literal|"Defer popping functions args from stack until later"
block|}
block|,
block|{
literal|"omit-frame-pointer"
block|,
operator|&
name|flag_omit_frame_pointer
block|,
literal|1
block|,
literal|"When possible do not generate stack frames"
block|}
block|,
block|{
literal|"cse-follow-jumps"
block|,
operator|&
name|flag_cse_follow_jumps
block|,
literal|1
block|,
literal|"When running CSE, follow jumps to their targets"
block|}
block|,
block|{
literal|"cse-skip-blocks"
block|,
operator|&
name|flag_cse_skip_blocks
block|,
literal|1
block|,
literal|"When running CSE, follow conditional jumps"
block|}
block|,
block|{
literal|"expensive-optimizations"
block|,
operator|&
name|flag_expensive_optimizations
block|,
literal|1
block|,
literal|"Perform a number of minor, expensive optimisations"
block|}
block|,
block|{
literal|"thread-jumps"
block|,
operator|&
name|flag_thread_jumps
block|,
literal|1
block|,
literal|"Perform jump threading optimisations"
block|}
block|,
block|{
literal|"strength-reduce"
block|,
operator|&
name|flag_strength_reduce
block|,
literal|1
block|,
literal|"Perform strength reduction optimisations"
block|}
block|,
block|{
literal|"unroll-loops"
block|,
operator|&
name|flag_unroll_loops
block|,
literal|1
block|,
literal|"Perform loop unrolling when iteration count is known"
block|}
block|,
block|{
literal|"unroll-all-loops"
block|,
operator|&
name|flag_unroll_all_loops
block|,
literal|1
block|,
literal|"Perform loop unrolling for all loops"
block|}
block|,
block|{
literal|"move-all-movables"
block|,
operator|&
name|flag_move_all_movables
block|,
literal|1
block|,
literal|"Force all loop invariant computations out of loops"
block|}
block|,
block|{
literal|"reduce-all-givs"
block|,
operator|&
name|flag_reduce_all_givs
block|,
literal|1
block|,
literal|"Strength reduce all loop general induction variables"
block|}
block|,
block|{
literal|"writable-strings"
block|,
operator|&
name|flag_writable_strings
block|,
literal|1
block|,
literal|"Store strings in writable data section"
block|}
block|,
block|{
literal|"peephole"
block|,
operator|&
name|flag_no_peephole
block|,
literal|0
block|,
literal|"Enable machine specific peephole optimisations"
block|}
block|,
block|{
literal|"force-mem"
block|,
operator|&
name|flag_force_mem
block|,
literal|1
block|,
literal|"Copy memory operands into registers before using"
block|}
block|,
block|{
literal|"force-addr"
block|,
operator|&
name|flag_force_addr
block|,
literal|1
block|,
literal|"Copy memory address constants into regs before using"
block|}
block|,
block|{
literal|"function-cse"
block|,
operator|&
name|flag_no_function_cse
block|,
literal|0
block|,
literal|"Allow function addresses to be held in registers"
block|}
block|,
block|{
literal|"inline-functions"
block|,
operator|&
name|flag_inline_functions
block|,
literal|1
block|,
literal|"Integrate simple functions into their callers"
block|}
block|,
block|{
literal|"keep-inline-functions"
block|,
operator|&
name|flag_keep_inline_functions
block|,
literal|1
block|,
literal|"Generate code for funcs even if they are fully inlined"
block|}
block|,
block|{
literal|"inline"
block|,
operator|&
name|flag_no_inline
block|,
literal|0
block|,
literal|"Pay attention to the 'inline' keyword"
block|}
block|,
block|{
literal|"keep-static-consts"
block|,
operator|&
name|flag_keep_static_consts
block|,
literal|1
block|,
literal|"Emit static const variables even if they are not used"
block|}
block|,
block|{
literal|"syntax-only"
block|,
operator|&
name|flag_syntax_only
block|,
literal|1
block|,
literal|"Check for syntax errors, then stop"
block|}
block|,
block|{
literal|"shared-data"
block|,
operator|&
name|flag_shared_data
block|,
literal|1
block|,
literal|"Mark data as shared rather than private"
block|}
block|,
block|{
literal|"caller-saves"
block|,
operator|&
name|flag_caller_saves
block|,
literal|1
block|,
literal|"Enable saving registers around function calls"
block|}
block|,
block|{
literal|"pcc-struct-return"
block|,
operator|&
name|flag_pcc_struct_return
block|,
literal|1
block|,
literal|"Return 'short' aggregates in memory, not registers"
block|}
block|,
block|{
literal|"reg-struct-return"
block|,
operator|&
name|flag_pcc_struct_return
block|,
literal|0
block|,
literal|"Return 'short' aggregates in registers"
block|}
block|,
block|{
literal|"delayed-branch"
block|,
operator|&
name|flag_delayed_branch
block|,
literal|1
block|,
literal|"Attempt to fill delay slots of branch instructions"
block|}
block|,
block|{
literal|"gcse"
block|,
operator|&
name|flag_gcse
block|,
literal|1
block|,
literal|"Perform the global common subexpression elimination"
block|}
block|,
block|{
literal|"rerun-cse-after-loop"
block|,
operator|&
name|flag_rerun_cse_after_loop
block|,
literal|1
block|,
literal|"Run CSE pass after loop optimisations"
block|}
block|,
block|{
literal|"rerun-loop-opt"
block|,
operator|&
name|flag_rerun_loop_opt
block|,
literal|1
block|,
literal|"Run the loop optimiser twice"
block|}
block|,
block|{
literal|"pretend-float"
block|,
operator|&
name|flag_pretend_float
block|,
literal|1
block|,
literal|"Pretend that host and target use the same FP format"
block|}
block|,
block|{
literal|"schedule-insns"
block|,
operator|&
name|flag_schedule_insns
block|,
literal|1
block|,
literal|"Reschedule instructions to avoid pipeline stalls"
block|}
block|,
block|{
literal|"schedule-insns2"
block|,
operator|&
name|flag_schedule_insns_after_reload
block|,
literal|1
block|,
literal|"Run two passes of the instruction scheduler"
block|}
block|,
ifdef|#
directive|ifdef
name|HAIFA
block|{
literal|"sched-interblock"
block|,
operator|&
name|flag_schedule_interblock
block|,
literal|1
block|,
literal|"Enable scheduling across basic blocks"
block|}
block|,
block|{
literal|"sched-spec"
block|,
operator|&
name|flag_schedule_speculative
block|,
literal|1
block|,
literal|"Allow speculative motion of non-loads"
block|}
block|,
block|{
literal|"sched-spec-load"
block|,
operator|&
name|flag_schedule_speculative_load
block|,
literal|1
block|,
literal|"Allow speculative motion of some loads"
block|}
block|,
block|{
literal|"sched-spec-load-dangerous"
block|,
operator|&
name|flag_schedule_speculative_load_dangerous
block|,
literal|1
block|,
literal|"Allow speculative motion of more loads"
block|}
block|,
endif|#
directive|endif
comment|/* HAIFA */
block|{
literal|"branch-count-reg"
block|,
operator|&
name|flag_branch_on_count_reg
block|,
literal|1
block|,
literal|"Replace add,compare,branch with branch on count reg"
block|}
block|,
block|{
literal|"pic"
block|,
operator|&
name|flag_pic
block|,
literal|1
block|,
literal|"Generate position independent code, if possible"
block|}
block|,
block|{
literal|"PIC"
block|,
operator|&
name|flag_pic
block|,
literal|2
block|,
literal|""
block|}
block|,
block|{
literal|"exceptions"
block|,
operator|&
name|flag_exceptions
block|,
literal|1
block|,
literal|"Enable exception handling"
block|}
block|,
block|{
literal|"new-exceptions"
block|,
operator|&
name|flag_new_exceptions
block|,
literal|1
block|,
literal|"Use the new model for exception handling"
block|}
block|,
block|{
literal|"sjlj-exceptions"
block|,
operator|&
name|exceptions_via_longjmp
block|,
literal|1
block|,
literal|"Use setjmp/longjmp to handle exceptions"
block|}
block|,
block|{
literal|"asynchronous-exceptions"
block|,
operator|&
name|asynchronous_exceptions
block|,
literal|1
block|,
literal|"Support asynchronous exceptions"
block|}
block|,
block|{
literal|"profile-arcs"
block|,
operator|&
name|profile_arc_flag
block|,
literal|1
block|,
literal|"Insert arc based program profiling code"
block|}
block|,
block|{
literal|"test-coverage"
block|,
operator|&
name|flag_test_coverage
block|,
literal|1
block|,
literal|"Create data files needed by gcov"
block|}
block|,
block|{
literal|"branch-probabilities"
block|,
operator|&
name|flag_branch_probabilities
block|,
literal|1
block|,
literal|"Use profiling information for branch probabilities"
block|}
block|,
block|{
literal|"fast-math"
block|,
operator|&
name|flag_fast_math
block|,
literal|1
block|,
literal|"Improve FP speed by violating ANSI& IEEE rules"
block|}
block|,
block|{
literal|"common"
block|,
operator|&
name|flag_no_common
block|,
literal|0
block|,
literal|"Do not put unitialised globals in the common section"
block|}
block|,
block|{
literal|"inhibit-size-directive"
block|,
operator|&
name|flag_inhibit_size_directive
block|,
literal|1
block|,
literal|"Do not generate .size directives"
block|}
block|,
block|{
literal|"function-sections"
block|,
operator|&
name|flag_function_sections
block|,
literal|1
block|,
literal|"place each function into its own section"
block|}
block|,
block|{
literal|"data-sections"
block|,
operator|&
name|flag_data_sections
block|,
literal|1
block|,
literal|"place data items into their own section"
block|}
block|,
block|{
literal|"verbose-asm"
block|,
operator|&
name|flag_verbose_asm
block|,
literal|1
block|,
literal|"Add extra commentry to assembler output"
block|}
block|,
block|{
literal|"gnu-linker"
block|,
operator|&
name|flag_gnu_linker
block|,
literal|1
block|,
literal|"Output GNU ld formatted global initialisers"
block|}
block|,
block|{
literal|"regmove"
block|,
operator|&
name|flag_regmove
block|,
literal|1
block|,
literal|"Enables a register move optimisation"
block|}
block|,
block|{
literal|"optimize-register-move"
block|,
operator|&
name|flag_regmove
block|,
literal|1
block|,
literal|"Do the full regmove optimization pass"
block|}
block|,
block|{
literal|"pack-struct"
block|,
operator|&
name|flag_pack_struct
block|,
literal|1
block|,
literal|"Pack structure members together without holes"
block|}
block|,
block|{
literal|"format-extensions"
block|,
operator|&
name|flag_format_extensions
block|,
literal|1
block|,
literal|"-Wformat accepts certain FreeBSD system-dependent formats"
block|}
block|,
block|{
literal|"stack-check"
block|,
operator|&
name|flag_stack_check
block|,
literal|1
block|,
literal|"Insert stack checking code into the program"
block|}
block|,
block|{
literal|"argument-alias"
block|,
operator|&
name|flag_argument_noalias
block|,
literal|0
block|,
literal|"Specify that arguments may alias each other& globals"
block|}
block|,
block|{
literal|"argument-noalias"
block|,
operator|&
name|flag_argument_noalias
block|,
literal|1
block|,
literal|"Assume arguments may alias globals but not each other"
block|}
block|,
block|{
literal|"argument-noalias-global"
block|,
operator|&
name|flag_argument_noalias
block|,
literal|2
block|,
literal|"Assume arguments do not alias each other or globals"
block|}
block|,
block|{
literal|"strict-aliasing"
block|,
operator|&
name|flag_strict_aliasing
block|,
literal|1
block|,
literal|"Assume strict aliasing rules apply"
block|}
block|,
block|{
literal|"check-memory-usage"
block|,
operator|&
name|flag_check_memory_usage
block|,
literal|1
block|,
literal|"Generate code to check every memory access"
block|}
block|,
block|{
literal|"prefix-function-name"
block|,
operator|&
name|flag_prefix_function_name
block|,
literal|1
block|,
literal|"Add a prefix to all function names"
block|}
block|,
block|{
literal|"dump-unnumbered"
block|,
operator|&
name|flag_dump_unnumbered
block|,
literal|1
block|,
literal|"Suppress output of instruction numbers and line number notes in debugging dumps"
block|}
block|,
block|{
literal|"instrument-functions"
block|,
operator|&
name|flag_instrument_function_entry_exit
block|,
literal|1
block|,
literal|"Instrument function entry/exit with profiling calls"
block|}
block|,
block|{
literal|"leading-underscore"
block|,
operator|&
name|flag_leading_underscore
block|,
literal|1
block|,
literal|"External symbols have a leading underscore"
block|}
block|,
block|{
literal|"ident"
block|,
operator|&
name|flag_no_ident
block|,
literal|0
block|,
literal|"Process #ident directives"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_ELEM
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof ((a)[0]))
end_define

begin_comment
comment|/* Table of language-specific options.  */
end_comment

begin_struct
specifier|static
struct|struct
name|lang_opt
block|{
specifier|const
name|char
modifier|*
name|option
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
decl_stmt|;
block|}
name|documented_lang_options
index|[]
init|=
block|{
comment|/* In order not to overload the --help output, the convention      used here is to only describe those options which are not      enabled by default.  */
block|{
literal|"-ansi"
block|,
literal|"Compile just for ANSI C"
block|}
block|,
block|{
literal|"-fallow-single-precision"
block|,
literal|"Do not promote floats to double if using -traditional"
block|}
block|,
block|{
literal|"-std= "
block|,
literal|"Determine language standard"
block|}
block|,
block|{
literal|"-fsigned-bitfields"
block|,
literal|""
block|}
block|,
block|{
literal|"-funsigned-bitfields"
block|,
literal|"Make bitfields by unsigned by default"
block|}
block|,
block|{
literal|"-fno-signed-bitfields"
block|,
literal|""
block|}
block|,
block|{
literal|"-fno-unsigned-bitfields"
block|,
literal|""
block|}
block|,
block|{
literal|"-fsigned-char"
block|,
literal|"Make 'char' be signed by default"
block|}
block|,
block|{
literal|"-funsigned-char"
block|,
literal|"Make 'char' be unsigned by default"
block|}
block|,
block|{
literal|"-fno-signed-char"
block|,
literal|""
block|}
block|,
block|{
literal|"-fno-unsigned-char"
block|,
literal|""
block|}
block|,
block|{
literal|"-ftraditional"
block|,
literal|""
block|}
block|,
block|{
literal|"-traditional"
block|,
literal|"Attempt to support traditional K&R style C"
block|}
block|,
block|{
literal|"-fnotraditional"
block|,
literal|""
block|}
block|,
block|{
literal|"-fno-traditional"
block|,
literal|""
block|}
block|,
block|{
literal|"-fasm"
block|,
literal|""
block|}
block|,
block|{
literal|"-fno-asm"
block|,
literal|"Do not recognise the 'asm' keyword"
block|}
block|,
block|{
literal|"-fbuiltin"
block|,
literal|""
block|}
block|,
block|{
literal|"-fno-builtin"
block|,
literal|"Do not recognise any built in functions"
block|}
block|,
block|{
literal|"-fhosted"
block|,
literal|"Assume normal C execution environment"
block|}
block|,
block|{
literal|"-fno-hosted"
block|,
literal|""
block|}
block|,
block|{
literal|"-ffreestanding"
block|,
literal|"Assume that standard libraries& main might not exist"
block|}
block|,
block|{
literal|"-fno-freestanding"
block|,
literal|""
block|}
block|,
block|{
literal|"-fcond-mismatch"
block|,
literal|"Allow different types as args of ? operator"
block|}
block|,
block|{
literal|"-fno-cond-mismatch"
block|,
literal|""
block|}
block|,
block|{
literal|"-fdollars-in-identifiers"
block|,
literal|"Allow the use of $ inside identifiers"
block|}
block|,
block|{
literal|"-fno-dollars-in-identifiers"
block|,
literal|""
block|}
block|,
block|{
literal|"-fshort-double"
block|,
literal|"Use the same size for double as for float"
block|}
block|,
block|{
literal|"-fno-short-double"
block|,
literal|""
block|}
block|,
block|{
literal|"-fshort-enums"
block|,
literal|"Use the smallest fitting integer to hold enums"
block|}
block|,
block|{
literal|"-fno-short-enums"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wall"
block|,
literal|"Enable most warning messages"
block|}
block|,
block|{
literal|"-Wbad-function-cast"
block|,
literal|"Warn about casting functions to incompatible types"
block|}
block|,
block|{
literal|"-Wno-bad-function-cast"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wmissing-noreturn"
block|,
literal|"Warn about functions which might be candidates for attribute noreturn"
block|}
block|,
block|{
literal|"-Wno-missing-noreturn"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wcast-qual"
block|,
literal|"Warn about casts which discard qualifiers"
block|}
block|,
block|{
literal|"-Wno-cast-qual"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wchar-subscripts"
block|,
literal|"Warn about subscripts whose type is 'char'"
block|}
block|,
block|{
literal|"-Wno-char-subscripts"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wcomment"
block|,
literal|"Warn if nested comments are detected"
block|}
block|,
block|{
literal|"-Wno-comment"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wcomments"
block|,
literal|"Warn if nested comments are detected"
block|}
block|,
block|{
literal|"-Wno-comments"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wconversion"
block|,
literal|"Warn about possibly confusing type conversions"
block|}
block|,
block|{
literal|"-Wno-conversion"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wformat"
block|,
literal|"Warn about printf format anomalies"
block|}
block|,
block|{
literal|"-Wnon-const-format"
block|,
literal|"Warn about printf-like format strings"
block|}
block|,
block|{
literal|"-Wno-format"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wno-format-extra-args"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wimplicit-function-declaration"
block|,
literal|"Warn about implicit function declarations"
block|}
block|,
block|{
literal|"-Wno-implicit-function-declaration"
block|,
literal|""
block|}
block|,
block|{
literal|"-Werror-implicit-function-declaration"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wimplicit-int"
block|,
literal|"Warn when a declaration does not specify a type"
block|}
block|,
block|{
literal|"-Wno-implicit-int"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wimplicit"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wno-implicit"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wimport"
block|,
literal|"Warn about the use of the #import directive"
block|}
block|,
block|{
literal|"-Wno-import"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wlong-long"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wno-long-long"
block|,
literal|"Do not warn about using 'long long' when -pedantic"
block|}
block|,
block|{
literal|"-Wmain"
block|,
literal|"Warn about suspicious declarations of main"
block|}
block|,
block|{
literal|"-Wframe-size-<N>"
block|,
literal|"Warn if frame uses greater than<N> bytes."
block|}
block|,
block|{
literal|"-Wlarglist-size-<N>"
block|,
literal|"Warn if function argument list uses greater than<N> bytes."
block|}
block|,
block|{
literal|"-Wno-main"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wmissing-braces"
block|,
literal|"Warn about possibly missing braces around initialisers"
block|}
block|,
block|{
literal|"-Wno-missing-braces"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wmissing-declarations"
block|,
literal|"Warn about global funcs without previous declarations"
block|}
block|,
block|{
literal|"-Wno-missing-declarations"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wmissing-prototypes"
block|,
literal|"Warn about global funcs without prototypes"
block|}
block|,
block|{
literal|"-Wno-missing-prototypes"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wmultichar"
block|,
literal|"Warn about use of multicharacter literals"
block|}
block|,
block|{
literal|"-Wno-multichar"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wnested-externs"
block|,
literal|"Warn about externs not at file scope level"
block|}
block|,
block|{
literal|"-Wno-nested-externs"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wparentheses"
block|,
literal|"Warn about possible missing parentheses"
block|}
block|,
block|{
literal|"-Wno-parentheses"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wpointer-arith"
block|,
literal|"Warn about function pointer arithmetic"
block|}
block|,
block|{
literal|"-Wno-pointer-arith"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wredundant-decls"
block|,
literal|"Warn about multiple declarations of the same object"
block|}
block|,
block|{
literal|"-Wno-redundant-decls"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wsign-compare"
block|,
literal|"Warn about signed/unsigned comparisons"
block|}
block|,
block|{
literal|"-Wno-sign-compare"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wunknown-pragmas"
block|,
literal|"Warn about unrecognised pragmas"
block|}
block|,
block|{
literal|"-Wno-unknown-pragmas"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wstrict-prototypes"
block|,
literal|"Warn about non-prototyped function decls"
block|}
block|,
block|{
literal|"-Wno-strict-prototypes"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wtraditional"
block|,
literal|"Warn about constructs whose meaning change in ANSI C"
block|}
block|,
block|{
literal|"-Wno-traditional"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wtrigraphs"
block|,
literal|"Warn when trigraphs are encountered"
block|}
block|,
block|{
literal|"-Wno-trigraphs"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wundef"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wno-undef"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wwrite-strings"
block|,
literal|"Mark strings as 'const char *'"
block|}
block|,
block|{
literal|"-Wno-write-strings"
block|,
literal|""
block|}
block|,
comment|/* These are for languages with USE_CPPLIB.  */
comment|/* These options are already documented in cpplib.c */
block|{
literal|"--help"
block|,
literal|""
block|}
block|,
block|{
literal|"-A"
block|,
literal|""
block|}
block|,
block|{
literal|"-D"
block|,
literal|""
block|}
block|,
block|{
literal|"-I"
block|,
literal|""
block|}
block|,
if|#
directive|if
name|USE_CPPLIB
block|{
literal|"-MD"
block|,
literal|"Print dependencies to FILE.d"
block|}
block|,
block|{
literal|"-MMD"
block|,
literal|"Print dependencies to FILE.d"
block|}
block|,
block|{
literal|"-M"
block|,
literal|"Print dependencies to stdout"
block|}
block|,
block|{
literal|"-MM"
block|,
literal|"Print dependencies to stdout"
block|}
block|,
endif|#
directive|endif
comment|/* USE_CPPLIB */
block|{
literal|"-U"
block|,
literal|""
block|}
block|,
block|{
literal|"-H"
block|,
literal|""
block|}
block|,
block|{
literal|"-idirafter"
block|,
literal|""
block|}
block|,
block|{
literal|"-imacros"
block|,
literal|""
block|}
block|,
block|{
literal|"-include"
block|,
literal|""
block|}
block|,
block|{
literal|"-iprefix"
block|,
literal|""
block|}
block|,
block|{
literal|"-isystem"
block|,
literal|""
block|}
block|,
block|{
literal|"-iwithprefix"
block|,
literal|""
block|}
block|,
block|{
literal|"-iwithprefixbefore"
block|,
literal|""
block|}
block|,
block|{
literal|"-lang-c"
block|,
literal|""
block|}
block|,
block|{
literal|"-lang-c89"
block|,
literal|""
block|}
block|,
block|{
literal|"-lang-c++"
block|,
literal|""
block|}
block|,
block|{
literal|"-remap"
block|,
literal|""
block|}
block|,
block|{
literal|"-nostdinc"
block|,
literal|""
block|}
block|,
block|{
literal|"-nostdinc++"
block|,
literal|""
block|}
block|,
block|{
literal|"-trigraphs"
block|,
literal|""
block|}
block|,
block|{
literal|"-undef"
block|,
literal|""
block|}
block|,
define|#
directive|define
name|DEFINE_LANG_NAME
parameter_list|(
name|NAME
parameter_list|)
value|{ NULL, NAME },
comment|/* These are for obj c.  */
name|DEFINE_LANG_NAME
argument_list|(
literal|"Objective C"
argument_list|)
block|{
literal|"-lang-objc"
block|,
literal|""
block|}
block|,
block|{
literal|"-gen-decls"
block|,
literal|"Dump decls to a .decl file"
block|}
block|,
block|{
literal|"-fgnu-runtime"
block|,
literal|"Generate code for GNU runtime environment"
block|}
block|,
block|{
literal|"-fno-gnu-runtime"
block|,
literal|""
block|}
block|,
block|{
literal|"-fnext-runtime"
block|,
literal|"Generate code for NeXT runtime environment"
block|}
block|,
block|{
literal|"-fno-next-runtime"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wselector"
block|,
literal|"Warn if a selector has multiple methods"
block|}
block|,
block|{
literal|"-Wno-selector"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wprotocol"
block|,
literal|""
block|}
block|,
block|{
literal|"-Wno-protocol"
block|,
literal|"Do not warn if inherited methods are unimplemented"
block|}
block|,
block|{
literal|"-print-objc-runtime-info"
block|,
literal|"Generate C header of platform specific features"
block|}
block|,
include|#
directive|include
file|"options.h"
block|}
struct|;
end_struct

begin_comment
comment|/* Here is a table, controlled by the tm.h file, listing each -m switch    and which bits in `target_switches' it should set or clear.    If VALUE is positive, it is bits to set.    If VALUE is negative, -VALUE is bits to clear.    (The sign bit is not used so there is no confusion.)  */
end_comment

begin_struct
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
decl_stmt|;
block|}
name|target_switches
index|[]
init|=
name|TARGET_SWITCHES
struct|;
end_struct

begin_comment
comment|/* This table is similar, but allows the switch to have a value.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
end_ifdef

begin_struct
struct|struct
block|{
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|variable
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
decl_stmt|;
block|}
name|target_options
index|[]
init|=
name|TARGET_OPTIONS
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Options controlling warnings */
end_comment

begin_comment
comment|/* Don't print warning messages.  -w.  */
end_comment

begin_decl_stmt
name|int
name|inhibit_warnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print various extra warnings.  -W.  */
end_comment

begin_decl_stmt
name|int
name|extra_warnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Treat warnings as errors.  -Werror.  */
end_comment

begin_decl_stmt
name|int
name|warnings_are_errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to warn about unused local variables.  */
end_comment

begin_decl_stmt
name|int
name|warn_unused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to warn about variables used before they are initialized.  */
end_comment

begin_decl_stmt
name|int
name|warn_uninitialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about all declarations which shadow others.   */
end_comment

begin_decl_stmt
name|int
name|warn_shadow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if a switch on an enum fails to have a case for every enum value.  */
end_comment

begin_decl_stmt
name|int
name|warn_switch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about function definitions that default the return type    or that use a null return and have a return-type other than void.  */
end_comment

begin_decl_stmt
name|int
name|warn_return_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about pointer casts that increase the required    alignment of the target type (and might therefore lead to a crash    due to a misaligned access).  */
end_comment

begin_decl_stmt
name|int
name|warn_cast_align
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if a frame is larger that N bytes.  The value     of N is warn_frame_size. */
end_comment

begin_decl_stmt
name|int
name|warn_frame_size_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warn_frame_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if a function call pushes more than N bytes     onto the stack.  The value of N is warn_arglist_size. */
end_comment

begin_decl_stmt
name|int
name|warn_arglist_size_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warn_arglist_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about any identifiers that match in the first N    characters.  The value N is in `id_clash_len'.  */
end_comment

begin_decl_stmt
name|int
name|warn_id_clash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|id_clash_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about any objects definitions whose size is larger    than N bytes.  Also want about function definitions whose returned    values are larger than N bytes. The value N is in `larger_than_size'.  */
end_comment

begin_decl_stmt
name|int
name|warn_larger_than
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|larger_than_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if inline function is too large.  */
end_comment

begin_decl_stmt
name|int
name|warn_inline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if a function returns an aggregate,    since there are often incompatible calling conventions for doing this.  */
end_comment

begin_decl_stmt
name|int
name|warn_aggregate_return
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise for -W.  */
end_comment

begin_decl_stmt
name|lang_independent_options
name|W_options
index|[]
init|=
block|{
block|{
literal|"unused"
block|,
operator|&
name|warn_unused
block|,
literal|1
block|,
literal|"Warn when a variable is unused"
block|}
block|,
block|{
literal|"error"
block|,
operator|&
name|warnings_are_errors
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"shadow"
block|,
operator|&
name|warn_shadow
block|,
literal|1
block|,
literal|"Warn when one local variable shadows another"
block|}
block|,
block|{
literal|"switch"
block|,
operator|&
name|warn_switch
block|,
literal|1
block|,
literal|"Warn about enumerated switches missing a specific case"
block|}
block|,
block|{
literal|"aggregate-return"
block|,
operator|&
name|warn_aggregate_return
block|,
literal|1
block|,
literal|"Warn about returning structures, unions or arrays"
block|}
block|,
block|{
literal|"cast-align"
block|,
operator|&
name|warn_cast_align
block|,
literal|1
block|,
literal|"Warn about pointer casts which increase alignment"
block|}
block|,
block|{
literal|"uninitialized"
block|,
operator|&
name|warn_uninitialized
block|,
literal|1
block|,
literal|"Warn about unitialized automatic variables"
block|}
block|,
block|{
literal|"inline"
block|,
operator|&
name|warn_inline
block|,
literal|1
block|,
literal|"Warn when an inlined function cannot be inlined"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Output files for assembler code (real compiler output)    and debugging dumps.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|aux_info_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|rtl_dump_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Decode the string P as an integral parameter.    If the string is indeed an integer return its numeric value else    issue an Invalid Option error for the option PNAME and return DEFVAL.    If PNAME is zero just return DEFVAL, do not call error.               */
end_comment

begin_function
name|int
name|read_integral_parameter
parameter_list|(
name|p
parameter_list|,
name|pname
parameter_list|,
name|defval
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|pname
decl_stmt|;
specifier|const
name|int
name|defval
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|endp
init|=
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|endp
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|>=
literal|'0'
operator|&&
operator|*
name|endp
operator|<=
literal|'9'
condition|)
name|endp
operator|++
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|endp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pname
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|pname
argument_list|)
expr_stmt|;
return|return
name|defval
return|;
block|}
return|return
name|atoi
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Time accumulators, to count the total time spent in various passes.  */
end_comment

begin_decl_stmt
name|int
name|parse_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|varconst_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|integration_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|jump_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cse_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gcse_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|loop_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cse2_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|branch_prob_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flow_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|combine_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|regmove_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sched_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|local_alloc_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|global_alloc_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flow2_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sched2_time
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DELAY_SLOTS
end_ifdef

begin_decl_stmt
name|int
name|dbr_sched_time
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|shorten_branch_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stack_reg_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|final_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|symout_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dump_time
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return time used so far, in microseconds.  */
end_comment

begin_function
name|long
name|get_run_time
parameter_list|()
block|{
if|if
condition|(
name|quiet_flag
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|__BEOS__
return|return
literal|0
return|;
else|#
directive|else
comment|/* not BeOS */
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|clock
argument_list|()
operator|<
literal|0
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|(
name|clock
argument_list|()
operator|*
literal|1000
operator|)
return|;
else|#
directive|else
comment|/* not _WIN32 */
ifdef|#
directive|ifdef
name|_SC_CLK_TCK
block|{
specifier|static
name|int
name|tick
decl_stmt|;
name|struct
name|tms
name|tms
decl_stmt|;
if|if
condition|(
name|tick
operator|==
literal|0
condition|)
name|tick
operator|=
literal|1000000
operator|/
name|sysconf
argument_list|(
name|_SC_CLK_TCK
argument_list|)
expr_stmt|;
name|times
argument_list|(
operator|&
name|tms
argument_list|)
expr_stmt|;
return|return
operator|(
name|tms
operator|.
name|tms_utime
operator|+
name|tms
operator|.
name|tms_stime
operator|)
operator|*
name|tick
return|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|USG
block|{
name|struct
name|tms
name|tms
decl_stmt|;
if|#
directive|if
name|HAVE_SYSCONF
operator|&&
name|defined
name|_SC_CLK_TCK
define|#
directive|define
name|TICKS_PER_SECOND
value|sysconf (_SC_CLK_TCK)
comment|/* POSIX 1003.1-1996 */
else|#
directive|else
ifdef|#
directive|ifdef
name|CLK_TCK
define|#
directive|define
name|TICKS_PER_SECOND
value|CLK_TCK
comment|/* POSIX 1003.1-1988; obsolescent */
else|#
directive|else
define|#
directive|define
name|TICKS_PER_SECOND
value|HZ
comment|/* traditional UNIX */
endif|#
directive|endif
endif|#
directive|endif
name|times
argument_list|(
operator|&
name|tms
argument_list|)
expr_stmt|;
return|return
operator|(
name|tms
operator|.
name|tms_utime
operator|+
name|tms
operator|.
name|tms_stime
operator|)
operator|*
operator|(
literal|1000000
operator|/
name|TICKS_PER_SECOND
operator|)
return|;
block|}
else|#
directive|else
ifndef|#
directive|ifndef
name|VMS
block|{
name|struct
name|rusage
name|rusage
decl_stmt|;
name|getrusage
argument_list|(
literal|0
argument_list|,
operator|&
name|rusage
argument_list|)
expr_stmt|;
return|return
operator|(
name|rusage
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
name|rusage
operator|.
name|ru_utime
operator|.
name|tv_usec
operator|+
name|rusage
operator|.
name|ru_stime
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
name|rusage
operator|.
name|ru_stime
operator|.
name|tv_usec
operator|)
return|;
block|}
else|#
directive|else
comment|/* VMS */
block|{
struct|struct
block|{
name|int
name|proc_user_time
decl_stmt|;
name|int
name|proc_system_time
decl_stmt|;
name|int
name|child_user_time
decl_stmt|;
name|int
name|child_system_time
decl_stmt|;
block|}
name|vms_times
struct|;
name|times
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|vms_times
argument_list|)
expr_stmt|;
return|return
operator|(
name|vms_times
operator|.
name|proc_user_time
operator|+
name|vms_times
operator|.
name|proc_system_time
operator|)
operator|*
literal|10000
return|;
block|}
endif|#
directive|endif
comment|/* VMS */
endif|#
directive|endif
comment|/* USG */
endif|#
directive|endif
comment|/* _SC_CLK_TCK */
endif|#
directive|endif
comment|/* _WIN32 */
endif|#
directive|endif
comment|/* __BEOS__ */
block|}
end_function

begin_define
define|#
directive|define
name|TIMEVAR
parameter_list|(
name|VAR
parameter_list|,
name|BODY
parameter_list|)
define|\
value|do { int otime = get_run_time (); BODY; VAR += get_run_time () - otime; } while (0)
end_define

begin_function
name|void
name|print_time
parameter_list|(
name|str
parameter_list|,
name|total
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|total
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"time in %s: %d.%06d\n"
argument_list|,
name|str
argument_list|,
name|total
operator|/
literal|1000000
argument_list|,
name|total
operator|%
literal|1000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count an error or warning.  Return 1 if the message should be printed.  */
end_comment

begin_function
name|int
name|count_error
parameter_list|(
name|warningp
parameter_list|)
name|int
name|warningp
decl_stmt|;
block|{
if|if
condition|(
name|warningp
operator|&&
name|inhibit_warnings
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|warningp
operator|&&
operator|!
name|warnings_are_errors
condition|)
name|warningcount
operator|++
expr_stmt|;
else|else
block|{
specifier|static
name|int
name|warning_message
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|warningp
operator|&&
operator|!
name|warning_message
condition|)
block|{
name|notice
argument_list|(
literal|"%s: warnings being treated as errors\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|warning_message
operator|=
literal|1
expr_stmt|;
block|}
name|errorcount
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print a fatal error message.  NAME is the text.    Also include a system error message based on `errno'.  */
end_comment

begin_function
name|void
name|pfatal_with_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fatal_io_error
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|notice
argument_list|(
literal|"%s: %s: I/O error\n"
argument_list|,
name|progname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called to give a better error message for a bad insn rather than    just calling abort().  */
end_comment

begin_decl_stmt
name|void
name|fatal_insn
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
name|rtx
name|insn
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|insn
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|insn
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|verror
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Called to give a better error message when we don't have an insn to match    what we are looking for or if the insn's constraints aren't satisfied,    rather than just calling abort().  */
end_comment

begin_function
name|void
name|fatal_insn_not_found
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|fatal_insn
argument_list|(
literal|"internal error--unrecognizable insn:"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|fatal_insn
argument_list|(
literal|"internal error--insn does not satisfy its constraints:"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the default decl_printable_name function.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|decl_name
parameter_list|(
name|decl
parameter_list|,
name|verbosity
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|verbosity
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|need_error_newline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function of last error message;    more generally, function such that if next error message is in it    then we don't have to mention the function name.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_error_function
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to detect when input_file_stack has changed since last described.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_error_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called when the start of a function definition is parsed,    this function prints on stderr the name of the function.  */
end_comment

begin_function
name|void
name|announce_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
if|if
condition|(
name|rtl_dump_and_exit
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|need_error_newline
operator|=
literal|1
expr_stmt|;
name|last_error_function
operator|=
name|current_function_decl
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The default function to print out name of current function that caused    an error.  */
end_comment

begin_function
name|void
name|default_print_error_function
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|last_error_function
operator|!=
name|current_function_decl
condition|)
block|{
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL
condition|)
name|notice
argument_list|(
literal|"At top level:\n"
argument_list|)
expr_stmt|;
else|else
name|notice
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|?
literal|"In method `%s':\n"
else|:
literal|"In function `%s':\n"
operator|)
argument_list|,
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|last_error_function
operator|=
name|current_function_decl
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called by report_error_function to print out function name.  * Default may be overridden by language front-ends.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*print_error_function
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
operator|=
name|default_print_error_function
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Prints out, if necessary, the name of the current function   that caused an error.  Called from all error and warning functions.   We ignore the FILE parameter, as it cannot be relied upon.  */
end_comment

begin_function
name|void
name|report_error_function
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|file_stack
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|need_error_newline
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|need_error_newline
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|input_file_stack
operator|&&
name|input_file_stack
operator|->
name|next
operator|!=
literal|0
operator|&&
name|input_file_stack_tick
operator|!=
name|last_error_tick
condition|)
block|{
for|for
control|(
name|p
operator|=
name|input_file_stack
operator|->
name|next
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|notice
argument_list|(
operator|(
name|p
operator|==
name|input_file_stack
operator|->
name|next
condition|?
literal|"In file included from %s:%d"
else|:
literal|",\n                 from %s:%d"
operator|)
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
name|last_error_tick
operator|=
name|input_file_stack_tick
expr_stmt|;
block|}
call|(
modifier|*
name|print_error_function
call|)
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a message.  */
end_comment

begin_function
specifier|static
name|void
name|vnotice
parameter_list|(
name|file
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|vfprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|notice
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vnotice
argument_list|(
name|stderr
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|fnotice
name|VPROTO
argument_list|(
operator|(
name|FILE
operator|*
name|file
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|file
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|FILE
operator|*
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vnotice
argument_list|(
name|file
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report FILE and LINE (or program name), and optionally just WARN.  */
end_comment

begin_function
specifier|static
name|void
name|report_file_and_line
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|warn
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|warn
decl_stmt|;
block|{
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn
condition|)
name|notice
argument_list|(
literal|"warning: "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a message.  */
end_comment

begin_function
specifier|static
name|void
name|vmessage
parameter_list|(
name|prefix
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|prefix
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a message relevant to line LINE of file FILE.  */
end_comment

begin_function
specifier|static
name|void
name|v_message_with_file_and_line
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|warn
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|warn
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|report_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|warn
argument_list|)
expr_stmt|;
name|vnotice
argument_list|(
name|stderr
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a message relevant to the given DECL.  */
end_comment

begin_function
specifier|static
name|void
name|v_message_with_decl
parameter_list|(
name|decl
parameter_list|,
name|warn
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|warn
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|report_file_and_line
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|warn
argument_list|)
expr_stmt|;
comment|/* Do magic to get around lack of varargs support for insertion      of arguments into existing list.  We know that the decl is first;      we ass_u_me that it will be printed with "%s".  */
for|for
control|(
name|p
operator|=
name|_
argument_list|(
name|msgid
argument_list|)
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'%'
condition|)
operator|++
name|p
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
literal|'s'
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|>
name|_
argument_list|(
name|msgid
argument_list|)
condition|)
comment|/* Print the left-hand substring.  */
block|{
name|char
name|fmt
index|[
sizeof|sizeof
expr|"%.255s"]
expr_stmt|;
name|long
name|width
init|=
name|p
operator|-
name|_
argument_list|(
name|msgid
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|>
literal|255L
condition|)
name|width
operator|=
literal|255L
expr_stmt|;
comment|/* arbitrary */
name|sprintf
argument_list|(
name|fmt
argument_list|,
literal|"%%.%lds"
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
comment|/* Print the name.  */
block|{
specifier|const
name|char
modifier|*
name|n
init|=
operator|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|?
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
else|:
literal|"((anonymous))"
operator|)
decl_stmt|;
name|fputs
argument_list|(
name|n
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|ISALPHA
argument_list|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|&
literal|0xFF
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|p
condition|)
comment|/* Print the rest of the message.  */
name|vmessage
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|p
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Figure file and line of the given INSN.  */
end_comment

begin_function
specifier|static
name|void
name|file_and_line_for_asm
parameter_list|(
name|insn
parameter_list|,
name|pfile
parameter_list|,
name|pline
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|char
modifier|*
modifier|*
name|pfile
decl_stmt|;
name|int
modifier|*
name|pline
decl_stmt|;
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|asmop
decl_stmt|;
comment|/* Find the (or one of the) ASM_OPERANDS in the insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|asmop
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|asmop
operator|=
name|body
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|asmop
operator|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|asmop
operator|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|asmop
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|asmop
condition|)
block|{
operator|*
name|pfile
operator|=
name|ASM_OPERANDS_SOURCE_FILE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
operator|*
name|pline
operator|=
name|ASM_OPERANDS_SOURCE_LINE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pfile
operator|=
name|input_filename
expr_stmt|;
operator|*
name|pline
operator|=
name|lineno
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Report an error at line LINE of file FILE.  */
end_comment

begin_function
specifier|static
name|void
name|v_error_with_file_and_line
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|count_error
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|report_error_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|v_message_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|0
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|error_with_file_and_line
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|file
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|line
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_error_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report an error at the declaration DECL.    MSGID is a format string which uses %s to substitute the declaration    name; subsequent substitutions are a la printf.  */
end_comment

begin_function
specifier|static
name|void
name|v_error_with_decl
parameter_list|(
name|decl
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|count_error
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|report_error_function
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|v_message_with_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|error_with_decl
name|VPROTO
argument_list|(
operator|(
name|tree
name|decl
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|decl
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|tree
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_error_with_decl
argument_list|(
name|decl
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report an error at the line number of the insn INSN.    This is used only when INSN is an `asm' with operands,    and each ASM_OPERANDS records its own source file and line.  */
end_comment

begin_function
specifier|static
name|void
name|v_error_for_asm
parameter_list|(
name|insn
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
name|rtx
name|insn
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|count_error
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|file_and_line_for_asm
argument_list|(
name|insn
argument_list|,
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|report_error_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|v_message_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|0
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|error_for_asm
name|VPROTO
argument_list|(
operator|(
name|rtx
name|insn
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|rtx
name|insn
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|insn
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_error_for_asm
argument_list|(
name|insn
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report an error at the current line number.  */
end_comment

begin_function
specifier|static
name|void
name|verror
parameter_list|(
name|msgid
parameter_list|,
name|ap
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|v_error_with_file_and_line
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|error
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|verror
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report a fatal error at the current line number.  */
end_comment

begin_function
specifier|static
name|void
name|vfatal
parameter_list|(
name|msgid
parameter_list|,
name|ap
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|verror
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|fatal
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vfatal
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report a warning at line LINE of file FILE.  */
end_comment

begin_function
specifier|static
name|void
name|v_warning_with_file_and_line
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|count_error
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|report_error_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|v_message_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|1
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|void
name|warning_with_file_and_line
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|file
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|line
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_warning_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report a warning at the declaration DECL.    MSGID is a format string which uses %s to substitute the declaration    name; subsequent substitutions are a la printf.  */
end_comment

begin_function
specifier|static
name|void
name|v_warning_with_decl
parameter_list|(
name|decl
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|count_error
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|report_error_function
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|v_message_with_decl
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|void
name|warning_with_decl
name|VPROTO
argument_list|(
operator|(
name|tree
name|decl
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|decl
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|tree
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_warning_with_decl
argument_list|(
name|decl
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report a warning at the line number of the insn INSN.    This is used only when INSN is an `asm' with operands,    and each ASM_OPERANDS records its own source file and line.  */
end_comment

begin_function
specifier|static
name|void
name|v_warning_for_asm
parameter_list|(
name|insn
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
name|rtx
name|insn
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|count_error
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|file_and_line_for_asm
argument_list|(
name|insn
argument_list|,
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|report_error_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|v_message_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|1
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|void
name|warning_for_asm
name|VPROTO
argument_list|(
operator|(
name|rtx
name|insn
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|rtx
name|insn
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|insn
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_warning_for_asm
argument_list|(
name|insn
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report a warning at the current line number.  */
end_comment

begin_function
specifier|static
name|void
name|vwarning
parameter_list|(
name|msgid
parameter_list|,
name|ap
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|v_warning_with_file_and_line
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|warning
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vwarning
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* These functions issue either warnings or errors depending on    -pedantic-errors.  */
end_comment

begin_function
specifier|static
name|void
name|vpedwarn
parameter_list|(
name|msgid
parameter_list|,
name|ap
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|flag_pedantic_errors
condition|)
name|verror
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|else
name|vwarning
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|pedwarn
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vpedwarn
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|v_pedwarn_with_decl
parameter_list|(
name|decl
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
comment|/* We don't want -pedantic-errors to cause the compilation to fail from      "errors" in system header files.  Sometimes fixincludes can't fix what's      broken (eg: unsigned char bitfields - fixing it may change the alignment      which will cause programs to mysteriously fail because the C library      or kernel uses the original layout).  There's no point in issuing a      warning either, it's just unnecessary noise.  */
if|if
condition|(
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_pedantic_errors
condition|)
name|v_error_with_decl
argument_list|(
name|decl
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|else
name|v_warning_with_decl
argument_list|(
name|decl
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|void
name|pedwarn_with_decl
name|VPROTO
argument_list|(
operator|(
name|tree
name|decl
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|decl
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|tree
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_pedwarn_with_decl
argument_list|(
name|decl
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|v_pedwarn_with_file_and_line
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|flag_pedantic_errors
condition|)
name|v_error_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|else
name|v_warning_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|pedwarn_with_file_and_line
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|file
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|line
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_pedwarn_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Apologize for not implementing some feature.  */
end_comment

begin_function
specifier|static
name|void
name|vsorry
parameter_list|(
name|msgid
parameter_list|,
name|ap
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|sorrycount
operator|++
expr_stmt|;
if|if
condition|(
name|input_filename
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|notice
argument_list|(
literal|"sorry, not implemented: "
argument_list|)
expr_stmt|;
name|vnotice
argument_list|(
name|stderr
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|sorry
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsorry
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Given a partial pathname as input, return another pathname that shares    no elements with the pathname of __FILE__.  This is used by abort() to    print `Internal compiler error in expr.c' instead of `Internal compiler    error in ../../egcs/gcc/expr.c'.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|trim_filename
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
name|this_file
init|=
name|__FILE__
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|name
decl_stmt|,
modifier|*
name|q
init|=
name|this_file
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
operator|*
name|q
operator|&&
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|q
operator|!=
literal|0
condition|)
name|p
operator|++
operator|,
name|q
operator|++
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|name
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR
ifdef|#
directive|ifdef
name|DIR_SEPARATOR_2
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR_2
endif|#
directive|endif
condition|)
name|p
operator|--
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.     I don't think this is actually a good idea.    Other sorts of crashes will look a certain way.    It is a good thing if crashes from calling abort look the same way.      -- RMS  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"internal gcc abort"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This calls abort and is used to avoid problems when abort if a macro.    It is used when we need to pass the address of abort.  */
end_comment

begin_function
name|void
name|do_abort
parameter_list|()
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When `malloc.c' is compiled with `rcheck' defined,    it calls this function to report clobberage.  */
end_comment

begin_function
name|void
name|botch
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as `malloc' but report error if no memory available.  */
end_comment

begin_function
name|PTR
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|value
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|value
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Same as `calloc' but report error if no memory available.  */
end_comment

begin_function
name|PTR
name|xcalloc
parameter_list|(
name|size1
parameter_list|,
name|size2
parameter_list|)
name|size_t
name|size1
decl_stmt|,
name|size2
decl_stmt|;
block|{
specifier|register
name|PTR
name|value
decl_stmt|;
if|if
condition|(
name|size1
operator|==
literal|0
operator|||
name|size2
operator|==
literal|0
condition|)
name|size1
operator|=
name|size2
operator|=
literal|1
expr_stmt|;
name|value
operator|=
operator|(
name|PTR
operator|)
name|calloc
argument_list|(
name|size1
argument_list|,
name|size2
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Same as `realloc' but report error if no memory available.      Also handle null PTR even if the vendor realloc gets it wrong.  */
end_comment

begin_function
name|PTR
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|PTR
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|result
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|result
operator|=
operator|(
name|ptr
condition|?
operator|(
name|PTR
operator|)
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
else|:
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Same as `strdup' but report error if no memory available.  */
end_comment

begin_function
name|char
modifier|*
name|xstrdup
parameter_list|(
name|s
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the logarithm of X, base 2, considering X unsigned,    if X is a power of 2.  Otherwise, returns -1.     This should be used via the `exact_log2' macro.  */
end_comment

begin_function
name|int
name|exact_log2_wide
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|HOST_WIDE_INT
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|log
init|=
literal|0
decl_stmt|;
comment|/* Test for 0 or a power of 2.  */
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|x
operator|!=
operator|(
name|x
operator|&
operator|-
name|x
operator|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
name|x
operator|>>=
literal|1
operator|)
operator|!=
literal|0
condition|)
name|log
operator|++
expr_stmt|;
return|return
name|log
return|;
block|}
end_function

begin_comment
comment|/* Given X, an unsigned number, return the largest int Y such that 2**Y<= X.    If X is 0, return -1.     This should be used via the floor_log2 macro.  */
end_comment

begin_function
name|int
name|floor_log2_wide
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|HOST_WIDE_INT
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|log
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
name|log
operator|++
operator|,
name|x
operator|>>=
literal|1
expr_stmt|;
return|return
name|log
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|float_handler_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|float_handled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|float_handler
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Signals actually come here.  */
end_comment

begin_function
specifier|static
name|void
name|float_signal
parameter_list|(
name|signo
parameter_list|)
comment|/* If this is missing, some compilers complain.  */
name|int
name|signo
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|float_handled
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|hpux
argument_list|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_signal
argument_list|)
expr_stmt|;
comment|/* re-enable the signal catcher */
endif|#
directive|endif
name|float_handled
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_signal
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|float_handler
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Specify where to longjmp to when a floating arithmetic error happens.    If HANDLER is 0, it means don't handle the errors any more.  */
end_comment

begin_function
name|void
name|set_float_handler
parameter_list|(
name|handler
parameter_list|)
name|jmp_buf
name|handler
decl_stmt|;
block|{
name|float_handled
operator|=
operator|(
name|handler
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|handler
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|handler
argument_list|,
operator|(
name|char
operator|*
operator|)
name|float_handler
argument_list|,
sizeof|sizeof
argument_list|(
name|float_handler
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|float_handled
operator|&&
operator|!
name|float_handler_set
condition|)
block|{
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_signal
argument_list|)
expr_stmt|;
name|float_handler_set
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is a wrapper function for code which might elicit an    arithmetic exception.  That code should be passed in as a function    pointer FN, and one argument DATA.  DATA is usually a struct which    contains the real input and output for function FN.  This function    returns 0 (failure) if longjmp was called (i.e. an exception    occured.)  It returns 1 (success) otherwise. */
end_comment

begin_function_decl
name|int
name|do_float_handler
parameter_list|(
name|fn
parameter_list|,
name|data
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*fn
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|jmp_buf
name|buf
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|buf
argument_list|)
condition|)
block|{
comment|/* We got here via longjmp() caused by an exception in function fn() */
name|set_float_handler
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|set_float_handler
argument_list|(
name|buf
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fn
call|)
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|set_float_handler
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Specify, in HANDLER, where to longjmp to when a floating arithmetic    error happens, pushing the previous specification into OLD_HANDLER.    Return an indication of whether there was a previous handler in effect.  */
end_comment

begin_function
name|int
name|push_float_handler
parameter_list|(
name|handler
parameter_list|,
name|old_handler
parameter_list|)
name|jmp_buf
name|handler
decl_stmt|,
name|old_handler
decl_stmt|;
block|{
name|int
name|was_handled
init|=
name|float_handled
decl_stmt|;
name|float_handled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|was_handled
condition|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|old_handler
argument_list|,
operator|(
name|char
operator|*
operator|)
name|float_handler
argument_list|,
sizeof|sizeof
argument_list|(
name|float_handler
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|float_handler
argument_list|,
operator|(
name|char
operator|*
operator|)
name|handler
argument_list|,
sizeof|sizeof
argument_list|(
name|float_handler
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|was_handled
return|;
block|}
end_function

begin_comment
comment|/* Restore the previous specification of whether and where to longjmp to    when a floating arithmetic error happens.  */
end_comment

begin_function
name|void
name|pop_float_handler
parameter_list|(
name|handled
parameter_list|,
name|handler
parameter_list|)
name|int
name|handled
decl_stmt|;
name|jmp_buf
name|handler
decl_stmt|;
block|{
name|float_handled
operator|=
name|handled
expr_stmt|;
if|if
condition|(
name|handled
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|handler
argument_list|,
operator|(
name|char
operator|*
operator|)
name|float_handler
argument_list|,
sizeof|sizeof
argument_list|(
name|float_handler
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handler for SIGPIPE.  */
end_comment

begin_function
specifier|static
name|void
name|pipe_closed
parameter_list|(
name|signo
parameter_list|)
comment|/* If this is missing, some compilers complain.  */
name|int
name|signo
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|fatal
argument_list|(
literal|"output pipe has been closed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Strip off a legitimate source ending from the input string NAME of    length LEN.  Rather than having to know the names used by all of    our front ends, we strip off an ending of a period followed by    up to five characters.  (Java uses ".class".) */
end_comment

begin_function
name|void
name|strip_off_ending
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|6
operator|&&
name|len
operator|>
name|i
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name
index|[
name|len
operator|-
name|i
index|]
operator|==
literal|'.'
condition|)
block|{
name|name
index|[
name|len
operator|-
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output a quoted string.  */
end_comment

begin_function
name|void
name|output_quoted_string
parameter_list|(
name|asm_file
parameter_list|,
name|string
parameter_list|)
name|FILE
modifier|*
name|asm_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OUTPUT_QUOTED_STRING
name|OUTPUT_QUOTED_STRING
argument_list|(
name|asm_file
argument_list|,
name|string
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
name|c
decl_stmt|;
name|putc
argument_list|(
literal|'\"'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\"'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output a file name in the form wanted by System V.  */
end_comment

begin_function
name|void
name|output_file_directive
parameter_list|(
name|asm_file
parameter_list|,
name|input_name
parameter_list|)
name|FILE
modifier|*
name|asm_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|input_name
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|input_name
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|na
init|=
name|input_name
operator|+
name|len
decl_stmt|;
comment|/* NA gets INPUT_NAME sans directory names.  */
while|while
condition|(
name|na
operator|>
name|input_name
condition|)
block|{
if|if
condition|(
name|na
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
break|break;
ifdef|#
directive|ifdef
name|DIR_SEPARATOR
if|if
condition|(
name|na
index|[
operator|-
literal|1
index|]
operator|==
name|DIR_SEPARATOR
condition|)
break|break;
endif|#
directive|endif
name|na
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MAIN_SOURCE_FILENAME
name|ASM_OUTPUT_MAIN_SOURCE_FILENAME
argument_list|(
name|asm_file
argument_list|,
name|na
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_FILENAME
name|ASM_OUTPUT_SOURCE_FILENAME
argument_list|(
name|asm_file
argument_list|,
name|na
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\t.file\t"
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|asm_file
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_IDENTIFY_LANGUAGE
end_ifdef

begin_comment
comment|/* Routine to build language identifier for object file.  */
end_comment

begin_function
specifier|static
name|void
name|output_lang_identify
parameter_list|(
name|asm_out_file
parameter_list|)
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|lang_identify
argument_list|()
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"__gnu_compiled_"
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"__gnu_compiled_%s"
argument_list|,
name|lang_identify
argument_list|()
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Routine to open a dump file.  */
end_comment

begin_function
specifier|static
name|void
name|open_dump_file
parameter_list|(
name|suffix
parameter_list|,
name|function_name
parameter_list|)
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
specifier|const
name|char
modifier|*
name|function_name
decl_stmt|;
block|{
name|char
modifier|*
name|dumpname
decl_stmt|;
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{        dumpname = (char *) xmalloc (strlen (dump_base_name) + strlen (suffix) +
literal|1
argument|);         if (rtl_dump_file != NULL) 	 fclose (rtl_dump_file);           strcpy (dumpname, dump_base_name);        strcat (dumpname, suffix);                rtl_dump_file = fopen (dumpname,
literal|"a"
argument|);                if (rtl_dump_file == NULL) 	 pfatal_with_name (dumpname);                free (dumpname);         if (function_name) 	 fprintf (rtl_dump_file,
literal|"\n;; Function %s\n\n"
argument|, function_name);      }
argument_list|)
empty_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Routine to close a dump file.  */
end_comment

begin_function_decl
specifier|static
name|void
name|close_dump_file
parameter_list|(
name|func
parameter_list|,
name|insns
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|rtx
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|rtx
name|insns
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{        if (func) 	 func (rtl_dump_file, insns);                fflush (rtl_dump_file);        fclose (rtl_dump_file);                rtl_dump_file = NULL;      }
argument_list|)
empty_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/* Routine to dump rtl into a file.  */
end_comment

begin_function_decl
specifier|static
name|void
name|dump_rtl
parameter_list|(
name|suffix
parameter_list|,
name|decl
parameter_list|,
name|func
parameter_list|,
name|insns
parameter_list|)
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
name|tree
name|decl
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|rtx
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|rtx
name|insns
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|open_dump_file
argument_list|(
name|suffix
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|func
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Routine to empty a dump file.  */
end_comment

begin_function
specifier|static
name|void
name|clean_dump_file
parameter_list|(
name|suffix
parameter_list|)
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
block|{
name|char
modifier|*
name|dumpname
decl_stmt|;
name|dumpname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dump_base_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|rtl_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
operator|==
name|NULL
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|rtl_dump_file
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Do any final processing required for the declarations in VEC, of    which there are LEN.  We write out inline functions and variables    that have been deferred until this point, but which are required.    Returns non-zero if anything was put out.  */
end_comment

begin_function
name|int
name|wrapup_global_declarations
parameter_list|(
name|vec
parameter_list|,
name|len
parameter_list|)
name|tree
modifier|*
name|vec
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|reconsider
decl_stmt|;
name|int
name|output_something
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|vec
index|[
name|i
index|]
expr_stmt|;
comment|/* We're not deferring this any longer.  */
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|incomplete_decl_finalize_hook
operator|!=
literal|0
condition|)
call|(
modifier|*
name|incomplete_decl_finalize_hook
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Now emit any global variables or functions that we have been      putting off.  We need to loop in case one of the things emitted      here references another one which comes earlier in the list.  */
do|do
block|{
name|reconsider
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|vec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
continue|continue;
comment|/* Don't write out static consts, unless we still need them.  	     We also keep static consts if not optimizing (for debugging), 	     unless the user specified -fno-keep-static-consts. 	     ??? They might be better written into the debug information. 	     This is possible when using DWARF.  	     A language processor that wants static constants to be always 	     written out (even if it is not used) is responsible for 	     calling rest_of_decl_compilation itself.  E.g. the C front-end 	     calls rest_of_decl_compilation from finish_decl. 	     One motivation for this is that is conventional in some 	     environments to write things like: 	     static const char rcsid[] = "... version string ..."; 	     intending to force the string to be in the executable.  	     A language processor that would prefer to have unneeded 	     static constants "optimized away" would just defer writing 	     them out until here.  E.g. C++ does this, because static 	     constants are often defined in header files.  	     ??? A tempting alternative (for both C and C++) would be 	     to force a constant to be written if and only if it is 	     defined in a main file, as opposed to an include file.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
operator|!
name|optimize
operator|&&
name|flag_keep_static_consts
operator|)
operator|||
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|reconsider
operator|=
literal|1
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|flag_keep_inline_functions
operator|||
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|reconsider
operator|=
literal|1
expr_stmt|;
name|temporary_allocation
argument_list|()
expr_stmt|;
name|output_inline_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|permanent_allocation
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reconsider
condition|)
name|output_something
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|reconsider
condition|)
do|;
return|return
name|output_something
return|;
block|}
end_function

begin_comment
comment|/* Issue appropriate warnings for the global declarations in VEC (of    which there are LEN).  Output debugging information for them.  */
end_comment

begin_function
name|void
name|check_global_declarations
parameter_list|(
name|vec
parameter_list|,
name|len
parameter_list|)
name|tree
modifier|*
name|vec
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|vec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Cancel the RTL for this decl so that, if debugging info 	   output for global variables is still to come, 	   this one will be omitted.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* Warn about any function 	 declared static but not defined. 	 We don't warn about variables, 	 because many programs have static variables 	 that exist only to get some text into the object file.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|warn_unused
operator|||
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|pedwarn_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' used but never defined"
argument_list|)
expr_stmt|;
else|else
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' declared `static' but never defined"
argument_list|)
expr_stmt|;
comment|/* This symbol is effectively an "extern" declaration now.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|assemble_external
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about static fns or vars defined but not used, 	 but not about inline functions or static consts 	 since defining those in header files is normal practice.  */
if|if
condition|(
name|warn_unused
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|)
comment|/* The TREE_USED bit for file-scope decls 	     is kept in the identifier, to handle multiple 	     external decls in different scopes.  */
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' defined but not used"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
comment|/* The COFF linker can move initialized global vars to the end. 	 And that can screw up the symbol ordering. 	 By putting the symbols in that order to begin with, 	 we avoid a problem.  mcsun!unido!fauern!tumuc!pes@uunet.uu.net.  */
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output COFF information for non-global 	 file-scope initialized variables.  */
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|sdbout_toplevel_data
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SDB_DEBUGGING_INFO */
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
comment|/* Output DWARF information for file-scope tentative data object 	 declarations, file-scope (extern) function declarations (which 	 had no corresponding body) and file-scope tagged type declarations 	 and definitions which have not yet been forced out.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dwarfout_file_scope_decl
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
comment|/* Output DWARF2 information for file-scope tentative data object 	 declarations, file-scope (extern) function declarations (which 	 had no corresponding body) and file-scope tagged type declarations 	 and definitions which have not yet been forced out.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dwarf2out_decl
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Compile an entire file of output from cpp, named NAME.    Write a file of assembly output and various debugging dumps.  */
end_comment

begin_function
specifier|static
name|void
name|compile_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|tree
name|globals
decl_stmt|;
name|int
name|start_time
decl_stmt|;
name|int
name|name_specified
init|=
name|name
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|dump_base_name
operator|==
literal|0
condition|)
name|dump_base_name
operator|=
name|name
condition|?
name|name
else|:
literal|"gccdump"
expr_stmt|;
name|parse_time
operator|=
literal|0
expr_stmt|;
name|varconst_time
operator|=
literal|0
expr_stmt|;
name|integration_time
operator|=
literal|0
expr_stmt|;
name|jump_time
operator|=
literal|0
expr_stmt|;
name|cse_time
operator|=
literal|0
expr_stmt|;
name|gcse_time
operator|=
literal|0
expr_stmt|;
name|loop_time
operator|=
literal|0
expr_stmt|;
name|cse2_time
operator|=
literal|0
expr_stmt|;
name|branch_prob_time
operator|=
literal|0
expr_stmt|;
name|flow_time
operator|=
literal|0
expr_stmt|;
name|combine_time
operator|=
literal|0
expr_stmt|;
name|regmove_time
operator|=
literal|0
expr_stmt|;
name|sched_time
operator|=
literal|0
expr_stmt|;
name|local_alloc_time
operator|=
literal|0
expr_stmt|;
name|global_alloc_time
operator|=
literal|0
expr_stmt|;
name|flow2_time
operator|=
literal|0
expr_stmt|;
name|sched2_time
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DELAY_SLOTS
name|dbr_sched_time
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|shorten_branch_time
operator|=
literal|0
expr_stmt|;
name|stack_reg_time
operator|=
literal|0
expr_stmt|;
name|final_time
operator|=
literal|0
expr_stmt|;
name|symout_time
operator|=
literal|0
expr_stmt|;
name|dump_time
operator|=
literal|0
expr_stmt|;
comment|/* Initialize data in various passes.  */
name|init_obstacks
argument_list|()
expr_stmt|;
name|init_tree_codes
argument_list|()
expr_stmt|;
name|name
operator|=
name|init_parse
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|init_rtl
argument_list|()
expr_stmt|;
name|init_emit_once
argument_list|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NORMAL
operator|||
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|||
name|flag_test_coverage
argument_list|)
expr_stmt|;
name|init_regs
argument_list|()
expr_stmt|;
name|init_decl_processing
argument_list|()
expr_stmt|;
name|init_optabs
argument_list|()
expr_stmt|;
name|init_stmt
argument_list|()
expr_stmt|;
name|init_expmed
argument_list|()
expr_stmt|;
name|init_expr_once
argument_list|()
expr_stmt|;
name|init_loop
argument_list|()
expr_stmt|;
name|init_reload
argument_list|()
expr_stmt|;
name|init_alias_once
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_caller_saves
condition|)
name|init_caller_save
argument_list|()
expr_stmt|;
comment|/* If auxiliary info generation is desired, open the output file.      This goes in the same directory as the source file--unlike      all the other output files.  */
if|if
condition|(
name|flag_gen_aux_info
condition|)
block|{
name|aux_info_file
operator|=
name|fopen
argument_list|(
name|aux_info_file_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux_info_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|aux_info_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the dump files.  */
if|if
condition|(
name|rtl_dump
condition|)
name|clean_dump_file
argument_list|(
literal|".rtl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump_opt_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".jump"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".jump"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addressof_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".addressof"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".addressof"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cse_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".cse"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".cse"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loop_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".loop"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".loop"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cse2_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".cse2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".cse2"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|branch_prob_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".bp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".bp"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flow_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".flow"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".flow"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|combine_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".combine"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".combine"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regmove_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".regmove"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".regmove"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sched_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".sched"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".sched"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_reg_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".lreg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".lreg"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|global_reg_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".greg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".greg"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flow2_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".flow2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".flow2"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sched2_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".sched2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".sched2"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|jump2_opt_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".jump2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".jump2"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DELAY_SLOTS
if|if
condition|(
name|dbr_sched_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".dbr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".dbr"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|gcse_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".gcse"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".gcse"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STACK_REGS
if|if
condition|(
name|stack_reg_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".stack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".stack"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MACHINE_DEPENDENT_REORG
if|if
condition|(
name|mach_dep_reorg_dump
condition|)
block|{
name|clean_dump_file
argument_list|(
literal|".mach"
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|clean_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".mach"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Open assembler code output file.  */
if|if
condition|(
name|flag_syntax_only
condition|)
name|asm_out_file
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|name_specified
operator|&&
name|asm_file_name
operator|==
literal|0
condition|)
name|asm_out_file
operator|=
name|stdout
expr_stmt|;
else|else
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|dump_base_name
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strip_off_ending
argument_list|(
name|dumpname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_file_name
operator|==
literal|0
condition|)
block|{
name|asm_file_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dumpname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|asm_file_name
argument_list|,
name|dumpname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asm_file_name
argument_list|,
literal|"-"
argument_list|)
condition|)
name|asm_out_file
operator|=
name|stdout
expr_stmt|;
else|else
name|asm_out_file
operator|=
name|fopen
argument_list|(
name|asm_file_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_out_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|asm_file_name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IO_BUFFER_SIZE
name|setvbuf
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|IO_BUFFER_SIZE
argument_list|)
argument_list|,
name|_IOFBF
argument_list|,
name|IO_BUFFER_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|input_filename
operator|=
name|name
expr_stmt|;
comment|/* Put an entry on the input file stack for the main input file.  */
name|input_file_stack
operator|=
operator|(
expr|struct
name|file_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_stack
argument_list|)
argument_list|)
expr_stmt|;
name|input_file_stack
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|input_file_stack
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
comment|/* Perform language-specific initialization.      This may set main_input_filename.  */
name|lang_init
argument_list|()
expr_stmt|;
comment|/* If the input doesn't start with a #line, use the input name      as the official input file name.  */
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
name|main_input_filename
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|flag_syntax_only
condition|)
block|{
name|write_symbols
operator|=
name|NO_DEBUG
expr_stmt|;
name|profile_flag
operator|=
literal|0
expr_stmt|;
name|profile_block_flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ASM_FILE_START
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_COMMENT_START
if|if
condition|(
name|flag_verbose_asm
condition|)
block|{
comment|/* Print the list of options in effect.  */
name|print_version
argument_list|(
name|asm_out_file
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|print_switch_values
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|,
name|MAX_LINE
argument_list|,
name|ASM_COMMENT_START
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Add a blank line here so it appears in assembler output but not 	     screen output.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Output something to inform GDB that this compilation was by GCC.  */
ifndef|#
directive|ifndef
name|ASM_IDENTIFY_GCC
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"gcc2_compiled.:\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_IDENTIFY_GCC
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Output something to identify which front-end produced this file.  */
ifdef|#
directive|ifdef
name|ASM_IDENTIFY_LANGUAGE
name|ASM_IDENTIFY_LANGUAGE
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* ! flag_syntax_only */
ifndef|#
directive|ifndef
name|ASM_OUTPUT_SECTION_NAME
if|if
condition|(
name|flag_function_sections
condition|)
block|{
name|warning
argument_list|(
literal|"-ffunction-sections not supported for this target."
argument_list|)
expr_stmt|;
name|flag_function_sections
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag_data_sections
condition|)
block|{
name|warning
argument_list|(
literal|"-fdata-sections not supported for this target."
argument_list|)
expr_stmt|;
name|flag_data_sections
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|flag_function_sections
operator|&&
operator|(
name|profile_flag
operator|||
name|profile_block_flag
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"-ffunction-sections disabled; it makes profiling impossible."
argument_list|)
expr_stmt|;
name|flag_function_sections
operator|=
literal|0
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OBJECT_FORMAT_ELF
if|if
condition|(
name|flag_function_sections
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|warning
argument_list|(
literal|"-ffunction-sections may affect debugging on some targets."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ??? Note: There used to be a conditional here       to call assemble_zeros without fail if DBX_DEBUGGING_INFO is defined.       This was to guarantee separation between gcc_compiled. and       the first function, for the sake of dbx on Suns.       However, having the extra zero here confused the Emacs       code for unexec, and might confuse other programs too.       Therefore, I took out that change.       In future versions we should find another way to solve       that dbx problem.  -- rms, 23 May 93.  */
comment|/* Don't let the first function fall at the same address      as gcc_compiled., if profiling.  */
if|if
condition|(
name|profile_flag
operator|||
name|profile_block_flag
condition|)
block|{
comment|/* It's best if we can write a nop here since some 	 assemblers don't tolerate zeros in the text section.  */
if|if
condition|(
name|insn_template
index|[
name|CODE_FOR_nop
index|]
operator|!=
literal|0
condition|)
name|output_asm_insn
argument_list|(
name|insn_template
index|[
name|CODE_FOR_nop
index|]
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
else|else
name|assemble_zeros
argument_list|(
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
comment|/* If dbx symbol table desired, initialize writing it      and output the predefined types.  */
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dbxout_init
argument_list|(
name|asm_out_file
argument_list|,
name|main_input_filename
argument_list|,
name|getdecls
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|sdbout_init
argument_list|(
name|asm_out_file
argument_list|,
name|main_input_filename
argument_list|,
name|getdecls
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dwarfout_init
argument_list|(
name|asm_out_file
argument_list|,
name|main_input_filename
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dwarf2out_init
argument_list|(
name|asm_out_file
argument_list|,
name|main_input_filename
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize yet another pass.  */
name|init_final
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
name|init_branch_prob
argument_list|(
name|dump_base_name
argument_list|)
expr_stmt|;
name|start_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
comment|/* Call the parser, which parses the entire file      (calling rest_of_compilation for each function).  */
if|if
condition|(
name|yyparse
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errorcount
operator|==
literal|0
condition|)
name|notice
argument_list|(
literal|"Errors detected in input file (your bison.simple is out of date)\n"
argument_list|)
expr_stmt|;
comment|/* In case there were missing closebraces, 	 get us back to the global binding level.  */
while|while
condition|(
operator|!
name|global_bindings_p
argument_list|()
condition|)
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Compilation is now finished except for writing      what's left of the symbol table output.  */
name|parse_time
operator|+=
name|get_run_time
argument_list|()
operator|-
name|start_time
expr_stmt|;
name|parse_time
operator|-=
name|integration_time
expr_stmt|;
name|parse_time
operator|-=
name|varconst_time
expr_stmt|;
if|if
condition|(
name|flag_syntax_only
condition|)
goto|goto
name|finish_syntax
goto|;
name|globals
operator|=
name|getdecls
argument_list|()
expr_stmt|;
comment|/* Really define vars that have had only a tentative definition.      Really output inline functions that must actually be callable      and have not been output so far.  */
block|{
name|int
name|len
init|=
name|list_length
argument_list|(
name|globals
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|vec
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|len
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|decl
decl_stmt|;
comment|/* Process the decls in reverse order--earliest first.        Put them into VEC from back to front, then take out from front.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|decl
operator|=
name|globals
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|vec
index|[
name|len
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|decl
expr_stmt|;
name|wrapup_global_declarations
argument_list|(
name|vec
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* This must occur after the loop to output deferred functions.  Else        the profiler initializer would not be emitted if all the functions        in this compilation unit were deferred.         output_func_start_profiler can not cause any additional functions or        data to need to be output, so it need not be in the deferred function        loop above.  */
name|output_func_start_profiler
argument_list|()
expr_stmt|;
comment|/* Now that all possible functions have been output, we can dump        the exception table.  */
name|output_exception_table
argument_list|()
expr_stmt|;
name|check_global_declarations
argument_list|(
name|vec
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Write out any pending weak symbol declarations.  */
name|weak_finish
argument_list|()
expr_stmt|;
comment|/* Do dbx symbols */
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|TIMEVAR
argument_list|(
argument|symout_time
argument_list|,
argument|{ 	       dbxout_finish (asm_out_file, main_input_filename); 	     }
argument_list|)
empty_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|TIMEVAR
argument_list|(
argument|symout_time
argument_list|,
argument|{ 	       dwarfout_finish (); 	     }
argument_list|)
empty_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_finish
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
name|TIMEVAR
argument_list|(
argument|symout_time
argument_list|,
argument|{ 	       dwarf2out_finish (); 	     }
argument_list|)
empty_stmt|;
endif|#
directive|endif
comment|/* Output some stuff at end of file if nec.  */
name|end_final
argument_list|(
name|dump_base_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch_prob_dump
condition|)
name|open_dump_file
argument_list|(
literal|".bp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|dump_time
argument_list|,
name|end_branch_prob
argument_list|(
name|rtl_dump_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch_prob_dump
condition|)
name|close_dump_file
argument_list|(
name|NULL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_FILE_END
name|ASM_FILE_END
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Language-specific end of compilation actions.  */
name|finish_syntax
label|:
name|lang_finish
argument_list|()
expr_stmt|;
comment|/* Close the dump files.  */
if|if
condition|(
name|flag_gen_aux_info
condition|)
block|{
name|fclose
argument_list|(
name|aux_info_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorcount
condition|)
name|unlink
argument_list|(
name|aux_info_file_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|combine_dump
condition|)
block|{
name|open_dump_file
argument_list|(
literal|".combine"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|dump_time
argument_list|,
name|dump_combine_total_stats
argument_list|(
name|rtl_dump_file
argument_list|)
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|NULL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* Close non-debugging input and output files.  Take special care to note      whether fclose returns an error, since the pages might still be on the      buffer chain while the file is open.  */
name|finish_parse
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|flag_syntax_only
operator|&&
operator|(
name|ferror
argument_list|(
name|asm_out_file
argument_list|)
operator|!=
literal|0
operator|||
name|fclose
argument_list|(
name|asm_out_file
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|fatal_io_error
argument_list|(
name|asm_file_name
argument_list|)
expr_stmt|;
comment|/* Do whatever is necessary to finish printing the graphs.  */
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
block|{
if|if
condition|(
name|jump_opt_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".jump"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressof_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".addressof"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cse_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".cse"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".loop"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cse2_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".cse2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch_prob_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".bp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".flow"
argument_list|)
expr_stmt|;
if|if
condition|(
name|combine_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".combine"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regmove_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".regmove"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".sched"
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_reg_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".lreg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_reg_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".greg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow2_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".flow2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched2_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".sched2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump2_opt_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".jump2"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DELAY_SLOTS
if|if
condition|(
name|dbr_sched_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".dbr"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|gcse_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".gcse"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
if|if
condition|(
name|stack_reg_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".stack"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MACHINE_DEPENDENT_REORG
if|if
condition|(
name|mach_dep_reorg_dump
condition|)
name|finish_graph_dump_file
argument_list|(
name|dump_base_name
argument_list|,
literal|".mach"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Free up memory for the benefit of leak detectors.  */
name|free_reg_info
argument_list|()
expr_stmt|;
comment|/* Print the times.  */
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"parse"
argument_list|,
name|parse_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"integration"
argument_list|,
name|integration_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"jump"
argument_list|,
name|jump_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"cse"
argument_list|,
name|cse_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"gcse"
argument_list|,
name|gcse_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"loop"
argument_list|,
name|loop_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"cse2"
argument_list|,
name|cse2_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"branch-prob"
argument_list|,
name|branch_prob_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"flow"
argument_list|,
name|flow_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"combine"
argument_list|,
name|combine_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"regmove"
argument_list|,
name|regmove_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"sched"
argument_list|,
name|sched_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"local-alloc"
argument_list|,
name|local_alloc_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"global-alloc"
argument_list|,
name|global_alloc_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"flow2"
argument_list|,
name|flow2_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"sched2"
argument_list|,
name|sched2_time
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DELAY_SLOTS
name|print_time
argument_list|(
literal|"dbranch"
argument_list|,
name|dbr_sched_time
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|print_time
argument_list|(
literal|"shorten-branch"
argument_list|,
name|shorten_branch_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"stack-reg"
argument_list|,
name|stack_reg_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"final"
argument_list|,
name|final_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"varconst"
argument_list|,
name|varconst_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"symout"
argument_list|,
name|symout_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"dump"
argument_list|,
name|dump_time
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is called from various places for FUNCTION_DECL, VAR_DECL,    and TYPE_DECL nodes.     This does nothing for local (non-static) variables.    Otherwise, it sets up the RTL and outputs any assembler code    (label definition, storage allocation and initialization).     DECL is the declaration.  If ASMSPEC is nonzero, it specifies    the assembler symbol name to be used.  TOP_LEVEL is nonzero    if this declaration is not within a function.  */
end_comment

begin_function
name|void
name|rest_of_decl_compilation
parameter_list|(
name|decl
parameter_list|,
name|asmspec
parameter_list|,
name|top_level
parameter_list|,
name|at_end
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|asmspec
decl_stmt|;
name|int
name|top_level
decl_stmt|;
name|int
name|at_end
decl_stmt|;
block|{
comment|/* Declarations of variables, and of functions defined elsewhere.  */
comment|/* The most obvious approach, to put an #ifndef around where    this macro is used, doesn't work since it's inside a macro call.  */
ifndef|#
directive|ifndef
name|ASM_FINISH_DECLARE_OBJECT
define|#
directive|define
name|ASM_FINISH_DECLARE_OBJECT
parameter_list|(
name|FILE
parameter_list|,
name|DECL
parameter_list|,
name|TOP
parameter_list|,
name|END
parameter_list|)
endif|#
directive|endif
comment|/* Forward declarations for nested functions are not "external",      but we need to treat them as if they were.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TIMEVAR
argument_list|(
argument|varconst_time
argument_list|,
argument|{ 	       make_decl_rtl (decl, asmspec, top_level);
comment|/* Initialized extern variable exists to be replaced 		  with its value, or represents something that will be 		  output in another file.  */
argument|if (! (TREE_CODE (decl) == VAR_DECL&& DECL_EXTERNAL (decl)&& TREE_READONLY (decl)&& DECL_INITIAL (decl) !=
literal|0
argument|&& DECL_INITIAL (decl) != error_mark_node))
comment|/* Don't output anything 		    when a tentative file-scope definition is seen. 		    But at end of compilation, do output code for them.  */
argument|if (! (! at_end&& top_level&& (DECL_INITIAL (decl) ==
literal|0
argument||| DECL_INITIAL (decl) == error_mark_node))) 		   assemble_variable (decl, top_level, at_end,
literal|0
argument|); 	       if (decl == last_assemble_variable_decl) 		 { 		   ASM_FINISH_DECLARE_OBJECT (asm_out_file, decl, 					      top_level, at_end); 		 } 	     }
argument_list|)
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
name|asmspec
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|decode_reg_name
argument_list|(
name|asmspec
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|top_level
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"invalid register name `%s' for register variable"
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
elseif|else
if|if
condition|(
operator|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|top_level
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Called after finishing a record, union or enumeral type.  */
end_comment

begin_function
name|void
name|rest_of_type_compilation
parameter_list|(
name|type
parameter_list|,
name|toplev
parameter_list|)
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|SDB_DEBUGGING_INFO
argument_list|)
name|tree
name|type
decl_stmt|;
name|int
name|toplev
decl_stmt|;
else|#
directive|else
name|tree
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|toplev
name|ATTRIBUTE_UNUSED
decl_stmt|;
endif|#
directive|endif
block|{
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dbxout_symbol
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|,
operator|!
name|toplev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|sdbout_symbol
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|,
operator|!
name|toplev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This is called from finish_function (within yyparse)    after each top-level definition is parsed.    It is supposed to compile that function or variable    and output the assembler code for it.    After we return, the tree storage is freed.  */
end_comment

begin_function
name|void
name|rest_of_compilation
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|rtx
name|insns
decl_stmt|;
name|int
name|start_time
init|=
name|get_run_time
argument_list|()
decl_stmt|;
name|int
name|tem
decl_stmt|;
comment|/* Nonzero if we have saved the original DECL_INITIAL of the function,      to be restored after we finish compiling the function      (for use when compiling inline calls to this function).  */
name|tree
name|saved_block_tree
init|=
literal|0
decl_stmt|;
comment|/* Likewise, for DECL_ARGUMENTS.  */
name|tree
name|saved_arguments
init|=
literal|0
decl_stmt|;
name|int
name|failure
init|=
literal|0
decl_stmt|;
name|int
name|rebuild_label_notes_after_reload
decl_stmt|;
comment|/* If we are reconsidering an inline function      at the end of compilation, skip the stuff for making it inline.  */
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|inlinable
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|lose
decl_stmt|;
comment|/* If requested, consider whether to make this function inline.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|||
name|flag_inline_functions
condition|)
name|TIMEVAR
argument_list|(
argument|integration_time
argument_list|,
argument|{ 		   lose = function_cannot_inline_p (decl); 		   if (lose || ! optimize) 		     { 		       if (warn_inline&& DECL_INLINE (decl)) 			 warning_with_decl (decl, lose); 		       DECL_ABSTRACT_ORIGIN (decl) =
literal|0
argument|;
comment|/* Don't really compile an extern inline function. 			  If we can't make it inline, pretend 			  it was only declared.  */
argument|if (DECL_EXTERNAL (decl)) 			 { 			   DECL_INITIAL (decl) =
literal|0
argument|; 			   goto exit_rest_of_compilation; 			 } 		     } 		   else
comment|/* ??? Note that this has the effect of making it look 			like "inline" was specified for a function if we choose 			to inline it.  This isn't quite right, but it's 			probably not worth the trouble to fix.  */
argument|inlinable = DECL_INLINE (decl) =
literal|1
argument|; 		 }
argument_list|)
empty_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
comment|/* Dump the rtl code if we are dumping rtl.  */
if|if
condition|(
name|rtl_dump
condition|)
block|{
name|open_dump_file
argument_list|(
literal|".rtl"
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; (integrable)\n\n"
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
comment|/* If we can, defer compiling inlines until EOF. 	 save_for_inline_copying can be extremely expensive.  */
if|if
condition|(
name|inlinable
operator|&&
operator|!
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If function is inline, and we don't yet know whether to 	 compile it by itself, defer decision till end of compilation. 	 finish_compilation will call rest_of_compilation again 	 for those functions that need to be output.  Also defer those 	 functions that we are supposed to defer.  We cannot defer 	 functions containing nested functions since the nested function 	 data is in our non-saved obstack.  We cannot defer nested 	 functions for the same reason.  */
comment|/* If this is a nested inline, remove ADDRESSOF now so we can 	 finish compiling ourselves.  Otherwise, wait until EOF. 	 We have to do this because the purge_addressof transformation 	 changes the DECL_RTL for many variables, which confuses integrate.  */
if|if
condition|(
name|inlinable
condition|)
block|{
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|)
name|purge_addressof
argument_list|(
name|insns
argument_list|)
expr_stmt|;
else|else
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|current_function_contains_functions
operator|&&
operator|(
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|flag_keep_inline_functions
operator|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If -Wreturn-type, we have to do a bit of compilation. 	     However, if we just fall through we will call 	     save_for_inline_copying() which results in excessive 	     memory use.  Instead, we just want to call 	     jump_optimize() to figure out whether or not we can fall 	     off the end of the function; we do the minimum amount of 	     work necessary to make that safe.  And, we set optimize 	     to zero to keep jump_optimize from working too hard.  */
if|if
condition|(
name|warn_return_type
condition|)
block|{
name|int
name|saved_optimize
init|=
name|optimize
decl_stmt|;
name|optimize
operator|=
literal|0
expr_stmt|;
name|find_exception_handler_labels
argument_list|()
expr_stmt|;
name|jump_optimize
argument_list|(
name|get_insns
argument_list|()
argument_list|,
operator|!
name|JUMP_CROSS_JUMP
argument_list|,
operator|!
name|JUMP_NOOP_MOVES
argument_list|,
operator|!
name|JUMP_AFTER_REGSCAN
argument_list|)
expr_stmt|;
name|optimize
operator|=
name|saved_optimize
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
comment|/* Generate the DWARF info for the "abstract" instance 	     of a function which we may later generate inlined and/or 	     out-of-line instances of.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
block|{
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dwarfout_file_scope_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
comment|/* Generate the DWARF2 info for the "abstract" instance 	     of a function which we may later generate inlined and/or 	     out-of-line instances of.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
block|{
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dwarf2out_decl
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|TIMEVAR
argument_list|(
name|integration_time
argument_list|,
name|save_for_inline_nocopy
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|inlinable
expr_stmt|;
goto|goto
name|exit_rest_of_compilation
goto|;
block|}
comment|/* If we have to compile the function now, save its rtl and subdecls 	 so that its compilation will not affect what others get.  */
if|if
condition|(
name|inlinable
operator|||
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
comment|/* Generate the DWARF info for the "abstract" instance of 	     a function which we will generate an out-of-line instance 	     of almost immediately (and which we may also later generate 	     various inlined instances of).  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
block|{
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dwarfout_file_scope_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
comment|/* Generate the DWARF2 info for the "abstract" instance of 	     a function which we will generate an out-of-line instance 	     of almost immediately (and which we may also later generate 	     various inlined instances of).  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
block|{
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dwarf2out_decl
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|saved_block_tree
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|saved_arguments
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|integration_time
argument_list|,
name|save_for_inline_copying
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|inlinable
expr_stmt|;
block|}
comment|/* If specified extern inline but we aren't inlining it, we are 	 done.  This goes for anything that gets here with DECL_EXTERNAL 	 set, not just things with DECL_INLINE.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
goto|goto
name|exit_rest_of_compilation
goto|;
block|}
if|if
condition|(
operator|!
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Now that integrate will no longer see our rtl, we need not distinguish      between the return value of this function and the return value of called      functions.  */
name|rtx_equal_function_value_matters
operator|=
literal|0
expr_stmt|;
comment|/* Don't return yet if -Wreturn-type; we need to do jump_optimize.  */
if|if
condition|(
operator|(
name|rtl_dump_and_exit
operator|||
name|flag_syntax_only
operator|)
operator|&&
operator|!
name|warn_return_type
condition|)
block|{
goto|goto
name|exit_rest_of_compilation
goto|;
block|}
comment|/* Emit code to get eh context, if needed. */
name|emit_eh_context
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FINALIZE_PIC
comment|/* If we are doing position-independent code generation, now      is the time to output special prologues and epilogues.      We do not want to do this earlier, because it just clutters      up inline functions with meaningless insns.  */
if|if
condition|(
name|flag_pic
condition|)
name|FINALIZE_PIC
expr_stmt|;
endif|#
directive|endif
comment|/* From now on, allocate rtl in current_obstack, not in saveable_obstack.      Note that that may have been done above, in save_for_inline_copying.      The call to resume_temporary_allocation near the end of this function      goes back to the usual state of affairs.  This must be done after      we've built up any unwinders for exception handling, and done      the FINALIZE_PIC work, if necessary.  */
name|rtl_in_current_obstack
argument_list|()
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
comment|/* Copy any shared structure that should not be shared.  */
name|unshare_all_rtl
argument_list|(
name|current_function_decl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SETJMP_VIA_SAVE_AREA
comment|/* This must be performed before virutal register instantiation.  */
if|if
condition|(
name|current_function_calls_alloca
condition|)
name|optimize_save_area_alloca
argument_list|(
name|insns
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Instantiate all virtual registers.  */
name|instantiate_virtual_regs
argument_list|(
name|current_function_decl
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* See if we have allocated stack slots that are not directly addressable.      If so, scan all the insns and create explicit address computation      for all references to such slots.  */
comment|/*   fixup_stack_slots (); */
comment|/* Find all the EH handlers.  */
name|find_exception_handler_labels
argument_list|()
expr_stmt|;
comment|/* Always do one jump optimization pass to ensure that JUMP_LABEL fields      are initialized and to compute whether control can drop off the end      of the function.  */
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|jump_optimize
argument_list|(
name|insns
argument_list|,
operator|!
name|JUMP_CROSS_JUMP
argument_list|,
operator|!
name|JUMP_NOOP_MOVES
argument_list|,
name|JUMP_AFTER_REGSCAN
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now is when we stop if -fsyntax-only and -Wreturn-type.  */
if|if
condition|(
name|rtl_dump_and_exit
operator|||
name|flag_syntax_only
operator|||
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
condition|)
goto|goto
name|exit_rest_of_compilation
goto|;
comment|/* Dump rtl code after jump, if we are doing that.  */
if|if
condition|(
name|jump_opt_dump
condition|)
name|dump_rtl
argument_list|(
literal|".jump"
argument_list|,
name|decl
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
comment|/* Perform common subexpression elimination.      Nonzero value from `cse_main' means that jumps were simplified      and some code may now be unreachable, so do      jump optimization again.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cse_dump
condition|)
name|open_dump_file
argument_list|(
literal|".cse"
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|cse_time
argument_list|,
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_thread_jumps
condition|)
comment|/* Hacks by tiemann& kenner.  */
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|thread_jumps
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|cse_time
argument_list|,
name|tem
operator|=
name|cse_main
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|,
name|rtl_dump_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|||
name|optimize
operator|>
literal|1
condition|)
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|jump_optimize
argument_list|(
name|insns
argument_list|,
operator|!
name|JUMP_CROSS_JUMP
argument_list|,
operator|!
name|JUMP_NOOP_MOVES
argument_list|,
operator|!
name|JUMP_AFTER_REGSCAN
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run this after jump optmizations remove all the unreachable code 	 so that unreachable code will not keep values live.  */
name|TIMEVAR
argument_list|(
name|cse_time
argument_list|,
name|delete_trivially_dead_insns
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump rtl code after cse, if we are doing that.  */
if|if
condition|(
name|cse_dump
condition|)
block|{
name|close_dump_file
argument_list|(
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".cse"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
name|purge_addressof
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressof_dump
condition|)
block|{
name|dump_rtl
argument_list|(
literal|".addressof"
argument_list|,
name|decl
argument_list|,
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".addressof"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
comment|/* Perform global cse.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_gcse
condition|)
block|{
if|if
condition|(
name|gcse_dump
condition|)
name|open_dump_file
argument_list|(
literal|".gcse"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|gcse_time
argument_list|,
name|tem
operator|=
name|gcse_main
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If gcse altered any jumps, rerun jump optimizations to clean 	 things up.  */
if|if
condition|(
name|tem
condition|)
block|{
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|jump_optimize
argument_list|(
name|insns
argument_list|,
operator|!
name|JUMP_CROSS_JUMP
argument_list|,
operator|!
name|JUMP_NOOP_MOVES
argument_list|,
operator|!
name|JUMP_AFTER_REGSCAN
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gcse_dump
condition|)
block|{
name|close_dump_file
argument_list|(
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".gcse"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Move constant computations out of loops.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|loop_dump
condition|)
name|open_dump_file
argument_list|(
literal|".loop"
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
argument|loop_time
argument_list|,
argument|{ 	   if (flag_rerun_loop_opt) 	     {
comment|/* We only want to perform unrolling once.  */
argument|loop_optimize (insns, rtl_dump_file,
literal|0
argument|,
literal|0
argument|);
comment|/* The first call to loop_optimize makes some instructions 		  trivially dead.  We delete those instructions now in the 		  hope that doing so will make the heuristics in loop work 		  better and possibly speed up compilation.  */
argument|delete_trivially_dead_insns (insns, max_reg_num ());
comment|/* The regscan pass is currently necessary as the alias 		  analysis code depends on this information.  */
argument|reg_scan (insns, max_reg_num (),
literal|1
argument|); 	     } 	   loop_optimize (insns, rtl_dump_file, flag_unroll_loops,
literal|1
argument|); 	 }
argument_list|)
empty_stmt|;
comment|/* Dump rtl code after loop opt, if we are doing that.  */
if|if
condition|(
name|loop_dump
condition|)
block|{
name|close_dump_file
argument_list|(
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".loop"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cse2_dump
condition|)
name|open_dump_file
argument_list|(
literal|".cse2"
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_rerun_cse_after_loop
condition|)
block|{
comment|/* Running another jump optimization pass before the second 	     cse pass sometimes simplifies the RTL enough to allow 	     the second CSE pass to do a better job.  Jump_optimize can change 	     max_reg_num so we must rerun reg_scan afterwards. 	     ??? Rework to not call reg_scan so often.  */
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|jump_optimize
argument_list|(
name|insns
argument_list|,
operator|!
name|JUMP_CROSS_JUMP
argument_list|,
operator|!
name|JUMP_NOOP_MOVES
argument_list|,
name|JUMP_AFTER_REGSCAN
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|cse2_time
argument_list|,
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|cse2_time
argument_list|,
name|tem
operator|=
name|cse_main
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|,
name|rtl_dump_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|jump_optimize
argument_list|(
name|insns
argument_list|,
operator|!
name|JUMP_CROSS_JUMP
argument_list|,
operator|!
name|JUMP_NOOP_MOVES
argument_list|,
operator|!
name|JUMP_AFTER_REGSCAN
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_thread_jumps
condition|)
block|{
comment|/* This pass of jump threading straightens out code 	     that was kinked by loop optimization.  */
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|thread_jumps
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Dump rtl code after cse, if we are doing that.  */
if|if
condition|(
name|cse2_dump
condition|)
block|{
name|close_dump_file
argument_list|(
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".cse2"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|profile_arc_flag
operator|||
name|flag_test_coverage
operator|||
name|flag_branch_probabilities
condition|)
block|{
if|if
condition|(
name|branch_prob_dump
condition|)
name|open_dump_file
argument_list|(
literal|".bp"
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
argument|branch_prob_time
argument_list|,
argument|{ 	   branch_prob (insns, rtl_dump_file); 	 }
argument_list|)
empty_stmt|;
if|if
condition|(
name|branch_prob_dump
condition|)
block|{
name|close_dump_file
argument_list|(
name|print_rtl
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".bp"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We are no longer anticipating cse in this function, at least.  */
name|cse_not_expected
operator|=
literal|1
expr_stmt|;
comment|/* Now we choose between stupid (pcc-like) register allocation      (if we got the -noreg switch and not -opt)      and smart register allocation.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
comment|/* Stupid allocation probably won't work */
name|obey_regdecls
operator|=
literal|0
expr_stmt|;
comment|/* if optimizations being done.  */
name|regclass_init
argument_list|()
expr_stmt|;
comment|/* Print function header into flow dump now      because doing the flow analysis makes some of the dump.  */
if|if
condition|(
name|flow_dump
condition|)
name|open_dump_file
argument_list|(
literal|".flow"
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obey_regdecls
condition|)
block|{
name|TIMEVAR
argument_list|(
argument|flow_time
argument_list|,
argument|{ 		 regclass (insns, max_reg_num ()); 		 stupid_life_analysis (insns, max_reg_num (), 				       rtl_dump_file); 	       }
argument_list|)
empty_stmt|;
block|}
else|else
block|{
comment|/* Do control and data flow analysis, 	 and write some of the results to dump file.  */
name|TIMEVAR
argument_list|(
argument|flow_time
argument_list|,
argument|{ 	   find_basic_blocks (insns, max_reg_num (), rtl_dump_file,
literal|1
argument|); 	   life_analysis (insns, max_reg_num (), rtl_dump_file,
literal|1
argument|); 	 }
argument_list|)
empty_stmt|;
if|if
condition|(
name|warn_uninitialized
condition|)
block|{
name|uninitialized_vars_warning
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|setjmp_args_warning
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Dump rtl after flow analysis.  */
if|if
condition|(
name|flow_dump
condition|)
block|{
name|close_dump_file
argument_list|(
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".flow"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
comment|/* The first life analysis pass has finished.  From now on we can not      generate any new pseudos.  */
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
comment|/* If -opt, try combining insns through substitution.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|TIMEVAR
argument_list|(
name|combine_time
argument_list|,
name|combine_instructions
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump rtl code after insn combination.  */
if|if
condition|(
name|combine_dump
condition|)
block|{
name|dump_rtl
argument_list|(
literal|".combine"
argument_list|,
name|decl
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".combine"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Register allocation pre-pass, to reduce number of moves      necessary for two-address machines.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
operator|(
name|flag_regmove
operator|||
name|flag_expensive_optimizations
operator|)
condition|)
block|{
if|if
condition|(
name|regmove_dump
condition|)
name|open_dump_file
argument_list|(
literal|".regmove"
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|regmove_time
argument_list|,
name|regmove_optimize
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regmove_dump
condition|)
block|{
name|close_dump_file
argument_list|(
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".regmove"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Print function header into sched dump now      because doing the sched analysis makes some of the dump.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_schedule_insns
condition|)
block|{
if|if
condition|(
name|sched_dump
condition|)
name|open_dump_file
argument_list|(
literal|".sched"
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do control and data sched analysis, 	 and write some of the results to dump file.  */
name|TIMEVAR
argument_list|(
name|sched_time
argument_list|,
name|schedule_insns
argument_list|(
name|rtl_dump_file
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump rtl after instruction scheduling.  */
if|if
condition|(
name|sched_dump
condition|)
block|{
name|close_dump_file
argument_list|(
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".sched"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Determine if the current function is a leaf before running reload      since this can impact optimizations done by the prologue and      epilogue thus changing register elimination offsets.  */
name|current_function_is_leaf
operator|=
name|leaf_function_p
argument_list|()
expr_stmt|;
comment|/* Unless we did stupid register allocation,      allocate pseudo-regs that are used only within 1 basic block.        RUN_JUMP_AFTER_RELOAD records whether or not we need to rerun the      jump optimizer after register allocation and reloading are finished.  */
if|if
condition|(
operator|!
name|obey_regdecls
condition|)
name|TIMEVAR
argument_list|(
argument|local_alloc_time
argument_list|,
argument|{ 	       recompute_reg_usage (insns, ! optimize_size); 	       regclass (insns, max_reg_num ()); 	       rebuild_label_notes_after_reload = local_alloc (); 	     }
argument_list|)
empty_stmt|;
else|else
name|rebuild_label_notes_after_reload
operator|=
literal|0
expr_stmt|;
comment|/* Dump rtl code after allocating regs within basic blocks.  */
if|if
condition|(
name|local_reg_dump
condition|)
block|{
name|open_dump_file
argument_list|(
literal|".lreg"
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|dump_time
argument_list|,
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|dump_time
argument_list|,
name|dump_local_alloc
argument_list|(
name|rtl_dump_file
argument_list|)
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".lreg"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|global_reg_dump
condition|)
name|open_dump_file
argument_list|(
literal|".greg"
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unless we did stupid register allocation,      allocate remaining pseudo-regs, then do the reload pass      fixing up any insns that are invalid.  */
name|TIMEVAR
argument_list|(
argument|global_alloc_time
argument_list|,
argument|{ 	     if (!obey_regdecls) 	       failure = global_alloc (rtl_dump_file); 	     else 	       failure = reload (insns,
literal|0
argument|, rtl_dump_file); 	   }
argument_list|)
empty_stmt|;
if|if
condition|(
name|failure
condition|)
goto|goto
name|exit_rest_of_compilation
goto|;
comment|/* Do a very simple CSE pass over just the hard registers.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
name|reload_cse_regs
argument_list|(
name|insns
argument_list|)
expr_stmt|;
comment|/* Register allocation and reloading may have turned an indirect jump into      a direct jump.  If so, we must rebuild the JUMP_LABEL fields of      jumping instructions.  */
if|if
condition|(
name|rebuild_label_notes_after_reload
condition|)
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If optimizing and we are performing instruction scheduling after      reload, then go ahead and split insns now since we are about to      recompute flow information anyway.       reload_cse_regs may expose more splitting opportunities, expecially      for double-word operations.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_schedule_insns_after_reload
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|last
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|last
operator|=
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|!=
name|insn
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|global_reg_dump
condition|)
block|{
name|TIMEVAR
argument_list|(
name|dump_time
argument_list|,
name|dump_global_regs
argument_list|(
name|rtl_dump_file
argument_list|)
argument_list|)
expr_stmt|;
name|close_dump_file
argument_list|(
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".greg"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
comment|/* Re-create the death notes which were deleted during reload.  */
if|if
condition|(
name|flow2_dump
condition|)
name|open_dump_file
argument_list|(
literal|".flow2"
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
block|{
name|TIMEVAR
argument_list|(
argument|flow2_time
argument_list|,
argument|{ 	   find_basic_blocks (insns, max_reg_num (), rtl_dump_file,
literal|1
argument|); 	   life_analysis (insns, max_reg_num (), rtl_dump_file,
literal|1
argument|); 	 }
argument_list|)
empty_stmt|;
block|}
name|flow2_completed
operator|=
literal|1
expr_stmt|;
comment|/* On some machines, the prologue and epilogue code, or parts thereof,      can be represented as RTL.  Doing so lets us schedule insns between      it and the rest of the code and also allows delayed branch      scheduling to operate in the epilogue.  */
name|thread_prologue_and_epilogue_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow2_dump
condition|)
block|{
name|close_dump_file
argument_list|(
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".flow2"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_schedule_insns_after_reload
condition|)
block|{
if|if
condition|(
name|sched2_dump
condition|)
name|open_dump_file
argument_list|(
literal|".sched2"
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do control and data sched analysis again, 	 and write some more of the results to dump file.  */
name|TIMEVAR
argument_list|(
name|sched2_time
argument_list|,
name|schedule_insns
argument_list|(
name|rtl_dump_file
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump rtl after post-reorder instruction scheduling.  */
if|if
condition|(
name|sched2_dump
condition|)
block|{
name|close_dump_file
argument_list|(
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".sched2"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
name|current_function_uses_only_leaf_regs
operator|=
name|optimize
operator|>
literal|0
operator|&&
name|only_leaf_regs_used
argument_list|()
operator|&&
name|leaf_function_p
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* One more attempt to remove jumps to .+1      left by dead-store-elimination.      Also do cross-jumping this time      and delete no-op move insns.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|jump_optimize
argument_list|(
name|insns
argument_list|,
name|JUMP_CROSS_JUMP
argument_list|,
name|JUMP_NOOP_MOVES
argument_list|,
operator|!
name|JUMP_AFTER_REGSCAN
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump rtl code after jump, if we are doing that.  */
if|if
condition|(
name|jump2_opt_dump
condition|)
block|{
name|dump_rtl
argument_list|(
literal|".jump2"
argument_list|,
name|decl
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".jump2"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If a machine dependent reorganization is needed, call it.  */
ifdef|#
directive|ifdef
name|MACHINE_DEPENDENT_REORG
name|MACHINE_DEPENDENT_REORG
argument_list|(
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|mach_dep_reorg_dump
condition|)
block|{
name|dump_rtl
argument_list|(
literal|".mach"
argument_list|,
name|decl
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".mach"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If a scheduling pass for delayed branches is to be done,      call the scheduling code.  */
ifdef|#
directive|ifdef
name|DELAY_SLOTS
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_delayed_branch
condition|)
block|{
if|if
condition|(
name|dbr_sched_dump
condition|)
name|open_dump_file
argument_list|(
literal|".dbr"
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|dbr_sched_time
argument_list|,
name|dbr_schedule
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbr_sched_dump
condition|)
block|{
name|close_dump_file
argument_list|(
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".dbr"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Shorten branches.  */
name|TIMEVAR
argument_list|(
argument|shorten_branch_time
argument_list|,
argument|{ 	     shorten_branches (get_insns ()); 	   }
argument_list|)
empty_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
if|if
condition|(
name|stack_reg_dump
condition|)
name|open_dump_file
argument_list|(
literal|".stack"
argument_list|,
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|stack_reg_time
argument_list|,
name|reg_to_stack
argument_list|(
name|insns
argument_list|,
name|rtl_dump_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_reg_dump
condition|)
block|{
name|dump_rtl
argument_list|(
literal|".stack"
argument_list|,
name|decl
argument_list|,
name|print_rtl_with_bb
argument_list|,
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_base_name
argument_list|,
literal|".stack"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|warn_frame_size_flag
condition|)
if|if
condition|(
name|get_frame_size
argument_list|()
operator|>
name|warn_frame_size
condition|)
name|warning
argument_list|(
literal|"%d byte frame exceeds user specified limit (%d bytes)"
argument_list|,
name|get_frame_size
argument_list|()
argument_list|,
name|warn_frame_size
argument_list|)
expr_stmt|;
comment|/* Now turn the rtl into assembler code.  */
name|TIMEVAR
argument_list|(
argument|final_time
argument_list|,
argument|{ 	     rtx x; 	     char *fnname;
comment|/* Get the function's name, as described by its RTL. 		This may be different from the DECL_NAME name used 		in the source file.  */
argument|x = DECL_RTL (decl); 	     if (GET_CODE (x) != MEM) 	       abort (); 	     x = XEXP (x,
literal|0
argument|); 	     if (GET_CODE (x) != SYMBOL_REF) 	       abort (); 	     fnname = XSTR (x,
literal|0
argument|);  	     assemble_start_function (decl, fnname); 	     final_start_function (insns, asm_out_file, optimize); 	     final (insns, asm_out_file, optimize,
literal|0
argument|); 	     final_end_function (insns, asm_out_file, optimize); 	     assemble_end_function (decl, fnname); 	     if (! quiet_flag) 	       fflush (asm_out_file);
comment|/* Release all memory allocated by flow.  */
argument|free_basic_block_vars (
literal|0
argument|);
comment|/* Release all memory held by regsets now */
argument|regset_release_memory (); 	   }
argument_list|)
empty_stmt|;
comment|/* Write DBX symbols if requested */
comment|/* Note that for those inline functions where we don't initially      know for certain that we will be generating an out-of-line copy,      the first invocation of this routine (rest_of_compilation) will      skip over this code by doing a `goto exit_rest_of_compilation;'.      Later on, finish_compilation will call rest_of_compilation again      for those inline functions that need to have out-of-line copies      generated.  During that call, we *will* be routed past here.  */
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dbxout_function
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dwarfout_file_scope_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dwarf2out_decl
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit_rest_of_compilation
label|:
name|free_bb_mem
argument_list|()
expr_stmt|;
comment|/* In case the function was not output,      don't leave any temporary anonymous types      queued up for sdb output.  */
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_types
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Put back the tree of subblocks and list of arguments      from before we copied them.      Code generation and the output of debugging info may have modified      the copy, but the original is unchanged.  */
if|if
condition|(
name|saved_block_tree
operator|!=
literal|0
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|saved_block_tree
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
operator|=
name|saved_arguments
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|reload_completed
operator|=
literal|0
expr_stmt|;
name|flow2_completed
operator|=
literal|0
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
name|TIMEVAR
argument_list|(
argument|final_time
argument_list|,
argument|{
comment|/* Clear out the insn_length contents now that they are no 		 longer valid.  */
argument|init_insn_lengths ();
comment|/* Clear out the real_constant_chain before some of the rtx's 		 it runs through become garbage.  */
argument|clear_const_double_mem ();
comment|/* Cancel the effect of rtl_in_current_obstack.  */
argument|resume_temporary_allocation ();
comment|/* Show no temporary slots allocated.  */
argument|init_temp_slots (); 	   }
argument_list|)
empty_stmt|;
comment|/* Make sure volatile mem refs aren't considered valid operands for      arithmetic insns.  We must call this here if this is a nested inline      function, since the above code leaves us in the init_recog state      (from final.c), and the function context push/pop code does not      save/restore volatile_ok.       ??? Maybe it isn't necessary for expand_start_function to call this      anymore if we do it here?  */
name|init_recog_no_volatile
argument_list|()
expr_stmt|;
comment|/* The parsing time is all the time spent in yyparse      *except* what is spent in this function.  */
name|parse_time
operator|-=
name|get_run_time
argument_list|()
operator|-
name|start_time
expr_stmt|;
comment|/* Reset global variables.  */
name|free_basic_block_vars
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|display_help
parameter_list|()
block|{
name|int
name|undoc
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|lang
decl_stmt|;
ifndef|#
directive|ifndef
name|USE_CPPLIB
name|printf
argument_list|(
literal|"Usage: %s input [switches]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Switches:\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"  -ffixed-<register>      Mark<register> as being unavailable to the compiler\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -fcall-used-<register>  Mark<register> as being corrupted by function calls\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -fcall-saved-<register> Mark<register> as being preserved across functions\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -finline-limit-<number> Limits the size of inlined functions to<number>\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_ELEM
argument_list|(
name|f_options
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|description
init|=
name|f_options
index|[
name|i
index|]
operator|.
name|description
decl_stmt|;
if|if
condition|(
name|description
operator|!=
name|NULL
operator|&&
operator|*
name|description
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"  -f%-21s %s\n"
argument_list|,
name|f_options
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  -O[number]              Set optimisation level to [number]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Os                     Optimise for space rather than speed\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -pedantic               Issue warnings needed by strict compliance to ANSI C\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -pedantic-errors        Like -pedantic except that errors are produced\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -w                      Suppress warnings\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -W                      Enable extra warnings\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_ELEM
argument_list|(
name|W_options
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|description
init|=
name|W_options
index|[
name|i
index|]
operator|.
name|description
decl_stmt|;
if|if
condition|(
name|description
operator|!=
name|NULL
operator|&&
operator|*
name|description
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"  -W%-21s %s\n"
argument_list|,
name|W_options
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  -Wid-clash-<num>        Warn if 2 identifiers have the same first<num> chars\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wlarger-than-<number>  Warn if an object is larger than<number> bytes\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -p                      Enable function profiling\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BLOCK_PROFILER
argument_list|)
operator|||
name|defined
argument_list|(
name|FUNCTION_BLOCK_PROFILER
argument_list|)
name|printf
argument_list|(
literal|"  -a                      Enable block profiling \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|BLOCK_PROFILER
argument_list|)
operator|||
name|defined
argument_list|(
name|FUNCTION_BLOCK_PROFILER
argument_list|)
operator|||
name|defined
name|FUNCTION_BLOCK_PROFILER_EXIT
name|printf
argument_list|(
literal|"  -ax                     Enable jump profiling \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"  -o<file>               Place output into<file> \n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -G<number>             Put global and static data smaller than<number>\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                           bytes into a special section (on some targets)\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_ELEM
argument_list|(
name|debug_args
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
if|if
condition|(
name|debug_args
index|[
name|i
index|]
operator|.
name|description
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"  -%-22s %s\n"
argument_list|,
name|debug_args
index|[
name|i
index|]
operator|.
name|arg
argument_list|,
name|debug_args
index|[
name|i
index|]
operator|.
name|description
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  -aux-info<file>        Emit declaration info into<file>.X\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -quiet                  Do not display functions compiled or elapsed time\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -version                Display the compiler's version\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -d[letters]             Enable dumps from specific passes of the compiler\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -dumpbase<file>        Base name to be used for dumps from specific passes\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|HAIFA
operator|||
name|defined
name|INSN_SCHEDULING
name|printf
argument_list|(
literal|"  -sched-verbose-<number> Set the verbosity level of the scheduler\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"  --help                  Display this information\n"
argument_list|)
expr_stmt|;
name|undoc
operator|=
literal|0
expr_stmt|;
name|lang
operator|=
literal|"language"
expr_stmt|;
comment|/* Display descriptions of language specific options.      If there is no description, note that there is an undocumented option.      If the description is empty, do not display anything.  (This allows      options to be deliberately undocumented, for whatever reason).      If the option string is missing, then this is a marker, indicating      that the description string is in fact the name of a language, whose      language specific options are to follow.  */
if|if
condition|(
name|NUM_ELEM
argument_list|(
name|documented_lang_options
argument_list|)
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\nLanguage specific options:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELEM
argument_list|(
name|documented_lang_options
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|description
init|=
name|documented_lang_options
index|[
name|i
index|]
operator|.
name|description
decl_stmt|;
specifier|const
name|char
modifier|*
name|option
init|=
name|documented_lang_options
index|[
name|i
index|]
operator|.
name|option
decl_stmt|;
if|if
condition|(
name|description
operator|==
name|NULL
condition|)
block|{
name|undoc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|printf
argument_list|(
literal|"  %-23.23s [undocumented]\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|description
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|option
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|undoc
condition|)
name|printf
argument_list|(
literal|"\nThere are undocumented %s specific options as well.\n"
argument_list|,
name|lang
argument_list|)
expr_stmt|;
name|undoc
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\n Options for %s:\n"
argument_list|,
name|description
argument_list|)
expr_stmt|;
name|lang
operator|=
name|description
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"  %-23.23s %s\n"
argument_list|,
name|option
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|undoc
condition|)
name|printf
argument_list|(
literal|"\nThere are undocumented %s specific options as well.\n"
argument_list|,
name|lang
argument_list|)
expr_stmt|;
if|if
condition|(
name|NUM_ELEM
argument_list|(
name|target_switches
argument_list|)
operator|>
literal|1
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
operator|||
name|NUM_ELEM
argument_list|(
name|target_options
argument_list|)
operator|>
literal|1
endif|#
directive|endif
condition|)
block|{
name|int
name|doc
init|=
literal|0
decl_stmt|;
name|undoc
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\nTarget specific options:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_ELEM
argument_list|(
name|target_switches
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|option
init|=
name|target_switches
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
init|=
name|target_switches
index|[
name|i
index|]
operator|.
name|description
decl_stmt|;
if|if
condition|(
name|option
operator|==
name|NULL
operator|||
operator|*
name|option
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|description
operator|==
name|NULL
condition|)
block|{
name|undoc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|printf
argument_list|(
literal|"  -m%-21.21s [undocumented]\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|description
operator|!=
literal|0
condition|)
name|doc
operator|+=
name|printf
argument_list|(
literal|"  -m%-21.21s %s\n"
argument_list|,
name|option
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
for|for
control|(
name|i
operator|=
name|NUM_ELEM
argument_list|(
name|target_options
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|option
init|=
name|target_options
index|[
name|i
index|]
operator|.
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
init|=
name|target_options
index|[
name|i
index|]
operator|.
name|description
decl_stmt|;
if|if
condition|(
name|option
operator|==
name|NULL
operator|||
operator|*
name|option
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|description
operator|==
name|NULL
condition|)
block|{
name|undoc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|printf
argument_list|(
literal|"  -m%-21.21s [undocumented]\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|description
operator|!=
literal|0
condition|)
name|doc
operator|+=
name|printf
argument_list|(
literal|"  -m%-21.21s %s\n"
argument_list|,
name|option
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|undoc
condition|)
block|{
if|if
condition|(
name|doc
condition|)
name|printf
argument_list|(
literal|"\nThere are undocumented target specific options as well.\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  They exist, but they are not documented.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compare the user specified 'option' with the language    specific 'lang_option'.  Return true if they match, or    if 'option' is a viable prefix of 'lang_option'.  */
end_comment

begin_function
specifier|static
name|int
name|check_lang_option
parameter_list|(
name|option
parameter_list|,
name|lang_option
parameter_list|)
name|char
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
name|lang_option
decl_stmt|;
block|{
name|lang_independent_options
modifier|*
name|indep_options
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|numopts
decl_stmt|;
name|long
name|k
decl_stmt|;
name|char
modifier|*
name|space
decl_stmt|;
comment|/* Ignore NULL entries.  */
if|if
condition|(
name|option
operator|==
name|NULL
operator|||
name|lang_option
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|space
operator|=
name|strchr
argument_list|(
name|lang_option
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|len
operator|=
name|space
operator|-
name|lang_option
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|lang_option
argument_list|)
expr_stmt|;
comment|/* If they do not match to the first n characters then fail.  */
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
name|lang_option
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Do not accept a lang option, if it matches a normal -f or -W      option.  Chill defines a -fpack, but we want to support      -fpack-struct.  */
comment|/* An exact match is OK  */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|option
argument_list|)
operator|==
name|len
condition|)
return|return
literal|1
return|;
comment|/* If it is not an -f or -W option allow the match */
if|if
condition|(
name|option
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|option
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'f'
case|:
name|indep_options
operator|=
name|f_options
expr_stmt|;
name|numopts
operator|=
name|NUM_ELEM
argument_list|(
name|f_options
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|indep_options
operator|=
name|W_options
expr_stmt|;
name|numopts
operator|=
name|NUM_ELEM
argument_list|(
name|W_options
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|1
return|;
block|}
comment|/* The option is a -f or -W option.      Skip past the prefix and search for the remainder in the      appropriate table of options.  */
name|option
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|option
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|option
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|option
index|[
literal|2
index|]
operator|==
literal|'-'
condition|)
name|option
operator|+=
literal|3
expr_stmt|;
for|for
control|(
name|k
operator|=
name|numopts
init|;
name|k
operator|--
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option
argument_list|,
name|indep_options
index|[
name|k
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
comment|/* The option matched a language independent option, 	     do not allow the language specific match.  */
return|return
literal|0
return|;
block|}
block|}
comment|/* The option matches the start of the langauge specific option      and it is not an exact match for a language independent option.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Entry point of cc1/c++.  Decode command args, then call compile_file.    Exit code is 35 if can't open files, 34 if fatal error,    33 if had nonfatal errors, else success.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|filename
init|=
literal|0
decl_stmt|;
name|int
name|flag_print_mem
init|=
literal|0
decl_stmt|;
name|int
name|version_flag
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* save in case md file wants to emit args as a comment.  */
name|save_argc
operator|=
name|argc
expr_stmt|;
name|save_argv
operator|=
name|argv
expr_stmt|;
name|p
operator|=
name|argv
index|[
literal|0
index|]
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|argv
index|[
literal|0
index|]
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
ifdef|#
directive|ifdef
name|DIR_SEPARATOR
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR
endif|#
directive|endif
condition|)
operator|--
name|p
expr_stmt|;
name|progname
operator|=
name|p
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|RLIMIT_STACK
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_GETRLIMIT
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETRLIMIT
argument_list|)
comment|/* Get rid of any avoidable limit on stack size.  */
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
comment|/* Set the stack limit huge so that alloca does not fail.  */
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LC_MESSAGES
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|localedir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_signal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGPIPE
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipe_closed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|decl_printable_name
operator|=
name|decl_name
expr_stmt|;
name|lang_expand_expr
operator|=
operator|(
name|lang_expand_expr_t
operator|)
name|do_abort
expr_stmt|;
comment|/* Initialize whether `char' is signed.  */
name|flag_signed_char
operator|=
name|DEFAULT_SIGNED_CHAR
expr_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_SHORT_ENUMS
comment|/* Initialize how much space enums occupy, by default.  */
name|flag_short_enums
operator|=
name|DEFAULT_SHORT_ENUMS
expr_stmt|;
endif|#
directive|endif
comment|/* Perform language-specific options intialization.  */
name|lang_init_options
argument_list|()
expr_stmt|;
comment|/* Scan to see what optimization level has been specified.  That will      determine the default value of many flags.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-O"
argument_list|)
condition|)
block|{
name|optimize
operator|=
literal|1
expr_stmt|;
name|optimize_size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'O'
condition|)
block|{
comment|/* Handle -Os, -O2, -O3, -O69, ...  */
name|char
modifier|*
name|p
init|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|optimize_size
operator|=
literal|1
expr_stmt|;
comment|/* Optimizing for size forces optimize to be 2. */
name|optimize
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|optimize_val
init|=
name|read_integral_parameter
argument_list|(
name|p
argument_list|,
name|p
operator|-
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|optimize_val
operator|!=
operator|-
literal|1
condition|)
block|{
name|optimize
operator|=
name|optimize_val
expr_stmt|;
ifdef|#
directive|ifdef
name|FORCE_OPTIMIZATION_DOWNGRADE
warning|#
directive|warning
warning|FORCE_OPTIMIZATION_DOWNGRADE
if|if
condition|(
name|optimize
operator|>
name|FORCE_OPTIMIZATION_DOWNGRADE
condition|)
block|{
name|optimize
operator|=
name|FORCE_OPTIMIZATION_DOWNGRADE
expr_stmt|;
name|warning
argument_list|(
literal|"\n***\n***\t-O%d converted to \"-O%d\" due to optimizer bugs on this platform\n***"
argument_list|,
name|optimize_val
argument_list|,
name|FORCE_OPTIMIZATION_DOWNGRADE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*FORCE_OPTIMIZATION_DOWNGRADE*/
if|#
directive|if
name|defined
argument_list|(
name|__alpha__
argument_list|)
if|if
condition|(
name|optimize
operator|>
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"\n***\n***\tThe -O%d flag TRIGGERS KNOWN OPTIMIZER BUGS ON THIS PLATFORM\n***"
argument_list|,
name|optimize_val
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*__alpha__*/
name|optimize_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
name|obey_regdecls
operator|=
operator|(
name|optimize
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|>=
literal|1
condition|)
block|{
name|flag_defer_pop
operator|=
literal|1
expr_stmt|;
name|flag_thread_jumps
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DELAY_SLOTS
name|flag_delayed_branch
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CAN_DEBUG_WITHOUT_FP
name|flag_omit_frame_pointer
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|optimize
operator|>=
literal|2
condition|)
block|{
name|flag_cse_follow_jumps
operator|=
literal|1
expr_stmt|;
name|flag_cse_skip_blocks
operator|=
literal|1
expr_stmt|;
name|flag_gcse
operator|=
literal|1
expr_stmt|;
name|flag_expensive_optimizations
operator|=
literal|1
expr_stmt|;
name|flag_strength_reduce
operator|=
literal|1
expr_stmt|;
name|flag_rerun_cse_after_loop
operator|=
literal|1
expr_stmt|;
name|flag_rerun_loop_opt
operator|=
literal|1
expr_stmt|;
name|flag_caller_saves
operator|=
literal|1
expr_stmt|;
name|flag_force_mem
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
name|flag_schedule_insns
operator|=
literal|1
expr_stmt|;
name|flag_schedule_insns_after_reload
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|flag_regmove
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|>=
literal|3
condition|)
block|{
name|flag_inline_functions
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Initialize target_flags before OPTIMIZATION_OPTIONS so the latter can      modify it.  */
name|target_flags
operator|=
literal|0
expr_stmt|;
name|set_target_switch
argument_list|(
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPTIMIZATION_OPTIONS
comment|/* Allow default optimizations to be specified on a per-machine basis.  */
name|OPTIMIZATION_OPTIONS
argument_list|(
name|optimize
argument_list|,
name|optimize_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize register usage now so switches may override.  */
name|init_reg_sets
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|j
decl_stmt|;
comment|/* If this is a language-specific option, 	 decode it in a language-specific way.  */
for|for
control|(
name|j
operator|=
name|NUM_ELEM
argument_list|(
name|documented_lang_options
argument_list|)
init|;
name|j
operator|--
condition|;
control|)
if|if
condition|(
name|check_lang_option
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|documented_lang_options
index|[
name|j
index|]
operator|.
name|option
argument_list|)
condition|)
break|break;
if|if
condition|(
name|j
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* If the option is valid for *some* language, 	     treat it as valid even if this language doesn't understand it.  */
name|int
name|strings_processed
init|=
name|lang_decode_option
argument_list|(
name|argc
operator|-
name|i
argument_list|,
name|argv
operator|+
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"--help"
argument_list|)
condition|)
block|{
name|display_help
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strings_processed
operator|!=
literal|0
condition|)
name|i
operator|+=
name|strings_processed
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|str
init|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'Y'
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'m'
condition|)
name|set_target_switch
argument_list|(
operator|&
name|str
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"dumpbase"
argument_list|)
condition|)
block|{
name|dump_base_name
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'d'
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|&
name|str
index|[
literal|1
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'a'
case|:
name|branch_prob_dump
operator|=
literal|1
expr_stmt|;
name|combine_dump
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DELAY_SLOTS
name|dbr_sched_dump
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|flow_dump
operator|=
literal|1
expr_stmt|;
name|flow2_dump
operator|=
literal|1
expr_stmt|;
name|global_reg_dump
operator|=
literal|1
expr_stmt|;
name|jump_opt_dump
operator|=
literal|1
expr_stmt|;
name|addressof_dump
operator|=
literal|1
expr_stmt|;
name|jump2_opt_dump
operator|=
literal|1
expr_stmt|;
name|local_reg_dump
operator|=
literal|1
expr_stmt|;
name|loop_dump
operator|=
literal|1
expr_stmt|;
name|regmove_dump
operator|=
literal|1
expr_stmt|;
name|rtl_dump
operator|=
literal|1
expr_stmt|;
name|cse_dump
operator|=
literal|1
operator|,
name|cse2_dump
operator|=
literal|1
expr_stmt|;
name|gcse_dump
operator|=
literal|1
expr_stmt|;
name|sched_dump
operator|=
literal|1
expr_stmt|;
name|sched2_dump
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
name|stack_reg_dump
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MACHINE_DEPENDENT_REORG
name|mach_dep_reorg_dump
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'A'
case|:
name|flag_debug_asm
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|branch_prob_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|combine_dump
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DELAY_SLOTS
case|case
literal|'d'
case|:
name|dbr_sched_dump
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'f'
case|:
name|flow_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|addressof_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|global_reg_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|gcse_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|jump_opt_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|jump2_opt_dump
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|STACK_REGS
case|case
literal|'k'
case|:
name|stack_reg_dump
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'l'
case|:
name|local_reg_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|loop_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|flag_print_mem
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|MACHINE_DEPENDENT_REORG
case|case
literal|'M'
case|:
name|mach_dep_reorg_dump
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'p'
case|:
name|flag_print_asm_name
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|rtl_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|sched2_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|cse_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|sched_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|cse2_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|regmove_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|graph_dump_format
operator|=
name|vcg
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|flow2_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|set_yydebug
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|rtl_dump_and_exit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* these are handled by the preprocessor */
case|case
literal|'I'
case|:
break|break;
default|default:
name|warning
argument_list|(
literal|"unrecognised gcc debugging option: %c"
argument_list|,
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'f'
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|&
name|str
index|[
literal|1
index|]
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* Some kind of -f option. 		 P's value is the option sans `-f'. 		 Search for it in the table of options.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|!
name|found
operator|&&
name|j
operator|<
sizeof|sizeof
argument_list|(
name|f_options
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|f_options
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
name|f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|f_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
name|f_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
comment|/* A goto here would be cleaner, 			 but breaks the vax pcc.  */
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|+
literal|3
argument_list|,
name|f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|f_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
operator|!
name|f_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"inline-limit-"
argument_list|,
literal|13
argument_list|)
condition|)
name|inline_max_insns
operator|=
name|read_integral_parameter
argument_list|(
name|p
operator|+
literal|13
argument_list|,
name|p
operator|-
literal|2
argument_list|,
name|inline_max_insns
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAIFA
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"sched-verbose-"
argument_list|,
literal|14
argument_list|)
condition|)
name|fix_sched_param
argument_list|(
literal|"verbose"
argument_list|,
operator|&
name|p
index|[
literal|14
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* HAIFA */
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"fixed-"
argument_list|,
literal|6
argument_list|)
condition|)
name|fix_register
argument_list|(
operator|&
name|p
index|[
literal|6
index|]
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"call-used-"
argument_list|,
literal|10
argument_list|)
condition|)
name|fix_register
argument_list|(
operator|&
name|p
index|[
literal|10
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"call-saved-"
argument_list|,
literal|11
argument_list|)
condition|)
name|fix_register
argument_list|(
operator|&
name|p
index|[
literal|11
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'O'
condition|)
block|{
comment|/* Already been treated above. Do nothing.  */
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"pedantic"
argument_list|)
condition|)
name|pedantic
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"pedantic-errors"
argument_list|)
condition|)
name|flag_pedantic_errors
operator|=
name|pedantic
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"quiet"
argument_list|)
condition|)
name|quiet_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"version"
argument_list|)
condition|)
name|version_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"w"
argument_list|)
condition|)
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"W"
argument_list|)
condition|)
block|{
name|extra_warnings
operator|=
literal|1
expr_stmt|;
comment|/* We save the value of warn_uninitialized, since if they put 		 -Wuninitialized on the command line, we need to generate a 		 warning about not using it without also specifying -O.  */
if|if
condition|(
name|warn_uninitialized
operator|!=
literal|1
condition|)
name|warn_uninitialized
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'W'
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|&
name|str
index|[
literal|1
index|]
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* Some kind of -W option. 		 P's value is the option sans `-W'. 		 Search for it in the table of options.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|!
name|found
operator|&&
name|j
operator|<
sizeof|sizeof
argument_list|(
name|W_options
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|W_options
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
name|W_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|W_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
name|W_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
comment|/* A goto here would be cleaner, 			 but breaks the vax pcc.  */
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|+
literal|3
argument_list|,
name|W_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|W_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
operator|!
name|W_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"id-clash-"
argument_list|,
literal|9
argument_list|)
condition|)
block|{
specifier|const
name|int
name|id_clash_val
init|=
name|read_integral_parameter
argument_list|(
name|p
operator|+
literal|9
argument_list|,
name|p
operator|-
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|id_clash_val
operator|!=
operator|-
literal|1
condition|)
block|{
name|id_clash_len
operator|=
name|id_clash_val
expr_stmt|;
name|warn_id_clash
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"larger-than-"
argument_list|,
literal|12
argument_list|)
condition|)
block|{
specifier|const
name|int
name|larger_than_val
init|=
name|read_integral_parameter
argument_list|(
name|p
operator|+
literal|12
argument_list|,
name|p
operator|-
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|larger_than_val
operator|!=
operator|-
literal|1
condition|)
block|{
name|larger_than_size
operator|=
name|larger_than_val
expr_stmt|;
name|warn_larger_than
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"p"
argument_list|)
condition|)
block|{
name|profile_flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"a"
argument_list|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BLOCK_PROFILER
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|FUNCTION_BLOCK_PROFILER
argument_list|)
name|warning
argument_list|(
literal|"`-a' option (basic block profile) not supported"
argument_list|)
expr_stmt|;
else|#
directive|else
name|profile_block_flag
operator|=
operator|(
name|profile_block_flag
operator|<
literal|2
operator|)
condition|?
literal|1
else|:
literal|3
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"ax"
argument_list|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FUNCTION_BLOCK_PROFILER_EXIT
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|BLOCK_PROFILER
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|FUNCTION_BLOCK_PROFILER
argument_list|)
name|warning
argument_list|(
literal|"`-ax' option (jump profiling) not supported"
argument_list|)
expr_stmt|;
else|#
directive|else
name|profile_block_flag
operator|=
operator|(
operator|!
name|profile_block_flag
operator|||
name|profile_block_flag
operator|==
literal|2
operator|)
condition|?
literal|2
else|:
literal|3
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'g'
condition|)
block|{
name|unsigned
name|level
decl_stmt|;
comment|/* A lot of code assumes write_symbols == NO_DEBUG if the 		 debugging level is 0 (thus -gstabs1 -gstabs0 would lose track 		 of what debugging type has been selected).  This records the 		 selected type.  It is an error to specify more than one 		 debugging type.  */
specifier|static
name|enum
name|debug_info_type
name|selected_debug_type
init|=
name|NO_DEBUG
decl_stmt|;
comment|/* Non-zero if debugging format has been explicitly set. 		 -g and -ggdb don't explicitly set the debugging format so 		 -gdwarf -g3 is equivalent to -gdwarf3.  */
specifier|static
name|int
name|type_explicitly_set_p
init|=
literal|0
decl_stmt|;
comment|/* Indexed by enum debug_info_type.  */
specifier|static
specifier|const
name|char
modifier|*
name|debug_type_names
index|[]
init|=
block|{
literal|"none"
block|,
literal|"stabs"
block|,
literal|"coff"
block|,
literal|"dwarf-1"
block|,
literal|"dwarf-2"
block|,
literal|"xcoff"
block|}
decl_stmt|;
comment|/* The maximum admissible debug level value.  */
specifier|static
specifier|const
name|unsigned
name|max_debug_level
init|=
literal|3
decl_stmt|;
comment|/* Look up STR in the table.  */
for|for
control|(
name|da
operator|=
name|debug_args
init|;
name|da
operator|->
name|arg
condition|;
name|da
operator|++
control|)
block|{
specifier|const
name|int
name|da_len
init|=
name|strlen
argument_list|(
name|da
operator|->
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
name|da
operator|->
name|arg
argument_list|,
name|da_len
argument_list|)
condition|)
block|{
name|enum
name|debug_info_type
name|type
init|=
name|da
operator|->
name|debug_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|str
operator|+
name|da_len
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
operator|)
condition|)
continue|continue;
comment|/* A debug flag without a level defaults to level 2. 			 Note we do not want to call read_integral_parameter 			 for that case since it will call atoi which  			 will return zero.  			 ??? We may want to generalize the interface to  			 read_integral_parameter to better handle this case 			 if this case shows up often.  */
if|if
condition|(
operator|*
name|p
condition|)
name|level
operator|=
name|read_integral_parameter
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|max_debug_level
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|level
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|da_len
operator|>
literal|1
operator|&&
operator|*
name|p
operator|&&
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"gdwarf"
argument_list|,
name|da_len
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"use -gdwarf -g%d for DWARF v1, level %d"
argument_list|,
name|level
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"use -gdwarf-2   for DWARF v2"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|>
name|max_debug_level
condition|)
block|{
name|warning
argument_list|(
literal|"ignoring option `%s' due to invalid debug level specification"
argument_list|,
name|str
operator|-
literal|1
argument_list|)
expr_stmt|;
name|level
operator|=
name|debug_info_level
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|NO_DEBUG
condition|)
block|{
name|type
operator|=
name|PREFERRED_DEBUGGING_TYPE
expr_stmt|;
if|if
condition|(
name|da_len
operator|>
literal|1
operator|&&
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"ggdb"
argument_list|,
name|da_len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LINKER_DOES_NOT_WORK_WITH_DWARF2
argument_list|)
name|type
operator|=
name|DWARF2_DEBUG
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
name|type
operator|=
name|DBX_DEBUG
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|type
operator|==
name|NO_DEBUG
condition|)
name|warning
argument_list|(
literal|"`-%s' not supported by this configuration of GCC"
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Does it conflict with an already selected type?  */
if|if
condition|(
name|type_explicitly_set_p
comment|/* -g/-ggdb don't conflict with anything */
operator|&&
name|da
operator|->
name|debug_type
operator|!=
name|NO_DEBUG
operator|&&
name|type
operator|!=
name|selected_debug_type
condition|)
name|warning
argument_list|(
literal|"`-%s' ignored, conflicts with `-g%s'"
argument_list|,
name|str
argument_list|,
name|debug_type_names
index|[
operator|(
name|int
operator|)
name|selected_debug_type
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If the format has already been set, -g/-ggdb 			     only change the debug level.  */
if|if
condition|(
name|type_explicitly_set_p
operator|&&
name|da
operator|->
name|debug_type
operator|==
name|NO_DEBUG
condition|)
empty_stmt|;
comment|/* don't change debugging type */
else|else
block|{
name|selected_debug_type
operator|=
name|type
expr_stmt|;
name|type_explicitly_set_p
operator|=
name|da
operator|->
name|debug_type
operator|!=
name|NO_DEBUG
expr_stmt|;
block|}
name|write_symbols
operator|=
operator|(
name|level
operator|==
literal|0
condition|?
name|NO_DEBUG
else|:
name|selected_debug_type
operator|)
expr_stmt|;
name|use_gnu_debug_info_extensions
operator|=
name|da
operator|->
name|use_extensions_p
expr_stmt|;
name|debug_info_level
operator|=
operator|(
expr|enum
name|debug_info_level
operator|)
name|level
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|da
operator|->
name|arg
condition|)
name|warning
argument_list|(
literal|"`-%s' not supported by this configuration of GCC"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"o"
argument_list|)
condition|)
block|{
name|asm_file_name
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'G'
condition|)
block|{
specifier|const
name|int
name|g_switch_val
init|=
operator|(
name|str
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|?
name|read_integral_parameter
argument_list|(
name|str
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
else|:
name|read_integral_parameter
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|g_switch_val
operator|!=
operator|-
literal|1
condition|)
block|{
name|g_switch_set
operator|=
name|TRUE
expr_stmt|;
name|g_switch_value
operator|=
name|g_switch_val
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Invalid option `-%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"aux-info"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|flag_gen_aux_info
operator|=
literal|1
expr_stmt|;
name|aux_info_file_name
operator|=
operator|(
name|str
index|[
literal|8
index|]
operator|!=
literal|'\0'
condition|?
name|str
operator|+
literal|8
else|:
name|argv
index|[
operator|++
name|i
index|]
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"-help"
argument_list|)
condition|)
block|{
name|display_help
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|filename
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Checker uses the frame pointer.  */
if|if
condition|(
name|flag_check_memory_usage
condition|)
name|flag_omit_frame_pointer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
block|{
comment|/* Inlining does not work if not optimizing, 	 so force it not to be done.  */
name|flag_no_inline
operator|=
literal|1
expr_stmt|;
name|warn_inline
operator|=
literal|0
expr_stmt|;
comment|/* The c_decode_option and lang_decode_option functions set 	 this to `2' if -Wall is used, so we can avoid giving out 	 lots of errors for people who don't realize what -Wall does.  */
if|if
condition|(
name|warn_uninitialized
operator|==
literal|1
condition|)
name|warning
argument_list|(
literal|"-Wuninitialized is not supported without -O"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OVERRIDE_OPTIONS
comment|/* Some machines may reject certain combinations of options.  */
name|OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|exceptions_via_longjmp
operator|==
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
name|exceptions_via_longjmp
operator|=
operator|!
name|DWARF2_UNWIND_INFO
expr_stmt|;
else|#
directive|else
name|exceptions_via_longjmp
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|profile_block_flag
operator|==
literal|3
condition|)
block|{
name|warning
argument_list|(
literal|"`-ax' and `-a' are conflicting options. `-a' ignored."
argument_list|)
expr_stmt|;
name|profile_block_flag
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Unrolling all loops implies that standard loop unrolling must also      be done.  */
if|if
condition|(
name|flag_unroll_all_loops
condition|)
name|flag_unroll_loops
operator|=
literal|1
expr_stmt|;
comment|/* Loop unrolling requires that strength_reduction be on also.  Silently      turn on strength reduction here if it isn't already on.  Also, the loop      unrolling code assumes that cse will be run after loop, so that must      be turned on also.  */
if|if
condition|(
name|flag_unroll_loops
condition|)
block|{
name|flag_strength_reduce
operator|=
literal|1
expr_stmt|;
name|flag_rerun_cse_after_loop
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Warn about options that are not supported on this machine.  */
ifndef|#
directive|ifndef
name|INSN_SCHEDULING
if|if
condition|(
name|flag_schedule_insns
operator|||
name|flag_schedule_insns_after_reload
condition|)
name|warning
argument_list|(
literal|"instruction scheduling not supported on this target machine"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|DELAY_SLOTS
if|if
condition|(
name|flag_delayed_branch
condition|)
name|warning
argument_list|(
literal|"this target machine does not have delayed branches"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|user_label_prefix
operator|=
name|USER_LABEL_PREFIX
expr_stmt|;
if|if
condition|(
name|flag_leading_underscore
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* If the default prefix is more complicated than "" or "_",  	 issue a warning and ignore this option.  */
if|if
condition|(
name|user_label_prefix
index|[
literal|0
index|]
operator|==
literal|0
operator|||
operator|(
name|user_label_prefix
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|user_label_prefix
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|user_label_prefix
operator|=
name|flag_leading_underscore
condition|?
literal|"_"
else|:
literal|""
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"-f%sleading-underscore not supported on this target machine"
argument_list|,
name|flag_leading_underscore
condition|?
literal|""
else|:
literal|"no-"
argument_list|)
expr_stmt|;
block|}
comment|/* If we are in verbose mode, write out the version and maybe all the      option flags in use.  */
if|if
condition|(
name|version_flag
condition|)
block|{
name|print_version
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|print_switch_values
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|,
name|MAX_LINE
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|compile_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OS2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|__INTERIX
argument_list|)
if|if
condition|(
name|flag_print_mem
condition|)
block|{
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|notice
argument_list|(
literal|"Data size %ld.\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|lim
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|environ
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
ifdef|#
directive|ifdef
name|USG
name|system
argument_list|(
literal|"ps -l 1>&2"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not USG */
name|system
argument_list|(
literal|"ps v"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not USG */
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* ! OS2&& ! VMS&& (! _WIN32 || CYGWIN)&& ! __INTERIX */
if|if
condition|(
name|errorcount
condition|)
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorrycount
condition|)
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode -m switches.  */
end_comment

begin_comment
comment|/* Decode the switch -mNAME.  */
end_comment

begin_function
specifier|static
name|void
name|set_target_switch
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|size_t
name|j
decl_stmt|;
name|int
name|valid_target_option
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|target_switches
operator|/
sizeof|sizeof
name|target_switches
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|target_switches
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|<
literal|0
condition|)
name|target_flags
operator|&=
operator|~
operator|-
name|target_switches
index|[
name|j
index|]
operator|.
name|value
expr_stmt|;
else|else
name|target_flags
operator||=
name|target_switches
index|[
name|j
index|]
operator|.
name|value
expr_stmt|;
name|valid_target_option
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
if|if
condition|(
operator|!
name|valid_target_option
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|target_options
operator|/
sizeof|sizeof
name|target_options
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|target_options
index|[
name|j
index|]
operator|.
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|target_options
index|[
name|j
index|]
operator|.
name|prefix
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|target_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
name|name
operator|+
name|len
expr_stmt|;
name|valid_target_option
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|valid_target_option
condition|)
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print version information to FILE.    Each line begins with INDENT (for the case where FILE is the    assembler output file).  */
end_comment

begin_function
specifier|static
name|void
name|print_version
parameter_list|(
name|file
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|indent
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|__VERSION__
define|#
directive|define
name|__VERSION__
value|"[?]"
endif|#
directive|endif
name|fnotice
argument_list|(
name|file
argument_list|,
ifdef|#
directive|ifdef
name|__GNUC__
literal|"%s%s%s version %s (%s) compiled by GNU C version %s.\n"
else|#
directive|else
literal|"%s%s%s version %s (%s) compiled by CC.\n"
endif|#
directive|endif
argument_list|,
name|indent
argument_list|,
operator|*
name|indent
operator|!=
literal|0
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|language_string
argument_list|,
name|version_string
argument_list|,
name|TARGET_NAME
argument_list|,
name|__VERSION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an option value and return the adjusted position in the line.    ??? We don't handle error returns from fprintf (disk full); presumably    other code will catch a disk full though.  */
end_comment

begin_function
specifier|static
name|int
name|print_single_switch
parameter_list|(
name|file
parameter_list|,
name|pos
parameter_list|,
name|max
parameter_list|,
name|indent
parameter_list|,
name|sep
parameter_list|,
name|term
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|max
decl_stmt|;
specifier|const
name|char
modifier|*
name|indent
decl_stmt|,
decl|*
name|sep
decl_stmt|,
modifier|*
name|term
decl_stmt|,
modifier|*
name|type
decl_stmt|,
modifier|*
name|name
decl_stmt|;
end_function

begin_block
block|{
comment|/* The ultrix fprintf returns 0 on success, so compute the result we want      here since we need it for the following test.  */
name|int
name|len
init|=
name|strlen
argument_list|(
name|sep
argument_list|)
operator|+
name|strlen
argument_list|(
name|type
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
literal|0
operator|&&
name|pos
operator|+
name|len
operator|>
name|max
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|pos
operator|=
name|strlen
argument_list|(
name|indent
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%s"
argument_list|,
name|sep
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|len
expr_stmt|;
return|return
name|pos
return|;
block|}
end_block

begin_comment
comment|/* Print active target switches to FILE.    POS is the current cursor position and MAX is the size of a "line".    Each line begins with INDENT and ends with TERM.    Each switch is separated from the next by SEP.  */
end_comment

begin_function
specifier|static
name|void
name|print_switch_values
parameter_list|(
name|file
parameter_list|,
name|pos
parameter_list|,
name|max
parameter_list|,
name|indent
parameter_list|,
name|sep
parameter_list|,
name|term
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|max
decl_stmt|;
specifier|const
name|char
modifier|*
name|indent
decl_stmt|,
decl|*
name|sep
decl_stmt|,
modifier|*
name|term
decl_stmt|;
end_function

begin_block
block|{
name|size_t
name|j
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
comment|/* Print the options as passed.  */
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
operator|*
name|indent
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|term
argument_list|,
name|_
argument_list|(
literal|"options passed: "
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|save_argv
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
comment|/* Ignore these.  */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
literal|"-o"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
literal|"-quiet"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
literal|"-version"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|*
name|p
operator|)
index|[
literal|1
index|]
operator|==
literal|'d'
condition|)
continue|continue;
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
name|sep
argument_list|,
name|term
argument_list|,
operator|*
name|p
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|term
argument_list|)
expr_stmt|;
comment|/* Print the -f and -m options that have been enabled.      We don't handle language specific options but printing argv      should suffice.  */
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
operator|*
name|indent
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|term
argument_list|,
name|_
argument_list|(
literal|"options enabled: "
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|f_options
operator|/
sizeof|sizeof
name|f_options
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|*
name|f_options
index|[
name|j
index|]
operator|.
name|variable
operator|==
name|f_options
index|[
name|j
index|]
operator|.
name|on_value
condition|)
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
name|sep
argument_list|,
name|term
argument_list|,
literal|"-f"
argument_list|,
name|f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
comment|/* Print target specific options.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|target_switches
operator|/
sizeof|sizeof
name|target_switches
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|target_switches
index|[
name|j
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|>
literal|0
operator|&&
operator|(
operator|(
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|&
name|target_flags
operator|)
operator|==
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|)
condition|)
block|{
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
name|sep
argument_list|,
name|term
argument_list|,
literal|"-m"
argument_list|,
name|target_switches
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|target_options
operator|/
sizeof|sizeof
name|target_options
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|*
name|target_options
index|[
name|j
index|]
operator|.
name|variable
operator|!=
name|NULL
condition|)
block|{
name|char
name|prefix
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|prefix
argument_list|,
literal|"-m%s"
argument_list|,
name|target_options
index|[
name|j
index|]
operator|.
name|prefix
argument_list|)
expr_stmt|;
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
name|sep
argument_list|,
name|term
argument_list|,
name|prefix
argument_list|,
operator|*
name|target_options
index|[
name|j
index|]
operator|.
name|variable
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Record the beginning of a new source file, named FILENAME.  */
end_comment

begin_function
name|void
name|debug_start_source_file
parameter_list|(
name|filename
parameter_list|)
specifier|register
name|char
modifier|*
name|filename
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|dbxout_start_new_source_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|&&
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_start_new_source_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|&&
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
name|dwarf2out_start_source_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF2_DEBUGGING_INFO */
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_start_new_source_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Record the resumption of a source file.  LINENO is the line number in    the source file we are returning to.  */
end_comment

begin_function
name|void
name|debug_end_source_file
parameter_list|(
name|lineno
parameter_list|)
specifier|register
name|unsigned
name|lineno
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|dbxout_resume_previous_source_file
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|&&
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_resume_previous_source_file
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|&&
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
name|dwarf2out_end_source_file
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF2_DEBUGGING_INFO */
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_resume_previous_source_file
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Called from check_newline in c-parse.y.  The `buffer' parameter contains    the tail part of the directive line, i.e. the part which is past the    initial whitespace, #, whitespace, directive-name, whitespace part.  */
end_comment

begin_function
name|void
name|debug_define
parameter_list|(
name|lineno
parameter_list|,
name|buffer
parameter_list|)
specifier|register
name|unsigned
name|lineno
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|&&
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_define
argument_list|(
name|lineno
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|&&
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
name|dwarf2out_define
argument_list|(
name|lineno
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF2_DEBUGGING_INFO */
block|}
end_function

begin_comment
comment|/* Called from check_newline in c-parse.y.  The `buffer' parameter contains    the tail part of the directive line, i.e. the part which is past the    initial whitespace, #, whitespace, directive-name, whitespace part.  */
end_comment

begin_function
name|void
name|debug_undef
parameter_list|(
name|lineno
parameter_list|,
name|buffer
parameter_list|)
specifier|register
name|unsigned
name|lineno
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|&&
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_undef
argument_list|(
name|lineno
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|&&
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
name|dwarf2out_undef
argument_list|(
name|lineno
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF2_DEBUGGING_INFO */
block|}
end_function

end_unit

