begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tree-dumping functionality for intermediate representation.    Copyright (C) 1999, 2000, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.    Written by Mark Mitchell<mark@codesourcery.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_function_decl
specifier|static
name|unsigned
name|int
name|queue
parameter_list|(
name|dump_info_p
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_index
parameter_list|(
name|dump_info_p
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dequeue_and_dump
parameter_list|(
name|dump_info_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_new_line
parameter_list|(
name|dump_info_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_maybe_newline
parameter_list|(
name|dump_info_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dump_enable_all
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add T to the end of the queue of nodes to dump.  Returns the index    assigned to T.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|queue
parameter_list|(
name|dump_info_p
name|di
parameter_list|,
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|dump_queue_p
name|dq
decl_stmt|;
name|dump_node_info_p
name|dni
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
comment|/* Assign the next available index to T.  */
name|index
operator|=
operator|++
name|di
operator|->
name|index
expr_stmt|;
comment|/* Obtain a new queue node.  */
if|if
condition|(
name|di
operator|->
name|free_list
condition|)
block|{
name|dq
operator|=
name|di
operator|->
name|free_list
expr_stmt|;
name|di
operator|->
name|free_list
operator|=
name|dq
operator|->
name|next
expr_stmt|;
block|}
else|else
name|dq
operator|=
name|XNEW
argument_list|(
expr|struct
name|dump_queue
argument_list|)
expr_stmt|;
comment|/* Create a new entry in the splay-tree.  */
name|dni
operator|=
name|XNEW
argument_list|(
expr|struct
name|dump_node_info
argument_list|)
expr_stmt|;
name|dni
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|dni
operator|->
name|binfo_p
operator|=
operator|(
operator|(
name|flags
operator|&
name|DUMP_BINFO
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|dq
operator|->
name|node
operator|=
name|splay_tree_insert
argument_list|(
name|di
operator|->
name|nodes
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|t
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|dni
argument_list|)
expr_stmt|;
comment|/* Add it to the end of the queue.  */
name|dq
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|di
operator|->
name|queue_end
condition|)
name|di
operator|->
name|queue
operator|=
name|dq
expr_stmt|;
else|else
name|di
operator|->
name|queue_end
operator|->
name|next
operator|=
name|dq
expr_stmt|;
name|di
operator|->
name|queue_end
operator|=
name|dq
expr_stmt|;
comment|/* Return the index.  */
return|return
name|index
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_index
parameter_list|(
name|dump_info_p
name|di
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"@%-6u "
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|+=
literal|8
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If T has not already been output, queue it for subsequent output.    FIELD is a string to print before printing the index.  Then, the    index of T is printed.  */
end_comment

begin_function
name|void
name|queue_and_dump_index
parameter_list|(
name|dump_info_p
name|di
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|,
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|int
name|index
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
comment|/* If there's no node, just return.  This makes for fewer checks in      our callers.  */
if|if
condition|(
operator|!
name|t
condition|)
return|return;
comment|/* See if we've already queued or dumped this node.  */
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|di
operator|->
name|nodes
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|index
operator|=
operator|(
operator|(
name|dump_node_info_p
operator|)
name|n
operator|->
name|value
operator|)
operator|->
name|index
expr_stmt|;
else|else
comment|/* If we haven't, add it to the queue.  */
name|index
operator|=
name|queue
argument_list|(
name|di
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Print the index of the node.  */
name|dump_maybe_newline
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%-4s: "
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|+=
literal|6
expr_stmt|;
name|dump_index
argument_list|(
name|di
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the type of T.  */
end_comment

begin_function
name|void
name|queue_and_dump_type
parameter_list|(
name|dump_info_p
name|di
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|queue_and_dump_index
argument_list|(
name|di
argument_list|,
literal|"type"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|DUMP_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump column control */
end_comment

begin_define
define|#
directive|define
name|SOL_COLUMN
value|25
end_define

begin_comment
comment|/* Start of line column.  */
end_comment

begin_define
define|#
directive|define
name|EOL_COLUMN
value|55
end_define

begin_comment
comment|/* End of line column.  */
end_comment

begin_define
define|#
directive|define
name|COLUMN_ALIGNMENT
value|15
end_define

begin_comment
comment|/* Alignment.  */
end_comment

begin_comment
comment|/* Insert a new line in the dump output, and indent to an appropriate    place to start printing more fields.  */
end_comment

begin_function
specifier|static
name|void
name|dump_new_line
parameter_list|(
name|dump_info_p
name|di
parameter_list|)
block|{
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"\n%*s"
argument_list|,
name|SOL_COLUMN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|=
name|SOL_COLUMN
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If necessary, insert a new line.  */
end_comment

begin_function
specifier|static
name|void
name|dump_maybe_newline
parameter_list|(
name|dump_info_p
name|di
parameter_list|)
block|{
name|int
name|extra
decl_stmt|;
comment|/* See if we need a new line.  */
if|if
condition|(
name|di
operator|->
name|column
operator|>
name|EOL_COLUMN
condition|)
name|dump_new_line
argument_list|(
name|di
argument_list|)
expr_stmt|;
comment|/* See if we need any padding.  */
elseif|else
if|if
condition|(
operator|(
name|extra
operator|=
operator|(
name|di
operator|->
name|column
operator|-
name|SOL_COLUMN
operator|)
operator|%
name|COLUMN_ALIGNMENT
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%*s"
argument_list|,
name|COLUMN_ALIGNMENT
operator|-
name|extra
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|+=
name|COLUMN_ALIGNMENT
operator|-
name|extra
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump pointer PTR using FIELD to identify it.  */
end_comment

begin_function
name|void
name|dump_pointer
parameter_list|(
name|dump_info_p
name|di
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|dump_maybe_newline
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%-4s: %-8lx "
argument_list|,
name|field
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ptr
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|+=
literal|15
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump integer I using FIELD to identify it.  */
end_comment

begin_function
name|void
name|dump_int
parameter_list|(
name|dump_info_p
name|di
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|dump_maybe_newline
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%-4s: %-7d "
argument_list|,
name|field
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|+=
literal|14
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the floating point value R, using FIELD to identify it.  */
end_comment

begin_function
specifier|static
name|void
name|dump_real
parameter_list|(
name|dump_info_p
name|di
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|real_to_decimal
argument_list|(
name|buf
argument_list|,
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|dump_maybe_newline
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%-4s: %s "
argument_list|,
name|field
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|7
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the string S.  */
end_comment

begin_function
name|void
name|dump_string
parameter_list|(
name|dump_info_p
name|di
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|dump_maybe_newline
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%-13s "
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|>
literal|13
condition|)
name|di
operator|->
name|column
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|di
operator|->
name|column
operator|+=
literal|14
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the string field S.  */
end_comment

begin_function
name|void
name|dump_string_field
parameter_list|(
name|dump_info_p
name|di
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|dump_maybe_newline
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%-4s: %-7s "
argument_list|,
name|field
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|>
literal|7
condition|)
name|di
operator|->
name|column
operator|+=
literal|6
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|di
operator|->
name|column
operator|+=
literal|14
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the next node in the queue.  */
end_comment

begin_function
specifier|static
name|void
name|dequeue_and_dump
parameter_list|(
name|dump_info_p
name|di
parameter_list|)
block|{
name|dump_queue_p
name|dq
decl_stmt|;
name|splay_tree_node
name|stn
decl_stmt|;
name|dump_node_info_p
name|dni
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|enum
name|tree_code_class
name|code_class
decl_stmt|;
specifier|const
name|char
modifier|*
name|code_name
decl_stmt|;
comment|/* Get the next node from the queue.  */
name|dq
operator|=
name|di
operator|->
name|queue
expr_stmt|;
name|stn
operator|=
name|dq
operator|->
name|node
expr_stmt|;
name|t
operator|=
operator|(
name|tree
operator|)
name|stn
operator|->
name|key
expr_stmt|;
name|dni
operator|=
operator|(
name|dump_node_info_p
operator|)
name|stn
operator|->
name|value
expr_stmt|;
name|index
operator|=
name|dni
operator|->
name|index
expr_stmt|;
comment|/* Remove the node from the queue, and put it on the free list.  */
name|di
operator|->
name|queue
operator|=
name|dq
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|di
operator|->
name|queue
condition|)
name|di
operator|->
name|queue_end
operator|=
literal|0
expr_stmt|;
name|dq
operator|->
name|next
operator|=
name|di
operator|->
name|free_list
expr_stmt|;
name|di
operator|->
name|free_list
operator|=
name|dq
expr_stmt|;
comment|/* Print the node index.  */
name|dump_index
argument_list|(
name|di
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* And the type of node this is.  */
if|if
condition|(
name|dni
operator|->
name|binfo_p
condition|)
name|code_name
operator|=
literal|"binfo"
expr_stmt|;
else|else
name|code_name
operator|=
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%-16s "
argument_list|,
name|code_name
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|=
literal|25
expr_stmt|;
comment|/* Figure out what kind of node this is.  */
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|code_class
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Although BINFOs are TREE_VECs, we dump them specially so as to be      more informative.  */
if|if
condition|(
name|dni
operator|->
name|binfo_p
condition|)
block|{
name|unsigned
name|ix
decl_stmt|;
name|tree
name|base
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|accesses
operator|=
name|BINFO_BASE_ACCESSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"type"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|t
argument_list|)
condition|)
name|dump_string_field
argument_list|(
name|di
argument_list|,
literal|"spec"
argument_list|,
literal|"virt"
argument_list|)
expr_stmt|;
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"bases"
argument_list|,
name|BINFO_N_BASE_BINFOS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|t
argument_list|,
name|ix
argument_list|,
name|base
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|access
init|=
operator|(
name|accesses
condition|?
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|accesses
argument_list|,
name|ix
argument_list|)
else|:
name|access_public_node
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|access
operator|==
name|access_public_node
condition|)
name|string
operator|=
literal|"pub"
expr_stmt|;
elseif|else
if|if
condition|(
name|access
operator|==
name|access_protected_node
condition|)
name|string
operator|=
literal|"prot"
expr_stmt|;
elseif|else
if|if
condition|(
name|access
operator|==
name|access_private_node
condition|)
name|string
operator|=
literal|"priv"
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|dump_string_field
argument_list|(
name|di
argument_list|,
literal|"accs"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|queue_and_dump_index
argument_list|(
name|di
argument_list|,
literal|"binf"
argument_list|,
name|base
argument_list|,
name|DUMP_BINFO
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* We can knock off a bunch of expression nodes in exactly the same      way.  */
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|code_class
argument_list|)
condition|)
block|{
comment|/* If we're dumping children, dump them now.  */
name|queue_and_dump_type
argument_list|(
name|di
argument_list|,
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code_class
condition|)
block|{
case|case
name|tcc_unary
case|:
name|dump_child
argument_list|(
literal|"op 0"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_binary
case|:
case|case
name|tcc_comparison
case|:
name|dump_child
argument_list|(
literal|"op 0"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"op 1"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_expression
case|:
case|case
name|tcc_reference
case|:
case|case
name|tcc_statement
case|:
comment|/* These nodes are handled explicitly below.  */
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|expanded_location
name|xloc
decl_stmt|;
comment|/* All declarations have names.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|dump_child
argument_list|(
literal|"name"
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|dump_child
argument_list|(
literal|"mngl"
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|t
argument_list|)
condition|)
name|dump_child
argument_list|(
literal|"orig"
argument_list|,
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And types.  */
name|queue_and_dump_type
argument_list|(
name|di
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"scpe"
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And a source position.  */
name|xloc
operator|=
name|expand_location
argument_list|(
name|DECL_SOURCE_LOCATION
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xloc
operator|.
name|file
condition|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|strrchr
argument_list|(
name|xloc
operator|.
name|file
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
name|filename
operator|=
name|xloc
operator|.
name|file
expr_stmt|;
else|else
comment|/* Skip the slash.  */
operator|++
name|filename
expr_stmt|;
name|dump_maybe_newline
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"srcp: %s:%-6d "
argument_list|,
name|filename
argument_list|,
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|+=
literal|6
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|8
expr_stmt|;
block|}
comment|/* And any declaration can be compiler-generated.  */
if|if
condition|(
name|CODE_CONTAINS_STRUCT
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TS_DECL_COMMON
argument_list|)
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
condition|)
name|dump_string_field
argument_list|(
name|di
argument_list|,
literal|"note"
argument_list|,
literal|"artificial"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|dump_flag
argument_list|(
name|di
argument_list|,
name|TDF_SLIM
argument_list|,
name|NULL
argument_list|)
condition|)
name|dump_child
argument_list|(
literal|"chan"
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code_class
operator|==
name|tcc_type
condition|)
block|{
comment|/* All types have qualifiers.  */
name|int
name|quals
init|=
name|lang_hooks
operator|.
name|tree_dump
operator|.
name|type_quals
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
block|{
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"qual: %c%c%c     "
argument_list|,
operator|(
name|quals
operator|&
name|TYPE_QUAL_CONST
operator|)
condition|?
literal|'c'
else|:
literal|' '
argument_list|,
operator|(
name|quals
operator|&
name|TYPE_QUAL_VOLATILE
operator|)
condition|?
literal|'v'
else|:
literal|' '
argument_list|,
operator|(
name|quals
operator|&
name|TYPE_QUAL_RESTRICT
operator|)
condition|?
literal|'r'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|+=
literal|14
expr_stmt|;
block|}
comment|/* All types have associated declarations.  */
name|dump_child
argument_list|(
literal|"name"
argument_list|,
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All types have a main variant.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|!=
name|t
condition|)
name|dump_child
argument_list|(
literal|"unql"
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And sizes.  */
name|dump_child
argument_list|(
literal|"size"
argument_list|,
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All types have alignments.  */
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"algn"
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code_class
operator|==
name|tcc_constant
condition|)
comment|/* All constants can have types.  */
name|queue_and_dump_type
argument_list|(
name|di
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Give the language-specific code a chance to print something.  If      it's completely taken care of things, don't bother printing      anything more ourselves.  */
if|if
condition|(
name|lang_hooks
operator|.
name|tree_dump
operator|.
name|dump_tree
argument_list|(
name|di
argument_list|,
name|t
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* Now handle the various kinds of nodes.  */
switch|switch
condition|(
name|code
condition|)
block|{
name|int
name|i
decl_stmt|;
case|case
name|IDENTIFIER_NODE
case|:
name|dump_string_field
argument_list|(
name|di
argument_list|,
literal|"strg"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"lngt"
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_LIST
case|:
name|dump_child
argument_list|(
literal|"purp"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"valu"
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"chan"
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATEMENT_LIST
case|:
block|{
name|tree_stmt_iterator
name|it
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|it
operator|=
name|tsi_start
argument_list|(
name|t
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|it
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|it
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|char
name|buffer
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
name|buffer
argument_list|,
name|tsi_stmt
argument_list|(
name|it
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TREE_VEC
case|:
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"lngt"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|char
name|buffer
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
name|buffer
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"prec"
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_string_field
argument_list|(
name|di
argument_list|,
literal|"sign"
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|t
argument_list|)
condition|?
literal|"unsigned"
else|:
literal|"signed"
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"min"
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"max"
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
name|dump_child
argument_list|(
literal|"csts"
argument_list|,
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"prec"
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
name|dump_child
argument_list|(
literal|"ptd"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REFERENCE_TYPE
case|:
name|dump_child
argument_list|(
literal|"refd"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
name|dump_child
argument_list|(
literal|"clas"
argument_list|,
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FUNCTION_TYPE
case|:
name|dump_child
argument_list|(
literal|"retn"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"prms"
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
name|dump_child
argument_list|(
literal|"elts"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"domn"
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|dump_string_field
argument_list|(
name|di
argument_list|,
literal|"tag"
argument_list|,
literal|"struct"
argument_list|)
expr_stmt|;
else|else
name|dump_string_field
argument_list|(
name|di
argument_list|,
literal|"tag"
argument_list|,
literal|"union"
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"flds"
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"fncs"
argument_list|,
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|queue_and_dump_index
argument_list|(
name|di
argument_list|,
literal|"binf"
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|DUMP_BINFO
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DECL
case|:
name|dump_child
argument_list|(
literal|"cnst"
argument_list|,
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_MEMORY_TAG
case|:
case|case
name|NAME_MEMORY_TAG
case|:
case|case
name|STRUCT_FIELD_TAG
case|:
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|dump_child
argument_list|(
literal|"argt"
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dump_child
argument_list|(
literal|"init"
argument_list|,
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"size"
argument_list|,
name|DECL_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"algn"
argument_list|,
name|DECL_ALIGN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|DECL_FIELD_OFFSET
argument_list|(
name|t
argument_list|)
condition|)
name|dump_child
argument_list|(
literal|"bpos"
argument_list|,
name|bit_position
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"used"
argument_list|,
name|TREE_USED
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|t
argument_list|)
condition|)
name|dump_string_field
argument_list|(
name|di
argument_list|,
literal|"spec"
argument_list|,
literal|"register"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
name|dump_child
argument_list|(
literal|"args"
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
condition|)
name|dump_string_field
argument_list|(
name|di
argument_list|,
literal|"body"
argument_list|,
literal|"undefined"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
condition|)
name|dump_string_field
argument_list|(
name|di
argument_list|,
literal|"link"
argument_list|,
literal|"extern"
argument_list|)
expr_stmt|;
else|else
name|dump_string_field
argument_list|(
name|di
argument_list|,
literal|"link"
argument_list|,
literal|"static"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|dump_flag
argument_list|(
name|di
argument_list|,
name|TDF_SLIM
argument_list|,
name|t
argument_list|)
condition|)
name|dump_child
argument_list|(
literal|"body"
argument_list|,
name|DECL_SAVED_TREE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
condition|)
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"high"
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"low"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"strg: %-7s "
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"lngt"
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
name|dump_real
argument_list|(
name|di
argument_list|,
literal|"valu"
argument_list|,
name|TREE_REAL_CST_PTR
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|ALIGN_INDIRECT_REF
case|:
case|case
name|MISALIGNED_INDIRECT_REF
case|:
case|case
name|CLEANUP_POINT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
comment|/* These nodes are unary, but do not have code class `1'.  */
name|dump_child
argument_list|(
literal|"op 0"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|INIT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
comment|/* These nodes are binary, but do not have code class `2'.  */
name|dump_child
argument_list|(
literal|"op 0"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"op 1"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
name|dump_child
argument_list|(
literal|"op 0"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"op 1"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"op 2"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
name|dump_child
argument_list|(
literal|"op 0"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"op 1"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"op 2"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"op 3"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|dump_child
argument_list|(
literal|"op 0"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"op 1"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"op 2"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_FINALLY_EXPR
case|:
name|dump_child
argument_list|(
literal|"op 0"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"op 1"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
name|dump_child
argument_list|(
literal|"fn"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"args"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|cnt
decl_stmt|;
name|tree
name|index
decl_stmt|,
name|value
decl_stmt|;
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"lngt"
argument_list|,
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (t)
argument_list|,
argument|cnt
argument_list|,
argument|index
argument_list|,
argument|value
argument_list|)
block|{
name|dump_child
argument_list|(
literal|"idx"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"val"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BIND_EXPR
case|:
name|dump_child
argument_list|(
literal|"vars"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"body"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOOP_EXPR
case|:
name|dump_child
argument_list|(
literal|"body"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXIT_EXPR
case|:
name|dump_child
argument_list|(
literal|"cond"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN_EXPR
case|:
name|dump_child
argument_list|(
literal|"expr"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_EXPR
case|:
name|dump_child
argument_list|(
literal|"decl"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"init"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"clnp"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There really are two possible places the initializer can be. 	 After RTL expansion, the second operand is moved to the 	 position of the fourth operand, and the second operand 	 becomes NULL.  */
name|dump_child
argument_list|(
literal|"init"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CASE_LABEL_EXPR
case|:
name|dump_child
argument_list|(
literal|"name"
argument_list|,
name|CASE_LABEL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CASE_LOW
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|dump_child
argument_list|(
literal|"low "
argument_list|,
name|CASE_LOW
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CASE_HIGH
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|dump_child
argument_list|(
literal|"high"
argument_list|,
name|CASE_HIGH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|LABEL_EXPR
case|:
name|dump_child
argument_list|(
literal|"name"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GOTO_EXPR
case|:
name|dump_child
argument_list|(
literal|"labl"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SWITCH_EXPR
case|:
name|dump_child
argument_list|(
literal|"cond"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"body"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|dump_child
argument_list|(
literal|"labl"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OMP_CLAUSE
case|:
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%s\n"
argument_list|,
name|omp_clause_code_name
index|[
name|OMP_CLAUSE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|omp_clause_num_ops
index|[
name|OMP_CLAUSE_CODE
argument_list|(
name|t
argument_list|)
index|]
condition|;
name|i
operator|++
control|)
name|dump_child
argument_list|(
literal|"op: "
argument_list|,
name|OMP_CLAUSE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* There are no additional fields to print.  */
break|break;
block|}
name|done
label|:
if|if
condition|(
name|dump_flag
argument_list|(
name|di
argument_list|,
name|TDF_ADDRESS
argument_list|,
name|NULL
argument_list|)
condition|)
name|dump_pointer
argument_list|(
name|di
argument_list|,
literal|"addr"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
comment|/* Terminate the line.  */
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if FLAG has been specified for the dump, and NODE    is not the root node of the dump.  */
end_comment

begin_function
name|int
name|dump_flag
parameter_list|(
name|dump_info_p
name|di
parameter_list|,
name|int
name|flag
parameter_list|,
name|tree
name|node
parameter_list|)
block|{
return|return
operator|(
name|di
operator|->
name|flags
operator|&
name|flag
operator|)
operator|&&
operator|(
name|node
operator|!=
name|di
operator|->
name|node
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Dump T, and all its children, on STREAM.  */
end_comment

begin_function
name|void
name|dump_node
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|dump_info
name|di
decl_stmt|;
name|dump_queue_p
name|dq
decl_stmt|;
name|dump_queue_p
name|next_dq
decl_stmt|;
comment|/* Initialize the dump-information structure.  */
name|di
operator|.
name|stream
operator|=
name|stream
expr_stmt|;
name|di
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|di
operator|.
name|column
operator|=
literal|0
expr_stmt|;
name|di
operator|.
name|queue
operator|=
literal|0
expr_stmt|;
name|di
operator|.
name|queue_end
operator|=
literal|0
expr_stmt|;
name|di
operator|.
name|free_list
operator|=
literal|0
expr_stmt|;
name|di
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|di
operator|.
name|node
operator|=
name|t
expr_stmt|;
name|di
operator|.
name|nodes
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
literal|0
argument_list|,
operator|(
name|splay_tree_delete_value_fn
operator|)
operator|&
name|free
argument_list|)
expr_stmt|;
comment|/* Queue up the first node.  */
name|queue
argument_list|(
operator|&
name|di
argument_list|,
name|t
argument_list|,
name|DUMP_NONE
argument_list|)
expr_stmt|;
comment|/* Until the queue is empty, keep dumping nodes.  */
while|while
condition|(
name|di
operator|.
name|queue
condition|)
name|dequeue_and_dump
argument_list|(
operator|&
name|di
argument_list|)
expr_stmt|;
comment|/* Now, clean up.  */
for|for
control|(
name|dq
operator|=
name|di
operator|.
name|free_list
init|;
name|dq
condition|;
name|dq
operator|=
name|next_dq
control|)
block|{
name|next_dq
operator|=
name|dq
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|dq
argument_list|)
expr_stmt|;
block|}
name|splay_tree_delete
argument_list|(
name|di
operator|.
name|nodes
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of tree dump switches. This must be consistent with the    TREE_DUMP_INDEX enumeration in tree.h.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dump_file_info
name|dump_files
index|[
name|TDI_end
index|]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".cgraph"
block|,
literal|"ipa-cgraph"
block|,
name|NULL
block|,
name|TDF_IPA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".tu"
block|,
literal|"translation-unit"
block|,
name|NULL
block|,
name|TDF_TREE
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|".class"
block|,
literal|"class-hierarchy"
block|,
name|NULL
block|,
name|TDF_TREE
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|".original"
block|,
literal|"tree-original"
block|,
name|NULL
block|,
name|TDF_TREE
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|".gimple"
block|,
literal|"tree-gimple"
block|,
name|NULL
block|,
name|TDF_TREE
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|".nested"
block|,
literal|"tree-nested"
block|,
name|NULL
block|,
name|TDF_TREE
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|".inlined"
block|,
literal|"tree-inlined"
block|,
name|NULL
block|,
name|TDF_TREE
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|}
block|,
block|{
literal|".vcg"
block|,
literal|"tree-vcg"
block|,
name|NULL
block|,
name|TDF_TREE
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|}
block|,
define|#
directive|define
name|FIRST_AUTO_NUMBERED_DUMP
value|8
block|{
name|NULL
block|,
literal|"tree-all"
block|,
name|NULL
block|,
name|TDF_TREE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|"rtl-all"
block|,
name|NULL
block|,
name|TDF_RTL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|"ipa-all"
block|,
name|NULL
block|,
name|TDF_IPA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dynamically registered tree dump files and switches.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dump_file_info
modifier|*
name|extra_dump_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|extra_dump_files_in_use
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|extra_dump_files_alloced
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define a name->number mapping for a dump flag value.  */
end_comment

begin_struct
struct|struct
name|dump_option_value_info
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* the name of the value */
specifier|const
name|int
name|value
decl_stmt|;
comment|/* the value of the name */
block|}
struct|;
end_struct

begin_comment
comment|/* Table of dump options. This must be consistent with the TDF_* flags    in tree.h */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|dump_option_value_info
name|dump_options
index|[]
init|=
block|{
block|{
literal|"address"
block|,
name|TDF_ADDRESS
block|}
block|,
block|{
literal|"slim"
block|,
name|TDF_SLIM
block|}
block|,
block|{
literal|"raw"
block|,
name|TDF_RAW
block|}
block|,
block|{
literal|"details"
block|,
name|TDF_DETAILS
block|}
block|,
block|{
literal|"stats"
block|,
name|TDF_STATS
block|}
block|,
block|{
literal|"blocks"
block|,
name|TDF_BLOCKS
block|}
block|,
block|{
literal|"vops"
block|,
name|TDF_VOPS
block|}
block|,
block|{
literal|"lineno"
block|,
name|TDF_LINENO
block|}
block|,
block|{
literal|"uid"
block|,
name|TDF_UID
block|}
block|,
block|{
literal|"stmtaddr"
block|,
name|TDF_STMTADDR
block|}
block|,
block|{
literal|"all"
block|,
operator|~
operator|(
name|TDF_RAW
operator||
name|TDF_SLIM
operator||
name|TDF_LINENO
operator||
name|TDF_TREE
operator||
name|TDF_RTL
operator||
name|TDF_IPA
operator||
name|TDF_STMTADDR
operator||
name|TDF_GRAPH
operator|)
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|unsigned
name|int
name|dump_register
parameter_list|(
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
specifier|const
name|char
modifier|*
name|swtch
parameter_list|,
specifier|const
name|char
modifier|*
name|glob
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|letter
parameter_list|)
block|{
specifier|static
name|int
name|next_dump
init|=
name|FIRST_AUTO_NUMBERED_DUMP
decl_stmt|;
name|int
name|num
init|=
name|next_dump
operator|++
decl_stmt|;
name|size_t
name|this
init|=
name|extra_dump_files_in_use
operator|++
decl_stmt|;
if|if
condition|(
name|this
operator|>=
name|extra_dump_files_alloced
condition|)
block|{
if|if
condition|(
name|extra_dump_files_alloced
operator|==
literal|0
condition|)
name|extra_dump_files_alloced
operator|=
literal|32
expr_stmt|;
else|else
name|extra_dump_files_alloced
operator|*=
literal|2
expr_stmt|;
name|extra_dump_files
operator|=
name|xrealloc
argument_list|(
name|extra_dump_files
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dump_file_info
argument_list|)
operator|*
name|extra_dump_files_alloced
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|extra_dump_files
index|[
name|this
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dump_file_info
argument_list|)
argument_list|)
expr_stmt|;
name|extra_dump_files
index|[
name|this
index|]
operator|.
name|suffix
operator|=
name|suffix
expr_stmt|;
name|extra_dump_files
index|[
name|this
index|]
operator|.
name|swtch
operator|=
name|swtch
expr_stmt|;
name|extra_dump_files
index|[
name|this
index|]
operator|.
name|glob
operator|=
name|glob
expr_stmt|;
name|extra_dump_files
index|[
name|this
index|]
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|extra_dump_files
index|[
name|this
index|]
operator|.
name|num
operator|=
name|num
expr_stmt|;
name|extra_dump_files
index|[
name|this
index|]
operator|.
name|letter
operator|=
name|letter
expr_stmt|;
return|return
name|this
operator|+
name|TDI_end
return|;
block|}
end_function

begin_comment
comment|/* Return the dump_file_info for the given phase.  */
end_comment

begin_function
name|struct
name|dump_file_info
modifier|*
name|get_dump_file_info
parameter_list|(
name|enum
name|tree_dump_index
name|phase
parameter_list|)
block|{
if|if
condition|(
name|phase
operator|<
name|TDI_end
condition|)
return|return
operator|&
name|dump_files
index|[
name|phase
index|]
return|;
elseif|else
if|if
condition|(
name|phase
operator|-
name|TDI_end
operator|>=
name|extra_dump_files_in_use
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|extra_dump_files
operator|+
operator|(
name|phase
operator|-
name|TDI_end
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the name of the dump file for the given phase.    If the dump is not enabled, returns NULL.  */
end_comment

begin_function
name|char
modifier|*
name|get_dump_file_name
parameter_list|(
name|enum
name|tree_dump_index
name|phase
parameter_list|)
block|{
name|char
name|dump_id
index|[
literal|10
index|]
decl_stmt|;
name|struct
name|dump_file_info
modifier|*
name|dfi
decl_stmt|;
if|if
condition|(
name|phase
operator|==
name|TDI_none
condition|)
return|return
name|NULL
return|;
name|dfi
operator|=
name|get_dump_file_info
argument_list|(
name|phase
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfi
operator|->
name|state
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|dfi
operator|->
name|num
operator|<
literal|0
condition|)
name|dump_id
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|char
name|suffix
decl_stmt|;
if|if
condition|(
name|dfi
operator|->
name|flags
operator|&
name|TDF_TREE
condition|)
name|suffix
operator|=
literal|'t'
expr_stmt|;
elseif|else
if|if
condition|(
name|dfi
operator|->
name|flags
operator|&
name|TDF_IPA
condition|)
name|suffix
operator|=
literal|'i'
expr_stmt|;
else|else
name|suffix
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|snprintf
argument_list|(
name|dump_id
argument_list|,
sizeof|sizeof
argument_list|(
name|dump_id
argument_list|)
argument_list|,
literal|".%03d%c"
argument_list|,
name|dfi
operator|->
name|num
argument_list|,
name|suffix
argument_list|)
operator|<
literal|0
condition|)
name|dump_id
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|concat
argument_list|(
name|dump_base_name
argument_list|,
name|dump_id
argument_list|,
name|dfi
operator|->
name|suffix
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Begin a tree dump for PHASE. Stores any user supplied flag in    *FLAG_PTR and returns a stream to write to. If the dump is not    enabled, returns NULL.    Multiple calls will reopen and append to the dump file.  */
end_comment

begin_function
name|FILE
modifier|*
name|dump_begin
parameter_list|(
name|enum
name|tree_dump_index
name|phase
parameter_list|,
name|int
modifier|*
name|flag_ptr
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|dump_file_info
modifier|*
name|dfi
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
if|if
condition|(
name|phase
operator|==
name|TDI_none
operator|||
operator|!
name|dump_enabled_p
argument_list|(
name|phase
argument_list|)
condition|)
return|return
name|NULL
return|;
name|name
operator|=
name|get_dump_file_name
argument_list|(
name|phase
argument_list|)
expr_stmt|;
name|dfi
operator|=
name|get_dump_file_info
argument_list|(
name|phase
argument_list|)
expr_stmt|;
name|stream
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|dfi
operator|->
name|state
operator|<
literal|0
condition|?
literal|"w"
else|:
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
name|error
argument_list|(
literal|"could not open dump file %qs: %s"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dfi
operator|->
name|state
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_ptr
condition|)
operator|*
name|flag_ptr
operator|=
name|dfi
operator|->
name|flags
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if tree dump PHASE is enabled.  If PHASE is    TDI_tree_all, return nonzero if any dump is enabled.  */
end_comment

begin_function
name|int
name|dump_enabled_p
parameter_list|(
name|enum
name|tree_dump_index
name|phase
parameter_list|)
block|{
if|if
condition|(
name|phase
operator|==
name|TDI_tree_all
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TDI_none
operator|+
literal|1
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|TDI_end
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dump_files
index|[
name|i
index|]
operator|.
name|state
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extra_dump_files_in_use
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|extra_dump_files
index|[
name|i
index|]
operator|.
name|state
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|struct
name|dump_file_info
modifier|*
name|dfi
init|=
name|get_dump_file_info
argument_list|(
name|phase
argument_list|)
decl_stmt|;
return|return
name|dfi
operator|->
name|state
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns nonzero if tree dump PHASE has been initialized.  */
end_comment

begin_function
name|int
name|dump_initialized_p
parameter_list|(
name|enum
name|tree_dump_index
name|phase
parameter_list|)
block|{
name|struct
name|dump_file_info
modifier|*
name|dfi
init|=
name|get_dump_file_info
argument_list|(
name|phase
argument_list|)
decl_stmt|;
return|return
name|dfi
operator|->
name|state
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns the switch name of PHASE.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|dump_flag_name
parameter_list|(
name|enum
name|tree_dump_index
name|phase
parameter_list|)
block|{
name|struct
name|dump_file_info
modifier|*
name|dfi
init|=
name|get_dump_file_info
argument_list|(
name|phase
argument_list|)
decl_stmt|;
return|return
name|dfi
operator|->
name|swtch
return|;
block|}
end_function

begin_comment
comment|/* Finish a tree dump for PHASE. STREAM is the stream created by    dump_begin.  */
end_comment

begin_function
name|void
name|dump_end
parameter_list|(
name|enum
name|tree_dump_index
name|phase
name|ATTRIBUTE_UNUSED
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enable all tree dumps.  Return number of enabled tree dumps.  */
end_comment

begin_function
specifier|static
name|int
name|dump_enable_all
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|letter
parameter_list|)
block|{
name|int
name|ir_type
init|=
operator|(
name|flags
operator|&
operator|(
name|TDF_TREE
operator||
name|TDF_RTL
operator||
name|TDF_IPA
operator|)
operator|)
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TDI_none
operator|+
literal|1
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|TDI_end
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|dump_files
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|ir_type
operator|)
operator|&&
operator|(
name|letter
operator|==
literal|0
operator|||
name|letter
operator|==
name|dump_files
index|[
name|i
index|]
operator|.
name|letter
operator|)
condition|)
block|{
name|dump_files
index|[
name|i
index|]
operator|.
name|state
operator|=
operator|-
literal|1
expr_stmt|;
name|dump_files
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|flags
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extra_dump_files_in_use
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|extra_dump_files
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|ir_type
operator|)
operator|&&
operator|(
name|letter
operator|==
literal|0
operator|||
name|letter
operator|==
name|extra_dump_files
index|[
name|i
index|]
operator|.
name|letter
operator|)
condition|)
block|{
name|extra_dump_files
index|[
name|i
index|]
operator|.
name|state
operator|=
operator|-
literal|1
expr_stmt|;
name|extra_dump_files
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|flags
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Parse ARG as a dump switch. Return nonzero if it is, and store the    relevant details in the dump_files array.  */
end_comment

begin_function
specifier|static
name|int
name|dump_switch_p_1
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|struct
name|dump_file_info
modifier|*
name|dfi
parameter_list|,
name|bool
name|doglob
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|option_value
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|doglob
operator|&&
operator|!
name|dfi
operator|->
name|glob
condition|)
return|return
literal|0
return|;
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
name|doglob
condition|?
name|dfi
operator|->
name|glob
else|:
name|dfi
operator|->
name|swtch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option_value
condition|)
return|return
literal|0
return|;
name|ptr
operator|=
name|option_value
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
specifier|const
name|struct
name|dump_option_value_info
modifier|*
name|option_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|end_ptr
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|==
literal|'-'
condition|)
name|ptr
operator|++
expr_stmt|;
name|end_ptr
operator|=
name|strchr
argument_list|(
name|ptr
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end_ptr
condition|)
name|end_ptr
operator|=
name|ptr
operator|+
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|length
operator|=
name|end_ptr
operator|-
name|ptr
expr_stmt|;
for|for
control|(
name|option_ptr
operator|=
name|dump_options
init|;
name|option_ptr
operator|->
name|name
condition|;
name|option_ptr
operator|++
control|)
if|if
condition|(
name|strlen
argument_list|(
name|option_ptr
operator|->
name|name
argument_list|)
operator|==
name|length
operator|&&
operator|!
name|memcmp
argument_list|(
name|option_ptr
operator|->
name|name
argument_list|,
name|ptr
argument_list|,
name|length
argument_list|)
condition|)
block|{
name|flags
operator||=
name|option_ptr
operator|->
name|value
expr_stmt|;
goto|goto
name|found
goto|;
block|}
name|warning
argument_list|(
literal|0
argument_list|,
literal|"ignoring unknown option %q.*s in %<-fdump-%s%>"
argument_list|,
name|length
argument_list|,
name|ptr
argument_list|,
name|dfi
operator|->
name|swtch
argument_list|)
expr_stmt|;
name|found
label|:
empty_stmt|;
name|ptr
operator|=
name|end_ptr
expr_stmt|;
block|}
name|dfi
operator|->
name|state
operator|=
operator|-
literal|1
expr_stmt|;
name|dfi
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
comment|/* Process -fdump-tree-all and -fdump-rtl-all, by enabling all the      known dumps.  */
if|if
condition|(
name|dfi
operator|->
name|suffix
operator|==
name|NULL
condition|)
name|dump_enable_all
argument_list|(
name|dfi
operator|->
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|dump_switch_p
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|any
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TDI_none
operator|+
literal|1
init|;
name|i
operator|!=
name|TDI_end
condition|;
name|i
operator|++
control|)
name|any
operator||=
name|dump_switch_p_1
argument_list|(
name|arg
argument_list|,
operator|&
name|dump_files
index|[
name|i
index|]
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Don't glob if we got a hit already */
if|if
condition|(
operator|!
name|any
condition|)
for|for
control|(
name|i
operator|=
name|TDI_none
operator|+
literal|1
init|;
name|i
operator|!=
name|TDI_end
condition|;
name|i
operator|++
control|)
name|any
operator||=
name|dump_switch_p_1
argument_list|(
name|arg
argument_list|,
operator|&
name|dump_files
index|[
name|i
index|]
argument_list|,
name|true
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extra_dump_files_in_use
condition|;
name|i
operator|++
control|)
name|any
operator||=
name|dump_switch_p_1
argument_list|(
name|arg
argument_list|,
operator|&
name|extra_dump_files
index|[
name|i
index|]
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|any
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extra_dump_files_in_use
condition|;
name|i
operator|++
control|)
name|any
operator||=
name|dump_switch_p_1
argument_list|(
name|arg
argument_list|,
operator|&
name|extra_dump_files
index|[
name|i
index|]
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|any
return|;
block|}
end_function

begin_comment
comment|/* Dump FUNCTION_DECL FN as tree dump PHASE.  */
end_comment

begin_function
name|void
name|dump_function
parameter_list|(
name|enum
name|tree_dump_index
name|phase
parameter_list|,
name|tree
name|fn
parameter_list|)
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|stream
operator|=
name|dump_begin
argument_list|(
name|phase
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
condition|)
block|{
name|dump_function_to_file
argument_list|(
name|fn
argument_list|,
name|stream
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dump_end
argument_list|(
name|phase
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|enable_rtl_dump_file
parameter_list|(
name|int
name|letter
parameter_list|)
block|{
if|if
condition|(
name|letter
operator|==
literal|'a'
condition|)
name|letter
operator|=
literal|0
expr_stmt|;
return|return
name|dump_enable_all
argument_list|(
name|TDF_RTL
operator||
name|TDF_DETAILS
operator||
name|TDF_BLOCKS
argument_list|,
name|letter
argument_list|)
operator|>
literal|0
return|;
block|}
end_function

end_unit

