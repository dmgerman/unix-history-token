begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tree-dumping functionality for intermediate representation.    Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.    Written by Mark Mitchell<mark@codesourcery.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|queue
name|PARAMS
argument_list|(
operator|(
name|dump_info_p
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_index
name|PARAMS
argument_list|(
operator|(
name|dump_info_p
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dequeue_and_dump
name|PARAMS
argument_list|(
operator|(
name|dump_info_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_new_line
name|PARAMS
argument_list|(
operator|(
name|dump_info_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_maybe_newline
name|PARAMS
argument_list|(
operator|(
name|dump_info_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_string_field
name|PARAMS
argument_list|(
operator|(
name|dump_info_p
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add T to the end of the queue of nodes to dump.  Returns the index    assigned to T.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|queue
parameter_list|(
name|di
parameter_list|,
name|t
parameter_list|,
name|flags
parameter_list|)
name|dump_info_p
name|di
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|dump_queue_p
name|dq
decl_stmt|;
name|dump_node_info_p
name|dni
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
comment|/* Assign the next available index to T.  */
name|index
operator|=
operator|++
name|di
operator|->
name|index
expr_stmt|;
comment|/* Obtain a new queue node.  */
if|if
condition|(
name|di
operator|->
name|free_list
condition|)
block|{
name|dq
operator|=
name|di
operator|->
name|free_list
expr_stmt|;
name|di
operator|->
name|free_list
operator|=
name|dq
operator|->
name|next
expr_stmt|;
block|}
else|else
name|dq
operator|=
operator|(
name|dump_queue_p
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dump_queue
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a new entry in the splay-tree.  */
name|dni
operator|=
operator|(
name|dump_node_info_p
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dump_node_info
argument_list|)
argument_list|)
expr_stmt|;
name|dni
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|dni
operator|->
name|binfo_p
operator|=
operator|(
operator|(
name|flags
operator|&
name|DUMP_BINFO
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|dq
operator|->
name|node
operator|=
name|splay_tree_insert
argument_list|(
name|di
operator|->
name|nodes
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|t
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|dni
argument_list|)
expr_stmt|;
comment|/* Add it to the end of the queue.  */
name|dq
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|di
operator|->
name|queue_end
condition|)
name|di
operator|->
name|queue
operator|=
name|dq
expr_stmt|;
else|else
name|di
operator|->
name|queue_end
operator|->
name|next
operator|=
name|dq
expr_stmt|;
name|di
operator|->
name|queue_end
operator|=
name|dq
expr_stmt|;
comment|/* Return the index.  */
return|return
name|index
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_index
parameter_list|(
name|di
parameter_list|,
name|index
parameter_list|)
name|dump_info_p
name|di
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"@%-6u "
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|+=
literal|8
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If T has not already been output, queue it for subsequent output.    FIELD is a string to print before printing the index.  Then, the    index of T is printed.  */
end_comment

begin_function
name|void
name|queue_and_dump_index
parameter_list|(
name|di
parameter_list|,
name|field
parameter_list|,
name|t
parameter_list|,
name|flags
parameter_list|)
name|dump_info_p
name|di
decl_stmt|;
specifier|const
name|char
modifier|*
name|field
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|unsigned
name|int
name|index
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
comment|/* If there's no node, just return.  This makes for fewer checks in      our callers.  */
if|if
condition|(
operator|!
name|t
condition|)
return|return;
comment|/* See if we've already queued or dumped this node.  */
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|di
operator|->
name|nodes
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|index
operator|=
operator|(
operator|(
name|dump_node_info_p
operator|)
name|n
operator|->
name|value
operator|)
operator|->
name|index
expr_stmt|;
else|else
comment|/* If we haven't, add it to the queue.  */
name|index
operator|=
name|queue
argument_list|(
name|di
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Print the index of the node.  */
name|dump_maybe_newline
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%-4s: "
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|+=
literal|6
expr_stmt|;
name|dump_index
argument_list|(
name|di
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the type of T.  */
end_comment

begin_function
name|void
name|queue_and_dump_type
parameter_list|(
name|di
parameter_list|,
name|t
parameter_list|)
name|dump_info_p
name|di
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|queue_and_dump_index
argument_list|(
name|di
argument_list|,
literal|"type"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|DUMP_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump column control */
end_comment

begin_define
define|#
directive|define
name|SOL_COLUMN
value|25
end_define

begin_comment
comment|/* Start of line column.  */
end_comment

begin_define
define|#
directive|define
name|EOL_COLUMN
value|55
end_define

begin_comment
comment|/* End of line column.  */
end_comment

begin_define
define|#
directive|define
name|COLUMN_ALIGNMENT
value|15
end_define

begin_comment
comment|/* Alignment.  */
end_comment

begin_comment
comment|/* Insert a new line in the dump output, and indent to an appropriate    place to start printing more fields.  */
end_comment

begin_function
specifier|static
name|void
name|dump_new_line
parameter_list|(
name|di
parameter_list|)
name|dump_info_p
name|di
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"\n%*s"
argument_list|,
name|SOL_COLUMN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|=
name|SOL_COLUMN
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If necessary, insert a new line.  */
end_comment

begin_function
specifier|static
name|void
name|dump_maybe_newline
parameter_list|(
name|di
parameter_list|)
name|dump_info_p
name|di
decl_stmt|;
block|{
name|int
name|extra
decl_stmt|;
comment|/* See if we need a new line.  */
if|if
condition|(
name|di
operator|->
name|column
operator|>
name|EOL_COLUMN
condition|)
name|dump_new_line
argument_list|(
name|di
argument_list|)
expr_stmt|;
comment|/* See if we need any padding.  */
elseif|else
if|if
condition|(
operator|(
name|extra
operator|=
operator|(
name|di
operator|->
name|column
operator|-
name|SOL_COLUMN
operator|)
operator|%
name|COLUMN_ALIGNMENT
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%*s"
argument_list|,
name|COLUMN_ALIGNMENT
operator|-
name|extra
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|+=
name|COLUMN_ALIGNMENT
operator|-
name|extra
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump pointer PTR using FIELD to identify it.  */
end_comment

begin_function
name|void
name|dump_pointer
parameter_list|(
name|di
parameter_list|,
name|field
parameter_list|,
name|ptr
parameter_list|)
name|dump_info_p
name|di
decl_stmt|;
specifier|const
name|char
modifier|*
name|field
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
name|dump_maybe_newline
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%-4s: %-8lx "
argument_list|,
name|field
argument_list|,
operator|(
name|long
operator|)
name|ptr
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|+=
literal|15
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump integer I using FIELD to identify it.  */
end_comment

begin_function
name|void
name|dump_int
parameter_list|(
name|di
parameter_list|,
name|field
parameter_list|,
name|i
parameter_list|)
name|dump_info_p
name|di
decl_stmt|;
specifier|const
name|char
modifier|*
name|field
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|dump_maybe_newline
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%-4s: %-7d "
argument_list|,
name|field
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|+=
literal|14
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the string S.  */
end_comment

begin_function
name|void
name|dump_string
parameter_list|(
name|di
parameter_list|,
name|string
parameter_list|)
name|dump_info_p
name|di
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|dump_maybe_newline
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%-13s "
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|>
literal|13
condition|)
name|di
operator|->
name|column
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|di
operator|->
name|column
operator|+=
literal|14
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the string field S.  */
end_comment

begin_function
specifier|static
name|void
name|dump_string_field
parameter_list|(
name|di
parameter_list|,
name|field
parameter_list|,
name|string
parameter_list|)
name|dump_info_p
name|di
decl_stmt|;
specifier|const
name|char
modifier|*
name|field
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|dump_maybe_newline
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%-4s: %-7s "
argument_list|,
name|field
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|>
literal|7
condition|)
name|di
operator|->
name|column
operator|+=
literal|6
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|di
operator|->
name|column
operator|+=
literal|14
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the next node in the queue.  */
end_comment

begin_function
specifier|static
name|void
name|dequeue_and_dump
parameter_list|(
name|di
parameter_list|)
name|dump_info_p
name|di
decl_stmt|;
block|{
name|dump_queue_p
name|dq
decl_stmt|;
name|splay_tree_node
name|stn
decl_stmt|;
name|dump_node_info_p
name|dni
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|char
name|code_class
decl_stmt|;
specifier|const
name|char
modifier|*
name|code_name
decl_stmt|;
comment|/* Get the next node from the queue.  */
name|dq
operator|=
name|di
operator|->
name|queue
expr_stmt|;
name|stn
operator|=
name|dq
operator|->
name|node
expr_stmt|;
name|t
operator|=
operator|(
name|tree
operator|)
name|stn
operator|->
name|key
expr_stmt|;
name|dni
operator|=
operator|(
name|dump_node_info_p
operator|)
name|stn
operator|->
name|value
expr_stmt|;
name|index
operator|=
name|dni
operator|->
name|index
expr_stmt|;
comment|/* Remove the node from the queue, and put it on the free list.  */
name|di
operator|->
name|queue
operator|=
name|dq
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|di
operator|->
name|queue
condition|)
name|di
operator|->
name|queue_end
operator|=
literal|0
expr_stmt|;
name|dq
operator|->
name|next
operator|=
name|di
operator|->
name|free_list
expr_stmt|;
name|di
operator|->
name|free_list
operator|=
name|dq
expr_stmt|;
comment|/* Print the node index.  */
name|dump_index
argument_list|(
name|di
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* And the type of node this is.  */
if|if
condition|(
name|dni
operator|->
name|binfo_p
condition|)
name|code_name
operator|=
literal|"binfo"
expr_stmt|;
else|else
name|code_name
operator|=
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"%-16s "
argument_list|,
name|code_name
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|=
literal|25
expr_stmt|;
comment|/* Figure out what kind of node this is.  */
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|code_class
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Although BINFOs are TREE_VECs, we dump them specially so as to be      more informative.  */
if|if
condition|(
name|dni
operator|->
name|binfo_p
condition|)
block|{
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|t
argument_list|)
condition|)
name|dump_string
argument_list|(
name|di
argument_list|,
literal|"pub"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|t
argument_list|)
condition|)
name|dump_string
argument_list|(
name|di
argument_list|,
literal|"prot"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_PRIVATE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_string
argument_list|(
name|di
argument_list|,
literal|"priv"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|)
condition|)
name|dump_string
argument_list|(
name|di
argument_list|,
literal|"virt"
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"type"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"base"
argument_list|,
name|BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* We can knock off a bunch of expression nodes in exactly the same      way.  */
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|code_class
argument_list|)
condition|)
block|{
comment|/* If we're dumping children, dump them now.  */
name|queue_and_dump_type
argument_list|(
name|di
argument_list|,
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code_class
condition|)
block|{
case|case
literal|'1'
case|:
name|dump_child
argument_list|(
literal|"op 0"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
case|case
literal|'<'
case|:
name|dump_child
argument_list|(
literal|"op 0"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"op 1"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* These nodes are handled explicitly below.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* All declarations have names.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|dump_child
argument_list|(
literal|"name"
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|dump_child
argument_list|(
literal|"mngl"
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And types.  */
name|queue_and_dump_type
argument_list|(
name|di
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"scpe"
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And a source position.  */
if|if
condition|(
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|strrchr
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
name|filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
comment|/* Skip the slash.  */
operator|++
name|filename
expr_stmt|;
name|dump_maybe_newline
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"srcp: %s:%-6d "
argument_list|,
name|filename
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|+=
literal|6
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|8
expr_stmt|;
block|}
comment|/* And any declaration can be compiler-generated.  */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
condition|)
name|dump_string
argument_list|(
name|di
argument_list|,
literal|"artificial"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|dump_flag
argument_list|(
name|di
argument_list|,
name|TDF_SLIM
argument_list|,
name|NULL
argument_list|)
condition|)
name|dump_child
argument_list|(
literal|"chan"
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code_class
operator|==
literal|'t'
condition|)
block|{
comment|/* All types have qualifiers.  */
name|int
name|quals
init|=
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_dump
operator|.
name|type_quals
call|)
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
block|{
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"qual: %c%c%c     "
argument_list|,
operator|(
name|quals
operator|&
name|TYPE_QUAL_CONST
operator|)
condition|?
literal|'c'
else|:
literal|' '
argument_list|,
operator|(
name|quals
operator|&
name|TYPE_QUAL_VOLATILE
operator|)
condition|?
literal|'v'
else|:
literal|' '
argument_list|,
operator|(
name|quals
operator|&
name|TYPE_QUAL_RESTRICT
operator|)
condition|?
literal|'r'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|di
operator|->
name|column
operator|+=
literal|14
expr_stmt|;
block|}
comment|/* All types have associated declarations.  */
name|dump_child
argument_list|(
literal|"name"
argument_list|,
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All types have a main variant.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|!=
name|t
condition|)
name|dump_child
argument_list|(
literal|"unql"
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And sizes.  */
name|dump_child
argument_list|(
literal|"size"
argument_list|,
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All types have alignments.  */
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"algn"
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code_class
operator|==
literal|'c'
condition|)
comment|/* All constants can have types.  */
name|queue_and_dump_type
argument_list|(
name|di
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Give the language-specific code a chance to print something.  If      it's completely taken care of things, don't bother printing      anything more ourselves.  */
if|if
condition|(
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_dump
operator|.
name|dump_tree
call|)
argument_list|(
name|di
argument_list|,
name|t
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* Now handle the various kinds of nodes.  */
switch|switch
condition|(
name|code
condition|)
block|{
name|int
name|i
decl_stmt|;
case|case
name|IDENTIFIER_NODE
case|:
name|dump_string_field
argument_list|(
name|di
argument_list|,
literal|"strg"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"lngt"
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_LIST
case|:
name|dump_child
argument_list|(
literal|"purp"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"valu"
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"chan"
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_VEC
case|:
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"lngt"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|char
name|buffer
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
name|buffer
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"prec"
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t
argument_list|)
condition|)
name|dump_string
argument_list|(
name|di
argument_list|,
literal|"unsigned"
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"min"
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"max"
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
name|dump_child
argument_list|(
literal|"csts"
argument_list|,
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"prec"
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
name|dump_child
argument_list|(
literal|"ptd"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REFERENCE_TYPE
case|:
name|dump_child
argument_list|(
literal|"refd"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
name|dump_child
argument_list|(
literal|"clas"
argument_list|,
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FUNCTION_TYPE
case|:
name|dump_child
argument_list|(
literal|"retn"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"prms"
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
name|dump_child
argument_list|(
literal|"elts"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"domn"
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|dump_string
argument_list|(
name|di
argument_list|,
literal|"struct"
argument_list|)
expr_stmt|;
else|else
name|dump_string
argument_list|(
name|di
argument_list|,
literal|"union"
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"flds"
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"fncs"
argument_list|,
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|queue_and_dump_index
argument_list|(
name|di
argument_list|,
literal|"binf"
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|DUMP_BINFO
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DECL
case|:
name|dump_child
argument_list|(
literal|"cnst"
argument_list|,
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|dump_child
argument_list|(
literal|"argt"
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dump_child
argument_list|(
literal|"init"
argument_list|,
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"size"
argument_list|,
name|DECL_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"algn"
argument_list|,
name|DECL_ALIGN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|DECL_FIELD_OFFSET
argument_list|(
name|t
argument_list|)
condition|)
name|dump_child
argument_list|(
literal|"bpos"
argument_list|,
name|bit_position
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"used"
argument_list|,
name|TREE_USED
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|t
argument_list|)
condition|)
name|dump_string
argument_list|(
name|di
argument_list|,
literal|"register"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
name|dump_child
argument_list|(
literal|"args"
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
condition|)
name|dump_string
argument_list|(
name|di
argument_list|,
literal|"undefined"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
condition|)
name|dump_string
argument_list|(
name|di
argument_list|,
literal|"extern"
argument_list|)
expr_stmt|;
else|else
name|dump_string
argument_list|(
name|di
argument_list|,
literal|"static"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|dump_flag
argument_list|(
name|di
argument_list|,
name|TDF_SLIM
argument_list|,
name|t
argument_list|)
condition|)
name|dump_child
argument_list|(
literal|"body"
argument_list|,
name|DECL_SAVED_TREE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
condition|)
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"high"
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"low"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"strg: %-7s "
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dump_int
argument_list|(
name|di
argument_list|,
literal|"lngt"
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|CLEANUP_POINT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
comment|/* These nodes are unary, but do not have code class `1'.  */
name|dump_child
argument_list|(
literal|"op 0"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|INIT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
comment|/* These nodes are binary, but do not have code class `2'.  */
name|dump_child
argument_list|(
literal|"op 0"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"op 1"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|dump_child
argument_list|(
literal|"op 0"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"op 1"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"op 2"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
name|dump_child
argument_list|(
literal|"fn"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"args"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
name|dump_child
argument_list|(
literal|"elts"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIND_EXPR
case|:
name|dump_child
argument_list|(
literal|"vars"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"body"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOOP_EXPR
case|:
name|dump_child
argument_list|(
literal|"body"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXIT_EXPR
case|:
name|dump_child
argument_list|(
literal|"cond"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_EXPR
case|:
name|dump_child
argument_list|(
literal|"decl"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"init"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dump_child
argument_list|(
literal|"clnp"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There really are two possible places the initializer can be. 	 After RTL expansion, the second operand is moved to the 	 position of the fourth operand, and the second operand 	 becomes NULL.  */
name|dump_child
argument_list|(
literal|"init"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPR_WITH_FILE_LOCATION
case|:
name|dump_child
argument_list|(
literal|"expr"
argument_list|,
name|EXPR_WFL_NODE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* There are no additional fields to print.  */
break|break;
block|}
name|done
label|:
if|if
condition|(
name|dump_flag
argument_list|(
name|di
argument_list|,
name|TDF_ADDRESS
argument_list|,
name|NULL
argument_list|)
condition|)
name|dump_pointer
argument_list|(
name|di
argument_list|,
literal|"addr"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
comment|/* Terminate the line.  */
name|fprintf
argument_list|(
name|di
operator|->
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if FLAG has been specified for the dump, and NODE    is not the root node of the dump.  */
end_comment

begin_function
name|int
name|dump_flag
parameter_list|(
name|di
parameter_list|,
name|flag
parameter_list|,
name|node
parameter_list|)
name|dump_info_p
name|di
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|tree
name|node
decl_stmt|;
block|{
return|return
operator|(
name|di
operator|->
name|flags
operator|&
name|flag
operator|)
operator|&&
operator|(
name|node
operator|!=
name|di
operator|->
name|node
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Dump T, and all its children, on STREAM.  */
end_comment

begin_function
name|void
name|dump_node
parameter_list|(
name|t
parameter_list|,
name|flags
parameter_list|,
name|stream
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|dump_info
name|di
decl_stmt|;
name|dump_queue_p
name|dq
decl_stmt|;
name|dump_queue_p
name|next_dq
decl_stmt|;
comment|/* Initialize the dump-information structure.  */
name|di
operator|.
name|stream
operator|=
name|stream
expr_stmt|;
name|di
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|di
operator|.
name|column
operator|=
literal|0
expr_stmt|;
name|di
operator|.
name|queue
operator|=
literal|0
expr_stmt|;
name|di
operator|.
name|queue_end
operator|=
literal|0
expr_stmt|;
name|di
operator|.
name|free_list
operator|=
literal|0
expr_stmt|;
name|di
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|di
operator|.
name|node
operator|=
name|t
expr_stmt|;
name|di
operator|.
name|nodes
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
literal|0
argument_list|,
operator|(
name|splay_tree_delete_value_fn
operator|)
operator|&
name|free
argument_list|)
expr_stmt|;
comment|/* Queue up the first node.  */
name|queue
argument_list|(
operator|&
name|di
argument_list|,
name|t
argument_list|,
name|DUMP_NONE
argument_list|)
expr_stmt|;
comment|/* Until the queue is empty, keep dumping nodes.  */
while|while
condition|(
name|di
operator|.
name|queue
condition|)
name|dequeue_and_dump
argument_list|(
operator|&
name|di
argument_list|)
expr_stmt|;
comment|/* Now, clean up.  */
for|for
control|(
name|dq
operator|=
name|di
operator|.
name|free_list
init|;
name|dq
condition|;
name|dq
operator|=
name|next_dq
control|)
block|{
name|next_dq
operator|=
name|dq
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|dq
argument_list|)
expr_stmt|;
block|}
name|splay_tree_delete
argument_list|(
name|di
operator|.
name|nodes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a tree dump switch.  */
end_comment

begin_struct
struct|struct
name|dump_file_info
block|{
specifier|const
name|char
modifier|*
specifier|const
name|suffix
decl_stmt|;
comment|/* suffix to give output file.  */
specifier|const
name|char
modifier|*
specifier|const
name|swtch
decl_stmt|;
comment|/* command line switch */
name|int
name|flags
decl_stmt|;
comment|/* user flags */
name|int
name|state
decl_stmt|;
comment|/* state of play */
block|}
struct|;
end_struct

begin_comment
comment|/* Table of tree dump switches. This must be consistent with the    TREE_DUMP_INDEX enumeration in tree.h */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dump_file_info
name|dump_files
index|[
name|TDI_end
index|]
init|=
block|{
block|{
literal|".tu"
block|,
literal|"dump-translation-unit"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".class"
block|,
literal|"dump-class-hierarchy"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".original"
block|,
literal|"dump-tree-original"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".optimized"
block|,
literal|"dump-tree-optimized"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|".inlined"
block|,
literal|"dump-tree-inlined"
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define a name->number mapping for a dump flag value.  */
end_comment

begin_struct
struct|struct
name|dump_option_value_info
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* the name of the value */
specifier|const
name|int
name|value
decl_stmt|;
comment|/* the value of the name */
block|}
struct|;
end_struct

begin_comment
comment|/* Table of dump options. This must be consistent with the TDF_* flags    in tree.h */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|dump_option_value_info
name|dump_options
index|[]
init|=
block|{
block|{
literal|"address"
block|,
name|TDF_ADDRESS
block|}
block|,
block|{
literal|"slim"
block|,
name|TDF_SLIM
block|}
block|,
block|{
literal|"all"
block|,
operator|~
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Begin a tree dump for PHASE. Stores any user supplied flag in    *FLAG_PTR and returns a stream to write to. If the dump is not    enabled, returns NULL.    Multiple calls will reopen and append to the dump file.  */
end_comment

begin_function
name|FILE
modifier|*
name|dump_begin
parameter_list|(
name|phase
parameter_list|,
name|flag_ptr
parameter_list|)
name|enum
name|tree_dump_index
name|phase
decl_stmt|;
name|int
modifier|*
name|flag_ptr
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|dump_files
index|[
name|phase
index|]
operator|.
name|state
condition|)
return|return
name|NULL
return|;
name|name
operator|=
name|concat
argument_list|(
name|dump_base_name
argument_list|,
name|dump_files
index|[
name|phase
index|]
operator|.
name|suffix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stream
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|dump_files
index|[
name|phase
index|]
operator|.
name|state
operator|<
literal|0
condition|?
literal|"w"
else|:
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
name|error
argument_list|(
literal|"could not open dump file `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|dump_files
index|[
name|phase
index|]
operator|.
name|state
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_ptr
condition|)
operator|*
name|flag_ptr
operator|=
name|dump_files
index|[
name|phase
index|]
operator|.
name|flags
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if tree dump PHASE is enabled.  */
end_comment

begin_function
name|int
name|dump_enabled_p
parameter_list|(
name|phase
parameter_list|)
name|enum
name|tree_dump_index
name|phase
decl_stmt|;
block|{
return|return
name|dump_files
index|[
name|phase
index|]
operator|.
name|state
return|;
block|}
end_function

begin_comment
comment|/* Returns the switch name of PHASE.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|dump_flag_name
parameter_list|(
name|phase
parameter_list|)
name|enum
name|tree_dump_index
name|phase
decl_stmt|;
block|{
return|return
name|dump_files
index|[
name|phase
index|]
operator|.
name|swtch
return|;
block|}
end_function

begin_comment
comment|/* Finish a tree dump for PHASE. STREAM is the stream created by    dump_begin.  */
end_comment

begin_function
name|void
name|dump_end
parameter_list|(
name|phase
parameter_list|,
name|stream
parameter_list|)
name|enum
name|tree_dump_index
name|phase
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse ARG as a dump switch. Return nonzero if it is, and store the    relevant details in the dump_files array.  */
end_comment

begin_function
name|int
name|dump_switch_p
parameter_list|(
name|arg
parameter_list|)
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|unsigned
name|ix
decl_stmt|;
specifier|const
name|char
modifier|*
name|option_value
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|TDI_end
condition|;
name|ix
operator|++
control|)
if|if
condition|(
operator|(
name|option_value
operator|=
name|skip_leading_substring
argument_list|(
name|arg
argument_list|,
name|dump_files
index|[
name|ix
index|]
operator|.
name|swtch
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|ptr
init|=
name|option_value
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
specifier|const
name|struct
name|dump_option_value_info
modifier|*
name|option_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|end_ptr
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|==
literal|'-'
condition|)
name|ptr
operator|++
expr_stmt|;
name|end_ptr
operator|=
name|strchr
argument_list|(
name|ptr
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end_ptr
condition|)
name|end_ptr
operator|=
name|ptr
operator|+
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|length
operator|=
name|end_ptr
operator|-
name|ptr
expr_stmt|;
for|for
control|(
name|option_ptr
operator|=
name|dump_options
init|;
name|option_ptr
operator|->
name|name
condition|;
name|option_ptr
operator|++
control|)
if|if
condition|(
name|strlen
argument_list|(
name|option_ptr
operator|->
name|name
argument_list|)
operator|==
name|length
operator|&&
operator|!
name|memcmp
argument_list|(
name|option_ptr
operator|->
name|name
argument_list|,
name|ptr
argument_list|,
name|length
argument_list|)
condition|)
block|{
name|flags
operator||=
name|option_ptr
operator|->
name|value
expr_stmt|;
goto|goto
name|found
goto|;
block|}
name|warning
argument_list|(
literal|"ignoring unknown option `%.*s' in `-f%s'"
argument_list|,
name|length
argument_list|,
name|ptr
argument_list|,
name|dump_files
index|[
name|ix
index|]
operator|.
name|swtch
argument_list|)
expr_stmt|;
name|found
label|:
empty_stmt|;
name|ptr
operator|=
name|end_ptr
expr_stmt|;
block|}
name|dump_files
index|[
name|ix
index|]
operator|.
name|state
operator|=
operator|-
literal|1
expr_stmt|;
name|dump_files
index|[
name|ix
index|]
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

