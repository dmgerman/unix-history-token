begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* target.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995, 1996, 1997, 1998, 2002 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       None     Description:       Implements conversion of lexer tokens to machine-dependent numerical       form and accordingly issues diagnostic messages when necessary.        Also, this module, especially its .h file, provides nearly all of the       information on the target machine's data type, kind type, and length       type capabilities.  The idea is that by carefully going through       target.h and changing things properly, one can accomplish much       towards the porting of the FFE to a new machine.	There are limits       to how much this can accomplish towards that end, however.  For one       thing, the ffeexpr_collapse_convert function doesn't contain all the       conversion cases necessary, because the text file would be       enormous (even though most of the function would be cut during the       cpp phase because of the absence of the types), so when adding to       the number of supported kind types for a given type, one must look       to see if ffeexpr_collapse_convert needs modification in this area,       in addition to providing the appropriate macros and functions in       ffetarget.  Note that if combinatorial explosion actually becomes a       problem for a given machine, one might have to modify the way conversion       expressions are built so that instead of just one conversion expr, a       series of conversion exprs are built to make a path from one type to       another that is not a "near neighbor".  For now, however, with a handful       of each of the numeric types and only one character type, things appear       manageable.        A nonobvious change to ffetarget would be if the target machine was       not a 2's-complement machine.  Any item with the word "magical" (case-       insensitive) in the FFE's source code (at least) indicates an assumption       that a 2's-complement machine is the target, and thus that there exists       a magnitude that can be represented as a negative number but not as       a positive number.  It is possible that this situation can be dealt       with by changing only ffetarget, for example, on a 1's-complement       machine, perhaps #defineing ffetarget_constant_is_magical to simply       FALSE along with making the appropriate changes in ffetarget's number       parsing functions would be sufficient to effectively "comment out" code       in places like ffeexpr that do certain magical checks.  But it is       possible there are other 2's-complement dependencies lurking in the       FFE (as possibly is true of any large program); if you find any, please       report them so we can replace them with dependencies on ffetarget       instead.     Modifications: */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"glimits.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"bad.h"
end_include

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_decl_stmt
name|char
name|ffetarget_string_
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temp for ascii-to-double (atof). */
end_comment

begin_decl_stmt
name|HOST_WIDE_INT
name|ffetarget_long_val_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HOST_WIDE_INT
name|ffetarget_long_junk_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_function_decl
specifier|static
name|void
name|ffetarget_print_char_
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|unsigned
name|char
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Internal macros. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REAL_VALUE_ATOF
end_ifdef

begin_define
define|#
directive|define
name|FFETARGET_ATOF_
parameter_list|(
name|p
parameter_list|,
name|m
parameter_list|)
value|REAL_VALUE_ATOF ((p),(m))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FFETARGET_ATOF_
parameter_list|(
name|p
parameter_list|,
name|m
parameter_list|)
value|atof ((p))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* ffetarget_print_char_ -- Print a single character (in apostrophe context)     See prototype.     Outputs char so it prints or is escaped C style.  */
end_comment

begin_function
specifier|static
name|void
name|ffetarget_print_char_
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|unsigned
name|char
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|fputs
argument_list|(
literal|"\\\\"
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|fputs
argument_list|(
literal|"\\\'"
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|fputc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffetarget_aggregate_info -- Determine type for aggregate storage area     See prototype.     If aggregate type is distinct, just return it.  Else return a type    representing a common denominator for the nondistinct type (for now,    just return default character, since that'll work on almost all target    machines).     The rules for abt/akt are (as implemented by ffestorag_update):     abt == FFEINFO_basictypeANY (akt == FFEINFO_kindtypeANY also, by    definition): CHARACTER and non-CHARACTER types mixed.     abt == FFEINFO_basictypeNONE (akt == FFEINFO_kindtypeNONE also, by    definition): More than one non-CHARACTER type mixed, but no CHARACTER    types mixed in.     abt some other value, akt == FFEINFO_kindtypeNONE: abt indicates the    only basic type mixed in, but more than one kind type is mixed in.     abt some other value, akt some other value: abt and akt indicate the    only type represented in the aggregation.  */
end_comment

begin_function
name|void
name|ffetarget_aggregate_info
parameter_list|(
name|ffeinfoBasictype
modifier|*
name|ebt
parameter_list|,
name|ffeinfoKindtype
modifier|*
name|ekt
parameter_list|,
name|ffetargetAlign
modifier|*
name|units
parameter_list|,
name|ffeinfoBasictype
name|abt
parameter_list|,
name|ffeinfoKindtype
name|akt
parameter_list|)
block|{
name|ffetype
name|type
decl_stmt|;
if|if
condition|(
operator|(
name|abt
operator|==
name|FFEINFO_basictypeNONE
operator|)
operator|||
operator|(
name|abt
operator|==
name|FFEINFO_basictypeANY
operator|)
operator|||
operator|(
name|akt
operator|==
name|FFEINFO_kindtypeNONE
operator|)
condition|)
block|{
operator|*
name|ebt
operator|=
name|FFEINFO_basictypeCHARACTER
expr_stmt|;
operator|*
name|ekt
operator|=
name|FFEINFO_kindtypeCHARACTERDEFAULT
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ebt
operator|=
name|abt
expr_stmt|;
operator|*
name|ekt
operator|=
name|akt
expr_stmt|;
block|}
name|type
operator|=
name|ffeinfo_type
argument_list|(
operator|*
name|ebt
argument_list|,
operator|*
name|ekt
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|type
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|units
operator|=
name|ffetype_size
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffetarget_align -- Align one storage area to superordinate, update super     See prototype.     updated_alignment/updated_modulo contain the already existing    alignment requirements for the storage area at whose offset the    object with alignment requirements alignment/modulo is to be placed.    Find the smallest pad such that the requirements are maintained and    return it, but only after updating the updated_alignment/_modulo    requirements as necessary to indicate the placement of the new object.  */
end_comment

begin_function
name|ffetargetAlign
name|ffetarget_align
parameter_list|(
name|ffetargetAlign
modifier|*
name|updated_alignment
parameter_list|,
name|ffetargetAlign
modifier|*
name|updated_modulo
parameter_list|,
name|ffetargetOffset
name|offset
parameter_list|,
name|ffetargetAlign
name|alignment
parameter_list|,
name|ffetargetAlign
name|modulo
parameter_list|)
block|{
name|ffetargetAlign
name|pad
decl_stmt|;
name|ffetargetAlign
name|min_pad
decl_stmt|;
comment|/* Minimum amount of padding needed. */
name|ffetargetAlign
name|min_m
init|=
literal|0
decl_stmt|;
comment|/* Minimum-padding m. */
name|ffetargetAlign
name|ua
decl_stmt|;
comment|/* Updated alignment. */
name|ffetargetAlign
name|um
decl_stmt|;
comment|/* Updated modulo. */
name|ffetargetAlign
name|ucnt
decl_stmt|;
comment|/* Multiplier applied to ua. */
name|ffetargetAlign
name|m
decl_stmt|;
comment|/* Copy of modulo. */
name|ffetargetAlign
name|cnt
decl_stmt|;
comment|/* Multiplier applied to alignment. */
name|ffetargetAlign
name|i
decl_stmt|;
name|ffetargetAlign
name|j
decl_stmt|;
name|assert
argument_list|(
name|alignment
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|updated_alignment
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|updated_modulo
operator|<
operator|*
name|updated_alignment
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|modulo
operator|<
name|alignment
argument_list|)
expr_stmt|;
comment|/* The easy case: similar alignment requirements.  */
if|if
condition|(
operator|*
name|updated_alignment
operator|==
name|alignment
condition|)
block|{
if|if
condition|(
name|modulo
operator|>
operator|*
name|updated_modulo
condition|)
name|pad
operator|=
name|alignment
operator|-
operator|(
name|modulo
operator|-
operator|*
name|updated_modulo
operator|)
expr_stmt|;
else|else
name|pad
operator|=
operator|*
name|updated_modulo
operator|-
name|modulo
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
comment|/* De-negatize offset, since % wouldn't do the expected thing.  */
name|offset
operator|=
name|alignment
operator|-
operator|(
operator|(
operator|-
name|offset
operator|)
operator|%
name|alignment
operator|)
expr_stmt|;
name|pad
operator|=
operator|(
name|offset
operator|+
name|pad
operator|)
operator|%
name|alignment
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
name|pad
operator|=
name|alignment
operator|-
name|pad
expr_stmt|;
return|return
name|pad
return|;
block|}
comment|/* Sigh, find LCM (Least Common Multiple) for the two alignment factors. */
for|for
control|(
name|ua
operator|=
operator|*
name|updated_alignment
operator|,
name|ucnt
operator|=
literal|1
init|;
name|ua
operator|%
name|alignment
operator|!=
literal|0
condition|;
name|ua
operator|+=
operator|*
name|updated_alignment
control|)
operator|++
name|ucnt
expr_stmt|;
name|cnt
operator|=
name|ua
operator|/
name|alignment
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
comment|/* De-negatize offset, since % wouldn't do the expected thing.  */
name|offset
operator|=
name|ua
operator|-
operator|(
operator|(
operator|-
name|offset
operator|)
operator|%
name|ua
operator|)
expr_stmt|;
comment|/* Set to largest value.  */
name|min_pad
operator|=
operator|~
operator|(
name|ffetargetAlign
operator|)
literal|0
expr_stmt|;
comment|/* Find all combinations of modulo values the two alignment requirements      have; pick the combination that results in the smallest padding      requirement.  Of course, if a zero-pad requirement is encountered, just      use that one. */
for|for
control|(
name|um
operator|=
operator|*
name|updated_modulo
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ucnt
condition|;
name|um
operator|+=
operator|*
name|updated_alignment
operator|,
operator|++
name|i
control|)
block|{
for|for
control|(
name|m
operator|=
name|modulo
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cnt
condition|;
name|m
operator|+=
name|alignment
operator|,
operator|++
name|j
control|)
block|{
comment|/* This code is similar to the "easy case" code above. */
if|if
condition|(
name|m
operator|>
name|um
condition|)
name|pad
operator|=
name|ua
operator|-
operator|(
name|m
operator|-
name|um
operator|)
expr_stmt|;
else|else
name|pad
operator|=
name|um
operator|-
name|m
expr_stmt|;
name|pad
operator|=
operator|(
name|offset
operator|+
name|pad
operator|)
operator|%
name|ua
expr_stmt|;
if|if
condition|(
name|pad
operator|==
literal|0
condition|)
block|{
comment|/* A zero pad means we've got something useful.  */
operator|*
name|updated_alignment
operator|=
name|ua
expr_stmt|;
operator|*
name|updated_modulo
operator|=
name|um
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pad
operator|=
name|ua
operator|-
name|pad
expr_stmt|;
if|if
condition|(
name|pad
operator|<
name|min_pad
condition|)
block|{
comment|/* New minimum padding value. */
name|min_pad
operator|=
name|pad
expr_stmt|;
name|min_m
operator|=
name|um
expr_stmt|;
block|}
block|}
block|}
operator|*
name|updated_alignment
operator|=
name|ua
expr_stmt|;
operator|*
name|updated_modulo
operator|=
name|min_m
expr_stmt|;
return|return
name|min_pad
return|;
block|}
end_function

begin_comment
comment|/* Always append a null byte to the end, in case this is wanted in    a special case such as passing a string as a FORMAT or %REF.    Done to save a bit of hassle, nothing more, but it's a kludge anyway,    because it isn't a "feature" that is self-documenting.  Use the    string "FFETARGET-NULL-KLUDGE" to flag anyplace you use this feature    in the code.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|bool
name|ffetarget_character1
parameter_list|(
name|ffetargetCharacter1
modifier|*
name|val
parameter_list|,
name|ffelexToken
name|character
parameter_list|,
name|mallocPool
name|pool
parameter_list|)
block|{
name|val
operator|->
name|length
operator|=
name|ffelex_token_length
argument_list|(
name|character
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|->
name|length
operator|==
literal|0
condition|)
name|val
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|val
operator|->
name|text
operator|=
name|malloc_new_kp
argument_list|(
name|pool
argument_list|,
literal|"ffetargetCharacter1"
argument_list|,
name|val
operator|->
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|val
operator|->
name|text
argument_list|,
name|ffelex_token_text
argument_list|(
name|character
argument_list|)
argument_list|,
name|val
operator|->
name|length
argument_list|)
expr_stmt|;
name|val
operator|->
name|text
index|[
name|val
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Produce orderable comparison between two constants     Compare lengths, if equal then use memcmp.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|int
name|ffetarget_cmp_character1
parameter_list|(
name|ffetargetCharacter1
name|l
parameter_list|,
name|ffetargetCharacter1
name|r
parameter_list|)
block|{
if|if
condition|(
name|l
operator|.
name|length
operator|<
name|r
operator|.
name|length
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|l
operator|.
name|length
operator|>
name|r
operator|.
name|length
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|l
operator|.
name|length
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|memcmp
argument_list|(
name|l
operator|.
name|text
argument_list|,
name|r
operator|.
name|text
argument_list|,
name|l
operator|.
name|length
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_concatenate_character1 -- Perform CONCAT op on two constants     Always append a null byte to the end, in case this is wanted in    a special case such as passing a string as a FORMAT or %REF.    Done to save a bit of hassle, nothing more, but it's a kludge anyway,    because it isn't a "feature" that is self-documenting.  Use the    string "FFETARGET-NULL-KLUDGE" to flag anyplace you use this feature    in the code.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|ffebad
name|ffetarget_concatenate_character1
parameter_list|(
name|ffetargetCharacter1
modifier|*
name|res
parameter_list|,
name|ffetargetCharacter1
name|l
parameter_list|,
name|ffetargetCharacter1
name|r
parameter_list|,
name|mallocPool
name|pool
parameter_list|,
name|ffetargetCharacterSize
modifier|*
name|len
parameter_list|)
block|{
name|res
operator|->
name|length
operator|=
operator|*
name|len
operator|=
name|l
operator|.
name|length
operator|+
name|r
operator|.
name|length
expr_stmt|;
if|if
condition|(
operator|*
name|len
operator|==
literal|0
condition|)
name|res
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|res
operator|->
name|text
operator|=
name|malloc_new_kp
argument_list|(
name|pool
argument_list|,
literal|"ffetargetCharacter1(CONCAT)"
argument_list|,
operator|*
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|.
name|length
operator|!=
literal|0
condition|)
name|memcpy
argument_list|(
name|res
operator|->
name|text
argument_list|,
name|l
operator|.
name|text
argument_list|,
name|l
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|length
operator|!=
literal|0
condition|)
name|memcpy
argument_list|(
name|res
operator|->
name|text
operator|+
name|l
operator|.
name|length
argument_list|,
name|r
operator|.
name|text
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|res
operator|->
name|text
index|[
operator|*
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_eq_character1 -- Perform relational comparison on char constants     Compare lengths, if equal then use memcmp.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|ffebad
name|ffetarget_eq_character1
parameter_list|(
name|bool
modifier|*
name|res
parameter_list|,
name|ffetargetCharacter1
name|l
parameter_list|,
name|ffetargetCharacter1
name|r
parameter_list|)
block|{
name|assert
argument_list|(
name|l
operator|.
name|length
operator|==
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|(
name|memcmp
argument_list|(
name|l
operator|.
name|text
argument_list|,
name|r
operator|.
name|text
argument_list|,
name|l
operator|.
name|length
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_le_character1 -- Perform relational comparison on char constants     Compare lengths, if equal then use memcmp.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|ffebad
name|ffetarget_le_character1
parameter_list|(
name|bool
modifier|*
name|res
parameter_list|,
name|ffetargetCharacter1
name|l
parameter_list|,
name|ffetargetCharacter1
name|r
parameter_list|)
block|{
name|assert
argument_list|(
name|l
operator|.
name|length
operator|==
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|(
name|memcmp
argument_list|(
name|l
operator|.
name|text
argument_list|,
name|r
operator|.
name|text
argument_list|,
name|l
operator|.
name|length
argument_list|)
operator|<=
literal|0
operator|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_lt_character1 -- Perform relational comparison on char constants     Compare lengths, if equal then use memcmp.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|ffebad
name|ffetarget_lt_character1
parameter_list|(
name|bool
modifier|*
name|res
parameter_list|,
name|ffetargetCharacter1
name|l
parameter_list|,
name|ffetargetCharacter1
name|r
parameter_list|)
block|{
name|assert
argument_list|(
name|l
operator|.
name|length
operator|==
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|(
name|memcmp
argument_list|(
name|l
operator|.
name|text
argument_list|,
name|r
operator|.
name|text
argument_list|,
name|l
operator|.
name|length
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_ge_character1 -- Perform relational comparison on char constants     Compare lengths, if equal then use memcmp.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|ffebad
name|ffetarget_ge_character1
parameter_list|(
name|bool
modifier|*
name|res
parameter_list|,
name|ffetargetCharacter1
name|l
parameter_list|,
name|ffetargetCharacter1
name|r
parameter_list|)
block|{
name|assert
argument_list|(
name|l
operator|.
name|length
operator|==
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|(
name|memcmp
argument_list|(
name|l
operator|.
name|text
argument_list|,
name|r
operator|.
name|text
argument_list|,
name|l
operator|.
name|length
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_gt_character1 -- Perform relational comparison on char constants     Compare lengths, if equal then use memcmp.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|ffebad
name|ffetarget_gt_character1
parameter_list|(
name|bool
modifier|*
name|res
parameter_list|,
name|ffetargetCharacter1
name|l
parameter_list|,
name|ffetargetCharacter1
name|r
parameter_list|)
block|{
name|assert
argument_list|(
name|l
operator|.
name|length
operator|==
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|(
name|memcmp
argument_list|(
name|l
operator|.
name|text
argument_list|,
name|r
operator|.
name|text
argument_list|,
name|l
operator|.
name|length
argument_list|)
operator|>
literal|0
operator|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|bool
name|ffetarget_iszero_character1
parameter_list|(
name|ffetargetCharacter1
name|constant
parameter_list|)
block|{
name|ffetargetCharacterSize
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|constant
operator|.
name|length
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|constant
operator|.
name|text
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|bool
name|ffetarget_iszero_hollerith
parameter_list|(
name|ffetargetHollerith
name|constant
parameter_list|)
block|{
name|ffetargetHollerithSize
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|constant
operator|.
name|length
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|constant
operator|.
name|text
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ffetarget_layout -- Do storage requirement analysis for entity     Return the alignment/modulo requirements along with the size, given the    data type info and the number of elements an array (1 for a scalar).	 */
end_comment

begin_function
name|void
name|ffetarget_layout
parameter_list|(
specifier|const
name|char
modifier|*
name|error_text
name|UNUSED
parameter_list|,
name|ffetargetAlign
modifier|*
name|alignment
parameter_list|,
name|ffetargetAlign
modifier|*
name|modulo
parameter_list|,
name|ffetargetOffset
modifier|*
name|size
parameter_list|,
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|,
name|ffetargetCharacterSize
name|charsize
parameter_list|,
name|ffetargetIntegerDefault
name|num_elements
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
comment|/* For character type. */
name|ffetargetOffset
name|numele
decl_stmt|;
comment|/* Converted from num_elements. */
name|ffetype
name|type
decl_stmt|;
name|type
operator|=
name|ffeinfo_type
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|type
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|alignment
operator|=
name|ffetype_alignment
argument_list|(
name|type
argument_list|)
expr_stmt|;
operator|*
name|modulo
operator|=
name|ffetype_modulo
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
block|{
name|ok
operator|=
name|ffetarget_offset_charsize
argument_list|(
name|size
argument_list|,
name|charsize
argument_list|,
name|ffetype_size
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ffetarget_offset_overflow
if|if
condition|(
operator|!
name|ok
condition|)
name|ffetarget_offset_overflow
argument_list|(
name|error_text
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
operator|*
name|size
operator|=
name|ffetype_size
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|num_elements
operator|<
literal|0
operator|)
operator|||
operator|!
name|ffetarget_offset
argument_list|(
operator|&
name|numele
argument_list|,
name|num_elements
argument_list|)
operator|||
operator|!
name|ffetarget_offset_multiply
argument_list|(
name|size
argument_list|,
operator|*
name|size
argument_list|,
name|numele
argument_list|)
condition|)
block|{
name|ffetarget_offset_overflow
argument_list|(
name|error_text
argument_list|)
expr_stmt|;
operator|*
name|alignment
operator|=
literal|1
expr_stmt|;
operator|*
name|modulo
operator|=
literal|0
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffetarget_ne_character1 -- Perform relational comparison on char constants     Compare lengths, if equal then use memcmp.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|ffebad
name|ffetarget_ne_character1
parameter_list|(
name|bool
modifier|*
name|res
parameter_list|,
name|ffetargetCharacter1
name|l
parameter_list|,
name|ffetargetCharacter1
name|r
parameter_list|)
block|{
name|assert
argument_list|(
name|l
operator|.
name|length
operator|==
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|(
name|memcmp
argument_list|(
name|l
operator|.
name|text
argument_list|,
name|r
operator|.
name|text
argument_list|,
name|l
operator|.
name|length
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_substr_character1 -- Perform SUBSTR op on three constants     Always append a null byte to the end, in case this is wanted in    a special case such as passing a string as a FORMAT or %REF.    Done to save a bit of hassle, nothing more, but it's a kludge anyway,    because it isn't a "feature" that is self-documenting.  Use the    string "FFETARGET-NULL-KLUDGE" to flag anyplace you use this feature    in the code.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|ffebad
name|ffetarget_substr_character1
parameter_list|(
name|ffetargetCharacter1
modifier|*
name|res
parameter_list|,
name|ffetargetCharacter1
name|l
parameter_list|,
name|ffetargetCharacterSize
name|first
parameter_list|,
name|ffetargetCharacterSize
name|last
parameter_list|,
name|mallocPool
name|pool
parameter_list|,
name|ffetargetCharacterSize
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
name|last
operator|<
name|first
condition|)
block|{
name|res
operator|->
name|length
operator|=
operator|*
name|len
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|res
operator|->
name|length
operator|=
operator|*
name|len
operator|=
name|last
operator|-
name|first
operator|+
literal|1
expr_stmt|;
name|res
operator|->
name|text
operator|=
name|malloc_new_kp
argument_list|(
name|pool
argument_list|,
literal|"ffetargetCharacter1(SUBSTR)"
argument_list|,
operator|*
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|->
name|text
argument_list|,
name|l
operator|.
name|text
operator|+
name|first
operator|-
literal|1
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
name|res
operator|->
name|text
index|[
operator|*
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_cmp_hollerith -- Produce orderable comparison between two    constants     Compare lengths, if equal then use memcmp.  */
end_comment

begin_function
name|int
name|ffetarget_cmp_hollerith
parameter_list|(
name|ffetargetHollerith
name|l
parameter_list|,
name|ffetargetHollerith
name|r
parameter_list|)
block|{
if|if
condition|(
name|l
operator|.
name|length
operator|<
name|r
operator|.
name|length
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|l
operator|.
name|length
operator|>
name|r
operator|.
name|length
condition|)
return|return
literal|1
return|;
return|return
name|memcmp
argument_list|(
name|l
operator|.
name|text
argument_list|,
name|r
operator|.
name|text
argument_list|,
name|l
operator|.
name|length
argument_list|)
return|;
block|}
end_function

begin_function
name|ffebad
name|ffetarget_convert_any_character1_
parameter_list|(
name|char
modifier|*
name|res
parameter_list|,
name|size_t
name|size
parameter_list|,
name|ffetargetCharacter1
name|l
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<=
operator|(
name|size_t
operator|)
name|l
operator|.
name|length
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|ffetargetCharacterSize
name|i
decl_stmt|;
name|memcpy
argument_list|(
name|res
argument_list|,
name|l
operator|.
name|text
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|l
operator|.
name|text
index|[
literal|0
index|]
operator|+
name|size
operator|,
name|i
operator|=
name|l
operator|.
name|length
operator|-
name|size
init|;
name|i
operator|>
literal|0
condition|;
operator|++
name|p
operator|,
operator|--
name|i
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
return|return
name|FFEBAD_TRUNCATING_CHARACTER
return|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|res
argument_list|,
name|l
operator|.
name|text
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|res
operator|+
name|l
operator|.
name|length
argument_list|,
literal|' '
argument_list|,
name|size
operator|-
name|l
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|FFEBAD
return|;
block|}
end_function

begin_function
name|ffebad
name|ffetarget_convert_any_hollerith_
parameter_list|(
name|char
modifier|*
name|res
parameter_list|,
name|size_t
name|size
parameter_list|,
name|ffetargetHollerith
name|l
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<=
operator|(
name|size_t
operator|)
name|l
operator|.
name|length
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|ffetargetCharacterSize
name|i
decl_stmt|;
name|memcpy
argument_list|(
name|res
argument_list|,
name|l
operator|.
name|text
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|l
operator|.
name|text
index|[
literal|0
index|]
operator|+
name|size
operator|,
name|i
operator|=
name|l
operator|.
name|length
operator|-
name|size
init|;
name|i
operator|>
literal|0
condition|;
operator|++
name|p
operator|,
operator|--
name|i
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
return|return
name|FFEBAD_TRUNCATING_HOLLERITH
return|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|res
argument_list|,
name|l
operator|.
name|text
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|res
operator|+
name|l
operator|.
name|length
argument_list|,
literal|' '
argument_list|,
name|size
operator|-
name|l
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|FFEBAD
return|;
block|}
end_function

begin_function
name|ffebad
name|ffetarget_convert_any_typeless_
parameter_list|(
name|char
modifier|*
name|res
parameter_list|,
name|size_t
name|size
parameter_list|,
name|ffetargetTypeless
name|l
parameter_list|)
block|{
name|unsigned
name|long
name|long
name|int
name|l1
decl_stmt|;
name|unsigned
name|long
name|int
name|l2
decl_stmt|;
name|unsigned
name|int
name|l3
decl_stmt|;
name|unsigned
name|short
name|int
name|l4
decl_stmt|;
name|unsigned
name|char
name|l5
decl_stmt|;
name|size_t
name|size_of
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
condition|)
block|{
name|l1
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l1
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
condition|)
block|{
name|l2
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l2
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|l3
argument_list|)
condition|)
block|{
name|l3
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l3
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l3
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|l4
argument_list|)
condition|)
block|{
name|l4
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l4
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l4
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|l5
argument_list|)
condition|)
block|{
name|l5
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l5
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l5
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l5
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
literal|"stumped by conversion from typeless!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|<=
name|size_of
condition|)
block|{
name|int
name|i
init|=
name|size_of
operator|-
name|size
decl_stmt|;
name|memcpy
argument_list|(
name|res
argument_list|,
name|p
operator|+
name|i
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
operator|++
name|p
operator|,
operator|--
name|i
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
return|return
name|FFEBAD_TRUNCATING_TYPELESS
return|;
block|}
else|else
block|{
name|int
name|i
init|=
name|size
operator|-
name|size_of
decl_stmt|;
name|memset
argument_list|(
name|res
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|+
name|i
argument_list|,
name|p
argument_list|,
name|size_of
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l1
operator|!=
name|l
condition|)
return|return
name|FFEBAD_TRUNCATING_TYPELESS
return|;
return|return
name|FFEBAD
return|;
block|}
end_function

begin_comment
comment|/* Always append a null byte to the end, in case this is wanted in    a special case such as passing a string as a FORMAT or %REF.    Done to save a bit of hassle, nothing more, but it's a kludge anyway,    because it isn't a "feature" that is self-documenting.  Use the    string "FFETARGET-NULL-KLUDGE" to flag anyplace you use this feature    in the code.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|ffebad
name|ffetarget_convert_character1_character1
parameter_list|(
name|ffetargetCharacter1
modifier|*
name|res
parameter_list|,
name|ffetargetCharacterSize
name|size
parameter_list|,
name|ffetargetCharacter1
name|l
parameter_list|,
name|mallocPool
name|pool
parameter_list|)
block|{
name|res
operator|->
name|length
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|res
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|res
operator|->
name|text
operator|=
name|malloc_new_kp
argument_list|(
name|pool
argument_list|,
literal|"FFETARGET cvt char1"
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|l
operator|.
name|length
condition|)
name|memcpy
argument_list|(
name|res
operator|->
name|text
argument_list|,
name|l
operator|.
name|text
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|res
operator|->
name|text
argument_list|,
name|l
operator|.
name|text
argument_list|,
name|l
operator|.
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|res
operator|->
name|text
operator|+
name|l
operator|.
name|length
argument_list|,
literal|' '
argument_list|,
name|size
operator|-
name|l
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|res
operator|->
name|text
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Always append a null byte to the end, in case this is wanted in    a special case such as passing a string as a FORMAT or %REF.    Done to save a bit of hassle, nothing more, but it's a kludge anyway,    because it isn't a "feature" that is self-documenting.  Use the    string "FFETARGET-NULL-KLUDGE" to flag anyplace you use this feature    in the code.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|ffebad
name|ffetarget_convert_character1_hollerith
parameter_list|(
name|ffetargetCharacter1
modifier|*
name|res
parameter_list|,
name|ffetargetCharacterSize
name|size
parameter_list|,
name|ffetargetHollerith
name|l
parameter_list|,
name|mallocPool
name|pool
parameter_list|)
block|{
name|res
operator|->
name|length
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|res
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|res
operator|->
name|text
operator|=
name|malloc_new_kp
argument_list|(
name|pool
argument_list|,
literal|"FFETARGET cvt char1"
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|res
operator|->
name|text
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|l
operator|.
name|length
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|ffetargetCharacterSize
name|i
decl_stmt|;
name|memcpy
argument_list|(
name|res
operator|->
name|text
argument_list|,
name|l
operator|.
name|text
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|l
operator|.
name|text
index|[
literal|0
index|]
operator|+
name|size
operator|,
name|i
operator|=
name|l
operator|.
name|length
operator|-
name|size
init|;
name|i
operator|>
literal|0
condition|;
operator|++
name|p
operator|,
operator|--
name|i
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
return|return
name|FFEBAD_TRUNCATING_HOLLERITH
return|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|res
operator|->
name|text
argument_list|,
name|l
operator|.
name|text
argument_list|,
name|l
operator|.
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|res
operator|->
name|text
operator|+
name|l
operator|.
name|length
argument_list|,
literal|' '
argument_list|,
name|size
operator|-
name|l
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_convert_character1_integer4 -- Raw conversion.     Always append a null byte to the end, in case this is wanted in    a special case such as passing a string as a FORMAT or %REF.    Done to save a bit of hassle, nothing more, but it's a kludge anyway,    because it isn't a "feature" that is self-documenting.  Use the    string "FFETARGET-NULL-KLUDGE" to flag anyplace you use this feature    in the code.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|ffebad
name|ffetarget_convert_character1_integer4
parameter_list|(
name|ffetargetCharacter1
modifier|*
name|res
parameter_list|,
name|ffetargetCharacterSize
name|size
parameter_list|,
name|ffetargetInteger4
name|l
parameter_list|,
name|mallocPool
name|pool
parameter_list|)
block|{
name|long
name|long
name|int
name|l1
decl_stmt|;
name|long
name|int
name|l2
decl_stmt|;
name|int
name|l3
decl_stmt|;
name|short
name|int
name|l4
decl_stmt|;
name|char
name|l5
decl_stmt|;
name|size_t
name|size_of
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
condition|)
block|{
name|l1
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l1
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
condition|)
block|{
name|l2
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l2
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|l3
argument_list|)
condition|)
block|{
name|l3
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l3
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l3
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|l4
argument_list|)
condition|)
block|{
name|l4
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l4
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l4
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|l5
argument_list|)
condition|)
block|{
name|l5
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l5
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l5
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l5
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
literal|"stumped by conversion from integer1!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|res
operator|->
name|length
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|res
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|res
operator|->
name|text
operator|=
name|malloc_new_kp
argument_list|(
name|pool
argument_list|,
literal|"FFETARGET cvt char1"
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|res
operator|->
name|text
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|<=
name|size_of
condition|)
block|{
name|int
name|i
init|=
name|size_of
operator|-
name|size
decl_stmt|;
name|memcpy
argument_list|(
name|res
operator|->
name|text
argument_list|,
name|p
operator|+
name|i
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
operator|++
name|p
operator|,
operator|--
name|i
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
return|return
name|FFEBAD_TRUNCATING_NUMERIC
return|;
block|}
else|else
block|{
name|int
name|i
init|=
name|size
operator|-
name|size_of
decl_stmt|;
name|memset
argument_list|(
name|res
operator|->
name|text
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|->
name|text
operator|+
name|i
argument_list|,
name|p
argument_list|,
name|size_of
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l1
operator|!=
name|l
condition|)
return|return
name|FFEBAD_TRUNCATING_NUMERIC
return|;
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_convert_character1_logical4 -- Raw conversion.     Always append a null byte to the end, in case this is wanted in    a special case such as passing a string as a FORMAT or %REF.    Done to save a bit of hassle, nothing more, but it's a kludge anyway,    because it isn't a "feature" that is self-documenting.  Use the    string "FFETARGET-NULL-KLUDGE" to flag anyplace you use this feature    in the code.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|ffebad
name|ffetarget_convert_character1_logical4
parameter_list|(
name|ffetargetCharacter1
modifier|*
name|res
parameter_list|,
name|ffetargetCharacterSize
name|size
parameter_list|,
name|ffetargetLogical4
name|l
parameter_list|,
name|mallocPool
name|pool
parameter_list|)
block|{
name|long
name|long
name|int
name|l1
decl_stmt|;
name|long
name|int
name|l2
decl_stmt|;
name|int
name|l3
decl_stmt|;
name|short
name|int
name|l4
decl_stmt|;
name|char
name|l5
decl_stmt|;
name|size_t
name|size_of
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
condition|)
block|{
name|l1
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l1
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
condition|)
block|{
name|l2
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l2
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|l3
argument_list|)
condition|)
block|{
name|l3
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l3
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l3
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|l4
argument_list|)
condition|)
block|{
name|l4
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l4
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l4
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|l5
argument_list|)
condition|)
block|{
name|l5
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l5
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l5
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l5
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
literal|"stumped by conversion from logical1!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|res
operator|->
name|length
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|res
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|res
operator|->
name|text
operator|=
name|malloc_new_kp
argument_list|(
name|pool
argument_list|,
literal|"FFETARGET cvt char1"
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|res
operator|->
name|text
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|<=
name|size_of
condition|)
block|{
name|int
name|i
init|=
name|size_of
operator|-
name|size
decl_stmt|;
name|memcpy
argument_list|(
name|res
operator|->
name|text
argument_list|,
name|p
operator|+
name|i
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
operator|++
name|p
operator|,
operator|--
name|i
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
return|return
name|FFEBAD_TRUNCATING_NUMERIC
return|;
block|}
else|else
block|{
name|int
name|i
init|=
name|size
operator|-
name|size_of
decl_stmt|;
name|memset
argument_list|(
name|res
operator|->
name|text
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|->
name|text
operator|+
name|i
argument_list|,
name|p
argument_list|,
name|size_of
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l1
operator|!=
name|l
condition|)
return|return
name|FFEBAD_TRUNCATING_NUMERIC
return|;
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_convert_character1_typeless -- Raw conversion.     Always append a null byte to the end, in case this is wanted in    a special case such as passing a string as a FORMAT or %REF.    Done to save a bit of hassle, nothing more, but it's a kludge anyway,    because it isn't a "feature" that is self-documenting.  Use the    string "FFETARGET-NULL-KLUDGE" to flag anyplace you use this feature    in the code.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|ffebad
name|ffetarget_convert_character1_typeless
parameter_list|(
name|ffetargetCharacter1
modifier|*
name|res
parameter_list|,
name|ffetargetCharacterSize
name|size
parameter_list|,
name|ffetargetTypeless
name|l
parameter_list|,
name|mallocPool
name|pool
parameter_list|)
block|{
name|unsigned
name|long
name|long
name|int
name|l1
decl_stmt|;
name|unsigned
name|long
name|int
name|l2
decl_stmt|;
name|unsigned
name|int
name|l3
decl_stmt|;
name|unsigned
name|short
name|int
name|l4
decl_stmt|;
name|unsigned
name|char
name|l5
decl_stmt|;
name|size_t
name|size_of
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
condition|)
block|{
name|l1
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l1
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
condition|)
block|{
name|l2
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l2
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|l3
argument_list|)
condition|)
block|{
name|l3
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l3
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l3
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|l4
argument_list|)
condition|)
block|{
name|l4
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l4
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l4
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|l5
argument_list|)
condition|)
block|{
name|l5
operator|=
name|l
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l5
expr_stmt|;
name|size_of
operator|=
sizeof|sizeof
argument_list|(
name|l5
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l5
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
literal|"stumped by conversion from typeless!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|res
operator|->
name|length
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|res
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|res
operator|->
name|text
operator|=
name|malloc_new_kp
argument_list|(
name|pool
argument_list|,
literal|"FFETARGET cvt char1"
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|res
operator|->
name|text
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|size
operator|)
operator|<=
name|size_of
condition|)
block|{
name|int
name|i
init|=
name|size_of
operator|-
name|size
decl_stmt|;
name|memcpy
argument_list|(
name|res
operator|->
name|text
argument_list|,
name|p
operator|+
name|i
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
operator|++
name|p
operator|,
operator|--
name|i
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
return|return
name|FFEBAD_TRUNCATING_TYPELESS
return|;
block|}
else|else
block|{
name|int
name|i
init|=
name|size
operator|-
name|size_of
decl_stmt|;
name|memset
argument_list|(
name|res
operator|->
name|text
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|->
name|text
operator|+
name|i
argument_list|,
name|p
argument_list|,
name|size_of
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l1
operator|!=
name|l
condition|)
return|return
name|FFEBAD_TRUNCATING_TYPELESS
return|;
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_divide_complex1 -- Divide function     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCOMPLEX1
end_if

begin_function
name|ffebad
name|ffetarget_divide_complex1
parameter_list|(
name|ffetargetComplex1
modifier|*
name|res
parameter_list|,
name|ffetargetComplex1
name|l
parameter_list|,
name|ffetargetComplex1
name|r
parameter_list|)
block|{
name|ffebad
name|bad
decl_stmt|;
name|ffetargetReal1
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmp3
decl_stmt|,
name|tmp4
decl_stmt|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp1
argument_list|,
name|r
operator|.
name|real
argument_list|,
name|r
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp2
argument_list|,
name|r
operator|.
name|imaginary
argument_list|,
name|r
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_add_real1
argument_list|(
operator|&
name|tmp3
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
if|if
condition|(
name|ffetarget_iszero_real1
argument_list|(
name|tmp3
argument_list|)
condition|)
block|{
name|ffetarget_real1_zero
argument_list|(
operator|&
operator|(
name|res
operator|)
operator|->
name|real
argument_list|)
expr_stmt|;
name|ffetarget_real1_zero
argument_list|(
operator|&
operator|(
name|res
operator|)
operator|->
name|imaginary
argument_list|)
expr_stmt|;
return|return
name|FFEBAD_DIV_BY_ZERO
return|;
block|}
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp1
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|r
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp2
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|r
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_add_real1
argument_list|(
operator|&
name|tmp4
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_divide_real1
argument_list|(
operator|&
name|res
operator|->
name|real
argument_list|,
name|tmp4
argument_list|,
name|tmp3
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp1
argument_list|,
name|r
operator|.
name|real
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp2
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|r
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_subtract_real1
argument_list|(
operator|&
name|tmp4
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_divide_real1
argument_list|(
operator|&
name|res
operator|->
name|imaginary
argument_list|,
name|tmp4
argument_list|,
name|tmp3
argument_list|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_divide_complex2 -- Divide function     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCOMPLEX2
end_if

begin_function
name|ffebad
name|ffetarget_divide_complex2
parameter_list|(
name|ffetargetComplex2
modifier|*
name|res
parameter_list|,
name|ffetargetComplex2
name|l
parameter_list|,
name|ffetargetComplex2
name|r
parameter_list|)
block|{
name|ffebad
name|bad
decl_stmt|;
name|ffetargetReal2
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmp3
decl_stmt|,
name|tmp4
decl_stmt|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp1
argument_list|,
name|r
operator|.
name|real
argument_list|,
name|r
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp2
argument_list|,
name|r
operator|.
name|imaginary
argument_list|,
name|r
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_add_real2
argument_list|(
operator|&
name|tmp3
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
if|if
condition|(
name|ffetarget_iszero_real2
argument_list|(
name|tmp3
argument_list|)
condition|)
block|{
name|ffetarget_real2_zero
argument_list|(
operator|&
operator|(
name|res
operator|)
operator|->
name|real
argument_list|)
expr_stmt|;
name|ffetarget_real2_zero
argument_list|(
operator|&
operator|(
name|res
operator|)
operator|->
name|imaginary
argument_list|)
expr_stmt|;
return|return
name|FFEBAD_DIV_BY_ZERO
return|;
block|}
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp1
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|r
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp2
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|r
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_add_real2
argument_list|(
operator|&
name|tmp4
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_divide_real2
argument_list|(
operator|&
name|res
operator|->
name|real
argument_list|,
name|tmp4
argument_list|,
name|tmp3
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp1
argument_list|,
name|r
operator|.
name|real
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp2
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|r
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_subtract_real2
argument_list|(
operator|&
name|tmp4
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_divide_real2
argument_list|(
operator|&
name|res
operator|->
name|imaginary
argument_list|,
name|tmp4
argument_list|,
name|tmp3
argument_list|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_hollerith -- Convert token to a hollerith constant     Always append a null byte to the end, in case this is wanted in    a special case such as passing a string as a FORMAT or %REF.    Done to save a bit of hassle, nothing more, but it's a kludge anyway,    because it isn't a "feature" that is self-documenting.  Use the    string "FFETARGET-NULL-KLUDGE" to flag anyplace you use this feature    in the code.  */
end_comment

begin_function
name|bool
name|ffetarget_hollerith
parameter_list|(
name|ffetargetHollerith
modifier|*
name|val
parameter_list|,
name|ffelexToken
name|integer
parameter_list|,
name|mallocPool
name|pool
parameter_list|)
block|{
name|val
operator|->
name|length
operator|=
name|ffelex_token_length
argument_list|(
name|integer
argument_list|)
expr_stmt|;
name|val
operator|->
name|text
operator|=
name|malloc_new_kp
argument_list|(
name|pool
argument_list|,
literal|"ffetargetHollerith"
argument_list|,
name|val
operator|->
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|val
operator|->
name|text
argument_list|,
name|ffelex_token_text
argument_list|(
name|integer
argument_list|)
argument_list|,
name|val
operator|->
name|length
argument_list|)
expr_stmt|;
name|val
operator|->
name|text
index|[
name|val
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ffetarget_integer_bad_magical -- Complain about a magical number     Just calls ffebad with the arguments.  */
end_comment

begin_function
name|void
name|ffetarget_integer_bad_magical
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_BAD_MAGICAL
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffetarget_integer_bad_magical_binary -- Complain about a magical number     Just calls ffebad with the arguments.  */
end_comment

begin_function
name|void
name|ffetarget_integer_bad_magical_binary
parameter_list|(
name|ffelexToken
name|integer
parameter_list|,
name|ffelexToken
name|minus
parameter_list|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_BAD_MAGICAL_BINARY
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|integer
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|minus
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|minus
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffetarget_integer_bad_magical_precedence -- Complain about a magical 						   number     Just calls ffebad with the arguments.  */
end_comment

begin_function
name|void
name|ffetarget_integer_bad_magical_precedence
parameter_list|(
name|ffelexToken
name|integer
parameter_list|,
name|ffelexToken
name|uminus
parameter_list|,
name|ffelexToken
name|higher_op
parameter_list|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_BAD_MAGICAL_PRECEDENCE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|integer
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|uminus
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|uminus
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|higher_op
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|higher_op
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffetarget_integer_bad_magical_precedence_binary -- Complain...     Just calls ffebad with the arguments.  */
end_comment

begin_function
name|void
name|ffetarget_integer_bad_magical_precedence_binary
parameter_list|(
name|ffelexToken
name|integer
parameter_list|,
name|ffelexToken
name|minus
parameter_list|,
name|ffelexToken
name|higher_op
parameter_list|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_BAD_MAGICAL_PRECEDENCE_BINARY
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|integer
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|minus
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|minus
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|higher_op
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|higher_op
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffetarget_integer1 -- Convert token to an integer     See prototype.     Token use count not affected overall.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okINTEGER1
end_if

begin_function
name|bool
name|ffetarget_integer1
parameter_list|(
name|ffetargetInteger1
modifier|*
name|val
parameter_list|,
name|ffelexToken
name|integer
parameter_list|)
block|{
name|ffetargetInteger1
name|x
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|integer
argument_list|)
operator|==
name|FFELEX_typeNUMBER
argument_list|)
expr_stmt|;
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|integer
argument_list|)
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
comment|/* Skip past leading zeros. */
while|while
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'0'
operator|)
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Interpret rest of number. */
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|==
name|FFETARGET_integerALMOST_BIG_MAGICAL
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'0'
operator|+
name|FFETARGET_integerFINISH_BIG_MAGICAL
operator|)
operator|&&
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'\0'
operator|)
condition|)
block|{
operator|*
name|val
operator|=
operator|(
name|ffetargetInteger1
operator|)
name|FFETARGET_integerBIG_MAGICAL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
name|FFETARGET_integerALMOST_BIG_MAGICAL
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|>
literal|'0'
operator|+
name|FFETARGET_integerFINISH_BIG_MAGICAL
operator|)
operator|||
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INTEGER_TOO_LARGE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|integer
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
operator|*
name|val
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|x
operator|>
name|FFETARGET_integerALMOST_BIG_MAGICAL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INTEGER_TOO_LARGE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|integer
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
operator|*
name|val
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|x
operator|=
name|x
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|c
operator|=
operator|*
operator|(
operator|++
name|p
operator|)
expr_stmt|;
block|}
empty_stmt|;
operator|*
name|val
operator|=
name|x
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_integerbinary -- Convert token to a binary integer     ffetarget_integerbinary x;    if (ffetarget_integerdefault_8(&x,integer_token))        // conversion ok.     Token use count not affected overall.  */
end_comment

begin_function
name|bool
name|ffetarget_integerbinary
parameter_list|(
name|ffetargetIntegerDefault
modifier|*
name|val
parameter_list|,
name|ffelexToken
name|integer
parameter_list|)
block|{
name|ffetargetIntegerDefault
name|x
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|bool
name|bad_digit
decl_stmt|;
name|assert
argument_list|(
operator|(
name|ffelex_token_type
argument_list|(
name|integer
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|integer
argument_list|)
operator|==
name|FFELEX_typeNUMBER
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|integer
argument_list|)
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
comment|/* Skip past leading zeros. */
while|while
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'0'
operator|)
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Interpret rest of number. */
name|bad_digit
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'1'
operator|)
condition|)
name|c
operator|-=
literal|'0'
expr_stmt|;
else|else
block|{
name|bad_digit
operator|=
name|TRUE
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Don't complain about signed overflow; just 				   unsigned overflow. */
block|if ((x == FFETARGET_integerALMOST_BIG_OVERFLOW_BINARY)&& (c == FFETARGET_integerFINISH_BIG_OVERFLOW_BINARY)&& (*(p + 1) == '\0')) 	{ 	  *val = FFETARGET_integerBIG_OVERFLOW_BINARY; 	  return TRUE; 	}       else
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_integerFINISH_BIG_OVERFLOW_BINARY
operator|==
literal|0
if|if
condition|(
operator|(
name|x
operator|&
name|FFETARGET_integerALMOST_BIG_OVERFLOW_BINARY
operator|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|x
operator|==
name|FFETARGET_integerALMOST_BIG_OVERFLOW_BINARY
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|>
name|FFETARGET_integerFINISH_BIG_OVERFLOW_BINARY
operator|)
operator|||
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INTEGER_TOO_LARGE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|integer
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
operator|*
name|val
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|x
operator|>
name|FFETARGET_integerALMOST_BIG_OVERFLOW_BINARY
condition|)
endif|#
directive|endif
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INTEGER_TOO_LARGE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|integer
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
operator|*
name|val
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|x
operator|=
operator|(
name|x
operator|<<
literal|1
operator|)
operator|+
name|c
expr_stmt|;
name|c
operator|=
operator|*
operator|(
operator|++
name|p
operator|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|bad_digit
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INVALID_BINARY_DIGIT
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|integer
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
operator|*
name|val
operator|=
name|x
expr_stmt|;
return|return
operator|!
name|bad_digit
return|;
block|}
end_function

begin_comment
comment|/* ffetarget_integerhex -- Convert token to a hex integer     ffetarget_integerhex x;    if (ffetarget_integerdefault_8(&x,integer_token))        // conversion ok.     Token use count not affected overall.  */
end_comment

begin_function
name|bool
name|ffetarget_integerhex
parameter_list|(
name|ffetargetIntegerDefault
modifier|*
name|val
parameter_list|,
name|ffelexToken
name|integer
parameter_list|)
block|{
name|ffetargetIntegerDefault
name|x
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|bool
name|bad_digit
decl_stmt|;
name|assert
argument_list|(
operator|(
name|ffelex_token_type
argument_list|(
name|integer
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|integer
argument_list|)
operator|==
name|FFELEX_typeNUMBER
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|integer
argument_list|)
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
comment|/* Skip past leading zeros. */
while|while
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'0'
operator|)
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Interpret rest of number. */
name|bad_digit
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|hex_p
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|hex_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|bad_digit
operator|=
name|TRUE
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Don't complain about signed overflow; just 				   unsigned overflow. */
block|if ((x == FFETARGET_integerALMOST_BIG_OVERFLOW_HEX)&& (c == FFETARGET_integerFINISH_BIG_OVERFLOW_HEX)&& (*(p + 1) == '\0')) 	{ 	  *val = FFETARGET_integerBIG_OVERFLOW_HEX; 	  return TRUE; 	}       else
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_integerFINISH_BIG_OVERFLOW_HEX
operator|==
literal|0
if|if
condition|(
name|x
operator|>=
name|FFETARGET_integerALMOST_BIG_OVERFLOW_HEX
condition|)
else|#
directive|else
if|if
condition|(
name|x
operator|==
name|FFETARGET_integerALMOST_BIG_OVERFLOW_HEX
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|>
name|FFETARGET_integerFINISH_BIG_OVERFLOW_HEX
operator|)
operator|||
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INTEGER_TOO_LARGE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|integer
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
operator|*
name|val
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|x
operator|>
name|FFETARGET_integerALMOST_BIG_OVERFLOW_HEX
condition|)
endif|#
directive|endif
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INTEGER_TOO_LARGE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|integer
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
operator|*
name|val
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|x
operator|=
operator|(
name|x
operator|<<
literal|4
operator|)
operator|+
name|c
expr_stmt|;
name|c
operator|=
operator|*
operator|(
operator|++
name|p
operator|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|bad_digit
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INVALID_HEX_DIGIT
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|integer
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
operator|*
name|val
operator|=
name|x
expr_stmt|;
return|return
operator|!
name|bad_digit
return|;
block|}
end_function

begin_comment
comment|/* ffetarget_integeroctal -- Convert token to an octal integer     ffetarget_integeroctal x;    if (ffetarget_integerdefault_8(&x,integer_token))        // conversion ok.     Token use count not affected overall.  */
end_comment

begin_function
name|bool
name|ffetarget_integeroctal
parameter_list|(
name|ffetargetIntegerDefault
modifier|*
name|val
parameter_list|,
name|ffelexToken
name|integer
parameter_list|)
block|{
name|ffetargetIntegerDefault
name|x
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|bool
name|bad_digit
decl_stmt|;
name|assert
argument_list|(
operator|(
name|ffelex_token_type
argument_list|(
name|integer
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|integer
argument_list|)
operator|==
name|FFELEX_typeNUMBER
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|integer
argument_list|)
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
comment|/* Skip past leading zeros. */
while|while
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'0'
operator|)
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Interpret rest of number. */
name|bad_digit
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'7'
operator|)
condition|)
name|c
operator|-=
literal|'0'
expr_stmt|;
else|else
block|{
name|bad_digit
operator|=
name|TRUE
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Don't complain about signed overflow; just 				   unsigned overflow. */
block|if ((x == FFETARGET_integerALMOST_BIG_OVERFLOW_OCTAL)&& (c == FFETARGET_integerFINISH_BIG_OVERFLOW_OCTAL)&& (*(p + 1) == '\0')) 	{ 	  *val = FFETARGET_integerBIG_OVERFLOW_OCTAL; 	  return TRUE; 	}       else
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_integerFINISH_BIG_OVERFLOW_OCTAL
operator|==
literal|0
if|if
condition|(
name|x
operator|>=
name|FFETARGET_integerALMOST_BIG_OVERFLOW_OCTAL
condition|)
else|#
directive|else
if|if
condition|(
name|x
operator|==
name|FFETARGET_integerALMOST_BIG_OVERFLOW_OCTAL
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|>
name|FFETARGET_integerFINISH_BIG_OVERFLOW_OCTAL
operator|)
operator|||
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INTEGER_TOO_LARGE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|integer
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
operator|*
name|val
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|x
operator|>
name|FFETARGET_integerALMOST_BIG_OVERFLOW_OCTAL
condition|)
endif|#
directive|endif
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INTEGER_TOO_LARGE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|integer
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
operator|*
name|val
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|x
operator|=
operator|(
name|x
operator|<<
literal|3
operator|)
operator|+
name|c
expr_stmt|;
name|c
operator|=
operator|*
operator|(
operator|++
name|p
operator|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|bad_digit
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INVALID_OCTAL_DIGIT
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|integer
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
operator|*
name|val
operator|=
name|x
expr_stmt|;
return|return
operator|!
name|bad_digit
return|;
block|}
end_function

begin_comment
comment|/* ffetarget_multiply_complex1 -- Multiply function     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCOMPLEX1
end_if

begin_function
name|ffebad
name|ffetarget_multiply_complex1
parameter_list|(
name|ffetargetComplex1
modifier|*
name|res
parameter_list|,
name|ffetargetComplex1
name|l
parameter_list|,
name|ffetargetComplex1
name|r
parameter_list|)
block|{
name|ffebad
name|bad
decl_stmt|;
name|ffetargetReal1
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp1
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|r
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp2
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|r
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_subtract_real1
argument_list|(
operator|&
name|res
operator|->
name|real
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp1
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|r
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp2
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|r
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_add_real1
argument_list|(
operator|&
name|res
operator|->
name|imaginary
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
return|return
name|bad
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_multiply_complex2 -- Multiply function     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCOMPLEX2
end_if

begin_function
name|ffebad
name|ffetarget_multiply_complex2
parameter_list|(
name|ffetargetComplex2
modifier|*
name|res
parameter_list|,
name|ffetargetComplex2
name|l
parameter_list|,
name|ffetargetComplex2
name|r
parameter_list|)
block|{
name|ffebad
name|bad
decl_stmt|;
name|ffetargetReal2
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp1
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|r
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp2
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|r
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_subtract_real2
argument_list|(
operator|&
name|res
operator|->
name|real
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp1
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|r
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp2
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|r
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_add_real2
argument_list|(
operator|&
name|res
operator|->
name|imaginary
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
return|return
name|bad
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_power_complexdefault_integerdefault -- Power function     See prototype.  */
end_comment

begin_function
name|ffebad
name|ffetarget_power_complexdefault_integerdefault
parameter_list|(
name|ffetargetComplexDefault
modifier|*
name|res
parameter_list|,
name|ffetargetComplexDefault
name|l
parameter_list|,
name|ffetargetIntegerDefault
name|r
parameter_list|)
block|{
name|ffebad
name|bad
decl_stmt|;
name|ffetargetRealDefault
name|tmp
decl_stmt|;
name|ffetargetRealDefault
name|tmp1
decl_stmt|;
name|ffetargetRealDefault
name|tmp2
decl_stmt|;
name|ffetargetRealDefault
name|two
decl_stmt|;
if|if
condition|(
name|ffetarget_iszero_real1
argument_list|(
name|l
operator|.
name|real
argument_list|)
operator|&&
name|ffetarget_iszero_real1
argument_list|(
name|l
operator|.
name|imaginary
argument_list|)
condition|)
block|{
name|ffetarget_real1_zero
argument_list|(
operator|&
name|res
operator|->
name|real
argument_list|)
expr_stmt|;
name|ffetarget_real1_zero
argument_list|(
operator|&
name|res
operator|->
name|imaginary
argument_list|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|ffetarget_real1_one
argument_list|(
operator|&
name|res
operator|->
name|real
argument_list|)
expr_stmt|;
name|ffetarget_real1_zero
argument_list|(
operator|&
name|res
operator|->
name|imaginary
argument_list|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|r
operator|=
operator|-
name|r
expr_stmt|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp1
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|l
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp2
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_add_real1
argument_list|(
operator|&
name|tmp
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_divide_real1
argument_list|(
operator|&
name|l
operator|.
name|real
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_divide_real1
argument_list|(
operator|&
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_uminus_real1
argument_list|(
operator|&
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
block|}
name|ffetarget_real1_two
argument_list|(
operator|&
name|two
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp1
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|l
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp2
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_subtract_real1
argument_list|(
operator|&
name|tmp
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|two
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|l
operator|.
name|real
operator|=
name|tmp
expr_stmt|;
name|r
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|l
expr_stmt|;
name|r
operator|>>=
literal|1
expr_stmt|;
while|while
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp1
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|l
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp2
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_subtract_real1
argument_list|(
operator|&
name|tmp
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|two
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|l
operator|.
name|real
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp1
argument_list|,
name|res
operator|->
name|real
argument_list|,
name|l
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp2
argument_list|,
name|res
operator|->
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_subtract_real1
argument_list|(
operator|&
name|tmp
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp1
argument_list|,
name|res
operator|->
name|imaginary
argument_list|,
name|l
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|tmp2
argument_list|,
name|res
operator|->
name|real
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_add_real1
argument_list|(
operator|&
name|res
operator|->
name|imaginary
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|res
operator|->
name|real
operator|=
name|tmp
expr_stmt|;
block|}
name|r
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
name|FFEBAD
return|;
block|}
end_function

begin_comment
comment|/* ffetarget_power_complexdouble_integerdefault -- Power function     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCOMPLEXDOUBLE
end_if

begin_function
name|ffebad
name|ffetarget_power_complexdouble_integerdefault
parameter_list|(
name|ffetargetComplexDouble
modifier|*
name|res
parameter_list|,
name|ffetargetComplexDouble
name|l
parameter_list|,
name|ffetargetIntegerDefault
name|r
parameter_list|)
block|{
name|ffebad
name|bad
decl_stmt|;
name|ffetargetRealDouble
name|tmp
decl_stmt|;
name|ffetargetRealDouble
name|tmp1
decl_stmt|;
name|ffetargetRealDouble
name|tmp2
decl_stmt|;
name|ffetargetRealDouble
name|two
decl_stmt|;
if|if
condition|(
name|ffetarget_iszero_real2
argument_list|(
name|l
operator|.
name|real
argument_list|)
operator|&&
name|ffetarget_iszero_real2
argument_list|(
name|l
operator|.
name|imaginary
argument_list|)
condition|)
block|{
name|ffetarget_real2_zero
argument_list|(
operator|&
name|res
operator|->
name|real
argument_list|)
expr_stmt|;
name|ffetarget_real2_zero
argument_list|(
operator|&
name|res
operator|->
name|imaginary
argument_list|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|ffetarget_real2_one
argument_list|(
operator|&
name|res
operator|->
name|real
argument_list|)
expr_stmt|;
name|ffetarget_real2_zero
argument_list|(
operator|&
name|res
operator|->
name|imaginary
argument_list|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|r
operator|=
operator|-
name|r
expr_stmt|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp1
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|l
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp2
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_add_real2
argument_list|(
operator|&
name|tmp
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_divide_real2
argument_list|(
operator|&
name|l
operator|.
name|real
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_divide_real2
argument_list|(
operator|&
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_uminus_real2
argument_list|(
operator|&
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
block|}
name|ffetarget_real2_two
argument_list|(
operator|&
name|two
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp1
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|l
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp2
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_subtract_real2
argument_list|(
operator|&
name|tmp
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|two
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|l
operator|.
name|real
operator|=
name|tmp
expr_stmt|;
name|r
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|l
expr_stmt|;
name|r
operator|>>=
literal|1
expr_stmt|;
while|while
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp1
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|l
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp2
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_subtract_real2
argument_list|(
operator|&
name|tmp
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|real
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|l
operator|.
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|,
name|two
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|l
operator|.
name|real
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp1
argument_list|,
name|res
operator|->
name|real
argument_list|,
name|l
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp2
argument_list|,
name|res
operator|->
name|imaginary
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_subtract_real2
argument_list|(
operator|&
name|tmp
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp1
argument_list|,
name|res
operator|->
name|imaginary
argument_list|,
name|l
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|tmp2
argument_list|,
name|res
operator|->
name|real
argument_list|,
name|l
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|bad
operator|=
name|ffetarget_add_real2
argument_list|(
operator|&
name|res
operator|->
name|imaginary
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|res
operator|->
name|real
operator|=
name|tmp
expr_stmt|;
block|}
name|r
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
name|FFEBAD
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_power_integerdefault_integerdefault -- Power function     See prototype.  */
end_comment

begin_function
name|ffebad
name|ffetarget_power_integerdefault_integerdefault
parameter_list|(
name|ffetargetIntegerDefault
modifier|*
name|res
parameter_list|,
name|ffetargetIntegerDefault
name|l
parameter_list|,
name|ffetargetIntegerDefault
name|r
parameter_list|)
block|{
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
literal|0
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
literal|1
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|==
literal|1
condition|)
operator|*
name|res
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|==
literal|0
condition|)
operator|*
name|res
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|==
operator|-
literal|1
condition|)
operator|*
name|res
operator|=
operator|(
operator|(
operator|-
name|r
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
else|else
operator|*
name|res
operator|=
literal|0
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
while|while
condition|(
operator|(
name|r
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|l
operator|*=
name|l
expr_stmt|;
name|r
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|l
expr_stmt|;
name|r
operator|>>=
literal|1
expr_stmt|;
while|while
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|l
operator|*=
name|l
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
operator|*
name|res
operator|*=
name|l
expr_stmt|;
name|r
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
name|FFEBAD
return|;
block|}
end_function

begin_comment
comment|/* ffetarget_power_realdefault_integerdefault -- Power function     See prototype.  */
end_comment

begin_function
name|ffebad
name|ffetarget_power_realdefault_integerdefault
parameter_list|(
name|ffetargetRealDefault
modifier|*
name|res
parameter_list|,
name|ffetargetRealDefault
name|l
parameter_list|,
name|ffetargetIntegerDefault
name|r
parameter_list|)
block|{
name|ffebad
name|bad
decl_stmt|;
if|if
condition|(
name|ffetarget_iszero_real1
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|ffetarget_real1_zero
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|ffetarget_real1_one
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|ffetargetRealDefault
name|one
decl_stmt|;
name|ffetarget_real1_one
argument_list|(
operator|&
name|one
argument_list|)
expr_stmt|;
name|r
operator|=
operator|-
name|r
expr_stmt|;
name|bad
operator|=
name|ffetarget_divide_real1
argument_list|(
operator|&
name|l
argument_list|,
name|one
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
block|}
while|while
condition|(
operator|(
name|r
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|l
argument_list|,
name|l
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|r
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|l
expr_stmt|;
name|r
operator|>>=
literal|1
expr_stmt|;
while|while
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
operator|&
name|l
argument_list|,
name|l
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
if|if
condition|(
operator|(
name|r
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
name|bad
operator|=
name|ffetarget_multiply_real1
argument_list|(
name|res
argument_list|,
operator|*
name|res
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
block|}
name|r
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
name|FFEBAD
return|;
block|}
end_function

begin_comment
comment|/* ffetarget_power_realdouble_integerdefault -- Power function     See prototype.  */
end_comment

begin_function
name|ffebad
name|ffetarget_power_realdouble_integerdefault
parameter_list|(
name|ffetargetRealDouble
modifier|*
name|res
parameter_list|,
name|ffetargetRealDouble
name|l
parameter_list|,
name|ffetargetIntegerDefault
name|r
parameter_list|)
block|{
name|ffebad
name|bad
decl_stmt|;
if|if
condition|(
name|ffetarget_iszero_real2
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|ffetarget_real2_zero
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|ffetarget_real2_one
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|ffetargetRealDouble
name|one
decl_stmt|;
name|ffetarget_real2_one
argument_list|(
operator|&
name|one
argument_list|)
expr_stmt|;
name|r
operator|=
operator|-
name|r
expr_stmt|;
name|bad
operator|=
name|ffetarget_divide_real2
argument_list|(
operator|&
name|l
argument_list|,
name|one
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
block|}
while|while
condition|(
operator|(
name|r
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|l
argument_list|,
name|l
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
name|r
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|l
expr_stmt|;
name|r
operator|>>=
literal|1
expr_stmt|;
while|while
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
operator|&
name|l
argument_list|,
name|l
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
if|if
condition|(
operator|(
name|r
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
name|bad
operator|=
name|ffetarget_multiply_real2
argument_list|(
name|res
argument_list|,
operator|*
name|res
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
return|return
name|bad
return|;
block|}
name|r
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
name|FFEBAD
return|;
block|}
end_function

begin_comment
comment|/* ffetarget_print_binary -- Output typeless binary integer     ffetargetTypeless val;    ffetarget_typeless_binary(dmpout,val);  */
end_comment

begin_function
name|void
name|ffetarget_print_binary
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|ffetargetTypeless
name|value
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|digits
index|[
sizeof|sizeof
argument_list|(
name|value
argument_list|)
operator|*
name|CHAR_BIT
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|f
operator|=
name|dmpout
expr_stmt|;
name|p
operator|=
operator|&
name|digits
index|[
name|ARRAY_SIZE
argument_list|(
name|digits
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|p
operator|=
operator|(
name|value
operator|&
literal|1
operator|)
operator|+
literal|'0'
expr_stmt|;
name|value
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|value
operator|==
literal|0
condition|)
do|;
name|fputs
argument_list|(
name|p
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffetarget_print_character1 -- Output character string     ffetargetCharacter1 val;    ffetarget_print_character1(dmpout,val);  */
end_comment

begin_function
name|void
name|ffetarget_print_character1
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|ffetargetCharacter1
name|value
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|ffetargetCharacterSize
name|i
decl_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|value
operator|.
name|text
init|;
name|i
operator|<
name|value
operator|.
name|length
condition|;
operator|++
name|i
operator|,
operator|++
name|p
control|)
name|ffetarget_print_char_
argument_list|(
name|f
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffetarget_print_hollerith -- Output hollerith string     ffetargetHollerith val;    ffetarget_print_hollerith(dmpout,val);  */
end_comment

begin_function
name|void
name|ffetarget_print_hollerith
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|ffetargetHollerith
name|value
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|ffetargetHollerithSize
name|i
decl_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|value
operator|.
name|text
init|;
name|i
operator|<
name|value
operator|.
name|length
condition|;
operator|++
name|i
operator|,
operator|++
name|p
control|)
name|ffetarget_print_char_
argument_list|(
name|f
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffetarget_print_octal -- Output typeless octal integer     ffetargetTypeless val;    ffetarget_print_octal(dmpout,val);  */
end_comment

begin_function
name|void
name|ffetarget_print_octal
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|ffetargetTypeless
name|value
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|digits
index|[
sizeof|sizeof
argument_list|(
name|value
argument_list|)
operator|*
name|CHAR_BIT
operator|/
literal|3
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|f
operator|=
name|dmpout
expr_stmt|;
name|p
operator|=
operator|&
name|digits
index|[
name|ARRAY_SIZE
argument_list|(
name|digits
argument_list|)
operator|-
literal|3
index|]
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|p
operator|=
operator|(
name|value
operator|&
literal|3
operator|)
operator|+
literal|'0'
expr_stmt|;
name|value
operator|>>=
literal|3
expr_stmt|;
block|}
do|while
condition|(
name|value
operator|==
literal|0
condition|)
do|;
name|fputs
argument_list|(
name|p
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffetarget_print_hex -- Output typeless hex integer     ffetargetTypeless val;    ffetarget_print_hex(dmpout,val);  */
end_comment

begin_function
name|void
name|ffetarget_print_hex
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|ffetargetTypeless
name|value
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|digits
index|[
sizeof|sizeof
argument_list|(
name|value
argument_list|)
operator|*
name|CHAR_BIT
operator|/
literal|4
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|char
name|hexdigits
index|[
literal|16
index|]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|f
operator|=
name|dmpout
expr_stmt|;
name|p
operator|=
operator|&
name|digits
index|[
name|ARRAY_SIZE
argument_list|(
name|digits
argument_list|)
operator|-
literal|3
index|]
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|p
operator|=
name|hexdigits
index|[
name|value
operator|&
literal|4
index|]
expr_stmt|;
name|value
operator|>>=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|value
operator|==
literal|0
condition|)
do|;
name|fputs
argument_list|(
name|p
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffetarget_real1 -- Convert token to a single-precision real number     See prototype.     Pass NULL for any token not provided by the user, but a valid Fortran    real number must be provided somehow.  For example, it is ok for    exponent_sign_token and exponent_digits_token to be NULL as long as    exponent_token not only starts with "E" or "e" but also contains at least    one digit following it.  Token use counts not affected overall.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okREAL1
end_if

begin_function
name|bool
name|ffetarget_real1
parameter_list|(
name|ffetargetReal1
modifier|*
name|value
parameter_list|,
name|ffelexToken
name|integer
parameter_list|,
name|ffelexToken
name|decimal
parameter_list|,
name|ffelexToken
name|fraction
parameter_list|,
name|ffelexToken
name|exponent
parameter_list|,
name|ffelexToken
name|exponent_sign
parameter_list|,
name|ffelexToken
name|exponent_digits
parameter_list|)
block|{
name|size_t
name|sz
init|=
literal|1
decl_stmt|;
comment|/* Allow room for '\0' byte at end. */
name|char
modifier|*
name|ptr
init|=
operator|&
name|ffetarget_string_
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|ptr
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
define|#
directive|define
name|dotok
parameter_list|(
name|x
parameter_list|)
value|if (x != NULL) ++sz;
define|#
directive|define
name|dotoktxt
parameter_list|(
name|x
parameter_list|)
value|if (x != NULL) sz += ffelex_token_length(x)
name|dotoktxt
argument_list|(
name|integer
argument_list|)
expr_stmt|;
name|dotok
argument_list|(
name|decimal
argument_list|)
expr_stmt|;
name|dotoktxt
argument_list|(
name|fraction
argument_list|)
expr_stmt|;
name|dotoktxt
argument_list|(
name|exponent
argument_list|)
expr_stmt|;
name|dotok
argument_list|(
name|exponent_sign
argument_list|)
expr_stmt|;
name|dotoktxt
argument_list|(
name|exponent_digits
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dotok
undef|#
directive|undef
name|dotoktxt
if|if
condition|(
name|sz
operator|>
name|ARRAY_SIZE
argument_list|(
name|ffetarget_string_
argument_list|)
condition|)
name|p
operator|=
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc_new_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"ffetarget_real1"
argument_list|,
name|sz
argument_list|)
expr_stmt|;
define|#
directive|define
name|dotoktxt
parameter_list|(
name|x
parameter_list|)
value|if (x != NULL)				   \ 		  {						   \ 		  for (q = ffelex_token_text(x); *q != '\0'; ++q)  \ 		    *p++ = *q;					   \ 		  }
name|dotoktxt
argument_list|(
name|integer
argument_list|)
expr_stmt|;
if|if
condition|(
name|decimal
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
name|dotoktxt
argument_list|(
name|fraction
argument_list|)
expr_stmt|;
name|dotoktxt
argument_list|(
name|exponent
argument_list|)
expr_stmt|;
if|if
condition|(
name|exponent_sign
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|exponent_sign
argument_list|)
operator|==
name|FFELEX_typePLUS
condition|)
operator|*
name|p
operator|++
operator|=
literal|'+'
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|exponent_sign
argument_list|)
operator|==
name|FFELEX_typeMINUS
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
block|}
name|dotoktxt
argument_list|(
name|exponent_digits
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dotoktxt
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|ffetarget_make_real1
argument_list|(
name|value
argument_list|,
name|FFETARGET_ATOF_
argument_list|(
name|ptr
argument_list|,
name|SFmode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|ARRAY_SIZE
argument_list|(
name|ffetarget_string_
argument_list|)
condition|)
name|malloc_kill_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
name|ptr
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffetarget_real2 -- Convert token to a single-precision real number     See prototype.     Pass NULL for any token not provided by the user, but a valid Fortran    real number must be provided somehow.  For example, it is ok for    exponent_sign_token and exponent_digits_token to be NULL as long as    exponent_token not only starts with "E" or "e" but also contains at least    one digit following it.  Token use counts not affected overall.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okREAL2
end_if

begin_function
name|bool
name|ffetarget_real2
parameter_list|(
name|ffetargetReal2
modifier|*
name|value
parameter_list|,
name|ffelexToken
name|integer
parameter_list|,
name|ffelexToken
name|decimal
parameter_list|,
name|ffelexToken
name|fraction
parameter_list|,
name|ffelexToken
name|exponent
parameter_list|,
name|ffelexToken
name|exponent_sign
parameter_list|,
name|ffelexToken
name|exponent_digits
parameter_list|)
block|{
name|size_t
name|sz
init|=
literal|1
decl_stmt|;
comment|/* Allow room for '\0' byte at end. */
name|char
modifier|*
name|ptr
init|=
operator|&
name|ffetarget_string_
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|ptr
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
define|#
directive|define
name|dotok
parameter_list|(
name|x
parameter_list|)
value|if (x != NULL) ++sz;
define|#
directive|define
name|dotoktxt
parameter_list|(
name|x
parameter_list|)
value|if (x != NULL) sz += ffelex_token_length(x)
name|dotoktxt
argument_list|(
name|integer
argument_list|)
expr_stmt|;
name|dotok
argument_list|(
name|decimal
argument_list|)
expr_stmt|;
name|dotoktxt
argument_list|(
name|fraction
argument_list|)
expr_stmt|;
name|dotoktxt
argument_list|(
name|exponent
argument_list|)
expr_stmt|;
name|dotok
argument_list|(
name|exponent_sign
argument_list|)
expr_stmt|;
name|dotoktxt
argument_list|(
name|exponent_digits
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dotok
undef|#
directive|undef
name|dotoktxt
if|if
condition|(
name|sz
operator|>
name|ARRAY_SIZE
argument_list|(
name|ffetarget_string_
argument_list|)
condition|)
name|p
operator|=
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc_new_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"ffetarget_real1"
argument_list|,
name|sz
argument_list|)
expr_stmt|;
define|#
directive|define
name|dotoktxt
parameter_list|(
name|x
parameter_list|)
value|if (x != NULL)				   \ 		  {						   \ 		  for (q = ffelex_token_text(x); *q != '\0'; ++q)  \ 		    *p++ = *q;					   \ 		  }
define|#
directive|define
name|dotoktxtexp
parameter_list|(
name|x
parameter_list|)
value|if (x != NULL)				       \ 		  {						       \ 		  *p++ = 'E';					       \ 		  for (q = ffelex_token_text(x) + 1; *q != '\0'; ++q)  \ 		    *p++ = *q;					       \ 		  }
name|dotoktxt
argument_list|(
name|integer
argument_list|)
expr_stmt|;
if|if
condition|(
name|decimal
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
name|dotoktxt
argument_list|(
name|fraction
argument_list|)
expr_stmt|;
name|dotoktxtexp
argument_list|(
name|exponent
argument_list|)
expr_stmt|;
if|if
condition|(
name|exponent_sign
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|exponent_sign
argument_list|)
operator|==
name|FFELEX_typePLUS
condition|)
operator|*
name|p
operator|++
operator|=
literal|'+'
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|exponent_sign
argument_list|)
operator|==
name|FFELEX_typeMINUS
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
block|}
name|dotoktxt
argument_list|(
name|exponent_digits
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dotoktxt
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|ffetarget_make_real2
argument_list|(
name|value
argument_list|,
name|FFETARGET_ATOF_
argument_list|(
name|ptr
argument_list|,
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|ARRAY_SIZE
argument_list|(
name|ffetarget_string_
argument_list|)
condition|)
name|malloc_kill_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
name|ptr
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|bool
name|ffetarget_typeless_binary
parameter_list|(
name|ffetargetTypeless
modifier|*
name|xvalue
parameter_list|,
name|ffelexToken
name|token
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|ffetargetTypeless
name|value
init|=
literal|0
decl_stmt|;
name|ffetargetTypeless
name|new_value
init|=
literal|0
decl_stmt|;
name|bool
name|bad_digit
init|=
name|FALSE
decl_stmt|;
name|bool
name|overflow
init|=
name|FALSE
decl_stmt|;
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|token
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|p
init|;
name|c
operator|!=
literal|'\0'
condition|;
name|c
operator|=
operator|*
operator|++
name|p
control|)
block|{
name|new_value
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|new_value
operator|>>
literal|1
operator|)
operator|!=
name|value
condition|)
name|overflow
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|new_value
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
else|else
name|bad_digit
operator|=
name|TRUE
expr_stmt|;
name|value
operator|=
name|new_value
expr_stmt|;
block|}
if|if
condition|(
name|bad_digit
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INVALID_TYPELESS_BINARY_DIGIT
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|overflow
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_TYPELESS_OVERFLOW
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
operator|*
name|xvalue
operator|=
name|value
expr_stmt|;
return|return
operator|!
name|bad_digit
operator|&&
operator|!
name|overflow
return|;
block|}
end_function

begin_function
name|bool
name|ffetarget_typeless_octal
parameter_list|(
name|ffetargetTypeless
modifier|*
name|xvalue
parameter_list|,
name|ffelexToken
name|token
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|ffetargetTypeless
name|value
init|=
literal|0
decl_stmt|;
name|ffetargetTypeless
name|new_value
init|=
literal|0
decl_stmt|;
name|bool
name|bad_digit
init|=
name|FALSE
decl_stmt|;
name|bool
name|overflow
init|=
name|FALSE
decl_stmt|;
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|token
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|p
init|;
name|c
operator|!=
literal|'\0'
condition|;
name|c
operator|=
operator|*
operator|++
name|p
control|)
block|{
name|new_value
operator|<<=
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|new_value
operator|>>
literal|3
operator|)
operator|!=
name|value
condition|)
name|overflow
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|new_value
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
else|else
name|bad_digit
operator|=
name|TRUE
expr_stmt|;
name|value
operator|=
name|new_value
expr_stmt|;
block|}
if|if
condition|(
name|bad_digit
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INVALID_TYPELESS_OCTAL_DIGIT
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|overflow
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_TYPELESS_OVERFLOW
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
operator|*
name|xvalue
operator|=
name|value
expr_stmt|;
return|return
operator|!
name|bad_digit
operator|&&
operator|!
name|overflow
return|;
block|}
end_function

begin_function
name|bool
name|ffetarget_typeless_hex
parameter_list|(
name|ffetargetTypeless
modifier|*
name|xvalue
parameter_list|,
name|ffelexToken
name|token
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|ffetargetTypeless
name|value
init|=
literal|0
decl_stmt|;
name|ffetargetTypeless
name|new_value
init|=
literal|0
decl_stmt|;
name|bool
name|bad_digit
init|=
name|FALSE
decl_stmt|;
name|bool
name|overflow
init|=
name|FALSE
decl_stmt|;
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|token
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|p
init|;
name|c
operator|!=
literal|'\0'
condition|;
name|c
operator|=
operator|*
operator|++
name|p
control|)
block|{
name|new_value
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|new_value
operator|>>
literal|4
operator|)
operator|!=
name|value
condition|)
name|overflow
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|hex_p
argument_list|(
name|c
argument_list|)
condition|)
name|new_value
operator|+=
name|hex_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|bad_digit
operator|=
name|TRUE
expr_stmt|;
name|value
operator|=
name|new_value
expr_stmt|;
block|}
if|if
condition|(
name|bad_digit
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INVALID_TYPELESS_HEX_DIGIT
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|overflow
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_TYPELESS_OVERFLOW
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
operator|*
name|xvalue
operator|=
name|value
expr_stmt|;
return|return
operator|!
name|bad_digit
operator|&&
operator|!
name|overflow
return|;
block|}
end_function

begin_function
name|void
name|ffetarget_verify_character1
parameter_list|(
name|mallocPool
name|pool
parameter_list|,
name|ffetargetCharacter1
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|.
name|length
operator|!=
literal|0
condition|)
name|malloc_verify_kp
argument_list|(
name|pool
argument_list|,
name|val
operator|.
name|text
argument_list|,
name|val
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is like memcpy.	 It is needed because some systems' header files    don't declare memcpy as a function but instead    "#define memcpy(to,from,len) something".  */
end_comment

begin_function
name|void
modifier|*
name|ffetarget_memcpy_
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CROSS_COMPILE
name|int
name|host_words_big_endian
init|=
ifndef|#
directive|ifndef
name|HOST_WORDS_BIG_ENDIAN
literal|0
else|#
directive|else
name|HOST_WORDS_BIG_ENDIAN
endif|#
directive|endif
decl_stmt|;
name|int
name|host_bytes_big_endian
init|=
ifndef|#
directive|ifndef
name|HOST_BYTES_BIG_ENDIAN
literal|0
else|#
directive|else
name|HOST_BYTES_BIG_ENDIAN
endif|#
directive|endif
decl_stmt|;
name|int
name|host_bits_big_endian
init|=
ifndef|#
directive|ifndef
name|HOST_BITS_BIG_ENDIAN
literal|0
else|#
directive|else
name|HOST_BITS_BIG_ENDIAN
endif|#
directive|endif
decl_stmt|;
comment|/* This is just hands thrown up in the air over bits coming through this      function representing a number being memcpy:d as-is from host to      target.  We can't generally adjust endianness here since we don't      know whether it's an integer or floating point number; they're passed      differently.  Better to not emit code at all than to emit wrong code.      We will get some false hits because some data coming through here      seems to be just character vectors, but often enough it's numbers,      for instance in g77.f-torture/execute/980628-[4-6].f and alpha2.f.      Still, we compile *some* code.  FIXME: Rewrite handling of numbers.  */
if|if
condition|(
operator|!
name|WORDS_BIG_ENDIAN
operator|!=
operator|!
name|host_words_big_endian
operator|||
operator|!
name|BYTES_BIG_ENDIAN
operator|!=
operator|!
name|host_bytes_big_endian
operator|||
operator|!
name|BITS_BIG_ENDIAN
operator|!=
operator|!
name|host_bits_big_endian
condition|)
name|sorry
argument_list|(
literal|"data initializer on host with different endianness"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CROSS_COMPILE */
return|return
operator|(
name|void
operator|*
operator|)
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffetarget_num_digits_ -- Determine number of non-space characters in token     ffetarget_num_digits_(token);     All non-spaces are assumed to be binary, octal, or hex digits.  */
end_comment

begin_function
name|int
name|ffetarget_num_digits_
parameter_list|(
name|ffelexToken
name|token
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|token
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNUMBER
case|:
return|return
name|ffelex_token_length
argument_list|(
name|token
argument_list|)
return|;
case|case
name|FFELEX_typeCHARACTER
case|:
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|ffelex_token_text
argument_list|(
name|token
argument_list|)
init|;
operator|*
name|c
operator|!=
literal|'\0'
condition|;
operator|++
name|c
control|)
block|{
if|if
condition|(
operator|*
name|c
operator|!=
literal|' '
condition|)
operator|++
name|i
expr_stmt|;
block|}
return|return
name|i
return|;
default|default:
name|assert
argument_list|(
literal|"weird token"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

end_unit

