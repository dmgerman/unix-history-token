begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ste.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995, 1996 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       ste.c     Description:       Implements the various statements and such like.     Modifications: */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_include
include|#
directive|include
file|"rtl.j"
end_include

begin_include
include|#
directive|include
file|"toplev.j"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ste.h"
end_include

begin_include
include|#
directive|include
file|"bld.h"
end_include

begin_include
include|#
directive|include
file|"com.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"lab.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"sta.h"
end_include

begin_include
include|#
directive|include
file|"stp.h"
end_include

begin_include
include|#
directive|include
file|"str.h"
end_include

begin_include
include|#
directive|include
file|"sts.h"
end_include

begin_include
include|#
directive|include
file|"stt.h"
end_include

begin_include
include|#
directive|include
file|"stv.h"
end_include

begin_include
include|#
directive|include
file|"stw.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|FFESTE_stateletSIMPLE_
block|,
comment|/* Expecting simple/start. */
name|FFESTE_stateletATTRIB_
block|,
comment|/* Expecting attrib/item/itemstart. */
name|FFESTE_stateletITEM_
block|,
comment|/* Expecting item/itemstart/finish. */
name|FFESTE_stateletITEMVALS_
block|,
comment|/* Expecting itemvalue/itemendvals. */
name|FFESTE_
block|}
name|ffesteStatelet_
typedef|;
end_typedef

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_decl_stmt
specifier|static
name|ffesteStatelet_
name|ffeste_statelet_
init|=
name|FFESTE_stateletSIMPLE_
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_decl_stmt
specifier|static
name|ffelab
name|ffeste_label_formatdef_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|tree
function_decl|(
modifier|*
name|ffeste_io_driver_
function_decl|)
parameter_list|(
name|ffebld
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* do?io. */
end_comment

begin_decl_stmt
specifier|static
name|ffecomGfrt
name|ffeste_io_endgfrt_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end function to call. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|ffeste_io_abort_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* abort-io label or NULL_TREE. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffeste_io_abort_is_temp_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* abort-io label is a temp. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|ffeste_io_end_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* END= label or NULL_TREE. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|ffeste_io_err_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ERR= label or NULL_TREE. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|ffeste_io_iostat_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IOSTAT= var or NULL_TREE. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffeste_io_iostat_is_temp_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IOSTAT= var is a temp. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_function_decl
specifier|static
name|void
name|ffeste_begin_iterdo_
parameter_list|(
name|ffestw
name|block
parameter_list|,
name|tree
modifier|*
name|tvar
parameter_list|,
name|tree
modifier|*
name|tincr
parameter_list|,
name|tree
modifier|*
name|xitersvar
parameter_list|,
name|ffebld
name|var
parameter_list|,
name|ffebld
name|start
parameter_list|,
name|ffelexToken
name|start_token
parameter_list|,
name|ffebld
name|end
parameter_list|,
name|ffelexToken
name|end_token
parameter_list|,
name|ffebld
name|incr
parameter_list|,
name|ffelexToken
name|incr_token
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeste_end_iterdo_
parameter_list|(
name|ffestw
name|block
parameter_list|,
name|tree
name|tvar
parameter_list|,
name|tree
name|tincr
parameter_list|,
name|tree
name|itersvar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeste_io_call_
parameter_list|(
name|tree
name|call
parameter_list|,
name|bool
name|do_check
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeste_io_impdo_
parameter_list|(
name|ffebld
name|impdo
parameter_list|,
name|ffelexToken
name|impdo_token
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffeste_io_dofio_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffeste_io_dolio_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffeste_io_douio_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffeste_io_ialist_
parameter_list|(
name|bool
name|have_err
parameter_list|,
name|ffestvUnit
name|unit
parameter_list|,
name|ffebld
name|unit_expr
parameter_list|,
name|int
name|unit_dflt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffeste_io_cilist_
parameter_list|(
name|bool
name|have_err
parameter_list|,
name|ffestvUnit
name|unit
parameter_list|,
name|ffebld
name|unit_expr
parameter_list|,
name|int
name|unit_dflt
parameter_list|,
name|bool
name|have_end
parameter_list|,
name|ffestvFormat
name|format
parameter_list|,
name|ffestpFile
modifier|*
name|format_spec
parameter_list|,
name|bool
name|rec
parameter_list|,
name|ffebld
name|rec_expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffeste_io_cllist_
parameter_list|(
name|bool
name|have_err
parameter_list|,
name|ffebld
name|unit_expr
parameter_list|,
name|ffestpFile
modifier|*
name|stat_spec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffeste_io_icilist_
parameter_list|(
name|bool
name|have_err
parameter_list|,
name|ffebld
name|unit_expr
parameter_list|,
name|bool
name|have_end
parameter_list|,
name|ffestvFormat
name|format
parameter_list|,
name|ffestpFile
modifier|*
name|format_spec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffeste_io_inlist_
parameter_list|(
name|bool
name|have_err
parameter_list|,
name|ffestpFile
modifier|*
name|unit_spec
parameter_list|,
name|ffestpFile
modifier|*
name|file_spec
parameter_list|,
name|ffestpFile
modifier|*
name|exist_spec
parameter_list|,
name|ffestpFile
modifier|*
name|open_spec
parameter_list|,
name|ffestpFile
modifier|*
name|number_spec
parameter_list|,
name|ffestpFile
modifier|*
name|named_spec
parameter_list|,
name|ffestpFile
modifier|*
name|name_spec
parameter_list|,
name|ffestpFile
modifier|*
name|access_spec
parameter_list|,
name|ffestpFile
modifier|*
name|sequential_spec
parameter_list|,
name|ffestpFile
modifier|*
name|direct_spec
parameter_list|,
name|ffestpFile
modifier|*
name|form_spec
parameter_list|,
name|ffestpFile
modifier|*
name|formatted_spec
parameter_list|,
name|ffestpFile
modifier|*
name|unformatted_spec
parameter_list|,
name|ffestpFile
modifier|*
name|recl_spec
parameter_list|,
name|ffestpFile
modifier|*
name|nextrec_spec
parameter_list|,
name|ffestpFile
modifier|*
name|blank_spec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffeste_io_olist_
parameter_list|(
name|bool
name|have_err
parameter_list|,
name|ffebld
name|unit_expr
parameter_list|,
name|ffestpFile
modifier|*
name|file_spec
parameter_list|,
name|ffestpFile
modifier|*
name|stat_spec
parameter_list|,
name|ffestpFile
modifier|*
name|access_spec
parameter_list|,
name|ffestpFile
modifier|*
name|form_spec
parameter_list|,
name|ffestpFile
modifier|*
name|recl_spec
parameter_list|,
name|ffestpFile
modifier|*
name|blank_spec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeste_subr_beru_
parameter_list|(
name|ffestpBeruStmt
modifier|*
name|info
parameter_list|,
name|ffecomGfrt
name|rt
parameter_list|)
function_decl|;
end_function_decl

begin_elif
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
end_elif

begin_function_decl
specifier|static
name|void
name|ffeste_subr_file_
parameter_list|(
specifier|const
name|char
modifier|*
name|kw
parameter_list|,
name|ffestpFile
modifier|*
name|spec
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Internal macros. */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_define
define|#
directive|define
name|ffeste_emit_line_note_
parameter_list|()
define|\
value|emit_line_note (input_filename, lineno)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ffeste_check_simple_
parameter_list|()
define|\
value|assert(ffeste_statelet_ == FFESTE_stateletSIMPLE_)
end_define

begin_define
define|#
directive|define
name|ffeste_check_start_
parameter_list|()
define|\
value|assert(ffeste_statelet_ == FFESTE_stateletSIMPLE_); \   ffeste_statelet_ = FFESTE_stateletATTRIB_
end_define

begin_define
define|#
directive|define
name|ffeste_check_attrib_
parameter_list|()
define|\
value|assert(ffeste_statelet_ == FFESTE_stateletATTRIB_)
end_define

begin_define
define|#
directive|define
name|ffeste_check_item_
parameter_list|()
define|\
value|assert(ffeste_statelet_ == FFESTE_stateletATTRIB_	 \ 	 || ffeste_statelet_ == FFESTE_stateletITEM_); \   ffeste_statelet_ = FFESTE_stateletITEM_
end_define

begin_define
define|#
directive|define
name|ffeste_check_item_startvals_
parameter_list|()
define|\
value|assert(ffeste_statelet_ == FFESTE_stateletATTRIB_	 \ 	 || ffeste_statelet_ == FFESTE_stateletITEM_); \   ffeste_statelet_ = FFESTE_stateletITEMVALS_
end_define

begin_define
define|#
directive|define
name|ffeste_check_item_value_
parameter_list|()
define|\
value|assert(ffeste_statelet_ == FFESTE_stateletITEMVALS_)
end_define

begin_define
define|#
directive|define
name|ffeste_check_item_endvals_
parameter_list|()
define|\
value|assert(ffeste_statelet_ == FFESTE_stateletITEMVALS_); \   ffeste_statelet_ = FFESTE_stateletITEM_
end_define

begin_define
define|#
directive|define
name|ffeste_check_finish_
parameter_list|()
define|\
value|assert(ffeste_statelet_ == FFESTE_stateletATTRIB_	 \ 	 || ffeste_statelet_ == FFESTE_stateletITEM_); \   ffeste_statelet_ = FFESTE_stateletSIMPLE_
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_init_charnolen_
parameter_list|(
name|Exp
parameter_list|,
name|Init
parameter_list|,
name|Spec
parameter_list|)
define|\
value|do									      \     {									      \       if ((Spec)->kw_or_val_present)					      \ 	Exp = ffecom_arg_ptr_to_const_expr ((Spec)->u.expr,&ignore);	      \       else								      \ 	Exp = null_pointer_node;					      \       if (Exp)								      \ 	Init = Exp;							      \       else								      \ 	{								      \ 	  Init = null_pointer_node;					      \ 	  constantp = FALSE;						      \ 	}								      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_init_char_
parameter_list|(
name|Exp
parameter_list|,
name|Init
parameter_list|,
name|Lenexp
parameter_list|,
name|Leninit
parameter_list|,
name|Spec
parameter_list|)
define|\
value|do									      \     {									      \       if ((Spec)->kw_or_val_present)					      \ 	Exp = ffecom_arg_ptr_to_const_expr ((Spec)->u.expr,&Lenexp);	      \       else								      \ 	{								      \ 	  Exp = null_pointer_node;					      \ 	  Lenexp = ffecom_f2c_ftnlen_zero_node;				      \ 	}								      \       if (Exp)								      \ 	Init = Exp;							      \       else								      \ 	{								      \ 	  Init = null_pointer_node;					      \ 	  constantp = FALSE;						      \ 	}								      \       if (Lenexp)							      \ 	Leninit = Lenexp;						      \       else								      \ 	{								      \ 	  Leninit = ffecom_f2c_ftnlen_zero_node;			      \ 	  constantp = FALSE;						      \ 	}								      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_init_flag_
parameter_list|(
name|Flag
parameter_list|,
name|Init
parameter_list|)
define|\
value|do									      \     {									      \       Init = convert (ffecom_f2c_flag_type_node,			      \ 		      (Flag) ? integer_one_node : integer_zero_node);	      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_init_format_
parameter_list|(
name|Exp
parameter_list|,
name|Init
parameter_list|,
name|Spec
parameter_list|)
define|\
value|do									      \     {									      \       Exp = ffecom_arg_ptr_to_const_expr ((Spec)->u.expr, NULL);	      \       if (Exp)								      \ 	Init = Exp;							      \       else								      \ 	{								      \ 	  Init = null_pointer_node;					      \ 	  constantp = FALSE;						      \ 	}								      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_init_int_
parameter_list|(
name|Exp
parameter_list|,
name|Init
parameter_list|,
name|Spec
parameter_list|)
define|\
value|do									      \     {									      \       if ((Spec)->kw_or_val_present)					      \ 	Exp = ffecom_const_expr ((Spec)->u.expr);			      \       else								      \ 	Exp = ffecom_integer_zero_node;					      \       if (Exp)								      \ 	Init = Exp;							      \       else								      \ 	{								      \ 	  Init = ffecom_integer_zero_node;				      \ 	  constantp = FALSE;						      \ 	}								      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_init_ptrtoint_
parameter_list|(
name|Exp
parameter_list|,
name|Init
parameter_list|,
name|Spec
parameter_list|)
define|\
value|do									      \     {									      \       if ((Spec)->kw_or_val_present)					      \ 	Exp = ffecom_ptr_to_const_expr ((Spec)->u.expr);		      \       else								      \ 	Exp = null_pointer_node;					      \       if (Exp)								      \ 	Init = Exp;							      \       else								      \ 	{								      \ 	  Init = null_pointer_node;					      \ 	  constantp = FALSE;						      \ 	}								      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_init_next_
parameter_list|(
name|Init
parameter_list|)
define|\
value|do									      \     {									      \       TREE_CHAIN (initn) = build_tree_list ((field = TREE_CHAIN (field)),     \ 					    (Init));			      \       initn = TREE_CHAIN(initn);					      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_prepare_charnolen_
parameter_list|(
name|Spec
parameter_list|,
name|Exp
parameter_list|)
define|\
value|do									      \     {									      \       if (! (Exp))							      \         ffecom_prepare_arg_ptr_to_expr ((Spec)->u.expr);		      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_prepare_char_
parameter_list|(
name|Spec
parameter_list|,
name|Exp
parameter_list|)
define|\
value|do									      \     {									      \       if (! (Exp))							      \         ffecom_prepare_arg_ptr_to_expr ((Spec)->u.expr);		      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_prepare_format_
parameter_list|(
name|Spec
parameter_list|,
name|Exp
parameter_list|)
define|\
value|do									      \     {									      \       if (! (Exp))							      \         ffecom_prepare_arg_ptr_to_expr ((Spec)->u.expr);		      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_prepare_int_
parameter_list|(
name|Spec
parameter_list|,
name|Exp
parameter_list|)
define|\
value|do									      \     {									      \       if (! (Exp))							      \         ffecom_prepare_expr ((Spec)->u.expr);				      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_prepare_ptrtoint_
parameter_list|(
name|Spec
parameter_list|,
name|Exp
parameter_list|)
define|\
value|do									      \     {									      \       if (! (Exp))							      \         ffecom_prepare_ptr_to_expr ((Spec)->u.expr);			      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_compile_
parameter_list|(
name|Field
parameter_list|,
name|Exp
parameter_list|)
define|\
value|do									      \     {									      \       tree exz;								      \       if ((Exp))							      \ 	{								      \ 	  exz = ffecom_modify (void_type_node,				      \ 			       ffecom_2 (COMPONENT_REF, TREE_TYPE (Field),    \ 					 t, (Field)),			      \ 			       (Exp));					      \ 	  expand_expr_stmt (exz);					      \ 	}								      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_compile_charnolen_
parameter_list|(
name|Field
parameter_list|,
name|Spec
parameter_list|,
name|Exp
parameter_list|)
define|\
value|do									      \     {									      \       tree exq;								      \       if (! (Exp))							      \ 	{								      \ 	  exq = ffecom_arg_ptr_to_expr ((Spec)->u.expr,&ignore);	      \ 	  ffeste_f2c_compile_ ((Field), exq);				      \ 	}								      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_compile_char_
parameter_list|(
name|Field
parameter_list|,
name|Lenfield
parameter_list|,
name|Spec
parameter_list|,
name|Exp
parameter_list|,
name|Lenexp
parameter_list|)
define|\
value|do									      \     {									      \       tree exq = (Exp);							      \       tree lenexq = (Lenexp);						      \       int need_exq = (! exq);						      \       int need_lenexq = (! lenexq); 					      \       if (need_exq || need_lenexq)					      \ 	{								      \ 	  exq = ffecom_arg_ptr_to_expr ((Spec)->u.expr,&lenexq);	      \ 	  if (need_exq)							      \ 	    ffeste_f2c_compile_ ((Field), exq);				      \ 	  if (need_lenexq)						      \ 	    ffeste_f2c_compile_ ((Lenfield), lenexq);			      \ 	}								      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_compile_format_
parameter_list|(
name|Field
parameter_list|,
name|Spec
parameter_list|,
name|Exp
parameter_list|)
define|\
value|do									      \     {									      \       tree exq;								      \       if (! (Exp))							      \ 	{								      \ 	  exq = ffecom_arg_ptr_to_expr ((Spec)->u.expr, NULL);		      \ 	  ffeste_f2c_compile_ ((Field), exq);				      \ 	}								      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_compile_int_
parameter_list|(
name|Field
parameter_list|,
name|Spec
parameter_list|,
name|Exp
parameter_list|)
define|\
value|do									      \     {									      \       tree exq;								      \       if (! (Exp))							      \ 	{								      \ 	  exq = ffecom_expr ((Spec)->u.expr);				      \ 	  ffeste_f2c_compile_ ((Field), exq);				      \ 	}								      \     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_f2c_compile_ptrtoint_
parameter_list|(
name|Field
parameter_list|,
name|Spec
parameter_list|,
name|Exp
parameter_list|)
define|\
value|do									      \     {									      \       tree exq;								      \       if (! (Exp))							      \ 	{								      \ 	  exq = ffecom_ptr_to_expr ((Spec)->u.expr);			      \ 	  ffeste_f2c_compile_ ((Field), exq);				      \ 	}								      \     } while(0)
end_define

begin_escape
end_escape

begin_comment
comment|/* Start a Fortran block.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_typedef
typedef|typedef
struct|struct
name|gbe_block
block|{
name|struct
name|gbe_block
modifier|*
name|outer
decl_stmt|;
name|ffestw
name|block
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|char
modifier|*
name|input_filename
decl_stmt|;
name|bool
name|is_stmt
decl_stmt|;
block|}
typedef|*
name|gbe_block
typedef|;
end_typedef

begin_decl_stmt
name|gbe_block
name|ffeste_top_block_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ffeste_start_block_
parameter_list|(
name|ffestw
name|block
parameter_list|)
block|{
name|gbe_block
name|b
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|b
operator|->
name|outer
operator|=
name|ffeste_top_block_
expr_stmt|;
name|b
operator|->
name|block
operator|=
name|block
expr_stmt|;
name|b
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|b
operator|->
name|input_filename
operator|=
name|input_filename
expr_stmt|;
name|b
operator|->
name|is_stmt
operator|=
name|FALSE
expr_stmt|;
name|ffeste_top_block_
operator|=
name|b
expr_stmt|;
name|ffecom_start_compstmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End a Fortran block.  */
end_comment

begin_function
specifier|static
name|void
name|ffeste_end_block_
parameter_list|(
name|ffestw
name|block
parameter_list|)
block|{
name|gbe_block
name|b
init|=
name|ffeste_top_block_
decl_stmt|;
name|assert
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|b
operator|->
name|is_stmt
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|->
name|block
operator|==
name|block
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|b
operator|->
name|is_stmt
argument_list|)
expr_stmt|;
name|ffeste_top_block_
operator|=
name|b
operator|->
name|outer
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|clear_momentary
argument_list|()
expr_stmt|;
name|ffecom_end_compstmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a Fortran statement.     Starts a back-end block, so temporaries can be managed, clean-ups    properly handled, etc.  Nesting of statements *is* allowed -- the    handling of I/O items, even implied-DO I/O lists, within a READ,    PRINT, or WRITE statement is one example.  */
end_comment

begin_function
specifier|static
name|void
name|ffeste_start_stmt_
parameter_list|(
name|void
parameter_list|)
block|{
name|gbe_block
name|b
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|b
operator|->
name|outer
operator|=
name|ffeste_top_block_
expr_stmt|;
name|b
operator|->
name|block
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|b
operator|->
name|input_filename
operator|=
name|input_filename
expr_stmt|;
name|b
operator|->
name|is_stmt
operator|=
name|TRUE
expr_stmt|;
name|ffeste_top_block_
operator|=
name|b
expr_stmt|;
name|ffecom_start_compstmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End a Fortran statement.  */
end_comment

begin_function
specifier|static
name|void
name|ffeste_end_stmt_
parameter_list|(
name|void
parameter_list|)
block|{
name|gbe_block
name|b
init|=
name|ffeste_top_block_
decl_stmt|;
name|assert
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|->
name|is_stmt
argument_list|)
expr_stmt|;
name|ffeste_top_block_
operator|=
name|b
operator|->
name|outer
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|clear_momentary
argument_list|()
expr_stmt|;
name|ffecom_end_compstmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (ENABLE_CHECKING) */
end_comment

begin_define
define|#
directive|define
name|ffeste_start_block_
parameter_list|(
name|b
parameter_list|)
value|ffecom_start_compstmt ()
end_define

begin_define
define|#
directive|define
name|ffeste_end_block_
parameter_list|(
name|b
parameter_list|)
define|\
value|do				\     {				\       clear_momentary ();	\       ffecom_end_compstmt ();	\     } while(0)
end_define

begin_define
define|#
directive|define
name|ffeste_start_stmt_
parameter_list|()
value|ffeste_start_block_(NULL)
end_define

begin_define
define|#
directive|define
name|ffeste_end_stmt_
parameter_list|()
value|ffeste_end_block_(NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (ENABLE_CHECKING) */
end_comment

begin_comment
comment|/* Begin an iterative DO loop.  Pass the block to start if applicable.     NOTE: Does _two_ push_momentary () calls, which the caller must    undo (by calling ffeste_end_iterdo_).  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_function
specifier|static
name|void
name|ffeste_begin_iterdo_
parameter_list|(
name|ffestw
name|block
parameter_list|,
name|tree
modifier|*
name|xtvar
parameter_list|,
name|tree
modifier|*
name|xtincr
parameter_list|,
name|tree
modifier|*
name|xitersvar
parameter_list|,
name|ffebld
name|var
parameter_list|,
name|ffebld
name|start
parameter_list|,
name|ffelexToken
name|start_token
parameter_list|,
name|ffebld
name|end
parameter_list|,
name|ffelexToken
name|end_token
parameter_list|,
name|ffebld
name|incr
parameter_list|,
name|ffelexToken
name|incr_token
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|tree
name|tvar
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|tstart
decl_stmt|;
name|tree
name|tend
decl_stmt|;
name|tree
name|tincr
decl_stmt|;
name|tree
name|tincr_saved
decl_stmt|;
name|tree
name|niters
decl_stmt|;
name|struct
name|nesting
modifier|*
name|expanded_loop
decl_stmt|;
comment|/* Want to have tvar, tincr, and niters for the whole loop body. */
if|if
condition|(
name|block
condition|)
name|ffeste_start_block_
argument_list|(
name|block
argument_list|)
expr_stmt|;
else|else
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|niters
operator|=
name|ffecom_make_tempvar
argument_list|(
name|block
condition|?
literal|"do"
else|:
literal|"impdo"
argument_list|,
name|ffecom_integer_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ffecom_prepare_expr
argument_list|(
name|incr
argument_list|)
expr_stmt|;
name|ffecom_prepare_expr_rw
argument_list|(
name|NULL_TREE
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
name|tvar
operator|=
name|ffecom_expr_rw
argument_list|(
name|NULL_TREE
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|tincr
operator|=
name|ffecom_expr
argument_list|(
name|incr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tvar
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|tincr
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|block
condition|)
block|{
name|ffeste_end_block_
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|ffestw_set_do_tvar
argument_list|(
name|block
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
operator|*
name|xtvar
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return;
block|}
comment|/* Check whether incr is known to be zero, complain and fix.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|tincr
argument_list|)
operator|||
name|real_zerop
argument_list|(
name|tincr
argument_list|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DO_STEP_ZERO
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|incr_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|incr_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|tincr
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
block|}
name|tincr_saved
operator|=
name|ffecom_save_tree
argument_list|(
name|tincr
argument_list|)
expr_stmt|;
name|preserve_momentary
argument_list|()
expr_stmt|;
comment|/* Want to have tstart, tend for just this statement. */
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffecom_prepare_expr
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|ffecom_prepare_expr
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
name|tstart
operator|=
name|ffecom_expr
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|tend
operator|=
name|ffecom_expr
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tstart
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|tend
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
if|if
condition|(
name|block
condition|)
block|{
name|ffeste_end_block_
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|ffestw_set_do_tvar
argument_list|(
name|block
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
operator|*
name|xtvar
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return;
block|}
comment|/* For warnings only, nothing else happens here.  */
block|{
name|tree
name|try
decl_stmt|;
if|if
condition|(
operator|!
name|ffe_is_onetrip
argument_list|()
condition|)
block|{
name|try
operator|=
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
argument_list|,
name|tend
argument_list|,
name|tstart
argument_list|)
expr_stmt|;
name|try
operator|=
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
argument_list|,
name|try
argument_list|,
name|tincr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
name|try
operator|=
name|ffecom_2
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|try
argument_list|,
name|tincr
argument_list|)
expr_stmt|;
else|else
name|try
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
argument_list|,
name|try
argument_list|,
name|tincr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Warn if loop never executed, since we've done the evaluation 	   of the unofficial iteration count already.  */
name|try
operator|=
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|try
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_onep
argument_list|(
name|try
argument_list|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DO_NULL
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|start_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|start_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Warn if end plus incr would overflow.  */
name|try
operator|=
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
argument_list|,
name|tend
argument_list|,
name|tincr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|try
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|try
argument_list|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DO_END_OVERFLOW
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|end_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|end_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Do the initial assignment into the DO var.  */
name|tstart
operator|=
name|ffecom_save_tree
argument_list|(
name|tstart
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
argument_list|,
name|tend
argument_list|,
name|tstart
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffe_is_onetrip
argument_list|()
condition|)
block|{
name|expr
operator|=
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|tincr_saved
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
name|expr
operator|=
name|ffecom_2
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|,
name|tincr_saved
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|ffecom_2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|,
name|tincr_saved
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* New, F90-approved approach: convert to default INTEGER. */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|expr
operator|=
name|convert
argument_list|(
name|ffecom_integer_type_node
argument_list|,
name|expr
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Old approach; convert to INTEGER unless that's a narrowing. */
if|if
condition|(
operator|(
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
operator|!=
name|error_mark_node
operator|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|)
operator|||
operator|(
operator|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|||
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|ffecom_integer_type_node
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
comment|/* Convert unless promoting INTEGER type of any kind downward to        default INTEGER; else leave as, say, INTEGER*8 (long long int).  */
name|expr
operator|=
name|convert
argument_list|(
name|ffecom_integer_type_node
argument_list|,
name|expr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|niters
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|niters
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|tvar
argument_list|,
name|tstart
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
name|expanded_loop
operator|=
name|expand_start_loop_continue_elsewhere
argument_list|(
operator|!
operator|!
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
condition|)
name|ffestw_set_do_hook
argument_list|(
name|block
argument_list|,
name|expanded_loop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffe_is_onetrip
argument_list|()
condition|)
block|{
name|expr
operator|=
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|GE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|PREDECREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|niters
argument_list|)
argument_list|,
name|niters
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|niters
argument_list|)
argument_list|,
name|ffecom_integer_one_node
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|niters
argument_list|)
argument_list|,
name|ffecom_integer_zero_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_exit_loop_if_false
argument_list|(
literal|0
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|block
condition|)
block|{
name|ffestw_set_do_tvar
argument_list|(
name|block
argument_list|,
name|tvar
argument_list|)
expr_stmt|;
name|ffestw_set_do_incr_saved
argument_list|(
name|block
argument_list|,
name|tincr_saved
argument_list|)
expr_stmt|;
name|ffestw_set_do_count_var
argument_list|(
name|block
argument_list|,
name|niters
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|xtvar
operator|=
name|tvar
expr_stmt|;
operator|*
name|xtincr
operator|=
name|tincr_saved
expr_stmt|;
operator|*
name|xitersvar
operator|=
name|niters
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* End an iterative DO loop.  Pass the same iteration variable and increment    value trees that were generated in the paired _begin_ call.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_function
specifier|static
name|void
name|ffeste_end_iterdo_
parameter_list|(
name|ffestw
name|block
parameter_list|,
name|tree
name|tvar
parameter_list|,
name|tree
name|tincr
parameter_list|,
name|tree
name|itersvar
parameter_list|)
block|{
name|tree
name|expr
decl_stmt|;
name|tree
name|niters
init|=
name|itersvar
decl_stmt|;
if|if
condition|(
name|tvar
operator|==
name|error_mark_node
condition|)
return|return;
name|expand_loop_continue_here
argument_list|()
expr_stmt|;
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffe_is_onetrip
argument_list|()
condition|)
block|{
name|expr
operator|=
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|GE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|PREDECREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|niters
argument_list|)
argument_list|,
name|niters
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|niters
argument_list|)
argument_list|,
name|ffecom_integer_one_node
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|niters
argument_list|)
argument_list|,
name|ffecom_integer_zero_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_exit_loop_if_false
argument_list|(
literal|0
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|tvar
argument_list|,
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tvar
argument_list|)
argument_list|,
name|tvar
argument_list|,
name|tincr
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Lose the stuff we just built. */
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
comment|/* Lose the tvar and incr_saved trees. */
if|if
condition|(
name|block
condition|)
name|ffeste_end_block_
argument_list|(
name|block
argument_list|)
expr_stmt|;
else|else
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generate call to run-time I/O routine.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_function
specifier|static
name|void
name|ffeste_io_call_
parameter_list|(
name|tree
name|call
parameter_list|,
name|bool
name|do_check
parameter_list|)
block|{
comment|/* Generate the call and optional assignment into iostat var. */
name|TREE_SIDE_EFFECTS
argument_list|(
name|call
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ffeste_io_iostat_
operator|!=
name|NULL_TREE
condition|)
name|call
operator|=
name|ffecom_modify
argument_list|(
name|do_check
condition|?
name|NULL_TREE
else|:
name|void_type_node
argument_list|,
name|ffeste_io_iostat_
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_check
operator|||
name|ffeste_io_abort_
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|ffeste_io_abort_
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* Generate optional test. */
name|expand_start_cond
argument_list|(
name|ffecom_truth_value
argument_list|(
name|ffeste_io_iostat_
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_goto
argument_list|(
name|ffeste_io_abort_
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle implied-DO in I/O list.     Expands code to start up the DO loop.  Then for each item in the    DO loop, handles appropriately (possibly including recursively calling    itself).  Then expands code to end the DO loop.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_function
specifier|static
name|void
name|ffeste_io_impdo_
parameter_list|(
name|ffebld
name|impdo
parameter_list|,
name|ffelexToken
name|impdo_token
parameter_list|)
block|{
name|ffebld
name|var
init|=
name|ffebld_head
argument_list|(
name|ffebld_right
argument_list|(
name|impdo
argument_list|)
argument_list|)
decl_stmt|;
name|ffebld
name|start
init|=
name|ffebld_head
argument_list|(
name|ffebld_trail
argument_list|(
name|ffebld_right
argument_list|(
name|impdo
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ffebld
name|end
init|=
name|ffebld_head
argument_list|(
name|ffebld_trail
argument_list|(
name|ffebld_trail
argument_list|(
name|ffebld_right
argument_list|(
name|impdo
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ffebld
name|incr
init|=
name|ffebld_head
argument_list|(
name|ffebld_trail
argument_list|(
name|ffebld_trail
argument_list|(
name|ffebld_trail
argument_list|(
name|ffebld_right
argument_list|(
name|impdo
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ffebld
name|list
decl_stmt|;
name|ffebld
name|item
decl_stmt|;
name|tree
name|tvar
decl_stmt|;
name|tree
name|tincr
decl_stmt|;
name|tree
name|titervar
decl_stmt|;
if|if
condition|(
name|incr
operator|==
name|NULL
condition|)
block|{
name|incr
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_integerdefault_val
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|incr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Start the DO loop.  */
name|start
operator|=
name|ffeexpr_convert_expr
argument_list|(
name|start
argument_list|,
name|impdo_token
argument_list|,
name|var
argument_list|,
name|impdo_token
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|end
operator|=
name|ffeexpr_convert_expr
argument_list|(
name|end
argument_list|,
name|impdo_token
argument_list|,
name|var
argument_list|,
name|impdo_token
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|incr
operator|=
name|ffeexpr_convert_expr
argument_list|(
name|incr
argument_list|,
name|impdo_token
argument_list|,
name|var
argument_list|,
name|impdo_token
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|ffeste_begin_iterdo_
argument_list|(
name|NULL
argument_list|,
operator|&
name|tvar
argument_list|,
operator|&
name|tincr
argument_list|,
operator|&
name|titervar
argument_list|,
name|var
argument_list|,
name|start
argument_list|,
name|impdo_token
argument_list|,
name|end
argument_list|,
name|impdo_token
argument_list|,
name|incr
argument_list|,
name|impdo_token
argument_list|,
literal|"Implied DO loop"
argument_list|)
expr_stmt|;
comment|/* Handle the list of items.  */
for|for
control|(
name|list
operator|=
name|ffebld_left
argument_list|(
name|impdo
argument_list|)
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
name|item
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Strip parens off items such as in "READ *,(A)".  This is really a bug 	 in the user's code, but I've been told lots of code does this.  */
while|while
condition|(
name|ffebld_op
argument_list|(
name|item
argument_list|)
operator|==
name|FFEBLD_opPAREN
condition|)
name|item
operator|=
name|ffebld_left
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|item
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
continue|continue;
if|if
condition|(
name|ffebld_op
argument_list|(
name|item
argument_list|)
operator|==
name|FFEBLD_opIMPDO
condition|)
name|ffeste_io_impdo_
argument_list|(
name|item
argument_list|,
name|impdo_token
argument_list|)
expr_stmt|;
else|else
block|{
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffecom_prepare_arg_ptr_to_expr
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
name|ffeste_io_call_
argument_list|(
call|(
modifier|*
name|ffeste_io_driver_
call|)
argument_list|(
name|item
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Generate end of implied-do construct. */
name|ffeste_end_iterdo_
argument_list|(
name|NULL
argument_list|,
name|tvar
argument_list|,
name|tincr
argument_list|,
name|titervar
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I/O driver for formatted I/O item (do_fio)     Returns a tree for a CALL_EXPR to the do_fio function, which handles    a formatted I/O list item, along with the appropriate arguments for    the function.  It is up to the caller to set the TREE_SIDE_EFFECTS flag    for the CALL_EXPR, expand (emit) the expression, emit any assignment    of the result to an IOSTAT= variable, and emit any checking of the    result for errors.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_function
specifier|static
name|tree
name|ffeste_io_dofio_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|tree
name|num_elements
decl_stmt|;
name|tree
name|variable
decl_stmt|;
name|tree
name|size
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|bool
name|is_complex
decl_stmt|;
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bt
operator|==
name|FFEINFO_basictypeANY
operator|)
operator|||
operator|(
name|kt
operator|==
name|FFEINFO_kindtypeANY
operator|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCOMPLEX
condition|)
block|{
name|is_complex
operator|=
name|TRUE
expr_stmt|;
name|bt
operator|=
name|FFEINFO_basictypeREAL
expr_stmt|;
block|}
else|else
name|is_complex
operator|=
name|FALSE
expr_stmt|;
name|variable
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|expr
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|variable
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|size
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|size
operator|==
name|NULL_TREE
condition|)
comment|/* Already filled in for CHARACTER type. */
block|{
comment|/* "(ftnlen) sizeof(type)" */
name|size
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Assume that while it is possible that char * is wider than 	   ftnlen, no object in Fortran space can get big enough for its 	   size to be wider than ftnlen.  I really hope nobody wastes 	   time debugging a case where it can!  */
block|assert (TYPE_PRECISION (ffecom_f2c_ftnlen_type_node)>= TYPE_PRECISION (TREE_TYPE (size)));
endif|#
directive|endif
name|size
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffeinfo_rank
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|variable
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|num_elements
operator|=
name|is_complex
condition|?
name|ffecom_f2c_ftnlen_two_node
else|:
name|ffecom_f2c_ftnlen_one_node
expr_stmt|;
else|else
block|{
name|num_elements
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|variable
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|num_elements
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|num_elements
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|num_elements
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
block|}
name|num_elements
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ffecom_f2c_ptr_to_ftnlen_type_node
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
name|variable
operator|=
name|convert
argument_list|(
name|string_type_node
argument_list|,
name|variable
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|variable
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtDOFIO
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I/O driver for list-directed I/O item (do_lio)     Returns a tree for a CALL_EXPR to the do_lio function, which handles    a list-directed I/O list item, along with the appropriate arguments for    the function.  It is up to the caller to set the TREE_SIDE_EFFECTS flag    for the CALL_EXPR, expand (emit) the expression, emit any assignment    of the result to an IOSTAT= variable, and emit any checking of the    result for errors.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_function
specifier|static
name|tree
name|ffeste_io_dolio_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|tree
name|type_id
decl_stmt|;
name|tree
name|num_elements
decl_stmt|;
name|tree
name|variable
decl_stmt|;
name|tree
name|size
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|int
name|tc
decl_stmt|;
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bt
operator|==
name|FFEINFO_basictypeANY
operator|)
operator|||
operator|(
name|kt
operator|==
name|FFEINFO_kindtypeANY
operator|)
condition|)
return|return
name|error_mark_node
return|;
name|tc
operator|=
name|ffecom_f2c_typecode
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tc
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|type_id
operator|=
name|build_int_2
argument_list|(
name|tc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type_id
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ffecom_f2c_ptr_to_ftnint_type_node
argument_list|,
name|convert
argument_list|(
name|ffecom_f2c_ftnint_type_node
argument_list|,
name|type_id
argument_list|)
argument_list|)
expr_stmt|;
name|variable
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|expr
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type_id
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|variable
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|size
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|size
operator|==
name|NULL_TREE
condition|)
comment|/* Already filled in for CHARACTER type. */
block|{
comment|/* "(ftnlen) sizeof(type)" */
name|size
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Assume that while it is possible that char * is wider than 	   ftnlen, no object in Fortran space can get big enough for its 	   size to be wider than ftnlen.  I really hope nobody wastes 	   time debugging a case where it can!  */
block|assert (TYPE_PRECISION (ffecom_f2c_ftnlen_type_node)>= TYPE_PRECISION (TREE_TYPE (size)));
endif|#
directive|endif
name|size
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffeinfo_rank
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|variable
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|num_elements
operator|=
name|ffecom_integer_one_node
expr_stmt|;
else|else
block|{
name|num_elements
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|variable
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|num_elements
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|num_elements
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|num_elements
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
block|}
name|num_elements
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ffecom_f2c_ptr_to_ftnlen_type_node
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
name|variable
operator|=
name|convert
argument_list|(
name|string_type_node
argument_list|,
name|variable
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|type_id
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|variable
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtDOLIO
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I/O driver for unformatted I/O item (do_uio)     Returns a tree for a CALL_EXPR to the do_uio function, which handles    an unformatted I/O list item, along with the appropriate arguments for    the function.  It is up to the caller to set the TREE_SIDE_EFFECTS flag    for the CALL_EXPR, expand (emit) the expression, emit any assignment    of the result to an IOSTAT= variable, and emit any checking of the    result for errors.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_function
specifier|static
name|tree
name|ffeste_io_douio_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|tree
name|num_elements
decl_stmt|;
name|tree
name|variable
decl_stmt|;
name|tree
name|size
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|bool
name|is_complex
decl_stmt|;
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bt
operator|==
name|FFEINFO_basictypeANY
operator|)
operator|||
operator|(
name|kt
operator|==
name|FFEINFO_kindtypeANY
operator|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCOMPLEX
condition|)
block|{
name|is_complex
operator|=
name|TRUE
expr_stmt|;
name|bt
operator|=
name|FFEINFO_basictypeREAL
expr_stmt|;
block|}
else|else
name|is_complex
operator|=
name|FALSE
expr_stmt|;
name|variable
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|expr
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|variable
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|size
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|size
operator|==
name|NULL_TREE
condition|)
comment|/* Already filled in for CHARACTER type. */
block|{
comment|/* "(ftnlen) sizeof(type)" */
name|size
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Assume that while it is possible that char * is wider than 	   ftnlen, no object in Fortran space can get big enough for its 	   size to be wider than ftnlen.  I really hope nobody wastes 	   time debugging a case where it can!  */
block|assert (TYPE_PRECISION (ffecom_f2c_ftnlen_type_node)>= TYPE_PRECISION (TREE_TYPE (size)));
endif|#
directive|endif
name|size
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffeinfo_rank
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|variable
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|num_elements
operator|=
name|is_complex
condition|?
name|ffecom_f2c_ftnlen_two_node
else|:
name|ffecom_f2c_ftnlen_one_node
expr_stmt|;
else|else
block|{
name|num_elements
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|variable
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|num_elements
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|num_elements
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|num_elements
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
block|}
name|num_elements
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ffecom_f2c_ptr_to_ftnlen_type_node
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
name|variable
operator|=
name|convert
argument_list|(
name|string_type_node
argument_list|,
name|variable
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|variable
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtDOUIO
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make arglist with ptr to BACKSPACE/ENDFILE/REWIND control list.     Returns a tree suitable as an argument list containing a pointer to    a BACKSPACE/ENDFILE/REWIND control list.  First, generates that control    list, if necessary, along with any static and run-time initializations    that are needed as specified by the arguments to this function.     Must ensure that all expressions are prepared before being evaluated,    for any whose evaluation might result in the generation of temporaries.     Note that this means this function causes a transition, within the    current block being code-generated via the back end, from the    declaration of variables (temporaries) to the expanding of expressions,    statements, etc.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_function
specifier|static
name|tree
name|ffeste_io_ialist_
parameter_list|(
name|bool
name|have_err
parameter_list|,
name|ffestvUnit
name|unit
parameter_list|,
name|ffebld
name|unit_expr
parameter_list|,
name|int
name|unit_dflt
parameter_list|)
block|{
specifier|static
name|tree
name|f2c_alist_struct
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|ttype
decl_stmt|;
name|int
name|yes
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|tree
name|inits
decl_stmt|,
name|initn
decl_stmt|;
name|bool
name|constantp
init|=
name|TRUE
decl_stmt|;
specifier|static
name|tree
name|errfield
decl_stmt|,
name|unitfield
decl_stmt|;
name|tree
name|errinit
decl_stmt|,
name|unitinit
decl_stmt|;
name|tree
name|unitexp
decl_stmt|;
specifier|static
name|int
name|mynumber
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|f2c_alist_struct
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|ref
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|ref
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|errfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|NULL_TREE
argument_list|,
literal|"err"
argument_list|,
name|ffecom_f2c_flag_type_node
argument_list|)
expr_stmt|;
name|unitfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|errfield
argument_list|,
literal|"unit"
argument_list|,
name|ffecom_f2c_ftnint_type_node
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|ref
argument_list|)
operator|=
name|errfield
expr_stmt|;
name|layout_type
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|f2c_alist_struct
operator|=
name|ref
expr_stmt|;
block|}
comment|/* Try to do as much compile-time initialization of the structure      as possible, to save run time.  */
name|ffeste_f2c_init_flag_
argument_list|(
name|have_err
argument_list|,
name|errinit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|unit
condition|)
block|{
case|case
name|FFESTV_unitNONE
case|:
case|case
name|FFESTV_unitASTERISK
case|:
name|unitinit
operator|=
name|build_int_2
argument_list|(
name|unit_dflt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unitexp
operator|=
name|unitinit
expr_stmt|;
break|break;
case|case
name|FFESTV_unitINTEXPR
case|:
name|unitexp
operator|=
name|ffecom_const_expr
argument_list|(
name|unit_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unitexp
condition|)
name|unitinit
operator|=
name|unitexp
expr_stmt|;
else|else
block|{
name|unitinit
operator|=
name|ffecom_integer_zero_node
expr_stmt|;
name|constantp
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad unit spec"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|unitinit
operator|=
name|ffecom_integer_zero_node
expr_stmt|;
name|unitexp
operator|=
name|unitinit
expr_stmt|;
break|break;
block|}
name|inits
operator|=
name|build_tree_list
argument_list|(
operator|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|f2c_alist_struct
argument_list|)
operator|)
argument_list|,
name|errinit
argument_list|)
expr_stmt|;
name|initn
operator|=
name|inits
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|unitinit
argument_list|)
expr_stmt|;
name|inits
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|f2c_alist_struct
argument_list|,
name|NULL_TREE
argument_list|,
name|inits
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|inits
argument_list|)
operator|=
name|constantp
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|inits
argument_list|)
operator|=
literal|1
expr_stmt|;
name|yes
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_alist_%d"
argument_list|,
name|NULL
argument_list|,
name|mynumber
operator|++
argument_list|)
argument_list|,
name|f2c_alist_struct
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|ffecom_start_decl
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ffecom_finish_decl
argument_list|(
name|t
argument_list|,
name|inits
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
comment|/* Prepare run-time expressions.  */
if|if
condition|(
operator|!
name|unitexp
condition|)
name|ffecom_prepare_expr
argument_list|(
name|unit_expr
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
comment|/* Now evaluate run-time expressions as needed.  */
if|if
condition|(
operator|!
name|unitexp
condition|)
block|{
name|unitexp
operator|=
name|ffecom_expr
argument_list|(
name|unit_expr
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_
argument_list|(
name|unitfield
argument_list|,
name|unitexp
argument_list|)
expr_stmt|;
block|}
name|ttype
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ttype
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make arglist with ptr to external-I/O control list.     Returns a tree suitable as an argument list containing a pointer to    an external-I/O control list.  First, generates that control    list, if necessary, along with any static and run-time initializations    that are needed as specified by the arguments to this function.     Must ensure that all expressions are prepared before being evaluated,    for any whose evaluation might result in the generation of temporaries.     Note that this means this function causes a transition, within the    current block being code-generated via the back end, from the    declaration of variables (temporaries) to the expanding of expressions,    statements, etc.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_function
specifier|static
name|tree
name|ffeste_io_cilist_
parameter_list|(
name|bool
name|have_err
parameter_list|,
name|ffestvUnit
name|unit
parameter_list|,
name|ffebld
name|unit_expr
parameter_list|,
name|int
name|unit_dflt
parameter_list|,
name|bool
name|have_end
parameter_list|,
name|ffestvFormat
name|format
parameter_list|,
name|ffestpFile
modifier|*
name|format_spec
parameter_list|,
name|bool
name|rec
parameter_list|,
name|ffebld
name|rec_expr
parameter_list|)
block|{
specifier|static
name|tree
name|f2c_cilist_struct
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|ttype
decl_stmt|;
name|int
name|yes
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|tree
name|inits
decl_stmt|,
name|initn
decl_stmt|;
name|bool
name|constantp
init|=
name|TRUE
decl_stmt|;
specifier|static
name|tree
name|errfield
decl_stmt|,
name|unitfield
decl_stmt|,
name|endfield
decl_stmt|,
name|formatfield
decl_stmt|,
name|recfield
decl_stmt|;
name|tree
name|errinit
decl_stmt|,
name|unitinit
decl_stmt|,
name|endinit
decl_stmt|,
name|formatinit
decl_stmt|,
name|recinit
decl_stmt|;
name|tree
name|unitexp
decl_stmt|,
name|formatexp
decl_stmt|,
name|recexp
decl_stmt|;
specifier|static
name|int
name|mynumber
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|f2c_cilist_struct
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|ref
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|ref
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|errfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|NULL_TREE
argument_list|,
literal|"err"
argument_list|,
name|ffecom_f2c_flag_type_node
argument_list|)
expr_stmt|;
name|unitfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|errfield
argument_list|,
literal|"unit"
argument_list|,
name|ffecom_f2c_ftnint_type_node
argument_list|)
expr_stmt|;
name|endfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|unitfield
argument_list|,
literal|"end"
argument_list|,
name|ffecom_f2c_flag_type_node
argument_list|)
expr_stmt|;
name|formatfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|endfield
argument_list|,
literal|"format"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|recfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|formatfield
argument_list|,
literal|"rec"
argument_list|,
name|ffecom_f2c_ftnint_type_node
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|ref
argument_list|)
operator|=
name|errfield
expr_stmt|;
name|layout_type
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|f2c_cilist_struct
operator|=
name|ref
expr_stmt|;
block|}
comment|/* Try to do as much compile-time initialization of the structure      as possible, to save run time.  */
name|ffeste_f2c_init_flag_
argument_list|(
name|have_err
argument_list|,
name|errinit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|unit
condition|)
block|{
case|case
name|FFESTV_unitNONE
case|:
case|case
name|FFESTV_unitASTERISK
case|:
name|unitinit
operator|=
name|build_int_2
argument_list|(
name|unit_dflt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unitexp
operator|=
name|unitinit
expr_stmt|;
break|break;
case|case
name|FFESTV_unitINTEXPR
case|:
name|unitexp
operator|=
name|ffecom_const_expr
argument_list|(
name|unit_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unitexp
condition|)
name|unitinit
operator|=
name|unitexp
expr_stmt|;
else|else
block|{
name|unitinit
operator|=
name|ffecom_integer_zero_node
expr_stmt|;
name|constantp
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad unit spec"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|unitinit
operator|=
name|ffecom_integer_zero_node
expr_stmt|;
name|unitexp
operator|=
name|unitinit
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FFESTV_formatNONE
case|:
name|formatinit
operator|=
name|null_pointer_node
expr_stmt|;
name|formatexp
operator|=
name|formatinit
expr_stmt|;
break|break;
case|case
name|FFESTV_formatLABEL
case|:
name|formatexp
operator|=
name|error_mark_node
expr_stmt|;
name|formatinit
operator|=
name|ffecom_lookup_label
argument_list|(
name|format_spec
operator|->
name|u
operator|.
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|formatinit
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|formatinit
argument_list|)
operator|==
name|ERROR_MARK
operator|)
condition|)
break|break;
name|formatinit
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|formatinit
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|formatinit
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|FFESTV_formatCHAREXPR
case|:
name|formatexp
operator|=
name|ffecom_arg_ptr_to_const_expr
argument_list|(
name|format_spec
operator|->
name|u
operator|.
name|expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|formatexp
condition|)
name|formatinit
operator|=
name|formatexp
expr_stmt|;
else|else
block|{
name|formatinit
operator|=
name|null_pointer_node
expr_stmt|;
name|constantp
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|FFESTV_formatASTERISK
case|:
name|formatinit
operator|=
name|null_pointer_node
expr_stmt|;
name|formatexp
operator|=
name|formatinit
expr_stmt|;
break|break;
case|case
name|FFESTV_formatINTEXPR
case|:
name|formatinit
operator|=
name|null_pointer_node
expr_stmt|;
name|formatexp
operator|=
name|ffecom_expr_assign
argument_list|(
name|format_spec
operator|->
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|formatexp
argument_list|)
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"ASSIGNed FORMAT specifier is too small"
argument_list|)
expr_stmt|;
name|formatexp
operator|=
name|convert
argument_list|(
name|string_type_node
argument_list|,
name|formatexp
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_formatNAMELIST
case|:
name|formatinit
operator|=
name|ffecom_expr
argument_list|(
name|format_spec
operator|->
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
name|formatexp
operator|=
name|formatinit
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad format spec"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|formatinit
operator|=
name|integer_zero_node
expr_stmt|;
name|formatexp
operator|=
name|formatinit
expr_stmt|;
break|break;
block|}
name|ffeste_f2c_init_flag_
argument_list|(
name|have_end
argument_list|,
name|endinit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
condition|)
name|recexp
operator|=
name|ffecom_const_expr
argument_list|(
name|rec_expr
argument_list|)
expr_stmt|;
else|else
name|recexp
operator|=
name|ffecom_integer_zero_node
expr_stmt|;
if|if
condition|(
name|recexp
condition|)
name|recinit
operator|=
name|recexp
expr_stmt|;
else|else
block|{
name|recinit
operator|=
name|ffecom_integer_zero_node
expr_stmt|;
name|constantp
operator|=
name|FALSE
expr_stmt|;
block|}
name|inits
operator|=
name|build_tree_list
argument_list|(
operator|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|f2c_cilist_struct
argument_list|)
operator|)
argument_list|,
name|errinit
argument_list|)
expr_stmt|;
name|initn
operator|=
name|inits
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|unitinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|endinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|formatinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|recinit
argument_list|)
expr_stmt|;
name|inits
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|f2c_cilist_struct
argument_list|,
name|NULL_TREE
argument_list|,
name|inits
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|inits
argument_list|)
operator|=
name|constantp
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|inits
argument_list|)
operator|=
literal|1
expr_stmt|;
name|yes
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_cilist_%d"
argument_list|,
name|NULL
argument_list|,
name|mynumber
operator|++
argument_list|)
argument_list|,
name|f2c_cilist_struct
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|ffecom_start_decl
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ffecom_finish_decl
argument_list|(
name|t
argument_list|,
name|inits
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
comment|/* Prepare run-time expressions.  */
if|if
condition|(
operator|!
name|unitexp
condition|)
name|ffecom_prepare_expr
argument_list|(
name|unit_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|formatexp
condition|)
name|ffecom_prepare_arg_ptr_to_expr
argument_list|(
name|format_spec
operator|->
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|recexp
condition|)
name|ffecom_prepare_expr
argument_list|(
name|rec_expr
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
comment|/* Now evaluate run-time expressions as needed.  */
if|if
condition|(
operator|!
name|unitexp
condition|)
block|{
name|unitexp
operator|=
name|ffecom_expr
argument_list|(
name|unit_expr
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_
argument_list|(
name|unitfield
argument_list|,
name|unitexp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|formatexp
condition|)
block|{
name|formatexp
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|format_spec
operator|->
name|u
operator|.
name|expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_
argument_list|(
name|formatfield
argument_list|,
name|formatexp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|==
name|FFESTV_formatINTEXPR
condition|)
name|ffeste_f2c_compile_
argument_list|(
name|formatfield
argument_list|,
name|formatexp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|recexp
condition|)
block|{
name|recexp
operator|=
name|ffecom_expr
argument_list|(
name|rec_expr
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_
argument_list|(
name|recfield
argument_list|,
name|recexp
argument_list|)
expr_stmt|;
block|}
name|ttype
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ttype
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make arglist with ptr to CLOSE control list.     Returns a tree suitable as an argument list containing a pointer to    a CLOSE-statement control list.  First, generates that control    list, if necessary, along with any static and run-time initializations    that are needed as specified by the arguments to this function.     Must ensure that all expressions are prepared before being evaluated,    for any whose evaluation might result in the generation of temporaries.     Note that this means this function causes a transition, within the    current block being code-generated via the back end, from the    declaration of variables (temporaries) to the expanding of expressions,    statements, etc.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_function
specifier|static
name|tree
name|ffeste_io_cllist_
parameter_list|(
name|bool
name|have_err
parameter_list|,
name|ffebld
name|unit_expr
parameter_list|,
name|ffestpFile
modifier|*
name|stat_spec
parameter_list|)
block|{
specifier|static
name|tree
name|f2c_close_struct
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|ttype
decl_stmt|;
name|int
name|yes
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|tree
name|inits
decl_stmt|,
name|initn
decl_stmt|;
name|tree
name|ignore
decl_stmt|;
comment|/* Ignore length info for certain fields. */
name|bool
name|constantp
init|=
name|TRUE
decl_stmt|;
specifier|static
name|tree
name|errfield
decl_stmt|,
name|unitfield
decl_stmt|,
name|statfield
decl_stmt|;
name|tree
name|errinit
decl_stmt|,
name|unitinit
decl_stmt|,
name|statinit
decl_stmt|;
name|tree
name|unitexp
decl_stmt|,
name|statexp
decl_stmt|;
specifier|static
name|int
name|mynumber
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|f2c_close_struct
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|ref
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|ref
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|errfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|NULL_TREE
argument_list|,
literal|"err"
argument_list|,
name|ffecom_f2c_flag_type_node
argument_list|)
expr_stmt|;
name|unitfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|errfield
argument_list|,
literal|"unit"
argument_list|,
name|ffecom_f2c_ftnint_type_node
argument_list|)
expr_stmt|;
name|statfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|unitfield
argument_list|,
literal|"stat"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|ref
argument_list|)
operator|=
name|errfield
expr_stmt|;
name|layout_type
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|f2c_close_struct
operator|=
name|ref
expr_stmt|;
block|}
comment|/* Try to do as much compile-time initialization of the structure      as possible, to save run time.  */
name|ffeste_f2c_init_flag_
argument_list|(
name|have_err
argument_list|,
name|errinit
argument_list|)
expr_stmt|;
name|unitexp
operator|=
name|ffecom_const_expr
argument_list|(
name|unit_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unitexp
condition|)
name|unitinit
operator|=
name|unitexp
expr_stmt|;
else|else
block|{
name|unitinit
operator|=
name|ffecom_integer_zero_node
expr_stmt|;
name|constantp
operator|=
name|FALSE
expr_stmt|;
block|}
name|ffeste_f2c_init_charnolen_
argument_list|(
name|statexp
argument_list|,
name|statinit
argument_list|,
name|stat_spec
argument_list|)
expr_stmt|;
name|inits
operator|=
name|build_tree_list
argument_list|(
operator|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|f2c_close_struct
argument_list|)
operator|)
argument_list|,
name|errinit
argument_list|)
expr_stmt|;
name|initn
operator|=
name|inits
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|unitinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|statinit
argument_list|)
expr_stmt|;
name|inits
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|f2c_close_struct
argument_list|,
name|NULL_TREE
argument_list|,
name|inits
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|inits
argument_list|)
operator|=
name|constantp
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|inits
argument_list|)
operator|=
literal|1
expr_stmt|;
name|yes
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_cllist_%d"
argument_list|,
name|NULL
argument_list|,
name|mynumber
operator|++
argument_list|)
argument_list|,
name|f2c_close_struct
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|ffecom_start_decl
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ffecom_finish_decl
argument_list|(
name|t
argument_list|,
name|inits
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
comment|/* Prepare run-time expressions.  */
if|if
condition|(
operator|!
name|unitexp
condition|)
name|ffecom_prepare_expr
argument_list|(
name|unit_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|statexp
condition|)
name|ffecom_prepare_arg_ptr_to_expr
argument_list|(
name|stat_spec
operator|->
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
comment|/* Now evaluate run-time expressions as needed.  */
if|if
condition|(
operator|!
name|unitexp
condition|)
block|{
name|unitexp
operator|=
name|ffecom_expr
argument_list|(
name|unit_expr
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_
argument_list|(
name|unitfield
argument_list|,
name|unitexp
argument_list|)
expr_stmt|;
block|}
name|ffeste_f2c_compile_charnolen_
argument_list|(
name|statfield
argument_list|,
name|stat_spec
argument_list|,
name|statexp
argument_list|)
expr_stmt|;
name|ttype
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ttype
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make arglist with ptr to internal-I/O control list.     Returns a tree suitable as an argument list containing a pointer to    an internal-I/O control list.  First, generates that control    list, if necessary, along with any static and run-time initializations    that are needed as specified by the arguments to this function.     Must ensure that all expressions are prepared before being evaluated,    for any whose evaluation might result in the generation of temporaries.     Note that this means this function causes a transition, within the    current block being code-generated via the back end, from the    declaration of variables (temporaries) to the expanding of expressions,    statements, etc.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_function
specifier|static
name|tree
name|ffeste_io_icilist_
parameter_list|(
name|bool
name|have_err
parameter_list|,
name|ffebld
name|unit_expr
parameter_list|,
name|bool
name|have_end
parameter_list|,
name|ffestvFormat
name|format
parameter_list|,
name|ffestpFile
modifier|*
name|format_spec
parameter_list|)
block|{
specifier|static
name|tree
name|f2c_icilist_struct
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|ttype
decl_stmt|;
name|int
name|yes
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|tree
name|inits
decl_stmt|,
name|initn
decl_stmt|;
name|bool
name|constantp
init|=
name|TRUE
decl_stmt|;
specifier|static
name|tree
name|errfield
decl_stmt|,
name|unitfield
decl_stmt|,
name|endfield
decl_stmt|,
name|formatfield
decl_stmt|,
name|unitlenfield
decl_stmt|,
name|unitnumfield
decl_stmt|;
name|tree
name|errinit
decl_stmt|,
name|unitinit
decl_stmt|,
name|endinit
decl_stmt|,
name|formatinit
decl_stmt|,
name|unitleninit
decl_stmt|,
name|unitnuminit
decl_stmt|;
name|tree
name|unitexp
decl_stmt|,
name|formatexp
decl_stmt|,
name|unitlenexp
decl_stmt|,
name|unitnumexp
decl_stmt|;
specifier|static
name|int
name|mynumber
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|f2c_icilist_struct
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|ref
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|ref
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|errfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|NULL_TREE
argument_list|,
literal|"err"
argument_list|,
name|ffecom_f2c_flag_type_node
argument_list|)
expr_stmt|;
name|unitfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|errfield
argument_list|,
literal|"unit"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|endfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|unitfield
argument_list|,
literal|"end"
argument_list|,
name|ffecom_f2c_flag_type_node
argument_list|)
expr_stmt|;
name|formatfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|endfield
argument_list|,
literal|"format"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|unitlenfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|formatfield
argument_list|,
literal|"unitlen"
argument_list|,
name|ffecom_f2c_ftnint_type_node
argument_list|)
expr_stmt|;
name|unitnumfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|unitlenfield
argument_list|,
literal|"unitnum"
argument_list|,
name|ffecom_f2c_ftnint_type_node
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|ref
argument_list|)
operator|=
name|errfield
expr_stmt|;
name|layout_type
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|f2c_icilist_struct
operator|=
name|ref
expr_stmt|;
block|}
comment|/* Try to do as much compile-time initialization of the structure      as possible, to save run time.  */
name|ffeste_f2c_init_flag_
argument_list|(
name|have_err
argument_list|,
name|errinit
argument_list|)
expr_stmt|;
name|unitexp
operator|=
name|ffecom_arg_ptr_to_const_expr
argument_list|(
name|unit_expr
argument_list|,
operator|&
name|unitlenexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unitexp
condition|)
name|unitinit
operator|=
name|unitexp
expr_stmt|;
else|else
block|{
name|unitinit
operator|=
name|null_pointer_node
expr_stmt|;
name|constantp
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|unitlenexp
condition|)
name|unitleninit
operator|=
name|unitlenexp
expr_stmt|;
else|else
block|{
name|unitleninit
operator|=
name|ffecom_integer_zero_node
expr_stmt|;
name|constantp
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Now see if we can fully initialize the number of elements, or      if we have to compute that at run time.  */
if|if
condition|(
name|ffeinfo_rank
argument_list|(
name|ffebld_info
argument_list|(
name|unit_expr
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|unitexp
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|unitexp
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|)
condition|)
block|{
comment|/* Not an array, so just one element.  */
name|unitnuminit
operator|=
name|ffecom_integer_one_node
expr_stmt|;
name|unitnumexp
operator|=
name|unitnuminit
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unitexp
operator|&&
name|unitlenexp
condition|)
block|{
comment|/* An array, but all the info is constant, so compute now.  */
name|unitnuminit
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|unitexp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|unitlenexp
argument_list|)
expr_stmt|;
name|unitnuminit
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|unitnuminit
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|unitnumexp
operator|=
name|unitnuminit
expr_stmt|;
block|}
else|else
block|{
comment|/* Put off computing until run time.  */
name|unitnuminit
operator|=
name|ffecom_integer_zero_node
expr_stmt|;
name|unitnumexp
operator|=
name|NULL_TREE
expr_stmt|;
name|constantp
operator|=
name|FALSE
expr_stmt|;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FFESTV_formatNONE
case|:
name|formatinit
operator|=
name|null_pointer_node
expr_stmt|;
name|formatexp
operator|=
name|formatinit
expr_stmt|;
break|break;
case|case
name|FFESTV_formatLABEL
case|:
name|formatexp
operator|=
name|error_mark_node
expr_stmt|;
name|formatinit
operator|=
name|ffecom_lookup_label
argument_list|(
name|format_spec
operator|->
name|u
operator|.
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|formatinit
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|formatinit
argument_list|)
operator|==
name|ERROR_MARK
operator|)
condition|)
break|break;
name|formatinit
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|formatinit
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|formatinit
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|FFESTV_formatCHAREXPR
case|:
name|ffeste_f2c_init_format_
argument_list|(
name|formatexp
argument_list|,
name|formatinit
argument_list|,
name|format_spec
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_formatASTERISK
case|:
name|formatinit
operator|=
name|null_pointer_node
expr_stmt|;
name|formatexp
operator|=
name|formatinit
expr_stmt|;
break|break;
case|case
name|FFESTV_formatINTEXPR
case|:
name|formatinit
operator|=
name|null_pointer_node
expr_stmt|;
name|formatexp
operator|=
name|ffecom_expr_assign
argument_list|(
name|format_spec
operator|->
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|formatexp
argument_list|)
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"ASSIGNed FORMAT specifier is too small"
argument_list|)
expr_stmt|;
name|formatexp
operator|=
name|convert
argument_list|(
name|string_type_node
argument_list|,
name|formatexp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad format spec"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|formatinit
operator|=
name|ffecom_integer_zero_node
expr_stmt|;
name|formatexp
operator|=
name|formatinit
expr_stmt|;
break|break;
block|}
name|ffeste_f2c_init_flag_
argument_list|(
name|have_end
argument_list|,
name|endinit
argument_list|)
expr_stmt|;
name|inits
operator|=
name|build_tree_list
argument_list|(
operator|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|f2c_icilist_struct
argument_list|)
operator|)
argument_list|,
name|errinit
argument_list|)
expr_stmt|;
name|initn
operator|=
name|inits
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|unitinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|endinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|formatinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|unitleninit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|unitnuminit
argument_list|)
expr_stmt|;
name|inits
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|f2c_icilist_struct
argument_list|,
name|NULL_TREE
argument_list|,
name|inits
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|inits
argument_list|)
operator|=
name|constantp
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|inits
argument_list|)
operator|=
literal|1
expr_stmt|;
name|yes
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_icilist_%d"
argument_list|,
name|NULL
argument_list|,
name|mynumber
operator|++
argument_list|)
argument_list|,
name|f2c_icilist_struct
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|ffecom_start_decl
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ffecom_finish_decl
argument_list|(
name|t
argument_list|,
name|inits
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
comment|/* Prepare run-time expressions.  */
if|if
condition|(
operator|!
name|unitexp
condition|)
name|ffecom_prepare_arg_ptr_to_expr
argument_list|(
name|unit_expr
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_format_
argument_list|(
name|format_spec
argument_list|,
name|formatexp
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
comment|/* Now evaluate run-time expressions as needed.  */
if|if
condition|(
operator|!
name|unitexp
operator|||
operator|!
name|unitlenexp
condition|)
block|{
name|int
name|need_unitexp
init|=
operator|(
operator|!
name|unitexp
operator|)
decl_stmt|;
name|int
name|need_unitlenexp
init|=
operator|(
operator|!
name|unitlenexp
operator|)
decl_stmt|;
name|unitexp
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|unit_expr
argument_list|,
operator|&
name|unitlenexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_unitexp
condition|)
name|ffeste_f2c_compile_
argument_list|(
name|unitfield
argument_list|,
name|unitexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_unitlenexp
condition|)
name|ffeste_f2c_compile_
argument_list|(
name|unitlenfield
argument_list|,
name|unitlenexp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|unitnumexp
operator|&&
name|unitexp
operator|!=
name|error_mark_node
operator|&&
name|unitlenexp
operator|!=
name|error_mark_node
condition|)
block|{
name|unitnumexp
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|unitexp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|unitlenexp
argument_list|)
expr_stmt|;
name|unitnumexp
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|unitnumexp
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_
argument_list|(
name|unitnumfield
argument_list|,
name|unitnumexp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|==
name|FFESTV_formatINTEXPR
condition|)
name|ffeste_f2c_compile_
argument_list|(
name|formatfield
argument_list|,
name|formatexp
argument_list|)
expr_stmt|;
else|else
name|ffeste_f2c_compile_format_
argument_list|(
name|formatfield
argument_list|,
name|format_spec
argument_list|,
name|formatexp
argument_list|)
expr_stmt|;
name|ttype
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ttype
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make arglist with ptr to INQUIRE control list     Returns a tree suitable as an argument list containing a pointer to    an INQUIRE-statement control list.  First, generates that control    list, if necessary, along with any static and run-time initializations    that are needed as specified by the arguments to this function.     Must ensure that all expressions are prepared before being evaluated,    for any whose evaluation might result in the generation of temporaries.     Note that this means this function causes a transition, within the    current block being code-generated via the back end, from the    declaration of variables (temporaries) to the expanding of expressions,    statements, etc.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_function
specifier|static
name|tree
name|ffeste_io_inlist_
parameter_list|(
name|bool
name|have_err
parameter_list|,
name|ffestpFile
modifier|*
name|unit_spec
parameter_list|,
name|ffestpFile
modifier|*
name|file_spec
parameter_list|,
name|ffestpFile
modifier|*
name|exist_spec
parameter_list|,
name|ffestpFile
modifier|*
name|open_spec
parameter_list|,
name|ffestpFile
modifier|*
name|number_spec
parameter_list|,
name|ffestpFile
modifier|*
name|named_spec
parameter_list|,
name|ffestpFile
modifier|*
name|name_spec
parameter_list|,
name|ffestpFile
modifier|*
name|access_spec
parameter_list|,
name|ffestpFile
modifier|*
name|sequential_spec
parameter_list|,
name|ffestpFile
modifier|*
name|direct_spec
parameter_list|,
name|ffestpFile
modifier|*
name|form_spec
parameter_list|,
name|ffestpFile
modifier|*
name|formatted_spec
parameter_list|,
name|ffestpFile
modifier|*
name|unformatted_spec
parameter_list|,
name|ffestpFile
modifier|*
name|recl_spec
parameter_list|,
name|ffestpFile
modifier|*
name|nextrec_spec
parameter_list|,
name|ffestpFile
modifier|*
name|blank_spec
parameter_list|)
block|{
specifier|static
name|tree
name|f2c_inquire_struct
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|ttype
decl_stmt|;
name|int
name|yes
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|tree
name|inits
decl_stmt|,
name|initn
decl_stmt|;
name|bool
name|constantp
init|=
name|TRUE
decl_stmt|;
specifier|static
name|tree
name|errfield
decl_stmt|,
name|unitfield
decl_stmt|,
name|filefield
decl_stmt|,
name|filelenfield
decl_stmt|,
name|existfield
decl_stmt|,
name|openfield
decl_stmt|,
name|numberfield
decl_stmt|,
name|namedfield
decl_stmt|,
name|namefield
decl_stmt|,
name|namelenfield
decl_stmt|,
name|accessfield
decl_stmt|,
name|accesslenfield
decl_stmt|,
name|sequentialfield
decl_stmt|,
name|sequentiallenfield
decl_stmt|,
name|directfield
decl_stmt|,
name|directlenfield
decl_stmt|,
name|formfield
decl_stmt|,
name|formlenfield
decl_stmt|,
name|formattedfield
decl_stmt|,
name|formattedlenfield
decl_stmt|,
name|unformattedfield
decl_stmt|,
name|unformattedlenfield
decl_stmt|,
name|reclfield
decl_stmt|,
name|nextrecfield
decl_stmt|,
name|blankfield
decl_stmt|,
name|blanklenfield
decl_stmt|;
name|tree
name|errinit
decl_stmt|,
name|unitinit
decl_stmt|,
name|fileinit
decl_stmt|,
name|fileleninit
decl_stmt|,
name|existinit
decl_stmt|,
name|openinit
decl_stmt|,
name|numberinit
decl_stmt|,
name|namedinit
decl_stmt|,
name|nameinit
decl_stmt|,
name|nameleninit
decl_stmt|,
name|accessinit
decl_stmt|,
name|accessleninit
decl_stmt|,
name|sequentialinit
decl_stmt|,
name|sequentialleninit
decl_stmt|,
name|directinit
decl_stmt|,
name|directleninit
decl_stmt|,
name|forminit
decl_stmt|,
name|formleninit
decl_stmt|,
name|formattedinit
decl_stmt|,
name|formattedleninit
decl_stmt|,
name|unformattedinit
decl_stmt|,
name|unformattedleninit
decl_stmt|,
name|reclinit
decl_stmt|,
name|nextrecinit
decl_stmt|,
name|blankinit
decl_stmt|,
name|blankleninit
decl_stmt|;
name|tree
name|unitexp
decl_stmt|,
name|fileexp
decl_stmt|,
name|filelenexp
decl_stmt|,
name|existexp
decl_stmt|,
name|openexp
decl_stmt|,
name|numberexp
decl_stmt|,
name|namedexp
decl_stmt|,
name|nameexp
decl_stmt|,
name|namelenexp
decl_stmt|,
name|accessexp
decl_stmt|,
name|accesslenexp
decl_stmt|,
name|sequentialexp
decl_stmt|,
name|sequentiallenexp
decl_stmt|,
name|directexp
decl_stmt|,
name|directlenexp
decl_stmt|,
name|formexp
decl_stmt|,
name|formlenexp
decl_stmt|,
name|formattedexp
decl_stmt|,
name|formattedlenexp
decl_stmt|,
name|unformattedexp
decl_stmt|,
name|unformattedlenexp
decl_stmt|,
name|reclexp
decl_stmt|,
name|nextrecexp
decl_stmt|,
name|blankexp
decl_stmt|,
name|blanklenexp
decl_stmt|;
specifier|static
name|int
name|mynumber
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|f2c_inquire_struct
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|ref
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|ref
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|errfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|NULL_TREE
argument_list|,
literal|"err"
argument_list|,
name|ffecom_f2c_flag_type_node
argument_list|)
expr_stmt|;
name|unitfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|errfield
argument_list|,
literal|"unit"
argument_list|,
name|ffecom_f2c_ftnint_type_node
argument_list|)
expr_stmt|;
name|filefield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|unitfield
argument_list|,
literal|"file"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|filelenfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|filefield
argument_list|,
literal|"filelen"
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|)
expr_stmt|;
name|existfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|filelenfield
argument_list|,
literal|"exist"
argument_list|,
name|ffecom_f2c_ptr_to_ftnint_type_node
argument_list|)
expr_stmt|;
name|openfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|existfield
argument_list|,
literal|"open"
argument_list|,
name|ffecom_f2c_ptr_to_ftnint_type_node
argument_list|)
expr_stmt|;
name|numberfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|openfield
argument_list|,
literal|"number"
argument_list|,
name|ffecom_f2c_ptr_to_ftnint_type_node
argument_list|)
expr_stmt|;
name|namedfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|numberfield
argument_list|,
literal|"named"
argument_list|,
name|ffecom_f2c_ptr_to_ftnint_type_node
argument_list|)
expr_stmt|;
name|namefield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|namedfield
argument_list|,
literal|"name"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|namelenfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|namefield
argument_list|,
literal|"namelen"
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|)
expr_stmt|;
name|accessfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|namelenfield
argument_list|,
literal|"access"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|accesslenfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|accessfield
argument_list|,
literal|"accesslen"
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|)
expr_stmt|;
name|sequentialfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|accesslenfield
argument_list|,
literal|"sequential"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|sequentiallenfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|sequentialfield
argument_list|,
literal|"sequentiallen"
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|)
expr_stmt|;
name|directfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|sequentiallenfield
argument_list|,
literal|"direct"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|directlenfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|directfield
argument_list|,
literal|"directlen"
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|)
expr_stmt|;
name|formfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|directlenfield
argument_list|,
literal|"form"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|formlenfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|formfield
argument_list|,
literal|"formlen"
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|)
expr_stmt|;
name|formattedfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|formlenfield
argument_list|,
literal|"formatted"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|formattedlenfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|formattedfield
argument_list|,
literal|"formattedlen"
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|)
expr_stmt|;
name|unformattedfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|formattedlenfield
argument_list|,
literal|"unformatted"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|unformattedlenfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|unformattedfield
argument_list|,
literal|"unformattedlen"
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|)
expr_stmt|;
name|reclfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|unformattedlenfield
argument_list|,
literal|"recl"
argument_list|,
name|ffecom_f2c_ptr_to_ftnint_type_node
argument_list|)
expr_stmt|;
name|nextrecfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|reclfield
argument_list|,
literal|"nextrec"
argument_list|,
name|ffecom_f2c_ptr_to_ftnint_type_node
argument_list|)
expr_stmt|;
name|blankfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|nextrecfield
argument_list|,
literal|"blank"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|blanklenfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|blankfield
argument_list|,
literal|"blanklen"
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|ref
argument_list|)
operator|=
name|errfield
expr_stmt|;
name|layout_type
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|f2c_inquire_struct
operator|=
name|ref
expr_stmt|;
block|}
comment|/* Try to do as much compile-time initialization of the structure      as possible, to save run time.  */
name|ffeste_f2c_init_flag_
argument_list|(
name|have_err
argument_list|,
name|errinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_int_
argument_list|(
name|unitexp
argument_list|,
name|unitinit
argument_list|,
name|unit_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_char_
argument_list|(
name|fileexp
argument_list|,
name|fileinit
argument_list|,
name|filelenexp
argument_list|,
name|fileleninit
argument_list|,
name|file_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_ptrtoint_
argument_list|(
name|existexp
argument_list|,
name|existinit
argument_list|,
name|exist_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_ptrtoint_
argument_list|(
name|openexp
argument_list|,
name|openinit
argument_list|,
name|open_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_ptrtoint_
argument_list|(
name|numberexp
argument_list|,
name|numberinit
argument_list|,
name|number_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_ptrtoint_
argument_list|(
name|namedexp
argument_list|,
name|namedinit
argument_list|,
name|named_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_char_
argument_list|(
name|nameexp
argument_list|,
name|nameinit
argument_list|,
name|namelenexp
argument_list|,
name|nameleninit
argument_list|,
name|name_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_char_
argument_list|(
name|accessexp
argument_list|,
name|accessinit
argument_list|,
name|accesslenexp
argument_list|,
name|accessleninit
argument_list|,
name|access_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_char_
argument_list|(
name|sequentialexp
argument_list|,
name|sequentialinit
argument_list|,
name|sequentiallenexp
argument_list|,
name|sequentialleninit
argument_list|,
name|sequential_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_char_
argument_list|(
name|directexp
argument_list|,
name|directinit
argument_list|,
name|directlenexp
argument_list|,
name|directleninit
argument_list|,
name|direct_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_char_
argument_list|(
name|formexp
argument_list|,
name|forminit
argument_list|,
name|formlenexp
argument_list|,
name|formleninit
argument_list|,
name|form_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_char_
argument_list|(
name|formattedexp
argument_list|,
name|formattedinit
argument_list|,
name|formattedlenexp
argument_list|,
name|formattedleninit
argument_list|,
name|formatted_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_char_
argument_list|(
name|unformattedexp
argument_list|,
name|unformattedinit
argument_list|,
name|unformattedlenexp
argument_list|,
name|unformattedleninit
argument_list|,
name|unformatted_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_ptrtoint_
argument_list|(
name|reclexp
argument_list|,
name|reclinit
argument_list|,
name|recl_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_ptrtoint_
argument_list|(
name|nextrecexp
argument_list|,
name|nextrecinit
argument_list|,
name|nextrec_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_char_
argument_list|(
name|blankexp
argument_list|,
name|blankinit
argument_list|,
name|blanklenexp
argument_list|,
name|blankleninit
argument_list|,
name|blank_spec
argument_list|)
expr_stmt|;
name|inits
operator|=
name|build_tree_list
argument_list|(
operator|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|f2c_inquire_struct
argument_list|)
operator|)
argument_list|,
name|errinit
argument_list|)
expr_stmt|;
name|initn
operator|=
name|inits
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|unitinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|fileinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|fileleninit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|existinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|openinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|numberinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|namedinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|nameinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|nameleninit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|accessinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|accessleninit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|sequentialinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|sequentialleninit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|directinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|directleninit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|forminit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|formleninit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|formattedinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|formattedleninit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|unformattedinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|unformattedleninit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|reclinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|nextrecinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|blankinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|blankleninit
argument_list|)
expr_stmt|;
name|inits
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|f2c_inquire_struct
argument_list|,
name|NULL_TREE
argument_list|,
name|inits
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|inits
argument_list|)
operator|=
name|constantp
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|inits
argument_list|)
operator|=
literal|1
expr_stmt|;
name|yes
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_inlist_%d"
argument_list|,
name|NULL
argument_list|,
name|mynumber
operator|++
argument_list|)
argument_list|,
name|f2c_inquire_struct
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|ffecom_start_decl
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ffecom_finish_decl
argument_list|(
name|t
argument_list|,
name|inits
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
comment|/* Prepare run-time expressions.  */
name|ffeste_f2c_prepare_int_
argument_list|(
name|unit_spec
argument_list|,
name|unitexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_char_
argument_list|(
name|file_spec
argument_list|,
name|fileexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_ptrtoint_
argument_list|(
name|exist_spec
argument_list|,
name|existexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_ptrtoint_
argument_list|(
name|open_spec
argument_list|,
name|openexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_ptrtoint_
argument_list|(
name|number_spec
argument_list|,
name|numberexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_ptrtoint_
argument_list|(
name|named_spec
argument_list|,
name|namedexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_char_
argument_list|(
name|name_spec
argument_list|,
name|nameexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_char_
argument_list|(
name|access_spec
argument_list|,
name|accessexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_char_
argument_list|(
name|sequential_spec
argument_list|,
name|sequentialexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_char_
argument_list|(
name|direct_spec
argument_list|,
name|directexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_char_
argument_list|(
name|form_spec
argument_list|,
name|formexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_char_
argument_list|(
name|formatted_spec
argument_list|,
name|formattedexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_char_
argument_list|(
name|unformatted_spec
argument_list|,
name|unformattedexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_ptrtoint_
argument_list|(
name|recl_spec
argument_list|,
name|reclexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_ptrtoint_
argument_list|(
name|nextrec_spec
argument_list|,
name|nextrecexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_char_
argument_list|(
name|blank_spec
argument_list|,
name|blankexp
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
comment|/* Now evaluate run-time expressions as needed.  */
name|ffeste_f2c_compile_int_
argument_list|(
name|unitfield
argument_list|,
name|unit_spec
argument_list|,
name|unitexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_char_
argument_list|(
name|filefield
argument_list|,
name|filelenfield
argument_list|,
name|file_spec
argument_list|,
name|fileexp
argument_list|,
name|filelenexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_ptrtoint_
argument_list|(
name|existfield
argument_list|,
name|exist_spec
argument_list|,
name|existexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_ptrtoint_
argument_list|(
name|openfield
argument_list|,
name|open_spec
argument_list|,
name|openexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_ptrtoint_
argument_list|(
name|numberfield
argument_list|,
name|number_spec
argument_list|,
name|numberexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_ptrtoint_
argument_list|(
name|namedfield
argument_list|,
name|named_spec
argument_list|,
name|namedexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_char_
argument_list|(
name|namefield
argument_list|,
name|namelenfield
argument_list|,
name|name_spec
argument_list|,
name|nameexp
argument_list|,
name|namelenexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_char_
argument_list|(
name|accessfield
argument_list|,
name|accesslenfield
argument_list|,
name|access_spec
argument_list|,
name|accessexp
argument_list|,
name|accesslenexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_char_
argument_list|(
name|sequentialfield
argument_list|,
name|sequentiallenfield
argument_list|,
name|sequential_spec
argument_list|,
name|sequentialexp
argument_list|,
name|sequentiallenexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_char_
argument_list|(
name|directfield
argument_list|,
name|directlenfield
argument_list|,
name|direct_spec
argument_list|,
name|directexp
argument_list|,
name|directlenexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_char_
argument_list|(
name|formfield
argument_list|,
name|formlenfield
argument_list|,
name|form_spec
argument_list|,
name|formexp
argument_list|,
name|formlenexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_char_
argument_list|(
name|formattedfield
argument_list|,
name|formattedlenfield
argument_list|,
name|formatted_spec
argument_list|,
name|formattedexp
argument_list|,
name|formattedlenexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_char_
argument_list|(
name|unformattedfield
argument_list|,
name|unformattedlenfield
argument_list|,
name|unformatted_spec
argument_list|,
name|unformattedexp
argument_list|,
name|unformattedlenexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_ptrtoint_
argument_list|(
name|reclfield
argument_list|,
name|recl_spec
argument_list|,
name|reclexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_ptrtoint_
argument_list|(
name|nextrecfield
argument_list|,
name|nextrec_spec
argument_list|,
name|nextrecexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_char_
argument_list|(
name|blankfield
argument_list|,
name|blanklenfield
argument_list|,
name|blank_spec
argument_list|,
name|blankexp
argument_list|,
name|blanklenexp
argument_list|)
expr_stmt|;
name|ttype
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ttype
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make arglist with ptr to OPEN control list     Returns a tree suitable as an argument list containing a pointer to    an OPEN-statement control list.  First, generates that control    list, if necessary, along with any static and run-time initializations    that are needed as specified by the arguments to this function.     Must ensure that all expressions are prepared before being evaluated,    for any whose evaluation might result in the generation of temporaries.     Note that this means this function causes a transition, within the    current block being code-generated via the back end, from the    declaration of variables (temporaries) to the expanding of expressions,    statements, etc.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_function
specifier|static
name|tree
name|ffeste_io_olist_
parameter_list|(
name|bool
name|have_err
parameter_list|,
name|ffebld
name|unit_expr
parameter_list|,
name|ffestpFile
modifier|*
name|file_spec
parameter_list|,
name|ffestpFile
modifier|*
name|stat_spec
parameter_list|,
name|ffestpFile
modifier|*
name|access_spec
parameter_list|,
name|ffestpFile
modifier|*
name|form_spec
parameter_list|,
name|ffestpFile
modifier|*
name|recl_spec
parameter_list|,
name|ffestpFile
modifier|*
name|blank_spec
parameter_list|)
block|{
specifier|static
name|tree
name|f2c_open_struct
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|ttype
decl_stmt|;
name|int
name|yes
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|tree
name|inits
decl_stmt|,
name|initn
decl_stmt|;
name|tree
name|ignore
decl_stmt|;
comment|/* Ignore length info for certain fields. */
name|bool
name|constantp
init|=
name|TRUE
decl_stmt|;
specifier|static
name|tree
name|errfield
decl_stmt|,
name|unitfield
decl_stmt|,
name|filefield
decl_stmt|,
name|filelenfield
decl_stmt|,
name|statfield
decl_stmt|,
name|accessfield
decl_stmt|,
name|formfield
decl_stmt|,
name|reclfield
decl_stmt|,
name|blankfield
decl_stmt|;
name|tree
name|errinit
decl_stmt|,
name|unitinit
decl_stmt|,
name|fileinit
decl_stmt|,
name|fileleninit
decl_stmt|,
name|statinit
decl_stmt|,
name|accessinit
decl_stmt|,
name|forminit
decl_stmt|,
name|reclinit
decl_stmt|,
name|blankinit
decl_stmt|;
name|tree
name|unitexp
decl_stmt|,
name|fileexp
decl_stmt|,
name|filelenexp
decl_stmt|,
name|statexp
decl_stmt|,
name|accessexp
decl_stmt|,
name|formexp
decl_stmt|,
name|reclexp
decl_stmt|,
name|blankexp
decl_stmt|;
specifier|static
name|int
name|mynumber
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|f2c_open_struct
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|ref
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|ref
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|errfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|NULL_TREE
argument_list|,
literal|"err"
argument_list|,
name|ffecom_f2c_flag_type_node
argument_list|)
expr_stmt|;
name|unitfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|errfield
argument_list|,
literal|"unit"
argument_list|,
name|ffecom_f2c_ftnint_type_node
argument_list|)
expr_stmt|;
name|filefield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|unitfield
argument_list|,
literal|"file"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|filelenfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|filefield
argument_list|,
literal|"filelen"
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|)
expr_stmt|;
name|statfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|filelenfield
argument_list|,
literal|"stat"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|accessfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|statfield
argument_list|,
literal|"access"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|formfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|accessfield
argument_list|,
literal|"form"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|reclfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|formfield
argument_list|,
literal|"recl"
argument_list|,
name|ffecom_f2c_ftnint_type_node
argument_list|)
expr_stmt|;
name|blankfield
operator|=
name|ffecom_decl_field
argument_list|(
name|ref
argument_list|,
name|reclfield
argument_list|,
literal|"blank"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|ref
argument_list|)
operator|=
name|errfield
expr_stmt|;
name|layout_type
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|f2c_open_struct
operator|=
name|ref
expr_stmt|;
block|}
comment|/* Try to do as much compile-time initialization of the structure      as possible, to save run time.  */
name|ffeste_f2c_init_flag_
argument_list|(
name|have_err
argument_list|,
name|errinit
argument_list|)
expr_stmt|;
name|unitexp
operator|=
name|ffecom_const_expr
argument_list|(
name|unit_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unitexp
condition|)
name|unitinit
operator|=
name|unitexp
expr_stmt|;
else|else
block|{
name|unitinit
operator|=
name|ffecom_integer_zero_node
expr_stmt|;
name|constantp
operator|=
name|FALSE
expr_stmt|;
block|}
name|ffeste_f2c_init_char_
argument_list|(
name|fileexp
argument_list|,
name|fileinit
argument_list|,
name|filelenexp
argument_list|,
name|fileleninit
argument_list|,
name|file_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_charnolen_
argument_list|(
name|statexp
argument_list|,
name|statinit
argument_list|,
name|stat_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_charnolen_
argument_list|(
name|accessexp
argument_list|,
name|accessinit
argument_list|,
name|access_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_charnolen_
argument_list|(
name|formexp
argument_list|,
name|forminit
argument_list|,
name|form_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_int_
argument_list|(
name|reclexp
argument_list|,
name|reclinit
argument_list|,
name|recl_spec
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_charnolen_
argument_list|(
name|blankexp
argument_list|,
name|blankinit
argument_list|,
name|blank_spec
argument_list|)
expr_stmt|;
name|inits
operator|=
name|build_tree_list
argument_list|(
operator|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|f2c_open_struct
argument_list|)
operator|)
argument_list|,
name|errinit
argument_list|)
expr_stmt|;
name|initn
operator|=
name|inits
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|unitinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|fileinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|fileleninit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|statinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|accessinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|forminit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|reclinit
argument_list|)
expr_stmt|;
name|ffeste_f2c_init_next_
argument_list|(
name|blankinit
argument_list|)
expr_stmt|;
name|inits
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|f2c_open_struct
argument_list|,
name|NULL_TREE
argument_list|,
name|inits
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|inits
argument_list|)
operator|=
name|constantp
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|inits
argument_list|)
operator|=
literal|1
expr_stmt|;
name|yes
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_olist_%d"
argument_list|,
name|NULL
argument_list|,
name|mynumber
operator|++
argument_list|)
argument_list|,
name|f2c_open_struct
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|ffecom_start_decl
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ffecom_finish_decl
argument_list|(
name|t
argument_list|,
name|inits
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
comment|/* Prepare run-time expressions.  */
if|if
condition|(
operator|!
name|unitexp
condition|)
name|ffecom_prepare_expr
argument_list|(
name|unit_expr
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_char_
argument_list|(
name|file_spec
argument_list|,
name|fileexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_charnolen_
argument_list|(
name|stat_spec
argument_list|,
name|statexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_charnolen_
argument_list|(
name|access_spec
argument_list|,
name|accessexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_charnolen_
argument_list|(
name|form_spec
argument_list|,
name|formexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_int_
argument_list|(
name|recl_spec
argument_list|,
name|reclexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_prepare_charnolen_
argument_list|(
name|blank_spec
argument_list|,
name|blankexp
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
comment|/* Now evaluate run-time expressions as needed.  */
if|if
condition|(
operator|!
name|unitexp
condition|)
block|{
name|unitexp
operator|=
name|ffecom_expr
argument_list|(
name|unit_expr
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_
argument_list|(
name|unitfield
argument_list|,
name|unitexp
argument_list|)
expr_stmt|;
block|}
name|ffeste_f2c_compile_char_
argument_list|(
name|filefield
argument_list|,
name|filelenfield
argument_list|,
name|file_spec
argument_list|,
name|fileexp
argument_list|,
name|filelenexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_charnolen_
argument_list|(
name|statfield
argument_list|,
name|stat_spec
argument_list|,
name|statexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_charnolen_
argument_list|(
name|accessfield
argument_list|,
name|access_spec
argument_list|,
name|accessexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_charnolen_
argument_list|(
name|formfield
argument_list|,
name|form_spec
argument_list|,
name|formexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_int_
argument_list|(
name|reclfield
argument_list|,
name|recl_spec
argument_list|,
name|reclexp
argument_list|)
expr_stmt|;
name|ffeste_f2c_compile_charnolen_
argument_list|(
name|blankfield
argument_list|,
name|blank_spec
argument_list|,
name|blankexp
argument_list|)
expr_stmt|;
name|ttype
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ttype
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Display file-statement specifier.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
end_if

begin_function
specifier|static
name|void
name|ffeste_subr_file_
parameter_list|(
specifier|const
name|char
modifier|*
name|kw
parameter_list|,
name|ffestpFile
modifier|*
name|spec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|spec
operator|->
name|kw_or_val_present
condition|)
return|return;
name|fputs
argument_list|(
name|kw
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|->
name|value_present
condition|)
block|{
name|fputc
argument_list|(
literal|'='
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|->
name|value_is_label
condition|)
block|{
name|assert
argument_list|(
name|spec
operator|->
name|value_is_label
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|/* Temporary checking only. */
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"%"
name|ffelabValue_f
literal|"u"
argument_list|,
name|ffelab_value
argument_list|(
name|spec
operator|->
name|u
operator|.
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ffebld_dump
argument_list|(
name|spec
operator|->
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generate code for BACKSPACE/ENDFILE/REWIND.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
end_if

begin_function
specifier|static
name|void
name|ffeste_subr_beru_
parameter_list|(
name|ffestpBeruStmt
modifier|*
name|info
parameter_list|,
name|ffecomGfrt
name|rt
parameter_list|)
block|{
name|tree
name|alist
decl_stmt|;
name|bool
name|iostat
decl_stmt|;
name|bool
name|errl
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
define|#
directive|define
name|specified
parameter_list|(
name|something
parameter_list|)
value|(info->beru_spec[something].kw_or_val_present)
name|iostat
operator|=
name|specified
argument_list|(
name|FFESTP_beruixIOSTAT
argument_list|)
expr_stmt|;
name|errl
operator|=
name|specified
argument_list|(
name|FFESTP_beruixERR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|specified
comment|/* ~~For now, we assume the unit number is specified and is not ASTERISK,      because the FFE doesn't support BACKSPACE(*) and rejects a BACKSPACE      without any unit specifier.  f2c, however, supports the former      construct.	 When it is time to add this feature to the FFE, which      probably is fairly easy, ffestc_R919 and company will want to pass an      ffestvUnit indicator of FFESTV_unitINTEXPR or _unitASTERISK to      ffeste_R919 and company, and they will want to pass that same value to      this function, and that argument will replace the constant _unitINTEXPR_      in the call below.	 Right now, the default unit number, 6, is ignored.  */
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
if|if
condition|(
name|errl
condition|)
block|{
comment|/* Have ERR= specification.   */
name|ffeste_io_err_
operator|=
name|ffeste_io_abort_
operator|=
name|ffecom_lookup_label
argument_list|(
name|info
operator|->
name|beru_spec
index|[
name|FFESTP_beruixERR
index|]
operator|.
name|u
operator|.
name|label
argument_list|)
expr_stmt|;
name|ffeste_io_abort_is_temp_
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* No ERR= specification.  */
name|ffeste_io_err_
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|(
name|ffeste_io_abort_is_temp_
operator|=
name|iostat
operator|)
condition|)
name|ffeste_io_abort_
operator|=
name|ffecom_temp_label
argument_list|()
expr_stmt|;
else|else
name|ffeste_io_abort_
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|iostat
condition|)
block|{
comment|/* Have IOSTAT= specification.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|FALSE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|ffecom_expr
argument_list|(
name|info
operator|->
name|beru_spec
index|[
name|FFESTP_beruixIOSTAT
index|]
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffeste_io_abort_
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Have no IOSTAT= but have ERR=.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|TRUE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"beru"
argument_list|,
name|ffecom_integer_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No IOSTAT= or ERR= specification.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|FALSE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Now prescan, then convert, all the arguments.  */
name|alist
operator|=
name|ffeste_io_ialist_
argument_list|(
name|errl
operator|||
name|iostat
argument_list|,
name|FFESTV_unitINTEXPR
argument_list|,
name|info
operator|->
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
operator|.
name|u
operator|.
name|expr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Don't generate "if (iostat != 0) goto label;" if label is temp abort      label, since we're gonna fall through to there anyway. */
name|ffeste_io_call_
argument_list|(
name|ffecom_call_gfrt
argument_list|(
name|rt
argument_list|,
name|alist
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
operator|!
name|ffeste_io_abort_is_temp_
argument_list|)
expr_stmt|;
comment|/* If we've got a temp label, generate its code here. */
if|if
condition|(
name|ffeste_io_abort_is_temp_
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|ffeste_io_abort_
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|emit_nop
argument_list|()
expr_stmt|;
name|expand_label
argument_list|(
name|ffeste_io_abort_
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeste_io_err_
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* END DO statement     Also invoked by _labeldef_branch_finish_ (or, in cases    of errors, other _labeldef_ functions) when the label definition is    for a DO-target (LOOPEND) label, once per matching/outstanding DO    block on the stack.  */
end_comment

begin_function
name|void
name|ffeste_do
parameter_list|(
name|ffestw
name|block
parameter_list|)
block|{
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ END_DO\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestw_do_tvar
argument_list|(
name|block
argument_list|)
operator|==
literal|0
condition|)
block|{
name|expand_end_loop
argument_list|()
expr_stmt|;
comment|/* DO WHILE and just DO. */
name|ffeste_end_block_
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
else|else
name|ffeste_end_iterdo_
argument_list|(
name|block
argument_list|,
name|ffestw_do_tvar
argument_list|(
name|block
argument_list|)
argument_list|,
name|ffestw_do_incr_saved
argument_list|(
name|block
argument_list|)
argument_list|,
name|ffestw_do_count_var
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* End of statement following logical IF.     Applies to *only* logical IF, not to IF-THEN.  */
end_comment

begin_function
name|void
name|ffeste_end_R807
parameter_list|()
block|{
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ END_IF\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
comment|/* Also see ffeste_R806. */
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
name|ffeste_end_block_
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Generate "code" for branch label definition.  */
end_comment

begin_function
name|void
name|ffeste_labeldef_branch
parameter_list|(
name|ffelab
name|label
parameter_list|)
block|{
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"+ label %lu\n"
argument_list|,
name|ffelab_value
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|glabel
decl_stmt|;
name|glabel
operator|=
name|ffecom_lookup_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|glabel
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|glabel
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
name|assert
argument_list|(
name|DECL_INITIAL
argument_list|(
name|glabel
argument_list|)
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|glabel
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|glabel
argument_list|)
operator|=
name|ffelab_definition_filename
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|glabel
argument_list|)
operator|=
name|ffelab_definition_filelinenum
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|emit_nop
argument_list|()
expr_stmt|;
name|expand_label
argument_list|(
name|glabel
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Generate "code" for FORMAT label definition.  */
end_comment

begin_function
name|void
name|ffeste_labeldef_format
parameter_list|(
name|ffelab
name|label
parameter_list|)
block|{
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"$ label %lu\n"
argument_list|,
name|ffelab_value
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_label_formatdef_
operator|=
name|label
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Assignment statement (outside of WHERE).  */
end_comment

begin_function
name|void
name|ffeste_R737A
parameter_list|(
name|ffebld
name|dest
parameter_list|,
name|ffebld
name|source
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ let "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"="
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffecom_expand_let_stmt
argument_list|(
name|dest
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Block IF (IF-THEN) statement.  */
end_comment

begin_function
name|void
name|ffeste_R803
parameter_list|(
name|ffestw
name|block
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ IF_block ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|temp
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|ffeste_start_block_
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|temp
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"ifthen"
argument_list|,
name|integer_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffecom_prepare_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffecom_prepare_end
argument_list|()
condition|)
block|{
name|tree
name|result
decl_stmt|;
name|result
operator|=
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|temp
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
name|temp
operator|=
name|ffecom_truth_value
argument_list|(
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_start_cond
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* No fake `else' constructs introduced (yet).  */
name|ffestw_set_ifthen_fake_else
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ELSE IF statement.  */
end_comment

begin_function
name|void
name|ffeste_R804
parameter_list|(
name|ffestw
name|block
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ ELSE_IF ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|temp
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
comment|/* Since ELSEIF(expr) might require preparations for expr,        implement as ELSE; prepare-expr; IF (expr) THEN ...; ENDIF.  */
name|expand_start_else
argument_list|()
expr_stmt|;
name|ffeste_start_block_
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|temp
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"elseif"
argument_list|,
name|integer_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffecom_prepare_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffecom_prepare_end
argument_list|()
condition|)
block|{
name|tree
name|result
decl_stmt|;
name|result
operator|=
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|temp
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* In this case, we could probably have used expand_start_elseif 	   instead, saving the need for a fake `else' construct.  But, 	   until it's clear that'd improve performance, it's easier this 	   way, since we have to expand_start_else before we get to this 	   test, given the current design.  */
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
name|temp
operator|=
name|ffecom_truth_value
argument_list|(
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_start_cond
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Increment number of fake `else' constructs introduced.  */
name|ffestw_set_ifthen_fake_else
argument_list|(
name|block
argument_list|,
name|ffestw_ifthen_fake_else
argument_list|(
name|block
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ELSE statement.  */
end_comment

begin_function
name|void
name|ffeste_R805
parameter_list|(
name|ffestw
name|block
name|UNUSED
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ ELSE\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|expand_start_else
argument_list|()
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* END IF statement.  */
end_comment

begin_function
name|void
name|ffeste_R806
parameter_list|(
name|ffestw
name|block
parameter_list|)
block|{
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ END_IF_then\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
comment|/* Also see ffeste_shriek_if_. */
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|int
name|i
init|=
name|ffestw_ifthen_fake_else
argument_list|(
name|block
argument_list|)
operator|+
literal|1
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|i
condition|;
operator|--
name|i
control|)
block|{
name|expand_end_cond
argument_list|()
expr_stmt|;
name|ffeste_end_block_
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Logical IF statement.  */
end_comment

begin_function
name|void
name|ffeste_R807
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ IF_logical ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|temp
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|ffeste_start_block_
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"if"
argument_list|,
name|integer_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffecom_prepare_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffecom_prepare_end
argument_list|()
condition|)
block|{
name|tree
name|result
decl_stmt|;
name|result
operator|=
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|temp
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
name|temp
operator|=
name|ffecom_truth_value
argument_list|(
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_start_cond
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* SELECT CASE statement.  */
end_comment

begin_function
name|void
name|ffeste_R809
parameter_list|(
name|ffestw
name|block
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ SELECT_CASE ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|ffeste_start_block_
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeANY
operator|)
condition|)
name|ffestw_set_select_texpr
argument_list|(
name|block
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
block|{
comment|/* ~~~Someday handle CHARACTER*1, CHARACTER*N */
name|ffebad_start_msg
argument_list|(
literal|"SELECT CASE on CHARACTER type (at %0) not supported -- sorry"
argument_list|,
name|FFEBAD_severityFATAL
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffestw_line
argument_list|(
name|block
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestw_set_select_texpr
argument_list|(
name|block
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|result
decl_stmt|;
name|tree
name|texpr
decl_stmt|;
name|result
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"select"
argument_list|,
name|ffecom_type_expr
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ffeinfo_size
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffecom_prepare_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
name|texpr
operator|=
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|texpr
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|texpr
operator|=
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|result
argument_list|,
name|texpr
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|texpr
argument_list|)
expr_stmt|;
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
name|expand_start_case
argument_list|(
literal|1
argument_list|,
name|result
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
literal|"SELECT CASE statement"
argument_list|)
expr_stmt|;
name|ffestw_set_select_texpr
argument_list|(
name|block
argument_list|,
name|texpr
argument_list|)
expr_stmt|;
name|ffestw_set_select_break
argument_list|(
name|block
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* CASE statement.     If casenum is 0, it's CASE DEFAULT.	Else it's the case ranges at    the start of the first_stmt list in the select object at the top of    the stack that match casenum.  */
end_comment

begin_function
name|void
name|ffeste_R810
parameter_list|(
name|ffestw
name|block
parameter_list|,
name|unsigned
name|long
name|casenum
parameter_list|)
block|{
name|ffestwSelect
name|s
init|=
name|ffestw_select
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|ffestwCase
name|c
decl_stmt|;
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|first_stmt
operator|==
operator|(
name|ffestwCase
operator|)
operator|&
name|s
operator|->
name|first_rel
condition|)
name|c
operator|=
name|NULL
expr_stmt|;
else|else
name|c
operator|=
name|s
operator|->
name|first_stmt
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
if|if
condition|(
operator|(
name|c
operator|==
name|NULL
operator|)
operator|||
operator|(
name|casenum
operator|!=
name|c
operator|->
name|casenum
operator|)
condition|)
block|{
if|if
condition|(
name|casenum
operator|==
literal|0
condition|)
comment|/* Intentional CASE DEFAULT. */
name|fputs
argument_list|(
literal|"+ CASE_DEFAULT"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|comma
init|=
name|FALSE
decl_stmt|;
name|fputs
argument_list|(
literal|"+ CASE ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|comma
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
else|else
name|comma
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|low
operator|!=
name|NULL
condition|)
name|ffebld_constant_dump
argument_list|(
name|c
operator|->
name|low
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|low
operator|!=
name|c
operator|->
name|high
condition|)
block|{
name|fputc
argument_list|(
literal|':'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|high
operator|!=
name|NULL
condition|)
name|ffebld_constant_dump
argument_list|(
name|c
operator|->
name|high
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|c
operator|->
name|next_stmt
expr_stmt|;
comment|/* Unlink prev.  */
name|c
operator|->
name|previous_stmt
operator|->
name|previous_stmt
operator|->
name|next_stmt
operator|=
name|c
expr_stmt|;
name|c
operator|->
name|previous_stmt
operator|=
name|c
operator|->
name|previous_stmt
operator|->
name|previous_stmt
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|!=
operator|(
name|ffestwCase
operator|)
operator|&
name|s
operator|->
name|first_rel
operator|)
operator|&&
operator|(
name|casenum
operator|==
name|c
operator|->
name|casenum
operator|)
condition|)
do|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|texprlow
decl_stmt|;
name|tree
name|texprhigh
decl_stmt|;
name|tree
name|tlabel
decl_stmt|;
name|int
name|pushok
decl_stmt|;
name|tree
name|duplicate
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestw_select_texpr
argument_list|(
name|block
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* ~~~Someday handle CHARACTER*1, CHARACTER*N */
name|tlabel
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestw_select_break
argument_list|(
name|block
argument_list|)
condition|)
name|expand_exit_something
argument_list|()
expr_stmt|;
else|else
name|ffestw_set_select_break
argument_list|(
name|block
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|NULL
operator|)
operator|||
operator|(
name|casenum
operator|!=
name|c
operator|->
name|casenum
operator|)
condition|)
block|{
if|if
condition|(
name|casenum
operator|==
literal|0
condition|)
comment|/* Intentional CASE DEFAULT. */
block|{
name|pushok
operator|=
name|pushcase
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
name|tlabel
argument_list|,
operator|&
name|duplicate
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pushok
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
do|do
block|{
name|texprlow
operator|=
operator|(
name|c
operator|->
name|low
operator|==
name|NULL
operator|)
condition|?
name|NULL_TREE
else|:
name|ffecom_constantunion
argument_list|(
operator|&
name|ffebld_constant_union
argument_list|(
name|c
operator|->
name|low
argument_list|)
argument_list|,
name|s
operator|->
name|type
argument_list|,
name|s
operator|->
name|kindtype
argument_list|,
name|ffecom_tree_type
index|[
name|s
operator|->
name|type
index|]
index|[
name|s
operator|->
name|kindtype
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|low
operator|!=
name|c
operator|->
name|high
condition|)
block|{
name|texprhigh
operator|=
operator|(
name|c
operator|->
name|high
operator|==
name|NULL
operator|)
condition|?
name|NULL_TREE
else|:
name|ffecom_constantunion
argument_list|(
operator|&
name|ffebld_constant_union
argument_list|(
name|c
operator|->
name|high
argument_list|)
argument_list|,
name|s
operator|->
name|type
argument_list|,
name|s
operator|->
name|kindtype
argument_list|,
name|ffecom_tree_type
index|[
name|s
operator|->
name|type
index|]
index|[
name|s
operator|->
name|kindtype
index|]
argument_list|)
expr_stmt|;
name|pushok
operator|=
name|pushcase_range
argument_list|(
name|texprlow
argument_list|,
name|texprhigh
argument_list|,
name|convert
argument_list|,
name|tlabel
argument_list|,
operator|&
name|duplicate
argument_list|)
expr_stmt|;
block|}
else|else
name|pushok
operator|=
name|pushcase
argument_list|(
name|texprlow
argument_list|,
name|convert
argument_list|,
name|tlabel
argument_list|,
operator|&
name|duplicate
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pushok
operator|==
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next_stmt
expr_stmt|;
comment|/* Unlink prev.  */
name|c
operator|->
name|previous_stmt
operator|->
name|previous_stmt
operator|->
name|next_stmt
operator|=
name|c
expr_stmt|;
name|c
operator|->
name|previous_stmt
operator|=
name|c
operator|->
name|previous_stmt
operator|->
name|previous_stmt
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|!=
operator|(
name|ffestwCase
operator|)
operator|&
name|s
operator|->
name|first_rel
operator|)
operator|&&
operator|(
name|casenum
operator|==
name|c
operator|->
name|casenum
operator|)
condition|)
do|;
name|clear_momentary
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* END SELECT statement.  */
end_comment

begin_function
name|void
name|ffeste_R811
parameter_list|(
name|ffestw
name|block
parameter_list|)
block|{
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ END_SELECT\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
comment|/* ~~~Someday handle CHARACTER*1, CHARACTER*N */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ffestw_select_texpr
argument_list|(
name|block
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|expand_end_case
argument_list|(
name|ffestw_select_texpr
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|ffeste_end_block_
argument_list|(
name|block
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Iterative DO statement.  */
end_comment

begin_function
name|void
name|ffeste_R819A
parameter_list|(
name|ffestw
name|block
parameter_list|,
name|ffelab
name|label
name|UNUSED
parameter_list|,
name|ffebld
name|var
parameter_list|,
name|ffebld
name|start
parameter_list|,
name|ffelexToken
name|start_token
parameter_list|,
name|ffebld
name|end
parameter_list|,
name|ffelexToken
name|end_token
parameter_list|,
name|ffebld
name|incr
parameter_list|,
name|ffelexToken
name|incr_token
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
if|if
condition|(
operator|(
name|ffebld_op
argument_list|(
name|incr
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|&&
operator|(
name|ffebld_constant_is_zero
argument_list|(
name|ffebld_conter
argument_list|(
name|incr
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DO_STEP_ZERO
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|incr_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|incr_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"Iterative DO loop"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
comment|/* Don't bother replacing it with 1 yet.  */
block|}
if|if
condition|(
name|label
operator|==
name|NULL
condition|)
name|fputs
argument_list|(
literal|"+ DO_iterative_nonlabeled ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"+ DO_iterative_labeled %lu ("
argument_list|,
name|ffelab_value
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'='
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|incr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|ffeste_begin_iterdo_
argument_list|(
name|block
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|var
argument_list|,
name|start
argument_list|,
name|start_token
argument_list|,
name|end
argument_list|,
name|end_token
argument_list|,
name|incr
argument_list|,
name|incr_token
argument_list|,
literal|"Iterative DO loop"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* DO WHILE statement.  */
end_comment

begin_function
name|void
name|ffeste_R819B
parameter_list|(
name|ffestw
name|block
parameter_list|,
name|ffelab
name|label
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
if|if
condition|(
name|label
operator|==
name|NULL
condition|)
name|fputs
argument_list|(
literal|"+ DO_WHILE_nonlabeled ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"+ DO_WHILE_labeled %lu ("
argument_list|,
name|ffelab_value
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|result
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|ffeste_start_block_
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
condition|)
block|{
name|struct
name|nesting
modifier|*
name|loop
decl_stmt|;
name|tree
name|mod
decl_stmt|;
name|result
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"dowhile"
argument_list|,
name|integer_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|loop
operator|=
name|expand_start_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffecom_prepare_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
name|mod
operator|=
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|result
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|mod
argument_list|)
expr_stmt|;
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
name|ffestw_set_do_hook
argument_list|(
name|block
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|expand_exit_loop_if_false
argument_list|(
literal|0
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
name|ffestw_set_do_hook
argument_list|(
name|block
argument_list|,
name|expand_start_loop
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_do_tvar
argument_list|(
name|block
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* END DO statement.     This is the MIL-STD 1753 END DO. It's syntactic sugar, similar to    CONTINUE (except that it has to have a label that is the target of    one or more iterative DO statement), not the Fortran-90 structured    END DO, which is handled elsewhere, as is the actual mechanism of    ending an iterative DO statement, even one that ends at a label.  */
end_comment

begin_function
name|void
name|ffeste_R825
parameter_list|()
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ END_DO_sugar\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|emit_nop
argument_list|()
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* CYCLE statement.  */
end_comment

begin_function
name|void
name|ffeste_R834
parameter_list|(
name|ffestw
name|block
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"+ CYCLE block #%lu\n"
argument_list|,
name|ffestw_blocknum
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|expand_continue_loop
argument_list|(
name|ffestw_do_hook
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* EXIT statement.  */
end_comment

begin_function
name|void
name|ffeste_R835
parameter_list|(
name|ffestw
name|block
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"+ EXIT block #%lu\n"
argument_list|,
name|ffestw_blocknum
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|expand_exit_loop
argument_list|(
name|ffestw_do_hook
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* GOTO statement.  */
end_comment

begin_function
name|void
name|ffeste_R836
parameter_list|(
name|ffelab
name|label
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"+ GOTO %lu\n"
argument_list|,
name|ffelab_value
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|glabel
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|glabel
operator|=
name|ffecom_lookup_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|glabel
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|glabel
argument_list|)
operator|!=
name|ERROR_MARK
operator|)
condition|)
block|{
name|expand_goto
argument_list|(
name|glabel
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|glabel
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Computed GOTO statement.  */
end_comment

begin_function
name|void
name|ffeste_R837
parameter_list|(
name|ffelab
modifier|*
name|labels
parameter_list|,
name|int
name|count
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ CGOTO ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"%"
name|ffelabValue_f
literal|"u"
argument_list|,
name|ffelab_value
argument_list|(
name|labels
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"),"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|texpr
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|tree
name|tlabel
decl_stmt|;
name|int
name|pushok
decl_stmt|;
name|tree
name|duplicate
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffecom_prepare_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
name|texpr
operator|=
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expand_start_case
argument_list|(
literal|0
argument_list|,
name|texpr
argument_list|,
name|TREE_TYPE
argument_list|(
name|texpr
argument_list|)
argument_list|,
literal|"computed GOTO statement"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|value
operator|=
name|build_int_2
argument_list|(
name|i
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tlabel
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pushok
operator|=
name|pushcase
argument_list|(
name|value
argument_list|,
name|convert
argument_list|,
name|tlabel
argument_list|,
operator|&
name|duplicate
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pushok
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tlabel
operator|=
name|ffecom_lookup_label
argument_list|(
name|labels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tlabel
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|tlabel
argument_list|)
operator|==
name|ERROR_MARK
operator|)
condition|)
continue|continue;
name|expand_goto
argument_list|(
name|tlabel
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|tlabel
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|expand_end_case
argument_list|(
name|texpr
argument_list|)
expr_stmt|;
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ASSIGN statement.  */
end_comment

begin_function
name|void
name|ffeste_R838
parameter_list|(
name|ffelab
name|label
parameter_list|,
name|ffebld
name|target
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"+ ASSIGN %lu TO "
argument_list|,
name|ffelab_value
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|expr_tree
decl_stmt|;
name|tree
name|label_tree
decl_stmt|;
name|tree
name|target_tree
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
comment|/* No need to call ffeste_start_stmt_(), as the sorts of expressions        seen here should never require use of temporaries.  */
name|label_tree
operator|=
name|ffecom_lookup_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|label_tree
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|label_tree
argument_list|)
operator|!=
name|ERROR_MARK
operator|)
condition|)
block|{
name|label_tree
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|label_tree
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|label_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
name|target_tree
operator|=
name|ffecom_expr_assign_w
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|target_tree
argument_list|)
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|label_tree
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"ASSIGN to variable that is too small"
argument_list|)
expr_stmt|;
name|label_tree
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|target_tree
argument_list|)
argument_list|,
name|label_tree
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|target_tree
argument_list|,
name|label_tree
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|expr_tree
argument_list|)
expr_stmt|;
name|clear_momentary
argument_list|()
expr_stmt|;
block|}
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Assigned GOTO statement.  */
end_comment

begin_function
name|void
name|ffeste_R839
parameter_list|(
name|ffebld
name|target
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ AGOTO "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|t
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
comment|/* No need to call ffeste_start_stmt_(), as the sorts of expressions        seen here should never require use of temporaries.  */
name|t
operator|=
name|ffecom_expr_assign
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"ASSIGNed GOTO target variable is too small"
argument_list|)
expr_stmt|;
name|expand_computed_goto
argument_list|(
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|clear_momentary
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Arithmetic IF statement.  */
end_comment

begin_function
name|void
name|ffeste_R840
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelab
name|neg
parameter_list|,
name|ffelab
name|zero
parameter_list|,
name|ffelab
name|pos
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ IF_arithmetic ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|") %"
name|ffelabValue_f
literal|"u,%"
name|ffelabValue_f
literal|"u,%"
name|ffelabValue_f
literal|"u\n"
argument_list|,
name|ffelab_value
argument_list|(
name|neg
argument_list|)
argument_list|,
name|ffelab_value
argument_list|(
name|zero
argument_list|)
argument_list|,
name|ffelab_value
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|gneg
init|=
name|ffecom_lookup_label
argument_list|(
name|neg
argument_list|)
decl_stmt|;
name|tree
name|gzero
init|=
name|ffecom_lookup_label
argument_list|(
name|zero
argument_list|)
decl_stmt|;
name|tree
name|gpos
init|=
name|ffecom_lookup_label
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|tree
name|texpr
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|gneg
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|gzero
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|gpos
operator|==
name|NULL_TREE
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|gneg
argument_list|)
operator|==
name|ERROR_MARK
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|gzero
argument_list|)
operator|==
name|ERROR_MARK
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|gpos
argument_list|)
operator|==
name|ERROR_MARK
operator|)
condition|)
return|return;
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffecom_prepare_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|neg
operator|==
name|zero
condition|)
block|{
if|if
condition|(
name|neg
operator|==
name|pos
condition|)
name|expand_goto
argument_list|(
name|gzero
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* IF (expr.LE.0) THEN GOTO neg/zero ELSE GOTO pos.  */
name|texpr
operator|=
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|texpr
operator|=
name|ffecom_2
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|texpr
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|texpr
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|ffecom_truth_value
argument_list|(
name|texpr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_goto
argument_list|(
name|gzero
argument_list|)
expr_stmt|;
name|expand_start_else
argument_list|()
expr_stmt|;
name|expand_goto
argument_list|(
name|gpos
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|neg
operator|==
name|pos
condition|)
block|{
comment|/* IF (expr.NE.0) THEN GOTO neg/pos ELSE GOTO zero.  */
name|texpr
operator|=
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|texpr
operator|=
name|ffecom_2
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|texpr
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|texpr
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|ffecom_truth_value
argument_list|(
name|texpr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_goto
argument_list|(
name|gneg
argument_list|)
expr_stmt|;
name|expand_start_else
argument_list|()
expr_stmt|;
name|expand_goto
argument_list|(
name|gzero
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zero
operator|==
name|pos
condition|)
block|{
comment|/* IF (expr.GE.0) THEN GOTO zero/pos ELSE GOTO neg.  */
name|texpr
operator|=
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|texpr
operator|=
name|ffecom_2
argument_list|(
name|GE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|texpr
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|texpr
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|ffecom_truth_value
argument_list|(
name|texpr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_goto
argument_list|(
name|gzero
argument_list|)
expr_stmt|;
name|expand_start_else
argument_list|()
expr_stmt|;
name|expand_goto
argument_list|(
name|gneg
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Use a SAVE_EXPR in combo with: 	   IF (expr.LT.0) THEN GOTO neg 	   ELSEIF (expr.GT.0) THEN GOTO pos 	   ELSE GOTO zero.  */
name|tree
name|expr_saved
init|=
name|ffecom_save_tree
argument_list|(
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
name|texpr
operator|=
name|ffecom_2
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|expr_saved
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr_saved
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|ffecom_truth_value
argument_list|(
name|texpr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_goto
argument_list|(
name|gneg
argument_list|)
expr_stmt|;
name|texpr
operator|=
name|ffecom_2
argument_list|(
name|GT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|expr_saved
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr_saved
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|expand_start_elseif
argument_list|(
name|ffecom_truth_value
argument_list|(
name|texpr
argument_list|)
argument_list|)
expr_stmt|;
name|expand_goto
argument_list|(
name|gpos
argument_list|)
expr_stmt|;
name|expand_start_else
argument_list|()
expr_stmt|;
name|expand_goto
argument_list|(
name|gzero
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* CONTINUE statement.  */
end_comment

begin_function
name|void
name|ffeste_R841
parameter_list|()
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ CONTINUE\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|emit_nop
argument_list|()
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* STOP statement.  */
end_comment

begin_function
name|void
name|ffeste_R842
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|"+ STOP\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|"+ STOP_coded "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|callit
decl_stmt|;
name|ffelexToken
name|msg
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeANY
operator|)
condition|)
block|{
name|msg
operator|=
name|ffelex_token_new_character
argument_list|(
literal|""
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_characterdefault
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeCHARACTER
argument_list|,
name|FFEINFO_kindtypeCHARACTERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
condition|)
block|{
name|char
name|num
index|[
literal|50
index|]
decl_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%"
name|ffetargetIntegerDefault_f
literal|"d"
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|=
name|ffelex_token_new_character
argument_list|(
name|num
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_characterdefault
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeCHARACTER
argument_list|,
name|FFEINFO_kindtypeCHARACTERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeCHARACTERDEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/* No need to call ffeste_start_stmt_(), as the sorts of expressions        seen here should never require use of temporaries.  */
name|callit
operator|=
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtSTOP
argument_list|,
name|ffecom_list_ptr_to_expr
argument_list|(
name|ffebld_new_item
argument_list|(
name|expr
argument_list|,
name|NULL
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|callit
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|callit
argument_list|)
expr_stmt|;
name|clear_momentary
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* PAUSE statement.  */
end_comment

begin_function
name|void
name|ffeste_R843
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|"+ PAUSE\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|"+ PAUSE_coded "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|callit
decl_stmt|;
name|ffelexToken
name|msg
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeANY
operator|)
condition|)
block|{
name|msg
operator|=
name|ffelex_token_new_character
argument_list|(
literal|""
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_characterdefault
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeCHARACTER
argument_list|,
name|FFEINFO_kindtypeCHARACTERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
condition|)
block|{
name|char
name|num
index|[
literal|50
index|]
decl_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%"
name|ffetargetIntegerDefault_f
literal|"d"
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|=
name|ffelex_token_new_character
argument_list|(
name|num
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_characterdefault
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeCHARACTER
argument_list|,
name|FFEINFO_kindtypeCHARACTERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeCHARACTERDEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/* No need to call ffeste_start_stmt_(), as the sorts of expressions        seen here should never require use of temporaries.  */
name|callit
operator|=
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtPAUSE
argument_list|,
name|ffecom_list_ptr_to_expr
argument_list|(
name|ffebld_new_item
argument_list|(
name|expr
argument_list|,
name|NULL
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|callit
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|callit
argument_list|)
expr_stmt|;
name|clear_momentary
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Old approach for phantom g77 run-time 				   library. */
block|{     tree callit;      ffeste_emit_line_note_ ();      if (expr == NULL)       callit = ffecom_call_gfrt (FFECOM_gfrtPAUSENIL, NULL_TREE, NULL_TREE);     else if (ffeinfo_basictype (ffebld_info (expr)) 	     == FFEINFO_basictypeINTEGER)       callit = ffecom_call_gfrt (FFECOM_gfrtPAUSEINT, 		      ffecom_list_ptr_to_expr (ffebld_new_item (expr, NULL)), 				 NULL_TREE);     else if (ffeinfo_basictype (ffebld_info (expr)) 	     == FFEINFO_basictypeCHARACTER)       callit = ffecom_call_gfrt (FFECOM_gfrtPAUSECHAR, 		      ffecom_list_ptr_to_expr (ffebld_new_item (expr, NULL)), 				 NULL_TREE);     else       abort ();     TREE_SIDE_EFFECTS (callit) = 1;      expand_expr_stmt (callit);      clear_momentary ();   }
endif|#
directive|endif
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* OPEN statement.  */
end_comment

begin_function
name|void
name|ffeste_R904
parameter_list|(
name|ffestpOpenStmt
modifier|*
name|info
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ OPEN ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixUNIT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ACCESS"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixACCESS
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ACTION"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixACTION
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ASSOCIATEVARIABLE"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixASSOCIATEVARIABLE
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"BLANK"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixBLANK
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"BLOCKSIZE"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixBLOCKSIZE
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"BUFFERCOUNT"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixBUFFERCOUNT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"CARRIAGECONTROL"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixCARRIAGECONTROL
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"DEFAULTFILE"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixDEFAULTFILE
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"DELIM"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixDELIM
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"DISPOSE"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixDISPOSE
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ERR"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixERR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"EXTENDSIZE"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixEXTENDSIZE
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"FILE"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixFILE
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"FORM"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixFORM
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"INITIALSIZE"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixINITIALSIZE
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"IOSTAT"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixIOSTAT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"KEY"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixKEY
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"MAXREC"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixMAXREC
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"NOSPANBLOCKS"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixNOSPANBLOCKS
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ORGANIZATION"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixORGANIZATION
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"PAD"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixPAD
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"POSITION"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixPOSITION
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"READONLY"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixREADONLY
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"RECL"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixRECL
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"RECORDTYPE"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixRECORDTYPE
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"SHARED"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixSHARED
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"STATUS"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixSTATUS
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"USEROPEN"
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixUSEROPEN
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|args
decl_stmt|;
name|bool
name|iostat
decl_stmt|;
name|bool
name|errl
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
define|#
directive|define
name|specified
parameter_list|(
name|something
parameter_list|)
value|(info->open_spec[something].kw_or_val_present)
name|iostat
operator|=
name|specified
argument_list|(
name|FFESTP_openixIOSTAT
argument_list|)
expr_stmt|;
name|errl
operator|=
name|specified
argument_list|(
name|FFESTP_openixERR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|specified
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
if|if
condition|(
name|errl
condition|)
block|{
name|ffeste_io_err_
operator|=
name|ffeste_io_abort_
operator|=
name|ffecom_lookup_label
argument_list|(
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixERR
index|]
operator|.
name|u
operator|.
name|label
argument_list|)
expr_stmt|;
name|ffeste_io_abort_is_temp_
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|ffeste_io_err_
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|(
name|ffeste_io_abort_is_temp_
operator|=
name|iostat
operator|)
condition|)
name|ffeste_io_abort_
operator|=
name|ffecom_temp_label
argument_list|()
expr_stmt|;
else|else
name|ffeste_io_abort_
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|iostat
condition|)
block|{
comment|/* Have IOSTAT= specification.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|FALSE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|ffecom_expr
argument_list|(
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixIOSTAT
index|]
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffeste_io_abort_
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Have no IOSTAT= but have ERR=.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|TRUE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"open"
argument_list|,
name|ffecom_integer_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No IOSTAT= or ERR= specification.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|FALSE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Now prescan, then convert, all the arguments.  */
name|args
operator|=
name|ffeste_io_olist_
argument_list|(
name|errl
operator|||
name|iostat
argument_list|,
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixUNIT
index|]
operator|.
name|u
operator|.
name|expr
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixFILE
index|]
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixSTATUS
index|]
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixACCESS
index|]
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixFORM
index|]
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixRECL
index|]
argument_list|,
operator|&
name|info
operator|->
name|open_spec
index|[
name|FFESTP_openixBLANK
index|]
argument_list|)
expr_stmt|;
comment|/* Don't generate "if (iostat != 0) goto label;" if label is temp abort        label, since we're gonna fall through to there anyway. */
name|ffeste_io_call_
argument_list|(
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtFOPEN
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
operator|!
name|ffeste_io_abort_is_temp_
argument_list|)
expr_stmt|;
comment|/* If we've got a temp label, generate its code here.  */
if|if
condition|(
name|ffeste_io_abort_is_temp_
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|ffeste_io_abort_
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|emit_nop
argument_list|()
expr_stmt|;
name|expand_label
argument_list|(
name|ffeste_io_abort_
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeste_io_err_
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* CLOSE statement.  */
end_comment

begin_function
name|void
name|ffeste_R907
parameter_list|(
name|ffestpCloseStmt
modifier|*
name|info
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ CLOSE ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|info
operator|->
name|close_spec
index|[
name|FFESTP_closeixUNIT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ERR"
argument_list|,
operator|&
name|info
operator|->
name|close_spec
index|[
name|FFESTP_closeixERR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"IOSTAT"
argument_list|,
operator|&
name|info
operator|->
name|close_spec
index|[
name|FFESTP_closeixIOSTAT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"STATUS"
argument_list|,
operator|&
name|info
operator|->
name|close_spec
index|[
name|FFESTP_closeixSTATUS
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|args
decl_stmt|;
name|bool
name|iostat
decl_stmt|;
name|bool
name|errl
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
define|#
directive|define
name|specified
parameter_list|(
name|something
parameter_list|)
value|(info->close_spec[something].kw_or_val_present)
name|iostat
operator|=
name|specified
argument_list|(
name|FFESTP_closeixIOSTAT
argument_list|)
expr_stmt|;
name|errl
operator|=
name|specified
argument_list|(
name|FFESTP_closeixERR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|specified
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
if|if
condition|(
name|errl
condition|)
block|{
name|ffeste_io_err_
operator|=
name|ffeste_io_abort_
operator|=
name|ffecom_lookup_label
argument_list|(
name|info
operator|->
name|close_spec
index|[
name|FFESTP_closeixERR
index|]
operator|.
name|u
operator|.
name|label
argument_list|)
expr_stmt|;
name|ffeste_io_abort_is_temp_
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|ffeste_io_err_
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|(
name|ffeste_io_abort_is_temp_
operator|=
name|iostat
operator|)
condition|)
name|ffeste_io_abort_
operator|=
name|ffecom_temp_label
argument_list|()
expr_stmt|;
else|else
name|ffeste_io_abort_
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|iostat
condition|)
block|{
comment|/* Have IOSTAT= specification.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|FALSE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|ffecom_expr
argument_list|(
name|info
operator|->
name|close_spec
index|[
name|FFESTP_closeixIOSTAT
index|]
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffeste_io_abort_
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Have no IOSTAT= but have ERR=.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|TRUE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"close"
argument_list|,
name|ffecom_integer_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No IOSTAT= or ERR= specification.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|FALSE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Now prescan, then convert, all the arguments.  */
name|args
operator|=
name|ffeste_io_cllist_
argument_list|(
name|errl
operator|||
name|iostat
argument_list|,
name|info
operator|->
name|close_spec
index|[
name|FFESTP_closeixUNIT
index|]
operator|.
name|u
operator|.
name|expr
argument_list|,
operator|&
name|info
operator|->
name|close_spec
index|[
name|FFESTP_closeixSTATUS
index|]
argument_list|)
expr_stmt|;
comment|/* Don't generate "if (iostat != 0) goto label;" if label is temp abort        label, since we're gonna fall through to there anyway. */
name|ffeste_io_call_
argument_list|(
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtFCLOS
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
operator|!
name|ffeste_io_abort_is_temp_
argument_list|)
expr_stmt|;
comment|/* If we've got a temp label, generate its code here. */
if|if
condition|(
name|ffeste_io_abort_is_temp_
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|ffeste_io_abort_
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|emit_nop
argument_list|()
expr_stmt|;
name|expand_label
argument_list|(
name|ffeste_io_abort_
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeste_io_err_
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* READ(...) statement -- start.  */
end_comment

begin_function
name|void
name|ffeste_R909_start
parameter_list|(
name|ffestpReadStmt
modifier|*
name|info
parameter_list|,
name|bool
name|only_format
name|UNUSED
parameter_list|,
name|ffestvUnit
name|unit
parameter_list|,
name|ffestvFormat
name|format
parameter_list|,
name|bool
name|rec
parameter_list|,
name|bool
name|key
name|UNUSED
parameter_list|)
block|{
name|ffeste_check_start_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FFESTV_formatNONE
case|:
if|if
condition|(
name|rec
condition|)
name|fputs
argument_list|(
literal|"+ READ_ufdac"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|key
condition|)
name|fputs
argument_list|(
literal|"+ READ_ufidx"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"+ READ_ufseq"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_formatLABEL
case|:
case|case
name|FFESTV_formatCHAREXPR
case|:
case|case
name|FFESTV_formatINTEXPR
case|:
if|if
condition|(
name|rec
condition|)
name|fputs
argument_list|(
literal|"+ READ_fmdac"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|key
condition|)
name|fputs
argument_list|(
literal|"+ READ_fmidx"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
name|fputs
argument_list|(
literal|"+ READ_fmint"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"+ READ_fmseq"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_formatASTERISK
case|:
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
name|fputs
argument_list|(
literal|"+ READ_lsint"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"+ READ_lsseq"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_formatNAMELIST
case|:
name|fputs
argument_list|(
literal|"+ READ_nlseq"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Unexpected kind of format item in R909 READ"
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|only_format
condition|)
block|{
name|fputc
argument_list|(
literal|' '
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"FORMAT"
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
return|return;
block|}
name|fputs
argument_list|(
literal|" ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixUNIT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"FORMAT"
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ADVANCE"
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixADVANCE
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"EOR"
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixEOR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ERR"
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixERR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"END"
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixEND
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"IOSTAT"
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixIOSTAT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"KEYEQ"
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixKEYEQ
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"KEYGE"
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixKEYGE
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"KEYGT"
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixKEYGT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"KEYID"
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixKEYID
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"NULLS"
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixNULLS
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"REC"
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixREC
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"SIZE"
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixSIZE
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|") "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
block|{
name|ffecomGfrt
name|start
decl_stmt|;
name|ffecomGfrt
name|end
decl_stmt|;
name|tree
name|cilist
decl_stmt|;
name|bool
name|iostat
decl_stmt|;
name|bool
name|errl
decl_stmt|;
name|bool
name|endl
decl_stmt|;
comment|/* First determine the start, per-item, and end run-time functions to        call.  The per-item function is picked by choosing an ffeste function        to call to handle a given item; it knows how to generate a call to the        appropriate run-time function, and is called an "I/O driver".  */
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FFESTV_formatNONE
case|:
comment|/* no FMT= */
name|ffeste_io_driver_
operator|=
name|ffeste_io_douio_
expr_stmt|;
if|if
condition|(
name|rec
condition|)
name|start
operator|=
name|FFECOM_gfrtSRDUE
operator|,
name|end
operator|=
name|FFECOM_gfrtERDUE
expr_stmt|;
if|#
directive|if
literal|0
if|else if (key) 	  start = FFECOM_gfrtSRIUE, end = FFECOM_gfrtERIUE;
endif|#
directive|endif
else|else
name|start
operator|=
name|FFECOM_gfrtSRSUE
operator|,
name|end
operator|=
name|FFECOM_gfrtERSUE
expr_stmt|;
break|break;
case|case
name|FFESTV_formatLABEL
case|:
comment|/* FMT=10 */
case|case
name|FFESTV_formatCHAREXPR
case|:
comment|/* FMT='(I10)' */
case|case
name|FFESTV_formatINTEXPR
case|:
comment|/* FMT=I [after ASSIGN 10 TO I] */
name|ffeste_io_driver_
operator|=
name|ffeste_io_dofio_
expr_stmt|;
if|if
condition|(
name|rec
condition|)
name|start
operator|=
name|FFECOM_gfrtSRDFE
operator|,
name|end
operator|=
name|FFECOM_gfrtERDFE
expr_stmt|;
if|#
directive|if
literal|0
if|else if (key) 	  start = FFECOM_gfrtSRIFE, end = FFECOM_gfrtERIFE;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
name|start
operator|=
name|FFECOM_gfrtSRSFI
operator|,
name|end
operator|=
name|FFECOM_gfrtERSFI
expr_stmt|;
else|else
name|start
operator|=
name|FFECOM_gfrtSRSFE
operator|,
name|end
operator|=
name|FFECOM_gfrtERSFE
expr_stmt|;
break|break;
case|case
name|FFESTV_formatASTERISK
case|:
comment|/* FMT=* */
name|ffeste_io_driver_
operator|=
name|ffeste_io_dolio_
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
name|start
operator|=
name|FFECOM_gfrtSRSLI
operator|,
name|end
operator|=
name|FFECOM_gfrtERSLI
expr_stmt|;
else|else
name|start
operator|=
name|FFECOM_gfrtSRSLE
operator|,
name|end
operator|=
name|FFECOM_gfrtERSLE
expr_stmt|;
break|break;
case|case
name|FFESTV_formatNAMELIST
case|:
comment|/* FMT=FOO or NML=FOO [NAMELIST 					   /FOO/] */
name|ffeste_io_driver_
operator|=
name|NULL
expr_stmt|;
comment|/* No start or driver function. */
name|start
operator|=
name|FFECOM_gfrtSRSNE
operator|,
name|end
operator|=
name|FFECOM_gfrt
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Weird stuff"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|start
operator|=
name|FFECOM_gfrt
operator|,
name|end
operator|=
name|FFECOM_gfrt
expr_stmt|;
break|break;
block|}
name|ffeste_io_endgfrt_
operator|=
name|end
expr_stmt|;
define|#
directive|define
name|specified
parameter_list|(
name|something
parameter_list|)
value|(info->read_spec[something].kw_or_val_present)
name|iostat
operator|=
name|specified
argument_list|(
name|FFESTP_readixIOSTAT
argument_list|)
expr_stmt|;
name|errl
operator|=
name|specified
argument_list|(
name|FFESTP_readixERR
argument_list|)
expr_stmt|;
name|endl
operator|=
name|specified
argument_list|(
name|FFESTP_readixEND
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|specified
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
if|if
condition|(
name|errl
condition|)
block|{
comment|/* Have ERR= specification.   */
name|ffeste_io_err_
operator|=
name|ffecom_lookup_label
argument_list|(
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixERR
index|]
operator|.
name|u
operator|.
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|endl
condition|)
block|{
comment|/* Have both ERR= and END=.  Need a temp label to handle both.  */
name|ffeste_io_end_
operator|=
name|ffecom_lookup_label
argument_list|(
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixEND
index|]
operator|.
name|u
operator|.
name|label
argument_list|)
expr_stmt|;
name|ffeste_io_abort_is_temp_
operator|=
name|TRUE
expr_stmt|;
name|ffeste_io_abort_
operator|=
name|ffecom_temp_label
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Have ERR= but no END=.  */
name|ffeste_io_end_
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|(
name|ffeste_io_abort_is_temp_
operator|=
name|iostat
operator|)
condition|)
name|ffeste_io_abort_
operator|=
name|ffecom_temp_label
argument_list|()
expr_stmt|;
else|else
name|ffeste_io_abort_
operator|=
name|ffeste_io_err_
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* No ERR= specification.  */
name|ffeste_io_err_
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|endl
condition|)
block|{
comment|/* Have END= but no ERR=.  */
name|ffeste_io_end_
operator|=
name|ffecom_lookup_label
argument_list|(
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixEND
index|]
operator|.
name|u
operator|.
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffeste_io_abort_is_temp_
operator|=
name|iostat
operator|)
condition|)
name|ffeste_io_abort_
operator|=
name|ffecom_temp_label
argument_list|()
expr_stmt|;
else|else
name|ffeste_io_abort_
operator|=
name|ffeste_io_end_
expr_stmt|;
block|}
else|else
block|{
comment|/* Have no ERR= or END=.  */
name|ffeste_io_end_
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|(
name|ffeste_io_abort_is_temp_
operator|=
name|iostat
operator|)
condition|)
name|ffeste_io_abort_
operator|=
name|ffecom_temp_label
argument_list|()
expr_stmt|;
else|else
name|ffeste_io_abort_
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|iostat
condition|)
block|{
comment|/* Have IOSTAT= specification.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|FALSE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|ffecom_expr
argument_list|(
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixIOSTAT
index|]
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffeste_io_abort_
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Have no IOSTAT= but have ERR= and/or END=.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|TRUE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"read"
argument_list|,
name|ffecom_integer_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No IOSTAT=, ERR=, or END= specification.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|FALSE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Now prescan, then convert, all the arguments.  */
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
name|cilist
operator|=
name|ffeste_io_icilist_
argument_list|(
name|errl
operator|||
name|iostat
argument_list|,
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixUNIT
index|]
operator|.
name|u
operator|.
name|expr
argument_list|,
name|endl
operator|||
name|iostat
argument_list|,
name|format
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
argument_list|)
expr_stmt|;
else|else
name|cilist
operator|=
name|ffeste_io_cilist_
argument_list|(
name|errl
operator|||
name|iostat
argument_list|,
name|unit
argument_list|,
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixUNIT
index|]
operator|.
name|u
operator|.
name|expr
argument_list|,
literal|5
argument_list|,
name|endl
operator|||
name|iostat
argument_list|,
name|format
argument_list|,
operator|&
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
argument_list|,
name|rec
argument_list|,
name|info
operator|->
name|read_spec
index|[
name|FFESTP_readixREC
index|]
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
comment|/* If there is no end function, then there are no item functions (i.e.        it's a NAMELIST), and vice versa by the way.  In this situation, don't        generate the "if (iostat != 0) goto label;" if the label is temp abort        label, since we're gonna fall through to there anyway.  */
name|ffeste_io_call_
argument_list|(
name|ffecom_call_gfrt
argument_list|(
name|start
argument_list|,
name|cilist
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
operator|(
operator|!
name|ffeste_io_abort_is_temp_
operator|)
operator|||
operator|(
name|end
operator|!=
name|FFECOM_gfrt
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* READ statement -- I/O item.  */
end_comment

begin_function
name|void
name|ffeste_R909_item
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffeste_check_item_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return;
comment|/* Strip parens off items such as in "READ *,(A)".  This is really a bug      in the user's code, but I've been told lots of code does this.  */
while|while
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opPAREN
condition|)
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
return|return;
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opIMPDO
condition|)
name|ffeste_io_impdo_
argument_list|(
name|expr
argument_list|,
name|expr_token
argument_list|)
expr_stmt|;
else|else
block|{
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffecom_prepare_arg_ptr_to_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
name|ffeste_io_call_
argument_list|(
call|(
modifier|*
name|ffeste_io_driver_
call|)
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* READ statement -- end.  */
end_comment

begin_function
name|void
name|ffeste_R909_finish
parameter_list|()
block|{
name|ffeste_check_finish_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
comment|/* Don't generate "if (iostat != 0) goto label;" if label is temp abort      label, since we're gonna fall through to there anyway. */
if|if
condition|(
name|ffeste_io_endgfrt_
operator|!=
name|FFECOM_gfrt
condition|)
name|ffeste_io_call_
argument_list|(
name|ffecom_call_gfrt
argument_list|(
name|ffeste_io_endgfrt_
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
operator|!
name|ffeste_io_abort_is_temp_
argument_list|)
expr_stmt|;
comment|/* If we've got a temp label, generate its code here and have it fan out      to the END= or ERR= label as appropriate. */
if|if
condition|(
name|ffeste_io_abort_is_temp_
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|ffeste_io_abort_
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|emit_nop
argument_list|()
expr_stmt|;
name|expand_label
argument_list|(
name|ffeste_io_abort_
argument_list|)
expr_stmt|;
comment|/* "if (iostat<0) goto end_label;".  */
if|if
condition|(
operator|(
name|ffeste_io_end_
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|ffeste_io_end_
argument_list|)
operator|!=
name|ERROR_MARK
operator|)
condition|)
block|{
name|expand_start_cond
argument_list|(
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffeste_io_iostat_
argument_list|,
name|ffecom_integer_zero_node
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_goto
argument_list|(
name|ffeste_io_end_
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
comment|/* "if (iostat>0) goto err_label;".  */
if|if
condition|(
operator|(
name|ffeste_io_err_
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|ffeste_io_err_
argument_list|)
operator|!=
name|ERROR_MARK
operator|)
condition|)
block|{
name|expand_start_cond
argument_list|(
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|GT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffeste_io_iostat_
argument_list|,
name|ffecom_integer_zero_node
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_goto
argument_list|(
name|ffeste_io_err_
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
block|}
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* WRITE statement -- start.  */
end_comment

begin_function
name|void
name|ffeste_R910_start
parameter_list|(
name|ffestpWriteStmt
modifier|*
name|info
parameter_list|,
name|ffestvUnit
name|unit
parameter_list|,
name|ffestvFormat
name|format
parameter_list|,
name|bool
name|rec
parameter_list|)
block|{
name|ffeste_check_start_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FFESTV_formatNONE
case|:
if|if
condition|(
name|rec
condition|)
name|fputs
argument_list|(
literal|"+ WRITE_ufdac ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"+ WRITE_ufseq_or_idx ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_formatLABEL
case|:
case|case
name|FFESTV_formatCHAREXPR
case|:
case|case
name|FFESTV_formatINTEXPR
case|:
if|if
condition|(
name|rec
condition|)
name|fputs
argument_list|(
literal|"+ WRITE_fmdac ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
name|fputs
argument_list|(
literal|"+ WRITE_fmint ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"+ WRITE_fmseq_or_idx ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_formatASTERISK
case|:
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
name|fputs
argument_list|(
literal|"+ WRITE_lsint ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"+ WRITE_lsseq ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_formatNAMELIST
case|:
name|fputs
argument_list|(
literal|"+ WRITE_nlseq ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Unexpected kind of format item in R910 WRITE"
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ffeste_subr_file_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|info
operator|->
name|write_spec
index|[
name|FFESTP_writeixUNIT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"FORMAT"
argument_list|,
operator|&
name|info
operator|->
name|write_spec
index|[
name|FFESTP_writeixFORMAT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ADVANCE"
argument_list|,
operator|&
name|info
operator|->
name|write_spec
index|[
name|FFESTP_writeixADVANCE
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"EOR"
argument_list|,
operator|&
name|info
operator|->
name|write_spec
index|[
name|FFESTP_writeixEOR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ERR"
argument_list|,
operator|&
name|info
operator|->
name|write_spec
index|[
name|FFESTP_writeixERR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"IOSTAT"
argument_list|,
operator|&
name|info
operator|->
name|write_spec
index|[
name|FFESTP_writeixIOSTAT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"REC"
argument_list|,
operator|&
name|info
operator|->
name|write_spec
index|[
name|FFESTP_writeixREC
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|") "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
block|{
name|ffecomGfrt
name|start
decl_stmt|;
name|ffecomGfrt
name|end
decl_stmt|;
name|tree
name|cilist
decl_stmt|;
name|bool
name|iostat
decl_stmt|;
name|bool
name|errl
decl_stmt|;
comment|/* First determine the start, per-item, and end run-time functions to        call.  The per-item function is picked by choosing an ffeste function        to call to handle a given item; it knows how to generate a call to the        appropriate run-time function, and is called an "I/O driver".  */
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FFESTV_formatNONE
case|:
comment|/* no FMT= */
name|ffeste_io_driver_
operator|=
name|ffeste_io_douio_
expr_stmt|;
if|if
condition|(
name|rec
condition|)
name|start
operator|=
name|FFECOM_gfrtSWDUE
operator|,
name|end
operator|=
name|FFECOM_gfrtEWDUE
expr_stmt|;
else|else
name|start
operator|=
name|FFECOM_gfrtSWSUE
operator|,
name|end
operator|=
name|FFECOM_gfrtEWSUE
expr_stmt|;
break|break;
case|case
name|FFESTV_formatLABEL
case|:
comment|/* FMT=10 */
case|case
name|FFESTV_formatCHAREXPR
case|:
comment|/* FMT='(I10)' */
case|case
name|FFESTV_formatINTEXPR
case|:
comment|/* FMT=I [after ASSIGN 10 TO I] */
name|ffeste_io_driver_
operator|=
name|ffeste_io_dofio_
expr_stmt|;
if|if
condition|(
name|rec
condition|)
name|start
operator|=
name|FFECOM_gfrtSWDFE
operator|,
name|end
operator|=
name|FFECOM_gfrtEWDFE
expr_stmt|;
elseif|else
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
name|start
operator|=
name|FFECOM_gfrtSWSFI
operator|,
name|end
operator|=
name|FFECOM_gfrtEWSFI
expr_stmt|;
else|else
name|start
operator|=
name|FFECOM_gfrtSWSFE
operator|,
name|end
operator|=
name|FFECOM_gfrtEWSFE
expr_stmt|;
break|break;
case|case
name|FFESTV_formatASTERISK
case|:
comment|/* FMT=* */
name|ffeste_io_driver_
operator|=
name|ffeste_io_dolio_
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
name|start
operator|=
name|FFECOM_gfrtSWSLI
operator|,
name|end
operator|=
name|FFECOM_gfrtEWSLI
expr_stmt|;
else|else
name|start
operator|=
name|FFECOM_gfrtSWSLE
operator|,
name|end
operator|=
name|FFECOM_gfrtEWSLE
expr_stmt|;
break|break;
case|case
name|FFESTV_formatNAMELIST
case|:
comment|/* FMT=FOO or NML=FOO [NAMELIST 					   /FOO/] */
name|ffeste_io_driver_
operator|=
name|NULL
expr_stmt|;
comment|/* No start or driver function. */
name|start
operator|=
name|FFECOM_gfrtSWSNE
operator|,
name|end
operator|=
name|FFECOM_gfrt
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Weird stuff"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|start
operator|=
name|FFECOM_gfrt
operator|,
name|end
operator|=
name|FFECOM_gfrt
expr_stmt|;
break|break;
block|}
name|ffeste_io_endgfrt_
operator|=
name|end
expr_stmt|;
define|#
directive|define
name|specified
parameter_list|(
name|something
parameter_list|)
value|(info->write_spec[something].kw_or_val_present)
name|iostat
operator|=
name|specified
argument_list|(
name|FFESTP_writeixIOSTAT
argument_list|)
expr_stmt|;
name|errl
operator|=
name|specified
argument_list|(
name|FFESTP_writeixERR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|specified
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffeste_io_end_
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|errl
condition|)
block|{
comment|/* Have ERR= specification.   */
name|ffeste_io_err_
operator|=
name|ffeste_io_abort_
operator|=
name|ffecom_lookup_label
argument_list|(
name|info
operator|->
name|write_spec
index|[
name|FFESTP_writeixERR
index|]
operator|.
name|u
operator|.
name|label
argument_list|)
expr_stmt|;
name|ffeste_io_abort_is_temp_
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* No ERR= specification.  */
name|ffeste_io_err_
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|(
name|ffeste_io_abort_is_temp_
operator|=
name|iostat
operator|)
condition|)
name|ffeste_io_abort_
operator|=
name|ffecom_temp_label
argument_list|()
expr_stmt|;
else|else
name|ffeste_io_abort_
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|iostat
condition|)
block|{
comment|/* Have IOSTAT= specification.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|FALSE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|ffecom_expr
argument_list|(
name|info
operator|->
name|write_spec
index|[
name|FFESTP_writeixIOSTAT
index|]
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffeste_io_abort_
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Have no IOSTAT= but have ERR=.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|TRUE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"write"
argument_list|,
name|ffecom_integer_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No IOSTAT= or ERR= specification.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|FALSE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Now prescan, then convert, all the arguments.  */
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
name|cilist
operator|=
name|ffeste_io_icilist_
argument_list|(
name|errl
operator|||
name|iostat
argument_list|,
name|info
operator|->
name|write_spec
index|[
name|FFESTP_writeixUNIT
index|]
operator|.
name|u
operator|.
name|expr
argument_list|,
name|FALSE
argument_list|,
name|format
argument_list|,
operator|&
name|info
operator|->
name|write_spec
index|[
name|FFESTP_writeixFORMAT
index|]
argument_list|)
expr_stmt|;
else|else
name|cilist
operator|=
name|ffeste_io_cilist_
argument_list|(
name|errl
operator|||
name|iostat
argument_list|,
name|unit
argument_list|,
name|info
operator|->
name|write_spec
index|[
name|FFESTP_writeixUNIT
index|]
operator|.
name|u
operator|.
name|expr
argument_list|,
literal|6
argument_list|,
name|FALSE
argument_list|,
name|format
argument_list|,
operator|&
name|info
operator|->
name|write_spec
index|[
name|FFESTP_writeixFORMAT
index|]
argument_list|,
name|rec
argument_list|,
name|info
operator|->
name|write_spec
index|[
name|FFESTP_writeixREC
index|]
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
comment|/* If there is no end function, then there are no item functions (i.e.        it's a NAMELIST), and vice versa by the way.  In this situation, don't        generate the "if (iostat != 0) goto label;" if the label is temp abort        label, since we're gonna fall through to there anyway.  */
name|ffeste_io_call_
argument_list|(
name|ffecom_call_gfrt
argument_list|(
name|start
argument_list|,
name|cilist
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
operator|(
operator|!
name|ffeste_io_abort_is_temp_
operator|)
operator|||
operator|(
name|end
operator|!=
name|FFECOM_gfrt
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* WRITE statement -- I/O item.  */
end_comment

begin_function
name|void
name|ffeste_R910_item
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffeste_check_item_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
return|return;
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opIMPDO
condition|)
name|ffeste_io_impdo_
argument_list|(
name|expr
argument_list|,
name|expr_token
argument_list|)
expr_stmt|;
else|else
block|{
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffecom_prepare_arg_ptr_to_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
name|ffeste_io_call_
argument_list|(
call|(
modifier|*
name|ffeste_io_driver_
call|)
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* WRITE statement -- end.  */
end_comment

begin_function
name|void
name|ffeste_R910_finish
parameter_list|()
block|{
name|ffeste_check_finish_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
comment|/* Don't generate "if (iostat != 0) goto label;" if label is temp abort      label, since we're gonna fall through to there anyway. */
if|if
condition|(
name|ffeste_io_endgfrt_
operator|!=
name|FFECOM_gfrt
condition|)
name|ffeste_io_call_
argument_list|(
name|ffecom_call_gfrt
argument_list|(
name|ffeste_io_endgfrt_
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
operator|!
name|ffeste_io_abort_is_temp_
argument_list|)
expr_stmt|;
comment|/* If we've got a temp label, generate its code here. */
if|if
condition|(
name|ffeste_io_abort_is_temp_
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|ffeste_io_abort_
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|emit_nop
argument_list|()
expr_stmt|;
name|expand_label
argument_list|(
name|ffeste_io_abort_
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeste_io_err_
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* PRINT statement -- start.  */
end_comment

begin_function
name|void
name|ffeste_R911_start
parameter_list|(
name|ffestpPrintStmt
modifier|*
name|info
parameter_list|,
name|ffestvFormat
name|format
parameter_list|)
block|{
name|ffeste_check_start_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FFESTV_formatLABEL
case|:
case|case
name|FFESTV_formatCHAREXPR
case|:
case|case
name|FFESTV_formatINTEXPR
case|:
name|fputs
argument_list|(
literal|"+ PRINT_fm "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_formatASTERISK
case|:
name|fputs
argument_list|(
literal|"+ PRINT_ls "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_formatNAMELIST
case|:
name|fputs
argument_list|(
literal|"+ PRINT_nl "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Unexpected kind of format item in R911 PRINT"
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ffeste_subr_file_
argument_list|(
literal|"FORMAT"
argument_list|,
operator|&
name|info
operator|->
name|print_spec
index|[
name|FFESTP_printixFORMAT
index|]
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
block|{
name|ffecomGfrt
name|start
decl_stmt|;
name|ffecomGfrt
name|end
decl_stmt|;
name|tree
name|cilist
decl_stmt|;
comment|/* First determine the start, per-item, and end run-time functions to        call.  The per-item function is picked by choosing an ffeste function        to call to handle a given item; it knows how to generate a call to the        appropriate run-time function, and is called an "I/O driver".  */
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FFESTV_formatLABEL
case|:
comment|/* FMT=10 */
case|case
name|FFESTV_formatCHAREXPR
case|:
comment|/* FMT='(I10)' */
case|case
name|FFESTV_formatINTEXPR
case|:
comment|/* FMT=I [after ASSIGN 10 TO I] */
name|ffeste_io_driver_
operator|=
name|ffeste_io_dofio_
expr_stmt|;
name|start
operator|=
name|FFECOM_gfrtSWSFE
operator|,
name|end
operator|=
name|FFECOM_gfrtEWSFE
expr_stmt|;
break|break;
case|case
name|FFESTV_formatASTERISK
case|:
comment|/* FMT=* */
name|ffeste_io_driver_
operator|=
name|ffeste_io_dolio_
expr_stmt|;
name|start
operator|=
name|FFECOM_gfrtSWSLE
operator|,
name|end
operator|=
name|FFECOM_gfrtEWSLE
expr_stmt|;
break|break;
case|case
name|FFESTV_formatNAMELIST
case|:
comment|/* FMT=FOO or NML=FOO [NAMELIST 					   /FOO/] */
name|ffeste_io_driver_
operator|=
name|NULL
expr_stmt|;
comment|/* No start or driver function. */
name|start
operator|=
name|FFECOM_gfrtSWSNE
operator|,
name|end
operator|=
name|FFECOM_gfrt
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Weird stuff"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|start
operator|=
name|FFECOM_gfrt
operator|,
name|end
operator|=
name|FFECOM_gfrt
expr_stmt|;
break|break;
block|}
name|ffeste_io_endgfrt_
operator|=
name|end
expr_stmt|;
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffeste_io_end_
operator|=
name|NULL_TREE
expr_stmt|;
name|ffeste_io_err_
operator|=
name|NULL_TREE
expr_stmt|;
name|ffeste_io_abort_
operator|=
name|NULL_TREE
expr_stmt|;
name|ffeste_io_abort_is_temp_
operator|=
name|FALSE
expr_stmt|;
name|ffeste_io_iostat_is_temp_
operator|=
name|FALSE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now prescan, then convert, all the arguments.  */
name|cilist
operator|=
name|ffeste_io_cilist_
argument_list|(
name|FALSE
argument_list|,
name|FFESTV_unitNONE
argument_list|,
name|NULL
argument_list|,
literal|6
argument_list|,
name|FALSE
argument_list|,
name|format
argument_list|,
operator|&
name|info
operator|->
name|print_spec
index|[
name|FFESTP_printixFORMAT
index|]
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If there is no end function, then there are no item functions (i.e.        it's a NAMELIST), and vice versa by the way.  In this situation, don't        generate the "if (iostat != 0) goto label;" if the label is temp abort        label, since we're gonna fall through to there anyway.  */
name|ffeste_io_call_
argument_list|(
name|ffecom_call_gfrt
argument_list|(
name|start
argument_list|,
name|cilist
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
operator|(
operator|!
name|ffeste_io_abort_is_temp_
operator|)
operator|||
operator|(
name|end
operator|!=
name|FFECOM_gfrt
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* PRINT statement -- I/O item.  */
end_comment

begin_function
name|void
name|ffeste_R911_item
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffeste_check_item_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
return|return;
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opIMPDO
condition|)
name|ffeste_io_impdo_
argument_list|(
name|expr
argument_list|,
name|expr_token
argument_list|)
expr_stmt|;
else|else
block|{
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffecom_prepare_arg_ptr_to_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
name|ffeste_io_call_
argument_list|(
call|(
modifier|*
name|ffeste_io_driver_
call|)
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* PRINT statement -- end.  */
end_comment

begin_function
name|void
name|ffeste_R911_finish
parameter_list|()
block|{
name|ffeste_check_finish_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
if|if
condition|(
name|ffeste_io_endgfrt_
operator|!=
name|FFECOM_gfrt
condition|)
name|ffeste_io_call_
argument_list|(
name|ffecom_call_gfrt
argument_list|(
name|ffeste_io_endgfrt_
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* BACKSPACE statement.  */
end_comment

begin_function
name|void
name|ffeste_R919
parameter_list|(
name|ffestpBeruStmt
modifier|*
name|info
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ BACKSPACE ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|info
operator|->
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ERR"
argument_list|,
operator|&
name|info
operator|->
name|beru_spec
index|[
name|FFESTP_beruixERR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"IOSTAT"
argument_list|,
operator|&
name|info
operator|->
name|beru_spec
index|[
name|FFESTP_beruixIOSTAT
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_subr_beru_
argument_list|(
name|info
argument_list|,
name|FFECOM_gfrtFBACK
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ENDFILE statement.  */
end_comment

begin_function
name|void
name|ffeste_R920
parameter_list|(
name|ffestpBeruStmt
modifier|*
name|info
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ ENDFILE ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|info
operator|->
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ERR"
argument_list|,
operator|&
name|info
operator|->
name|beru_spec
index|[
name|FFESTP_beruixERR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"IOSTAT"
argument_list|,
operator|&
name|info
operator|->
name|beru_spec
index|[
name|FFESTP_beruixIOSTAT
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_subr_beru_
argument_list|(
name|info
argument_list|,
name|FFECOM_gfrtFEND
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* REWIND statement.  */
end_comment

begin_function
name|void
name|ffeste_R921
parameter_list|(
name|ffestpBeruStmt
modifier|*
name|info
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ REWIND ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|info
operator|->
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ERR"
argument_list|,
operator|&
name|info
operator|->
name|beru_spec
index|[
name|FFESTP_beruixERR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"IOSTAT"
argument_list|,
operator|&
name|info
operator|->
name|beru_spec
index|[
name|FFESTP_beruixIOSTAT
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|ffeste_subr_beru_
argument_list|(
name|info
argument_list|,
name|FFECOM_gfrtFREW
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* INQUIRE statement (non-IOLENGTH version).  */
end_comment

begin_function
name|void
name|ffeste_R923A
parameter_list|(
name|ffestpInquireStmt
modifier|*
name|info
parameter_list|,
name|bool
name|by_file
name|UNUSED
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
if|if
condition|(
name|by_file
condition|)
block|{
name|fputs
argument_list|(
literal|"+ INQUIRE_file ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"FILE"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixFILE
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|"+ INQUIRE_unit ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixUNIT
index|]
argument_list|)
expr_stmt|;
block|}
name|ffeste_subr_file_
argument_list|(
literal|"ACCESS"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixACCESS
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ACTION"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixACTION
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"BLANK"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixBLANK
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"CARRIAGECONTROL"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixCARRIAGECONTROL
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"DEFAULTFILE"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixDEFAULTFILE
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"DELIM"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixDELIM
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"DIRECT"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixDIRECT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ERR"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixERR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"EXIST"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixEXIST
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"FORM"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixFORM
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"FORMATTED"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixFORMATTED
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"IOSTAT"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixIOSTAT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"KEYED"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixKEYED
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"NAME"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixNAME
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"NAMED"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixNAMED
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"NEXTREC"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixNEXTREC
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"NUMBER"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixNUMBER
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"OPENED"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixOPENED
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ORGANIZATION"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixORGANIZATION
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"PAD"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixPAD
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"POSITION"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixPOSITION
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"READ"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixREAD
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"READWRITE"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixREADWRITE
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"RECL"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixRECL
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"RECORDTYPE"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixRECORDTYPE
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"SEQUENTIAL"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixSEQUENTIAL
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"UNFORMATTED"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixUNFORMATTED
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"WRITE"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixWRITE
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|args
decl_stmt|;
name|bool
name|iostat
decl_stmt|;
name|bool
name|errl
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
define|#
directive|define
name|specified
parameter_list|(
name|something
parameter_list|)
value|(info->inquire_spec[something].kw_or_val_present)
name|iostat
operator|=
name|specified
argument_list|(
name|FFESTP_inquireixIOSTAT
argument_list|)
expr_stmt|;
name|errl
operator|=
name|specified
argument_list|(
name|FFESTP_inquireixERR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|specified
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
if|if
condition|(
name|errl
condition|)
block|{
name|ffeste_io_err_
operator|=
name|ffeste_io_abort_
operator|=
name|ffecom_lookup_label
argument_list|(
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixERR
index|]
operator|.
name|u
operator|.
name|label
argument_list|)
expr_stmt|;
name|ffeste_io_abort_is_temp_
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|ffeste_io_err_
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|(
name|ffeste_io_abort_is_temp_
operator|=
name|iostat
operator|)
condition|)
name|ffeste_io_abort_
operator|=
name|ffecom_temp_label
argument_list|()
expr_stmt|;
else|else
name|ffeste_io_abort_
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|iostat
condition|)
block|{
comment|/* Have IOSTAT= specification.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|FALSE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|ffecom_expr
argument_list|(
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixIOSTAT
index|]
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffeste_io_abort_
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Have no IOSTAT= but have ERR=.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|TRUE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"inquire"
argument_list|,
name|ffecom_integer_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No IOSTAT= or ERR= specification.  */
name|ffeste_io_iostat_is_temp_
operator|=
name|FALSE
expr_stmt|;
name|ffeste_io_iostat_
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Now prescan, then convert, all the arguments.  */
name|args
operator|=
name|ffeste_io_inlist_
argument_list|(
name|errl
operator|||
name|iostat
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixUNIT
index|]
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixFILE
index|]
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixEXIST
index|]
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixOPENED
index|]
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixNUMBER
index|]
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixNAMED
index|]
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixNAME
index|]
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixACCESS
index|]
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixSEQUENTIAL
index|]
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixDIRECT
index|]
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixFORM
index|]
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixFORMATTED
index|]
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixUNFORMATTED
index|]
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixRECL
index|]
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixNEXTREC
index|]
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixBLANK
index|]
argument_list|)
expr_stmt|;
comment|/* Don't generate "if (iostat != 0) goto label;" if label is temp abort        label, since we're gonna fall through to there anyway. */
name|ffeste_io_call_
argument_list|(
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtFINQU
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
operator|!
name|ffeste_io_abort_is_temp_
argument_list|)
expr_stmt|;
comment|/* If we've got a temp label, generate its code here.  */
if|if
condition|(
name|ffeste_io_abort_is_temp_
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|ffeste_io_abort_
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|emit_nop
argument_list|()
expr_stmt|;
name|expand_label
argument_list|(
name|ffeste_io_abort_
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeste_io_err_
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* INQUIRE(IOLENGTH=expr) statement -- start.  */
end_comment

begin_function
name|void
name|ffeste_R923B_start
parameter_list|(
name|ffestpInquireStmt
modifier|*
name|info
name|UNUSED
parameter_list|)
block|{
name|ffeste_check_start_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ INQUIRE ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"IOLENGTH"
argument_list|,
operator|&
name|info
operator|->
name|inquire_spec
index|[
name|FFESTP_inquireixIOLENGTH
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|") "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|assert
argument_list|(
literal|"INQUIRE(IOLENGTH=<var>) not implemented yet! ~~~"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* INQUIRE(IOLENGTH=expr) statement -- I/O item.  */
end_comment

begin_function
name|void
name|ffeste_R923B_item
parameter_list|(
name|ffebld
name|expr
name|UNUSED
parameter_list|)
block|{
name|ffeste_check_item_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* INQUIRE(IOLENGTH=expr) statement -- end.  */
end_comment

begin_function
name|void
name|ffeste_R923B_finish
parameter_list|()
block|{
name|ffeste_check_finish_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffeste_R1001 -- FORMAT statement     ffeste_R1001(format_list);  */
end_comment

begin_function
name|void
name|ffeste_R1001
parameter_list|(
name|ffests
name|s
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"$ FORMAT %.*s\n"
argument_list|,
operator|(
name|int
operator|)
name|ffests_length
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffests_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|ttype
decl_stmt|;
name|tree
name|maxindex
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|assert
argument_list|(
name|ffeste_label_formatdef_
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|t
operator|=
name|build_string
argument_list|(
name|ffests_length
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffests_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|build_type_variant
argument_list|(
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_range_type
argument_list|(
name|integer_type_node
argument_list|,
name|integer_one_node
argument_list|,
name|build_int_2
argument_list|(
name|ffests_length
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|var
operator|=
name|ffecom_lookup_label
argument_list|(
name|ffeste_label_formatdef_
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
operator|=
name|t
expr_stmt|;
name|maxindex
operator|=
name|build_int_2
argument_list|(
name|ffests_length
argument_list|(
name|s
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttype
operator|=
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|ttype
argument_list|)
operator|=
name|build_range_type
argument_list|(
name|integer_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|maxindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
operator|=
name|TYPE_DOMAIN
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|var
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_decl
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|ffeste_label_formatdef_
operator|=
name|NULL
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* END PROGRAM.  */
end_comment

begin_function
name|void
name|ffeste_R1103
parameter_list|()
block|{
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ END_PROGRAM\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* END BLOCK DATA.  */
end_comment

begin_function
name|void
name|ffeste_R1112
parameter_list|()
block|{
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"* END_BLOCK_DATA\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* CALL statement.  */
end_comment

begin_function
name|void
name|ffeste_R1212
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ CALL "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|ffebld
name|args
init|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|ffebld
name|arg
decl_stmt|;
name|ffebld
name|labels
init|=
name|NULL
decl_stmt|;
comment|/* First in list of LABTERs. */
name|ffebld
name|prevlabels
init|=
name|NULL
decl_stmt|;
name|ffebld
name|prevargs
init|=
name|NULL
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
comment|/* Here we split the list at ffebld_right(expr) into two lists: one at        ffebld_right(expr) consisting of all items that are not LABTERs, the        other at labels consisting of all items that are LABTERs.  Then, if        the latter list is NULL, we have an ordinary call, else we have a call        with alternate returns. */
for|for
control|(
name|args
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
init|;
name|args
operator|!=
name|NULL
condition|;
name|args
operator|=
name|ffebld_trail
argument_list|(
name|args
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|arg
operator|=
name|ffebld_head
argument_list|(
name|args
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|arg
argument_list|)
operator|!=
name|FFEBLD_opLABTER
operator|)
condition|)
block|{
if|if
condition|(
name|prevargs
operator|==
name|NULL
condition|)
block|{
name|prevargs
operator|=
name|args
expr_stmt|;
name|ffebld_set_right
argument_list|(
name|expr
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffebld_set_trail
argument_list|(
name|prevargs
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|prevargs
operator|=
name|args
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|prevlabels
operator|==
name|NULL
condition|)
block|{
name|prevlabels
operator|=
name|labels
operator|=
name|args
expr_stmt|;
block|}
else|else
block|{
name|ffebld_set_trail
argument_list|(
name|prevlabels
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|prevlabels
operator|=
name|args
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|prevlabels
operator|==
name|NULL
condition|)
name|labels
operator|=
name|NULL
expr_stmt|;
else|else
name|ffebld_set_trail
argument_list|(
name|prevlabels
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevargs
operator|==
name|NULL
condition|)
name|ffebld_set_right
argument_list|(
name|expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ffebld_set_trail
argument_list|(
name|prevargs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
comment|/* No temporaries are actually needed at this level, but we go        through the motions anyway, just to be sure in case they do        get made.  Temporaries needed for arguments should be in the        scopes of inner blocks, and if clean-up actions are supported,        such as CALL-ing an intrinsic that writes to an argument of one        type when a variable of a different type is provided (requiring        assignment to the variable from a temporary after the library        routine returns), the clean-up must be done by the expression        evaluator, generally, to handle alternate returns (which we hope        won't ever be supported by intrinsics, but might be a similar        issue, such as CALL-ing an F90-style subroutine with an INTERFACE        block).  That implies the expression evaluator will have to        recognize the need for its own temporary anyway, meaning it'll        construct a block within the one constructed here.  */
name|ffecom_prepare_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|labels
operator|==
name|NULL
condition|)
name|expand_expr_stmt
argument_list|(
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|texpr
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|tree
name|tlabel
decl_stmt|;
name|int
name|caseno
decl_stmt|;
name|int
name|pushok
decl_stmt|;
name|tree
name|duplicate
decl_stmt|;
name|ffebld
name|label
decl_stmt|;
name|texpr
operator|=
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expand_start_case
argument_list|(
literal|0
argument_list|,
name|texpr
argument_list|,
name|TREE_TYPE
argument_list|(
name|texpr
argument_list|)
argument_list|,
literal|"CALL statement"
argument_list|)
expr_stmt|;
for|for
control|(
name|caseno
operator|=
literal|1
operator|,
name|label
operator|=
name|labels
init|;
name|label
operator|!=
name|NULL
condition|;
operator|++
name|caseno
operator|,
name|label
operator|=
name|ffebld_trail
argument_list|(
name|label
argument_list|)
control|)
block|{
name|value
operator|=
name|build_int_2
argument_list|(
name|caseno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tlabel
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pushok
operator|=
name|pushcase
argument_list|(
name|value
argument_list|,
name|convert
argument_list|,
name|tlabel
argument_list|,
operator|&
name|duplicate
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pushok
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tlabel
operator|=
name|ffecom_lookup_label
argument_list|(
name|ffebld_labter
argument_list|(
name|ffebld_head
argument_list|(
name|label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tlabel
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|tlabel
argument_list|)
operator|==
name|ERROR_MARK
operator|)
condition|)
continue|continue;
name|TREE_USED
argument_list|(
name|tlabel
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_goto
argument_list|(
name|tlabel
argument_list|)
expr_stmt|;
block|}
name|expand_end_case
argument_list|(
name|texpr
argument_list|)
expr_stmt|;
block|}
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* END FUNCTION.  */
end_comment

begin_function
name|void
name|ffeste_R1221
parameter_list|()
block|{
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ END_FUNCTION\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* END SUBROUTINE.  */
end_comment

begin_function
name|void
name|ffeste_R1225
parameter_list|()
block|{
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"+ END_SUBROUTINE\n"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ENTRY statement.  */
end_comment

begin_function
name|void
name|ffeste_R1226
parameter_list|(
name|ffesymbol
name|entry
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"+ ENTRY %s"
argument_list|,
name|ffesymbol_text
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_dummyargs
argument_list|(
name|entry
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ffebld
name|argh
decl_stmt|;
name|fputc
argument_list|(
literal|'('
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
for|for
control|(
name|argh
operator|=
name|ffesymbol_dummyargs
argument_list|(
name|entry
argument_list|)
init|;
name|argh
operator|!=
name|NULL
condition|;
name|argh
operator|=
name|ffebld_trail
argument_list|(
name|argh
argument_list|)
control|)
block|{
name|assert
argument_list|(
name|ffebld_head
argument_list|(
name|argh
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|ffebld_head
argument_list|(
name|argh
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opSYMTER
case|:
name|fputs
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffebld_symter
argument_list|(
name|ffebld_head
argument_list|(
name|argh
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opSTAR
case|:
name|fputc
argument_list|(
literal|'*'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fputc
argument_list|(
literal|'?'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|ffebld_head
argument_list|(
name|argh
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'?'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffebld_trail
argument_list|(
name|argh
argument_list|)
operator|!=
name|NULL
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|')'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|label
init|=
name|ffesymbol_hook
argument_list|(
name|entry
argument_list|)
operator|.
name|length_tree
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|error_mark_node
condition|)
return|return;
name|DECL_INITIAL
argument_list|(
name|label
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|emit_nop
argument_list|()
expr_stmt|;
name|expand_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* RETURN statement.  */
end_comment

begin_function
name|void
name|ffeste_R1227
parameter_list|(
name|ffestw
name|block
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|"+ RETURN\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|"+ RETURN_alternate "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
name|tree
name|rtn
decl_stmt|;
name|ffeste_emit_line_note_
argument_list|()
expr_stmt|;
name|ffeste_start_stmt_
argument_list|()
expr_stmt|;
name|ffecom_prepare_return_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
name|rtn
operator|=
name|ffecom_return_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rtn
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|rtn
operator|==
name|error_mark_node
operator|)
condition|)
name|expand_null_return
argument_list|()
expr_stmt|;
else|else
block|{
name|tree
name|result
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
name|error_mark_node
operator|)
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|!=
name|error_mark_node
operator|)
condition|)
name|expand_return
argument_list|(
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|result
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|rtn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
name|ffeste_end_stmt_
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* REWRITE statement -- start.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
name|void
name|ffeste_V018_start
parameter_list|(
name|ffestpRewriteStmt
modifier|*
name|info
parameter_list|,
name|ffestvFormat
name|format
parameter_list|)
block|{
name|ffeste_check_start_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FFESTV_formatNONE
case|:
name|fputs
argument_list|(
literal|"+ REWRITE_uf ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_formatLABEL
case|:
case|case
name|FFESTV_formatCHAREXPR
case|:
case|case
name|FFESTV_formatINTEXPR
case|:
name|fputs
argument_list|(
literal|"+ REWRITE_fm ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Unexpected kind of format item in V018 REWRITE"
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ffeste_subr_file_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|info
operator|->
name|rewrite_spec
index|[
name|FFESTP_rewriteixUNIT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"FMT"
argument_list|,
operator|&
name|info
operator|->
name|rewrite_spec
index|[
name|FFESTP_rewriteixFMT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ERR"
argument_list|,
operator|&
name|info
operator|->
name|rewrite_spec
index|[
name|FFESTP_rewriteixERR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"IOSTAT"
argument_list|,
operator|&
name|info
operator|->
name|rewrite_spec
index|[
name|FFESTP_rewriteixIOSTAT
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|") "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* REWRITE statement -- I/O item.  */
end_comment

begin_function
name|void
name|ffeste_V018_item
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffeste_check_item_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* REWRITE statement -- end.  */
end_comment

begin_function
name|void
name|ffeste_V018_finish
parameter_list|()
block|{
name|ffeste_check_finish_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ACCEPT statement -- start.  */
end_comment

begin_function
name|void
name|ffeste_V019_start
parameter_list|(
name|ffestpAcceptStmt
modifier|*
name|info
parameter_list|,
name|ffestvFormat
name|format
parameter_list|)
block|{
name|ffeste_check_start_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FFESTV_formatLABEL
case|:
case|case
name|FFESTV_formatCHAREXPR
case|:
case|case
name|FFESTV_formatINTEXPR
case|:
name|fputs
argument_list|(
literal|"+ ACCEPT_fm "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_formatASTERISK
case|:
name|fputs
argument_list|(
literal|"+ ACCEPT_ls "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_formatNAMELIST
case|:
name|fputs
argument_list|(
literal|"+ ACCEPT_nl "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Unexpected kind of format item in V019 ACCEPT"
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ffeste_subr_file_
argument_list|(
literal|"FORMAT"
argument_list|,
operator|&
name|info
operator|->
name|accept_spec
index|[
name|FFESTP_acceptixFORMAT
index|]
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ACCEPT statement -- I/O item.  */
end_comment

begin_function
name|void
name|ffeste_V019_item
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffeste_check_item_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ACCEPT statement -- end.  */
end_comment

begin_function
name|void
name|ffeste_V019_finish
parameter_list|()
block|{
name|ffeste_check_finish_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TYPE statement -- start.  */
end_comment

begin_function
name|void
name|ffeste_V020_start
parameter_list|(
name|ffestpTypeStmt
modifier|*
name|info
name|UNUSED
parameter_list|,
name|ffestvFormat
name|format
name|UNUSED
parameter_list|)
block|{
name|ffeste_check_start_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FFESTV_formatLABEL
case|:
case|case
name|FFESTV_formatCHAREXPR
case|:
case|case
name|FFESTV_formatINTEXPR
case|:
name|fputs
argument_list|(
literal|"+ TYPE_fm "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_formatASTERISK
case|:
name|fputs
argument_list|(
literal|"+ TYPE_ls "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_formatNAMELIST
case|:
name|fputs
argument_list|(
literal|"* TYPE_nl "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Unexpected kind of format item in V020 TYPE"
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ffeste_subr_file_
argument_list|(
literal|"FORMAT"
argument_list|,
operator|&
name|info
operator|->
name|type_spec
index|[
name|FFESTP_typeixFORMAT
index|]
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* TYPE statement -- I/O item.  */
end_comment

begin_function
name|void
name|ffeste_V020_item
parameter_list|(
name|ffebld
name|expr
name|UNUSED
parameter_list|)
block|{
name|ffeste_check_item_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* TYPE statement -- end.  */
end_comment

begin_function
name|void
name|ffeste_V020_finish
parameter_list|()
block|{
name|ffeste_check_finish_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* DELETE statement.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
name|void
name|ffeste_V021
parameter_list|(
name|ffestpDeleteStmt
modifier|*
name|info
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ DELETE ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|info
operator|->
name|delete_spec
index|[
name|FFESTP_deleteixUNIT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"REC"
argument_list|,
operator|&
name|info
operator|->
name|delete_spec
index|[
name|FFESTP_deleteixREC
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ERR"
argument_list|,
operator|&
name|info
operator|->
name|delete_spec
index|[
name|FFESTP_deleteixERR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"IOSTAT"
argument_list|,
operator|&
name|info
operator|->
name|delete_spec
index|[
name|FFESTP_deleteixIOSTAT
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* UNLOCK statement.  */
end_comment

begin_function
name|void
name|ffeste_V022
parameter_list|(
name|ffestpBeruStmt
modifier|*
name|info
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ UNLOCK ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|info
operator|->
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ERR"
argument_list|,
operator|&
name|info
operator|->
name|beru_spec
index|[
name|FFESTP_beruixERR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"IOSTAT"
argument_list|,
operator|&
name|info
operator|->
name|beru_spec
index|[
name|FFESTP_beruixIOSTAT
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ENCODE statement -- start.  */
end_comment

begin_function
name|void
name|ffeste_V023_start
parameter_list|(
name|ffestpVxtcodeStmt
modifier|*
name|info
parameter_list|)
block|{
name|ffeste_check_start_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ ENCODE ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"C"
argument_list|,
operator|&
name|info
operator|->
name|vxtcode_spec
index|[
name|FFESTP_vxtcodeixC
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"F"
argument_list|,
operator|&
name|info
operator|->
name|vxtcode_spec
index|[
name|FFESTP_vxtcodeixF
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"B"
argument_list|,
operator|&
name|info
operator|->
name|vxtcode_spec
index|[
name|FFESTP_vxtcodeixB
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ERR"
argument_list|,
operator|&
name|info
operator|->
name|vxtcode_spec
index|[
name|FFESTP_vxtcodeixERR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"IOSTAT"
argument_list|,
operator|&
name|info
operator|->
name|vxtcode_spec
index|[
name|FFESTP_vxtcodeixIOSTAT
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|") "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ENCODE statement -- I/O item.  */
end_comment

begin_function
name|void
name|ffeste_V023_item
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffeste_check_item_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ENCODE statement -- end.  */
end_comment

begin_function
name|void
name|ffeste_V023_finish
parameter_list|()
block|{
name|ffeste_check_finish_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* DECODE statement -- start.  */
end_comment

begin_function
name|void
name|ffeste_V024_start
parameter_list|(
name|ffestpVxtcodeStmt
modifier|*
name|info
parameter_list|)
block|{
name|ffeste_check_start_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ DECODE ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"C"
argument_list|,
operator|&
name|info
operator|->
name|vxtcode_spec
index|[
name|FFESTP_vxtcodeixC
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"F"
argument_list|,
operator|&
name|info
operator|->
name|vxtcode_spec
index|[
name|FFESTP_vxtcodeixF
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"B"
argument_list|,
operator|&
name|info
operator|->
name|vxtcode_spec
index|[
name|FFESTP_vxtcodeixB
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ERR"
argument_list|,
operator|&
name|info
operator|->
name|vxtcode_spec
index|[
name|FFESTP_vxtcodeixERR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"IOSTAT"
argument_list|,
operator|&
name|info
operator|->
name|vxtcode_spec
index|[
name|FFESTP_vxtcodeixIOSTAT
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|") "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* DECODE statement -- I/O item.  */
end_comment

begin_function
name|void
name|ffeste_V024_item
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffeste_check_item_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|ffebld_dump
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* DECODE statement -- end.  */
end_comment

begin_function
name|void
name|ffeste_V024_finish
parameter_list|()
block|{
name|ffeste_check_finish_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* DEFINEFILE statement -- start.  */
end_comment

begin_function
name|void
name|ffeste_V025_start
parameter_list|()
block|{
name|ffeste_check_start_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ DEFINE_FILE "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* DEFINE FILE statement -- item.  */
end_comment

begin_function
name|void
name|ffeste_V025_item
parameter_list|(
name|ffebld
name|u
parameter_list|,
name|ffebld
name|m
parameter_list|,
name|ffebld
name|n
parameter_list|,
name|ffebld
name|asv
parameter_list|)
block|{
name|ffeste_check_item_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|ffebld_dump
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'('
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|",U,"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|asv
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"),"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* DEFINE FILE statement -- end.  */
end_comment

begin_function
name|void
name|ffeste_V025_finish
parameter_list|()
block|{
name|ffeste_check_finish_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* FIND statement.  */
end_comment

begin_function
name|void
name|ffeste_V026
parameter_list|(
name|ffestpFindStmt
modifier|*
name|info
parameter_list|)
block|{
name|ffeste_check_simple_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
name|fputs
argument_list|(
literal|"+ FIND ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|info
operator|->
name|find_spec
index|[
name|FFESTP_findixUNIT
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"REC"
argument_list|,
operator|&
name|info
operator|->
name|find_spec
index|[
name|FFESTP_findixREC
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"ERR"
argument_list|,
operator|&
name|info
operator|->
name|find_spec
index|[
name|FFESTP_findixERR
index|]
argument_list|)
expr_stmt|;
name|ffeste_subr_file_
argument_list|(
literal|"IOSTAT"
argument_list|,
operator|&
name|info
operator|->
name|find_spec
index|[
name|FFESTP_findixIOSTAT
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_function
name|void
name|ffeste_terminate_2
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|ffeste_top_block_
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

