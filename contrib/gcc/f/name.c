begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* name.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       None.     Description:       Name and name space abstraction.     Modifications: */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"bad.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"src.h"
end_include

begin_include
include|#
directive|include
file|"where.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_function_decl
specifier|static
name|ffename
name|ffename_lookup_
parameter_list|(
name|ffenameSpace
name|ns
parameter_list|,
name|ffelexToken
name|t
parameter_list|,
name|bool
modifier|*
name|found
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Internal macros. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Searches for and returns the matching ffename object, or returns a    pointer to the name before which the new name should go.  */
end_comment

begin_function
specifier|static
name|ffename
name|ffename_lookup_
parameter_list|(
name|ffenameSpace
name|ns
parameter_list|,
name|ffelexToken
name|t
parameter_list|,
name|bool
modifier|*
name|found
parameter_list|)
block|{
name|ffename
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|ns
operator|->
name|first
init|;
name|n
operator|!=
operator|(
name|ffename
operator|)
operator|&
name|ns
operator|->
name|first
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ffelex_token_strcmp
argument_list|(
name|t
argument_list|,
name|n
operator|->
name|t
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|found
operator|=
name|TRUE
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
operator|*
name|found
operator|=
name|FALSE
expr_stmt|;
return|return
name|n
return|;
comment|/* (n == (ffename)&ns->first) */
block|}
end_function

begin_comment
comment|/* Searches for and returns the matching ffename object, or creates a new    one (with a NULL ffesymbol) and returns that.  If last arg is TRUE,    check whether token meets character-content requirements (such as    "all characters must be uppercase", as determined by    ffesrc_bad_char_symbol (), issue diagnostic if it doesn't.  */
end_comment

begin_function
name|ffename
name|ffename_find
parameter_list|(
name|ffenameSpace
name|ns
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffename
name|n
decl_stmt|;
name|ffename
name|newn
decl_stmt|;
name|bool
name|found
decl_stmt|;
name|assert
argument_list|(
name|ns
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|t
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAMES
operator|)
operator|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|ffename_lookup_
argument_list|(
name|ns
argument_list|,
name|t
argument_list|,
operator|&
name|found
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return
name|n
return|;
name|newn
operator|=
name|malloc_new_ks
argument_list|(
name|ns
operator|->
name|pool
argument_list|,
literal|"FFENAME name"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|newn
operator|->
name|next
operator|=
name|n
expr_stmt|;
name|newn
operator|->
name|previous
operator|=
name|n
operator|->
name|previous
expr_stmt|;
name|n
operator|->
name|previous
operator|=
name|newn
expr_stmt|;
name|newn
operator|->
name|previous
operator|->
name|next
operator|=
name|newn
expr_stmt|;
name|newn
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|newn
operator|->
name|u
operator|.
name|s
operator|=
name|NULL
expr_stmt|;
return|return
name|newn
return|;
block|}
end_function

begin_comment
comment|/* ffename_kill -- Kill name from name space     ffenameSpace ns;    ffename s;    ffename_kill(ns,s);     Removes the name from the name space.  */
end_comment

begin_function
name|void
name|ffename_kill
parameter_list|(
name|ffenameSpace
name|ns
parameter_list|,
name|ffename
name|n
parameter_list|)
block|{
name|assert
argument_list|(
name|ns
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|n
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|n
operator|->
name|t
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|->
name|previous
operator|=
name|n
operator|->
name|previous
expr_stmt|;
name|n
operator|->
name|previous
operator|->
name|next
operator|=
name|n
operator|->
name|next
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|ns
operator|->
name|pool
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffename_lookup -- Look up name in name space     ffenameSpace ns;    ffelexToken t;    ffename s;    n = ffename_lookup(ns,t);     Searches for and returns the matching ffename object, or returns NULL.  */
end_comment

begin_function
name|ffename
name|ffename_lookup
parameter_list|(
name|ffenameSpace
name|ns
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffename
name|n
decl_stmt|;
name|bool
name|found
decl_stmt|;
name|assert
argument_list|(
name|ns
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|t
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAMES
operator|)
operator|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|ffename_lookup_
argument_list|(
name|ns
argument_list|,
name|t
argument_list|,
operator|&
name|found
argument_list|)
expr_stmt|;
return|return
name|found
condition|?
name|n
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ffename_space_drive_global -- Call given fn for each global in name space     ffenameSpace ns;    ffeglobal (*fn)();    ffename_space_drive_global(ns,fn);  */
end_comment

begin_function
name|void
name|ffename_space_drive_global
parameter_list|(
name|ffenameSpace
name|ns
parameter_list|,
name|ffeglobal
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|ffeglobal
parameter_list|)
parameter_list|)
block|{
name|ffename
name|n
decl_stmt|;
if|if
condition|(
name|ns
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|n
operator|=
name|ns
operator|->
name|first
init|;
name|n
operator|!=
operator|(
name|ffename
operator|)
operator|&
name|ns
operator|->
name|first
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
name|n
operator|->
name|u
operator|.
name|g
operator|!=
name|NULL
condition|)
name|n
operator|->
name|u
operator|.
name|g
operator|=
call|(
modifier|*
name|fn
call|)
argument_list|(
name|n
operator|->
name|u
operator|.
name|g
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffename_space_drive_symbol -- Call given fn for each symbol in name space     ffenameSpace ns;    ffesymbol (*fn)();    ffename_space_drive_symbol(ns,fn);  */
end_comment

begin_function
name|void
name|ffename_space_drive_symbol
parameter_list|(
name|ffenameSpace
name|ns
parameter_list|,
name|ffesymbol
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|ffesymbol
parameter_list|)
parameter_list|)
block|{
name|ffename
name|n
decl_stmt|;
if|if
condition|(
name|ns
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|n
operator|=
name|ns
operator|->
name|first
init|;
name|n
operator|!=
operator|(
name|ffename
operator|)
operator|&
name|ns
operator|->
name|first
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
name|n
operator|->
name|u
operator|.
name|s
operator|!=
name|NULL
condition|)
name|n
operator|->
name|u
operator|.
name|s
operator|=
call|(
modifier|*
name|fn
call|)
argument_list|(
name|n
operator|->
name|u
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffename_space_kill -- Kill name space     ffenameSpace ns;    ffename_space_kill(ns);     Removes the names from the name space; kills the name space.	 */
end_comment

begin_function
name|void
name|ffename_space_kill
parameter_list|(
name|ffenameSpace
name|ns
parameter_list|)
block|{
name|assert
argument_list|(
name|ns
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|ns
operator|->
name|first
operator|!=
operator|(
name|ffename
operator|)
operator|&
name|ns
operator|->
name|first
condition|)
name|ffename_kill
argument_list|(
name|ns
argument_list|,
name|ns
operator|->
name|first
argument_list|)
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|ns
operator|->
name|pool
argument_list|,
name|ns
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ns
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffename_space_new -- Create name space     ffenameSpace ns;    ns = ffename_space_new(malloc_pool_image());     Create new name space.  */
end_comment

begin_function
name|ffenameSpace
name|ffename_space_new
parameter_list|(
name|mallocPool
name|pool
parameter_list|)
block|{
name|ffenameSpace
name|ns
decl_stmt|;
name|ns
operator|=
name|malloc_new_ks
argument_list|(
name|pool
argument_list|,
literal|"FFENAME space"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ns
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|->
name|first
operator|=
operator|(
name|ffename
operator|)
operator|&
name|ns
operator|->
name|first
expr_stmt|;
name|ns
operator|->
name|last
operator|=
operator|(
name|ffename
operator|)
operator|&
name|ns
operator|->
name|first
expr_stmt|;
name|ns
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
return|return
name|ns
return|;
block|}
end_function

end_unit

