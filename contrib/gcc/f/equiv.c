begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* equiv.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995-1998 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       None     Description:       Handles the EQUIVALENCE relationships in a program unit.     Modifications: */
end_comment

begin_define
define|#
directive|define
name|FFEEQUIV_DEBUG
value|0
end_define

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"equiv.h"
end_include

begin_include
include|#
directive|include
file|"bad.h"
end_include

begin_include
include|#
directive|include
file|"bld.h"
end_include

begin_include
include|#
directive|include
file|"com.h"
end_include

begin_include
include|#
directive|include
file|"data.h"
end_include

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_struct
struct|struct
name|_ffeequiv_list_
block|{
name|ffeequiv
name|first
decl_stmt|;
name|ffeequiv
name|last
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|_ffeequiv_list_
name|ffeequiv_list_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_function_decl
specifier|static
name|void
name|ffeequiv_destroy_
parameter_list|(
name|ffeequiv
name|eq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeequiv_layout_local_
parameter_list|(
name|ffeequiv
name|eq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffeequiv_offset_
parameter_list|(
name|ffetargetOffset
modifier|*
name|offset
parameter_list|,
name|ffesymbol
name|s
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|bool
name|subtract
parameter_list|,
name|ffetargetOffset
name|adjust
parameter_list|,
name|bool
name|no_precede
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Internal macros. */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|void
name|ffeequiv_destroy_
parameter_list|(
name|ffeequiv
name|victim
parameter_list|)
block|{
name|ffebld
name|list
decl_stmt|;
name|ffebld
name|item
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
for|for
control|(
name|list
operator|=
name|victim
operator|->
name|list
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
for|for
control|(
name|item
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
name|ffesymbol
name|sym
decl_stmt|;
name|expr
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|sym
operator|=
name|ffeequiv_symbol
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ffesymbol_equiv
argument_list|(
name|sym
argument_list|)
operator|!=
name|NULL
condition|)
name|ffesymbol_set_equiv
argument_list|(
name|sym
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|ffeequiv_kill
argument_list|(
name|victim
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffeequiv_layout_local_ -- Lay out storage for local equivalenced vars     ffeequiv eq;    ffeequiv_layout_local_(eq);     Makes a single master ffestorag object that contains all the vars    in the equivalence, and makes subordinate ffestorag objects for the    vars with the correct offsets.     The resulting var offsets are relative not necessarily to 0 -- the    are relative to the offset of the master area, which might be 0 or    negative, but should never be positive.  */
end_comment

begin_function
specifier|static
name|void
name|ffeequiv_layout_local_
parameter_list|(
name|ffeequiv
name|eq
parameter_list|)
block|{
name|ffestorag
name|st
decl_stmt|;
comment|/* Equivalence storage area. */
name|ffebld
name|list
decl_stmt|;
comment|/* List of list of equivalences. */
name|ffebld
name|item
decl_stmt|;
comment|/* List of equivalences. */
name|ffebld
name|root_exp
decl_stmt|;
comment|/* Expression for root sym. */
name|ffestorag
name|root_st
decl_stmt|;
comment|/* Storage for root. */
name|ffesymbol
name|root_sym
decl_stmt|;
comment|/* Root itself. */
name|ffebld
name|rooted_exp
decl_stmt|;
comment|/* Expression for rooted sym in an eqlist. */
name|ffestorag
name|rooted_st
decl_stmt|;
comment|/* Storage for rooted. */
name|ffesymbol
name|rooted_sym
decl_stmt|;
comment|/* Rooted symbol itself. */
name|ffetargetOffset
name|eqlist_offset
decl_stmt|;
comment|/* Offset for eqlist from rooted sym. */
name|ffetargetAlign
name|alignment
decl_stmt|;
name|ffetargetAlign
name|modulo
decl_stmt|;
name|ffetargetAlign
name|pad
decl_stmt|;
name|ffetargetOffset
name|size
decl_stmt|;
name|ffetargetOffset
name|num_elements
decl_stmt|;
name|bool
name|new_storage
decl_stmt|;
comment|/* Established new storage info. */
name|bool
name|need_storage
decl_stmt|;
comment|/* Have need for more storage info. */
name|bool
name|init
decl_stmt|;
name|assert
argument_list|(
name|eq
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffeequiv_common
argument_list|(
name|eq
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Put in common due to programmer error. */
name|ffeequiv_destroy_
argument_list|(
name|eq
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find the symbol for the first valid item in the list of lists, use that      as the root symbol.  Doesn't matter if it won't end up at the beginning      of the list, though.  */
if|#
directive|if
name|FFEEQUIV_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Equiv1:\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|root_sym
operator|=
name|NULL
expr_stmt|;
name|root_exp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|list
operator|=
name|ffeequiv_list
argument_list|(
name|eq
argument_list|)
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
comment|/* For every equivalence list in the list of 				   equivs */
for|for
control|(
name|item
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
comment|/* For every equivalence item in the list */
name|ffetargetOffset
name|ign
decl_stmt|;
comment|/* Ignored. */
name|root_exp
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|root_sym
operator|=
name|ffeequiv_symbol
argument_list|(
name|root_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|root_sym
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Ignore me. */
name|assert
argument_list|(
name|ffesymbol_storage
argument_list|(
name|root_sym
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* No storage yet. */
if|if
condition|(
operator|!
name|ffeequiv_offset_
argument_list|(
operator|&
name|ign
argument_list|,
name|root_sym
argument_list|,
name|root_exp
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
comment|/* We can't just eliminate this one symbol from the list 		 of candidates, because it might be the only one that 		 ties all these equivs together.  So just destroy the 		 whole list.  */
name|ffeequiv_destroy_
argument_list|(
name|eq
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
comment|/* Use first valid eqv expr for root exp/sym. */
block|}
if|if
condition|(
name|root_sym
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|root_sym
operator|==
name|NULL
condition|)
block|{
name|ffeequiv_destroy_
argument_list|(
name|eq
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|FFEEQUIV_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Root: `%s'\n"
argument_list|,
name|ffesymbol_text
argument_list|(
name|root_sym
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We've got work to do, so make the LOCAL storage object that'll hold all      the equivalenced vars inside it. */
name|st
operator|=
name|ffestorag_new
argument_list|(
name|ffestorag_list_master
argument_list|()
argument_list|)
expr_stmt|;
name|ffestorag_set_parent
argument_list|(
name|st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Initializations happen here. */
name|ffestorag_set_init
argument_list|(
name|st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestorag_set_accretion
argument_list|(
name|st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestorag_set_offset
argument_list|(
name|st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Assume equiv will be at root offset 0 for now. */
name|ffestorag_set_alignment
argument_list|(
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ffestorag_set_modulo
argument_list|(
name|st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffestorag_set_type
argument_list|(
name|st
argument_list|,
name|FFESTORAG_typeLOCAL
argument_list|)
expr_stmt|;
name|ffestorag_set_basictype
argument_list|(
name|st
argument_list|,
name|ffesymbol_basictype
argument_list|(
name|root_sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffestorag_set_kindtype
argument_list|(
name|st
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|root_sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffestorag_set_typesymbol
argument_list|(
name|st
argument_list|,
name|root_sym
argument_list|)
expr_stmt|;
name|ffestorag_set_is_save
argument_list|(
name|st
argument_list|,
name|ffeequiv_is_save
argument_list|(
name|eq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_is_save
argument_list|(
name|root_sym
argument_list|)
condition|)
name|ffestorag_update_save
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|ffestorag_set_is_init
argument_list|(
name|st
argument_list|,
name|ffeequiv_is_init
argument_list|(
name|eq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_is_init
argument_list|(
name|root_sym
argument_list|)
condition|)
name|ffestorag_update_init
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|ffestorag_set_symbol
argument_list|(
name|st
argument_list|,
name|root_sym
argument_list|)
expr_stmt|;
comment|/* Assume this will be the root until 					   we know better (used only to generate 					   the internal name for the aggregate area, 					   e.g. for debugging). */
comment|/* Make the EQUIV storage object for the root symbol. */
if|if
condition|(
name|ffesymbol_rank
argument_list|(
name|root_sym
argument_list|)
operator|==
literal|0
condition|)
name|num_elements
operator|=
literal|1
expr_stmt|;
else|else
name|num_elements
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|ffesymbol_arraysize
argument_list|(
name|root_sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffetarget_layout
argument_list|(
name|ffesymbol_text
argument_list|(
name|root_sym
argument_list|)
argument_list|,
operator|&
name|alignment
argument_list|,
operator|&
name|modulo
argument_list|,
operator|&
name|size
argument_list|,
name|ffesymbol_basictype
argument_list|(
name|root_sym
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|root_sym
argument_list|)
argument_list|,
name|ffesymbol_size
argument_list|(
name|root_sym
argument_list|)
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
name|ffestorag_set_size
argument_list|(
name|st
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Set initial size of aggregate area. */
name|pad
operator|=
name|ffetarget_align
argument_list|(
name|ffestorag_ptr_to_alignment
argument_list|(
name|st
argument_list|)
argument_list|,
name|ffestorag_ptr_to_modulo
argument_list|(
name|st
argument_list|)
argument_list|,
literal|0
argument_list|,
name|alignment
argument_list|,
name|modulo
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pad
operator|==
literal|0
argument_list|)
expr_stmt|;
name|root_st
operator|=
name|ffestorag_new
argument_list|(
name|ffestorag_list_equivs
argument_list|(
name|st
argument_list|)
argument_list|)
expr_stmt|;
name|ffestorag_set_parent
argument_list|(
name|root_st
argument_list|,
name|st
argument_list|)
expr_stmt|;
comment|/* Initializations happen there. */
name|ffestorag_set_init
argument_list|(
name|root_st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestorag_set_accretion
argument_list|(
name|root_st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestorag_set_symbol
argument_list|(
name|root_st
argument_list|,
name|root_sym
argument_list|)
expr_stmt|;
name|ffestorag_set_size
argument_list|(
name|root_st
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ffestorag_set_offset
argument_list|(
name|root_st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Will not change; always 0 relative to itself! */
name|ffestorag_set_alignment
argument_list|(
name|root_st
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|ffestorag_set_modulo
argument_list|(
name|root_st
argument_list|,
name|modulo
argument_list|)
expr_stmt|;
name|ffestorag_set_type
argument_list|(
name|root_st
argument_list|,
name|FFESTORAG_typeEQUIV
argument_list|)
expr_stmt|;
name|ffestorag_set_basictype
argument_list|(
name|root_st
argument_list|,
name|ffesymbol_basictype
argument_list|(
name|root_sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffestorag_set_kindtype
argument_list|(
name|root_st
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|root_sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffestorag_set_typesymbol
argument_list|(
name|root_st
argument_list|,
name|root_sym
argument_list|)
expr_stmt|;
name|ffestorag_set_is_save
argument_list|(
name|root_st
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Assume FALSE, then... */
if|if
condition|(
name|ffestorag_is_save
argument_list|(
name|st
argument_list|)
condition|)
comment|/* ...update to TRUE if needed. */
name|ffestorag_update_save
argument_list|(
name|root_st
argument_list|)
expr_stmt|;
name|ffestorag_set_is_init
argument_list|(
name|root_st
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Assume FALSE, then... */
if|if
condition|(
name|ffestorag_is_init
argument_list|(
name|st
argument_list|)
condition|)
comment|/* ...update to TRUE if needed. */
name|ffestorag_update_init
argument_list|(
name|root_st
argument_list|)
expr_stmt|;
name|ffesymbol_set_storage
argument_list|(
name|root_sym
argument_list|,
name|root_st
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|root_sym
argument_list|)
expr_stmt|;
name|init
operator|=
name|ffesymbol_is_init
argument_list|(
name|root_sym
argument_list|)
expr_stmt|;
comment|/* Now that we know the root (offset=0) symbol, revisit all the lists and      do the actual storage allocation.	Keep doing this until we've gone      through them all without making any new storage objects. */
do|do
block|{
name|new_storage
operator|=
name|FALSE
expr_stmt|;
name|need_storage
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|list
operator|=
name|ffeequiv_list
argument_list|(
name|eq
argument_list|)
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
comment|/* For every equivalence list in the list of 				   equivs */
comment|/* Now find a "rooted" symbol in this list.  That is, find the 	     first item we can that is valid and whose symbol already 	     has a storage area, because that means we know where it 	     belongs in the equivalence area and can then allocate the 	     rest of the items in the list accordingly.  */
name|rooted_sym
operator|=
name|NULL
expr_stmt|;
name|rooted_exp
operator|=
name|NULL
expr_stmt|;
name|eqlist_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|item
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
comment|/* For every equivalence item in the list */
name|rooted_exp
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|rooted_sym
operator|=
name|ffeequiv_symbol
argument_list|(
name|rooted_exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rooted_sym
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|rooted_st
operator|=
name|ffesymbol_storage
argument_list|(
name|rooted_sym
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|rooted_sym
operator|=
name|NULL
expr_stmt|;
continue|continue;
comment|/* Ignore me. */
block|}
name|need_storage
operator|=
name|TRUE
expr_stmt|;
comment|/* Somebody is likely to need 					   storage. */
if|#
directive|if
name|FFEEQUIV_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Rooted: `%s' at %"
name|ffetargetOffset_f
literal|"d\n"
argument_list|,
name|ffesymbol_text
argument_list|(
name|rooted_sym
argument_list|)
argument_list|,
name|ffestorag_offset
argument_list|(
name|rooted_st
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The offset of this symbol from the equiv's root symbol 		 is already known, and the size of this symbol is already 		 incorporated in the size of the equiv's aggregate area. 		 What we now determine is the offset of this equivalence 		 _list_ from the equiv's root symbol.  		 For example, if we know that A is at offset 16 from the 		 root symbol, given EQUIVALENCE (B(24),A(2)), we're looking 		 at A(2), meaning that the offset for this equivalence list 		 is 20 (4 bytes beyond the beginning of A, assuming typical 		 array types, dimensions, and type info).  */
if|if
condition|(
operator|!
name|ffeequiv_offset_
argument_list|(
operator|&
name|eqlist_offset
argument_list|,
name|rooted_sym
argument_list|,
name|rooted_exp
argument_list|,
name|FALSE
argument_list|,
name|ffestorag_offset
argument_list|(
name|rooted_st
argument_list|)
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
comment|/* Can't use this one. */
name|ffesymbol_set_equiv
argument_list|(
name|rooted_sym
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Equiv area slated for 							    death. */
name|rooted_sym
operator|=
name|NULL
expr_stmt|;
continue|continue;
comment|/* Something's wrong with eqv expr, try another. */
block|}
if|#
directive|if
name|FFEEQUIV_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Eqlist offset: %"
name|ffetargetOffset_f
literal|"d\n"
argument_list|,
name|eqlist_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* If no rooted symbol, it means this list has no roots -- yet. 	     So, forget this list this time around, but we'll get back 	     to it after the outer loop iterates at least one more time, 	     and, ultimately, it will have a root.  */
if|if
condition|(
name|rooted_sym
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|FFEEQUIV_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No roots.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|/* We now have a rooted symbol/expr and the offset of this equivalence 	     list from the root symbol.  The other expressions in this 	     list all identify an initial storage unit that must have the 	     same offset. */
for|for
control|(
name|item
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
comment|/* For every equivalence item in the list */
name|ffebld
name|item_exp
decl_stmt|;
comment|/* Expression for equivalence. */
name|ffestorag
name|item_st
decl_stmt|;
comment|/* Storage for var. */
name|ffesymbol
name|item_sym
decl_stmt|;
comment|/* Var itself. */
name|ffetargetOffset
name|item_offset
decl_stmt|;
comment|/* Offset for var from root. */
name|ffetargetOffset
name|new_size
decl_stmt|;
name|item_exp
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item_sym
operator|=
name|ffeequiv_symbol
argument_list|(
name|item_exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|item_sym
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffesymbol_equiv
argument_list|(
name|item_sym
argument_list|)
operator|==
name|NULL
operator|)
condition|)
continue|continue;
comment|/* Ignore me. */
if|if
condition|(
name|item_sym
operator|==
name|rooted_sym
condition|)
continue|continue;
comment|/* Rooted sym already set up. */
if|if
condition|(
operator|!
name|ffeequiv_offset_
argument_list|(
operator|&
name|item_offset
argument_list|,
name|item_sym
argument_list|,
name|item_exp
argument_list|,
name|TRUE
argument_list|,
name|eqlist_offset
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|ffesymbol_set_equiv
argument_list|(
name|item_sym
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Don't bother with me anymore. */
continue|continue;
block|}
if|#
directive|if
name|FFEEQUIV_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Item `%s' at %"
name|ffetargetOffset_f
literal|"d"
argument_list|,
name|ffesymbol_text
argument_list|(
name|item_sym
argument_list|)
argument_list|,
name|item_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ffesymbol_rank
argument_list|(
name|item_sym
argument_list|)
operator|==
literal|0
condition|)
name|num_elements
operator|=
literal|1
expr_stmt|;
else|else
name|num_elements
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|ffesymbol_arraysize
argument_list|(
name|item_sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffetarget_layout
argument_list|(
name|ffesymbol_text
argument_list|(
name|item_sym
argument_list|)
argument_list|,
operator|&
name|alignment
argument_list|,
operator|&
name|modulo
argument_list|,
operator|&
name|size
argument_list|,
name|ffesymbol_basictype
argument_list|(
name|item_sym
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|item_sym
argument_list|)
argument_list|,
name|ffesymbol_size
argument_list|(
name|item_sym
argument_list|)
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
name|pad
operator|=
name|ffetarget_align
argument_list|(
name|ffestorag_ptr_to_alignment
argument_list|(
name|st
argument_list|)
argument_list|,
name|ffestorag_ptr_to_modulo
argument_list|(
name|st
argument_list|)
argument_list|,
name|item_offset
argument_list|,
name|alignment
argument_list|,
name|modulo
argument_list|)
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_EQUIV_ALIGN
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|item_sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffesymbol_set_equiv
argument_list|(
name|item_sym
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Don't bother with me anymore. */
continue|continue;
block|}
comment|/* If the variable's offset is less than the offset for the 		 aggregate storage area, it means it has to expand backwards 		 -- i.e. the new known starting point of the area precedes the 		 old one.  This can't happen with COMMON areas (the standard, 		 and common sense, disallow it), but it is normal for local 		 EQUIVALENCE areas.  		 Also handle choosing the "documented" rooted symbol for this 		 area here.  It's the symbol at the bottom (lowest offset) 		 of the aggregate area, with ties going to the name that would 		 sort to the top of the list of ties.  */
if|if
condition|(
name|item_offset
operator|==
name|ffestorag_offset
argument_list|(
name|st
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|item_sym
operator|!=
name|ffestorag_symbol
argument_list|(
name|st
argument_list|)
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|ffesymbol_text
argument_list|(
name|item_sym
argument_list|)
argument_list|,
name|ffesymbol_text
argument_list|(
name|ffestorag_symbol
argument_list|(
name|st
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|ffestorag_set_symbol
argument_list|(
name|st
argument_list|,
name|item_sym
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|item_offset
operator|<
name|ffestorag_offset
argument_list|(
name|st
argument_list|)
condition|)
block|{
comment|/* Increase size of equiv area to start for lower offset 		     relative to root symbol.  */
if|if
condition|(
operator|!
name|ffetarget_offset_add
argument_list|(
operator|&
name|new_size
argument_list|,
name|ffestorag_offset
argument_list|(
name|st
argument_list|)
operator|-
name|item_offset
argument_list|,
name|ffestorag_size
argument_list|(
name|st
argument_list|)
argument_list|)
condition|)
name|ffetarget_offset_overflow
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ffestorag_set_size
argument_list|(
name|st
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|ffestorag_set_symbol
argument_list|(
name|st
argument_list|,
name|item_sym
argument_list|)
expr_stmt|;
name|ffestorag_set_offset
argument_list|(
name|st
argument_list|,
name|item_offset
argument_list|)
expr_stmt|;
if|#
directive|if
name|FFEEQUIV_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" [eq offset=%"
name|ffetargetOffset_f
literal|"d, size=%"
name|ffetargetOffset_f
literal|"d]"
argument_list|,
name|item_offset
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|item_st
operator|=
name|ffesymbol_storage
argument_list|(
name|item_sym
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Create new ffestorag object, extend equiv 				   area. */
if|#
directive|if
name|FFEEQUIV_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|new_storage
operator|=
name|TRUE
expr_stmt|;
name|item_st
operator|=
name|ffestorag_new
argument_list|(
name|ffestorag_list_equivs
argument_list|(
name|st
argument_list|)
argument_list|)
expr_stmt|;
name|ffestorag_set_parent
argument_list|(
name|item_st
argument_list|,
name|st
argument_list|)
expr_stmt|;
comment|/* Initializations 							   happen there. */
name|ffestorag_set_init
argument_list|(
name|item_st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestorag_set_accretion
argument_list|(
name|item_st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestorag_set_symbol
argument_list|(
name|item_st
argument_list|,
name|item_sym
argument_list|)
expr_stmt|;
name|ffestorag_set_size
argument_list|(
name|item_st
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ffestorag_set_offset
argument_list|(
name|item_st
argument_list|,
name|item_offset
argument_list|)
expr_stmt|;
name|ffestorag_set_alignment
argument_list|(
name|item_st
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|ffestorag_set_modulo
argument_list|(
name|item_st
argument_list|,
name|modulo
argument_list|)
expr_stmt|;
name|ffestorag_set_type
argument_list|(
name|item_st
argument_list|,
name|FFESTORAG_typeEQUIV
argument_list|)
expr_stmt|;
name|ffestorag_set_basictype
argument_list|(
name|item_st
argument_list|,
name|ffesymbol_basictype
argument_list|(
name|item_sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffestorag_set_kindtype
argument_list|(
name|item_st
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|item_sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffestorag_set_typesymbol
argument_list|(
name|item_st
argument_list|,
name|item_sym
argument_list|)
expr_stmt|;
name|ffestorag_set_is_save
argument_list|(
name|item_st
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Assume FALSE... */
if|if
condition|(
name|ffestorag_is_save
argument_list|(
name|st
argument_list|)
condition|)
comment|/* ...update TRUE */
name|ffestorag_update_save
argument_list|(
name|item_st
argument_list|)
expr_stmt|;
comment|/* if needed. */
name|ffestorag_set_is_init
argument_list|(
name|item_st
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Assume FALSE... */
if|if
condition|(
name|ffestorag_is_init
argument_list|(
name|st
argument_list|)
condition|)
comment|/* ...update TRUE */
name|ffestorag_update_init
argument_list|(
name|item_st
argument_list|)
expr_stmt|;
comment|/* if needed. */
name|ffesymbol_set_storage
argument_list|(
name|item_sym
argument_list|,
name|item_st
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|item_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_is_init
argument_list|(
name|item_sym
argument_list|)
condition|)
name|init
operator|=
name|TRUE
expr_stmt|;
comment|/* Determine new size of equiv area, complain if overflow.  */
if|if
condition|(
operator|!
name|ffetarget_offset_add
argument_list|(
operator|&
name|size
argument_list|,
name|item_offset
argument_list|,
name|size
argument_list|)
operator|||
operator|!
name|ffetarget_offset_add
argument_list|(
operator|&
name|size
argument_list|,
operator|-
name|ffestorag_offset
argument_list|(
name|st
argument_list|)
argument_list|,
name|size
argument_list|)
condition|)
name|ffetarget_offset_overflow
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|>
name|ffestorag_size
argument_list|(
name|st
argument_list|)
condition|)
name|ffestorag_set_size
argument_list|(
name|st
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ffestorag_update
argument_list|(
name|st
argument_list|,
name|item_sym
argument_list|,
name|ffesymbol_basictype
argument_list|(
name|item_sym
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|item_sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|FFEEQUIV_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (was %"
name|ffetargetOffset_f
literal|"d).\n"
argument_list|,
name|ffestorag_offset
argument_list|(
name|item_st
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make sure offset agrees with known offset. */
if|if
condition|(
name|item_offset
operator|!=
name|ffestorag_offset
argument_list|(
name|item_st
argument_list|)
condition|)
block|{
name|char
name|io1
index|[
literal|40
index|]
decl_stmt|;
name|char
name|io2
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
operator|&
name|io1
index|[
literal|0
index|]
argument_list|,
literal|"%"
name|ffetargetOffset_f
literal|"d"
argument_list|,
name|item_offset
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|io2
index|[
literal|0
index|]
argument_list|,
literal|"%"
name|ffetargetOffset_f
literal|"d"
argument_list|,
name|ffestorag_offset
argument_list|(
name|item_st
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_EQUIV_MISMATCH
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|item_sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|root_sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|io1
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|io2
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|ffesymbol_set_equiv
argument_list|(
name|item_sym
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Don't bother with me anymore. */
block|}
comment|/* (For every equivalence item in the list) */
name|ffebld_set_head
argument_list|(
name|list
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Don't do this list again. */
block|}
comment|/* (For every equivalence list in the list of 				   equivs) */
block|}
do|while
condition|(
name|new_storage
operator|&&
name|need_storage
condition|)
do|;
name|ffesymbol_set_equiv
argument_list|(
name|root_sym
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* This one has storage now. */
name|ffeequiv_kill
argument_list|(
name|eq
argument_list|)
expr_stmt|;
comment|/* Fully processed, no longer needed. */
comment|/* If the offset for this storage area is zero (it cannot be positive),      that means the alignment/modulo info is already correct.  Otherwise,      the alignment info is correct, but the modulo info reflects a      zero offset, so fix it.  */
if|if
condition|(
name|ffestorag_offset
argument_list|(
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Calculate the initial padding necessary to preserve 	 the alignment/modulo requirements for the storage area. 	 These requirements are themselves kept track of in the 	 record for the storage area as a whole, but really pertain 	 to offset 0 of that area, which is where the root symbol 	 was originally placed.  	 The goal here is to have the offset and size for the area 	 faithfully reflect the area itself, not extra requirements 	 like alignment.  So to meet the alignment requirements, 	 the modulo for the area should be set as if the area had an 	 alignment requirement of alignment/0 and was aligned/padded 	 downward to meet the alignment requirements of the area at 	 offset zero, the amount of padding needed being the desired 	 value for the modulo of the area.  */
name|alignment
operator|=
name|ffestorag_alignment
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|modulo
operator|=
name|ffestorag_modulo
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* Since we want to move the whole area *down* (lower memory 	 addresses) as required by the alignment/modulo paid, negate 	 the offset to ffetarget_align, which assumes aligning *up* 	 is desired.  */
name|pad
operator|=
name|ffetarget_align
argument_list|(
operator|&
name|alignment
argument_list|,
operator|&
name|modulo
argument_list|,
operator|-
name|ffestorag_offset
argument_list|(
name|st
argument_list|)
argument_list|,
name|alignment
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffestorag_set_modulo
argument_list|(
name|st
argument_list|,
name|pad
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
condition|)
name|ffedata_gather
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* Gather subordinate inits into one init. */
block|}
end_function

begin_comment
comment|/* ffeequiv_offset_ -- Determine offset from start of symbol     ffetargetOffset offset;    ffesymbol s;	 // Symbol for error reporting.    ffebld expr;	 // opSUBSTR, opARRAYREF, opSYMTER, opANY.    bool subtract;  // FALSE means add to adjust, TRUE means subtract from it.    ffetargetOffset adjust;  // Helps keep answer in pos range (unsigned).    if (!ffeequiv_offset_(&offset,s,expr,subtract,adjust))        // error doing the calculation, message already printed     Returns the offset represented by the SUBSTR, ARRAYREF, or SUBSTR/ARRAYREF    combination added-to/subtracted-from the adjustment specified.  If there    is an error of some kind, returns FALSE, else returns TRUE.	Note that    only the first storage unit specified is considered; A(1:1) and A(1:2000)    have the same first storage unit and so return the same offset.  */
end_comment

begin_function
specifier|static
name|bool
name|ffeequiv_offset_
parameter_list|(
name|ffetargetOffset
modifier|*
name|offset
parameter_list|,
name|ffesymbol
name|s
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|bool
name|subtract
parameter_list|,
name|ffetargetOffset
name|adjust
parameter_list|,
name|bool
name|no_precede
parameter_list|)
block|{
name|ffetargetIntegerDefault
name|value
init|=
literal|0
decl_stmt|;
name|ffetargetOffset
name|cval
decl_stmt|;
comment|/* Converted value. */
name|ffesymbol
name|sym
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|again
label|:
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opANY
case|:
return|return
name|FALSE
return|;
case|case
name|FFEBLD_opSYMTER
case|:
block|{
name|ffetargetOffset
name|size
decl_stmt|;
comment|/* Size of a single unit. */
name|ffetargetAlign
name|a
decl_stmt|;
comment|/* Ignored. */
name|ffetargetAlign
name|m
decl_stmt|;
comment|/* Ignored. */
name|sym
operator|=
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_basictype
argument_list|(
name|sym
argument_list|)
operator|==
name|FFEINFO_basictypeANY
condition|)
return|return
name|FALSE
return|;
name|ffetarget_layout
argument_list|(
name|ffesymbol_text
argument_list|(
name|sym
argument_list|)
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|size
argument_list|,
name|ffesymbol_basictype
argument_list|(
name|sym
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
comment|/* Really invalid, as in A(-2:5), but in case 				   it's wanted.... */
if|if
condition|(
operator|!
name|ffetarget_offset
argument_list|(
operator|&
name|cval
argument_list|,
operator|-
name|value
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|ffetarget_offset_multiply
argument_list|(
operator|&
name|cval
argument_list|,
name|cval
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|subtract
condition|)
return|return
name|ffetarget_offset_add
argument_list|(
name|offset
argument_list|,
name|cval
argument_list|,
name|adjust
argument_list|)
return|;
if|if
condition|(
name|no_precede
operator|&&
operator|(
name|cval
operator|>
name|adjust
operator|)
condition|)
block|{
name|neg
label|:
comment|/* :::::::::::::::::::: */
name|ffebad_start
argument_list|(
name|FFEBAD_COMMON_NEG
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|ffetarget_offset_add
argument_list|(
name|offset
argument_list|,
operator|-
name|cval
argument_list|,
name|adjust
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ffetarget_offset
argument_list|(
operator|&
name|cval
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|ffetarget_offset_multiply
argument_list|(
operator|&
name|cval
argument_list|,
name|cval
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|subtract
condition|)
return|return
name|ffetarget_offset_add
argument_list|(
name|offset
argument_list|,
name|cval
argument_list|,
name|adjust
argument_list|)
return|;
if|if
condition|(
name|no_precede
operator|&&
operator|(
name|cval
operator|>
name|adjust
operator|)
condition|)
goto|goto
name|neg
goto|;
comment|/* :::::::::::::::::::: */
return|return
name|ffetarget_offset_add
argument_list|(
name|offset
argument_list|,
operator|-
name|cval
argument_list|,
name|adjust
argument_list|)
return|;
block|}
case|case
name|FFEBLD_opARRAYREF
case|:
block|{
name|ffebld
name|symexp
init|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|ffebld
name|subscripts
init|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|ffebld
name|dims
decl_stmt|;
name|ffetargetIntegerDefault
name|width
decl_stmt|;
name|ffetargetIntegerDefault
name|arrayval
decl_stmt|;
name|ffetargetIntegerDefault
name|lowbound
decl_stmt|;
name|ffetargetIntegerDefault
name|highbound
decl_stmt|;
name|ffebld
name|subscript
decl_stmt|;
name|ffebld
name|dim
decl_stmt|;
name|ffebld
name|low
decl_stmt|;
name|ffebld
name|high
decl_stmt|;
name|int
name|rank
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|symexp
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
condition|)
return|return
name|FALSE
return|;
name|sym
operator|=
name|ffebld_symter
argument_list|(
name|symexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_basictype
argument_list|(
name|sym
argument_list|)
operator|==
name|FFEINFO_basictypeANY
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|ffesymbol_size
argument_list|(
name|sym
argument_list|)
operator|==
name|FFETARGET_charactersizeNONE
condition|)
name|width
operator|=
literal|1
expr_stmt|;
else|else
name|width
operator|=
name|ffesymbol_size
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|dims
operator|=
name|ffesymbol_dims
argument_list|(
name|sym
argument_list|)
expr_stmt|;
while|while
condition|(
name|subscripts
operator|!=
name|NULL
condition|)
block|{
operator|++
name|rank
expr_stmt|;
if|if
condition|(
name|dims
operator|==
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_EQUIV_MANY
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|subscript
operator|=
name|ffebld_head
argument_list|(
name|subscripts
argument_list|)
expr_stmt|;
name|dim
operator|=
name|ffebld_head
argument_list|(
name|dims
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|subscript
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
return|return
name|FALSE
return|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|subscript
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|subscript
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|subscript
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|arrayval
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|subscript
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|dim
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
return|return
name|FALSE
return|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|dim
argument_list|)
operator|==
name|FFEBLD_opBOUNDS
argument_list|)
expr_stmt|;
name|low
operator|=
name|ffebld_left
argument_list|(
name|dim
argument_list|)
expr_stmt|;
name|high
operator|=
name|ffebld_right
argument_list|(
name|dim
argument_list|)
expr_stmt|;
if|if
condition|(
name|low
operator|==
name|NULL
condition|)
name|lowbound
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ffebld_op
argument_list|(
name|low
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
return|return
name|FALSE
return|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|low
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|low
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|low
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|lowbound
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffebld_op
argument_list|(
name|high
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
return|return
name|FALSE
return|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|high
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|high
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|high
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGER1
argument_list|)
expr_stmt|;
name|highbound
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arrayval
operator|<
name|lowbound
operator|)
operator|||
operator|(
name|arrayval
operator|>
name|highbound
operator|)
condition|)
block|{
name|char
name|rankstr
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|rankstr
argument_list|,
literal|"%d"
argument_list|,
name|rank
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_EQUIV_SUBSCRIPT
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|rankstr
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|subscripts
operator|=
name|ffebld_trail
argument_list|(
name|subscripts
argument_list|)
expr_stmt|;
name|dims
operator|=
name|ffebld_trail
argument_list|(
name|dims
argument_list|)
expr_stmt|;
name|value
operator|+=
name|width
operator|*
operator|(
name|arrayval
operator|-
name|lowbound
operator|)
expr_stmt|;
if|if
condition|(
name|subscripts
operator|!=
name|NULL
condition|)
name|width
operator|*=
name|highbound
operator|-
name|lowbound
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dims
operator|!=
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_EQUIV_FEW
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|expr
operator|=
name|symexp
expr_stmt|;
block|}
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEBLD_opSUBSTR
case|:
block|{
name|ffebld
name|begin
init|=
name|ffebld_head
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opARRAYREF
condition|)
name|sym
operator|=
name|ffebld_symter
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opSYMTER
condition|)
name|sym
operator|=
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
expr_stmt|;
else|else
name|sym
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|sym
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffesymbol_basictype
argument_list|(
name|sym
argument_list|)
operator|==
name|FFEINFO_basictypeANY
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|begin
operator|==
name|NULL
condition|)
name|value
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ffebld_op
argument_list|(
name|begin
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
return|return
name|FALSE
return|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|begin
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|begin
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|begin
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|value
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|begin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|<
literal|1
operator|)
operator|||
operator|(
operator|(
name|sym
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|value
operator|>
name|ffesymbol_size
argument_list|(
name|sym
argument_list|)
operator|)
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_EQUIV_RANGE
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
operator|--
name|value
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sym
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffesymbol_basictype
argument_list|(
name|sym
argument_list|)
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_EQUIV_SUBSTR
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
default|default:
name|assert
argument_list|(
literal|"bad op"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeequiv_add -- Add list of equivalences to list of lists for eq object     ffeequiv eq;    ffebld list;    ffelexToken t;  // points to first item in equivalence list    ffeequiv_add(eq,list,t);     Check the list to make sure only one common symbol is involved (even    if multiple times) and agrees with the common symbol for the equivalence    object (or it has no common symbol until now).  Prepend (or append, it    doesn't matter) the list to the list of lists for the equivalence object.    Otherwise report an error and return.  */
end_comment

begin_function
name|void
name|ffeequiv_add
parameter_list|(
name|ffeequiv
name|eq
parameter_list|,
name|ffebld
name|list
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebld
name|item
decl_stmt|;
name|ffesymbol
name|symbol
decl_stmt|;
name|ffesymbol
name|common
init|=
name|ffeequiv_common
argument_list|(
name|eq
argument_list|)
decl_stmt|;
for|for
control|(
name|item
operator|=
name|list
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
name|symbol
operator|=
name|ffeequiv_symbol
argument_list|(
name|ffebld_head
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_common
argument_list|(
name|symbol
argument_list|)
operator|!=
name|NULL
condition|)
comment|/* Is symbol known in COMMON yet? */
block|{
if|if
condition|(
name|common
operator|==
name|NULL
condition|)
name|common
operator|=
name|ffesymbol_common
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|common
operator|!=
name|ffesymbol_common
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
comment|/* Yes, and symbol disagrees with others on the COMMON area. */
name|ffebad_start
argument_list|(
name|FFEBAD_EQUIV_COMMON
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|common
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffesymbol_common
argument_list|(
name|symbol
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|common
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeequiv_common
argument_list|(
name|eq
argument_list|)
operator|==
name|NULL
operator|)
condition|)
comment|/* Is COMMON involved already? */
name|ffeequiv_set_common
argument_list|(
name|eq
argument_list|,
name|common
argument_list|)
expr_stmt|;
comment|/* No, but it is now. */
for|for
control|(
name|item
operator|=
name|list
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
name|symbol
operator|=
name|ffeequiv_symbol
argument_list|(
name|ffebld_head
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_equiv
argument_list|(
name|symbol
argument_list|)
operator|==
name|NULL
condition|)
name|ffesymbol_set_equiv
argument_list|(
name|symbol
argument_list|,
name|eq
argument_list|)
expr_stmt|;
else|else
name|assert
argument_list|(
name|ffesymbol_equiv
argument_list|(
name|symbol
argument_list|)
operator|==
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_common
argument_list|(
name|symbol
argument_list|)
operator|==
name|NULL
condition|)
comment|/* Is symbol in a COMMON 						   area? */
block|{
comment|/* No (at least not yet). */
if|if
condition|(
name|ffesymbol_is_save
argument_list|(
name|symbol
argument_list|)
condition|)
name|ffeequiv_update_save
argument_list|(
name|eq
argument_list|)
expr_stmt|;
comment|/* EQUIVALENCE has>=1 SAVEd entity. */
if|if
condition|(
name|ffesymbol_is_init
argument_list|(
name|symbol
argument_list|)
condition|)
name|ffeequiv_update_init
argument_list|(
name|eq
argument_list|)
expr_stmt|;
comment|/* EQUIVALENCE has>=1 init'd entity. */
continue|continue;
comment|/* Nothing more to do here. */
block|}
if|#
directive|if
name|FFEGLOBAL_ENABLED
if|if
condition|(
name|ffesymbol_is_init
argument_list|(
name|symbol
argument_list|)
condition|)
name|ffeglobal_init_common
argument_list|(
name|ffesymbol_common
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ffesymbol_is_save
argument_list|(
name|ffesymbol_common
argument_list|(
name|symbol
argument_list|)
argument_list|)
condition|)
name|ffeequiv_update_save
argument_list|(
name|eq
argument_list|)
expr_stmt|;
comment|/* EQUIVALENCE is in a SAVEd COMMON block. */
if|if
condition|(
name|ffesymbol_is_init
argument_list|(
name|ffesymbol_common
argument_list|(
name|symbol
argument_list|)
argument_list|)
condition|)
name|ffeequiv_update_init
argument_list|(
name|eq
argument_list|)
expr_stmt|;
comment|/* EQUIVALENCE is in a init'd COMMON block. */
block|}
name|ffeequiv_set_list
argument_list|(
name|eq
argument_list|,
name|ffebld_new_item
argument_list|(
name|list
argument_list|,
name|ffeequiv_list
argument_list|(
name|eq
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffeequiv_dump -- Dump info on equivalence object     ffeequiv eq;    ffeequiv_dump(eq);  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
end_if

begin_function
name|void
name|ffeequiv_dump
parameter_list|(
name|ffeequiv
name|eq
parameter_list|)
block|{
if|if
condition|(
name|ffeequiv_common
argument_list|(
name|eq
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"(common %s) "
argument_list|,
name|ffesymbol_text
argument_list|(
name|ffeequiv_common
argument_list|(
name|eq
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|ffeequiv_list
argument_list|(
name|eq
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffeequiv_exec_transition -- Do the hard work on all the equivalence objects     ffeequiv_exec_transition();	*/
end_comment

begin_function
name|void
name|ffeequiv_exec_transition
parameter_list|()
block|{
while|while
condition|(
name|ffeequiv_list_
operator|.
name|first
operator|!=
operator|(
name|ffeequiv
operator|)
operator|&
name|ffeequiv_list_
operator|.
name|first
condition|)
name|ffeequiv_layout_local_
argument_list|(
name|ffeequiv_list_
operator|.
name|first
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffeequiv_init_2 -- Initialize for new program unit     ffeequiv_init_2();     Initializes the list of equivalences.  */
end_comment

begin_function
name|void
name|ffeequiv_init_2
parameter_list|()
block|{
name|ffeequiv_list_
operator|.
name|first
operator|=
operator|(
name|ffeequiv
operator|)
operator|&
name|ffeequiv_list_
operator|.
name|first
expr_stmt|;
name|ffeequiv_list_
operator|.
name|last
operator|=
operator|(
name|ffeequiv
operator|)
operator|&
name|ffeequiv_list_
operator|.
name|first
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffeequiv_kill -- Kill equivalence object after removing from list     ffeequiv eq;    ffeequiv_kill(eq);     Removes equivalence object from master list, then kills it.	*/
end_comment

begin_function
name|void
name|ffeequiv_kill
parameter_list|(
name|ffeequiv
name|victim
parameter_list|)
block|{
name|victim
operator|->
name|next
operator|->
name|previous
operator|=
name|victim
operator|->
name|previous
expr_stmt|;
name|victim
operator|->
name|previous
operator|->
name|next
operator|=
name|victim
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ffe_is_do_internal_checks
argument_list|()
condition|)
block|{
name|ffebld
name|list
decl_stmt|;
name|ffebld
name|item
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
comment|/* Assert that nobody our victim points to still points to it.  */
name|assert
argument_list|(
operator|(
name|victim
operator|->
name|common
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffesymbol_equiv
argument_list|(
name|victim
operator|->
name|common
argument_list|)
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|victim
operator|->
name|list
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
for|for
control|(
name|item
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
name|ffesymbol
name|sym
decl_stmt|;
name|expr
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|sym
operator|=
name|ffeequiv_symbol
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
continue|continue;
name|assert
argument_list|(
name|ffesymbol_equiv
argument_list|(
name|sym
argument_list|)
operator|!=
name|victim
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|malloc_kill_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
name|victim
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|victim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffeequiv_layout_cblock -- Lay out storage for common area     ffestorag st;    if (ffeequiv_layout_cblock(st))        // at least one equiv'd symbol has init/accretion expr.     Now that the explicitly COMMONed variables in the common area (whose    ffestorag object is passed) have been laid out, lay out the storage    for all variables equivalenced into the area by making subordinate    ffestorag objects for them.	*/
end_comment

begin_function
name|bool
name|ffeequiv_layout_cblock
parameter_list|(
name|ffestorag
name|st
parameter_list|)
block|{
name|ffesymbol
name|s
init|=
name|ffestorag_symbol
argument_list|(
name|st
argument_list|)
decl_stmt|;
comment|/* CBLOCK symbol. */
name|ffebld
name|list
decl_stmt|;
comment|/* List of explicit common vars, in order, in 				   s. */
name|ffebld
name|item
decl_stmt|;
comment|/* List of list of equivalences in a given 				   explicit common var. */
name|ffebld
name|root
decl_stmt|;
comment|/* Expression for (1st) explicit common var 				   in list of eqs. */
name|ffestorag
name|rst
decl_stmt|;
comment|/* Storage for root. */
name|ffetargetOffset
name|root_offset
decl_stmt|;
comment|/* Offset for root into common area. */
name|ffesymbol
name|sr
decl_stmt|;
comment|/* Root itself. */
name|ffeequiv
name|seq
decl_stmt|;
comment|/* Its equivalence object, if any. */
name|ffebld
name|var
decl_stmt|;
comment|/* Expression for equivalence. */
name|ffestorag
name|vst
decl_stmt|;
comment|/* Storage for var. */
name|ffetargetOffset
name|var_offset
decl_stmt|;
comment|/* Offset for var into common area. */
name|ffesymbol
name|sv
decl_stmt|;
comment|/* Var itself. */
name|ffebld
name|altroot
decl_stmt|;
comment|/* Alternate root. */
name|ffesymbol
name|altrootsym
decl_stmt|;
comment|/* Alternate root symbol. */
name|ffetargetAlign
name|alignment
decl_stmt|;
name|ffetargetAlign
name|modulo
decl_stmt|;
name|ffetargetAlign
name|pad
decl_stmt|;
name|ffetargetOffset
name|size
decl_stmt|;
name|ffetargetOffset
name|num_elements
decl_stmt|;
name|bool
name|new_storage
decl_stmt|;
comment|/* Established new storage info. */
name|bool
name|need_storage
decl_stmt|;
comment|/* Have need for more storage info. */
name|bool
name|ok
decl_stmt|;
name|bool
name|init
init|=
name|FALSE
decl_stmt|;
name|assert
argument_list|(
name|st
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffestorag_type
argument_list|(
name|st
argument_list|)
operator|==
name|FFESTORAG_typeCBLOCK
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffesymbol_kind
argument_list|(
name|ffestorag_symbol
argument_list|(
name|st
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindCOMMON
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|ffesymbol_commonlist
argument_list|(
name|ffestorag_symbol
argument_list|(
name|st
argument_list|)
argument_list|)
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
comment|/* For every variable in the common area */
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|ffebld_head
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opSYMTER
argument_list|)
expr_stmt|;
name|sr
operator|=
name|ffebld_symter
argument_list|(
name|ffebld_head
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|seq
operator|=
name|ffesymbol_equiv
argument_list|(
name|sr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* No equivalences to process. */
name|rst
operator|=
name|ffesymbol_storage
argument_list|(
name|sr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rst
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|ffesymbol_kind
argument_list|(
name|sr
argument_list|)
operator|==
name|FFEINFO_kindANY
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ffesymbol_set_equiv
argument_list|(
name|sr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Cancel ref to equiv obj. */
do|do
block|{
name|new_storage
operator|=
name|FALSE
expr_stmt|;
name|need_storage
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|item
operator|=
name|ffeequiv_list
argument_list|(
name|seq
argument_list|)
init|;
comment|/* Get list of equivs. */
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
comment|/* For every eqv list in the list of equivs 				   for the variable */
name|altroot
operator|=
name|NULL
expr_stmt|;
name|altrootsym
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|root
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
init|;
name|root
operator|!=
name|NULL
condition|;
name|root
operator|=
name|ffebld_trail
argument_list|(
name|root
argument_list|)
control|)
block|{
comment|/* For every equivalence item in the list */
name|sv
operator|=
name|ffeequiv_symbol
argument_list|(
name|ffebld_head
argument_list|(
name|root
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|==
name|sr
condition|)
break|break;
comment|/* Found first mention of "rooted" symbol. */
if|if
condition|(
name|ffesymbol_storage
argument_list|(
name|sv
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|altroot
operator|=
name|root
expr_stmt|;
comment|/* If no mention, use this guy 					   instead. */
name|altrootsym
operator|=
name|sv
expr_stmt|;
block|}
block|}
if|if
condition|(
name|root
operator|!=
name|NULL
condition|)
block|{
name|root
operator|=
name|ffebld_head
argument_list|(
name|root
argument_list|)
expr_stmt|;
comment|/* Lose its opITEM. */
name|ok
operator|=
name|ffeequiv_offset_
argument_list|(
operator|&
name|root_offset
argument_list|,
name|sr
argument_list|,
name|root
argument_list|,
name|FALSE
argument_list|,
name|ffestorag_offset
argument_list|(
name|rst
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Equiv point prior to start of common area? */
block|}
elseif|else
if|if
condition|(
name|altroot
operator|!=
name|NULL
condition|)
block|{
comment|/* Equiv point prior to start of common area? */
name|root
operator|=
name|ffebld_head
argument_list|(
name|altroot
argument_list|)
expr_stmt|;
name|ok
operator|=
name|ffeequiv_offset_
argument_list|(
operator|&
name|root_offset
argument_list|,
name|altrootsym
argument_list|,
name|root
argument_list|,
name|FALSE
argument_list|,
name|ffestorag_offset
argument_list|(
name|ffesymbol_storage
argument_list|(
name|altrootsym
argument_list|)
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ffesymbol_set_equiv
argument_list|(
name|altrootsym
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* No rooted symbol in list of equivalences! */
block|{
comment|/* Assume this was due to opANY and ignore 				   this list for now. */
name|need_storage
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* We now know the root symbol and the operating offset of that 		 root into the common area.  The other expressions in the 		 list all identify an initial storage unit that must have the 		 same offset. */
for|for
control|(
name|var
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
init|;
name|var
operator|!=
name|NULL
condition|;
name|var
operator|=
name|ffebld_trail
argument_list|(
name|var
argument_list|)
control|)
block|{
comment|/* For every equivalence item in the list */
if|if
condition|(
name|ffebld_head
argument_list|(
name|var
argument_list|)
operator|==
name|root
condition|)
continue|continue;
comment|/* Except root, of course. */
name|sv
operator|=
name|ffeequiv_symbol
argument_list|(
name|ffebld_head
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Except erroneous stuff (opANY). */
name|ffesymbol_set_equiv
argument_list|(
name|sv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Don't need this ref 							   anymore. */
if|if
condition|(
operator|!
name|ok
operator|||
operator|!
name|ffeequiv_offset_
argument_list|(
operator|&
name|var_offset
argument_list|,
name|sv
argument_list|,
name|ffebld_head
argument_list|(
name|var
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|root_offset
argument_list|,
name|TRUE
argument_list|)
condition|)
continue|continue;
comment|/* Can't do negative offset wrt COMMON. */
if|if
condition|(
name|ffesymbol_rank
argument_list|(
name|sv
argument_list|)
operator|==
literal|0
condition|)
name|num_elements
operator|=
literal|1
expr_stmt|;
else|else
name|num_elements
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|ffesymbol_arraysize
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffetarget_layout
argument_list|(
name|ffesymbol_text
argument_list|(
name|sv
argument_list|)
argument_list|,
operator|&
name|alignment
argument_list|,
operator|&
name|modulo
argument_list|,
operator|&
name|size
argument_list|,
name|ffesymbol_basictype
argument_list|(
name|sv
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|sv
argument_list|)
argument_list|,
name|ffesymbol_size
argument_list|(
name|sv
argument_list|)
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
name|pad
operator|=
name|ffetarget_align
argument_list|(
name|ffestorag_ptr_to_alignment
argument_list|(
name|st
argument_list|)
argument_list|,
name|ffestorag_ptr_to_modulo
argument_list|(
name|st
argument_list|)
argument_list|,
name|var_offset
argument_list|,
name|alignment
argument_list|,
name|modulo
argument_list|)
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_EQUIV_ALIGN
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|vst
operator|=
name|ffesymbol_storage
argument_list|(
name|sv
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Create new ffestorag object, extend 				   cblock. */
name|new_storage
operator|=
name|TRUE
expr_stmt|;
name|vst
operator|=
name|ffestorag_new
argument_list|(
name|ffestorag_list_equivs
argument_list|(
name|st
argument_list|)
argument_list|)
expr_stmt|;
name|ffestorag_set_parent
argument_list|(
name|vst
argument_list|,
name|st
argument_list|)
expr_stmt|;
comment|/* Initializations 							   happen there. */
name|ffestorag_set_init
argument_list|(
name|vst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestorag_set_accretion
argument_list|(
name|vst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestorag_set_symbol
argument_list|(
name|vst
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|ffestorag_set_size
argument_list|(
name|vst
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ffestorag_set_offset
argument_list|(
name|vst
argument_list|,
name|var_offset
argument_list|)
expr_stmt|;
name|ffestorag_set_alignment
argument_list|(
name|vst
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|ffestorag_set_modulo
argument_list|(
name|vst
argument_list|,
name|modulo
argument_list|)
expr_stmt|;
name|ffestorag_set_type
argument_list|(
name|vst
argument_list|,
name|FFESTORAG_typeEQUIV
argument_list|)
expr_stmt|;
name|ffestorag_set_basictype
argument_list|(
name|vst
argument_list|,
name|ffesymbol_basictype
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|ffestorag_set_kindtype
argument_list|(
name|vst
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|ffestorag_set_typesymbol
argument_list|(
name|vst
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|ffestorag_set_is_save
argument_list|(
name|vst
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Assume FALSE... */
if|if
condition|(
name|ffestorag_is_save
argument_list|(
name|st
argument_list|)
condition|)
comment|/* ...update TRUE */
name|ffestorag_update_save
argument_list|(
name|vst
argument_list|)
expr_stmt|;
comment|/* if needed. */
name|ffestorag_set_is_init
argument_list|(
name|vst
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Assume FALSE... */
if|if
condition|(
name|ffestorag_is_init
argument_list|(
name|st
argument_list|)
condition|)
comment|/* ...update TRUE */
name|ffestorag_update_init
argument_list|(
name|vst
argument_list|)
expr_stmt|;
comment|/* if needed. */
if|if
condition|(
operator|!
name|ffetarget_offset_add
argument_list|(
operator|&
name|size
argument_list|,
name|var_offset
argument_list|,
name|size
argument_list|)
condition|)
comment|/* Find one size of common block, complain if 			   overflow. */
name|ffetarget_offset_overflow
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|>
name|ffestorag_size
argument_list|(
name|st
argument_list|)
condition|)
comment|/* Extend common. */
name|ffestorag_set_size
argument_list|(
name|st
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ffesymbol_set_storage
argument_list|(
name|sv
argument_list|,
name|vst
argument_list|)
expr_stmt|;
name|ffesymbol_set_common
argument_list|(
name|sv
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|ffestorag_update
argument_list|(
name|st
argument_list|,
name|sv
argument_list|,
name|ffesymbol_basictype
argument_list|(
name|sv
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_is_init
argument_list|(
name|sv
argument_list|)
condition|)
name|init
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure offset agrees with known offset. */
if|if
condition|(
name|var_offset
operator|!=
name|ffestorag_offset
argument_list|(
name|vst
argument_list|)
condition|)
block|{
name|char
name|io1
index|[
literal|40
index|]
decl_stmt|;
name|char
name|io2
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
operator|&
name|io1
index|[
literal|0
index|]
argument_list|,
literal|"%"
name|ffetargetOffset_f
literal|"d"
argument_list|,
name|var_offset
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|io2
index|[
literal|0
index|]
argument_list|,
literal|"%"
name|ffetargetOffset_f
literal|"d"
argument_list|,
name|ffestorag_offset
argument_list|(
name|vst
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_EQUIV_MISMATCH
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|io1
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|io2
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* (For every equivalence item in the list) */
block|}
comment|/* (For every eqv list in the list of equivs 				   for the variable) */
block|}
do|while
condition|(
name|new_storage
operator|&&
name|need_storage
condition|)
do|;
name|ffeequiv_kill
argument_list|(
name|seq
argument_list|)
expr_stmt|;
comment|/* Kill equiv obj. */
block|}
comment|/* (For every variable in the common area) */
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* ffeequiv_merge -- Merge two equivalence objects, return the merged result     ffeequiv eq1;    ffeequiv eq2;    ffelexToken t;  // points to current equivalence item forcing the merge.    eq1 = ffeequiv_merge(eq1,eq2,t);     If the two equivalence objects can be merged, they are, all the    ffesymbols in their lists of lists are adjusted to point to the merged    equivalence object, and the merged object is returned.     Otherwise, the two equivalence objects have different non-NULL common    symbols, so the merge cannot take place.  An error message is issued and    NULL is returned.  */
end_comment

begin_function
name|ffeequiv
name|ffeequiv_merge
parameter_list|(
name|ffeequiv
name|eq1
parameter_list|,
name|ffeequiv
name|eq2
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebld
name|list
decl_stmt|;
name|ffebld
name|eqs
decl_stmt|;
name|ffesymbol
name|symbol
decl_stmt|;
name|ffebld
name|last
init|=
name|NULL
decl_stmt|;
comment|/* If both equivalence objects point to different common-based symbols,      complain.	Of course, one or both might have NULL common symbols now,      and get COMMONed later, but the COMMON statement handler checks for      this. */
if|if
condition|(
operator|(
name|ffeequiv_common
argument_list|(
name|eq1
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeequiv_common
argument_list|(
name|eq2
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeequiv_common
argument_list|(
name|eq1
argument_list|)
operator|!=
name|ffeequiv_common
argument_list|(
name|eq2
argument_list|)
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_EQUIV_COMMON
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffeequiv_common
argument_list|(
name|eq1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffeequiv_common
argument_list|(
name|eq2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Make eq1 the new, merged object (arbitrarily). */
if|if
condition|(
name|ffeequiv_common
argument_list|(
name|eq1
argument_list|)
operator|==
name|NULL
condition|)
name|ffeequiv_set_common
argument_list|(
name|eq1
argument_list|,
name|ffeequiv_common
argument_list|(
name|eq2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the victim object has any init'ed entities, so does the new object. */
if|if
condition|(
name|eq2
operator|->
name|is_init
condition|)
name|eq1
operator|->
name|is_init
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|FFEGLOBAL_ENABLED
if|if
condition|(
name|eq1
operator|->
name|is_init
operator|&&
operator|(
name|ffeequiv_common
argument_list|(
name|eq1
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|ffeglobal_init_common
argument_list|(
name|ffeequiv_common
argument_list|(
name|eq1
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the victim object has any SAVEd entities, then the new object has      some. */
if|if
condition|(
name|ffeequiv_is_save
argument_list|(
name|eq2
argument_list|)
condition|)
name|ffeequiv_update_save
argument_list|(
name|eq1
argument_list|)
expr_stmt|;
comment|/* If the victim object has any init'd entities, then the new object has      some. */
if|if
condition|(
name|ffeequiv_is_init
argument_list|(
name|eq2
argument_list|)
condition|)
name|ffeequiv_update_init
argument_list|(
name|eq1
argument_list|)
expr_stmt|;
comment|/* Adjust all the symbols in the list of lists of equivalences for the      victim equivalence object so they point to the new merged object      instead. */
for|for
control|(
name|list
operator|=
name|ffeequiv_list
argument_list|(
name|eq2
argument_list|)
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
for|for
control|(
name|eqs
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
init|;
name|eqs
operator|!=
name|NULL
condition|;
name|eqs
operator|=
name|ffebld_trail
argument_list|(
name|eqs
argument_list|)
control|)
block|{
name|symbol
operator|=
name|ffeequiv_symbol
argument_list|(
name|ffebld_head
argument_list|(
name|eqs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_equiv
argument_list|(
name|symbol
argument_list|)
operator|==
name|eq2
condition|)
name|ffesymbol_set_equiv
argument_list|(
name|symbol
argument_list|,
name|eq1
argument_list|)
expr_stmt|;
else|else
name|assert
argument_list|(
name|ffesymbol_equiv
argument_list|(
name|symbol
argument_list|)
operator|==
name|eq1
argument_list|)
expr_stmt|;
comment|/* Can see a sym> once. */
block|}
comment|/* For convenience, remember where the last ITEM in the outer list is. */
if|if
condition|(
name|ffebld_trail
argument_list|(
name|list
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|last
operator|=
name|list
expr_stmt|;
break|break;
block|}
block|}
comment|/* Append the list of lists in the new, merged object to the list of lists      in the victim object, then use the new combined list in the new merged      object. */
name|ffebld_set_trail
argument_list|(
name|last
argument_list|,
name|ffeequiv_list
argument_list|(
name|eq1
argument_list|)
argument_list|)
expr_stmt|;
name|ffeequiv_set_list
argument_list|(
name|eq1
argument_list|,
name|ffeequiv_list
argument_list|(
name|eq2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unlink and kill the victim object. */
name|ffeequiv_kill
argument_list|(
name|eq2
argument_list|)
expr_stmt|;
return|return
name|eq1
return|;
comment|/* Return the new merged object. */
block|}
end_function

begin_comment
comment|/* ffeequiv_new -- Create new equivalence object, put in list     ffeequiv eq;    eq = ffeequiv_new();     Creates a new equivalence object and adds it to the list of equivalence    objects.  */
end_comment

begin_function
name|ffeequiv
name|ffeequiv_new
parameter_list|()
block|{
name|ffeequiv
name|eq
decl_stmt|;
name|eq
operator|=
name|malloc_new_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
literal|"ffeequiv"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eq
argument_list|)
argument_list|)
expr_stmt|;
name|eq
operator|->
name|next
operator|=
operator|(
name|ffeequiv
operator|)
operator|&
name|ffeequiv_list_
operator|.
name|first
expr_stmt|;
name|eq
operator|->
name|previous
operator|=
name|ffeequiv_list_
operator|.
name|last
expr_stmt|;
name|ffeequiv_set_common
argument_list|(
name|eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* No COMMON area yet. */
name|ffeequiv_set_list
argument_list|(
name|eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* No list of lists of equivalences yet. */
name|ffeequiv_set_is_save
argument_list|(
name|eq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffeequiv_set_is_init
argument_list|(
name|eq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eq
operator|->
name|next
operator|->
name|previous
operator|=
name|eq
expr_stmt|;
name|eq
operator|->
name|previous
operator|->
name|next
operator|=
name|eq
expr_stmt|;
return|return
name|eq
return|;
block|}
end_function

begin_comment
comment|/* ffeequiv_symbol -- Return symbol for equivalence expression     ffesymbol symbol;    ffebld expr;    symbol = ffeequiv_symbol(expr);     Finds the terminal SYMTER in an equivalence expression and returns the    ffesymbol for it.  */
end_comment

begin_function
name|ffesymbol
name|ffeequiv_symbol
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|assert
argument_list|(
name|expr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|again
label|:
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opARRAYREF
case|:
case|case
name|FFEBLD_opSUBSTR
case|:
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEBLD_opSYMTER
case|:
return|return
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
return|;
case|case
name|FFEBLD_opANY
case|:
return|return
name|NULL
return|;
default|default:
name|assert
argument_list|(
literal|"bad eq expr"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeequiv_update_init -- Update the INIT flag for the area to TRUE     ffeequiv eq;    ffeequiv_update_init(eq);     If the INIT flag for the<eq> object is already set, return.	 Else,    set it TRUE and call ffe*_update_init for all objects contained in    this one.  */
end_comment

begin_function
name|void
name|ffeequiv_update_init
parameter_list|(
name|ffeequiv
name|eq
parameter_list|)
block|{
name|ffebld
name|list
decl_stmt|;
comment|/* Current list in list of lists. */
name|ffebld
name|item
decl_stmt|;
comment|/* Current item in current list. */
name|ffebld
name|expr
decl_stmt|;
comment|/* Expression in head of current item. */
if|if
condition|(
name|eq
operator|->
name|is_init
condition|)
return|return;
name|eq
operator|->
name|is_init
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|eq
operator|->
name|common
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|ffesymbol_is_init
argument_list|(
name|eq
operator|->
name|common
argument_list|)
condition|)
name|ffesymbol_update_init
argument_list|(
name|eq
operator|->
name|common
argument_list|)
expr_stmt|;
comment|/* Shouldn't be needed. */
for|for
control|(
name|list
operator|=
name|eq
operator|->
name|list
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
for|for
control|(
name|item
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
name|expr
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|again
label|:
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opANY
case|:
break|break;
case|case
name|FFEBLD_opSYMTER
case|:
if|if
condition|(
operator|!
name|ffesymbol_is_init
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|ffesymbol_update_init
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opARRAYREF
case|:
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEBLD_opSUBSTR
case|:
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
default|default:
name|assert
argument_list|(
literal|"bad op for ffeequiv_update_init"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* ffeequiv_update_save -- Update the SAVE flag for the area to TRUE     ffeequiv eq;    ffeequiv_update_save(eq);     If the SAVE flag for the<eq> object is already set, return.	 Else,    set it TRUE and call ffe*_update_save for all objects contained in    this one.  */
end_comment

begin_function
name|void
name|ffeequiv_update_save
parameter_list|(
name|ffeequiv
name|eq
parameter_list|)
block|{
name|ffebld
name|list
decl_stmt|;
comment|/* Current list in list of lists. */
name|ffebld
name|item
decl_stmt|;
comment|/* Current item in current list. */
name|ffebld
name|expr
decl_stmt|;
comment|/* Expression in head of current item. */
if|if
condition|(
name|eq
operator|->
name|is_save
condition|)
return|return;
name|eq
operator|->
name|is_save
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|eq
operator|->
name|common
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|ffesymbol_is_save
argument_list|(
name|eq
operator|->
name|common
argument_list|)
condition|)
name|ffesymbol_update_save
argument_list|(
name|eq
operator|->
name|common
argument_list|)
expr_stmt|;
comment|/* Shouldn't be needed. */
for|for
control|(
name|list
operator|=
name|eq
operator|->
name|list
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
for|for
control|(
name|item
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
name|expr
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|again
label|:
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opANY
case|:
break|break;
case|case
name|FFEBLD_opSYMTER
case|:
if|if
condition|(
operator|!
name|ffesymbol_is_save
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|ffesymbol_update_save
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opARRAYREF
case|:
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEBLD_opSUBSTR
case|:
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
default|default:
name|assert
argument_list|(
literal|"bad op for ffeequiv_update_save"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

end_unit

