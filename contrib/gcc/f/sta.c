begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sta.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       None     Description:       Analyzes the first two tokens, figures out what statements are       possible, tries parsing the possible statements by calling on       the ffestb functions.     Modifications: */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"sta.h"
end_include

begin_include
include|#
directive|include
file|"bad.h"
end_include

begin_include
include|#
directive|include
file|"implic.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"stb.h"
end_include

begin_include
include|#
directive|include
file|"stc.h"
end_include

begin_include
include|#
directive|include
file|"std.h"
end_include

begin_include
include|#
directive|include
file|"str.h"
end_include

begin_include
include|#
directive|include
file|"storag.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_decl_stmt
name|ffelexToken
name|ffesta_tokens
index|[
name|FFESTA_tokensMAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For use by a possible. */
end_comment

begin_decl_stmt
name|ffestrFirst
name|ffesta_first_kw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First NAME(S) looked up. */
end_comment

begin_decl_stmt
name|ffestrSecond
name|ffesta_second_kw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Second NAME(S) looked up. */
end_comment

begin_decl_stmt
name|mallocPool
name|ffesta_output_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pool for results of stmt handling. */
end_comment

begin_decl_stmt
name|mallocPool
name|ffesta_scratch_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pool for stmt scratch handling. */
end_comment

begin_decl_stmt
name|ffelexToken
name|ffesta_construct_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ffelexToken
name|ffesta_label_token
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pending label stuff. */
end_comment

begin_decl_stmt
name|bool
name|ffesta_seen_first_exec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|ffesta_is_entry_valid
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE only in SUBROUTINE/FUNCTION. */
end_comment

begin_decl_stmt
name|bool
name|ffesta_line_has_semicolons
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_define
define|#
directive|define
name|FFESTA_ABORT_ON_CONFIRM_
value|1
end_define

begin_comment
comment|/* 0=slow, tested way; 1=faster way 					   that might not always work. Here's 					   the old description of what used 					   to not work with ==1: (try 					   "CONTINUE\10 					   FORMAT('hi',I11)\END").  Problem 					   is that the "topology" of the 					   confirmed stmt's tokens with 					   regard to CHARACTER, HOLLERITH, 					   NAME/NAMES/NUMBER tokens (like hex 					   numbers), isn't traced if we abort 					   early, then other stmts might get 					   their grubby hands on those 					   unprocessed tokens and commit them 					   improperly.	Ideal fix is to rerun 					   the confirmed stmt and forget the 					   rest.  */
end_comment

begin_define
define|#
directive|define
name|FFESTA_maxPOSSIBLES_
value|8
end_define

begin_comment
comment|/* Never more than this # of possibles. */
end_comment

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|_ffesta_possible_
modifier|*
name|ffestaPossible_
typedef|;
end_typedef

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_struct
struct|struct
name|_ffesta_possible_
block|{
name|ffestaPossible_
name|next
decl_stmt|;
name|ffestaPossible_
name|previous
decl_stmt|;
name|ffelexHandler
name|handler
decl_stmt|;
name|bool
name|named
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_ffesta_possible_root_
block|{
name|ffestaPossible_
name|first
decl_stmt|;
name|ffestaPossible_
name|last
decl_stmt|;
name|ffelexHandler
name|nil
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffesta_is_inhibited_
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffelexToken
name|ffesta_token_0_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For use by ffest possibility 					   handling. */
end_comment

begin_decl_stmt
specifier|static
name|ffestaPossible_
name|ffesta_possibles_
index|[
name|FFESTA_maxPOSSIBLES_
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ffesta_num_possibles_
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of possibilities. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|_ffesta_possible_root_
name|ffesta_possible_nonexecs_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|_ffesta_possible_root_
name|ffesta_possible_execs_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffestaPossible_
name|ffesta_current_possible_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffelexHandler
name|ffesta_current_handler_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ffesta_confirmed_current_
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ffesta_confirmed_other_
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffestaPossible_
name|ffesta_confirmed_possible_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ffesta_current_shutdown_
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|FFESTA_ABORT_ON_CONFIRM_
end_if

begin_decl_stmt
specifier|static
name|bool
name|ffesta_is_two_into_statement_
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For IF, WHERE stmts. */
end_comment

begin_decl_stmt
specifier|static
name|ffelexToken
name|ffesta_twotokens_1_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For IF, WHERE stmts. */
end_comment

begin_decl_stmt
specifier|static
name|ffelexToken
name|ffesta_twotokens_2_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For IF, WHERE stmts. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|ffestaPooldisp
name|ffesta_outpooldisp_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* After statement dealt 						   with. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffesta_inhibit_confirmation_
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_function_decl
specifier|static
name|void
name|ffesta_add_possible_
parameter_list|(
name|ffelexHandler
name|fn
parameter_list|,
name|bool
name|exec
parameter_list|,
name|bool
name|named
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffesta_inhibited_exec_transition_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffesta_reset_possibles_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffesta_save_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffesta_second_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|FFESTA_ABORT_ON_CONFIRM_
end_if

begin_function_decl
specifier|static
name|ffelexHandler
name|ffesta_send_two_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Internal macros. */
end_comment

begin_define
define|#
directive|define
name|ffesta_add_possible_exec_
parameter_list|(
name|fn
parameter_list|)
value|(ffesta_add_possible_ (fn, TRUE, TRUE))
end_define

begin_define
define|#
directive|define
name|ffesta_add_possible_nonexec_
parameter_list|(
name|fn
parameter_list|)
value|(ffesta_add_possible_ (fn, FALSE, TRUE))
end_define

begin_define
define|#
directive|define
name|ffesta_add_possible_unnamed_exec_
parameter_list|(
name|fn
parameter_list|)
value|(ffesta_add_possible_ (fn, TRUE, FALSE))
end_define

begin_define
define|#
directive|define
name|ffesta_add_possible_unnamed_nonexec_
parameter_list|(
name|fn
parameter_list|)
value|(ffesta_add_possible_ (fn, FALSE, FALSE))
end_define

begin_escape
end_escape

begin_comment
comment|/* Add possible statement to appropriate list.  */
end_comment

begin_function
specifier|static
name|void
name|ffesta_add_possible_
parameter_list|(
name|ffelexHandler
name|fn
parameter_list|,
name|bool
name|exec
parameter_list|,
name|bool
name|named
parameter_list|)
block|{
name|ffestaPossible_
name|p
decl_stmt|;
name|assert
argument_list|(
name|ffesta_num_possibles_
operator|<
name|FFESTA_maxPOSSIBLES_
argument_list|)
expr_stmt|;
name|p
operator|=
name|ffesta_possibles_
index|[
name|ffesta_num_possibles_
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|exec
condition|)
block|{
name|p
operator|->
name|next
operator|=
operator|(
name|ffestaPossible_
operator|)
operator|&
name|ffesta_possible_execs_
operator|.
name|first
expr_stmt|;
name|p
operator|->
name|previous
operator|=
name|ffesta_possible_execs_
operator|.
name|last
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|next
operator|=
operator|(
name|ffestaPossible_
operator|)
operator|&
name|ffesta_possible_nonexecs_
operator|.
name|first
expr_stmt|;
name|p
operator|->
name|previous
operator|=
name|ffesta_possible_nonexecs_
operator|.
name|last
expr_stmt|;
block|}
name|p
operator|->
name|next
operator|->
name|previous
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|previous
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|handler
operator|=
name|fn
expr_stmt|;
name|p
operator|->
name|named
operator|=
name|named
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffesta_inhibited_exec_transition_ -- Do exec transition while inhibited     if (!ffesta_inhibited_exec_transition_())  // couldn't transition...     Invokes ffestc_exec_transition, but first enables ffebad and ffesta and    afterwards disables them again.  Then returns the result of the    invocation of ffestc_exec_transition.  */
end_comment

begin_function
specifier|static
name|bool
name|ffesta_inhibited_exec_transition_
parameter_list|()
block|{
name|bool
name|result
decl_stmt|;
name|assert
argument_list|(
name|ffebad_inhibit
argument_list|()
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffesta_is_inhibited_
argument_list|)
expr_stmt|;
name|ffebad_set_inhibit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|ffesta_is_inhibited_
operator|=
name|FALSE
expr_stmt|;
name|result
operator|=
name|ffestc_exec_transition
argument_list|()
expr_stmt|;
name|ffebad_set_inhibit
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffesta_is_inhibited_
operator|=
name|TRUE
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* ffesta_reset_possibles_ -- Reset (clear) lists of possible statements     ffesta_reset_possibles_();     Clears the lists of executable and nonexecutable statements.	 */
end_comment

begin_function
specifier|static
name|void
name|ffesta_reset_possibles_
parameter_list|()
block|{
name|ffesta_num_possibles_
operator|=
literal|0
expr_stmt|;
name|ffesta_possible_execs_
operator|.
name|first
operator|=
name|ffesta_possible_execs_
operator|.
name|last
operator|=
operator|(
name|ffestaPossible_
operator|)
operator|&
name|ffesta_possible_execs_
operator|.
name|first
expr_stmt|;
name|ffesta_possible_nonexecs_
operator|.
name|first
operator|=
name|ffesta_possible_nonexecs_
operator|.
name|last
operator|=
operator|(
name|ffestaPossible_
operator|)
operator|&
name|ffesta_possible_nonexecs_
operator|.
name|first
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffesta_save_ -- Save token on list, pass thru to current handler     return ffesta_save_;	 // to lexer.     Receives a token from the lexer.  Saves it in the list of tokens.  Calls    the current handler with the token.     If no shutdown error occurred (via    ffest_ffebad_start), then if the token was EOS or SEMICOLON, mark the    current possible as successful and confirmed but try the next possible    anyway until ambiguities in the form handling are ironed out.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffesta_save_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
specifier|static
name|ffelexToken
modifier|*
name|saved_tokens
init|=
name|NULL
decl_stmt|;
comment|/* A variable-sized array. */
specifier|static
name|unsigned
name|int
name|num_saved_tokens
init|=
literal|0
decl_stmt|;
comment|/* Number currently saved. */
specifier|static
name|unsigned
name|int
name|max_saved_tokens
init|=
literal|0
decl_stmt|;
comment|/* Maximum to be saved. */
name|unsigned
name|int
name|toknum
decl_stmt|;
comment|/* Index into saved_tokens array. */
name|ffelexToken
name|eos
decl_stmt|;
comment|/* EOS created on-the-fly for shutdown 				   purposes. */
name|ffelexToken
name|t2
decl_stmt|;
comment|/* Another temporary token (no intersect with 				   eos, btw). */
comment|/* Save the current token. */
if|if
condition|(
name|saved_tokens
operator|==
name|NULL
condition|)
block|{
name|saved_tokens
operator|=
operator|(
name|ffelexToken
operator|*
operator|)
name|malloc_new_ksr
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFEST Saved Tokens"
argument_list|,
operator|(
name|max_saved_tokens
operator|=
literal|8
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ffelexToken
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start off with 8. */
block|}
elseif|else
if|if
condition|(
name|num_saved_tokens
operator|>=
name|max_saved_tokens
condition|)
block|{
name|toknum
operator|=
name|max_saved_tokens
expr_stmt|;
name|max_saved_tokens
operator|<<=
literal|1
expr_stmt|;
comment|/* Multiply by two. */
name|assert
argument_list|(
name|max_saved_tokens
operator|>
name|toknum
argument_list|)
expr_stmt|;
name|saved_tokens
operator|=
operator|(
name|ffelexToken
operator|*
operator|)
name|malloc_resize_ksr
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
name|saved_tokens
argument_list|,
name|max_saved_tokens
operator|*
sizeof|sizeof
argument_list|(
name|ffelexToken
argument_list|)
argument_list|,
name|toknum
operator|*
sizeof|sizeof
argument_list|(
name|ffelexToken
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|saved_tokens
operator|+
name|num_saved_tokens
operator|++
operator|)
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Transmit the current token to the current handler. */
name|ffesta_current_handler_
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|ffesta_current_handler_
argument_list|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* See if this possible has been shut down, or confirmed in which case we      might as well shut it down anyway to save time. */
if|if
condition|(
operator|(
name|ffesta_current_shutdown_
operator|||
operator|(
name|FFESTA_ABORT_ON_CONFIRM_
operator|&&
name|ffesta_confirmed_current_
operator|)
operator|)
operator|&&
operator|!
name|ffelex_expecting_character
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
break|break;
default|default:
name|eos
operator|=
name|ffelex_token_new_eos
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffesta_inhibit_confirmation_
operator|=
name|ffesta_current_shutdown_
expr_stmt|;
call|(
modifier|*
name|ffesta_current_handler_
call|)
argument_list|(
name|eos
argument_list|)
expr_stmt|;
name|ffesta_inhibit_confirmation_
operator|=
name|FALSE
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|eos
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* If this is an EOS or SEMICOLON token, switch to next handler, else 	 return self as next handler for lexer. */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
break|break;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_save_
return|;
block|}
block|}
name|next_handler
label|:
comment|/* :::::::::::::::::::: */
comment|/* Note that a shutdown also happens after seeing the first two tokens      after "IF (expr)" or "WHERE (expr)" where a statement follows, even      though there is no error.	This causes the IF or WHERE form to be      implemented first before ffest_first is called for the first token in      the following statement. */
if|if
condition|(
name|ffesta_current_shutdown_
condition|)
name|ffesta_current_shutdown_
operator|=
name|FALSE
expr_stmt|;
comment|/* Only after sending EOS! */
else|else
name|assert
argument_list|(
name|ffesta_confirmed_current_
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_confirmed_current_
condition|)
block|{
name|ffesta_confirmed_current_
operator|=
name|FALSE
expr_stmt|;
name|ffesta_confirmed_other_
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Pick next handler. */
name|ffesta_current_possible_
operator|=
name|ffesta_current_possible_
operator|->
name|next
expr_stmt|;
name|ffesta_current_handler_
operator|=
name|ffesta_current_possible_
operator|->
name|handler
expr_stmt|;
if|if
condition|(
name|ffesta_current_handler_
operator|==
name|NULL
condition|)
block|{
comment|/* No handler in this list, try exec list if 				   not tried yet. */
if|if
condition|(
name|ffesta_current_possible_
operator|==
operator|(
name|ffestaPossible_
operator|)
operator|&
name|ffesta_possible_nonexecs_
condition|)
block|{
name|ffesta_current_possible_
operator|=
name|ffesta_possible_execs_
operator|.
name|first
expr_stmt|;
name|ffesta_current_handler_
operator|=
name|ffesta_current_possible_
operator|->
name|handler
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ffesta_current_handler_
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|!
name|ffesta_seen_first_exec
operator|&&
operator|(
operator|(
name|ffesta_confirmed_possible_
operator|!=
name|NULL
operator|)
operator|||
operator|!
name|ffesta_inhibited_exec_transition_
argument_list|()
operator|)
operator|)
condition|)
comment|/* Don't run execs if:	  (decoding the "if" ^^^ up here ^^^) - we 	   have no exec handler available, or - we haven't seen the first 	   executable statement yet, and - we've confirmed a nonexec 	   (otherwise even a nonexec would cause a transition), or - a 	   nonexec-to-exec transition can't be made at the statement context 	   level (as in an executable statement in the middle of a STRUCTURE 	   definition); if it can be made, ffestc_exec_transition makes the 	   corresponding transition at the statement state level so 	   specification statements are no longer accepted following an 	   unrecognized statement.  (Note: it is valid for f_e_t_ to decide 	   to always return TRUE by "shrieking" away the statement state 	   stack until a transitionable state is reached.  Or it can leave 	   the stack as is and return FALSE.)  	   If we decide not to run execs, enter this block to rerun the 	   confirmed statement, if any. */
block|{
comment|/* At end of both lists!  Pick confirmed or 				   first possible. */
name|ffebad_set_inhibit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|ffesta_is_inhibited_
operator|=
name|FALSE
expr_stmt|;
name|ffesta_confirmed_other_
operator|=
name|FALSE
expr_stmt|;
name|ffesta_tokens
index|[
literal|0
index|]
operator|=
name|ffesta_token_0_
expr_stmt|;
if|if
condition|(
name|ffesta_confirmed_possible_
operator|==
name|NULL
condition|)
block|{
comment|/* No confirmed success, just use first 				   named possible, or first possible if 				   no named possibles. */
name|ffestaPossible_
name|possible
init|=
name|ffesta_possible_nonexecs_
operator|.
name|first
decl_stmt|;
name|ffestaPossible_
name|first
init|=
name|NULL
decl_stmt|;
name|ffestaPossible_
name|first_named
init|=
name|NULL
decl_stmt|;
name|ffestaPossible_
name|first_exec
init|=
name|NULL
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|possible
operator|->
name|handler
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|possible
operator|==
operator|(
name|ffestaPossible_
operator|)
operator|&
name|ffesta_possible_nonexecs_
condition|)
block|{
name|possible
operator|=
name|first_exec
operator|=
name|ffesta_possible_execs_
operator|.
name|first
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
name|first
operator|=
name|possible
expr_stmt|;
if|if
condition|(
name|possible
operator|->
name|named
operator|&&
operator|(
name|first_named
operator|==
name|NULL
operator|)
condition|)
name|first_named
operator|=
name|possible
expr_stmt|;
name|possible
operator|=
name|possible
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|first_named
operator|!=
name|NULL
condition|)
name|ffesta_current_possible_
operator|=
name|first_named
expr_stmt|;
elseif|else
if|if
condition|(
name|ffesta_seen_first_exec
operator|&&
operator|(
name|first_exec
operator|!=
name|NULL
operator|)
condition|)
name|ffesta_current_possible_
operator|=
name|first_exec
expr_stmt|;
else|else
name|ffesta_current_possible_
operator|=
name|first
expr_stmt|;
name|ffesta_current_handler_
operator|=
name|ffesta_current_possible_
operator|->
name|handler
expr_stmt|;
name|assert
argument_list|(
name|ffesta_current_handler_
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Confirmed success, use it. */
name|ffesta_current_possible_
operator|=
name|ffesta_confirmed_possible_
expr_stmt|;
name|ffesta_current_handler_
operator|=
name|ffesta_confirmed_possible_
operator|->
name|handler
expr_stmt|;
block|}
name|ffesta_reset_possibles_
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Switching from [empty?] list of nonexecs 				   to nonempty list of execs at this point. */
name|ffesta_tokens
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ffesta_token_0_
argument_list|)
expr_stmt|;
name|ffesymbol_set_retractable
argument_list|(
name|ffesta_scratch_pool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ffesta_tokens
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ffesta_token_0_
argument_list|)
expr_stmt|;
name|ffesymbol_set_retractable
argument_list|(
name|ffesta_scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Send saved tokens to current handler until either shut down or all      tokens sent. */
for|for
control|(
name|toknum
operator|=
literal|0
init|;
name|toknum
operator|<
name|num_saved_tokens
condition|;
operator|++
name|toknum
control|)
block|{
name|t
operator|=
operator|*
operator|(
name|saved_tokens
operator|+
name|toknum
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCHARACTER
case|:
name|ffelex_set_expecting_hollerith
argument_list|(
literal|0
argument_list|,
literal|'\0'
argument_list|,
name|ffewhere_line_unknown
argument_list|()
argument_list|,
name|ffewhere_column_unknown
argument_list|()
argument_list|)
expr_stmt|;
name|ffesta_current_handler_
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|ffesta_current_handler_
argument_list|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffelex_is_names_expected
argument_list|()
condition|)
name|ffesta_current_handler_
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|ffesta_current_handler_
argument_list|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|t2
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffesta_current_handler_
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|ffesta_current_handler_
argument_list|)
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|ffesta_current_handler_
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|ffesta_current_handler_
argument_list|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited_
condition|)
name|ffelex_token_kill
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Won't need this any more. */
comment|/* See if this possible has been shut down. */
elseif|else
if|if
condition|(
operator|(
name|ffesta_current_shutdown_
operator|||
operator|(
name|FFESTA_ABORT_ON_CONFIRM_
operator|&&
name|ffesta_confirmed_current_
operator|)
operator|)
operator|&&
operator|!
name|ffelex_expecting_character
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
break|break;
default|default:
name|eos
operator|=
name|ffelex_token_new_eos
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffesta_inhibit_confirmation_
operator|=
name|ffesta_current_shutdown_
expr_stmt|;
call|(
modifier|*
name|ffesta_current_handler_
call|)
argument_list|(
name|eos
argument_list|)
expr_stmt|;
name|ffesta_inhibit_confirmation_
operator|=
name|FALSE
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|eos
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|next_handler
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
comment|/* Finished sending all the tokens so far.  If still trying possibilities,      then if we've just sent an EOS or SEMICOLON token through, go to the      next handler.  Otherwise, return self so we can gather and process more      tokens. */
if|if
condition|(
name|ffesta_is_inhibited_
condition|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
goto|goto
name|next_handler
goto|;
comment|/* :::::::::::::::::::: */
default|default:
if|#
directive|if
name|FFESTA_ABORT_ON_CONFIRM_
name|assert
argument_list|(
operator|!
name|ffesta_confirmed_other_
argument_list|)
expr_stmt|;
comment|/* Catch ambiguities. */
endif|#
directive|endif
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_save_
return|;
block|}
block|}
comment|/* This was the one final possibility, uninhibited, so send the final      handler it sent. */
name|num_saved_tokens
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|FFESTA_ABORT_ON_CONFIRM_
if|if
condition|(
name|ffesta_is_two_into_statement_
condition|)
block|{
comment|/* End of the line for the previous two 				   tokens, resurrect them. */
name|ffelexHandler
name|next
decl_stmt|;
name|ffesta_is_two_into_statement_
operator|=
name|FALSE
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffesta_first
argument_list|(
name|ffesta_twotokens_1_
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_twotokens_1_
argument_list|)
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|ffesta_twotokens_2_
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_twotokens_2_
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|next
return|;
block|}
endif|#
directive|endif
name|assert
argument_list|(
name|ffesta_current_handler_
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_current_handler_
return|;
block|}
end_function

begin_comment
comment|/* ffesta_second_ -- Parse the token after a NAME/NAMES in a statement     return ffesta_second_;  // to lexer.     The second token cannot be a NAMES, since the first token is a NAME or    NAMES.  If the second token is a NAME, look up its name in the list of    second names for use by whoever needs it.     Then make a list of all the possible statements this could be, based on    looking at the first two tokens.  Two lists of possible statements are    created, one consisting of nonexecutable statements, the other consisting    of executable statements.     If the total number of possibilities is one, just fire up that    possibility by calling its handler function, passing the first two    tokens through it and so on.     Otherwise, start up a process whereby tokens are passed to the first    possibility on the list until EOS or SEMICOLON is reached or an error    is detected.	 But inhibit any actual reporting of errors; just record    their existence in the list.	 If EOS or SEMICOLON is reached with no    errors (other than non-form errors happening downstream, such as an    overflowing value for an integer or a GOTO statement identifying a label    on a FORMAT statement), then that is the only possible statement.  Rerun    the statement with error-reporting turned on if any non-form errors were    generated, otherwise just use its results, then erase the list of tokens    memorized during the search process.	 If a form error occurs, immediately    cancel that possibility by sending EOS as the next token, remember the    error code for that possibility, and try the next possibility on the list,    first sending it the list of tokens memorized while handling the first    possibility, then continuing on as before.     Ultimately, either the end of the list of possibilities will be reached    without any successful forms being detected, in which case we pick one    based on hueristics (usually the first possibility) and rerun it with    error reporting turned on using the list of memorized tokens so the user    sees the error, or one of the possibilities will effectively succeed.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffesta_second_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNAMES
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
condition|)
name|ffesta_second_kw
operator|=
name|ffestr_second
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Here we use switch on the first keyword name and handle each possible      recognizable name by looking at the second token, and building the list      of possible names accordingly.  For now, just put every possible      statement on the list for ambiguity checking. */
switch|switch
condition|(
name|ffesta_first_kw
condition|)
block|{
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTR_firstACCEPT
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_V019
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstALLOCATABLE
case|:
name|ffestb_args
operator|.
name|dimlist
operator|.
name|len
operator|=
name|FFESTR_firstlALLOCATABLE
expr_stmt|;
name|ffestb_args
operator|.
name|dimlist
operator|.
name|badname
operator|=
literal|"ALLOCATABLE"
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_dimlist
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstALLOCATE
case|:
name|ffestb_args
operator|.
name|heap
operator|.
name|len
operator|=
name|FFESTR_firstlALLOCATE
expr_stmt|;
name|ffestb_args
operator|.
name|heap
operator|.
name|badname
operator|=
literal|"ALLOCATE"
expr_stmt|;
name|ffestb_args
operator|.
name|heap
operator|.
name|ctx
operator|=
name|FFEEXPR_contextALLOCATE
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_heap
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstASSIGN
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R838
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstBACKSPACE
case|:
name|ffestb_args
operator|.
name|beru
operator|.
name|len
operator|=
name|FFESTR_firstlBACKSPACE
expr_stmt|;
name|ffestb_args
operator|.
name|beru
operator|.
name|badname
operator|=
literal|"BACKSPACE"
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstBLOCK
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_block
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstBLOCKDATA
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_blockdata
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstBYTE
case|:
name|ffestb_args
operator|.
name|decl
operator|.
name|len
operator|=
name|FFESTR_firstlBYTE
expr_stmt|;
name|ffestb_args
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeBYTE
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_gentype
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstCALL
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R1212
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstCASE
case|:
case|case
name|FFESTR_firstCASEDEFAULT
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R810
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstCHRCTR
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_chartype
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstCLOSE
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R907
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstCOMMON
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R547
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstCMPLX
case|:
name|ffestb_args
operator|.
name|decl
operator|.
name|len
operator|=
name|FFESTR_firstlCMPLX
expr_stmt|;
name|ffestb_args
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeCOMPLEX
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_gentype
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstCONTAINS
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R1228
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstCONTINUE
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R841
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstCYCLE
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R834
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstDATA
case|:
if|if
condition|(
name|ffe_is_pedantic_not_90
argument_list|()
condition|)
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R528
argument_list|)
expr_stmt|;
else|else
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R528
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstDEALLOCATE
case|:
name|ffestb_args
operator|.
name|heap
operator|.
name|len
operator|=
name|FFESTR_firstlDEALLOCATE
expr_stmt|;
name|ffestb_args
operator|.
name|heap
operator|.
name|badname
operator|=
literal|"DEALLOCATE"
expr_stmt|;
name|ffestb_args
operator|.
name|heap
operator|.
name|ctx
operator|=
name|FFEEXPR_contextDEALLOCATE
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_heap
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTR_firstDECODE
case|:
name|ffestb_args
operator|.
name|vxtcode
operator|.
name|len
operator|=
name|FFESTR_firstlDECODE
expr_stmt|;
name|ffestb_args
operator|.
name|vxtcode
operator|.
name|badname
operator|=
literal|"DECODE"
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_vxtcode
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTR_firstDEFINEFILE
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_V025
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstDELETE
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_V021
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstDIMENSION
case|:
name|ffestb_args
operator|.
name|R524
operator|.
name|len
operator|=
name|FFESTR_firstlDIMENSION
expr_stmt|;
name|ffestb_args
operator|.
name|R524
operator|.
name|badname
operator|=
literal|"DIMENSION"
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R524
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstDO
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_do
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstDBL
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_double
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstDBLCMPLX
case|:
name|ffestb_args
operator|.
name|decl
operator|.
name|len
operator|=
name|FFESTR_firstlDBLCMPLX
expr_stmt|;
name|ffestb_args
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeDBLCMPLX
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_dbltype
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstDBLPRCSN
case|:
name|ffestb_args
operator|.
name|decl
operator|.
name|len
operator|=
name|FFESTR_firstlDBLPRCSN
expr_stmt|;
name|ffestb_args
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeDBLPRCSN
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_dbltype
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstDOWHILE
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_dowhile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstELSE
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_else
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstELSEIF
case|:
name|ffestb_args
operator|.
name|elsexyz
operator|.
name|second
operator|=
name|FFESTR_secondIF
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_elsexyz
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstELSEWHERE
case|:
name|ffestb_args
operator|.
name|elsexyz
operator|.
name|second
operator|=
name|FFESTR_secondWHERE
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_elsexyz
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTR_firstENCODE
case|:
name|ffestb_args
operator|.
name|vxtcode
operator|.
name|len
operator|=
name|FFESTR_firstlENCODE
expr_stmt|;
name|ffestb_args
operator|.
name|vxtcode
operator|.
name|badname
operator|=
literal|"ENCODE"
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_vxtcode
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstEND
case|:
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|ffesta_token_0_
argument_list|)
operator|==
name|FFELEX_typeNAMES
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNAME
operator|)
condition|)
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_end
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|ffesta_second_kw
condition|)
block|{
case|case
name|FFESTR_secondBLOCK
case|:
case|case
name|FFESTR_secondBLOCKDATA
case|:
case|case
name|FFESTR_secondDO
case|:
case|case
name|FFESTR_secondFILE
case|:
case|case
name|FFESTR_secondFUNCTION
case|:
case|case
name|FFESTR_secondIF
case|:
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_secondMODULE
case|:
endif|#
directive|endif
case|case
name|FFESTR_secondPROGRAM
case|:
case|case
name|FFESTR_secondSELECT
case|:
case|case
name|FFESTR_secondSUBROUTINE
case|:
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_secondWHERE
case|:
endif|#
directive|endif
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_end
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_end
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|FFESTR_firstENDBLOCK
case|:
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|=
name|FFESTR_firstlENDBLOCK
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondBLOCK
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_endxyz
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstENDBLOCKDATA
case|:
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|=
name|FFESTR_firstlENDBLOCKDATA
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondBLOCKDATA
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_endxyz
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstENDDO
case|:
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|=
name|FFESTR_firstlENDDO
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondDO
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_endxyz
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstENDFILE
case|:
name|ffestb_args
operator|.
name|beru
operator|.
name|len
operator|=
name|FFESTR_firstlENDFILE
expr_stmt|;
name|ffestb_args
operator|.
name|beru
operator|.
name|badname
operator|=
literal|"ENDFILE"
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstENDFUNCTION
case|:
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|=
name|FFESTR_firstlENDFUNCTION
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondFUNCTION
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_endxyz
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstENDIF
case|:
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|=
name|FFESTR_firstlENDIF
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondIF
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_endxyz
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstENDINTERFACE
case|:
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|=
name|FFESTR_firstlENDINTERFACE
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondINTERFACE
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_endxyz
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTR_firstENDMAP
case|:
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|=
name|FFESTR_firstlENDMAP
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondMAP
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_endxyz
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstENDMODULE
case|:
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|=
name|FFESTR_firstlENDMODULE
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondMODULE
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_endxyz
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstENDPROGRAM
case|:
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|=
name|FFESTR_firstlENDPROGRAM
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondPROGRAM
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_endxyz
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstENDSELECT
case|:
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|=
name|FFESTR_firstlENDSELECT
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondSELECT
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_endxyz
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTR_firstENDSTRUCTURE
case|:
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|=
name|FFESTR_firstlENDSTRUCTURE
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondSTRUCTURE
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_endxyz
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstENDSUBROUTINE
case|:
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|=
name|FFESTR_firstlENDSUBROUTINE
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondSUBROUTINE
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_endxyz
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstENDTYPE
case|:
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|=
name|FFESTR_firstlENDTYPE
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondTYPE
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_endxyz
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTR_firstENDUNION
case|:
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|=
name|FFESTR_firstlENDUNION
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondUNION
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_endxyz
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstENDWHERE
case|:
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|=
name|FFESTR_firstlENDWHERE
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondWHERE
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_endxyz
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstENTRY
case|:
name|ffestb_args
operator|.
name|dummy
operator|.
name|len
operator|=
name|FFESTR_firstlENTRY
expr_stmt|;
name|ffestb_args
operator|.
name|dummy
operator|.
name|badname
operator|=
literal|"ENTRY"
expr_stmt|;
name|ffestb_args
operator|.
name|dummy
operator|.
name|is_subr
operator|=
name|ffestc_is_entry_in_subr
argument_list|()
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_dummy
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstEQUIVALENCE
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R544
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstEXIT
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R835
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstEXTERNAL
case|:
name|ffestb_args
operator|.
name|varlist
operator|.
name|len
operator|=
name|FFESTR_firstlEXTERNAL
expr_stmt|;
name|ffestb_args
operator|.
name|varlist
operator|.
name|badname
operator|=
literal|"EXTERNAL"
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_varlist
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTR_firstFIND
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_V026
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* WARNING: don't put anything that might cause an item to precede 	 FORMAT in the list of possible statements (it's added below) without 	 making sure FORMAT still is first.  It has to run with 	 ffelex_set_names_pure(TRUE), to make sure the lexer delivers NAMES 	 tokens. */
case|case
name|FFESTR_firstFORMAT
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R1001
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstFUNCTION
case|:
name|ffestb_args
operator|.
name|dummy
operator|.
name|len
operator|=
name|FFESTR_firstlFUNCTION
expr_stmt|;
name|ffestb_args
operator|.
name|dummy
operator|.
name|badname
operator|=
literal|"FUNCTION"
expr_stmt|;
name|ffestb_args
operator|.
name|dummy
operator|.
name|is_subr
operator|=
name|FALSE
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_dummy
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstGOTO
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_goto
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstIF
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_if
argument_list|)
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R840
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstIMPLICIT
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstINCLUDE
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_S3P4
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeAPOSTROPHE
case|:
case|case
name|FFELEX_typeQUOTE
case|:
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FFESTR_firstINQUIRE
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R923
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstINTGR
case|:
name|ffestb_args
operator|.
name|decl
operator|.
name|len
operator|=
name|FFESTR_firstlINTGR
expr_stmt|;
name|ffestb_args
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeINTEGER
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_gentype
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstINTENT
case|:
name|ffestb_args
operator|.
name|varlist
operator|.
name|len
operator|=
name|FFESTR_firstlINTENT
expr_stmt|;
name|ffestb_args
operator|.
name|varlist
operator|.
name|badname
operator|=
literal|"INTENT"
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_varlist
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstINTERFACE
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R1202
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstINTRINSIC
case|:
name|ffestb_args
operator|.
name|varlist
operator|.
name|len
operator|=
name|FFESTR_firstlINTRINSIC
expr_stmt|;
name|ffestb_args
operator|.
name|varlist
operator|.
name|badname
operator|=
literal|"INTRINSIC"
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_varlist
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstLGCL
case|:
name|ffestb_args
operator|.
name|decl
operator|.
name|len
operator|=
name|FFESTR_firstlLGCL
expr_stmt|;
name|ffestb_args
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeLOGICAL
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_gentype
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTR_firstMAP
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_V012
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstMODULE
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_module
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstNAMELIST
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R542
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstNULLIFY
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R624
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstOPEN
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R904
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstOPTIONAL
case|:
name|ffestb_args
operator|.
name|varlist
operator|.
name|len
operator|=
name|FFESTR_firstlOPTIONAL
expr_stmt|;
name|ffestb_args
operator|.
name|varlist
operator|.
name|badname
operator|=
literal|"OPTIONAL"
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_varlist
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstPARAMETER
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R537
argument_list|)
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_V027
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstPAUSE
case|:
name|ffestb_args
operator|.
name|halt
operator|.
name|len
operator|=
name|FFESTR_firstlPAUSE
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_halt
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstPOINTER
case|:
name|ffestb_args
operator|.
name|dimlist
operator|.
name|len
operator|=
name|FFESTR_firstlPOINTER
expr_stmt|;
name|ffestb_args
operator|.
name|dimlist
operator|.
name|badname
operator|=
literal|"POINTER"
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_dimlist
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstPRINT
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R911
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|HARD_F90
case|case
name|FFESTR_firstPRIVATE
case|:
name|ffestb_args
operator|.
name|varlist
operator|.
name|len
operator|=
name|FFESTR_firstlPRIVATE
expr_stmt|;
name|ffestb_args
operator|.
name|varlist
operator|.
name|badname
operator|=
literal|"ACCESS"
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_varlist
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstPROGRAM
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R1102
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|HARD_F90
case|case
name|FFESTR_firstPUBLIC
case|:
name|ffestb_args
operator|.
name|varlist
operator|.
name|len
operator|=
name|FFESTR_firstlPUBLIC
expr_stmt|;
name|ffestb_args
operator|.
name|varlist
operator|.
name|badname
operator|=
literal|"ACCESS"
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_varlist
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstREAD
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R909
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstREAL
case|:
name|ffestb_args
operator|.
name|decl
operator|.
name|len
operator|=
name|FFESTR_firstlREAL
expr_stmt|;
name|ffestb_args
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeREAL
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_gentype
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTR_firstRECORD
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_V016
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstRECURSIVE
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_recursive
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstRETURN
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R1227
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstREWIND
case|:
name|ffestb_args
operator|.
name|beru
operator|.
name|len
operator|=
name|FFESTR_firstlREWIND
expr_stmt|;
name|ffestb_args
operator|.
name|beru
operator|.
name|badname
operator|=
literal|"REWIND"
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTR_firstREWRITE
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_V018
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstSAVE
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R522
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstSELECT
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R809
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstSELECTCASE
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R809
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|HARD_F90
case|case
name|FFESTR_firstSEQUENCE
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R423B
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstSTOP
case|:
name|ffestb_args
operator|.
name|halt
operator|.
name|len
operator|=
name|FFESTR_firstlSTOP
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_halt
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTR_firstSTRUCTURE
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_V003
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstSUBROUTINE
case|:
name|ffestb_args
operator|.
name|dummy
operator|.
name|len
operator|=
name|FFESTR_firstlSUBROUTINE
expr_stmt|;
name|ffestb_args
operator|.
name|dummy
operator|.
name|badname
operator|=
literal|"SUBROUTINE"
expr_stmt|;
name|ffestb_args
operator|.
name|dummy
operator|.
name|is_subr
operator|=
name|TRUE
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_dummy
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstTARGET
case|:
name|ffestb_args
operator|.
name|dimlist
operator|.
name|len
operator|=
name|FFESTR_firstlTARGET
expr_stmt|;
name|ffestb_args
operator|.
name|dimlist
operator|.
name|badname
operator|=
literal|"TARGET"
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_dimlist
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstTYPE
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_V020
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstTYPE
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_type
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|HARD_F90
case|case
name|FFESTR_firstTYPE
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_typetype
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTR_firstUNLOCK
case|:
name|ffestb_args
operator|.
name|beru
operator|.
name|len
operator|=
name|FFESTR_firstlUNLOCK
expr_stmt|;
name|ffestb_args
operator|.
name|beru
operator|.
name|badname
operator|=
literal|"UNLOCK"
expr_stmt|;
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTR_firstUNION
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_V009
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTR_firstUSE
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R1107
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstVIRTUAL
case|:
name|ffestb_args
operator|.
name|R524
operator|.
name|len
operator|=
name|FFESTR_firstlVIRTUAL
expr_stmt|;
name|ffestb_args
operator|.
name|R524
operator|.
name|badname
operator|=
literal|"VIRTUAL"
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R524
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstVOLATILE
case|:
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_V014
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|HARD_F90
case|case
name|FFESTR_firstWHERE
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_where
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTR_firstWORD
case|:
name|ffestb_args
operator|.
name|decl
operator|.
name|len
operator|=
name|FFESTR_firstlWORD
expr_stmt|;
name|ffestb_args
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeWORD
expr_stmt|;
name|ffesta_add_possible_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_gentype
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstWRITE
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R910
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Now check the default cases, which are always "live" (meaning that no      other possibility can override them).  These are where the second token      is OPEN_PAREN, PERCENT, EQUALS, POINTS, or COLON. */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|s
operator|=
name|ffesymbol_lookup_local
argument_list|(
name|ffesta_token_0_
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|s
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffesymbol_dims
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|&&
operator|!
name|ffesta_seen_first_exec
condition|)
block|{
comment|/* Not known as array; may be stmt function. */
name|ffesta_add_possible_unnamed_nonexec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_R1229
argument_list|)
expr_stmt|;
comment|/* If the symbol is (or will be due to implicit typing) of 	     CHARACTER type, then the statement might be an assignment 	     statement.	 If so, since it can't be a function invocation nor 	     an array element reference, the open paren following the symbol 	     name must be followed by an expression and a colon.  Without the 	     colon (which cannot appear in a stmt function definition), the 	     let stmt rejects.	So CHARACTER_NAME(...)=expr, unlike any other 	     type, is not ambiguous alone. */
if|if
condition|(
name|ffeimplic_peek_symbol_type
argument_list|(
name|s
argument_list|,
name|ffelex_token_text
argument_list|(
name|ffesta_token_0_
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
name|ffesta_add_possible_unnamed_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_let
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Not statement function if known as an 				   array. */
name|ffesta_add_possible_unnamed_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_let
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFELEX_typePERCENT
case|:
endif|#
directive|endif
case|case
name|FFELEX_typeEQUALS
case|:
if|#
directive|if
name|FFESTR_F90
case|case
name|FFELEX_typePOINTS
case|:
endif|#
directive|endif
name|ffesta_add_possible_unnamed_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_let
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELEX_typeCOLON
case|:
name|ffesta_add_possible_exec_
argument_list|(
operator|(
name|ffelexHandler
operator|)
name|ffestb_construct
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
comment|/* Now see how many possibilities are on the list. */
switch|switch
condition|(
name|ffesta_num_possibles_
condition|)
block|{
case|case
literal|0
case|:
comment|/* None, so invalid statement. */
name|no_stmts
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_tokens
index|[
literal|0
index|]
operator|=
name|ffesta_token_0_
expr_stmt|;
name|ffesta_ffebad_2t
argument_list|(
name|FFEBAD_UNREC_STMT
argument_list|,
name|ffesta_token_0_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|NULL
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* One, so just do it! */
name|ffesta_tokens
index|[
literal|0
index|]
operator|=
name|ffesta_token_0_
expr_stmt|;
name|next
operator|=
name|ffesta_possible_execs_
operator|.
name|first
operator|->
name|handler
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
comment|/* Have a nonexec stmt. */
name|next
operator|=
name|ffesta_possible_nonexecs_
operator|.
name|first
operator|->
name|handler
expr_stmt|;
name|assert
argument_list|(
name|next
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffesta_seen_first_exec
condition|)
empty_stmt|;
comment|/* Have an exec stmt after exec transition. */
elseif|else
if|if
condition|(
operator|!
name|ffestc_exec_transition
argument_list|()
condition|)
comment|/* 1 exec stmt only, but not valid in context, so pretend as though 	   statement is unrecognized. */
goto|goto
name|no_stmts
goto|;
comment|/* :::::::::::::::::::: */
break|break;
default|default:
comment|/* More than one, so try them in order. */
name|ffesta_confirmed_possible_
operator|=
name|NULL
expr_stmt|;
name|ffesta_current_possible_
operator|=
name|ffesta_possible_nonexecs_
operator|.
name|first
expr_stmt|;
name|ffesta_current_handler_
operator|=
name|ffesta_current_possible_
operator|->
name|handler
expr_stmt|;
if|if
condition|(
name|ffesta_current_handler_
operator|==
name|NULL
condition|)
block|{
name|ffesta_current_possible_
operator|=
name|ffesta_possible_execs_
operator|.
name|first
expr_stmt|;
name|ffesta_current_handler_
operator|=
name|ffesta_current_possible_
operator|->
name|handler
expr_stmt|;
name|assert
argument_list|(
name|ffesta_current_handler_
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_seen_first_exec
condition|)
block|{
comment|/* Need to do exec transition now. */
name|ffesta_tokens
index|[
literal|0
index|]
operator|=
name|ffesta_token_0_
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_exec_transition
argument_list|()
condition|)
goto|goto
name|no_stmts
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
name|ffesta_tokens
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ffesta_token_0_
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffesta_save_
expr_stmt|;
name|ffebad_set_inhibit
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffesta_is_inhibited_
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|ffesta_output_pool
operator|=
name|malloc_pool_new
argument_list|(
literal|"Statement Output"
argument_list|,
name|ffe_pool_program_unit
argument_list|()
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|ffesta_scratch_pool
operator|=
name|malloc_pool_new
argument_list|(
literal|"Statement Scratch"
argument_list|,
name|ffe_pool_program_unit
argument_list|()
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|ffesta_outpooldisp_
operator|=
name|FFESTA_pooldispDISCARD
expr_stmt|;
if|if
condition|(
name|ffesta_is_inhibited_
condition|)
name|ffesymbol_set_retractable
argument_list|(
name|ffesta_scratch_pool
argument_list|)
expr_stmt|;
name|ffelex_set_names
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Most handlers will want this.  If not, 				   they have to set it TRUE again (its value 				   at the beginning of a statement). */
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffesta_send_two_ -- Send the two tokens saved by ffesta_two after all     return ffesta_send_two_;  // to lexer.     Currently, if this function gets called, it means that the two tokens    saved by ffesta_two did not have their handlers derailed by    ffesta_save_, which probably means they weren't sent by ffesta_save_    but directly by the lexer, which probably means the original statement    (which should be IF (expr) or WHERE (expr)) somehow evaluated to only    one possibility in ffesta_second_ or somebody optimized FFEST to    immediately revert to one possibility upon confirmation but forgot to    change this function (and thus perhaps the entire resubmission    mechanism).	*/
end_comment

begin_if
if|#
directive|if
operator|!
name|FFESTA_ABORT_ON_CONFIRM_
end_if

begin_function
specifier|static
name|ffelexHandler
name|ffesta_send_two_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|assert
argument_list|(
literal|"what am I doing here?"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffesta_confirmed -- Confirm current possibility as only one     ffesta_confirmed();     Sets the confirmation flag.	During debugging for ambiguous constructs,    asserts that the confirmation flag for a previous possibility has not    yet been set.  */
end_comment

begin_function
name|void
name|ffesta_confirmed
parameter_list|()
block|{
if|if
condition|(
name|ffesta_inhibit_confirmation_
condition|)
return|return;
name|ffesta_confirmed_current_
operator|=
name|TRUE
expr_stmt|;
name|assert
argument_list|(
operator|!
name|ffesta_confirmed_other_
operator|||
operator|(
name|ffesta_confirmed_possible_
operator|==
name|ffesta_current_possible_
operator|)
argument_list|)
expr_stmt|;
name|ffesta_confirmed_possible_
operator|=
name|ffesta_current_possible_
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffesta_eof -- End of (non-INCLUDEd) source file     ffesta_eof();     Call after piping tokens through ffest_first, where the most recent    token sent through must be EOS.     20-Feb-91  JCB  1.1       Put new EOF token in ffesta_tokens[0], not NULL, because too much       code expects something there for error reporting and the like.  Also,       do basically the same things ffest_second and ffesta_zero do for       processing a statement (make and destroy pools, et cetera).  */
end_comment

begin_function
name|void
name|ffesta_eof
parameter_list|()
block|{
name|ffesta_tokens
index|[
literal|0
index|]
operator|=
name|ffelex_token_new_eof
argument_list|()
expr_stmt|;
name|ffesta_output_pool
operator|=
name|malloc_pool_new
argument_list|(
literal|"Statement Output"
argument_list|,
name|ffe_pool_program_unit
argument_list|()
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|ffesta_scratch_pool
operator|=
name|malloc_pool_new
argument_list|(
literal|"Statement Scratch"
argument_list|,
name|ffe_pool_program_unit
argument_list|()
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|ffesta_outpooldisp_
operator|=
name|FFESTA_pooldispDISCARD
expr_stmt|;
name|ffestc_eof
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_output_pool
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffesta_outpooldisp_
operator|==
name|FFESTA_pooldispDISCARD
condition|)
name|malloc_pool_kill
argument_list|(
name|ffesta_output_pool
argument_list|)
expr_stmt|;
name|ffesta_output_pool
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ffesta_scratch_pool
operator|!=
name|NULL
condition|)
block|{
name|malloc_pool_kill
argument_list|(
name|ffesta_scratch_pool
argument_list|)
expr_stmt|;
name|ffesta_scratch_pool
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ffesta_label_token
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_label_token
argument_list|)
expr_stmt|;
name|ffesta_label_token
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ffe_is_ffedebug
argument_list|()
condition|)
block|{
name|ffestorag_report
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffesta_ffebad_here_current_stmt -- ffebad_here with ptr to current stmt     ffesta_ffebad_here_current_stmt(0);     Outsiders can call this fn if they have no more convenient place to    point to (via a token or pair of ffewhere objects) and they know a    current, useful statement is being evaluted by ffest (i.e. they are    being called from ffestb, ffestc, ffestd, ... functions).  */
end_comment

begin_function
name|void
name|ffesta_ffebad_here_current_stmt
parameter_list|(
name|ffebadIndex
name|i
parameter_list|)
block|{
name|assert
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
name|i
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffesta_ffebad_start -- Start a possibly inhibited error report     if (ffesta_ffebad_start(FFEBAD_SOME_ERROR))        {        ffebad_here, ffebad_string ...;        ffebad_finish();        }     Call if the error might indicate that ffest is evaluating the wrong    statement form, instead of calling ffebad_start directly.  If ffest    is choosing between forms, it will return FALSE, send an EOS/SEMICOLON    token through as the next token (if the current one isn't already one    of those), and try another possible form.  Otherwise, ffebad_start is    called with the argument and TRUE returned.	*/
end_comment

begin_function
name|bool
name|ffesta_ffebad_start
parameter_list|(
name|ffebad
name|errnum
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ffesta_is_inhibited_
condition|)
block|{
name|ffebad_start
argument_list|(
name|errnum
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|!
name|ffesta_confirmed_current_
condition|)
name|ffesta_current_shutdown_
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ffesta_first -- Parse the first token in a statement     return ffesta_first;	 // to lexer.  */
end_comment

begin_function
name|ffelexHandler
name|ffesta_first
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeEOS
case|:
name|ffesta_tokens
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_label_token
operator|!=
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_WITHOUT_STMT
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
name|ffesta_token_0_
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffesta_first_kw
operator|=
name|ffestr_first
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_second_
return|;
case|case
name|FFELEX_typeNUMBER
case|:
if|if
condition|(
name|ffesta_line_has_semicolons
operator|&&
operator|!
name|ffe_is_free_form
argument_list|()
operator|&&
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_WRONG_PLACE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ffesta_label_token
operator|==
name|NULL
condition|)
block|{
name|ffesta_label_token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_first
return|;
block|}
else|else
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_EXTRA_LABEL_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_first
return|;
block|}
default|default:
comment|/* Invalid first token. */
name|ffesta_tokens
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_STMT_BEGINS_BAD
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffesta_init_0 -- Initialize for entire image invocation     ffesta_init_0();     Call just once per invocation of the compiler (not once per invocation    of the front end).     Gets memory for the list of possibles once and for all, since this    list never gets larger than a certain size (FFESTA_maxPOSSIBLES_)    and is not particularly large.  Initializes the array of pointers to    this list.  Initializes the executable and nonexecutable lists.  */
end_comment

begin_function
name|void
name|ffesta_init_0
parameter_list|()
block|{
name|ffestaPossible_
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ptr
operator|=
operator|(
name|ffestaPossible_
operator|)
name|malloc_new_kp
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFEST possibles"
argument_list|,
name|FFESTA_maxPOSSIBLES_
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FFESTA_maxPOSSIBLES_
condition|;
operator|++
name|i
control|)
name|ffesta_possibles_
index|[
name|i
index|]
operator|=
name|ptr
operator|++
expr_stmt|;
name|ffesta_possible_execs_
operator|.
name|first
operator|=
name|ffesta_possible_execs_
operator|.
name|last
operator|=
operator|(
name|ffestaPossible_
operator|)
operator|&
name|ffesta_possible_execs_
operator|.
name|first
expr_stmt|;
name|ffesta_possible_nonexecs_
operator|.
name|first
operator|=
name|ffesta_possible_nonexecs_
operator|.
name|last
operator|=
operator|(
name|ffestaPossible_
operator|)
operator|&
name|ffesta_possible_nonexecs_
operator|.
name|first
expr_stmt|;
name|ffesta_possible_execs_
operator|.
name|nil
operator|=
name|ffesta_possible_nonexecs_
operator|.
name|nil
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffesta_init_3 -- Initialize for any program unit     ffesta_init_3();  */
end_comment

begin_function
name|void
name|ffesta_init_3
parameter_list|()
block|{
name|ffesta_output_pool
operator|=
name|NULL
expr_stmt|;
comment|/* May be doing this just before reaching */
name|ffesta_scratch_pool
operator|=
name|NULL
expr_stmt|;
comment|/* ffesta_zero or ffesta_two. */
comment|/* NOTE: we let the ffe_terminate_2 action of killing the program_unit pool      handle the killing of the output and scratch pools for us, which is why      we don't have a terminate_3 action to do so. */
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
name|ffesta_label_token
operator|=
name|NULL
expr_stmt|;
name|ffesta_seen_first_exec
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffesta_is_inhibited -- Test whether the current possibility is inhibited     if (!ffesta_is_inhibited())        // implement the statement.     Just make sure the current possibility has been confirmed.  If anyone    really needs to test whether the current possibility is inhibited prior    to confirming it, that indicates a need to begin statement processing    before it is certain that the given possibility is indeed the statement    to be processed.  As of this writing, there does not appear to be such    a need.  If there is, then when confirming a statement would normally    immediately disable the inhibition (whereas currently we leave the    confirmed statement disabled until we've tried the other possibilities,    to check for ambiguities), we must check to see if the possibility has    already tested for inhibition prior to confirmation and, if so, maintain    inhibition until the end of the statement (which may be forced right    away) and then rerun the entire statement from the beginning.  Otherwise,    initial calls to ffestb functions won't have been made, but subsequent    calls (after confirmation) will, which is wrong.  Of course, this all    applies only to those statements implemented via multiple calls to    ffestb, although if a statement requiring only a single ffestb call    tested for inhibition prior to confirmation, it would likely mean that    the ffestb call would be completely dropped without this mechanism.	*/
end_comment

begin_function
name|bool
name|ffesta_is_inhibited
parameter_list|()
block|{
name|assert
argument_list|(
name|ffesta_confirmed_current_
operator|||
name|ffesta_inhibit_confirmation_
argument_list|)
expr_stmt|;
return|return
name|ffesta_is_inhibited_
return|;
block|}
end_function

begin_comment
comment|/* ffesta_ffebad_1p -- Issue diagnostic with one source character     ffelexToken names_token;    ffeTokenLength index;    ffelexToken next_token;    ffesta_ffebad_1p(FFEBAD_SOME_ERROR,names_token,index,next_token);     Equivalent to "if (ffest_ffebad_start(FFEBAD_SOME_ERROR))" followed by    sending one argument, the location of index with names_token, if TRUE is    returned.  If index is equal to the length of names_token, meaning it    points to the end of the token, then uses the location in next_token    (which should be the token sent by the lexer after it sent names_token)    instead.  */
end_comment

begin_function
name|void
name|ffesta_ffebad_1p
parameter_list|(
name|ffebad
name|errnum
parameter_list|,
name|ffelexToken
name|names_token
parameter_list|,
name|ffeTokenLength
name|index
parameter_list|,
name|ffelexToken
name|next_token
parameter_list|)
block|{
name|ffewhereLine
name|line
decl_stmt|;
name|ffewhereColumn
name|col
decl_stmt|;
name|assert
argument_list|(
name|index
operator|<=
name|ffelex_token_length
argument_list|(
name|names_token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_ffebad_start
argument_list|(
name|errnum
argument_list|)
condition|)
block|{
if|if
condition|(
name|index
operator|==
name|ffelex_token_length
argument_list|(
name|names_token
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|next_token
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|line
operator|=
name|ffelex_token_where_line
argument_list|(
name|next_token
argument_list|)
expr_stmt|;
name|col
operator|=
name|ffelex_token_where_column
argument_list|(
name|next_token
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffewhere_set_from_track
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|col
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|names_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|names_token
argument_list|)
argument_list|,
name|ffelex_token_wheretrack
argument_list|(
name|names_token
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|ffewhere_line_kill
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ffesta_ffebad_1sp
parameter_list|(
name|ffebad
name|errnum
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|ffelexToken
name|names_token
parameter_list|,
name|ffeTokenLength
name|index
parameter_list|,
name|ffelexToken
name|next_token
parameter_list|)
block|{
name|ffewhereLine
name|line
decl_stmt|;
name|ffewhereColumn
name|col
decl_stmt|;
name|assert
argument_list|(
name|index
operator|<=
name|ffelex_token_length
argument_list|(
name|names_token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_ffebad_start
argument_list|(
name|errnum
argument_list|)
condition|)
block|{
name|ffebad_string
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|ffelex_token_length
argument_list|(
name|names_token
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|next_token
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|line
operator|=
name|ffelex_token_where_line
argument_list|(
name|next_token
argument_list|)
expr_stmt|;
name|col
operator|=
name|ffelex_token_where_column
argument_list|(
name|next_token
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffewhere_set_from_track
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|col
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|names_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|names_token
argument_list|)
argument_list|,
name|ffelex_token_wheretrack
argument_list|(
name|names_token
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|ffewhere_line_kill
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ffesta_ffebad_1st
parameter_list|(
name|ffebad
name|errnum
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffesta_ffebad_start
argument_list|(
name|errnum
argument_list|)
condition|)
block|{
name|ffebad_string
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffesta_ffebad_1t -- Issue diagnostic with one source token     ffelexToken t;    ffesta_ffebad_1t(FFEBAD_SOME_ERROR,t);     Equivalent to "if (ffesta_ffebad_start(FFEBAD_SOME_ERROR))" followed by    sending one argument, the location of the token t, if TRUE is returned.  */
end_comment

begin_function
name|void
name|ffesta_ffebad_1t
parameter_list|(
name|ffebad
name|errnum
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffesta_ffebad_start
argument_list|(
name|errnum
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ffesta_ffebad_2st
parameter_list|(
name|ffebad
name|errnum
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|ffelexToken
name|t1
parameter_list|,
name|ffelexToken
name|t2
parameter_list|)
block|{
if|if
condition|(
name|ffesta_ffebad_start
argument_list|(
name|errnum
argument_list|)
condition|)
block|{
name|ffebad_string
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t1
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t2
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffesta_ffebad_2t -- Issue diagnostic with two source tokens     ffelexToken t1, t2;    ffesta_ffebad_2t(FFEBAD_SOME_ERROR,t1,t2);     Equivalent to "if (ffesta_ffebad_start(FFEBAD_SOME_ERROR))" followed by    sending two argument, the locations of the tokens t1 and t2, if TRUE is    returned.  */
end_comment

begin_function
name|void
name|ffesta_ffebad_2t
parameter_list|(
name|ffebad
name|errnum
parameter_list|,
name|ffelexToken
name|t1
parameter_list|,
name|ffelexToken
name|t2
parameter_list|)
block|{
if|if
condition|(
name|ffesta_ffebad_start
argument_list|(
name|errnum
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t1
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t2
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|ffestaPooldisp
name|ffesta_outpooldisp
parameter_list|()
block|{
return|return
name|ffesta_outpooldisp_
return|;
block|}
end_function

begin_function
name|void
name|ffesta_set_outpooldisp
parameter_list|(
name|ffestaPooldisp
name|d
parameter_list|)
block|{
name|ffesta_outpooldisp_
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shut down current parsing possibility, but without bothering the    user with a diagnostic if we're not inhibited.  */
end_comment

begin_function
name|void
name|ffesta_shutdown
parameter_list|()
block|{
if|if
condition|(
name|ffesta_is_inhibited_
condition|)
name|ffesta_current_shutdown_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffesta_two -- Deal with the first two tokens after a swallowed statement     return ffesta_two(first_token,second_token);	 // to lexer.     Like ffesta_zero, except instead of expecting an EOS or SEMICOLON, it    expects the first two tokens of a statement that is part of another    statement: the first two tokens of statement in "IF (expr) statement" or    "WHERE (expr) statement", in particular.  The first token must be a NAME    or NAMES, the second can be basically anything.  The statement type MUST    be confirmed by now.     If we're not inhibited, just handle things as if we were ffesta_zero    and saw an EOS just before the two tokens.     If we're inhibited, set ffesta_current_shutdown_ to shut down the current    statement and continue with other possibilities, then (presumably) come    back to this one for real when not inhibited.  */
end_comment

begin_function
name|ffelexHandler
name|ffesta_two
parameter_list|(
name|ffelexToken
name|first
parameter_list|,
name|ffelexToken
name|second
parameter_list|)
block|{
if|#
directive|if
name|FFESTA_ABORT_ON_CONFIRM_
name|ffelexHandler
name|next
decl_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
operator|(
name|ffelex_token_type
argument_list|(
name|first
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|first
argument_list|)
operator|==
name|FFELEX_typeNAMES
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_is_inhibited_
condition|)
comment|/* Oh, not really done with statement. */
block|{
name|ffesta_current_shutdown_
operator|=
name|TRUE
expr_stmt|;
comment|/* To catch the EOS on shutdown. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|second
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
name|ffestw_display_state
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_output_pool
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffesta_outpooldisp_
operator|==
name|FFESTA_pooldispDISCARD
condition|)
name|malloc_pool_kill
argument_list|(
name|ffesta_output_pool
argument_list|)
expr_stmt|;
name|ffesta_output_pool
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ffesta_scratch_pool
operator|!=
name|NULL
condition|)
block|{
name|malloc_pool_kill
argument_list|(
name|ffesta_scratch_pool
argument_list|)
expr_stmt|;
name|ffesta_scratch_pool
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_reset_possibles_
argument_list|()
expr_stmt|;
name|ffesta_confirmed_current_
operator|=
name|FALSE
expr_stmt|;
comment|/* What happens here is somewhat interesting.	 We effectively derail the      line of handlers for these two tokens, the first two in a statement, by      setting a flag to TRUE.  This flag tells ffesta_save_ (or, conceivably,      the lexer via ffesta_second_'s case 1:, where it has only one possible      kind of statement -- someday this will be more likely, i.e. after      confirmation causes an immediate switch to only the one context rather      than just setting a flag and running through the remaining possibles to      look for ambiguities) that the last two tokens it sent did not reach the      truly desired targets (ffest_first and ffesta_second_) since that would      otherwise attempt to recursively invoke ffesta_save_ in most cases,      while the existing ffesta_save_ was still alive and making use of static      (nonrecursive) variables.	Instead, ffesta_save_, upon seeing this flag      set TRUE, sets it to FALSE and resubmits the two tokens copied here to      ffest_first and, presumably, ffesta_second_, kills them, and returns the      handler returned by the handler for the second token.  Thus, even though      ffesta_save_ is still (likely to be) recursively invoked, the former      invocation is past the use of any static variables possibly changed      during the first-two-token invocation of the latter invocation. */
if|#
directive|if
name|FFESTA_ABORT_ON_CONFIRM_
comment|/* Shouldn't be in ffesta_save_ at all here. */
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffesta_first
argument_list|(
name|first
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|second
argument_list|)
return|;
else|#
directive|else
name|ffesta_twotokens_1_
operator|=
name|ffelex_token_use
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|ffesta_twotokens_2_
operator|=
name|ffelex_token_use
argument_list|(
name|second
argument_list|)
expr_stmt|;
name|ffesta_is_two_into_statement_
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_send_two_
return|;
comment|/* Shouldn't get called. */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffesta_zero -- Deal with the end of a swallowed statement     return ffesta_zero;	// to lexer.     NOTICE that this code is COPIED, largely, into a    similar function named ffesta_two that gets invoked in place of    _zero_ when the end of the statement happens before EOS or SEMICOLON and    to tokens into the next statement have been read (as is the case with the    logical-IF and WHERE-stmt statements).  So any changes made here should    probably be made in _two_ at the same time.	*/
end_comment

begin_function
name|ffelexHandler
name|ffesta_zero
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeEOS
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeSEMICOLON
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_is_inhibited_
condition|)
name|ffesymbol_retract
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|ffestw_display_state
argument_list|()
expr_stmt|;
comment|/* Do CONTINUE if nothing else.  This is done specifically so that "IF      (...) BLAH" causes the same things to happen as if "IF (...) CONTINUE"      was done, so that tracking of labels and such works.  (Try a small      program like "DO 10 ...", "IF (...) BLAH", "10 CONTINUE", "END".)       But it turns out that just testing "!ffesta_confirmed_current_"      isn't enough, because then typing "GOTO" instead of "BLAH" above      doesn't work -- the statement is confirmed (we know the user      attempted a GOTO) but ffestc hasn't seen it.  So, instead, just      always tell ffestc to do "any" statement it needs to reset.  */
if|if
condition|(
operator|!
name|ffesta_is_inhibited_
operator|&&
name|ffesta_seen_first_exec
condition|)
block|{
name|ffestc_any
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_is_inhibited_
condition|)
comment|/* Oh, not really done with statement. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
return|;
comment|/* Call me again when done! */
if|if
condition|(
name|ffesta_output_pool
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffesta_outpooldisp_
operator|==
name|FFESTA_pooldispDISCARD
condition|)
name|malloc_pool_kill
argument_list|(
name|ffesta_output_pool
argument_list|)
expr_stmt|;
name|ffesta_output_pool
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ffesta_scratch_pool
operator|!=
name|NULL
condition|)
block|{
name|malloc_pool_kill
argument_list|(
name|ffesta_scratch_pool
argument_list|)
expr_stmt|;
name|ffesta_scratch_pool
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_reset_possibles_
argument_list|()
expr_stmt|;
name|ffesta_confirmed_current_
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeSEMICOLON
condition|)
block|{
name|ffesta_line_has_semicolons
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ffe_is_pedantic_not_90
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_SEMICOLON
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|ffesta_line_has_semicolons
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ffesta_label_token
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_label_token
argument_list|)
expr_stmt|;
name|ffesta_label_token
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ffe_is_ffedebug
argument_list|()
condition|)
block|{
name|ffestorag_report
argument_list|()
expr_stmt|;
block|}
name|ffelex_set_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_first
return|;
block|}
end_function

end_unit

