begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* stb.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995, 1996, 2002, 2003    Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       st.c     Description:       Parses the proper form for statements, builds up expression trees for       them, but does not actually implement them.  Uses ffebad (primarily via       ffesta_ffebad_start) to indicate errors in form.	In many cases, an invalid       statement form indicates another possible statement needs to be looked at       by ffest.	 In a few cases, a valid statement form might not completely       determine the nature of the statement, as in REALFUNCTIONA(B), which is       a valid form for either the first statement of a function named A taking       an argument named B or for the declaration of a real array named FUNCTIONA       with an adjustable size of B.  A similar (though somewhat easier) choice       must be made for the statement-function-def vs. assignment forms, as in       the case of FOO(A) = A+2.0.        A given parser consists of one or more state handlers, the first of which       is the initial state, and the last of which (for any given input) returns       control to a final state handler (ffesta_zero or ffesta_two, explained       below).  The functions handling the states for a given parser usually have       the same names, differing only in the final number, as in ffestb_foo_       (handles the initial state), ffestb_foo_1_, ffestb_foo_2_ (handle       subsequent states), although liberties sometimes are taken with the "foo"       part either when keywords are clarified into given statements or are       transferred into other possible areas.  (For example, the type-name       states can hop over to _dummy_ functions when the FUNCTION or RECURSIVE       keywords are seen, though this kind of thing is kept to a minimum.)  Only       the names without numbers are exported to the rest of ffest; the others       are local (static).        Each initial state is provided with the first token in ffesta_tokens[0],       which will be killed upon return to the final state (ffesta_zero or       ffelex_swallow_tokens passed through to ffesta_zero), so while it may       be changed to another token, a valid token must be left there to be       killed.  Also, a "convenient" array of tokens are left in       ffesta_tokens[1..FFESTA_tokensMAX].  The initial state of this set of       elements is undefined, thus, if tokens are stored here, they must be       killed before returning to the final state.  Any parser may also use       cross-state local variables by sticking a structure containing storage       for those variables in the local union ffestb_local_ (unless the union       goes on strike).	Furthermore, parsers that handle more than one first or       second tokens (like _varlist_, which handles EXTERNAL, INTENT, INTRINSIC,       OPTIONAL,       PUBLIC, or PRIVATE, and _endxyz_, which handles ENDBLOCK, ENDBLOCKDATA,       ENDDO, ENDIF, and so on) may expect arguments from ffest in the       ffest-wide union ffest_args_, the substructure specific to the parser.        A parser's responsibility is: to call either ffesta_confirmed or       ffest_ffebad_start before returning to the final state; to be the only       parser that can possibly call ffesta_confirmed for a given statement;       to call ffest_ffebad_start immediately upon recognizing a bad token       (specifically one that another statement parser might confirm upon);       to call ffestc functions only after calling ffesta_confirmed and only       when ffesta_is_inhibited returns FALSE; and to call ffesta_is_inhibited       only after calling ffesta_confirmed.  Confirm as early as reasonably       possible, even when only one ffestc function is called for the statement       later on, because early confirmation can enhance the error-reporting       capabilities if a subsequent error is detected and this parser isn't       the first possibility for the statement.        To assist the parser, functions like ffesta_ffebad_1t and _1p_ have       been provided to make use of ffest_ffebad_start fairly easy.     Modifications: */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"stb.h"
end_include

begin_include
include|#
directive|include
file|"bad.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"src.h"
end_include

begin_include
include|#
directive|include
file|"sta.h"
end_include

begin_include
include|#
directive|include
file|"stc.h"
end_include

begin_include
include|#
directive|include
file|"stp.h"
end_include

begin_include
include|#
directive|include
file|"str.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_decl_stmt
name|struct
name|_ffestb_args_
name|ffestb_args
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_define
define|#
directive|define
name|FFESTB_KILL_EASY_
value|1
end_define

begin_comment
comment|/* 1 for only one _subr_kill_xyz_ fn. */
end_comment

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_union
union|union
name|ffestb_subrargs_u_
block|{
struct|struct
block|{
name|ffesttTokenList
name|labels
decl_stmt|;
comment|/* Input arg, must not be NULL. */
name|ffelexHandler
name|handler
decl_stmt|;
comment|/* Input arg, call me when done. */
name|bool
name|ok
decl_stmt|;
comment|/* Output arg, TRUE if list ended in 				   CLOSE_PAREN. */
block|}
name|label_list
struct|;
struct|struct
block|{
name|ffesttDimList
name|dims
decl_stmt|;
comment|/* Input arg, must not be NULL. */
name|ffelexHandler
name|handler
decl_stmt|;
comment|/* Input arg, call me when done. */
name|mallocPool
name|pool
decl_stmt|;
comment|/* Pool to allocate into. */
name|bool
name|ok
decl_stmt|;
comment|/* Output arg, TRUE if list ended in 				   CLOSE_PAREN. */
name|ffeexprContext
name|ctx
decl_stmt|;
comment|/* DIMLIST or DIMLISTCOMMON. */
ifdef|#
directive|ifdef
name|FFECOM_dimensionsMAX
name|int
name|ndims
decl_stmt|;
comment|/* For backends that really can't have 				   infinite dims. */
endif|#
directive|endif
block|}
name|dim_list
struct|;
struct|struct
block|{
name|ffesttTokenList
name|args
decl_stmt|;
comment|/* Input arg, must not be NULL. */
name|ffelexHandler
name|handler
decl_stmt|;
comment|/* Input arg, call me when done. */
name|ffelexToken
name|close_paren
decl_stmt|;
comment|/* Output arg if ok, CLOSE_PAREN token. */
name|bool
name|is_subr
decl_stmt|;
comment|/* Input arg, TRUE if list in subr-def 				   context. */
name|bool
name|ok
decl_stmt|;
comment|/* Output arg, TRUE if list ended in 				   CLOSE_PAREN. */
name|bool
name|names
decl_stmt|;
comment|/* Do ffelex_set_names(TRUE) before return. */
block|}
name|name_list
struct|;
block|}
union|;
end_union

begin_union
union|union
name|ffestb_local_u_
block|{
struct|struct
block|{
name|ffebld
name|expr
decl_stmt|;
block|}
name|call_stmt
struct|;
struct|struct
block|{
name|ffebld
name|expr
decl_stmt|;
block|}
name|go_to
struct|;
struct|struct
block|{
name|ffebld
name|dest
decl_stmt|;
name|bool
name|vxtparam
decl_stmt|;
comment|/* If assignment might really be VXT 				   PARAMETER stmt. */
block|}
name|let
struct|;
struct|struct
block|{
name|ffebld
name|expr
decl_stmt|;
block|}
name|if_stmt
struct|;
struct|struct
block|{
name|ffebld
name|expr
decl_stmt|;
block|}
name|else_stmt
struct|;
struct|struct
block|{
name|ffebld
name|expr
decl_stmt|;
block|}
name|dowhile
struct|;
struct|struct
block|{
name|ffebld
name|var
decl_stmt|;
name|ffebld
name|start
decl_stmt|;
name|ffebld
name|end
decl_stmt|;
block|}
name|do_stmt
struct|;
struct|struct
block|{
name|bool
name|is_cblock
decl_stmt|;
block|}
name|R522
struct|;
struct|struct
block|{
name|ffebld
name|expr
decl_stmt|;
name|bool
name|started
decl_stmt|;
block|}
name|parameter
struct|;
struct|struct
block|{
name|ffesttExprList
name|exprs
decl_stmt|;
name|bool
name|started
decl_stmt|;
block|}
name|equivalence
struct|;
struct|struct
block|{
name|ffebld
name|expr
decl_stmt|;
name|bool
name|started
decl_stmt|;
block|}
name|data
struct|;
struct|struct
block|{
name|ffestrOther
name|kw
decl_stmt|;
block|}
name|varlist
struct|;
struct|struct
block|{
name|ffelexHandler
name|next
decl_stmt|;
block|}
name|construct
struct|;
struct|struct
block|{
name|ffesttFormatList
name|f
decl_stmt|;
name|ffestpFormatType
name|current
decl_stmt|;
comment|/* What we're currently working on. */
name|ffelexToken
name|t
decl_stmt|;
comment|/* Token of what we're currently working on. */
name|ffesttFormatValue
name|pre
decl_stmt|;
name|ffesttFormatValue
name|post
decl_stmt|;
name|ffesttFormatValue
name|dot
decl_stmt|;
name|ffesttFormatValue
name|exp
decl_stmt|;
name|bool
name|sign
decl_stmt|;
comment|/* _3_, pos/neg; elsewhere, signed/unsigned. */
name|bool
name|complained
decl_stmt|;
comment|/* If run-time expr seen in nonexec context. */
block|}
name|format
struct|;
struct|struct
block|{
name|ffebld
name|expr
decl_stmt|;
block|}
name|selectcase
struct|;
struct|struct
block|{
name|ffesttCaseList
name|cases
decl_stmt|;
block|}
name|case_stmt
struct|;
struct|struct
block|{
name|bool
name|is_cblock
decl_stmt|;
block|}
name|V014
struct|;
struct|struct
block|{
name|ffestpBeruIx
name|ix
decl_stmt|;
name|bool
name|label
decl_stmt|;
name|bool
name|left
decl_stmt|;
name|ffeexprContext
name|context
decl_stmt|;
block|}
name|beru
struct|;
struct|struct
block|{
name|ffestpCloseIx
name|ix
decl_stmt|;
name|bool
name|label
decl_stmt|;
name|bool
name|left
decl_stmt|;
name|ffeexprContext
name|context
decl_stmt|;
block|}
name|close
struct|;
struct|struct
block|{
name|ffestpDeleteIx
name|ix
decl_stmt|;
name|bool
name|label
decl_stmt|;
name|bool
name|left
decl_stmt|;
name|ffeexprContext
name|context
decl_stmt|;
block|}
name|delete
struct|;
struct|struct
block|{
name|ffestpDeleteIx
name|ix
decl_stmt|;
name|bool
name|label
decl_stmt|;
name|bool
name|left
decl_stmt|;
name|ffeexprContext
name|context
decl_stmt|;
block|}
name|find
struct|;
struct|struct
block|{
name|ffestpInquireIx
name|ix
decl_stmt|;
name|bool
name|label
decl_stmt|;
name|bool
name|left
decl_stmt|;
name|ffeexprContext
name|context
decl_stmt|;
name|bool
name|may_be_iolength
decl_stmt|;
block|}
name|inquire
struct|;
struct|struct
block|{
name|ffestpOpenIx
name|ix
decl_stmt|;
name|bool
name|label
decl_stmt|;
name|bool
name|left
decl_stmt|;
name|ffeexprContext
name|context
decl_stmt|;
block|}
name|open
struct|;
struct|struct
block|{
name|ffestpReadIx
name|ix
decl_stmt|;
name|bool
name|label
decl_stmt|;
name|bool
name|left
decl_stmt|;
name|ffeexprContext
name|context
decl_stmt|;
block|}
name|read
struct|;
struct|struct
block|{
name|ffestpRewriteIx
name|ix
decl_stmt|;
name|bool
name|label
decl_stmt|;
name|bool
name|left
decl_stmt|;
name|ffeexprContext
name|context
decl_stmt|;
block|}
name|rewrite
struct|;
struct|struct
block|{
name|ffestpWriteIx
name|ix
decl_stmt|;
name|bool
name|label
decl_stmt|;
name|bool
name|left
decl_stmt|;
name|ffeexprContext
name|context
decl_stmt|;
block|}
name|vxtcode
struct|;
struct|struct
block|{
name|ffestpWriteIx
name|ix
decl_stmt|;
name|bool
name|label
decl_stmt|;
name|bool
name|left
decl_stmt|;
name|ffeexprContext
name|context
decl_stmt|;
block|}
name|write
struct|;
struct|struct
block|{
name|bool
name|started
decl_stmt|;
block|}
name|common
struct|;
struct|struct
block|{
name|bool
name|started
decl_stmt|;
block|}
name|dimension
struct|;
struct|struct
block|{
name|bool
name|started
decl_stmt|;
block|}
name|dimlist
struct|;
struct|struct
block|{
specifier|const
name|char
modifier|*
name|badname
decl_stmt|;
name|ffestrFirst
name|first_kw
decl_stmt|;
name|bool
name|is_subr
decl_stmt|;
block|}
name|dummy
struct|;
struct|struct
block|{
name|ffebld
name|kind
decl_stmt|;
comment|/* Kind type parameter, if any. */
name|ffelexToken
name|kindt
decl_stmt|;
comment|/* Kind type first token, if any. */
name|ffebld
name|len
decl_stmt|;
comment|/* Length type parameter, if any. */
name|ffelexToken
name|lent
decl_stmt|;
comment|/* Length type parameter, if any. */
name|ffelexHandler
name|handler
decl_stmt|;
name|ffelexToken
name|recursive
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
name|ffesttTokenList
name|toklist
decl_stmt|;
comment|/* For ambiguity resolution. */
name|ffesttImpList
name|imps
decl_stmt|;
comment|/* List of IMPLICIT letters. */
name|ffelexHandler
name|imp_handler
decl_stmt|;
comment|/* Call if paren list wasn't letters. */
specifier|const
name|char
modifier|*
name|badname
decl_stmt|;
name|ffestrOther
name|kw
decl_stmt|;
comment|/* INTENT(IN/OUT/INOUT). */
name|ffestpType
name|type
decl_stmt|;
name|bool
name|parameter
decl_stmt|;
comment|/* If PARAMETER attribute seen (governs =expr 				   context). */
name|bool
name|coloncolon
decl_stmt|;
comment|/* If COLONCOLON seen (allows =expr). */
name|bool
name|aster_after
decl_stmt|;
comment|/* "*" seen after, not before, 				   [RECURSIVE]FUNCTIONxyz. */
name|bool
name|empty
decl_stmt|;
comment|/* Ambig function dummy arg list empty so 				   far? */
name|bool
name|imp_started
decl_stmt|;
comment|/* Started IMPLICIT statement already. */
name|bool
name|imp_seen_comma
decl_stmt|;
comment|/* TRUE if next COMMA within parens means not 				   R541. */
block|}
name|decl
struct|;
struct|struct
block|{
name|bool
name|started
decl_stmt|;
block|}
name|vxtparam
struct|;
block|}
union|;
end_union

begin_comment
comment|/* Merge with the one in ffestb later. */
end_comment

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_decl_stmt
specifier|static
name|union
name|ffestb_subrargs_u_
name|ffestb_subrargs_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|union
name|ffestb_local_u_
name|ffestb_local_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_function_decl
specifier|static
name|void
name|ffestb_subr_ambig_to_ents_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_subr_ambig_nope_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_subr_dimlist_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_subr_dimlist_1_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_subr_dimlist_2_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_subr_name_list_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_subr_name_list_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestb_subr_R1001_append_p_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_kindparam_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_kindparam_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_kindparam_2_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_starkind_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_starlen_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_starlen_1_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_typeparams_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_typeparams_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_typeparams_2_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_typeparams_3_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_subr_label_list_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_subr_label_list_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_do1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_do2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_do3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_do4_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_do5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_do6_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_do7_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_do8_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_do9_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_else1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_else2_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_else3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_else4_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_else5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_end1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_end2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_end3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_goto1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_goto2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_goto3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_goto4_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_goto5_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_goto6_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_goto7_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_halt1_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_if1_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_if2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_if3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_let1_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_let2_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_varlist5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_varlist6_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5221_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5222_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5223_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5224_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5281_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5282_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5283_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5284_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5371_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5372_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5373_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5421_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5422_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5423_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5424_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5425_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5441_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5442_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5443_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5444_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8341_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8351_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8381_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8382_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8383_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8401_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8402_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8403_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8404_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8405_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8406_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8407_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R11021_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R1111_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R1111_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R12121_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R12271_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_construct1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_construct2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8091_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8092_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8093_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8101_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8102_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8103_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R8104_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R10011_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R10012_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R10013_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R10014_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R10015_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R10016_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R10017_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R10018_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R10019_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R100110_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R100111_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R100112_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R100113_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R100114_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R100115_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R100116_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R100117_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R100118_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_S3P41_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_V0141_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_V0142_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_V0143_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_V0144_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTB_KILL_EASY_
end_if

begin_function_decl
specifier|static
name|void
name|ffestb_subr_kill_easy_
parameter_list|(
name|ffestpInquireIx
name|max
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|ffestb_subr_kill_accept_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestb_subr_kill_beru_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestb_subr_kill_close_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestb_subr_kill_delete_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestb_subr_kill_find_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Not written yet. */
end_comment

begin_function_decl
specifier|static
name|void
name|ffestb_subr_kill_inquire_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestb_subr_kill_open_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestb_subr_kill_print_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestb_subr_kill_read_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestb_subr_kill_rewrite_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestb_subr_kill_type_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestb_subr_kill_vxtcode_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Not written yet. */
end_comment

begin_function_decl
specifier|static
name|void
name|ffestb_subr_kill_write_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_beru1_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_beru2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_beru3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_beru4_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_beru5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_beru6_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_beru7_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_beru8_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_beru9_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_beru10_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9041_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9042_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9043_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9044_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9045_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9046_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9047_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9048_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9049_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9071_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9072_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9073_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9074_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9075_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9076_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9077_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9078_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9079_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9091_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9092_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9093_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9094_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9095_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9096_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9097_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9098_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9099_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R90910_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R90911_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R90912_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R90913_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R90914_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R90915_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9101_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9102_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9103_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9104_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9105_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9106_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9107_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9108_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9109_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R91010_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R91011_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R91012_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R91013_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R91014_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9111_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9112_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9231_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9232_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9233_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9234_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9235_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9236_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9237_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9238_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R9239_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R92310_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R92311_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_V0201_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_V0202_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_dummy1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_dummy2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5241_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5242_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5243_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5244_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5471_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5472_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5473_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5474_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5475_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5476_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R5477_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R12291_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_R12292_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_chartype1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_attrs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_attrs_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_attrs_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_attrs_7_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_attrsp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_4_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_6_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_7_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_8_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_9_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_10_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_11_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_4_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_6_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_7_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_8_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_3_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_4_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_6_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_7_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_8_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_9_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_V0271_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_V0272_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_V0273_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R5391_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R5392_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R5394_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R5395_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R539letters_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R539letters_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R539letters_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R539letters_3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R539letters_4_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R539letters_5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R539maybe_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R539maybe_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R539maybe_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R539maybe_3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R539maybe_4_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffestb_decl_R539maybe_5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Internal macros. */
end_comment

begin_if
if|#
directive|if
name|FFESTB_KILL_EASY_
end_if

begin_define
define|#
directive|define
name|ffestb_subr_kill_accept_
parameter_list|()
define|\
value|ffestb_subr_kill_easy_((ffestpInquireIx) FFESTP_acceptix)
end_define

begin_define
define|#
directive|define
name|ffestb_subr_kill_beru_
parameter_list|()
define|\
value|ffestb_subr_kill_easy_((ffestpInquireIx) FFESTP_beruix)
end_define

begin_define
define|#
directive|define
name|ffestb_subr_kill_close_
parameter_list|()
define|\
value|ffestb_subr_kill_easy_((ffestpInquireIx) FFESTP_closeix)
end_define

begin_define
define|#
directive|define
name|ffestb_subr_kill_delete_
parameter_list|()
define|\
value|ffestb_subr_kill_easy_((ffestpInquireIx) FFESTP_deleteix)
end_define

begin_define
define|#
directive|define
name|ffestb_subr_kill_find_
parameter_list|()
define|\
value|ffestb_subr_kill_easy_((ffestpInquireIx) FFESTP_findix)
end_define

begin_define
define|#
directive|define
name|ffestb_subr_kill_inquire_
parameter_list|()
define|\
value|ffestb_subr_kill_easy_((ffestpInquireIx) FFESTP_inquireix)
end_define

begin_define
define|#
directive|define
name|ffestb_subr_kill_open_
parameter_list|()
define|\
value|ffestb_subr_kill_easy_((ffestpInquireIx) FFESTP_openix)
end_define

begin_define
define|#
directive|define
name|ffestb_subr_kill_print_
parameter_list|()
define|\
value|ffestb_subr_kill_easy_((ffestpInquireIx) FFESTP_printix)
end_define

begin_define
define|#
directive|define
name|ffestb_subr_kill_read_
parameter_list|()
define|\
value|ffestb_subr_kill_easy_((ffestpInquireIx) FFESTP_readix)
end_define

begin_define
define|#
directive|define
name|ffestb_subr_kill_rewrite_
parameter_list|()
define|\
value|ffestb_subr_kill_easy_((ffestpInquireIx) FFESTP_rewriteix)
end_define

begin_define
define|#
directive|define
name|ffestb_subr_kill_type_
parameter_list|()
define|\
value|ffestb_subr_kill_easy_((ffestpInquireIx) FFESTP_typeix)
end_define

begin_define
define|#
directive|define
name|ffestb_subr_kill_vxtcode_
parameter_list|()
define|\
value|ffestb_subr_kill_easy_((ffestpInquireIx) FFESTP_vxtcodeix)
end_define

begin_define
define|#
directive|define
name|ffestb_subr_kill_write_
parameter_list|()
define|\
value|ffestb_subr_kill_easy_((ffestpInquireIx) FFESTP_writeix)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* ffestb_subr_ambig_nope_ -- Cleans up and aborts ambig w/o confirming     ffestb_subr_ambig_nope_();     Switch from ambiguity handling in _entsp_ functions to handling entities    in _ents_ (perform housekeeping tasks).  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_subr_ambig_nope_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_subr_ambig_to_ents_ -- Switches from ambiguity to entity decl     ffestb_subr_ambig_to_ents_();     Switch from ambiguity handling in _entsp_ functions to handling entities    in _ents_ (perform housekeeping tasks).  */
end_comment

begin_function
specifier|static
name|void
name|ffestb_subr_ambig_to_ents_
parameter_list|(
name|void
parameter_list|)
block|{
name|ffelexToken
name|nt
decl_stmt|;
name|nt
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|nt
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|decl
operator|.
name|aster_after
condition|)
block|{
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|==
name|FFESTP_typeCHARACTER
condition|)
block|{
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|==
name|FFESTP_typeCHARACTER
condition|)
block|{
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* NAME/NAMES token already in ffesta_tokens[1]. */
block|}
end_function

begin_comment
comment|/* ffestb_subr_dimlist_ -- OPEN_PAREN expr     (ffestb_subr_dimlist_)  // to expression handler     Deal with a dimension list.     19-Dec-90  JCB  1.1       Detect too many dimensions if backend wants it.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_subr_dimlist_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
ifdef|#
directive|ifdef
name|FFECOM_dimensionsMAX
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ndims
operator|++
operator|==
name|FFECOM_dimensionsMAX
condition|)
block|{
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_TOO_MANY_DIMS
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ok
operator|=
name|TRUE
expr_stmt|;
comment|/* Not a parse error, really. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|handler
return|;
block|}
endif|#
directive|endif
name|ffestt_dimlist_append
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|,
name|NULL
argument_list|,
name|expr
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ok
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|handler
return|;
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opSTAR
operator|)
condition|)
break|break;
ifdef|#
directive|ifdef
name|FFECOM_dimensionsMAX
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ndims
operator|++
operator|==
name|FFECOM_dimensionsMAX
condition|)
block|{
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_TOO_MANY_DIMS
argument_list|,
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|pool
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ctx
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_subr_dimlist_2_
argument_list|)
return|;
block|}
endif|#
directive|endif
name|ffestt_dimlist_append
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|,
name|NULL
argument_list|,
name|expr
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|pool
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ctx
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_subr_dimlist_
argument_list|)
return|;
case|case
name|FFELEX_typeCOLON
case|:
if|if
condition|(
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opSTAR
operator|)
condition|)
break|break;
ifdef|#
directive|ifdef
name|FFECOM_dimensionsMAX
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ndims
operator|++
operator|==
name|FFECOM_dimensionsMAX
condition|)
block|{
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_TOO_MANY_DIMS
argument_list|,
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|pool
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ctx
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_subr_dimlist_2_
argument_list|)
return|;
block|}
endif|#
directive|endif
name|ffestt_dimlist_append
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|,
name|expr
argument_list|,
name|NULL
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NULL second expr for 							   now, just plug in. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|pool
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ctx
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_subr_dimlist_1_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ok
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|handler
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_subr_dimlist_1_ -- OPEN_PAREN expr COLON expr     (ffestb_subr_dimlist_1_)  // to expression handler     Get the upper bound.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_subr_dimlist_1_
parameter_list|(
name|ffelexToken
name|ft
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|->
name|previous
operator|->
name|upper
operator|=
name|expr
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ok
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|handler
return|;
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opSTAR
operator|)
condition|)
break|break;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|->
name|previous
operator|->
name|upper
operator|=
name|expr
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|pool
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ctx
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_subr_dimlist_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ok
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|handler
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_subr_dimlist_2_ -- OPEN_PAREN too-many-dim-exprs     (ffestb_subr_dimlist_2_)  // to expression handler     Get the upper bound.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_subr_dimlist_2_
parameter_list|(
name|ffelexToken
name|ft
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ok
operator|=
name|TRUE
expr_stmt|;
comment|/* Not a parse error, really. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|handler
return|;
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLON
case|:
if|if
condition|(
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opSTAR
operator|)
condition|)
break|break;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|pool
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ctx
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_subr_dimlist_2_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ok
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|handler
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_subr_name_list_ -- Collect a list of name args and close-paren     return ffestb_subr_name_list_;  // to lexer after seeing OPEN_PAREN     This implements R1224 in the Fortran 90 spec.  The arg list may be    empty, or be a comma-separated list (an optional trailing comma currently    results in a warning but no other effect) of arguments.  For functions,    however, "*" is invalid (we implement dummy-arg-name, rather than R1224    dummy-arg, which itself is either dummy-arg-name or "*").  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_subr_name_list_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|ffestt_tokenlist_count
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Trailing comma, warn. */
name|ffebad_start
argument_list|(
name|FFEBAD_TRAILING_COMMA
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|ok
operator|=
name|TRUE
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|names
condition|)
name|ffelex_set_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|handler
return|;
case|case
name|FFELEX_typeASTERISK
case|:
if|if
condition|(
operator|!
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|is_subr
condition|)
break|break;
case|case
name|FFELEX_typeNAME
case|:
name|ffestt_tokenlist_append
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subr_name_list_1_
return|;
default|default:
break|break;
block|}
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|ok
operator|=
name|FALSE
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|names
condition|)
name|ffelex_set_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|handler
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_subr_name_list_1_ -- NAME or ASTERISK     return ffestb_subr_name_list_1_;  // to lexer     The next token must be COMMA or CLOSE_PAREN, either way go to original    state, but only after adding the appropriate name list item.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_subr_name_list_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subr_name_list_
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|ok
operator|=
name|TRUE
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|names
condition|)
name|ffelex_set_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|handler
return|;
default|default:
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|ok
operator|=
name|FALSE
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|names
condition|)
name|ffelex_set_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|handler
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ffestb_subr_R1001_append_p_
parameter_list|(
name|void
parameter_list|)
block|{
name|ffesttFormatList
name|f
decl_stmt|;
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
block|{
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_FORMAT_BAD_P_SPEC
argument_list|,
name|ffestb_local_
operator|.
name|format
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeP
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|t
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_kindparam_ -- "type" OPEN_PAREN     return ffestb_decl_kindparam_;  // to lexer     Handle "[KIND=]expr)".  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_kindparam_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_kindparam_1_
return|;
default|default:
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextKINDTYPE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_kindparam_2_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_decl_kindparam_1_ -- "type" OPEN_PAREN NAME     return ffestb_decl_kindparam_1_;  // to lexer     Handle "[KIND=]expr)".  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_kindparam_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestr_other
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
operator|!=
name|FFESTR_otherKIND
condition|)
break|break;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextKINDTYPE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_kindparam_2_
argument_list|)
return|;
default|default:
name|nt
operator|=
name|ffesta_tokens
index|[
literal|1
index|]
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextKINDTYPE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_kindparam_2_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_kindparam_2_ -- "type" OPEN_PAREN ["KIND="] expr     (ffestb_decl_kindparam_2_)  // to expression handler     Handle "[KIND=]expr)".  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_kindparam_2_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|expr
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
name|ffelex_set_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_starkind_ -- "type" ASTERISK     return ffestb_decl_starkind_;  // to lexer     Handle NUMBER.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_starkind_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
name|ffelex_set_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_starlen_ -- "CHARACTER" ASTERISK     return ffestb_decl_starlen_;	 // to lexer     Handle NUMBER.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_starlen_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffelex_set_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextCHARACTERSIZE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_starlen_1_
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_starlen_1_ -- "CHARACTER" ASTERISK OPEN_PAREN expr     (ffestb_decl_starlen_1_)  // to expression handler     Handle CLOSE_PAREN.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_starlen_1_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|expr
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffelex_set_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_typeparams_ -- "CHARACTER" OPEN_PAREN     return ffestb_decl_typeparams_;  // to lexer     Handle "[KIND=]expr)".  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_typeparams_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_typeparams_1_
return|;
default|default:
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|==
name|NULL
condition|)
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextCHARACTERSIZE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_typeparams_2_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
break|break;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextKINDTYPE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_typeparams_3_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_typeparams_1_ -- "CHARACTER" OPEN_PAREN NAME     return ffestb_decl_typeparams_1_;  // to lexer     Handle "[KIND=]expr)".  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_typeparams_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffestr_other
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
name|FFESTR_otherLEN
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
break|break;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextCHARACTERSIZE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_typeparams_2_
argument_list|)
return|;
case|case
name|FFESTR_otherKIND
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
break|break;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextKINDTYPE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_typeparams_3_
argument_list|)
return|;
default|default:
break|break;
block|}
break|break;
default|default:
name|nt
operator|=
name|ffesta_tokens
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|==
name|NULL
condition|)
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextCHARACTERSIZE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_typeparams_2_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|nt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|==
name|NULL
condition|)
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextKINDTYPE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_typeparams_3_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|nt
argument_list|)
expr_stmt|;
else|else
block|{
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|nt
expr_stmt|;
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_typeparams_2_ -- "CHARACTER" OPEN_PAREN ["LEN="] expr     (ffestb_decl_typeparams_2_)	// to expression handler     Handle "[LEN=]expr)".  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_typeparams_2_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|expr
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffelex_set_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
return|;
case|case
name|FFELEX_typeCOMMA
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|expr
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_typeparams_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_typeparams_3_ -- "CHARACTER" OPEN_PAREN ["KIND="] expr     (ffestb_decl_typeparams_3_)	// to expression handler     Handle "[KIND=]expr)".  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_typeparams_3_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|expr
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffelex_set_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
return|;
case|case
name|FFELEX_typeCOMMA
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|expr
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_typeparams_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_subr_label_list_ -- Collect a tokenlist of labels and close-paren     return ffestb_subr_label_list_;  // to lexer after seeing OPEN_PAREN     First token must be a NUMBER.  Must be followed by zero or more COMMA    NUMBER pairs.  Must then be followed by a CLOSE_PAREN.  If all ok, put    the NUMBER tokens in a token list and return via the handler for the    token after CLOSE_PAREN.  Else return via    same handler, but with the ok return value set FALSE.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_subr_label_list_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNUMBER
condition|)
block|{
name|ffestt_tokenlist_append
argument_list|(
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|labels
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subr_label_list_1_
return|;
block|}
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|ok
operator|=
name|FALSE
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|handler
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_subr_label_list_1_ -- NUMBER     return ffestb_subr_label_list_1_;  // to lexer after seeing NUMBER     The next token must be COMMA, in which case go back to    ffestb_subr_label_list_, or CLOSE_PAREN, in which case set ok to TRUE    and go to the handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_subr_label_list_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subr_label_list_
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|ok
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|handler
return|;
default|default:
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|ok
operator|=
name|FALSE
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|handler
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_do -- Parse the DO statement     return ffestb_do;  // to lexer     Make sure the statement has a valid form for the DO statement.  If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_do
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
name|ffestrSecond
name|kw
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstDO
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_do1_
return|;
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_do2_
return|;
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|ffesta_tokens
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_do3_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_do1_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstDO
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlDO
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
comment|/* Must be "DO" label "WHILE". */
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_number_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|p
operator|)
operator|!=
literal|'W'
operator|)
operator|&&
operator|(
operator|(
operator|*
name|p
operator|)
operator|!=
literal|'w'
operator|)
condition|)
goto|goto
name|bad_i1
goto|;
comment|/* :::::::::::::::::::: */
name|nt
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kw
operator|=
name|ffestr_second
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|kw
operator|!=
name|FFESTR_secondWHILE
condition|)
goto|goto
name|bad_i1
goto|;
comment|/* :::::::::::::::::::: */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDOWHILE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_do4_
argument_list|)
return|;
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_do2_
return|;
block|}
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_number_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
goto|goto
name|bad_i1
goto|;
comment|/* :::::::::::::::::::: */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_do2_
return|;
case|case
name|FFELEX_typeEQUALS
case|:
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_number_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i1
goto|;
comment|/* :::::::::::::::::::: */
name|nt
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDO
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_do6_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
comment|/* Will get it back in _6_... */
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_number_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
goto|goto
name|bad_i1
goto|;
comment|/* :::::::::::::::::::: */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_do1_
argument_list|(
name|t
argument_list|)
return|;
block|}
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DO"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i1
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DO"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_dowhile -- Parse the DOWHILE statement     return ffestb_dowhile;  // to lexer     Make sure the statement has a valid form for the DOWHILE statement.	If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_dowhile
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstDOWHILE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlDOWHILE
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDOWHILE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_do4_
argument_list|)
return|;
case|case
name|FFELEX_typeEQUALS
case|:
comment|/* Not really DOWHILE, but DOWHILExyz=.... */
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|nt
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|FFESTR_firstlDO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDO
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_do6_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
comment|/* Will get it back in _6_... */
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DO"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DO"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_do1_ -- "DO" [label]     return ffestb_do1_;	// to lexer     Make sure the statement has a valid form for the DO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_do1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_do2_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffestc_R819B
argument_list|(
name|ffesta_construct_name
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ffestc_R820B
argument_list|(
name|ffesta_construct_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAME
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_do2_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_do2_ -- "DO" [label] [,]     return ffestb_do2_;	// to lexer     Make sure the statement has a valid form for the DO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_do2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_do3_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_do3_ -- "DO" [label] [,] NAME     return ffestb_do3_;	// to lexer     Make sure the statement has a valid form for the DO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_do3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDO
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_do6_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Will get it back in _6_... */
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
name|ffestr_second
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
operator|!=
name|FFESTR_secondWHILE
condition|)
block|{
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DO"
argument_list|,
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid token. */
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDOWHILE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_do4_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_do4_ -- "DO" [label] [,] "WHILE" OPEN_PAREN expr     (ffestb_do4_)  // to expression handler     Make sure the statement has a valid form for the DO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_do4_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_tokens
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|dowhile
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_do5_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_do5_ -- "DO" [label] [,] "WHILE" OPEN_PAREN expr CLOSE_PAREN     return ffestb_do5_;	// to lexer     Make sure the statement has a valid form for the DO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_do5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffestc_R819B
argument_list|(
name|ffesta_construct_name
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_local_
operator|.
name|dowhile
operator|.
name|expr
argument_list|,
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|ffestc_R820B
argument_list|(
name|ffesta_construct_name
argument_list|,
name|ffestb_local_
operator|.
name|dowhile
operator|.
name|expr
argument_list|,
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_do6_ -- "DO" [label] [,] var-expr     (ffestb_do6_)  // to expression handler     Make sure the statement has a valid form for the DO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_do6_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
comment|/* _3_ already ensured that this would be an EQUALS token.  If not, it is a      bug in the FFE. */
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeEQUALS
argument_list|)
expr_stmt|;
name|ffesta_tokens
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|do_stmt
operator|.
name|var
operator|=
name|expr
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDO
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_do7_
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_do7_ -- "DO" [label] [,] var-expr EQUALS expr     (ffestb_do7_)  // to expression handler     Make sure the statement has a valid form for the DO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_do7_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_tokens
index|[
literal|3
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|do_stmt
operator|.
name|start
operator|=
name|expr
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDO
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_do8_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_do8_ -- "DO" [label] [,] var-expr EQUALS expr COMMA expr     (ffestb_do8_)  // to expression handler     Make sure the statement has a valid form for the DO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_do8_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_tokens
index|[
literal|4
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|do_stmt
operator|.
name|end
operator|=
name|expr
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDO
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_do9_
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_tokens
index|[
literal|4
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|do_stmt
operator|.
name|end
operator|=
name|expr
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_do9_
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_do9_ -- "DO" [label] [,] var-expr EQUALS expr COMMA expr 		  [COMMA expr]     (ffestb_do9_)  // to expression handler     Make sure the statement has a valid form for the DO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_do9_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|ft
operator|!=
name|NULL
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffestc_R819A
argument_list|(
name|ffesta_construct_name
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_local_
operator|.
name|do_stmt
operator|.
name|var
argument_list|,
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|,
name|ffestb_local_
operator|.
name|do_stmt
operator|.
name|start
argument_list|,
name|ffesta_tokens
index|[
literal|3
index|]
argument_list|,
name|ffestb_local_
operator|.
name|do_stmt
operator|.
name|end
argument_list|,
name|ffesta_tokens
index|[
literal|4
index|]
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
else|else
name|ffestc_R820A
argument_list|(
name|ffesta_construct_name
argument_list|,
name|ffestb_local_
operator|.
name|do_stmt
operator|.
name|var
argument_list|,
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|,
name|ffestb_local_
operator|.
name|do_stmt
operator|.
name|start
argument_list|,
name|ffesta_tokens
index|[
literal|3
index|]
argument_list|,
name|ffestb_local_
operator|.
name|do_stmt
operator|.
name|end
argument_list|,
name|ffesta_tokens
index|[
literal|4
index|]
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_else -- Parse the ELSE statement     return ffestb_else;	// to lexer     Make sure the statement has a valid form for the ELSE statement.  If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_else
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstELSE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|ffestb_args
operator|.
name|elsexyz
operator|.
name|second
operator|=
name|FFESTR_secondNone
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_else1_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_args
operator|.
name|elsexyz
operator|.
name|second
operator|=
name|ffesta_second_kw
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_else1_
return|;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstELSE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlELSE
condition|)
block|{
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlELSE
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|ffestb_args
operator|.
name|elsexyz
operator|.
name|second
operator|=
name|FFESTR_secondNone
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_else1_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ELSE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ELSE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ELSE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_elsexyz -- Parse an ELSEIF/ELSEWHERE statement     return ffestb_elsexyz;  // to lexer     Expects len and second to be set in ffestb_args.elsexyz to the length    of the ELSExyz keyword involved and the corresponding ffestrSecond value.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_elsexyz
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
name|ffesta_first_kw
operator|==
name|FFESTR_firstELSEIF
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_else1_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstELSEIF
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_else1_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
case|case
name|FFELEX_typeNAMES
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstELSEIF
condition|)
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlELSEIF
condition|)
block|{
name|i
operator|=
name|FFESTR_firstlELSEIF
expr_stmt|;
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_else1_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlELSE
operator|)
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_else1_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ELSE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ELSE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ELSE IF"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_else1_ -- "ELSE" (NAME)     return ffestb_else1_;  // to lexer     If EOS/SEMICOLON, implement the appropriate statement (keep in mind that    "ELSE WHERE" is ambiguous at the syntactic level).  If OPEN_PAREN, start    expression analysis with callback at _2_.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_else1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
name|ffestb_args
operator|.
name|elsexyz
operator|.
name|second
operator|==
name|FFESTR_secondIF
condition|)
block|{
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextIF
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_else2_
argument_list|)
return|;
block|}
comment|/* Fall through. */
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ELSE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ffestb_args
operator|.
name|elsexyz
operator|.
name|second
condition|)
block|{
default|default:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R805
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_else2_ -- "ELSE" "IF" OPEN_PAREN expr     (ffestb_else2_)  // to expression handler     Make sure the next token is CLOSE_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_else2_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestb_local_
operator|.
name|else_stmt
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffelex_set_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_else3_
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ELSE IF"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_else3_ -- "ELSE" "IF" OPEN_PAREN expr CLOSE_PAREN     return ffestb_else3_;  // to lexer     Make sure the next token is "THEN".	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_else3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffelex_set_names
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestr_first
argument_list|(
name|t
argument_list|)
operator|==
name|FFESTR_firstTHEN
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_else4_
return|;
break|break;
case|case
name|FFELEX_typeNAMES
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestr_first
argument_list|(
name|t
argument_list|)
operator|!=
name|FFESTR_firstTHEN
condition|)
break|break;
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|==
name|FFESTR_firstlTHEN
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_else4_
return|;
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlTHEN
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_tokens
index|[
literal|2
index|]
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_else5_
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ELSE IF"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ELSE IF"
argument_list|,
name|t
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_else4_ -- "ELSE" "IF" OPEN_PAREN expr CLOSE_PAREN "THEN"     return ffestb_else4_;  // to lexer     Handle a NAME or EOS/SEMICOLON, then go to state _5_.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_else4_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelex_set_names
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_tokens
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_else5_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_else5_
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ELSE IF"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_else5_ -- "ELSE" "IF" OPEN_PAREN expr CLOSE_PAREN "THEN"     return ffestb_else5_;  // to lexer     Make sure the next token is EOS or SEMICOLON; implement R804.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_else5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R804
argument_list|(
name|ffestb_local_
operator|.
name|else_stmt
operator|.
name|expr
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|2
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ELSE IF"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|2
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_end -- Parse the END statement     return ffestb_end;  // to lexer     Make sure the statement has a valid form for the END statement.  If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_end
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstEND
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondNone
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_end3_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|ffesta_second_kw
expr_stmt|;
switch|switch
condition|(
name|ffesta_second_kw
condition|)
block|{
case|case
name|FFESTR_secondFILE
case|:
name|ffestb_args
operator|.
name|beru
operator|.
name|badname
operator|=
literal|"ENDFILE"
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru
return|;
case|case
name|FFESTR_secondBLOCK
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_end1_
return|;
case|case
name|FFESTR_secondNone
case|:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_end2_
return|;
block|}
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstEND
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlEND
condition|)
block|{
name|i
operator|=
name|FFESTR_firstlEND
expr_stmt|;
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|=
name|FFESTR_secondNone
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_end3_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"END"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"END"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"END"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_endxyz -- Parse an ENDxyz statement     return ffestb_endxyz;  // to lexer     Expects len and second to be set in ffestb_args.endxyz to the length    of the ENDxyz keyword involved and the corresponding ffestrSecond value.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_endxyz
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_end3_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
condition|)
block|{
case|case
name|FFESTR_secondBLOCK
case|:
if|if
condition|(
name|ffesta_second_kw
operator|!=
name|FFESTR_secondDATA
condition|)
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_end2_
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_end2_
argument_list|(
name|t
argument_list|)
return|;
block|}
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
case|case
name|FFELEX_typeNAMES
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|==
name|FFESTR_secondBLOCK
condition|)
block|{
name|i
operator|=
name|FFESTR_firstlEND
expr_stmt|;
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
condition|)
block|{
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|ffestb_args
operator|.
name|endxyz
operator|.
name|len
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_end3_
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_end3_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"END"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"END"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"END"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_end1_ -- "END" "BLOCK"     return ffestb_end1_;	 // to lexer     Make sure the next token is "DATA".	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_end1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
operator|&&
operator|(
name|ffesrc_strcmp_2c
argument_list|(
name|ffe_case_match
argument_list|()
argument_list|,
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"DATA"
argument_list|,
literal|"data"
argument_list|,
literal|"Data"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_end2_
return|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"END"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_end2_ -- "END"<unit-kind>     return ffestb_end2_;	 // to lexer     Make sure the next token is a NAME or EOS.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_end2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_end3_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_end3_
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"END"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_end3_ -- "END"<unit-kind> (NAME)     return ffestb_end3_;	 // to lexer     Make sure the next token is an EOS, then implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_end3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"END"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
operator|==
name|FFESTR_secondNone
condition|)
block|{
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_end
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
block|}
break|break;
block|}
switch|switch
condition|(
name|ffestb_args
operator|.
name|endxyz
operator|.
name|second
condition|)
block|{
case|case
name|FFESTR_secondIF
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R806
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_secondSELECT
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R811
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_secondDO
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R825
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_secondPROGRAM
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1103
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_secondBLOCK
case|:
case|case
name|FFESTR_secondBLOCKDATA
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1112
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_secondFUNCTION
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1221
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_secondSUBROUTINE
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1225
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"END"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_goto -- Parse the GOTO statement     return ffestb_goto;	// to lexer     Make sure the statement has a valid form for the GOTO statement.  If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_goto
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffesta_first_kw
condition|)
block|{
case|case
name|FFESTR_firstGO
case|:
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffesta_second_kw
operator|!=
name|FFESTR_secondTO
operator|)
condition|)
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_confirmed
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_goto1_
return|;
case|case
name|FFESTR_firstGOTO
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_goto1_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstGOTO
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
case|case
name|FFELEX_typePERCENT
case|:
comment|/* Since GOTO I%J is apparently valid 					   in '90. */
case|case
name|FFELEX_typeCOMMA
case|:
break|break;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlGOTO
condition|)
block|{
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlGOTO
operator|)
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|nt
operator|=
name|ffelex_token_number_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ffelex_token_length
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|i
operator|+=
name|ffelex_token_length
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
elseif|else
if|if
condition|(
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|nt
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_goto1_
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_goto1_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"GO TO"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"GO TO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"GO TO"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_goto1_ -- "GOTO" or "GO" "TO"     return ffestb_goto1_;  // to lexer     Make sure the statement has a valid form for the GOTO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_goto1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|==
name|FFELEX_typeNAME
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_goto2_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|labels
operator|=
name|ffestt_tokenlist_create
argument_list|()
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_goto3_
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subr_label_list_
return|;
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|==
name|FFELEX_typeNAME
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextAGOTO
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_goto4_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
break|break;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"GO TO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_goto2_ -- "GO/TO" NUMBER     return ffestb_goto2_;  // to lexer     Make sure the statement has a valid form for the GOTO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_goto2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R836
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"GO TO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_goto3_ -- "GO/TO" OPEN_PAREN label-list CLOSE_PAREN     return ffestb_goto3_;  // to lexer     Make sure the statement has a valid form for the GOTO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_goto3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|ok
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextCGOTO
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_goto5_
argument_list|)
return|;
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
break|break;
default|default:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
comment|/* Could still be assignment!! */
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextCGOTO
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_goto5_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"computed-GOTO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|labels
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_goto4_ -- "GO/TO" expr     (ffestb_goto4_)  // to expression handler     Make sure the statement has a valid form for the GOTO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_goto4_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|go_to
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_goto6_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|go_to
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_goto6_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R839
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"assigned-GOTO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_goto5_ -- "GO/TO" OPEN_PAREN label-list CLOSE_PAREN (COMMA) expr     (ffestb_goto5_)  // to expression handler     Make sure the statement has a valid form for the GOTO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_goto5_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R837
argument_list|(
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|labels
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|labels
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"computed-GOTO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|labels
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_goto6_ -- "GO/TO" expr (COMMA)     return ffestb_goto6_;  // to lexer     Make sure the statement has a valid form for the GOTO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_goto6_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffesta_tokens
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|labels
operator|=
name|ffestt_tokenlist_create
argument_list|()
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_goto7_
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subr_label_list_
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"assigned-GOTO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_goto7_ -- "GO/TO" expr (COMMA) OPEN_PAREN label-list CLOSE_PAREN     return ffestb_goto7_;  // to lexer     Make sure the statement has a valid form for the GOTO statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_goto7_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|ok
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R839
argument_list|(
name|ffestb_local_
operator|.
name|go_to
operator|.
name|expr
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|labels
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|labels
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"assigned-GOTO"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|label_list
operator|.
name|labels
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_halt -- Parse the STOP/PAUSE statement     return ffestb_halt;	// to lexer     Make sure the statement has a valid form for the STOP/PAUSE statement.  If    it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_halt
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNUMBER
case|:
case|case
name|FFELEX_typeAPOSTROPHE
case|:
case|case
name|FFELEX_typeQUOTE
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextSTOP
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_halt1_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAMES
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNUMBER
case|:
case|case
name|FFELEX_typeAPOSTROPHE
case|:
case|case
name|FFELEX_typeQUOTE
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
block|}
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextSTOP
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_halt1_
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffelex_splice_tokens
argument_list|(
name|next
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|ffestb_args
operator|.
name|halt
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
operator|(
name|ffesta_first_kw
operator|==
name|FFESTR_firstSTOP
operator|)
condition|?
literal|"STOP"
else|:
literal|"PAUSE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
operator|(
name|ffesta_first_kw
operator|==
name|FFESTR_firstSTOP
operator|)
condition|?
literal|"STOP"
else|:
literal|"PAUSE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_halt1_ -- "STOP/PAUSE" expr     (ffestb_halt1_)  // to expression handler     Make sure the next token is an EOS or SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_halt1_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
name|ffesta_first_kw
operator|==
name|FFESTR_firstSTOP
condition|)
name|ffestc_R842
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
else|else
name|ffestc_R843
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
operator|(
name|ffesta_first_kw
operator|==
name|FFESTR_firstSTOP
operator|)
condition|?
literal|"STOP"
else|:
literal|"PAUSE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_if -- Parse an IF statement     return ffestb_if;  // to lexer     Make sure the statement has a valid form for an IF statement.    If it does, implement the statement.	 */
end_comment

begin_function
name|ffelexHandler
name|ffestb_if
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstIF
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstIF
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlIF
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextIF
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_if1_
argument_list|)
return|;
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IF"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IF"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_if1_ -- "IF" OPEN_PAREN expr     (ffestb_if1_)  // to expression handler     Make sure the next token is CLOSE_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_if1_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestb_local_
operator|.
name|if_stmt
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffelex_set_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_if2_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IF"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_if2_ -- "IF" OPEN_PAREN expr CLOSE_PAREN     return ffestb_if2_;	// to lexer     Make sure the next token is NAME.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_if2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelex_set_names
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_if3_
return|;
default|default:
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffesta_construct_name
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNUMBER
operator|)
condition|)
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IF"
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|ffesta_ffebad_2st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CONSTRUCT"
argument_list|,
name|ffesta_construct_name
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_if3_ -- "IF" OPEN_PAREN expr CLOSE_PAREN NAME     return ffestb_if3_;	// to lexer     If the next token is EOS or SEMICOLON and the preceding NAME was "THEN",    implement R803.  Else, implement R807 and send the preceding NAME followed    by the current token.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_if3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
name|ffestr_first
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
operator|==
name|FFESTR_firstTHEN
condition|)
block|{
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R803
argument_list|(
name|ffesta_construct_name
argument_list|,
name|ffestb_local_
operator|.
name|if_stmt
operator|.
name|expr
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffesta_ffebad_2st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CONSTRUCT"
argument_list|,
name|ffesta_construct_name
argument_list|,
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R807
argument_list|(
name|ffestb_local_
operator|.
name|if_stmt
operator|.
name|expr
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|{
name|ffelexToken
name|my_2
init|=
name|ffesta_tokens
index|[
literal|2
index|]
decl_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffesta_two
argument_list|(
name|my_2
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|my_2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|next
return|;
block|}
end_function

begin_comment
comment|/* ffestb_let -- Parse an assignment statement     return ffestb_let;  // to lexer     Make sure the statement has a valid form for an assignment statement.  If    it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_let
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|bool
name|vxtparam
decl_stmt|;
comment|/* TRUE if it might really be a VXT PARAMETER 				   stmt. */
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|vxtparam
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFELEX_typeNAMES
case|:
name|vxtparam
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
case|case
name|FFELEX_typePERCENT
case|:
case|case
name|FFELEX_typePOINTS
case|:
name|ffestb_local_
operator|.
name|let
operator|.
name|vxtparam
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFELEX_typeEQUALS
case|:
if|if
condition|(
operator|!
name|vxtparam
operator|||
operator|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstPARAMETER
operator|)
condition|)
block|{
name|ffestb_local_
operator|.
name|let
operator|.
name|vxtparam
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
name|FFESTR_firstlPARAMETER
expr_stmt|;
name|ffestb_local_
operator|.
name|let
operator|.
name|vxtparam
operator|=
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextLET
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_let1_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"assignment"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"assignment"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_let1_ -- expr     (ffestb_let1_)  // to expression handler     Make sure the next token is EQUALS or POINTS.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_let1_
parameter_list|(
name|ffelexToken
name|ft
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestb_local_
operator|.
name|let
operator|.
name|dest
operator|=
name|expr
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextLET
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_let2_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"assignment"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_let2_ -- expr EQUALS/POINTS expr     (ffestb_end2_)  // to expression handler     Make sure the next token is EOS or SEMICOLON; implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_let2_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|ffestb_local_
operator|.
name|let
operator|.
name|vxtparam
operator|&&
operator|!
name|ffestc_is_let_not_V027
argument_list|()
condition|)
break|break;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_let
argument_list|(
name|ffestb_local_
operator|.
name|let
operator|.
name|dest
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
operator|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
operator|==
name|FFELEX_typeEQUALS
operator|)
condition|?
literal|"assignment"
else|:
literal|"pointer-assignment"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_varlist -- Parse EXTERNAL/INTENT/INTRINSIC/OPTIONAL/PUBLIC/PRIVATE 		     statement     return ffestb_varlist;  // to lexer     Make sure the statement has a valid form.  If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_varlist
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffesta_first_kw
condition|)
block|{
case|case
name|FFESTR_firstEXTERNAL
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1207_start
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTR_firstINTRINSIC
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1208_start
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_varlist5_
argument_list|(
name|t
argument_list|)
return|;
block|}
case|case
name|FFELEX_typeNAMES
case|:
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|ffestb_args
operator|.
name|varlist
operator|.
name|len
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffesta_first_kw
condition|)
block|{
case|case
name|FFESTR_firstEXTERNAL
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1207_start
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTR_firstINTRINSIC
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1208_start
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_varlist5_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
comment|/* Here, we have at least one char after the first keyword and t is 	 COMMA or EOS/SEMICOLON.  Also we know that this form is valid for 	 only the statements reaching here (specifically, INTENT won't reach 	 here). */
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|nt
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|ffesta_first_kw
condition|)
block|{
case|case
name|FFESTR_firstEXTERNAL
case|:
name|ffestc_R1207_start
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTR_firstINTRINSIC
case|:
name|ffestc_R1208_start
argument_list|()
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_varlist5_
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|varlist
operator|.
name|badname
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|varlist
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|varlist
operator|.
name|badname
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_varlist5_ -- Handles the list of variable names     return ffestb_varlist5_;  // to lexer     Handle NAME.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_varlist5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_varlist6_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|varlist
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|ffesta_first_kw
condition|)
block|{
case|case
name|FFESTR_firstEXTERNAL
case|:
name|ffestc_R1207_finish
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTR_firstINTRINSIC
case|:
name|ffestc_R1208_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_varlist6_ -- (whatever) NAME     return ffestb_varlist6_;  // to lexer     Handle COMMA or EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_varlist6_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|ffesta_first_kw
condition|)
block|{
case|case
name|FFESTR_firstEXTERNAL
case|:
name|ffestc_R1207_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstINTRINSIC
case|:
name|ffestc_R1208_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_varlist5_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|ffesta_first_kw
condition|)
block|{
case|case
name|FFESTR_firstEXTERNAL
case|:
name|ffestc_R1207_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestc_R1207_finish
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTR_firstINTRINSIC
case|:
name|ffestc_R1208_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestc_R1208_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|varlist
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|ffesta_first_kw
condition|)
block|{
case|case
name|FFESTR_firstEXTERNAL
case|:
name|ffestc_R1207_finish
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTR_firstINTRINSIC
case|:
name|ffestc_R1208_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R522 -- Parse the SAVE statement     return ffestb_R522;	// to lexer     Make sure the statement has a valid form for the SAVE statement.  If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R522
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstSAVE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R522
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeSLASH
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R522start
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5221_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R522start
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5221_
return|;
block|}
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstSAVE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlSAVE
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R522
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeSLASH
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R522start
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5221_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R522start
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5221_
return|;
block|}
comment|/* Here, we have at least one char after "SAVE" and t is COMMA or 	 EOS/SEMICOLON. */
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|nt
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R522start
argument_list|()
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5221_
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"SAVE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"SAVE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"SAVE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5221_ -- "SAVE" [COLONCOLON]     return ffestb_R5221_;  // to lexer     Handle NAME or SLASH.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5221_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffestb_local_
operator|.
name|R522
operator|.
name|is_cblock
operator|=
name|FALSE
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5224_
return|;
case|case
name|FFELEX_typeSLASH
case|:
name|ffestb_local_
operator|.
name|R522
operator|.
name|is_cblock
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5222_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"SAVE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R522finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5222_ -- "SAVE" [COLONCOLON] SLASH     return ffestb_R5222_;  // to lexer     Handle NAME.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5222_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5223_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"SAVE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R522finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5223_ -- "SAVE" [COLONCOLON] SLASH NAME     return ffestb_R5223_;  // to lexer     Handle SLASH.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5223_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeSLASH
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5224_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"SAVE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R522finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5224_ -- "SAVE" [COLONCOLON] R523     return ffestb_R5224_;  // to lexer     Handle COMMA or EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5224_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
name|ffestb_local_
operator|.
name|R522
operator|.
name|is_cblock
condition|)
name|ffestc_R522item_cblock
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|ffestc_R522item_object
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5221_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
name|ffestb_local_
operator|.
name|R522
operator|.
name|is_cblock
condition|)
name|ffestc_R522item_cblock
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|ffestc_R522item_object
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestc_R522finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"SAVE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R522finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R528 -- Parse the DATA statement     return ffestb_R528;	// to lexer     Make sure the statement has a valid form for the DATA statement.  If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R528
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffeTokenLength
name|i
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstDATA
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeSLASH
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
block|}
name|ffestb_local_
operator|.
name|data
operator|.
name|started
operator|=
name|FALSE
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDATA
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5281_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstDATA
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlDATA
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|ffestb_local_
operator|.
name|data
operator|.
name|started
operator|=
name|FALSE
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDATA
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5281_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
break|break;
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeSLASH
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffestb_local_
operator|.
name|data
operator|.
name|started
operator|=
name|FALSE
expr_stmt|;
name|nt
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDATA
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5281_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DATA"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DATA"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DATA"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5281_ -- "DATA" expr-list     (ffestb_R5281_)  // to expression handler     Handle COMMA or SLASH.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5281_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|data
operator|.
name|started
condition|)
block|{
name|ffestc_R528_start
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|data
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
block|}
name|ffestc_R528_item_object
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDATA
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5281_
argument_list|)
return|;
case|case
name|FFELEX_typeSLASH
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|data
operator|.
name|started
condition|)
block|{
name|ffestc_R528_start
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|data
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
block|}
name|ffestc_R528_item_object
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffestc_R528_item_startvals
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDATA
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5282_
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DATA"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|data
operator|.
name|started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R528_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5282_ -- "DATA" expr-list SLASH expr-list     (ffestb_R5282_)  // to expression handler     Handle ASTERISK, COMMA, or SLASH.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5282_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R528_item_value
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDATA
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5282_
argument_list|)
return|;
case|case
name|FFELEX_typeASTERISK
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffestb_local_
operator|.
name|data
operator|.
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|t
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGER1
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDATA
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5283_
argument_list|)
return|;
case|case
name|FFELEX_typeSLASH
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_R528_item_value
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffestc_R528_item_endvals
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5284_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DATA"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_R528_item_endvals
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffestc_R528_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5283_ -- "DATA" expr-list SLASH expr ASTERISK expr     (ffestb_R5283_)  // to expression handler     Handle COMMA or SLASH.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5283_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R528_item_value
argument_list|(
name|ffestb_local_
operator|.
name|data
operator|.
name|expr
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDATA
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5282_
argument_list|)
return|;
case|case
name|FFELEX_typeSLASH
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_R528_item_value
argument_list|(
name|ffestb_local_
operator|.
name|data
operator|.
name|expr
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffestc_R528_item_endvals
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5284_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DATA"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_R528_item_endvals
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffestc_R528_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5284_ -- "DATA" expr-list SLASH expr-list SLASH     return ffestb_R5284_;  // to lexer     Handle [COMMA] NAME or EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5284_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDATA
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5281_
argument_list|)
return|;
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeOPEN_PAREN
case|:
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDATA
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5281_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R528_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"DATA"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R528_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R537 -- Parse a PARAMETER statement     return ffestb_R537;	// to lexer     Make sure the statement has a valid form for an PARAMETER statement.    If it does, implement the statement.	 */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R537
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstPARAMETER
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstPARAMETER
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlPARAMETER
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ffestb_local_
operator|.
name|parameter
operator|.
name|started
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextPARAMETER
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5371_
argument_list|)
return|;
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PARAMETER"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PARAMETER"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_R5371_ -- "PARAMETER" OPEN_PAREN expr     (ffestb_R5371_)  // to expression handler     Make sure the next token is EQUALS.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5371_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestb_local_
operator|.
name|parameter
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextPARAMETER
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5372_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PARAMETER"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|parameter
operator|.
name|started
condition|)
name|ffestc_R537_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5372_ -- "PARAMETER" OPEN_PAREN expr EQUALS expr     (ffestb_R5372_)  // to expression handler     Make sure the next token is COMMA or CLOSE_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5372_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|parameter
operator|.
name|started
condition|)
block|{
name|ffestc_R537_start
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|parameter
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
block|}
name|ffestc_R537_item
argument_list|(
name|ffestb_local_
operator|.
name|parameter
operator|.
name|expr
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextPARAMETER
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5371_
argument_list|)
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|parameter
operator|.
name|started
condition|)
block|{
name|ffestc_R537_start
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|parameter
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
block|}
name|ffestc_R537_item
argument_list|(
name|ffestb_local_
operator|.
name|parameter
operator|.
name|expr
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffestc_R537_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5373_
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PARAMETER"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|parameter
operator|.
name|started
condition|)
name|ffestc_R537_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5373_ -- "PARAMETER" OPEN_PAREN expr EQUALS expr CLOSE_PAREN     return ffestb_R5373_;  // to lexer     Make sure the next token is EOS or SEMICOLON, or generate an error.	All    cleanup has already been done, by the way.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5373_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PARAMETER"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R542 -- Parse the NAMELIST statement     return ffestb_R542;	// to lexer     Make sure the statement has a valid form for the NAMELIST statement.	 If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R542
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffeTokenLength
name|i
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstNAMELIST
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstNAMELIST
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlNAMELIST
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
break|break;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeSLASH
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R542_start
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5421_
return|;
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"NAMELIST"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"NAMELIST"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"NAMELIST"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5421_ -- "NAMELIST" SLASH     return ffestb_R5421_;  // to lexer     Handle NAME.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5421_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R542_item_nlist
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5422_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"NAMELIST"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R542_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5422_ -- "NAMELIST" SLASH NAME     return ffestb_R5422_;  // to lexer     Handle SLASH.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5422_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeSLASH
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5423_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"NAMELIST"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R542_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5423_ -- "NAMELIST" SLASH NAME SLASH     return ffestb_R5423_;  // to lexer     Handle NAME.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5423_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R542_item_nitem
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5424_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"NAMELIST"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R542_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5424_ -- "NAMELIST" SLASH NAME SLASH NAME     return ffestb_R5424_;  // to lexer     Handle COMMA, EOS/SEMICOLON, or SLASH.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5424_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5425_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R542_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeSLASH
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5421_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"NAMELIST"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R542_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5425_ -- "NAMELIST" SLASH NAME SLASH NAME COMMA     return ffestb_R5425_;  // to lexer     Handle NAME or SLASH.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5425_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R542_item_nitem
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5424_
return|;
case|case
name|FFELEX_typeSLASH
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5421_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"NAMELIST"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R542_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R544 -- Parse an EQUIVALENCE statement     return ffestb_R544;	// to lexer     Make sure the statement has a valid form for an EQUIVALENCE statement.    If it does, implement the statement.	 */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R544
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstEQUIVALENCE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstEQUIVALENCE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlEQUIVALENCE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|started
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextEQUIVALENCE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5441_
argument_list|)
return|;
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"EQUIVALENCE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"EQUIVALENCE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_R5441_ -- "EQUIVALENCE" OPEN_PAREN expr     (ffestb_R5441_)  // to expression handler     Make sure the next token is COMMA.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5441_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|exprs
operator|=
name|ffestt_exprlist_create
argument_list|()
expr_stmt|;
name|ffestt_exprlist_append
argument_list|(
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|exprs
argument_list|,
name|expr
argument_list|,
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextEQUIVALENCE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5442_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"EQUIVALENCE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|started
condition|)
name|ffestc_R544_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5442_ -- "EQUIVALENCE" OPEN_PAREN expr COMMA expr     (ffestb_R5442_)  // to expression handler     Make sure the next token is COMMA or CLOSE_PAREN.  For COMMA, we just    append the expression to our list and continue; for CLOSE_PAREN, we    append the expression and move to _3_.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5442_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffestt_exprlist_append
argument_list|(
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|exprs
argument_list|,
name|expr
argument_list|,
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextEQUIVALENCE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5442_
argument_list|)
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffestt_exprlist_append
argument_list|(
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|exprs
argument_list|,
name|expr
argument_list|,
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5443_
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"EQUIVALENCE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|started
condition|)
name|ffestc_R544_finish
argument_list|()
expr_stmt|;
name|ffestt_exprlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|exprs
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5443_ -- "EQUIVALENCE" OPEN_PAREN expr COMMA expr CLOSE_PAREN     return ffestb_R5443_;  // to lexer     Make sure the next token is COMMA or EOS/SEMICOLON.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5443_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|started
condition|)
block|{
name|ffestc_R544_start
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
block|}
name|ffestc_R544_item
argument_list|(
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|exprs
argument_list|)
expr_stmt|;
block|}
name|ffestt_exprlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|exprs
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5444_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|started
condition|)
block|{
name|ffestc_R544_start
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
block|}
name|ffestc_R544_item
argument_list|(
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|exprs
argument_list|)
expr_stmt|;
name|ffestc_R544_finish
argument_list|()
expr_stmt|;
block|}
name|ffestt_exprlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|exprs
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"EQUIVALENCE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|started
condition|)
name|ffestc_R544_finish
argument_list|()
expr_stmt|;
name|ffestt_exprlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|exprs
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5444_ -- "EQUIVALENCE" OPEN_PAREN expr COMMA expr CLOSE_PAREN COMMA     return ffestb_R5444_;  // to lexer     Make sure the next token is OPEN_PAREN, or generate an error.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5444_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextEQUIVALENCE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R5441_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"EQUIVALENCE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|equivalence
operator|.
name|started
condition|)
name|ffestc_R544_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R834 -- Parse the CYCLE statement     return ffestb_R834;	// to lexer     Make sure the statement has a valid form for the CYCLE statement.  If    it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R834
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstCYCLE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8341_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8341_
argument_list|(
name|t
argument_list|)
return|;
block|}
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstCYCLE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlCYCLE
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8341_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CYCLE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CYCLE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CYCLE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8341_ -- "CYCLE" [NAME]     return ffestb_R8341_;  // to lexer     Make sure the next token is an EOS or SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8341_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R834
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CYCLE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R835 -- Parse the EXIT statement     return ffestb_R835;	// to lexer     Make sure the statement has a valid form for the EXIT statement.  If    it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R835
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstEXIT
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8351_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8351_
argument_list|(
name|t
argument_list|)
return|;
block|}
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstEXIT
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlEXIT
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8351_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"EXIT"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"EXIT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"EXIT"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8351_ -- "EXIT" [NAME]     return ffestb_R8351_;  // to lexer     Make sure the next token is an EOS or SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8351_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R835
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"EXIT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R838 -- Parse the ASSIGN statement     return ffestb_R838;	// to lexer     Make sure the statement has a valid form for the ASSIGN statement.  If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R838
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffeTokenLength
name|i
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|et
decl_stmt|;
comment|/* First token in target. */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstASSIGN
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNUMBER
case|:
break|break;
block|}
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8381_
return|;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstASSIGN
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFELEX_typePERCENT
case|:
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlASSIGN
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_number_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Skip to "TO". */
name|i
operator|+=
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesrc_char_match_init
argument_list|(
operator|*
name|p
argument_list|,
literal|'T'
argument_list|,
literal|'t'
argument_list|)
comment|/* "TO". */
operator|||
operator|(
operator|++
name|i
operator|,
operator|!
name|ffesrc_char_match_noninit
argument_list|(
operator|*
operator|++
name|p
argument_list|,
literal|'O'
argument_list|,
literal|'o'
argument_list|)
operator|)
condition|)
block|{
name|bad_i_1
label|:
comment|/* :::::::::::::::::::: */
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
block|}
operator|++
name|p
operator|,
operator|++
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i_1
goto|;
comment|/* :::::::::::::::::::: */
name|et
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextASSIGN
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R8383_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|et
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|et
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ASSIGN"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid first token. */
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ASSIGN"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ASSIGN"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8381_ -- "ASSIGN" NUMBER     return ffestb_R8381_;  // to lexer     Make sure the next token is "TO".  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8381_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
operator|&&
operator|(
name|ffesrc_strcmp_2c
argument_list|(
name|ffe_case_match
argument_list|()
argument_list|,
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"TO"
argument_list|,
literal|"to"
argument_list|,
literal|"To"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8382_
return|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ASSIGN"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8382_
argument_list|(
name|t
argument_list|)
return|;
comment|/* Maybe user forgot "TO". */
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8382_ -- "ASSIGN" NUMBER ("TO")     return ffestb_R8382_;  // to lexer     Make sure the next token is a name, then pass it along to the expression    evaluator as an LHS expression.  The callback function is _3_.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8382_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
condition|)
block|{
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextASSIGN
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R8383_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ASSIGN"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8383_ -- "ASSIGN" NUMBER ("TO") expression     (ffestb_R8383_)  // to expression handler     Make sure the next token is an EOS or SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8383_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R838
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"ASSIGN"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R840 -- Parse an arithmetic-IF statement     return ffestb_R840;	// to lexer     Make sure the statement has a valid form for an arithmetic-IF statement.    If it does, implement the statement.	 */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R840
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlIF
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstIF
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstIF
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextARITHIF
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R8401_
argument_list|)
return|;
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"arithmetic-IF"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"arithmetic-IF"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_R8401_ -- "IF" OPEN_PAREN expr     (ffestb_R8401_)  // to expression handler     Make sure the next token is CLOSE_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8401_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestb_local_
operator|.
name|if_stmt
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffelex_set_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* In case it's a logical IF instead. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8402_
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"arithmetic-IF"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8402_ -- "IF" OPEN_PAREN expr CLOSE_PAREN     return ffestb_R8402_;  // to lexer     Make sure the next token is NUMBER.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8402_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelex_set_names
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8403_
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"arithmetic-IF"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8403_ -- "IF" OPEN_PAREN expr CLOSE_PAREN NUMBER     return ffestb_R8403_;  // to lexer     Make sure the next token is COMMA.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8403_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8404_
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"arithmetic-IF"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8404_ -- "IF" OPEN_PAREN expr CLOSE_PAREN NUMBER COMMA     return ffestb_R8404_;  // to lexer     Make sure the next token is NUMBER.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8404_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|ffesta_tokens
index|[
literal|3
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8405_
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"arithmetic-IF"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8405_ -- "IF" OPEN_PAREN expr CLOSE_PAREN NUMBER COMMA NUMBER     return ffestb_R8405_;  // to lexer     Make sure the next token is COMMA.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8405_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8406_
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"arithmetic-IF"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8406_ -- "IF" OPEN_PAREN expr CLOSE_PAREN NUMBER COMMA NUMBER COMMA     return ffestb_R8406_;  // to lexer     Make sure the next token is NUMBER.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8406_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|ffesta_tokens
index|[
literal|4
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8407_
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"arithmetic-IF"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8407_ -- "IF" OPEN_PAREN expr CLOSE_PAREN NUMBER COMMA NUMBER COMMA 		    NUMBER     return ffestb_R8407_;  // to lexer     Make sure the next token is EOS or SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8407_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R840
argument_list|(
name|ffestb_local_
operator|.
name|if_stmt
operator|.
name|expr
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|,
name|ffesta_tokens
index|[
literal|3
index|]
argument_list|,
name|ffesta_tokens
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"arithmetic-IF"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R841 -- Parse the CONTINUE statement     return ffestb_R841;	// to lexer     Make sure the statement has a valid form for the CONTINUE statement.	 If    it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R841
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffeTokenLength
name|i
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstCONTINUE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstCONTINUE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlCONTINUE
condition|)
block|{
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlCONTINUE
operator|)
expr_stmt|;
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R841
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CONTINUE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid first token. */
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CONTINUE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CONTINUE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R1102 -- Parse the PROGRAM statement     return ffestb_R1102;	 // to lexer     Make sure the statement has a valid form for the PROGRAM statement.	If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R1102
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstPROGRAM
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R11021_
return|;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstPROGRAM
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlPROGRAM
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R11021_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PROGRAM"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PROGRAM"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PROGRAM"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R11021_ -- "PROGRAM" NAME     return ffestb_R11021_;  // to lexer     Make sure the next token is an EOS or SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R11021_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1102
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PROGRAM"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_block -- Parse the BLOCK DATA statement     return ffestb_block;	 // to lexer     Make sure the statement has a valid form for the BLOCK DATA statement.  If    it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_block
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstBLOCK
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_second_kw
operator|!=
name|FFESTR_secondDATA
condition|)
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R1111_1_
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"BLOCK DATA"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"BLOCK DATA"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_blockdata -- Parse the BLOCKDATA statement     return ffestb_blockdata;  // to lexer     Make sure the statement has a valid form for the BLOCKDATA statement.  If    it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_blockdata
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstBLOCKDATA
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R1111_2_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R1111_2_
argument_list|(
name|t
argument_list|)
return|;
block|}
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstBLOCKDATA
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlBLOCKDATA
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R1111_2_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"BLOCK DATA"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"BLOCK DATA"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"BLOCK DATA"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R1111_1_ -- "BLOCK" "DATA"     return ffestb_R1111_1_;  // to lexer     Make sure the next token is a NAME, EOS, or SEMICOLON token.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R1111_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R1111_2_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R1111_2_
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"BLOCK DATA"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R1111_2_ -- "BLOCK/DATA" NAME     return ffestb_R1111_2_;  // to lexer     Make sure the next token is an EOS or SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R1111_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1111
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"BLOCK DATA"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R1212 -- Parse the CALL statement     return ffestb_R1212;	 // to lexer     Make sure the statement has a valid form for the CALL statement.  If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R1212
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstCALL
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextSUBROUTINEREF
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R12121_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstCALL
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOLONCOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlCALL
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|nt
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextSUBROUTINEREF
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R12121_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CALL"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CALL"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CALL"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R12121_ -- "CALL" expr     (ffestb_R12121_)  // to expression handler     Make sure the statement has a valid form for the CALL statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R12121_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1212
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CALL"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R1227 -- Parse the RETURN statement     return ffestb_R1227;	 // to lexer     Make sure the statement has a valid form for the RETURN statement.  If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R1227
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstRETURN
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
case|case
name|FFELEX_typeCOLON
case|:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNUMBER
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextRETURN
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R12271_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstRETURN
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
case|case
name|FFELEX_typeCOLON
case|:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextRETURN
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R12271_
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffelex_splice_tokens
argument_list|(
name|next
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|FFESTR_firstlRETURN
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"RETURN"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"RETURN"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_R12271_ -- "RETURN" expr     (ffestb_R12271_)  // to expression handler     Make sure the next token is an EOS or SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R12271_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1227
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"RETURN"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_construct -- Parse a construct name     return ffestb_construct;  // to lexer     Make sure the statement can have a construct name (if-then-stmt, do-stmt,    select-case-stmt).  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_construct
parameter_list|(
name|ffelexToken
name|t
name|UNUSED
parameter_list|)
block|{
comment|/* This handler gets invoked only when token 0 is NAME/NAMES and token 1 is      COLON. */
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffelex_set_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_construct1_
return|;
block|}
end_function

begin_comment
comment|/* ffestb_construct1_ -- NAME COLON     return ffestb_construct1_;  // to lexer     Make sure we've got a NAME that is DO, DOWHILE, IF, SELECT, or SELECTCASE.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_construct1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelex_set_names
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_first_kw
operator|=
name|ffestr_first
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffesta_first_kw
condition|)
block|{
case|case
name|FFESTR_firstIF
case|:
name|ffestb_local_
operator|.
name|construct
operator|.
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_if
expr_stmt|;
break|break;
case|case
name|FFESTR_firstDO
case|:
name|ffestb_local_
operator|.
name|construct
operator|.
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_do
expr_stmt|;
break|break;
case|case
name|FFESTR_firstDOWHILE
case|:
name|ffestb_local_
operator|.
name|construct
operator|.
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_dowhile
expr_stmt|;
break|break;
case|case
name|FFESTR_firstSELECT
case|:
case|case
name|FFESTR_firstSELECTCASE
case|:
name|ffestb_local_
operator|.
name|construct
operator|.
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_R809
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ffesta_construct_name
operator|=
name|ffesta_tokens
index|[
literal|0
index|]
expr_stmt|;
name|ffesta_tokens
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_construct2_
return|;
case|case
name|FFELEX_typeNAMES
case|:
name|ffesta_first_kw
operator|=
name|ffestr_first
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffesta_first_kw
condition|)
block|{
case|case
name|FFESTR_firstIF
case|:
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|!=
name|FFESTR_firstlIF
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
name|ffestb_local_
operator|.
name|construct
operator|.
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_if
expr_stmt|;
break|break;
case|case
name|FFESTR_firstDO
case|:
name|ffestb_local_
operator|.
name|construct
operator|.
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_do
expr_stmt|;
break|break;
case|case
name|FFESTR_firstDOWHILE
case|:
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|!=
name|FFESTR_firstlDOWHILE
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
name|ffestb_local_
operator|.
name|construct
operator|.
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_dowhile
expr_stmt|;
break|break;
case|case
name|FFESTR_firstSELECTCASE
case|:
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|!=
name|FFESTR_firstlSELECTCASE
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
name|ffestb_local_
operator|.
name|construct
operator|.
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_R809
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ffesta_construct_name
operator|=
name|ffesta_tokens
index|[
literal|0
index|]
expr_stmt|;
name|ffesta_tokens
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_construct2_
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_2st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CONSTRUCT"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_construct2_ -- NAME COLON "DO/DOWHILE/IF/SELECT/SELECTCASE"     return ffestb_construct2_;  // to lexer     This extra step is needed to set ffesta_second_kw if the second token    (here) is a NAME, so DO and SELECT can continue to expect it.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_construct2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
condition|)
name|ffesta_second_kw
operator|=
name|ffestr_second
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|ffestb_local_
operator|.
name|construct
operator|.
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R809 -- Parse the SELECTCASE statement     return ffestb_R809;	// to lexer     Make sure the statement has a valid form for the SELECTCASE statement.    If it does, implement the statement.	 */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R809
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffesta_first_kw
condition|)
block|{
case|case
name|FFESTR_firstSELECT
case|:
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffesta_second_kw
operator|!=
name|FFESTR_secondCASE
operator|)
condition|)
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_confirmed
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8091_
return|;
case|case
name|FFESTR_firstSELECTCASE
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8091_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstSELECTCASE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
block|}
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlSELECTCASE
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8091_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"SELECT CASE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"SELECT CASE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"SELECT CASE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8091_ -- "SELECTCASE" or "SELECT" "CASE"     return ffestb_R8091_;  // to lexer     Make sure the statement has a valid form for the SELECTCASE statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8091_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextSELECTCASE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R8092_
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"SELECT CASE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8092_ -- "SELECT/CASE" OPEN_PAREN expr     (ffestb_R8092_)  // to expression handler     Make sure the statement has a valid form for the SELECTCASE statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8092_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|selectcase
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8093_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"SELECT CASE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8093_ -- "SELECT/CASE" OPEN_PAREN expr CLOSE_PAREN     return ffestb_R8093_;  // to lexer     Make sure the statement has a valid form for the SELECTCASE statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8093_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R809
argument_list|(
name|ffesta_construct_name
argument_list|,
name|ffestb_local_
operator|.
name|selectcase
operator|.
name|expr
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
break|break;
default|default:
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_construct_name
operator|!=
name|NULL
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffesta_construct_name
argument_list|)
expr_stmt|;
name|ffesta_construct_name
operator|=
name|NULL
expr_stmt|;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"SELECT CASE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R810 -- Parse the CASE statement     return ffestb_R810;	// to lexer     Make sure the statement has a valid form for the CASE statement.    If it does, implement the statement.	 */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R810
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstCASE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffesta_second_kw
operator|!=
name|FFESTR_secondDEFAULT
condition|)
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8101_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
operator|=
name|ffestt_caselist_create
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextCASE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R8103_
argument_list|)
return|;
block|}
case|case
name|FFELEX_typeNAMES
case|:
switch|switch
condition|(
name|ffesta_first_kw
condition|)
block|{
case|case
name|FFESTR_firstCASEDEFAULT
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
block|}
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlCASEDEFAULT
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8101_
argument_list|(
name|t
argument_list|)
return|;
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8102_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFESTR_firstCASE
case|:
break|break;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
block|}
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlCASE
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
operator|=
name|ffestt_caselist_create
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextCASE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R8103_
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CASE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CASE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CASE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8101_ -- "CASE" case-selector     return ffestb_R8101_;  // to lexer     Make sure the statement has a valid form for the CASE statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8101_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8102_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8102_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
operator|!=
name|NULL
condition|)
name|ffestt_caselist_kill
argument_list|(
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CASE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8102_ -- "CASE" case-selector [NAME]     return ffestb_R8102_;  // to lexer     Make sure the statement has a valid form for the CASE statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8102_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R810
argument_list|(
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
operator|!=
name|NULL
condition|)
name|ffestt_caselist_kill
argument_list|(
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
operator|!=
name|NULL
condition|)
name|ffestt_caselist_kill
argument_list|(
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_tokens
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CASE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8103_ -- "CASE" OPEN_PAREN expr     (ffestb_R8103_)  // to expression handler     Make sure the statement has a valid form for the CASE statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8103_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestt_caselist_append
argument_list|(
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
argument_list|,
name|FALSE
argument_list|,
name|expr
argument_list|,
name|NULL
argument_list|,
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8101_
return|;
case|case
name|FFELEX_typeCOMMA
case|:
name|ffestt_caselist_append
argument_list|(
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
argument_list|,
name|FALSE
argument_list|,
name|expr
argument_list|,
name|NULL
argument_list|,
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextCASE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R8103_
argument_list|)
return|;
case|case
name|FFELEX_typeCOLON
case|:
name|ffestt_caselist_append
argument_list|(
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
argument_list|,
name|TRUE
argument_list|,
name|expr
argument_list|,
name|NULL
argument_list|,
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NULL second expr for 							   now, just plug in. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextCASE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R8104_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestt_caselist_kill
argument_list|(
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CASE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R8104_ -- "CASE" OPEN_PAREN expr COLON expr     (ffestb_R8104_)  // to expression handler     Make sure the statement has a valid form for the CASE statement.  If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R8104_
parameter_list|(
name|ffelexToken
name|ft
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
operator|->
name|previous
operator|->
name|expr2
operator|=
name|expr
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R8101_
return|;
case|case
name|FFELEX_typeCOMMA
case|:
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
operator|->
name|previous
operator|->
name|expr2
operator|=
name|expr
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextCASE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R8103_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestt_caselist_kill
argument_list|(
name|ffestb_local_
operator|.
name|case_stmt
operator|.
name|cases
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CASE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R1001 -- Parse a FORMAT statement     return ffestb_R1001;	 // to lexer     Make sure the statement has a valid form for an FORMAT statement.    If it does, implement the statement.	 */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R1001
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesttFormatList
name|f
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstFORMAT
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstFORMAT
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlFORMAT
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|complained
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|NULL
expr_stmt|;
comment|/* No parent yet. */
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|ffestt_formatlist_create
argument_list|(
name|NULL
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffelex_set_names_pure
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Have even free-form lexer give us 					   NAMES. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10011_
return|;
case|case
name|FFELEX_typeOPEN_ARRAY
case|:
comment|/* "(/". */
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|complained
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|ffestt_formatlist_create
argument_list|(
name|NULL
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeSLASH
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
name|ffelex_set_names_pure
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Have even free-form lexer give us 					   NAMES. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100112_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FORMAT"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FORMAT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_R10011_ -- "FORMAT" OPEN_PAREN expr     return ffestb_R10011_;  // to lexer     For CLOSE_PAREN, wrap up the format list and if it is the top-level one,    exit.  For anything else, pass it to _2_.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R10011_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesttFormatList
name|f
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
break|break;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10012_
argument_list|(
name|t
argument_list|)
return|;
block|}
comment|/* If we have a format we're working on, continue working on it. */
name|f
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|f
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100111_
return|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100114_
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R10012_ -- "FORMAT" OPEN_PAREN [format-item-list]     return ffestb_R10012_;  // to lexer     The initial state for a format-item.	 Here, just handle the initial    number, sign for number, or run-time expression.  Also handle spurious    comma, close-paren (indicating spurious comma), close-array (like    close-paren but preceded by slash), and quoted strings.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R10012_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|unsigned
name|long
name|unsigned_val
decl_stmt|;
name|ffesttFormatList
name|f
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_ANGLE
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffelex_set_names_pure
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_seen_first_exec
operator|&&
operator|!
name|ffestb_local_
operator|.
name|format
operator|.
name|complained
condition|)
block|{
name|ffestb_local_
operator|.
name|format
operator|.
name|complained
operator|=
name|TRUE
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_EXPR_SPEC
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFORMAT
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R100115_
argument_list|)
return|;
case|case
name|FFELEX_typeNUMBER
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
operator|=
name|FALSE
expr_stmt|;
comment|/* No sign present. */
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|=
name|unsigned_val
operator|=
name|strtoul
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|ffelex_set_expecting_hollerith
argument_list|(
name|unsigned_val
argument_list|,
literal|'\0'
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10014_
return|;
case|case
name|FFELEX_typePLUS
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
operator|=
name|TRUE
expr_stmt|;
comment|/* Positive. */
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10013_
return|;
case|case
name|FFELEX_typeMINUS
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
operator|=
name|FALSE
expr_stmt|;
comment|/* Negative. */
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10013_
return|;
case|case
name|FFELEX_typeCOLON
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
comment|/* "::". */
case|case
name|FFELEX_typeSLASH
case|:
case|case
name|FFELEX_typeCONCAT
case|:
comment|/* "//". */
case|case
name|FFELEX_typeNAMES
case|:
case|case
name|FFELEX_typeDOLLAR
case|:
case|case
name|FFELEX_typeOPEN_PAREN
case|:
case|case
name|FFELEX_typeOPEN_ARRAY
case|:
comment|/* "(/". */
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
operator|=
name|FALSE
expr_stmt|;
comment|/* No sign present. */
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10014_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCOMMA
case|:
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_EXTRA_COMMA
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10012_
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_EXTRA_COMMA
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|f
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100114_
return|;
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|f
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100111_
return|;
case|case
name|FFELEX_typeCLOSE_ARRAY
case|:
comment|/* "/)". */
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeSLASH
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
name|f
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100114_
return|;
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|f
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100111_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_FORMAT_MISSING_PAREN
argument_list|,
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|f
init|;
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
operator|->
name|next
control|)
empty_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|f
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100114_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeQUOTE
case|:
if|if
condition|(
name|ffe_is_vxt
argument_list|()
condition|)
break|break;
comment|/* Error, probably something like FORMAT("17) 				   = X. */
name|ffelex_set_expecting_hollerith
argument_list|(
operator|-
literal|1
argument_list|,
literal|'\"'
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't have to unset 									   this one. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100113_
return|;
case|case
name|FFELEX_typeAPOSTROPHE
case|:
if|#
directive|if
literal|0
comment|/* No apparent need for this, and not killed 				   anywhere. */
block|ffesta_tokens[1] = ffelex_token_use (t);
endif|#
directive|endif
name|ffelex_set_expecting_hollerith
argument_list|(
operator|-
literal|1
argument_list|,
literal|'\''
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't have to unset 									   this one. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100113_
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FORMAT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffestt_formatlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R10013_ -- "FORMAT" OPEN_PAREN [format-item-list] PLUS/MINUS     return ffestb_R10013_;  // to lexer     Expect a NUMBER or complain about and then ignore the PLUS/MINUS.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R10013_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|unsigned
name|long
name|unsigned_val
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|unsigned_val
operator|=
name|strtoul
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
condition|?
name|unsigned_val
else|:
operator|-
name|unsigned_val
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
operator|=
name|TRUE
expr_stmt|;
comment|/* Sign present. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10014_
return|;
default|default:
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_SPURIOUS_SIGN
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10012_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R10014_ -- "FORMAT" OPEN_PAREN [format-item-list] [[+/-] NUMBER]     return ffestb_R10014_;  // to lexer     Here is where we expect to see the actual NAMES, COLON, SLASH, OPEN_PAREN,    OPEN_ARRAY, COLONCOLON, CONCAT, DOLLAR, or HOLLERITH that identifies what    kind of format-item we're dealing with.  But if we see a NUMBER instead, it    means free-form spaces number like "5 6 X", so scale the current number    accordingly and reenter this state.	(I really wouldn't be surprised if    they change this spacing rule in the F90 spec so that you can't embed    spaces within numbers or within keywords like BN in a free-source-form    program.)  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R10014_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesttFormatList
name|f
decl_stmt|;
name|ffeTokenLength
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffestrFormat
name|kw
decl_stmt|;
name|ffelex_set_expecting_hollerith
argument_list|(
literal|0
argument_list|,
literal|'\0'
argument_list|,
name|ffewhere_line_unknown
argument_list|()
argument_list|,
name|ffewhere_column_unknown
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeHOLLERITH
case|:
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeR1016
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
comment|/* It WAS present! */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100111_
return|;
case|case
name|FFELEX_typeNUMBER
case|:
name|assert
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
argument_list|)
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|rtexpr
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_SPURIOUS_NUMBER
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10014_
return|;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
condition|)
block|{
for|for
control|(
name|i
operator|=
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|+
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
operator|*=
literal|10
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
operator|+=
name|strtoul
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|+
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|*=
literal|10
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|+=
name|strtoul
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|ffelex_set_expecting_hollerith
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
argument_list|,
literal|'\0'
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10014_
return|;
case|case
name|FFELEX_typeCOLONCOLON
case|:
comment|/* "::". */
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
block|{
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_FORMAT_BAD_COLON_SPEC
argument_list|,
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeCOLON
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
block|}
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeCOLON
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100112_
return|;
case|case
name|FFELEX_typeCOLON
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
block|{
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_FORMAT_BAD_COLON_SPEC
argument_list|,
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100112_
return|;
block|}
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeCOLON
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100112_
return|;
case|case
name|FFELEX_typeCONCAT
case|:
comment|/* "//". */
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_SPURIOUS_SIGN
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|=
operator|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
operator|<
literal|0
operator|)
condition|?
operator|-
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
else|:
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
expr_stmt|;
block|}
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeSLASH
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeSLASH
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100112_
return|;
case|case
name|FFELEX_typeSLASH
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_SPURIOUS_SIGN
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|=
operator|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
operator|<
literal|0
operator|)
condition|?
operator|-
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
else|:
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
expr_stmt|;
block|}
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeSLASH
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100112_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_SPURIOUS_SIGN
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|=
operator|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
operator|<
literal|0
operator|)
condition|?
operator|-
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
else|:
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
expr_stmt|;
block|}
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeFORMAT
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1003D
operator|.
name|R1004
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1003D
operator|.
name|format
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|ffestt_formatlist_create
argument_list|(
name|f
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10011_
return|;
case|case
name|FFELEX_typeOPEN_ARRAY
case|:
comment|/* "(/". */
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_SPURIOUS_SIGN
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|=
operator|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
operator|<
literal|0
operator|)
condition|?
operator|-
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
else|:
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
expr_stmt|;
block|}
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeFORMAT
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1003D
operator|.
name|R1004
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1003D
operator|.
name|format
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|ffestt_formatlist_create
argument_list|(
name|f
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeSLASH
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100112_
return|;
case|case
name|FFELEX_typeCLOSE_ARRAY
case|:
comment|/* "/)". */
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeSLASH
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
expr_stmt|;
name|f
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100114_
return|;
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|f
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100111_
return|;
case|case
name|FFELEX_typeQUOTE
case|:
if|if
condition|(
name|ffe_is_vxt
argument_list|()
condition|)
break|break;
comment|/* A totally bad character in a VXT FORMAT. */
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_SPURIOUS_NUMBER
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* No apparent need for this, and not killed 				   anywhere. */
block|ffesta_tokens[1] = ffelex_token_use (t);
endif|#
directive|endif
name|ffelex_set_expecting_hollerith
argument_list|(
operator|-
literal|1
argument_list|,
literal|'\"'
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't have to unset 									   this one. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100113_
return|;
case|case
name|FFELEX_typeAPOSTROPHE
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_SPURIOUS_NUMBER
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* No apparent need for this, and not killed 				   anywhere. */
block|ffesta_tokens[1] = ffelex_token_use (t);
endif|#
directive|endif
name|ffelex_set_expecting_hollerith
argument_list|(
operator|-
literal|1
argument_list|,
literal|'\''
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't have to unset 									   this one. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100113_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_FORMAT_MISSING_PAREN
argument_list|,
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|f
init|;
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
operator|->
name|next
control|)
empty_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|f
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100114_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeDOLLAR
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeDOLLAR
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10015_
return|;
case|case
name|FFELEX_typeNAMES
case|:
name|kw
operator|=
name|ffestr_format
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kw
condition|)
block|{
case|case
name|FFESTR_formatI
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeI
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlI
expr_stmt|;
break|break;
case|case
name|FFESTR_formatB
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeB
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlB
expr_stmt|;
break|break;
case|case
name|FFESTR_formatO
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeO
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlO
expr_stmt|;
break|break;
case|case
name|FFESTR_formatZ
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeZ
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlZ
expr_stmt|;
break|break;
case|case
name|FFESTR_formatF
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeF
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlF
expr_stmt|;
break|break;
case|case
name|FFESTR_formatE
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeE
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlE
expr_stmt|;
break|break;
case|case
name|FFESTR_formatEN
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeEN
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlEN
expr_stmt|;
break|break;
case|case
name|FFESTR_formatG
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeG
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlG
expr_stmt|;
break|break;
case|case
name|FFESTR_formatL
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeL
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlL
expr_stmt|;
break|break;
case|case
name|FFESTR_formatA
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeA
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlA
expr_stmt|;
break|break;
case|case
name|FFESTR_formatD
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeD
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlD
expr_stmt|;
break|break;
case|case
name|FFESTR_formatQ
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeQ
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlQ
expr_stmt|;
break|break;
case|case
name|FFESTR_formatDOLLAR
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeDOLLAR
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlDOLLAR
expr_stmt|;
break|break;
case|case
name|FFESTR_formatP
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeP
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlP
expr_stmt|;
break|break;
case|case
name|FFESTR_formatT
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeT
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlT
expr_stmt|;
break|break;
case|case
name|FFESTR_formatTL
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeTL
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlTL
expr_stmt|;
break|break;
case|case
name|FFESTR_formatTR
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeTR
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlTR
expr_stmt|;
break|break;
case|case
name|FFESTR_formatX
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeX
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlX
expr_stmt|;
break|break;
case|case
name|FFESTR_formatS
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeS
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlS
expr_stmt|;
break|break;
case|case
name|FFESTR_formatSP
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeSP
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlSP
expr_stmt|;
break|break;
case|case
name|FFESTR_formatSS
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeSS
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlSS
expr_stmt|;
break|break;
case|case
name|FFESTR_formatBN
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeBN
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlBN
expr_stmt|;
break|break;
case|case
name|FFESTR_formatBZ
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeBZ
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlBZ
expr_stmt|;
break|break;
case|case
name|FFESTR_formatH
case|:
comment|/* Error, either "H" or "<expr>H". */
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeH
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlH
expr_stmt|;
break|break;
case|case
name|FFESTR_formatPD
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_subr_R1001_append_p_
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|t
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|t
argument_list|,
name|FFESTR_formatlP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeD
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlPD
expr_stmt|;
break|break;
case|case
name|FFESTR_formatPE
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_subr_R1001_append_p_
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|t
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|t
argument_list|,
name|FFESTR_formatlP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeE
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlPE
expr_stmt|;
break|break;
case|case
name|FFESTR_formatPEN
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_subr_R1001_append_p_
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|t
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|t
argument_list|,
name|FFESTR_formatlP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeEN
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlPEN
expr_stmt|;
break|break;
case|case
name|FFESTR_formatPF
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_subr_R1001_append_p_
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|t
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|t
argument_list|,
name|FFESTR_formatlP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeF
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlPF
expr_stmt|;
break|break;
case|case
name|FFESTR_formatPG
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_subr_R1001_append_p_
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|t
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|t
argument_list|,
name|FFESTR_formatlP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeG
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlPG
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Number preceding this invalid elsewhere. */
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
name|p
operator|=
name|strpbrk
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"0123456789"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|i
operator|=
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|p
operator|-
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
operator|+
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10015_
return|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|==
name|FFESTP_formattypeH
condition|)
name|p
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|"0123456789"
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10015_
return|;
name|i
operator|=
name|p
operator|-
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Collect digits. */
block|}
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|present
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
operator|=
name|ffelex_token_number_from_names
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|u
operator|.
name|unsigned_val
operator|=
name|strtoul
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ffelex_token_length
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
expr_stmt|;
name|i
operator|+=
name|ffelex_token_length
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10016_
return|;
if|if
condition|(
operator|(
name|kw
operator|!=
name|FFESTR_formatP
operator|)
operator|||
operator|!
name|ffelex_is_firstnamechar
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|!=
name|FFESTP_formattypeH
condition|)
name|ffesta_ffebad_1p
argument_list|(
name|FFEBAD_FORMAT_TEXT_IN_NUMBER
argument_list|,
name|t
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10016_
return|;
block|}
comment|/* Here we have [number]P[number][text].	Treat as 	 [number]P,[number][text]. */
name|ffestb_subr_R1001_append_p_
argument_list|()
expr_stmt|;
name|t
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|t
operator|=
name|ffelex_token_names_from_names
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|post
expr_stmt|;
name|kw
operator|=
name|ffestr_format
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kw
condition|)
block|{
comment|/* Only a few possibilities here. */
case|case
name|FFESTR_formatD
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeD
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlD
expr_stmt|;
break|break;
case|case
name|FFESTR_formatE
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeE
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlE
expr_stmt|;
break|break;
case|case
name|FFESTR_formatEN
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeEN
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlEN
expr_stmt|;
break|break;
case|case
name|FFESTR_formatF
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeF
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlF
expr_stmt|;
break|break;
case|case
name|FFESTR_formatG
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeG
expr_stmt|;
name|i
operator|=
name|FFESTR_formatlG
expr_stmt|;
break|break;
default|default:
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_P_NOCOMMA
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
name|p
operator|=
name|strpbrk
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"0123456789"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|i
operator|=
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|p
operator|-
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
operator|+
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10015_
return|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
name|p
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|"0123456789"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10015_
return|;
name|i
operator|=
name|p
operator|-
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Collect digits anyway. */
block|}
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|present
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
operator|=
name|ffelex_token_number_from_names
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|u
operator|.
name|unsigned_val
operator|=
name|strtoul
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ffelex_token_length
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
expr_stmt|;
name|i
operator|+=
name|ffelex_token_length
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10016_
return|;
name|ffesta_ffebad_1p
argument_list|(
name|FFEBAD_FORMAT_TEXT_IN_NUMBER
argument_list|,
name|t
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10016_
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FORMAT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffestt_formatlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R10015_ -- [[+/-] NUMBER] NAMES     return ffestb_R10015_;  // to lexer     Here we've gotten at least the initial mnemonic for the edit descriptor.    We expect either a NUMBER, for the post-mnemonic value, a NAMES, for    further clarification (in free-form only, sigh) of the mnemonic, or    anything else.  In all cases we go to _6_, with the difference that for    NUMBER and NAMES we send the next token rather than the current token.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R10015_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|bool
name|split_pea
decl_stmt|;
comment|/* New NAMES requires splitting kP from new 				   edit desc. */
name|ffestrFormat
name|kw
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffeTokenLength
name|i
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_ANGLE
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffelex_set_names_pure
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_seen_first_exec
operator|&&
operator|!
name|ffestb_local_
operator|.
name|format
operator|.
name|complained
condition|)
block|{
name|ffestb_local_
operator|.
name|format
operator|.
name|complained
operator|=
name|TRUE
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_EXPR_SPEC
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFORMAT
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R100116_
argument_list|)
return|;
case|case
name|FFELEX_typeNUMBER
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|present
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|u
operator|.
name|unsigned_val
operator|=
name|strtoul
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10016_
return|;
case|case
name|FFELEX_typeNAMES
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* NAMES " " NAMES invalid elsewhere in 				   free-form. */
name|kw
operator|=
name|ffestr_format
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
condition|)
block|{
case|case
name|FFESTP_formattypeP
case|:
name|split_pea
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeH
case|:
comment|/* An error, maintain this indicator. */
name|kw
operator|=
name|FFESTR_formatNone
expr_stmt|;
name|split_pea
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|split_pea
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|kw
condition|)
block|{
case|case
name|FFESTR_formatF
case|:
switch|switch
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
condition|)
block|{
case|case
name|FFESTP_formattypeP
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeF
expr_stmt|;
break|break;
default|default:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|FFESTR_formatlF
expr_stmt|;
break|break;
case|case
name|FFESTR_formatE
case|:
switch|switch
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
condition|)
block|{
case|case
name|FFESTP_formattypeP
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeE
expr_stmt|;
break|break;
default|default:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|FFESTR_formatlE
expr_stmt|;
break|break;
case|case
name|FFESTR_formatEN
case|:
switch|switch
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
condition|)
block|{
case|case
name|FFESTP_formattypeP
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeEN
expr_stmt|;
break|break;
default|default:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|FFESTR_formatlEN
expr_stmt|;
break|break;
case|case
name|FFESTR_formatG
case|:
switch|switch
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
condition|)
block|{
case|case
name|FFESTP_formattypeP
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeG
expr_stmt|;
break|break;
default|default:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|FFESTR_formatlG
expr_stmt|;
break|break;
case|case
name|FFESTR_formatL
case|:
switch|switch
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
condition|)
block|{
case|case
name|FFESTP_formattypeT
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeTL
expr_stmt|;
break|break;
default|default:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|FFESTR_formatlL
expr_stmt|;
break|break;
case|case
name|FFESTR_formatD
case|:
switch|switch
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
condition|)
block|{
case|case
name|FFESTP_formattypeP
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeD
expr_stmt|;
break|break;
default|default:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|FFESTR_formatlD
expr_stmt|;
break|break;
case|case
name|FFESTR_formatS
case|:
switch|switch
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
condition|)
block|{
case|case
name|FFESTP_formattypeS
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeSS
expr_stmt|;
break|break;
default|default:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|FFESTR_formatlS
expr_stmt|;
break|break;
case|case
name|FFESTR_formatP
case|:
switch|switch
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
condition|)
block|{
case|case
name|FFESTP_formattypeS
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeSP
expr_stmt|;
break|break;
default|default:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|FFESTR_formatlP
expr_stmt|;
break|break;
case|case
name|FFESTR_formatR
case|:
switch|switch
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
condition|)
block|{
case|case
name|FFESTP_formattypeT
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeTR
expr_stmt|;
break|break;
default|default:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|FFESTR_formatlR
expr_stmt|;
break|break;
case|case
name|FFESTR_formatZ
case|:
switch|switch
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
condition|)
block|{
case|case
name|FFESTP_formattypeB
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeBZ
expr_stmt|;
break|break;
default|default:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|FFESTR_formatlZ
expr_stmt|;
break|break;
case|case
name|FFESTR_formatN
case|:
switch|switch
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
condition|)
block|{
case|case
name|FFESTP_formattypeE
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeEN
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeB
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeBN
expr_stmt|;
break|break;
default|default:
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|FFESTR_formatlN
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|!=
name|FFESTP_formattypeH
condition|)
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
name|split_pea
operator|=
name|FALSE
expr_stmt|;
comment|/* Go ahead and let the P be in the party. */
name|p
operator|=
name|strpbrk
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"0123456789"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|i
operator|=
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|p
operator|-
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|split_pea
condition|)
block|{
name|ffestb_subr_R1001_append_p_
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
operator|+
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10015_
return|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
name|p
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|"0123456789"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10015_
return|;
name|i
operator|=
name|p
operator|-
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Collect digits anyway. */
block|}
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|present
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
operator|=
name|ffelex_token_number_from_names
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|u
operator|.
name|unsigned_val
operator|=
name|strtoul
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ffelex_token_length
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
expr_stmt|;
name|i
operator|+=
name|ffelex_token_length
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10016_
return|;
name|ffesta_ffebad_1p
argument_list|(
name|FFEBAD_FORMAT_TEXT_IN_NUMBER
argument_list|,
name|t
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10016_
return|;
default|default:
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10016_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R10016_ -- [[+/-] NUMBER] NAMES NUMBER     return ffestb_R10016_;  // to lexer     Expect a PERIOD here.  Maybe find a NUMBER to append to the current    number, in which case return to this state.	Maybe find a NAMES to switch    from a kP descriptor to a new descriptor (else the NAMES is spurious),    in which case generator the P item and go to state _4_.  Anything    else, pass token on to state _8_.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R10016_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typePERIOD
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10017_
return|;
case|case
name|FFELEX_typeNUMBER
case|:
name|assert
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|present
argument_list|)
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|rtexpr
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_SPURIOUS_NUMBER
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10016_
return|;
block|}
for|for
control|(
name|i
operator|=
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|+
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|u
operator|.
name|unsigned_val
operator|*=
literal|10
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|u
operator|.
name|unsigned_val
operator|+=
name|strtoul
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10016_
return|;
case|case
name|FFELEX_typeNAMES
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* NUMBER " " NAMES invalid elsewhere. */
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|!=
name|FFESTP_formattypeP
condition|)
block|{
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_FORMAT_TEXT_IN_NUMBER
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10016_
return|;
block|}
name|ffestb_subr_R1001_append_p_
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|post
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10014_
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10018_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R10017_ -- [[+/-] NUMBER] NAMES NUMBER PERIOD     return ffestb_R10017_;  // to lexer     Here we've gotten the period following the edit descriptor.    We expect either a NUMBER, for the dot value, or something else, which    probably means we're not even close to being in a real FORMAT statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R10017_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_ANGLE
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffelex_set_names_pure
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_seen_first_exec
operator|&&
operator|!
name|ffestb_local_
operator|.
name|format
operator|.
name|complained
condition|)
block|{
name|ffestb_local_
operator|.
name|format
operator|.
name|complained
operator|=
name|TRUE
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_EXPR_SPEC
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFORMAT
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R100117_
argument_list|)
return|;
case|case
name|FFELEX_typeNUMBER
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|present
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|u
operator|.
name|unsigned_val
operator|=
name|strtoul
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10018_
return|;
default|default:
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_FORMAT_MISSING_DOT
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffestt_formatlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R10018_ -- [[+/-] NUMBER] NAMES NUMBER PERIOD NUMBER     return ffestb_R10018_;  // to lexer     Expect a NAMES here, which must begin with "E" to be valid.	Maybe find a    NUMBER to append to the current number, in which case return to this state.    Anything else, pass token on to state _10_.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R10018_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|assert
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|present
argument_list|)
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|rtexpr
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_SPURIOUS_NUMBER
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10018_
return|;
block|}
for|for
control|(
name|i
operator|=
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|+
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|u
operator|.
name|unsigned_val
operator|*=
literal|10
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|u
operator|.
name|unsigned_val
operator|+=
name|strtoul
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10018_
return|;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
operator|!
name|ffesrc_char_match_init
argument_list|(
operator|*
operator|(
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
operator|)
argument_list|,
literal|'E'
argument_list|,
literal|'e'
argument_list|)
condition|)
block|{
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_FORMAT_TEXT_IN_NUMBER
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10018_
return|;
block|}
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10019_
return|;
comment|/* Go get NUMBER. */
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|ffesta_ffebad_1p
argument_list|(
name|FFEBAD_FORMAT_TEXT_IN_NUMBER
argument_list|,
name|t
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10018_
return|;
block|}
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|present
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|t
operator|=
name|ffelex_token_number_from_names
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|u
operator|.
name|unsigned_val
operator|=
name|strtoul
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ffelex_token_length
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|t
argument_list|)
expr_stmt|;
name|i
operator|+=
name|ffelex_token_length
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100110_
return|;
name|ffesta_ffebad_1p
argument_list|(
name|FFEBAD_FORMAT_TEXT_IN_NUMBER
argument_list|,
name|t
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100110_
return|;
default|default:
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100110_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R10019_ -- [[+/-] NUMBER] NAMES NUMBER PERIOD NUMBER "E"     return ffestb_R10019_;  // to lexer     Here we've gotten the "E" following the edit descriptor.    We expect either a NUMBER, for the exponent value, or something else.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R10019_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_ANGLE
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffelex_set_names_pure
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_seen_first_exec
operator|&&
operator|!
name|ffestb_local_
operator|.
name|format
operator|.
name|complained
condition|)
block|{
name|ffestb_local_
operator|.
name|format
operator|.
name|complained
operator|=
name|TRUE
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_EXPR_SPEC
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFORMAT
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R100118_
argument_list|)
return|;
case|case
name|FFELEX_typeNUMBER
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|present
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|u
operator|.
name|unsigned_val
operator|=
name|strtoul
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100110_
return|;
default|default:
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_FORMAT_MISSING_EXP
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffestt_formatlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R100110_ -- [[+/-] NUMBER] NAMES NUMBER [PERIOD NUMBER ["E" NUMBER]]     return ffestb_R100110_;  // to lexer     Maybe find a NUMBER to append to the current number, in which case return    to this state.  Anything else, handle current descriptor, then pass token    on to state _10_.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R100110_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
enum|enum
name|expect
block|{
name|required
block|,
name|optional
block|,
name|disallowed
block|}
enum|;
name|ffebad
name|err
decl_stmt|;
name|enum
name|expect
name|pre
decl_stmt|;
name|enum
name|expect
name|post
decl_stmt|;
name|enum
name|expect
name|dot
decl_stmt|;
name|enum
name|expect
name|exp
decl_stmt|;
name|bool
name|R1005
decl_stmt|;
name|ffesttFormatList
name|f
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|assert
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|present
argument_list|)
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|rtexpr
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_SPURIOUS_NUMBER
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100110_
return|;
block|}
for|for
control|(
name|i
operator|=
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|+
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|u
operator|.
name|unsigned_val
operator|*=
literal|10
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|u
operator|.
name|unsigned_val
operator|+=
name|strtoul
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100110_
return|;
default|default:
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|sign
operator|&&
operator|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|!=
name|FFESTP_formattypeP
operator|)
operator|&&
operator|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
operator|!=
name|FFESTP_formattypeH
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_SPURIOUS_SIGN
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|unsigned_val
operator|=
operator|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
operator|<
literal|0
operator|)
condition|?
operator|-
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
else|:
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|signed_val
expr_stmt|;
block|}
switch|switch
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|current
condition|)
block|{
case|case
name|FFESTP_formattypeI
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_I_SPEC
expr_stmt|;
name|pre
operator|=
name|optional
expr_stmt|;
name|post
operator|=
name|required
expr_stmt|;
name|dot
operator|=
name|optional
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeB
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_B_SPEC
expr_stmt|;
name|pre
operator|=
name|optional
expr_stmt|;
name|post
operator|=
name|required
expr_stmt|;
name|dot
operator|=
name|optional
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeO
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_O_SPEC
expr_stmt|;
name|pre
operator|=
name|optional
expr_stmt|;
name|post
operator|=
name|required
expr_stmt|;
name|dot
operator|=
name|optional
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeZ
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_Z_SPEC
expr_stmt|;
name|pre
operator|=
name|optional
expr_stmt|;
name|post
operator|=
name|required
expr_stmt|;
name|dot
operator|=
name|optional
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeF
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_F_SPEC
expr_stmt|;
name|pre
operator|=
name|optional
expr_stmt|;
name|post
operator|=
name|required
expr_stmt|;
name|dot
operator|=
name|required
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeE
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_E_SPEC
expr_stmt|;
name|pre
operator|=
name|optional
expr_stmt|;
name|post
operator|=
name|required
expr_stmt|;
name|dot
operator|=
name|required
expr_stmt|;
name|exp
operator|=
name|optional
expr_stmt|;
name|R1005
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeEN
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_EN_SPEC
expr_stmt|;
name|pre
operator|=
name|optional
expr_stmt|;
name|post
operator|=
name|required
expr_stmt|;
name|dot
operator|=
name|required
expr_stmt|;
name|exp
operator|=
name|optional
expr_stmt|;
name|R1005
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeG
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_G_SPEC
expr_stmt|;
name|pre
operator|=
name|optional
expr_stmt|;
name|post
operator|=
name|required
expr_stmt|;
name|dot
operator|=
name|required
expr_stmt|;
name|exp
operator|=
name|optional
expr_stmt|;
name|R1005
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeL
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_L_SPEC
expr_stmt|;
name|pre
operator|=
name|optional
expr_stmt|;
name|post
operator|=
name|required
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeA
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_A_SPEC
expr_stmt|;
name|pre
operator|=
name|optional
expr_stmt|;
name|post
operator|=
name|optional
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeD
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_D_SPEC
expr_stmt|;
name|pre
operator|=
name|optional
expr_stmt|;
name|post
operator|=
name|required
expr_stmt|;
name|dot
operator|=
name|required
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeQ
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_Q_SPEC
expr_stmt|;
name|pre
operator|=
name|disallowed
expr_stmt|;
name|post
operator|=
name|disallowed
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeDOLLAR
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_DOLLAR_SPEC
expr_stmt|;
name|pre
operator|=
name|disallowed
expr_stmt|;
name|post
operator|=
name|disallowed
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeP
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_P_SPEC
expr_stmt|;
name|pre
operator|=
name|required
expr_stmt|;
name|post
operator|=
name|disallowed
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeT
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_T_SPEC
expr_stmt|;
name|pre
operator|=
name|disallowed
expr_stmt|;
name|post
operator|=
name|required
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeTL
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_TL_SPEC
expr_stmt|;
name|pre
operator|=
name|disallowed
expr_stmt|;
name|post
operator|=
name|required
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeTR
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_TR_SPEC
expr_stmt|;
name|pre
operator|=
name|disallowed
expr_stmt|;
name|post
operator|=
name|required
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeX
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_X_SPEC
expr_stmt|;
name|pre
operator|=
name|ffe_is_pedantic
argument_list|()
condition|?
name|required
else|:
name|optional
expr_stmt|;
name|post
operator|=
name|disallowed
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeS
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_S_SPEC
expr_stmt|;
name|pre
operator|=
name|disallowed
expr_stmt|;
name|post
operator|=
name|disallowed
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeSP
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_SP_SPEC
expr_stmt|;
name|pre
operator|=
name|disallowed
expr_stmt|;
name|post
operator|=
name|disallowed
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeSS
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_SS_SPEC
expr_stmt|;
name|pre
operator|=
name|disallowed
expr_stmt|;
name|post
operator|=
name|disallowed
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeBN
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_BN_SPEC
expr_stmt|;
name|pre
operator|=
name|disallowed
expr_stmt|;
name|post
operator|=
name|disallowed
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeBZ
case|:
name|err
operator|=
name|FFEBAD_FORMAT_BAD_BZ_SPEC
expr_stmt|;
name|pre
operator|=
name|disallowed
expr_stmt|;
name|post
operator|=
name|disallowed
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeH
case|:
comment|/* Definitely an error, make sure of 					   it. */
name|err
operator|=
name|FFEBAD_FORMAT_BAD_H_SPEC
expr_stmt|;
name|pre
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|?
name|disallowed
else|:
name|required
expr_stmt|;
name|post
operator|=
name|disallowed
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeNone
case|:
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_FORMAT_BAD_SPEC
argument_list|,
name|ffestb_local_
operator|.
name|format
operator|.
name|t
argument_list|)
expr_stmt|;
name|clean_up_to_11_
label|:
comment|/* :::::::::::::::::::: */
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100111_
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|assert
argument_list|(
literal|"bad format item"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|FFEBAD_FORMAT_BAD_H_SPEC
expr_stmt|;
name|pre
operator|=
name|disallowed
expr_stmt|;
name|post
operator|=
name|disallowed
expr_stmt|;
name|dot
operator|=
name|disallowed
expr_stmt|;
name|exp
operator|=
name|disallowed
expr_stmt|;
name|R1005
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|pre
operator|==
name|disallowed
operator|)
operator|&&
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
operator|)
operator|||
operator|(
operator|(
name|pre
operator|==
name|required
operator|)
operator|&&
operator|!
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
operator|)
condition|)
block|{
name|ffesta_ffebad_1t
argument_list|(
name|err
argument_list|,
operator|(
name|pre
operator|==
name|required
operator|)
condition|?
name|ffestb_local_
operator|.
name|format
operator|.
name|t
else|:
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
goto|goto
name|clean_up_to_11_
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
operator|(
operator|(
name|post
operator|==
name|disallowed
operator|)
operator|&&
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|present
operator|)
operator|||
operator|(
operator|(
name|post
operator|==
name|required
operator|)
operator|&&
operator|!
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|present
operator|)
condition|)
block|{
name|ffesta_ffebad_1t
argument_list|(
name|err
argument_list|,
operator|(
name|post
operator|==
name|required
operator|)
condition|?
name|ffestb_local_
operator|.
name|format
operator|.
name|t
else|:
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
expr_stmt|;
goto|goto
name|clean_up_to_11_
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
operator|(
operator|(
name|dot
operator|==
name|disallowed
operator|)
operator|&&
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|present
operator|)
operator|||
operator|(
operator|(
name|dot
operator|==
name|required
operator|)
operator|&&
operator|!
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|present
operator|)
condition|)
block|{
name|ffesta_ffebad_1t
argument_list|(
name|err
argument_list|,
operator|(
name|dot
operator|==
name|required
operator|)
condition|?
name|ffestb_local_
operator|.
name|format
operator|.
name|t
else|:
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|t
argument_list|)
expr_stmt|;
goto|goto
name|clean_up_to_11_
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
operator|(
operator|(
name|exp
operator|==
name|disallowed
operator|)
operator|&&
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|present
operator|)
operator|||
operator|(
operator|(
name|exp
operator|==
name|required
operator|)
operator|&&
operator|!
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|present
operator|)
condition|)
block|{
name|ffesta_ffebad_1t
argument_list|(
name|err
argument_list|,
operator|(
name|exp
operator|==
name|required
operator|)
condition|?
name|ffestb_local_
operator|.
name|format
operator|.
name|t
else|:
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|t
argument_list|)
expr_stmt|;
goto|goto
name|clean_up_to_11_
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|current
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|t
expr_stmt|;
if|if
condition|(
name|R1005
condition|)
block|{
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|post
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1009
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
expr_stmt|;
block|}
else|else
comment|/* Must be R1010. */
block|{
if|if
condition|(
name|pre
operator|==
name|disallowed
condition|)
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|post
expr_stmt|;
else|else
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100111_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R100111_ -- edit-descriptor     return ffestb_R100111_;  // to lexer     Expect a COMMA, CLOSE_PAREN, CLOSE_ARRAY, COLON, COLONCOLON, SLASH, or    CONCAT, or complain about missing comma.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R100111_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesttFormatList
name|f
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10012_
return|;
case|case
name|FFELEX_typeCOLON
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
case|case
name|FFELEX_typeSLASH
case|:
case|case
name|FFELEX_typeCONCAT
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10012_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|f
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100114_
return|;
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|f
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100111_
return|;
case|case
name|FFELEX_typeCLOSE_ARRAY
case|:
comment|/* "/)". */
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeSLASH
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
name|f
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100114_
return|;
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|f
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100111_
return|;
case|case
name|FFELEX_typeOPEN_ANGLE
case|:
case|case
name|FFELEX_typeDOLLAR
case|:
case|case
name|FFELEX_typeNUMBER
case|:
case|case
name|FFELEX_typeOPEN_PAREN
case|:
case|case
name|FFELEX_typeOPEN_ARRAY
case|:
case|case
name|FFELEX_typeQUOTE
case|:
case|case
name|FFELEX_typeAPOSTROPHE
case|:
case|case
name|FFELEX_typeNAMES
case|:
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_FORMAT_MISSING_COMMA
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10012_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_FORMAT_MISSING_PAREN
argument_list|,
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|f
init|;
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
operator|->
name|next
control|)
empty_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|f
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100114_
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FORMAT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffestt_formatlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R100112_ -- COLON, COLONCOLON, SLASH, OPEN_ARRAY, or CONCAT     return ffestb_R100112_;  // to lexer     Like _11_ except the COMMA is optional.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R100112_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesttFormatList
name|f
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10012_
return|;
case|case
name|FFELEX_typeCOLON
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
case|case
name|FFELEX_typeSLASH
case|:
case|case
name|FFELEX_typeCONCAT
case|:
case|case
name|FFELEX_typeOPEN_ANGLE
case|:
case|case
name|FFELEX_typeNAMES
case|:
case|case
name|FFELEX_typeDOLLAR
case|:
case|case
name|FFELEX_typeNUMBER
case|:
case|case
name|FFELEX_typeOPEN_PAREN
case|:
case|case
name|FFELEX_typeOPEN_ARRAY
case|:
case|case
name|FFELEX_typeQUOTE
case|:
case|case
name|FFELEX_typeAPOSTROPHE
case|:
case|case
name|FFELEX_typePLUS
case|:
case|case
name|FFELEX_typeMINUS
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10012_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|f
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100114_
return|;
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|f
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100111_
return|;
case|case
name|FFELEX_typeCLOSE_ARRAY
case|:
comment|/* "/)". */
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeSLASH
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|present
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|rtexpr
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|unsigned_val
operator|=
literal|1
expr_stmt|;
name|f
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100114_
return|;
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|f
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100111_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_FORMAT_MISSING_PAREN
argument_list|,
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|ffestb_local_
operator|.
name|format
operator|.
name|f
init|;
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|u
operator|.
name|root
operator|.
name|parent
operator|->
name|next
control|)
empty_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|f
operator|=
name|f
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100114_
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FORMAT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffestt_formatlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R100113_ -- Handle CHARACTER token.     return ffestb_R100113_;  // to lexer     Append the format item to the list, go to _11_.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R100113_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesttFormatList
name|f
decl_stmt|;
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCHARACTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_pedantic_not_90
argument_list|()
operator|&&
operator|(
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_NULL_CHAR_CONST
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|f
operator|=
name|ffestt_formatlist_append
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|FFESTP_formattypeR1016
expr_stmt|;
name|f
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100111_
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R100114_ -- "FORMAT" OPEN_PAREN format-item-list CLOSE_PAREN     return ffestb_R100114_;  // to lexer     Handle EOS/SEMICOLON or something else.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R100114_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelex_set_names_pure
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
operator|&&
operator|!
name|ffestb_local_
operator|.
name|format
operator|.
name|complained
condition|)
name|ffestc_R1001
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
name|ffestt_formatlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FORMAT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffestt_formatlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R100115_ -- OPEN_ANGLE expr     (ffestb_R100115_)  // to expression handler     Handle expression prior to the edit descriptor.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R100115_
parameter_list|(
name|ffelexToken
name|ft
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_ANGLE
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|rtexpr
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|ffelex_set_names_pure
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10014_
return|;
default|default:
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FORMAT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffestt_formatlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R100116_ -- "[n]X" OPEN_ANGLE expr     (ffestb_R100116_)  // to expression handler     Handle expression after the edit descriptor.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R100116_
parameter_list|(
name|ffelexToken
name|ft
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_ANGLE
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|present
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|rtexpr
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|ffelex_set_names_pure
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10016_
return|;
default|default:
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FORMAT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffestt_formatlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R100117_ -- "[n]X[n]." OPEN_ANGLE expr     (ffestb_R100117_)  // to expression handler     Handle expression after the PERIOD.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R100117_
parameter_list|(
name|ffelexToken
name|ft
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_ANGLE
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|present
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|rtexpr
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|ffelex_set_names_pure
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R10018_
return|;
default|default:
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FORMAT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffestt_formatlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R100118_ -- "[n]X[n].[n]E" OPEN_ANGLE expr     (ffestb_R100118_)  // to expression handler     Handle expression after the "E".  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R100118_
parameter_list|(
name|ffelexToken
name|ft
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_ANGLE
case|:
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|present
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|rtexpr
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|ffelex_set_names_pure
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R100110_
return|;
default|default:
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|exp
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|pre
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|post
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|dot
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FORMAT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffestt_formatlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|format
operator|.
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_S3P4 -- Parse the INCLUDE line     return ffestb_S3P4;	// to lexer     Make sure the statement has a valid form for the INCLUDE line.  If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_S3P4
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
name|ffelexToken
name|ut
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstINCLUDE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
case|case
name|FFELEX_typeAPOSTROPHE
case|:
case|case
name|FFELEX_typeQUOTE
case|:
break|break;
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextINCLUDE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_S3P41_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstINCLUDE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlINCLUDE
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeAPOSTROPHE
case|:
case|case
name|FFELEX_typeQUOTE
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextINCLUDE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_S3P41_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|nt
operator|=
name|ffelex_token_number_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ffelex_token_length
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|i
operator|+=
name|ffelex_token_length
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|!=
literal|'_'
operator|)
operator|||
operator|(
operator|++
name|i
operator|,
operator|*
operator|++
name|p
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ut
operator|=
name|ffelex_token_uscore_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextINCLUDE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_S3P41_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|ut
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ut
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"INCLUDE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"INCLUDE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"INCLUDE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_S3P41_ -- "INCLUDE" [NUMBER "_"] expr     (ffestb_S3P41_)  // to expression handler     Make sure the next token is an EOS, but not a SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_S3P41_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
operator|&&
operator|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeSEMICOLON
operator|)
operator|||
name|ffesta_line_has_semicolons
operator|)
condition|)
block|{
comment|/* xgettext:no-c-format */
name|ffebad_start_msg
argument_list|(
literal|"INCLUDE at %0 not the only statement on the source line"
argument_list|,
name|FFEBAD_severityWARNING
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_S3P4
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"INCLUDE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_V014 -- Parse the VOLATILE statement     return ffestb_V014;	// to lexer     Make sure the statement has a valid form for the VOLATILE statement.	 If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_V014
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstVOLATILE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeSLASH
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V014_start
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_V0141_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V014_start
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_V0141_
return|;
block|}
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstVOLATILE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlVOLATILE
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFELEX_typeSLASH
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V014_start
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_V0141_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V014_start
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_V0141_
return|;
block|}
comment|/* Here, we have at least one char after "VOLATILE" and t is COMMA or 	 EOS/SEMICOLON. */
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|nt
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V014_start
argument_list|()
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_V0141_
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"VOLATILE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"VOLATILE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"VOLATILE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_V0141_ -- "VOLATILE" [COLONCOLON]     return ffestb_V0141_;  // to lexer     Handle NAME or SLASH.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_V0141_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffestb_local_
operator|.
name|V014
operator|.
name|is_cblock
operator|=
name|FALSE
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_V0144_
return|;
case|case
name|FFELEX_typeSLASH
case|:
name|ffestb_local_
operator|.
name|V014
operator|.
name|is_cblock
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_V0142_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"VOLATILE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V014_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_V0142_ -- "VOLATILE" [COLONCOLON] SLASH     return ffestb_V0142_;  // to lexer     Handle NAME.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_V0142_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_V0143_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"VOLATILE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V014_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_V0143_ -- "VOLATILE" [COLONCOLON] SLASH NAME     return ffestb_V0143_;  // to lexer     Handle SLASH.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_V0143_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeSLASH
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_V0144_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"VOLATILE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V014_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_V0144_ -- "VOLATILE" [COLONCOLON] R523     return ffestb_V0144_;  // to lexer     Handle COMMA or EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_V0144_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
name|ffestb_local_
operator|.
name|V014
operator|.
name|is_cblock
condition|)
name|ffestc_V014_item_cblock
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|ffestc_V014_item_object
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_V0141_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
name|ffestb_local_
operator|.
name|V014
operator|.
name|is_cblock
condition|)
name|ffestc_V014_item_cblock
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|ffestc_V014_item_object
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestc_V014_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"VOLATILE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V014_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_subr_kill_easy_ -- Kill I/O statement data structure     ffestb_subr_kill_easy_();     Kills all tokens in the I/O data structure.	Assumes that they are    overlaid with each other (union) in ffest_private.h and the typing    and structure references assume (though not necessarily dangerous if    FALSE) that INQUIRE has the most file elements.  */
end_comment

begin_if
if|#
directive|if
name|FFESTB_KILL_EASY_
end_if

begin_function
specifier|static
name|void
name|ffestb_subr_kill_easy_
parameter_list|(
name|ffestpInquireIx
name|max
parameter_list|)
block|{
name|ffestpInquireIx
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|max
condition|;
operator|++
name|ix
control|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|kw_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|kw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|value_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestb_subr_kill_accept_ -- Kill ACCEPT statement data structure     ffestb_subr_kill_accept_();     Kills all tokens in the ACCEPT data structure.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|FFESTB_KILL_EASY_
end_if

begin_function
specifier|static
name|void
name|ffestb_subr_kill_accept_
parameter_list|(
name|void
parameter_list|)
block|{
name|ffestpAcceptIx
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_acceptix
condition|;
operator|++
name|ix
control|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|accept
operator|.
name|accept_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|accept
operator|.
name|accept_spec
index|[
name|ix
index|]
operator|.
name|kw_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|accept
operator|.
name|accept_spec
index|[
name|ix
index|]
operator|.
name|kw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|accept
operator|.
name|accept_spec
index|[
name|ix
index|]
operator|.
name|value_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|accept
operator|.
name|accept_spec
index|[
name|ix
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestb_subr_kill_beru_ -- Kill BACKSPACE/ENDFILE/REWIND/UNLOCK statement 			    data structure     ffestb_subr_kill_beru_();     Kills all tokens in the BACKSPACE/ENDFILE/REWIND/UNLOCK data structure.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|FFESTB_KILL_EASY_
end_if

begin_function
specifier|static
name|void
name|ffestb_subr_kill_beru_
parameter_list|(
name|void
parameter_list|)
block|{
name|ffestpBeruIx
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_beruix
condition|;
operator|++
name|ix
control|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ix
index|]
operator|.
name|kw_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ix
index|]
operator|.
name|kw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ix
index|]
operator|.
name|value_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ix
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestb_subr_kill_close_ -- Kill CLOSE statement data structure     ffestb_subr_kill_close_();     Kills all tokens in the CLOSE data structure.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|FFESTB_KILL_EASY_
end_if

begin_function
specifier|static
name|void
name|ffestb_subr_kill_close_
parameter_list|(
name|void
parameter_list|)
block|{
name|ffestpCloseIx
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_closeix
condition|;
operator|++
name|ix
control|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ix
index|]
operator|.
name|kw_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ix
index|]
operator|.
name|kw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ix
index|]
operator|.
name|value_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ix
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestb_subr_kill_delete_ -- Kill DELETE statement data structure     ffestb_subr_kill_delete_();     Kills all tokens in the DELETE data structure.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|FFESTB_KILL_EASY_
end_if

begin_function
specifier|static
name|void
name|ffestb_subr_kill_delete_
parameter_list|(
name|void
parameter_list|)
block|{
name|ffestpDeleteIx
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_deleteix
condition|;
operator|++
name|ix
control|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|delete
operator|.
name|delete_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|delete
operator|.
name|delete_spec
index|[
name|ix
index|]
operator|.
name|kw_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|delete
operator|.
name|delete_spec
index|[
name|ix
index|]
operator|.
name|kw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|delete
operator|.
name|delete_spec
index|[
name|ix
index|]
operator|.
name|value_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|delete
operator|.
name|delete_spec
index|[
name|ix
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestb_subr_kill_inquire_ -- Kill INQUIRE statement data structure     ffestb_subr_kill_inquire_();     Kills all tokens in the INQUIRE data structure.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|FFESTB_KILL_EASY_
end_if

begin_function
specifier|static
name|void
name|ffestb_subr_kill_inquire_
parameter_list|(
name|void
parameter_list|)
block|{
name|ffestpInquireIx
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_inquireix
condition|;
operator|++
name|ix
control|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|kw_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|kw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|value_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestb_subr_kill_open_ -- Kill OPEN statement data structure     ffestb_subr_kill_open_();     Kills all tokens in the OPEN data structure.	 */
end_comment

begin_if
if|#
directive|if
operator|!
name|FFESTB_KILL_EASY_
end_if

begin_function
specifier|static
name|void
name|ffestb_subr_kill_open_
parameter_list|(
name|void
parameter_list|)
block|{
name|ffestpOpenIx
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_openix
condition|;
operator|++
name|ix
control|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ix
index|]
operator|.
name|kw_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ix
index|]
operator|.
name|kw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ix
index|]
operator|.
name|value_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ix
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestb_subr_kill_print_ -- Kill PRINT statement data structure     ffestb_subr_kill_print_();     Kills all tokens in the PRINT data structure.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|FFESTB_KILL_EASY_
end_if

begin_function
specifier|static
name|void
name|ffestb_subr_kill_print_
parameter_list|(
name|void
parameter_list|)
block|{
name|ffestpPrintIx
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_printix
condition|;
operator|++
name|ix
control|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|print
operator|.
name|print_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|print
operator|.
name|print_spec
index|[
name|ix
index|]
operator|.
name|kw_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|print
operator|.
name|print_spec
index|[
name|ix
index|]
operator|.
name|kw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|print
operator|.
name|print_spec
index|[
name|ix
index|]
operator|.
name|value_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|print
operator|.
name|print_spec
index|[
name|ix
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestb_subr_kill_read_ -- Kill READ statement data structure     ffestb_subr_kill_read_();     Kills all tokens in the READ data structure.	 */
end_comment

begin_if
if|#
directive|if
operator|!
name|FFESTB_KILL_EASY_
end_if

begin_function
specifier|static
name|void
name|ffestb_subr_kill_read_
parameter_list|(
name|void
parameter_list|)
block|{
name|ffestpReadIx
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_readix
condition|;
operator|++
name|ix
control|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ix
index|]
operator|.
name|kw_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ix
index|]
operator|.
name|kw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ix
index|]
operator|.
name|value_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ix
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestb_subr_kill_rewrite_ -- Kill REWRITE statement data structure     ffestb_subr_kill_rewrite_();     Kills all tokens in the REWRITE data structure.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|FFESTB_KILL_EASY_
end_if

begin_function
specifier|static
name|void
name|ffestb_subr_kill_rewrite_
parameter_list|(
name|void
parameter_list|)
block|{
name|ffestpRewriteIx
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_rewriteix
condition|;
operator|++
name|ix
control|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|rewrite
operator|.
name|rewrite_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|rewrite
operator|.
name|rewrite_spec
index|[
name|ix
index|]
operator|.
name|kw_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|rewrite
operator|.
name|rewrite_spec
index|[
name|ix
index|]
operator|.
name|kw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|rewrite
operator|.
name|rewrite_spec
index|[
name|ix
index|]
operator|.
name|value_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|rewrite
operator|.
name|rewrite_spec
index|[
name|ix
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestb_subr_kill_type_ -- Kill TYPE statement data structure     ffestb_subr_kill_type_();     Kills all tokens in the TYPE data structure.	 */
end_comment

begin_if
if|#
directive|if
operator|!
name|FFESTB_KILL_EASY_
end_if

begin_function
specifier|static
name|void
name|ffestb_subr_kill_type_
parameter_list|(
name|void
parameter_list|)
block|{
name|ffestpTypeIx
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_typeix
condition|;
operator|++
name|ix
control|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|type
operator|.
name|type_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|type
operator|.
name|type_spec
index|[
name|ix
index|]
operator|.
name|kw_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|type
operator|.
name|type_spec
index|[
name|ix
index|]
operator|.
name|kw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|type
operator|.
name|type_spec
index|[
name|ix
index|]
operator|.
name|value_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|type
operator|.
name|type_spec
index|[
name|ix
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestb_subr_kill_write_ -- Kill WRITE statement data structure     ffestb_subr_kill_write_();     Kills all tokens in the WRITE data structure.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|FFESTB_KILL_EASY_
end_if

begin_function
specifier|static
name|void
name|ffestb_subr_kill_write_
parameter_list|(
name|void
parameter_list|)
block|{
name|ffestpWriteIx
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_writeix
condition|;
operator|++
name|ix
control|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ix
index|]
operator|.
name|kw_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ix
index|]
operator|.
name|kw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ix
index|]
operator|.
name|value_present
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ix
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestb_beru -- Parse the BACKSPACE/ENDFILE/REWIND/UNLOCK statement     return ffestb_beru;	// to lexer     Make sure the statement has a valid form for the BACKSPACE/ENDFILE/REWIND/    UNLOCK statement.  If it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_beru
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|ffestpBeruIx
name|ix
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
case|case
name|FFELEX_typeCOLON
case|:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNUMBER
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_beruix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru2_
return|;
default|default:
break|break;
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_beruix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILENUM
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_beru1_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAMES
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
case|case
name|FFELEX_typeCOLON
case|:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|ffestb_args
operator|.
name|beru
operator|.
name|len
condition|)
break|break;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_beruix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru2_
return|;
default|default:
break|break;
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_beruix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILENUM
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_beru1_
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffelex_splice_tokens
argument_list|(
name|next
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|ffestb_args
operator|.
name|beru
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|beru
operator|.
name|badname
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|beru
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_beru1_ -- "BACKSPACE/ENDFILE/REWIND/UNLOCK" expr     (ffestb_beru1_)  // to expression handler     Make sure the next token is an EOS or SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_beru1_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
operator|.
name|kw_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
operator|.
name|value_is_label
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|ffesta_first_kw
condition|)
block|{
case|case
name|FFESTR_firstBACKSPACE
case|:
name|ffestc_R919
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTR_firstENDFILE
case|:
case|case
name|FFESTR_firstEND
case|:
name|ffestc_R920
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTR_firstREWIND
case|:
name|ffestc_R921
argument_list|()
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|ffestb_subr_kill_beru_
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_beru_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|beru
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_beru2_ -- "BACKSPACE/ENDFILE/REWIND/UNLOCK" OPEN_PAREN     return ffestb_beru2_;  // to lexer     Handle expr construct (not NAME=expr construct) here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_beru2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexToken
name|nt
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru3_
return|;
default|default:
name|nt
operator|=
name|ffesta_tokens
index|[
literal|1
index|]
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILENUMAMBIG
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_beru4_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_beru3_ -- "BACKSPACE/ENDFILE/REWIND/UNLOCK" OPEN_PAREN NAME     return ffestb_beru3_;  // to lexer     If EQUALS here, go to states that handle it.	 Else, send NAME and this    token thru expression handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_beru3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
name|ffelexToken
name|ot
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|nt
operator|=
name|ffesta_tokens
index|[
literal|2
index|]
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru5_
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|nt
operator|=
name|ffesta_tokens
index|[
literal|1
index|]
expr_stmt|;
name|ot
operator|=
name|ffesta_tokens
index|[
literal|2
index|]
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILENUMAMBIG
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_beru4_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|ot
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ot
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_beru4_ -- "BACKSPACE/ENDFILE/REWIND/UNLOCK" OPEN_PAREN expr [CLOSE_PAREN]     (ffestb_beru4_)  // to expression handler     Handle COMMA or EOS/SEMICOLON here.     15-Feb-91  JCB  1.2       Now using new mechanism whereby expr comes back as opITEM if the       expr is considered part (or all) of an I/O control list (and should       be stripped of its outer opITEM node) or not if it is considered       a plain unit number that happens to have been enclosed in parens.    26-Mar-90  JCB  1.1       No longer expecting close-paren here because of constructs like       BACKSPACE (5)+2, so now expecting either COMMA because it was a       construct like BACKSPACE (5+2,... or EOS/SEMICOLON because it is like       the former construct.  Ah, the vagaries of Fortran.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_beru4_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|bool
name|inlist
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opITEM
condition|)
block|{
name|inlist
operator|=
name|TRUE
expr_stmt|;
name|expr
operator|=
name|ffebld_head
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
name|inlist
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
operator|.
name|kw_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
operator|.
name|value_is_label
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|inlist
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru9_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru10_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_beru_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|beru
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_beru5_ -- "BACKSPACE/ENDFILE/REWIND/UNLOCK" OPEN_PAREN [external-file-unit 		    COMMA]     return ffestb_beru5_;  // to lexer     Handle expr construct (not NAME=expr construct) here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_beru5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestrGenio
name|kw
decl_stmt|;
name|ffestb_local_
operator|.
name|beru
operator|.
name|label
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|kw
operator|=
name|ffestr_genio
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kw
condition|)
block|{
case|case
name|FFESTR_genioERR
case|:
name|ffestb_local_
operator|.
name|beru
operator|.
name|ix
operator|=
name|FFESTP_beruixERR
expr_stmt|;
name|ffestb_local_
operator|.
name|beru
operator|.
name|label
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTR_genioIOSTAT
case|:
name|ffestb_local_
operator|.
name|beru
operator|.
name|ix
operator|=
name|FFESTP_beruixIOSTAT
expr_stmt|;
name|ffestb_local_
operator|.
name|beru
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|beru
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEINT
expr_stmt|;
break|break;
case|case
name|FFESTR_genioUNIT
case|:
name|ffestb_local_
operator|.
name|beru
operator|.
name|ix
operator|=
name|FFESTP_beruixUNIT
expr_stmt|;
name|ffestb_local_
operator|.
name|beru
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|beru
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUM
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ffestb_local_
operator|.
name|beru
operator|.
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
break|break;
comment|/* Can't specify a keyword twice! */
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ffestb_local_
operator|.
name|beru
operator|.
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ffestb_local_
operator|.
name|beru
operator|.
name|ix
index|]
operator|.
name|kw_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ffestb_local_
operator|.
name|beru
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ffestb_local_
operator|.
name|beru
operator|.
name|ix
index|]
operator|.
name|value_is_label
operator|=
name|ffestb_local_
operator|.
name|beru
operator|.
name|label
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ffestb_local_
operator|.
name|beru
operator|.
name|ix
index|]
operator|.
name|kw
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru6_
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffestb_subr_kill_beru_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|beru
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_beru6_ -- "BACKSPACE/ENDFILE/REWIND/UNLOCK" OPEN_PAREN [external-file-unit 		    COMMA] NAME     return ffestb_beru6_;  // to lexer     Make sure EQUALS here, send next token to expression handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_beru6_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|beru
operator|.
name|label
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru8_
return|;
if|if
condition|(
name|ffestb_local_
operator|.
name|beru
operator|.
name|left
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestb_local_
operator|.
name|beru
operator|.
name|context
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_beru7_
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestb_local_
operator|.
name|beru
operator|.
name|context
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_beru7_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_beru_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|beru
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_beru7_ -- "BACKSPACE/ENDFILE/REWIND/UNLOCK" OPEN_PAREN ... NAME EQUALS expr     (ffestb_beru7_)  // to expression handler     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_beru7_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ffestb_local_
operator|.
name|beru
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ffestb_local_
operator|.
name|beru
operator|.
name|ix
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ffestb_local_
operator|.
name|beru
operator|.
name|ix
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru5_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru10_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_beru_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|beru
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_beru8_ -- "BACKSPACE/ENDFILE/REWIND/UNLOCK" OPEN_PAREN ... NAME EQUALS     return ffestb_beru8_;  // to lexer     Handle NUMBER for label here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_beru8_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ffestb_local_
operator|.
name|beru
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|ffestb_local_
operator|.
name|beru
operator|.
name|ix
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru9_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_beru_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|beru
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_beru9_ -- "BACKSPACE/ENDFILE/REWIND/UNLOCK" OPEN_PAREN ... NAME EQUALS 		   NUMBER     return ffestb_beru9_;  // to lexer     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_beru9_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru5_
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_beru10_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_beru_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|beru
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_beru10_ -- "BACKSPACE/ENDFILE/REWIND/UNLOCK" OPEN_PAREN ... CLOSE_PAREN     return ffestb_beru10_;  // to lexer     Handle EOS or SEMICOLON here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_beru10_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|ffesta_first_kw
condition|)
block|{
case|case
name|FFESTR_firstBACKSPACE
case|:
name|ffestc_R919
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTR_firstENDFILE
case|:
case|case
name|FFESTR_firstEND
case|:
name|ffestc_R920
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTR_firstREWIND
case|:
name|ffestc_R921
argument_list|()
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|ffestb_subr_kill_beru_
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_beru_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|beru
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R904 -- Parse an OPEN statement     return ffestb_R904;	// to lexer     Make sure the statement has a valid form for an OPEN statement.    If it does, implement the statement.	 */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R904
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestpOpenIx
name|ix
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstOPEN
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstOPEN
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlOPEN
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_openix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9041_
return|;
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"OPEN"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"OPEN"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_R9041_ -- "OPEN" OPEN_PAREN     return ffestb_R9041_;  // to lexer     Handle expr construct (not NAME=expr construct) here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9041_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9042_
return|;
default|default:
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILENUM
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9043_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R9042_ -- "OPEN" OPEN_PAREN NAME     return ffestb_R9042_;  // to lexer     If EQUALS here, go to states that handle it.	 Else, send NAME and this    token thru expression handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9042_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|nt
operator|=
name|ffesta_tokens
index|[
literal|1
index|]
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9044_
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILENUM
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9043_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R9043_ -- "OPEN" OPEN_PAREN expr     (ffestb_R9043_)  // to expression handler     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9043_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixUNIT
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixUNIT
index|]
operator|.
name|kw_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixUNIT
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixUNIT
index|]
operator|.
name|value_is_label
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixUNIT
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixUNIT
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9044_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9049_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_open_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"OPEN"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9044_ -- "OPEN" OPEN_PAREN [external-file-unit COMMA]     return ffestb_R9044_;  // to lexer     Handle expr construct (not NAME=expr construct) here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9044_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestrOpen
name|kw
decl_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|label
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|kw
operator|=
name|ffestr_open
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kw
condition|)
block|{
case|case
name|FFESTR_openACCESS
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixACCESS
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_openACTION
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixACTION
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_openASSOCIATEVARIABLE
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixASSOCIATEVARIABLE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEASSOC
expr_stmt|;
break|break;
case|case
name|FFESTR_openBLANK
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixBLANK
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_openBLOCKSIZE
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixBLOCKSIZE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUM
expr_stmt|;
break|break;
case|case
name|FFESTR_openBUFFERCOUNT
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixBUFFERCOUNT
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUM
expr_stmt|;
break|break;
case|case
name|FFESTR_openCARRIAGECONTROL
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixCARRIAGECONTROL
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILECHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_openDEFAULTFILE
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixDEFAULTFILE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILECHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_openDELIM
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixDELIM
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_openDISP
case|:
case|case
name|FFESTR_openDISPOSE
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixDISPOSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILECHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_openERR
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixERR
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|label
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTR_openEXTENDSIZE
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixEXTENDSIZE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUM
expr_stmt|;
break|break;
case|case
name|FFESTR_openFILE
case|:
case|case
name|FFESTR_openNAME
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixFILE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILECHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_openFORM
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixFORM
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_openINITIALSIZE
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixINITIALSIZE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUM
expr_stmt|;
break|break;
case|case
name|FFESTR_openIOSTAT
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixIOSTAT
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEINT
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* Haven't added support for expression 				   context yet (though easy). */
block|case FFESTR_openKEY: 	  ffestb_local_.open.ix = FFESTP_openixKEY; 	  ffestb_local_.open.left = FALSE; 	  ffestb_local_.open.context = FFEEXPR_contextFILEKEY; 	  break;
endif|#
directive|endif
case|case
name|FFESTR_openMAXREC
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixMAXREC
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUM
expr_stmt|;
break|break;
case|case
name|FFESTR_openNOSPANBLOCKS
case|:
if|if
condition|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixNOSPANBLOCKS
index|]
operator|.
name|kw_or_val_present
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixNOSPANBLOCKS
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixNOSPANBLOCKS
index|]
operator|.
name|kw_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixNOSPANBLOCKS
index|]
operator|.
name|value_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixNOSPANBLOCKS
index|]
operator|.
name|kw
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9048_
return|;
case|case
name|FFESTR_openORGANIZATION
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixORGANIZATION
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILECHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_openPAD
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixPAD
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_openPOSITION
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixPOSITION
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_openREADONLY
case|:
if|if
condition|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixREADONLY
index|]
operator|.
name|kw_or_val_present
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixREADONLY
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixREADONLY
index|]
operator|.
name|kw_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixREADONLY
index|]
operator|.
name|value_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixREADONLY
index|]
operator|.
name|kw
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9048_
return|;
case|case
name|FFESTR_openRECL
case|:
case|case
name|FFESTR_openRECORDSIZE
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixRECL
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUM
expr_stmt|;
break|break;
case|case
name|FFESTR_openRECORDTYPE
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixRECORDTYPE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILECHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_openSHARED
case|:
if|if
condition|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSHARED
index|]
operator|.
name|kw_or_val_present
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSHARED
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSHARED
index|]
operator|.
name|kw_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSHARED
index|]
operator|.
name|value_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSHARED
index|]
operator|.
name|kw
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9048_
return|;
case|case
name|FFESTR_openSTATUS
case|:
case|case
name|FFESTR_openTYPE
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixSTATUS
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_openUNIT
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixUNIT
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUM
expr_stmt|;
break|break;
case|case
name|FFESTR_openUSEROPEN
case|:
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
operator|=
name|FFESTP_openixUSEROPEN
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|open
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEEXTFUNC
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
break|break;
comment|/* Can't specify a keyword twice! */
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
index|]
operator|.
name|kw_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
index|]
operator|.
name|value_is_label
operator|=
name|ffestb_local_
operator|.
name|open
operator|.
name|label
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
index|]
operator|.
name|kw
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9045_
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffestb_subr_kill_open_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"OPEN"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9045_ -- "OPEN" OPEN_PAREN [external-file-unit COMMA] NAME     return ffestb_R9045_;  // to lexer     Make sure EQUALS here, send next token to expression handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9045_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|open
operator|.
name|label
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9047_
return|;
if|if
condition|(
name|ffestb_local_
operator|.
name|open
operator|.
name|left
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestb_local_
operator|.
name|open
operator|.
name|context
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9046_
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestb_local_
operator|.
name|open
operator|.
name|context
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9046_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_open_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"OPEN"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9046_ -- "OPEN" OPEN_PAREN ... NAME EQUALS expr     (ffestb_R9046_)  // to expression handler     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9046_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9044_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9049_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_open_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"OPEN"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9047_ -- "OPEN" OPEN_PAREN ... NAME EQUALS     return ffestb_R9047_;  // to lexer     Handle NUMBER for label here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9047_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|ffestb_local_
operator|.
name|open
operator|.
name|ix
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9048_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_open_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"OPEN"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9048_ -- "OPEN" OPEN_PAREN ... NAME EQUALS NUMBER     return ffestb_R9048_;  // to lexer     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9048_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9044_
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9049_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_open_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"OPEN"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9049_ -- "OPEN" OPEN_PAREN ... CLOSE_PAREN     return ffestb_R9049_;  // to lexer     Handle EOS or SEMICOLON here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9049_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R904
argument_list|()
expr_stmt|;
name|ffestb_subr_kill_open_
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_open_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"OPEN"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R907 -- Parse a CLOSE statement     return ffestb_R907;	// to lexer     Make sure the statement has a valid form for a CLOSE statement.    If it does, implement the statement.	 */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R907
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestpCloseIx
name|ix
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstCLOSE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstCLOSE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlCLOSE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_closeix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9071_
return|;
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CLOSE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CLOSE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_R9071_ -- "CLOSE" OPEN_PAREN     return ffestb_R9071_;  // to lexer     Handle expr construct (not NAME=expr construct) here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9071_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9072_
return|;
default|default:
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILENUM
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9073_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R9072_ -- "CLOSE" OPEN_PAREN NAME     return ffestb_R9072_;  // to lexer     If EQUALS here, go to states that handle it.	 Else, send NAME and this    token thru expression handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9072_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|nt
operator|=
name|ffesta_tokens
index|[
literal|1
index|]
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9074_
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILENUM
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9073_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R9073_ -- "CLOSE" OPEN_PAREN expr     (ffestb_R9073_)  // to expression handler     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9073_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|FFESTP_closeixUNIT
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|FFESTP_closeixUNIT
index|]
operator|.
name|kw_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|FFESTP_closeixUNIT
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|FFESTP_closeixUNIT
index|]
operator|.
name|value_is_label
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|FFESTP_closeixUNIT
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|FFESTP_closeixUNIT
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9074_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9079_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_close_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CLOSE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9074_ -- "CLOSE" OPEN_PAREN [external-file-unit COMMA]     return ffestb_R9074_;  // to lexer     Handle expr construct (not NAME=expr construct) here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9074_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestrGenio
name|kw
decl_stmt|;
name|ffestb_local_
operator|.
name|close
operator|.
name|label
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|kw
operator|=
name|ffestr_genio
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kw
condition|)
block|{
case|case
name|FFESTR_genioERR
case|:
name|ffestb_local_
operator|.
name|close
operator|.
name|ix
operator|=
name|FFESTP_closeixERR
expr_stmt|;
name|ffestb_local_
operator|.
name|close
operator|.
name|label
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTR_genioIOSTAT
case|:
name|ffestb_local_
operator|.
name|close
operator|.
name|ix
operator|=
name|FFESTP_closeixIOSTAT
expr_stmt|;
name|ffestb_local_
operator|.
name|close
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|close
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEINT
expr_stmt|;
break|break;
case|case
name|FFESTR_genioSTATUS
case|:
case|case
name|FFESTR_genioDISP
case|:
case|case
name|FFESTR_genioDISPOSE
case|:
name|ffestb_local_
operator|.
name|close
operator|.
name|ix
operator|=
name|FFESTP_closeixSTATUS
expr_stmt|;
name|ffestb_local_
operator|.
name|close
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|close
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_genioUNIT
case|:
name|ffestb_local_
operator|.
name|close
operator|.
name|ix
operator|=
name|FFESTP_closeixUNIT
expr_stmt|;
name|ffestb_local_
operator|.
name|close
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|close
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUM
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ffestb_local_
operator|.
name|close
operator|.
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
break|break;
comment|/* Can't specify a keyword twice! */
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ffestb_local_
operator|.
name|close
operator|.
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ffestb_local_
operator|.
name|close
operator|.
name|ix
index|]
operator|.
name|kw_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ffestb_local_
operator|.
name|close
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ffestb_local_
operator|.
name|close
operator|.
name|ix
index|]
operator|.
name|value_is_label
operator|=
name|ffestb_local_
operator|.
name|close
operator|.
name|label
expr_stmt|;
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ffestb_local_
operator|.
name|close
operator|.
name|ix
index|]
operator|.
name|kw
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9075_
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffestb_subr_kill_close_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CLOSE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9075_ -- "CLOSE" OPEN_PAREN [external-file-unit COMMA] NAME     return ffestb_R9075_;  // to lexer     Make sure EQUALS here, send next token to expression handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9075_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|close
operator|.
name|label
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9077_
return|;
if|if
condition|(
name|ffestb_local_
operator|.
name|close
operator|.
name|left
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestb_local_
operator|.
name|close
operator|.
name|context
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9076_
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestb_local_
operator|.
name|close
operator|.
name|context
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9076_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_close_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CLOSE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9076_ -- "CLOSE" OPEN_PAREN ... NAME EQUALS expr     (ffestb_R9076_)  // to expression handler     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9076_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ffestb_local_
operator|.
name|close
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ffestb_local_
operator|.
name|close
operator|.
name|ix
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ffestb_local_
operator|.
name|close
operator|.
name|ix
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9074_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9079_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_close_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CLOSE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9077_ -- "CLOSE" OPEN_PAREN ... NAME EQUALS     return ffestb_R9077_;  // to lexer     Handle NUMBER for label here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9077_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ffestb_local_
operator|.
name|close
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|ffestb_local_
operator|.
name|close
operator|.
name|ix
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9078_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_close_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CLOSE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9078_ -- "CLOSE" OPEN_PAREN ... NAME EQUALS NUMBER     return ffestb_R9078_;  // to lexer     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9078_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9074_
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9079_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_close_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CLOSE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9079_ -- "CLOSE" OPEN_PAREN ... CLOSE_PAREN     return ffestb_R9079_;  // to lexer     Handle EOS or SEMICOLON here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9079_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R907
argument_list|()
expr_stmt|;
name|ffestb_subr_kill_close_
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_close_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"CLOSE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R909 -- Parse the READ statement     return ffestb_R909;	// to lexer     Make sure the statement has a valid form for the READ    statement.  If it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R909
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|ffestpReadIx
name|ix
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstREAD
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
case|case
name|FFELEX_typeCOLON
case|:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNUMBER
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_readix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9092_
return|;
default|default:
break|break;
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_readix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILEFORMATNML
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9091_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstREAD
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlREAD
condition|)
break|break;
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
case|case
name|FFELEX_typeCOLON
case|:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlREAD
condition|)
break|break;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_readix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9092_
return|;
default|default:
break|break;
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_readix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILEFORMATNML
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9091_
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffelex_splice_tokens
argument_list|(
name|next
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|FFESTR_firstlREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"READ"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"READ"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_R9091_ -- "READ" expr     (ffestb_R9091_)  // to expression handler     Make sure the next token is a COMMA or EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9091_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|kw_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|value_is_label
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R909_start
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestb_subr_kill_read_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestc_context_iolist
argument_list|()
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R90915_
argument_list|)
return|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R909_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_read_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"READ"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9092_ -- "READ" OPEN_PAREN     return ffestb_R9092_;  // to lexer     Handle expr construct (not NAME=expr construct) here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9092_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexToken
name|nt
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9093_
return|;
default|default:
name|nt
operator|=
name|ffesta_tokens
index|[
literal|1
index|]
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILEUNITAMBIG
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9094_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R9093_ -- "READ" OPEN_PAREN NAME     return ffestb_R9093_;  // to lexer     If EQUALS here, go to states that handle it.	 Else, send NAME and this    token thru expression handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9093_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
name|ffelexToken
name|ot
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|nt
operator|=
name|ffesta_tokens
index|[
literal|2
index|]
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9098_
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|nt
operator|=
name|ffesta_tokens
index|[
literal|1
index|]
expr_stmt|;
name|ot
operator|=
name|ffesta_tokens
index|[
literal|2
index|]
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILEUNITAMBIG
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9094_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|ot
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ot
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R9094_ -- "READ" OPEN_PAREN expr [CLOSE_PAREN]     (ffestb_R9094_)  // to expression handler     Handle COMMA or EOS/SEMICOLON here.     15-Feb-91  JCB  1.1       Use new ffeexpr mechanism whereby the expr is encased in an opITEM if       ffeexpr decided it was an item in a control list (hence a unit       specifier), or a format specifier otherwise.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9094_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opITEM
condition|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|kw_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|value_is_label
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R909_start
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestb_subr_kill_read_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestc_context_iolist
argument_list|()
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R90915_
argument_list|)
return|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R909_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
name|expr
operator|=
name|ffebld_head
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixUNIT
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixUNIT
index|]
operator|.
name|kw_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixUNIT
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixUNIT
index|]
operator|.
name|value_is_label
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixUNIT
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixUNIT
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9095_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R90913_
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffestb_subr_kill_read_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"READ"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9095_ -- "READ" OPEN_PAREN expr COMMA     return ffestb_R9095_;  // to lexer     Handle expr construct (not NAME=expr construct) here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9095_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9096_
return|;
default|default:
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILEFORMATNML
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9097_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R9096_ -- "READ" OPEN_PAREN expr COMMA NAME     return ffestb_R9096_;  // to lexer     If EQUALS here, go to states that handle it.	 Else, send NAME and this    token thru expression handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9096_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|nt
operator|=
name|ffesta_tokens
index|[
literal|1
index|]
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9098_
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|nt
operator|=
name|ffesta_tokens
index|[
literal|1
index|]
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILEFORMATNML
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9097_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R9097_ -- "READ" OPEN_PAREN expr COMMA expr     (ffestb_R9097_)  // to expression handler     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9097_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|kw_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|value_is_label
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9098_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R90913_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_read_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"READ"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9098_ -- "READ" OPEN_PAREN [external-file-unit COMMA [format 		   COMMA]]     return ffestb_R9098_;  // to lexer     Handle expr construct (not NAME=expr construct) here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9098_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestrGenio
name|kw
decl_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|label
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|kw
operator|=
name|ffestr_genio
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kw
condition|)
block|{
case|case
name|FFESTR_genioADVANCE
case|:
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
operator|=
name|FFESTP_readixADVANCE
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_genioEOR
case|:
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
operator|=
name|FFESTP_readixEOR
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|label
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTR_genioERR
case|:
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
operator|=
name|FFESTP_readixERR
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|label
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTR_genioEND
case|:
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
operator|=
name|FFESTP_readixEND
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|label
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTR_genioFMT
case|:
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
operator|=
name|FFESTP_readixFORMAT
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEFORMAT
expr_stmt|;
break|break;
case|case
name|FFESTR_genioIOSTAT
case|:
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
operator|=
name|FFESTP_readixIOSTAT
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEINT
expr_stmt|;
break|break;
case|case
name|FFESTR_genioKEY
case|:
case|case
name|FFESTR_genioKEYEQ
case|:
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
operator|=
name|FFESTP_readixKEYEQ
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUMCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_genioKEYGE
case|:
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
operator|=
name|FFESTP_readixKEYGE
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUMCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_genioKEYGT
case|:
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
operator|=
name|FFESTP_readixKEYGT
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUMCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_genioKEYID
case|:
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
operator|=
name|FFESTP_readixKEYID
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUM
expr_stmt|;
break|break;
case|case
name|FFESTR_genioNML
case|:
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
operator|=
name|FFESTP_readixFORMAT
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENAMELIST
expr_stmt|;
break|break;
case|case
name|FFESTR_genioNULLS
case|:
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
operator|=
name|FFESTP_readixNULLS
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEINT
expr_stmt|;
break|break;
case|case
name|FFESTR_genioREC
case|:
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
operator|=
name|FFESTP_readixREC
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUM
expr_stmt|;
break|break;
case|case
name|FFESTR_genioSIZE
case|:
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
operator|=
name|FFESTP_readixSIZE
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEINT
expr_stmt|;
break|break;
case|case
name|FFESTR_genioUNIT
case|:
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
operator|=
name|FFESTP_readixUNIT
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|read
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEUNIT
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
break|break;
comment|/* Can't specify a keyword twice! */
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
index|]
operator|.
name|kw_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
index|]
operator|.
name|value_is_label
operator|=
name|ffestb_local_
operator|.
name|read
operator|.
name|label
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
index|]
operator|.
name|kw
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9099_
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffestb_subr_kill_read_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"READ"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9099_ -- "READ" OPEN_PAREN [external-file-unit COMMA [format 		   COMMA]] NAME     return ffestb_R9099_;  // to lexer     Make sure EQUALS here, send next token to expression handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9099_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|read
operator|.
name|label
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R90911_
return|;
if|if
condition|(
name|ffestb_local_
operator|.
name|read
operator|.
name|left
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestb_local_
operator|.
name|read
operator|.
name|context
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R90910_
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestb_local_
operator|.
name|read
operator|.
name|context
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R90910_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_read_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"READ"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R90910_ -- "READ" OPEN_PAREN ... NAME EQUALS expr     (ffestb_R90910_)  // to expression handler     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R90910_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ffestb_local_
operator|.
name|read
operator|.
name|context
operator|==
name|FFEEXPR_contextFILEFORMAT
condition|)
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
index|]
operator|.
name|value_is_label
operator|=
name|TRUE
expr_stmt|;
else|else
break|break;
block|}
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9098_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R90913_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_read_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"READ"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R90911_ -- "READ" OPEN_PAREN ... NAME EQUALS     return ffestb_R90911_;  // to lexer     Handle NUMBER for label here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R90911_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|ffestb_local_
operator|.
name|read
operator|.
name|ix
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R90912_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_read_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"READ"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R90912_ -- "READ" OPEN_PAREN ... NAME EQUALS NUMBER     return ffestb_R90912_;  // to lexer     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R90912_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9098_
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R90913_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_read_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"READ"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R90913_ -- "READ" OPEN_PAREN ... CLOSE_PAREN     return ffestb_R90913_;  // to lexer     Handle EOS or SEMICOLON here.     15-Feb-91  JCB  1.1       Fix to allow implied-DO construct here (OPEN_PAREN) -- actually,       don't presume knowledge of what an initial token in an lhs context       is going to be, let ffeexpr_lhs handle that as much as possible.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R90913_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_R909_start
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|ffestc_R909_finish
argument_list|()
expr_stmt|;
block|}
name|ffestb_subr_kill_read_
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
comment|/* Could still be assignment!! */
break|break;
block|}
comment|/* If token isn't NAME or OPEN_PAREN, ffeexpr_lhs will ultimately whine      about it, so leave it up to that code. */
comment|/* EXTENSION: Allow an optional preceding COMMA here if not pedantic.	 (f2c      provides this extension, as do other compilers, supposedly.) */
if|if
condition|(
operator|!
name|ffe_is_pedantic
argument_list|()
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
operator|)
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestc_context_iolist
argument_list|()
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R90914_
argument_list|)
return|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestc_context_iolist
argument_list|()
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R90914_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R90914_ -- "READ(...)" expr     (ffestb_R90914_)  // to expression handler     Handle COMMA or EOS/SEMICOLON here.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R90914_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R909_start
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|ffestb_subr_kill_read_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R909_item
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestc_context_iolist
argument_list|()
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R90915_
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R909_start
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|ffestb_subr_kill_read_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_R909_item
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffestc_R909_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_read_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"READ"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R90915_ -- "READ(...)" expr COMMA expr     (ffestb_R90915_)  // to expression handler     Handle COMMA or EOS/SEMICOLON here.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R90915_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R909_item
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestc_context_iolist
argument_list|()
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R90915_
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_R909_item
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffestc_R909_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R909_finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"READ"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R910 -- Parse the WRITE statement     return ffestb_R910;	// to lexer     Make sure the statement has a valid form for the WRITE    statement.  If it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R910
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestpWriteIx
name|ix
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstWRITE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNUMBER
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_writeix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9101_
return|;
block|}
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstWRITE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlWRITE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_writeix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9101_
return|;
block|}
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"WRITE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"WRITE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_R9101_ -- "WRITE" OPEN_PAREN     return ffestb_R9101_;  // to lexer     Handle expr construct (not NAME=expr construct) here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9101_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9102_
return|;
default|default:
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILEUNIT
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9103_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R9102_ -- "WRITE" OPEN_PAREN NAME     return ffestb_R9102_;  // to lexer     If EQUALS here, go to states that handle it.	 Else, send NAME and this    token thru expression handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9102_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|nt
operator|=
name|ffesta_tokens
index|[
literal|1
index|]
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9107_
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|nt
operator|=
name|ffesta_tokens
index|[
literal|1
index|]
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILEUNIT
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9103_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R9103_ -- "WRITE" OPEN_PAREN expr [CLOSE_PAREN]     (ffestb_R9103_)  // to expression handler     Handle COMMA or EOS/SEMICOLON here.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9103_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixUNIT
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixUNIT
index|]
operator|.
name|kw_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixUNIT
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixUNIT
index|]
operator|.
name|value_is_label
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixUNIT
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixUNIT
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9104_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R91012_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_write_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"WRITE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9104_ -- "WRITE" OPEN_PAREN expr COMMA     return ffestb_R9104_;  // to lexer     Handle expr construct (not NAME=expr construct) here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9104_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9105_
return|;
default|default:
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILEFORMATNML
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9106_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R9105_ -- "WRITE" OPEN_PAREN expr COMMA NAME     return ffestb_R9105_;  // to lexer     If EQUALS here, go to states that handle it.	 Else, send NAME and this    token thru expression handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9105_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|nt
operator|=
name|ffesta_tokens
index|[
literal|1
index|]
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9107_
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|nt
operator|=
name|ffesta_tokens
index|[
literal|1
index|]
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILEFORMATNML
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9106_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R9106_ -- "WRITE" OPEN_PAREN expr COMMA expr     (ffestb_R9106_)  // to expression handler     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9106_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixFORMAT
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixFORMAT
index|]
operator|.
name|kw_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixFORMAT
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixFORMAT
index|]
operator|.
name|value_is_label
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixFORMAT
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixFORMAT
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9107_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R91012_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_write_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"WRITE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9107_ -- "WRITE" OPEN_PAREN [external-file-unit COMMA [format 		   COMMA]]     return ffestb_R9107_;  // to lexer     Handle expr construct (not NAME=expr construct) here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9107_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestrGenio
name|kw
decl_stmt|;
name|ffestb_local_
operator|.
name|write
operator|.
name|label
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|kw
operator|=
name|ffestr_genio
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kw
condition|)
block|{
case|case
name|FFESTR_genioADVANCE
case|:
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
operator|=
name|FFESTP_writeixADVANCE
expr_stmt|;
name|ffestb_local_
operator|.
name|write
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|write
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_genioEOR
case|:
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
operator|=
name|FFESTP_writeixEOR
expr_stmt|;
name|ffestb_local_
operator|.
name|write
operator|.
name|label
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTR_genioERR
case|:
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
operator|=
name|FFESTP_writeixERR
expr_stmt|;
name|ffestb_local_
operator|.
name|write
operator|.
name|label
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTR_genioFMT
case|:
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
operator|=
name|FFESTP_writeixFORMAT
expr_stmt|;
name|ffestb_local_
operator|.
name|write
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|write
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEFORMAT
expr_stmt|;
break|break;
case|case
name|FFESTR_genioIOSTAT
case|:
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
operator|=
name|FFESTP_writeixIOSTAT
expr_stmt|;
name|ffestb_local_
operator|.
name|write
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|write
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEINT
expr_stmt|;
break|break;
case|case
name|FFESTR_genioNML
case|:
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
operator|=
name|FFESTP_writeixFORMAT
expr_stmt|;
name|ffestb_local_
operator|.
name|write
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|write
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENAMELIST
expr_stmt|;
break|break;
case|case
name|FFESTR_genioREC
case|:
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
operator|=
name|FFESTP_writeixREC
expr_stmt|;
name|ffestb_local_
operator|.
name|write
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|write
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUM
expr_stmt|;
break|break;
case|case
name|FFESTR_genioUNIT
case|:
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
operator|=
name|FFESTP_writeixUNIT
expr_stmt|;
name|ffestb_local_
operator|.
name|write
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|write
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEUNIT
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
break|break;
comment|/* Can't specify a keyword twice! */
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
index|]
operator|.
name|kw_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
index|]
operator|.
name|value_is_label
operator|=
name|ffestb_local_
operator|.
name|write
operator|.
name|label
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
index|]
operator|.
name|kw
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9108_
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffestb_subr_kill_write_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"WRITE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9108_ -- "WRITE" OPEN_PAREN [external-file-unit COMMA [format 		   COMMA]] NAME     return ffestb_R9108_;  // to lexer     Make sure EQUALS here, send next token to expression handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9108_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|write
operator|.
name|label
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R91010_
return|;
if|if
condition|(
name|ffestb_local_
operator|.
name|write
operator|.
name|left
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestb_local_
operator|.
name|write
operator|.
name|context
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9109_
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestb_local_
operator|.
name|write
operator|.
name|context
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9109_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_write_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"WRITE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9109_ -- "WRITE" OPEN_PAREN ... NAME EQUALS expr     (ffestb_R9109_)  // to expression handler     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9109_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ffestb_local_
operator|.
name|write
operator|.
name|context
operator|==
name|FFEEXPR_contextFILEFORMAT
condition|)
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
index|]
operator|.
name|value_is_label
operator|=
name|TRUE
expr_stmt|;
else|else
break|break;
block|}
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9107_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R91012_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_write_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"WRITE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R91010_ -- "WRITE" OPEN_PAREN ... NAME EQUALS     return ffestb_R91010_;  // to lexer     Handle NUMBER for label here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R91010_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|ffestb_local_
operator|.
name|write
operator|.
name|ix
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R91011_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_write_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"WRITE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R91011_ -- "WRITE" OPEN_PAREN ... NAME EQUALS NUMBER     return ffestb_R91011_;  // to lexer     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R91011_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9107_
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R91012_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_write_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"WRITE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R91012_ -- "WRITE" OPEN_PAREN ... CLOSE_PAREN     return ffestb_R91012_;  // to lexer     Handle EOS or SEMICOLON here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R91012_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_R910_start
argument_list|()
expr_stmt|;
name|ffestc_R910_finish
argument_list|()
expr_stmt|;
block|}
name|ffestb_subr_kill_write_
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
comment|/* Could still be assignment!! */
comment|/* EXTENSION: Allow an optional preceding COMMA here if not pedantic. 	 (f2c provides this extension, as do other compilers, supposedly.) */
if|if
condition|(
operator|!
name|ffe_is_pedantic
argument_list|()
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
operator|)
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestc_context_iolist
argument_list|()
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R91013_
argument_list|)
return|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestc_context_iolist
argument_list|()
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R91013_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
break|break;
block|}
name|ffestb_subr_kill_write_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"WRITE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R91013_ -- "WRITE(...)" expr     (ffestb_R91013_)  // to expression handler     Handle COMMA or EOS/SEMICOLON here.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R91013_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R910_start
argument_list|()
expr_stmt|;
name|ffestb_subr_kill_write_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R910_item
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestc_context_iolist
argument_list|()
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R91014_
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R910_start
argument_list|()
expr_stmt|;
name|ffestb_subr_kill_write_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_R910_item
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffestc_R910_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_write_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"WRITE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R91014_ -- "WRITE(...)" expr COMMA expr     (ffestb_R91014_)  // to expression handler     Handle COMMA or EOS/SEMICOLON here.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R91014_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R910_item
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestc_context_iolist
argument_list|()
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R91014_
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_R910_item
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffestc_R910_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R910_finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"WRITE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R911 -- Parse the PRINT statement     return ffestb_R911;	// to lexer     Make sure the statement has a valid form for the PRINT    statement.  If it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R911
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|ffestpPrintIx
name|ix
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstPRINT
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
case|case
name|FFELEX_typeCOLON
case|:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNUMBER
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_printix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|print
operator|.
name|print_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILEFORMATNML
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9111_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstPRINT
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlPRINT
condition|)
break|break;
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
case|case
name|FFELEX_typeCOLON
case|:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
break|break;
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_printix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|print
operator|.
name|print_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILEFORMATNML
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9111_
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffelex_splice_tokens
argument_list|(
name|next
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|FFESTR_firstlPRINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PRINT"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PRINT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_R9111_ -- "PRINT" expr     (ffestb_R9111_)  // to expression handler     Make sure the next token is a COMMA or EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9111_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestp_file
operator|.
name|print
operator|.
name|print_spec
index|[
name|FFESTP_printixFORMAT
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|print
operator|.
name|print_spec
index|[
name|FFESTP_printixFORMAT
index|]
operator|.
name|kw_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|print
operator|.
name|print_spec
index|[
name|FFESTP_printixFORMAT
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|print
operator|.
name|print_spec
index|[
name|FFESTP_printixFORMAT
index|]
operator|.
name|value_is_label
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
expr_stmt|;
name|ffestp_file
operator|.
name|print
operator|.
name|print_spec
index|[
name|FFESTP_printixFORMAT
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|print
operator|.
name|print_spec
index|[
name|FFESTP_printixFORMAT
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R911_start
argument_list|()
expr_stmt|;
name|ffestb_subr_kill_print_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextIOLIST
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9112_
argument_list|)
return|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R911_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_print_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PRINT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9112_ -- "PRINT" expr COMMA expr     (ffestb_R9112_)  // to expression handler     Handle COMMA or EOS/SEMICOLON here.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9112_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R911_item
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextIOLIST
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9112_
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_R911_item
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffestc_R911_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R911_finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PRINT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R923 -- Parse an INQUIRE statement     return ffestb_R923;	// to lexer     Make sure the statement has a valid form for an INQUIRE statement.    If it does, implement the statement.	 */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R923
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestpInquireIx
name|ix
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstINQUIRE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstINQUIRE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlINQUIRE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
break|break;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_inquireix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|may_be_iolength
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9231_
return|;
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"INQUIRE"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"INQUIRE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_R9231_ -- "INQUIRE" OPEN_PAREN     return ffestb_R9231_;  // to lexer     Handle expr construct (not NAME=expr construct) here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9231_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9232_
return|;
default|default:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|may_be_iolength
operator|=
name|FALSE
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILENUM
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9233_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R9232_ -- "INQUIRE" OPEN_PAREN NAME     return ffestb_R9232_;  // to lexer     If EQUALS here, go to states that handle it.	 Else, send NAME and this    token thru expression handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9232_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|nt
operator|=
name|ffesta_tokens
index|[
literal|1
index|]
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9234_
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|may_be_iolength
operator|=
name|FALSE
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILENUM
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9233_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R9233_ -- "INQUIRE" OPEN_PAREN expr     (ffestb_R9233_)  // to expression handler     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9233_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixUNIT
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixUNIT
index|]
operator|.
name|kw_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixUNIT
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixUNIT
index|]
operator|.
name|value_is_label
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixUNIT
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixUNIT
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9234_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9239_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_inquire_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"INQUIRE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9234_ -- "INQUIRE" OPEN_PAREN [external-file-unit COMMA]     return ffestb_R9234_;  // to lexer     Handle expr construct (not NAME=expr construct) here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9234_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestrInquire
name|kw
decl_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|label
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|kw
operator|=
name|ffestr_inquire
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|kw
operator|!=
name|FFESTR_inquireIOLENGTH
condition|)
name|ffestb_local_
operator|.
name|inquire
operator|.
name|may_be_iolength
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|kw
condition|)
block|{
case|case
name|FFESTR_inquireACCESS
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixACCESS
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireACTION
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixACTION
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireBLANK
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixBLANK
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireCARRIAGECONTROL
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixCARRIAGECONTROL
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILECHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireDEFAULTFILE
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixDEFAULTFILE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILECHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireDELIM
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixDELIM
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireDIRECT
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixDIRECT
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireERR
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixERR
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|label
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireEXIST
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixEXIST
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILELOG
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireFILE
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixFILE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILECHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireFORM
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixFORM
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireFORMATTED
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixFORMATTED
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireIOLENGTH
case|:
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|inquire
operator|.
name|may_be_iolength
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixIOLENGTH
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEINT
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireIOSTAT
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixIOSTAT
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEINT
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireKEYED
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixKEYED
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILECHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireNAME
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixNAME
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILECHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireNAMED
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixNAMED
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILELOG
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireNEXTREC
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixNEXTREC
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFINT
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireNUMBER
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixNUMBER
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEINT
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireOPENED
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixOPENED
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILELOG
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireORGANIZATION
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixORGANIZATION
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILECHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquirePAD
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixPAD
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquirePOSITION
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixPOSITION
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireREAD
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixREAD
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireREADWRITE
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixREADWRITE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireRECL
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixRECL
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEINT
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireRECORDTYPE
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixRECORDTYPE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILECHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireSEQUENTIAL
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixSEQUENTIAL
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireUNFORMATTED
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixUNFORMATTED
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|TRUE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILEDFCHAR
expr_stmt|;
break|break;
case|case
name|FFESTR_inquireUNIT
case|:
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|=
name|FFESTP_inquireixUNIT
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
operator|=
name|FALSE
expr_stmt|;
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
operator|=
name|FFEEXPR_contextFILENUM
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
index|]
operator|.
name|kw_or_val_present
condition|)
break|break;
comment|/* Can't specify a keyword twice! */
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
index|]
operator|.
name|kw_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
index|]
operator|.
name|value_is_label
operator|=
name|ffestb_local_
operator|.
name|inquire
operator|.
name|label
expr_stmt|;
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
index|]
operator|.
name|kw
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9235_
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffestb_subr_kill_inquire_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"INQUIRE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9235_ -- "INQUIRE" OPEN_PAREN [external-file-unit COMMA] NAME     return ffestb_R9235_;  // to lexer     Make sure EQUALS here, send next token to expression handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9235_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|inquire
operator|.
name|label
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9237_
return|;
if|if
condition|(
name|ffestb_local_
operator|.
name|inquire
operator|.
name|left
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9236_
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestb_local_
operator|.
name|inquire
operator|.
name|context
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R9236_
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_inquire_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"INQUIRE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9236_ -- "INQUIRE" OPEN_PAREN ... NAME EQUALS expr     (ffestb_R9236_)  // to expression handler     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9236_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|==
name|FFESTP_inquireixIOLENGTH
condition|)
break|break;
comment|/* IOLENGTH=expr must be followed by 				   CLOSE_PAREN. */
comment|/* Fall through. */
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9234_
return|;
if|if
condition|(
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
operator|==
name|FFESTP_inquireixIOLENGTH
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R92310_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9239_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_inquire_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"INQUIRE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9237_ -- "INQUIRE" OPEN_PAREN ... NAME EQUALS     return ffestb_R9237_;  // to lexer     Handle NUMBER for label here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9237_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ffestb_local_
operator|.
name|inquire
operator|.
name|ix
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9238_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_inquire_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"INQUIRE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9238_ -- "INQUIRE" OPEN_PAREN ... NAME EQUALS NUMBER     return ffestb_R9238_;  // to lexer     Handle COMMA or CLOSE_PAREN here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9238_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9234_
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R9239_
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_inquire_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"INQUIRE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R9239_ -- "INQUIRE" OPEN_PAREN ... CLOSE_PAREN     return ffestb_R9239_;  // to lexer     Handle EOS or SEMICOLON here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R9239_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R923A
argument_list|()
expr_stmt|;
name|ffestb_subr_kill_inquire_
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_inquire_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"INQUIRE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R92310_ -- "INQUIRE(IOLENGTH=expr)"     return ffestb_R92310_;  // to lexer     Make sure EOS or SEMICOLON not here; begin R923B processing and expect    output IO list.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R92310_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
break|break;
default|default:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R923B_start
argument_list|()
expr_stmt|;
name|ffestb_subr_kill_inquire_
argument_list|()
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextIOLIST
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R92311_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffestb_subr_kill_inquire_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"INQUIRE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R92311_ -- "INQUIRE(IOLENGTH=expr)" expr     (ffestb_R92311_)  // to expression handler     Handle COMMA or EOS/SEMICOLON here.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R92311_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R923B_item
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextIOLIST
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R92311_
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_R923B_item
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffestc_R923B_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R923B_finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"INQUIRE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_V020 -- Parse the TYPE statement     return ffestb_V020;	// to lexer     Make sure the statement has a valid form for the TYPE    statement.  If it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_V020
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
name|ffestpTypeIx
name|ix
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstTYPE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOLONCOLON
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
case|case
name|FFELEX_typeCOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
comment|/* Because "TYPE,PUBLIC::A" is ambiguous with 				   '90. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNUMBER
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFELEX_typeNAME
case|:
comment|/* Because TYPE A is ambiguous with '90. */
default|default:
break|break;
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_typeix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|type
operator|.
name|type_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
operator|(
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILEFORMATNML
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_V0201_
argument_list|)
operator|)
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstTYPE
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|!=
name|FFESTR_firstlTYPE
condition|)
break|break;
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|==
name|FFESTR_firstlTYPE
condition|)
break|break;
comment|/* Else might be assignment/stmtfuncdef. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
case|case
name|FFELEX_typeCOLON
case|:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
break|break;
block|}
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlTYPE
operator|)
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Else might be '90 TYPE statement. */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|FFESTP_typeix
condition|;
operator|++
name|ix
control|)
name|ffestp_file
operator|.
name|type
operator|.
name|type_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|FALSE
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextFILEFORMATNML
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_V0201_
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffelex_splice_tokens
argument_list|(
name|next
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|FFESTR_firstlTYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"TYPE I/O"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"TYPE I/O"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_V0201_ -- "TYPE" expr     (ffestb_V0201_)  // to expression handler     Make sure the next token is a COMMA or EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_V0201_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|bool
name|comma
init|=
name|TRUE
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffe_is_vxt
argument_list|()
operator|&&
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opSYMTER
operator|)
condition|)
break|break;
name|comma
operator|=
name|FALSE
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
operator|!
name|ffe_is_vxt
argument_list|()
operator|&&
name|comma
operator|&&
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opPAREN
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opSYMTER
operator|)
condition|)
break|break;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestp_file
operator|.
name|type
operator|.
name|type_spec
index|[
name|FFESTP_typeixFORMAT
index|]
operator|.
name|kw_or_val_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|type
operator|.
name|type_spec
index|[
name|FFESTP_typeixFORMAT
index|]
operator|.
name|kw_present
operator|=
name|FALSE
expr_stmt|;
name|ffestp_file
operator|.
name|type
operator|.
name|type_spec
index|[
name|FFESTP_typeixFORMAT
index|]
operator|.
name|value_present
operator|=
name|TRUE
expr_stmt|;
name|ffestp_file
operator|.
name|type
operator|.
name|type_spec
index|[
name|FFESTP_typeixFORMAT
index|]
operator|.
name|value_is_label
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
expr_stmt|;
name|ffestp_file
operator|.
name|type
operator|.
name|type_spec
index|[
name|FFESTP_typeixFORMAT
index|]
operator|.
name|value
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffestp_file
operator|.
name|type
operator|.
name|type_spec
index|[
name|FFESTP_typeixFORMAT
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V020_start
argument_list|()
expr_stmt|;
name|ffestb_subr_kill_type_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextIOLIST
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_V0202_
argument_list|)
return|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V020_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestb_subr_kill_type_
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"TYPE I/O"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_V0202_ -- "TYPE" expr COMMA expr     (ffestb_V0202_)  // to expression handler     Handle COMMA or EOS/SEMICOLON here.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_V0202_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V020_item
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextIOLIST
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_V0202_
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_V020_item
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffestc_V020_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V020_finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"TYPE I/O"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_dummy -- Parse an ENTRY/FUNCTION/SUBROUTINE statement     return ffestb_dummy;	 // to lexer     Make sure the statement has a valid form for an ENTRY/FUNCTION/SUBROUTINE    statement.  If it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_dummy
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|dummy
operator|.
name|badname
operator|=
name|ffestb_args
operator|.
name|dummy
operator|.
name|badname
expr_stmt|;
name|ffestb_local_
operator|.
name|dummy
operator|.
name|is_subr
operator|=
name|ffestb_args
operator|.
name|dummy
operator|.
name|is_subr
expr_stmt|;
name|ffestb_local_
operator|.
name|dummy
operator|.
name|first_kw
operator|=
name|ffesta_first_kw
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_dummy1_
return|;
case|case
name|FFELEX_typeNAMES
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
block|}
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|ffestb_args
operator|.
name|dummy
operator|.
name|len
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|dummy
operator|.
name|badname
operator|=
name|ffestb_args
operator|.
name|dummy
operator|.
name|badname
expr_stmt|;
name|ffestb_local_
operator|.
name|dummy
operator|.
name|is_subr
operator|=
name|ffestb_args
operator|.
name|dummy
operator|.
name|is_subr
expr_stmt|;
name|ffestb_local_
operator|.
name|dummy
operator|.
name|first_kw
operator|=
name|ffesta_first_kw
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_dummy1_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|dummy
operator|.
name|badname
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|dummy
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|dummy
operator|.
name|badname
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_dummy1_ -- "ENTRY/FUNCTION/SUBROUTINE" NAME     return ffestb_dummy1_;  // to lexer     Make sure the next token is an EOS, SEMICOLON, or OPEN_PAREN.  In the    former case, just implement a null arg list, else get the arg list and    then implement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_dummy1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|dummy
operator|.
name|first_kw
operator|==
name|FFESTR_firstFUNCTION
condition|)
block|{
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Later, not if typename w/o RECURSIVE. */
break|break;
comment|/* Produce an error message, need that open 				   paren. */
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
comment|/* Pretend as though we got a truly NULL 				   list. */
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
operator|=
name|NULL
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|ok
operator|=
name|TRUE
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_dummy2_
argument_list|(
name|t
argument_list|)
return|;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
operator|=
name|ffestt_tokenlist_create
argument_list|()
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_dummy2_
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|is_subr
operator|=
name|ffestb_local_
operator|.
name|dummy
operator|.
name|is_subr
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|names
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subr_name_list_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_local_
operator|.
name|dummy
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_dummy2_ --<dummy-keyword> NAME OPEN_PAREN arg-list CLOSE_PAREN     return ffestb_dummy2_;  // to lexer     Make sure the statement has a valid form for a dummy-def statement.	If it    does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_dummy2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|ok
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|ffestb_local_
operator|.
name|dummy
operator|.
name|first_kw
condition|)
block|{
case|case
name|FFESTR_firstFUNCTION
case|:
name|ffestc_R1219
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|,
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|,
name|FFESTP_typeNone
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstSUBROUTINE
case|:
name|ffestc_R1223
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|,
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTR_firstENTRY
case|:
name|ffestc_R1226
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|,
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
operator|!=
name|NULL
condition|)
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ffestb_local_
operator|.
name|dummy
operator|.
name|first_kw
operator|!=
name|FFESTR_firstFUNCTION
operator|)
operator|||
operator|(
name|ffestr_other
argument_list|(
name|t
argument_list|)
operator|!=
name|FFESTR_otherRESULT
operator|)
condition|)
break|break;
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeNone
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_funcname_6_
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_local_
operator|.
name|dummy
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
operator|!=
name|NULL
condition|)
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R524 -- Parse the DIMENSION statement     return ffestb_R524;	// to lexer     Make sure the statement has a valid form for the DIMENSION statement.  If    it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R524
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R524_start
argument_list|(
name|ffesta_first_kw
operator|==
name|FFESTR_firstVIRTUAL
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|dimension
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5241_
argument_list|(
name|t
argument_list|)
return|;
block|}
case|case
name|FFELEX_typeNAMES
case|:
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|ffestb_args
operator|.
name|R524
operator|.
name|len
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
block|}
comment|/* Here, we have at least one char after "DIMENSION" and t is 	 OPEN_PAREN. */
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|nt
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|dimension
operator|.
name|started
operator|=
name|FALSE
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5241_
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|R524
operator|.
name|badname
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|R524
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|R524
operator|.
name|badname
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5241_ -- "DIMENSION"     return ffestb_R5241_;  // to lexer     Handle NAME.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5241_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5242_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|R524
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R524_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5242_ -- "DIMENSION" ... NAME     return ffestb_R5242_;  // to lexer     Handle OPEN_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5242_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|=
name|ffestt_dimlist_create
argument_list|()
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5243_
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ctx
operator|=
name|ffesta_is_entry_valid
condition|?
name|FFEEXPR_contextDIMLIST
else|:
name|FFEEXPR_contextDIMLISTCOMMON
expr_stmt|;
ifdef|#
directive|ifdef
name|FFECOM_dimensionsMAX
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ndims
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ctx
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_subr_dimlist_
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|R524
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R524_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5243_ -- "DIMENSION" ... NAME OPEN_PAREN dimlist CLOSE_PAREN     return ffestb_R5243_;  // to lexer     Handle COMMA or EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5243_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ok
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|dimension
operator|.
name|started
condition|)
block|{
name|ffestc_R524_start
argument_list|(
name|ffesta_first_kw
operator|==
name|FFESTR_firstVIRTUAL
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|dimension
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
block|}
name|ffestc_R524_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5244_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|dimension
operator|.
name|started
condition|)
block|{
name|ffestc_R524_start
argument_list|(
name|ffesta_first_kw
operator|==
name|FFESTR_firstVIRTUAL
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|dimension
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
block|}
name|ffestc_R524_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
name|ffestc_R524_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|R524
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|dimension
operator|.
name|started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R524_finish
argument_list|()
expr_stmt|;
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5244_ -- "DIMENSION" ... COMMA     return ffestb_R5244_;  // to lexer     Make sure we don't have EOS or SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5244_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R524_finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
name|ffestb_args
operator|.
name|R524
operator|.
name|badname
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5241_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R547 -- Parse the COMMON statement     return ffestb_R547;	// to lexer     Make sure the statement has a valid form for the COMMON statement.  If it    does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R547
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstCOMMON
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeSLASH
case|:
case|case
name|FFELEX_typeCONCAT
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R547_start
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|common
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5471_
argument_list|(
name|t
argument_list|)
return|;
block|}
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstCOMMON
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlCOMMON
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFELEX_typeSLASH
case|:
case|case
name|FFELEX_typeCONCAT
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R547_start
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|common
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5471_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
block|}
comment|/* Here, we have at least one char after "COMMON" and t is COMMA, 	 EOS/SEMICOLON, OPEN_PAREN, SLASH, or CONCAT. */
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|nt
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeOPEN_PAREN
condition|)
name|ffestb_local_
operator|.
name|common
operator|.
name|started
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R547_start
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|common
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
block|}
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5471_
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"COMMON"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"COMMON"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"COMMON"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5471_ -- "COMMON"     return ffestb_R5471_;  // to lexer     Handle NAME, SLASH, or CONCAT.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5471_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5474_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeSLASH
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5472_
return|;
case|case
name|FFELEX_typeCONCAT
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R547_item_cblock
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5474_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"COMMON"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R547_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5472_ -- "COMMON" SLASH     return ffestb_R5472_;  // to lexer     Handle NAME.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5472_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5473_
return|;
case|case
name|FFELEX_typeSLASH
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R547_item_cblock
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5474_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"COMMON"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R547_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5473_ -- "COMMON" SLASH NAME     return ffestb_R5473_;  // to lexer     Handle SLASH.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5473_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeSLASH
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R547_item_cblock
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5474_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"COMMON"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R547_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5474_ -- "COMMON" [SLASH NAME SLASH] or "COMMON" CONCAT     return ffestb_R5474_;  // to lexer     Handle NAME.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5474_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5475_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"COMMON"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R547_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5475_ -- "COMMON" ... NAME     return ffestb_R5475_;  // to lexer     Handle OPEN_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5475_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|=
name|ffestt_dimlist_create
argument_list|()
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5476_
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ctx
operator|=
name|FFEEXPR_contextDIMLISTCOMMON
expr_stmt|;
ifdef|#
directive|ifdef
name|FFECOM_dimensionsMAX
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ndims
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDIMLISTCOMMON
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_subr_dimlist_
argument_list|)
return|;
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R547_item_object
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5477_
return|;
case|case
name|FFELEX_typeSLASH
case|:
case|case
name|FFELEX_typeCONCAT
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R547_item_object
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5471_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_R547_item_object
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestc_R547_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"COMMON"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R547_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5476_ -- "COMMON" ... NAME OPEN_PAREN dimlist CLOSE_PAREN     return ffestb_R5476_;  // to lexer     Handle COMMA, SLASH, CONCAT, EOS/SEMICOLON.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5476_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ok
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|common
operator|.
name|started
condition|)
block|{
name|ffestc_R547_start
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|common
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
block|}
name|ffestc_R547_item_object
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5477_
return|;
case|case
name|FFELEX_typeSLASH
case|:
case|case
name|FFELEX_typeCONCAT
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|common
operator|.
name|started
condition|)
block|{
name|ffestc_R547_start
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|common
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
block|}
name|ffestc_R547_item_object
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5471_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|common
operator|.
name|started
condition|)
name|ffestc_R547_start
argument_list|()
expr_stmt|;
name|ffestc_R547_item_object
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
name|ffestc_R547_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"COMMON"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|common
operator|.
name|started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R547_finish
argument_list|()
expr_stmt|;
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R5477_ -- "COMMON" ... COMMA     return ffestb_R5477_;  // to lexer     Make sure we don't have EOS or SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R5477_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R547_finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"COMMON"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_R5471_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_R1229 -- Parse a STMTFUNCTION statement     return ffestb_R1229;	 // to lexer     Make sure the statement has a valid form for a STMTFUNCTION    statement.  If it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_R1229
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
break|break;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
operator|=
name|ffestt_tokenlist_create
argument_list|()
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_R12291_
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|is_subr
operator|=
name|FALSE
expr_stmt|;
comment|/* No "*" items in list! */
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|names
operator|=
name|TRUE
expr_stmt|;
comment|/* In case "IF(FOO)CALL 						   FOO...". */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subr_name_list_
return|;
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_2t
argument_list|(
name|FFEBAD_UNREC_STMT
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R12291_ -- "STMTFUNCTION" OPEN_PAREN dummy-name-list CLOSE_PAREN     return ffestb_R12291_;  // to lexer     Make sure the statement has a valid form for a STMTFUNCTION statement.  If    it does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R12291_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelex_set_names
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|ok
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1229_start
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|,
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextSFUNCDEF
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_R12292_
argument_list|)
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_2t
argument_list|(
name|FFEBAD_UNREC_STMT
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_R12292_ -- "STMTFUNCTION" OPEN_PAREN dummy-name-list CLOSE_PAREN 		     EQUALS expr     (ffestb_R12292_)  // to expression handler     Make sure the statement has a valid form for a STMTFUNCTION statement.  If    it does, implement the statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_R12292_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1229_finish
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffestc_R1229_finish
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"statement-function-definition"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_chartype -- Parse the CHARACTER statement     return ffestb_decl_chartype;	 // to lexer     Make sure the statement has a valid form for the CHARACTER statement.  If    it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_decl_chartype
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeCHARACTER
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|parameter
operator|=
name|FALSE
expr_stmt|;
comment|/* No PARAMETER attribute seen. */
name|ffestb_local_
operator|.
name|decl
operator|.
name|coloncolon
operator|=
name|FALSE
expr_stmt|;
comment|/* No COLONCOLON seen. */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstCHRCTR
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_
return|;
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|coloncolon
operator|=
name|TRUE
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_
return|;
case|case
name|FFELEX_typeASTERISK
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_chartype1_
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
operator|=
literal|"TYPEDECL"
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_starlen_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrsp_
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
operator|=
literal|"_TYPEDECL"
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_typeparams_
return|;
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_
argument_list|(
name|t
argument_list|)
return|;
block|}
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstCHRCTR
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlCHRCTR
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_
return|;
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|coloncolon
operator|=
name|TRUE
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_
return|;
case|case
name|FFELEX_typeASTERISK
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_chartype1_
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
operator|=
literal|"TYPEDECL"
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_starlen_
return|;
case|case
name|FFELEX_typeSLASH
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrsp_
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
operator|=
literal|"TYPEDECL"
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_typeparams_
return|;
block|}
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_names_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_2_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_chartype1_ -- "CHARACTER" ASTERISK char-length     return ffestb_decl_chartype1_;  // to lexer     Handle COMMA, COLONCOLON, or anything else.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_chartype1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelex_set_names
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|coloncolon
operator|=
name|TRUE
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_decl_dbltype -- Parse the DOUBLEPRECISION/DOUBLECOMPLEX statement     return ffestb_decl_dbltype;	// to lexer     Make sure the statement has a valid form for the DOUBLEPRECISION/    DOUBLECOMPLEX statement.  If it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_decl_dbltype
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|ffestb_args
operator|.
name|decl
operator|.
name|type
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|parameter
operator|=
name|FALSE
expr_stmt|;
comment|/* No PARAMETER attribute seen. */
name|ffestb_local_
operator|.
name|decl
operator|.
name|coloncolon
operator|=
name|FALSE
expr_stmt|;
comment|/* No COLONCOLON seen. */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_
return|;
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|coloncolon
operator|=
name|TRUE
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_
return|;
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_
argument_list|(
name|t
argument_list|)
return|;
block|}
case|case
name|FFELEX_typeNAMES
case|:
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|ffestb_args
operator|.
name|decl
operator|.
name|len
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_
return|;
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|coloncolon
operator|=
name|TRUE
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_
return|;
case|case
name|FFELEX_typeSLASH
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_names_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_2_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_double -- Parse the DOUBLE PRECISION/DOUBLE COMPLEX statement     return ffestb_decl_double;  // to lexer     Make sure the statement has a valid form for the DOUBLE PRECISION/    DOUBLE COMPLEX statement.  If it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_decl_double
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|parameter
operator|=
name|FALSE
expr_stmt|;
comment|/* No PARAMETER attribute seen. */
name|ffestb_local_
operator|.
name|decl
operator|.
name|coloncolon
operator|=
name|FALSE
expr_stmt|;
comment|/* No COLONCOLON seen. */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstDBL
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffestr_second
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFESTR_secondCOMPLEX
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeDBLCMPLX
expr_stmt|;
break|break;
case|case
name|FFESTR_secondPRECISION
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeDBLPRCSN
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrsp_
return|;
block|}
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_decl_gentype -- Parse the INTEGER/REAL/COMPLEX/LOGICAL statement     return ffestb_decl_gentype;	// to lexer     Make sure the statement has a valid form for the INTEGER/REAL/COMPLEX/    LOGICAL statement.  If it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_decl_gentype
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|ffestb_args
operator|.
name|decl
operator|.
name|type
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|parameter
operator|=
name|FALSE
expr_stmt|;
comment|/* No PARAMETER attribute seen. */
name|ffestb_local_
operator|.
name|decl
operator|.
name|coloncolon
operator|=
name|FALSE
expr_stmt|;
comment|/* No COLONCOLON seen. */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_
return|;
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|coloncolon
operator|=
name|TRUE
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_
return|;
case|case
name|FFELEX_typeASTERISK
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrsp_
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
operator|=
literal|"TYPEDECL"
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_starkind_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrsp_
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
operator|=
literal|"TYPEDECL"
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_kindparam_
return|;
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_
argument_list|(
name|t
argument_list|)
return|;
block|}
case|case
name|FFELEX_typeNAMES
case|:
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|ffestb_args
operator|.
name|decl
operator|.
name|len
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_
return|;
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|coloncolon
operator|=
name|TRUE
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_
return|;
case|case
name|FFELEX_typeSLASH
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeASTERISK
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrsp_
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
operator|=
literal|"TYPEDECL"
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_starkind_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrsp_
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
operator|=
literal|"TYPEDECL"
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_kindparam_
return|;
block|}
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_names_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_2_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_attrs_ -- "type" [type parameters] COMMA     return ffestb_decl_attrs_;  // to lexer     Handle NAME of an attribute.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_attrs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffestr_first
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFESTR_firstDIMENSION
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_1_
return|;
case|case
name|FFESTR_firstEXTERNAL
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_attrib
argument_list|(
name|FFESTP_attribEXTERNAL
argument_list|,
name|t
argument_list|,
name|FFESTR_otherNone
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_7_
return|;
case|case
name|FFESTR_firstINTRINSIC
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_attrib
argument_list|(
name|FFESTP_attribINTRINSIC
argument_list|,
name|t
argument_list|,
name|FFESTR_otherNone
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_7_
return|;
case|case
name|FFESTR_firstPARAMETER
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|parameter
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_attrib
argument_list|(
name|FFESTP_attribPARAMETER
argument_list|,
name|t
argument_list|,
name|FFESTR_otherNone
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_7_
return|;
case|case
name|FFESTR_firstSAVE
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_attrib
argument_list|(
name|FFESTP_attribSAVE
argument_list|,
name|t
argument_list|,
name|FFESTR_otherNone
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_7_
return|;
default|default:
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_INVALID_TYPEDECL_ATTR
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_7_
return|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_attrs_1_ -- "type" [type parameters] ",DIMENSION"     return ffestb_decl_attrs_1_;	 // to lexer     Handle OPEN_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_attrs_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|=
name|ffestt_dimlist_create
argument_list|()
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_2_
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|pool
operator|=
name|ffesta_scratch_pool
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ctx
operator|=
name|ffesta_is_entry_valid
condition|?
name|FFEEXPR_contextDIMLIST
else|:
name|FFEEXPR_contextDIMLISTCOMMON
expr_stmt|;
ifdef|#
directive|ifdef
name|FFECOM_dimensionsMAX
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ndims
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_scratch_pool
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ctx
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_subr_dimlist_
argument_list|)
return|;
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_INVALID_TYPEDECL_ATTR
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_7_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_INVALID_TYPEDECL_ATTR
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_attrs_2_ -- "type" [type parameters] ",DIMENSION" OPEN_PAREN 			  dimlist CLOSE_PAREN     return ffestb_decl_attrs_2_;	 // to lexer     Handle COMMA or COLONCOLON.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_attrs_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ok
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_attrib
argument_list|(
name|FFESTP_attribDIMENSION
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|FFESTR_otherNone
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_7_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_attrs_7_ -- "type" [type parameters] attribute     return ffestb_decl_attrs_7_;	 // to lexer     Handle COMMA (another attribute) or COLONCOLON (entities).  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_attrs_7_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_
return|;
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|coloncolon
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_attrsp_ -- "type" [type parameters]     return ffestb_decl_attrsp_;	// to lexer     Handle COMMA (meaning we have attributes), COLONCOLON (meaning we have    no attributes but entities), or go to entsp to see about functions or    entities.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_attrsp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelex_set_names
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_attrs_
return|;
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|coloncolon
operator|=
name|TRUE
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestb_decl_ents_ -- "type" [type parameters] [attributes "::"]     return ffestb_decl_ents_;  // to lexer     Handle NAME of an entity.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_1_
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_ents_1_ -- "type" [type parameters] [attributes "::"] NAME     return ffestb_decl_ents_1_;	// to lexer     Handle ASTERISK, OPEN_PAREN, EQUALS, SLASH, COMMA, or EOS/SEMICOLON.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_decl_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeASTERISK
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_2_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_3_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typeSLASH
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_7_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_ents_2_ -- "type" [type parameters] [attributes "::"] NAME 			 ASTERISK     return ffestb_decl_ents_2_;	// to lexer     Handle NUMBER or OPEN_PAREN.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|!=
name|FFESTP_typeCHARACTER
condition|)
block|{
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_3_
return|;
block|}
comment|/* Fall through. */
comment|/* (CHARACTER's *n is always a len spec. */
case|case
name|FFELEX_typeOPEN_PAREN
case|:
comment|/* "*(" is after the (omitted) 				   "(array-spec)". */
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_5_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_ents_3_ -- "type" [type parameters] [attributes "::"] NAME 			 [ASTERISK NUMBER]     return ffestb_decl_ents_3_;	// to lexer     Handle ASTERISK, OPEN_PAREN, EQUALS, SLASH, COMMA, or EOS/SEMICOLON.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_decl_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeASTERISK
case|:
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_5_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|=
name|ffestt_dimlist_create
argument_list|()
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_4_
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ctx
operator|=
name|ffesta_is_entry_valid
condition|?
name|FFEEXPR_contextDIMLIST
else|:
name|FFEEXPR_contextDIMLISTCOMMON
expr_stmt|;
ifdef|#
directive|ifdef
name|FFECOM_dimensionsMAX
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ndims
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ctx
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_subr_dimlist_
argument_list|)
return|;
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typeSLASH
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_7_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_ents_4_ -- "type" [type parameters] [attributes "::"] NAME 			 [ASTERISK NUMBER] [OPEN_PAREN dimlist CLOSE_PAREN]     return ffestb_decl_ents_4_;	// to lexer     Handle ASTERISK, EQUALS, SLASH, COMMA, or EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_4_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexToken
name|nt
decl_stmt|;
if|if
condition|(
operator|!
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|ok
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
operator|==
name|FFELEX_typeNAMES
condition|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeASTERISK
case|:
case|case
name|FFELEX_typeSLASH
case|:
comment|/* But NOT FFELEX_typeEQUALS. */
case|case
name|FFELEX_typeCOLONCOLON
case|:
comment|/* Actually an error. */
break|break;
comment|/* Confirm and handle. */
default|default:
comment|/* Perhaps EQUALS, as in 				   INTEGERFUNCTIONX(A)=B. */
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|nt
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|nt
expr_stmt|;
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_decl_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeASTERISK
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
break|break;
comment|/* Can't specify "*length" twice. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_5_
return|;
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typeSLASH
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_7_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
operator|!=
name|FFELEX_typeNAMES
operator|)
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_ents_5_ -- "type" [type parameters] [attributes "::"] NAME 			 [ASTERISK NUMBER] [OPEN_PAREN dimlist CLOSE_PAREN] 			 ASTERISK     return ffestb_decl_ents_5_;	// to lexer     Handle NUMBER or OPEN_PAREN.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_7_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextCHARACTERSIZE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_ents_6_
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|!=
name|NULL
condition|)
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_ents_6_ -- "type" [type parameters] [attributes "::"] NAME 			 [ASTERISK NUMBER] [OPEN_PAREN dimlist CLOSE_PAREN] 			 ASTERISK OPEN_PAREN expr     (ffestb_decl_ents_6_)  // to expression handler     Handle CLOSE_PAREN.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_6_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|expr
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_7_
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|!=
name|NULL
condition|)
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_ents_7_ -- "type" [type parameters] [attributes "::"] NAME 			 [ASTERISK NUMBER] [OPEN_PAREN dimlist CLOSE_PAREN] 			 [ASTERISK charlength]     return ffestb_decl_ents_7_;	// to lexer     Handle EQUALS, SLASH, COMMA, or EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_7_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|!=
name|NULL
condition|)
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_decl_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|!=
name|NULL
condition|)
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeEQUALS
case|:
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|decl
operator|.
name|coloncolon
condition|)
name|ffesta_ffebad_1t
argument_list|(
name|FFEBAD_INVALID_TYPEDECL_INIT
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|parameter
condition|?
name|FFEEXPR_contextPARAMETER
else|:
name|FFEEXPR_contextINITVAL
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_ents_8_
argument_list|)
return|;
case|case
name|FFELEX_typeSLASH
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_decl_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_decl_itemstartvals
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|!=
name|NULL
condition|)
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDATA
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_ents_9_
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|!=
name|NULL
condition|)
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_ents_8_ -- "type" [type parameters] [attributes "::"] NAME 			 [ASTERISK NUMBER] [OPEN_PAREN dimlist CLOSE_PAREN] 			 [ASTERISK charlength] EQUALS expr     (ffestb_decl_ents_8_)  // to expression handler     Handle COMMA or EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_8_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|!=
name|NULL
condition|)
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_decl_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|!=
name|NULL
condition|)
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|!=
name|NULL
condition|)
name|ffestt_dimlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_ents_9_ -- "type" ... SLASH expr     (ffestb_decl_ents_9_)  // to expression handler     Handle ASTERISK, COMMA, or SLASH.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_9_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_itemvalue
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDATA
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_ents_9_
argument_list|)
return|;
case|case
name|FFELEX_typeASTERISK
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
name|ffestb_local_
operator|.
name|decl
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDATA
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_ents_10_
argument_list|)
return|;
case|case
name|FFELEX_typeSLASH
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_decl_itemvalue
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffestc_decl_itemendvals
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_11_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_decl_itemendvals
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_ents_10_ -- "type" ... SLASH expr ASTERISK expr     (ffestb_decl_ents_10_)  // to expression handler     Handle COMMA or SLASH.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_10_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_itemvalue
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|expr
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextDATA
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_ents_9_
argument_list|)
return|;
case|case
name|FFELEX_typeSLASH
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_decl_itemvalue
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|expr
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffestc_decl_itemendvals
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_11_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_decl_itemendvals
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_ents_11_ -- "type" [type parameters] [attributes "::"] NAME 			 [ASTERISK NUMBER] [OPEN_PAREN dimlist CLOSE_PAREN] 			 [ASTERISK charlength] SLASH initvals SLASH     return ffestb_decl_ents_11_;	 // to lexer     Handle COMMA or EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_ents_11_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_
return|;
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_entsp_ -- "type" [type parameters]     return ffestb_decl_entsp_;  // to lexer     Handle NAME or NAMES beginning either an entity (object) declaration or    a function definition..  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_1_
return|;
case|case
name|FFELEX_typeNAMES
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_2_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"type-declaration"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_entsp_1_ -- "type" [type parameters] NAME     return ffestb_decl_entsp_1_;	 // to lexer     If we get another NAME token here, then the previous one must be    "RECURSIVE" or "FUNCTION" and we handle it accordingly.  Otherwise,    we send the previous and current token through to _ents_.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffestr_first
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
name|FFESTR_firstFUNCTION
case|:
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_funcname_
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
operator|!=
name|FFELEX_typeNAMES
operator|)
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_decl_start
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
comment|/* NAME/NAMES token already in ffesta_tokens[1]. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_1_
argument_list|(
name|t
argument_list|)
return|;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_entsp_2_ -- "type" [type parameters] NAMES     return ffestb_decl_entsp_2_;	 // to lexer     If we get an ASTERISK or OPEN_PAREN here, then if the previous NAMES    begins with "FUNCTION" or "RECURSIVEFUNCTION" and is followed by a    first-name-char, we have a possible syntactically ambiguous situation.    Otherwise, we have a straightforward situation just as if we went    through _entsp_1_ instead of here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexToken
name|nt
decl_stmt|;
name|bool
name|asterisk_ok
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffeTokenLength
name|i
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeASTERISK
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
condition|)
block|{
case|case
name|FFESTP_typeINTEGER
case|:
case|case
name|FFESTP_typeREAL
case|:
case|case
name|FFESTP_typeCOMPLEX
case|:
case|case
name|FFESTP_typeLOGICAL
case|:
name|asterisk_ok
operator|=
operator|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|==
name|NULL
operator|)
expr_stmt|;
break|break;
case|case
name|FFESTP_typeCHARACTER
case|:
name|asterisk_ok
operator|=
operator|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|==
name|NULL
operator|)
expr_stmt|;
break|break;
case|case
name|FFESTP_typeBYTE
case|:
case|case
name|FFESTP_typeWORD
case|:
default|default:
name|asterisk_ok
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ffestr_first
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
name|FFESTR_firstFUNCTION
case|:
if|if
condition|(
operator|!
name|asterisk_ok
condition|)
break|break;
comment|/* For our own convenience, treat as non-FN 				   stmt. */
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlFUNCTION
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|=
name|NULL
expr_stmt|;
name|ffesta_tokens
index|[
literal|2
index|]
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|FFESTR_firstlFUNCTION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_3_
return|;
default|default:
break|break;
block|}
break|break;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|aster_after
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|ffestr_first
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
name|FFESTR_firstFUNCTION
case|:
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlFUNCTION
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|=
name|NULL
expr_stmt|;
name|ffesta_tokens
index|[
literal|2
index|]
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|FFESTR_firstlFUNCTION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_5_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
operator|)
condition|)
break|break;
comment|/* Have kind/len type param, definitely not 				   assignment stmt. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_1_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|nt
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|nt
expr_stmt|;
comment|/* Change NAMES to NAME. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_1_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_entsp_3_ -- "type" [type parameters] [RECURSIVE] FUNCTION 			     NAME ASTERISK     return ffestb_decl_entsp_3_;	 // to lexer     Handle NUMBER or OPEN_PAREN.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestb_local_
operator|.
name|decl
operator|.
name|aster_after
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
switch|switch
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
condition|)
block|{
case|case
name|FFESTP_typeINTEGER
case|:
case|case
name|FFESTP_typeREAL
case|:
case|case
name|FFESTP_typeCOMPLEX
case|:
case|case
name|FFESTP_typeLOGICAL
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_typeCHARACTER
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_typeBYTE
case|:
case|case
name|FFESTP_typeWORD
case|:
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_5_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextCHARACTERSIZE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_entsp_4_
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_entsp_4_ -- "type" [type parameters] [RECURSIVE] FUNCTION 			     NAME ASTERISK OPEN_PAREN expr     (ffestb_decl_entsp_4_)  // to expression handler     Allow only CLOSE_PAREN; and deal with character-length expression.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_4_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
switch|switch
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
condition|)
block|{
case|case
name|FFESTP_typeCHARACTER
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|expr
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_5_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_entsp_5_ -- "type" [type parameters] [RECURSIVE] FUNCTION 			     NAME [type parameter]     return ffestb_decl_entsp_5_;	 // to lexer     Make sure the next token is an OPEN_PAREN.  Get the arg list or dimension    list.  If it can't be an arg list, or if the CLOSE_PAREN is followed by    something other than EOS/SEMICOLON or NAME, then treat as dimension list    and handle statement as an R426/R501.  If it can't be a dimension list, or    if the CLOSE_PAREN is followed by NAME, treat as an arg list and handle    statement as an R1219.  If it can be either an arg list or a dimension    list and if the CLOSE_PAREN is followed by EOS/SEMICOLON, ask FFESTC    whether to treat the statement as an R426/R501 or an R1219 and act    accordingly.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|aster_after
operator|&&
operator|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* "CHARACTER[RECURSIVE]FUNCTIONxyz*(len-expr) 				   (..." must be a function-stmt, since the 				   (len-expr) cannot precede (array-spec) in 				   an object declaration but can precede 				   (name-list) in a function stmt. */
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffesta_tokens
index|[
literal|2
index|]
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_funcname_4_
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
operator|=
name|ffestt_tokenlist_create
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|empty
operator|=
name|TRUE
expr_stmt|;
name|ffestt_tokenlist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_6_
return|;
default|default:
break|break;
block|}
name|assert
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|aster_after
argument_list|)
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* We've seen an ASTERISK, so even EQUALS 				   confirmed. */
name|ffestb_subr_ambig_to_ents_
argument_list|()
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|dim_list
operator|.
name|dims
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_7_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_entsp_6_ -- "type" [type parameters] [RECURSIVE] FUNCTION 			     NAME [type parameter] OPEN_PAREN     return ffestb_decl_entsp_6_;	 // to lexer     If CLOSE_PAREN, we definitely have an R1219 function-stmt, since    the notation "name()" is invalid for a declaration.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_6_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|decl
operator|.
name|empty
condition|)
block|{
comment|/* Trailing comma, just a warning for 				   stmt func def, so allow ambiguity. */
name|ffestt_tokenlist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_8_
return|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffesta_tokens
index|[
literal|2
index|]
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestt_tokenlist_handle
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_funcname_4_
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAME
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|empty
operator|=
name|FALSE
expr_stmt|;
name|ffestt_tokenlist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_7_
return|;
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
case|case
name|FFELEX_typePERCENT
case|:
case|case
name|FFELEX_typePERIOD
case|:
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
operator|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
operator|)
condition|)
break|break;
comment|/* type(params)name or type*val name, either 				   way confirmed. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subr_ambig_nope_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_subr_ambig_to_ents_
argument_list|()
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestt_tokenlist_handle
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_3_
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_entsp_7_ -- "type" [type parameters] [RECURSIVE] FUNCTION 			     NAME [type parameter] OPEN_PAREN NAME     return ffestb_decl_entsp_7_;	 // to lexer     Expect COMMA or CLOSE_PAREN to remain ambiguous, else not an R1219    function-stmt.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_7_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestt_tokenlist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_8_
return|;
case|case
name|FFELEX_typeCOMMA
case|:
name|ffestt_tokenlist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_entsp_6_
return|;
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
case|case
name|FFELEX_typePERCENT
case|:
case|case
name|FFELEX_typePERIOD
case|:
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
operator|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
operator|)
condition|)
break|break;
comment|/* type(params)name or type*val name, either 				   way confirmed. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subr_ambig_nope_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_subr_ambig_to_ents_
argument_list|()
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestt_tokenlist_handle
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_3_
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_entsp_8_ -- "type" [type parameters] [RECURSIVE] FUNCTION 			     NAME [type parameter] OPEN_PAREN name-list 			     CLOSE_PAREN     return ffestb_decl_entsp_8_;	 // to lexer     If EOS/SEMICOLON, situation remains ambiguous, ask FFESTC to resolve    it.	If NAME (must be "RESULT", but that is checked later on),    definitely an R1219 function-stmt.  Anything else, handle as entity decl.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_entsp_8_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_is_decl_not_R1219
argument_list|()
condition|)
break|break;
comment|/* Fall through. */
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffesta_tokens
index|[
literal|2
index|]
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestt_tokenlist_handle
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_funcname_4_
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
case|case
name|FFELEX_typePERCENT
case|:
case|case
name|FFELEX_typePERIOD
case|:
case|case
name|FFELEX_typeOPEN_PAREN
case|:
if|if
condition|(
operator|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
operator|)
condition|)
break|break;
comment|/* type(params)name or type*val name, either 				   way confirmed. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subr_ambig_nope_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_subr_ambig_to_ents_
argument_list|()
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestt_tokenlist_handle
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_ents_3_
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_funcname_ -- "type" [type parameters] [RECURSIVE] FUNCTION     return ffestb_decl_funcname_;  // to lexer     Handle NAME of a function.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_funcname_1_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_funcname_1_ -- "type" [type parameters] [RECURSIVE] FUNCTION 			     NAME     return ffestb_decl_funcname_1_;  // to lexer     Handle ASTERISK or OPEN_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeASTERISK
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_funcname_2_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_funcname_4_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_funcname_2_ -- "type" [type parameters] [RECURSIVE] FUNCTION 			     NAME ASTERISK     return ffestb_decl_funcname_2_;  // to lexer     Handle NUMBER or OPEN_PAREN.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
switch|switch
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
condition|)
block|{
case|case
name|FFESTP_typeINTEGER
case|:
case|case
name|FFESTP_typeREAL
case|:
case|case
name|FFESTP_typeCOMPLEX
case|:
case|case
name|FFESTP_typeLOGICAL
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|==
name|NULL
condition|)
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_typeCHARACTER
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|==
name|NULL
condition|)
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_typeBYTE
case|:
case|case
name|FFESTP_typeWORD
case|:
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_funcname_4_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextCHARACTERSIZE
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_decl_funcname_3_
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_funcname_3_ -- "type" [type parameters] [RECURSIVE] FUNCTION 			     NAME ASTERISK OPEN_PAREN expr     (ffestb_decl_funcname_3_)  // to expression handler     Allow only CLOSE_PAREN; and deal with character-length expression.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_3_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
switch|switch
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
condition|)
block|{
case|case
name|FFESTP_typeCHARACTER
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|==
name|NULL
condition|)
block|{
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|expr
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
block|}
else|else
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_funcname_4_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_funcname_4_ -- "type" [type parameters] [RECURSIVE] FUNCTION 			     NAME [type parameter]     return ffestb_decl_funcname_4_;  // to lexer     Make sure the next token is an OPEN_PAREN.  Get the arg list and    then implement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_4_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
operator|=
name|ffestt_tokenlist_create
argument_list|()
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_funcname_5_
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|is_subr
operator|=
name|FALSE
expr_stmt|;
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|names
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_subr_name_list_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_funcname_5_ -- "type" [type parameters] [RECURSIVE] FUNCTION 			     NAME [type parameter] OPEN_PAREN arg-list 			     CLOSE_PAREN     return ffestb_decl_funcname_5_;  // to lexer     Must have EOS/SEMICOLON or "RESULT" here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|ok
condition|)
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1219
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|,
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffestr_other
argument_list|(
name|t
argument_list|)
operator|!=
name|FFESTR_otherRESULT
condition|)
break|break;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_funcname_6_
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_funcname_6_ -- "type" [type parameters] [RECURSIVE] FUNCTION 			     NAME [type parameter] OPEN_PAREN arglist 			     CLOSE_PAREN "RESULT"     return ffestb_decl_funcname_6_;  // to lexer     Make sure the next token is an OPEN_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_6_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_funcname_7_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_funcname_7_ -- "type" [type parameters] [RECURSIVE] FUNCTION 			     NAME [type parameter] OPEN_PAREN arglist 			     CLOSE_PAREN "RESULT" OPEN_PAREN     return ffestb_decl_funcname_7_;  // to lexer     Make sure the next token is a NAME.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_7_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_funcname_8_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_funcname_8_ -- "type" [type parameters] [RECURSIVE] FUNCTION 			     NAME [type parameter] OPEN_PAREN arglist 			     CLOSE_PAREN "RESULT" OPEN_PAREN NAME     return ffestb_decl_funcname_8_;  // to lexer     Make sure the next token is a CLOSE_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_8_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_funcname_9_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_funcname_9_ -- "type" [type parameters] [RECURSIVE] FUNCTION 			     NAME [type parameter] OPEN_PAREN arg-list 			     CLOSE_PAREN "RESULT" OPEN_PAREN NAME CLOSE_PAREN     return ffestb_decl_funcname_9_;  // to lexer     Must have EOS/SEMICOLON here.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_funcname_9_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R1219
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|,
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|,
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|close_paren
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_subrargs_
operator|.
name|name_list
operator|.
name|args
argument_list|)
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"FUNCTION"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_V027 -- Parse the VXT PARAMETER statement     return ffestb_V027;	// to lexer     Make sure the statement has a valid form for the VXT PARAMETER statement.    If it does, implement the statement.	 */
end_comment

begin_function
name|ffelexHandler
name|ffestb_V027
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffeTokenLength
name|i
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstPARAMETER
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
break|break;
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|vxtparam
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V027_start
argument_list|()
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_V0271_
return|;
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstPARAMETER
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlPARAMETER
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
break|break;
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_i
goto|;
comment|/* :::::::::::::::::::: */
name|ffestb_local_
operator|.
name|vxtparam
operator|.
name|started
operator|=
name|FALSE
expr_stmt|;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_V0271_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PARAMETER"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PARAMETER"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
name|bad_i
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1sp
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PARAMETER"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_V0271_ -- "PARAMETER" NAME     return ffestb_V0271_;  // to lexer     Handle EQUALS.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_V0271_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEQUALS
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffesta_output_pool
argument_list|,
name|FFEEXPR_contextPARAMETER
argument_list|,
operator|(
name|ffeexprCallback
operator|)
name|ffestb_V0272_
argument_list|)
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PARAMETER"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|vxtparam
operator|.
name|started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V027_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_V0272_ -- "PARAMETER" NAME EQUALS expr     (ffestb_V0272_)  // to expression handler     Handle COMMA or EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_V0272_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|vxtparam
operator|.
name|started
condition|)
block|{
if|if
condition|(
name|ffestc_is_let_not_V027
argument_list|()
condition|)
break|break;
comment|/* Not a valid VXTPARAMETER stmt. */
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V027_start
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|vxtparam
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
block|{
name|ffestc_V027_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffestc_V027_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeCOMMA
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|vxtparam
operator|.
name|started
condition|)
block|{
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V027_start
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|vxtparam
operator|.
name|started
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V027_item
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_V0273_
return|;
default|default:
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|vxtparam
operator|.
name|started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V027_finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PARAMETER"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_V0273_ -- "PARAMETER" NAME EQUALS expr COMMA     return ffestb_V0273_;  // to lexer     Handle NAME.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_V0273_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_V0271_
return|;
default|default:
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"PARAMETER"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|vxtparam
operator|.
name|started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_V027_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R539 -- Parse the IMPLICIT FUNCTION statement     return ffestb_decl_R539;  // to lexer     Make sure the statement has a valid form for the IMPLICIT    statement.  If it does, implement the statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffestb_decl_R539
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeTokenLength
name|i
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ffelexToken
name|nt
decl_stmt|;
name|ffestrSecond
name|kw
decl_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|recursive
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstIMPLICIT
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
comment|/* Error, but clearly intended. */
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFELEX_typeNAME
case|:
break|break;
block|}
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|ffesta_second_kw
condition|)
block|{
case|case
name|FFESTR_secondINTEGER
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeINTEGER
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
return|;
case|case
name|FFESTR_secondBYTE
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeBYTE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
return|;
case|case
name|FFESTR_secondWORD
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeWORD
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
return|;
case|case
name|FFESTR_secondREAL
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeREAL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
return|;
case|case
name|FFESTR_secondCOMPLEX
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeCOMPLEX
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
return|;
case|case
name|FFESTR_secondLOGICAL
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeLOGICAL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
return|;
case|case
name|FFESTR_secondCHARACTER
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeCHARACTER
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
return|;
case|case
name|FFESTR_secondDOUBLE
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5392_
return|;
case|case
name|FFESTR_secondDOUBLEPRECISION
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeDBLPRCSN
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_
return|;
case|case
name|FFESTR_secondDOUBLECOMPLEX
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeDBLCMPLX
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_
return|;
case|case
name|FFESTR_secondNONE
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5394_
return|;
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
name|ffesta_first_kw
operator|!=
name|FFESTR_firstIMPLICIT
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLONCOLON
case|:
case|case
name|FFELEX_typeASTERISK
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
case|case
name|FFELEX_typeEOS
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
break|break;
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|i
operator|=
name|FFESTR_firstlIMPLICIT
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
operator|=
name|FALSE
expr_stmt|;
name|nt
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|FFESTR_firstlIMPLICIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kw
operator|=
name|ffestr_second
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|nt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kw
condition|)
block|{
case|case
name|FFESTR_secondINTEGER
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeINTEGER
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFESTR_secondBYTE
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeBYTE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFESTR_secondWORD
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeWORD
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFESTR_secondREAL
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeREAL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFESTR_secondCOMPLEX
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeCOMPLEX
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFESTR_secondLOGICAL
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeLOGICAL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFESTR_secondCHARACTER
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeCHARACTER
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFESTR_secondDOUBLEPRECISION
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeDBLPRCSN
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFESTR_secondDOUBLECOMPLEX
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeDBLCMPLX
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFESTR_secondNONE
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5394_
argument_list|(
name|t
argument_list|)
return|;
default|default:
goto|goto
name|bad_1
goto|;
comment|/* :::::::::::::::::::: */
block|}
default|default:
goto|goto
name|bad_0
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|bad_0
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IMPLICIT"
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
name|bad_1
label|:
comment|/* :::::::::::::::::::: */
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IMPLICIT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
comment|/* Invalid second token. */
block|}
end_function

begin_comment
comment|/* ffestb_decl_R5391_ -- "IMPLICIT" generic-type     return ffestb_decl_R5391_;  // to lexer     Handle ASTERISK or OPEN_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R5391_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeASTERISK
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
operator|=
literal|"IMPLICIT"
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|==
name|FFESTP_typeCHARACTER
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_starlen_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_starkind_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|badname
operator|=
literal|"IMPLICIT"
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|==
name|FFESTP_typeCHARACTER
condition|)
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_typeparams_
expr_stmt|;
else|else
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_handler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_kindparam_
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539maybe_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IMPLICIT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R5392_ -- "IMPLICIT" "DOUBLE"     return ffestb_decl_R5392_;  // to lexer     Handle NAME.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R5392_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffestr_second
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFESTR_secondPRECISION
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeDBLPRCSN
expr_stmt|;
break|break;
case|case
name|FFESTR_secondCOMPLEX
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeDBLCMPLX
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_
return|;
default|default:
break|break;
block|}
name|bad
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IMPLICIT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R5394_ -- "IMPLICIT" "NONE"     return ffestb_decl_R5394_;  // to lexer     Handle EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R5394_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539
argument_list|()
expr_stmt|;
comment|/* IMPLICIT NONE. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IMPLICIT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R5395_ -- "IMPLICIT" implicit-spec-list COMMA     return ffestb_decl_R5395_;  // to lexer     Handle NAME for next type-spec.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R5395_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffestr_second
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFESTR_secondINTEGER
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeINTEGER
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
return|;
case|case
name|FFESTR_secondBYTE
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeBYTE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
return|;
case|case
name|FFESTR_secondWORD
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeWORD
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
return|;
case|case
name|FFESTR_secondREAL
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeREAL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
return|;
case|case
name|FFESTR_secondCOMPLEX
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeCOMPLEX
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
return|;
case|case
name|FFESTR_secondLOGICAL
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeLOGICAL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
return|;
case|case
name|FFESTR_secondCHARACTER
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeCHARACTER
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5391_
return|;
case|case
name|FFESTR_secondDOUBLE
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5392_
return|;
case|case
name|FFESTR_secondDOUBLEPRECISION
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeDBLPRCSN
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_
return|;
case|case
name|FFESTR_secondDOUBLECOMPLEX
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|=
name|FFESTP_typeDBLCMPLX
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
operator|=
name|NULL
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_
return|;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IMPLICIT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R539letters_ -- "IMPLICIT" type-spec     return ffestb_decl_R539letters_;  // to lexer     Handle OPEN_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R539letters_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelex_set_names
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
operator|=
name|ffestt_implist_create
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_1_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IMPLICIT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R539letters_1_ -- "IMPLICIT" type-spec OPEN_PAREN     return ffestb_decl_R539letters_1_;  // to lexer     Handle NAME.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R539letters_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|!=
literal|1
condition|)
break|break;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_2_
return|;
default|default:
break|break;
block|}
name|ffestt_implist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IMPLICIT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R539letters_2_ -- "IMPLICIT" type-spec OPEN_PAREN NAME     return ffestb_decl_R539letters_2_;  // to lexer     Handle COMMA or MINUS.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R539letters_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
name|ffestt_implist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_1_
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestt_implist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_5_
return|;
case|case
name|FFELEX_typeMINUS
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_3_
return|;
default|default:
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestt_implist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IMPLICIT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R539letters_3_ -- "IMPLICIT" type-spec OPEN_PAREN NAME MINUS     return ffestb_decl_R539letters_3_;  // to lexer     Handle NAME.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R539letters_3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|!=
literal|1
condition|)
break|break;
name|ffestt_implist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_4_
return|;
default|default:
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestt_implist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IMPLICIT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R539letters_4_ -- "IMPLICIT" type-spec OPEN_PAREN NAME MINUS 				 NAME     return ffestb_decl_R539letters_4_;  // to lexer     Handle COMMA or CLOSE_PAREN.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R539letters_4_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_1_
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_5_
return|;
default|default:
break|break;
block|}
name|ffestt_implist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IMPLICIT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R539letters_5_ -- "IMPLICIT" type-spec OPEN_PAREN 				 letter-spec-list CLOSE_PAREN     return ffestb_decl_R539letters_5_;  // to lexer     Handle COMMA or EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R539letters_5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
condition|)
block|{
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
operator|=
name|TRUE
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539start
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539item
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffestt_implist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5395_
return|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestt_implist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IMPLICIT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R539maybe_ -- "IMPLICIT" generic-type-spec     return ffestb_decl_R539maybe_;  // to lexer     Handle OPEN_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R539maybe_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeOPEN_PAREN
argument_list|)
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
operator|=
name|ffestt_implist_create
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
operator|=
name|ffestt_tokenlist_create
argument_list|()
expr_stmt|;
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_seen_comma
operator|=
operator|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
operator|!=
name|FFESTP_typeCHARACTER
operator|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539maybe_1_
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R539maybe_1_ -- "IMPLICIT" generic-type-spec OPEN_PAREN     return ffestb_decl_R539maybe_1_;  // to lexer     Handle NAME.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R539maybe_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|!=
literal|1
condition|)
break|break;
name|ffesta_tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539maybe_2_
return|;
default|default:
break|break;
block|}
name|ffestt_implist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestt_tokenlist_handle
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_handler
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R539maybe_2_ -- "IMPLICIT" generic-type-spec OPEN_PAREN NAME     return ffestb_decl_R539maybe_2_;  // to lexer     Handle COMMA or MINUS.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R539maybe_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
name|ffestt_implist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_seen_comma
condition|)
block|{
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_1_
return|;
block|}
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_seen_comma
operator|=
name|TRUE
expr_stmt|;
name|ffestt_tokenlist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539maybe_1_
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestt_implist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539maybe_5_
return|;
case|case
name|FFELEX_typeMINUS
case|:
name|ffestt_tokenlist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539maybe_3_
return|;
default|default:
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestt_implist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestt_tokenlist_handle
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_handler
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R539maybe_3_ -- "IMPLICIT" type-spec OPEN_PAREN NAME MINUS     return ffestb_decl_R539maybe_3_;  // to lexer     Handle NAME.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R539maybe_3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
if|if
condition|(
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|!=
literal|1
condition|)
break|break;
name|ffestt_implist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|,
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539maybe_4_
return|;
default|default:
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffesta_tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffestt_implist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestt_tokenlist_handle
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_handler
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R539maybe_4_ -- "IMPLICIT" type-spec OPEN_PAREN NAME MINUS 				 NAME     return ffestb_decl_R539maybe_4_;  // to lexer     Handle COMMA or CLOSE_PAREN.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R539maybe_4_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_seen_comma
condition|)
block|{
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539letters_1_
return|;
block|}
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_seen_comma
operator|=
name|TRUE
expr_stmt|;
name|ffestt_tokenlist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539maybe_1_
return|;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffestt_tokenlist_append
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R539maybe_5_
return|;
default|default:
break|break;
block|}
name|ffestt_implist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestt_tokenlist_handle
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_handler
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestb_decl_R539maybe_5_ -- "IMPLICIT" type-spec OPEN_PAREN 				 letter-spec-list CLOSE_PAREN     return ffestb_decl_R539maybe_5_;  // to lexer     Handle COMMA or EOS/SEMICOLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffestb_decl_R539maybe_5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
condition|)
block|{
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
operator|=
name|TRUE
expr_stmt|;
name|ffesta_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539start
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539item
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|type
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kind
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|len
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|,
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
name|ffestt_implist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffestb_decl_R5395_
return|;
if|if
condition|(
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffesta_confirmed
argument_list|()
expr_stmt|;
name|ffestt_implist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffestt_tokenlist_handle
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_handler
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|ffestt_implist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imps
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|toklist
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|kindt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|lent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestb_local_
operator|.
name|decl
operator|.
name|imp_started
operator|&&
operator|!
name|ffesta_is_inhibited
argument_list|()
condition|)
name|ffestc_R539finish
argument_list|()
expr_stmt|;
name|ffesta_ffebad_1st
argument_list|(
name|FFEBAD_INVALID_STMT_FORM
argument_list|,
literal|"IMPLICIT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffesta_zero
argument_list|)
return|;
block|}
end_function

end_unit

