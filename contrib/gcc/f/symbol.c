begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implementation of Fortran symbol manager    Copyright (C) 1995, 1996, 1997, 2003    Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_include
include|#
directive|include
file|"bad.h"
end_include

begin_include
include|#
directive|include
file|"bld.h"
end_include

begin_include
include|#
directive|include
file|"com.h"
end_include

begin_include
include|#
directive|include
file|"equiv.h"
end_include

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"intrin.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"src.h"
end_include

begin_include
include|#
directive|include
file|"st.h"
end_include

begin_include
include|#
directive|include
file|"storag.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"where.h"
end_include

begin_comment
comment|/* Choice of how to handle global symbols -- either global only within the    program unit being defined or global within the entire source file.    The former is appropriate for systems where an object file can    easily be taken apart program unit by program unit, the latter is the    UNIX/C model where the object file is essentially a monolith.  */
end_comment

begin_define
define|#
directive|define
name|FFESYMBOL_globalPROGUNIT_
value|1
end_define

begin_define
define|#
directive|define
name|FFESYMBOL_globalFILE_
value|2
end_define

begin_comment
comment|/* Choose how to handle global symbols here.  */
end_comment

begin_comment
comment|/* Would be good to understand why PROGUNIT in this case too.    (1995-08-22).  */
end_comment

begin_define
define|#
directive|define
name|FFESYMBOL_globalCURRENT_
value|FFESYMBOL_globalPROGUNIT_
end_define

begin_comment
comment|/* Choose how to handle memory pools based on global symbol stuff.  */
end_comment

begin_if
if|#
directive|if
name|FFESYMBOL_globalCURRENT_
operator|==
name|FFESYMBOL_globalPROGUNIT_
end_if

begin_define
define|#
directive|define
name|FFESYMBOL_SPACE_POOL_
value|ffe_pool_program_unit()
end_define

begin_elif
elif|#
directive|elif
name|FFESYMBOL_globalCURRENT_
operator|==
name|FFESYMBOL_globalFILE_
end_elif

begin_define
define|#
directive|define
name|FFESYMBOL_SPACE_POOL_
value|ffe_pool_file()
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* What kind of retraction is needed for a symbol?  */
end_comment

begin_enum
enum|enum
name|_ffesymbol_retractcommand_
block|{
name|FFESYMBOL_retractcommandDELETE_
block|,
name|FFESYMBOL_retractcommandRETRACT_
block|,
name|FFESYMBOL_retractcommand_
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
name|enum
name|_ffesymbol_retractcommand_
name|ffesymbolRetractCommand_
typedef|;
end_typedef

begin_comment
comment|/* This object keeps track of retraction for a symbol and links to the next    such object.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|_ffesymbol_retract_
modifier|*
name|ffesymbolRetract_
typedef|;
end_typedef

begin_struct
struct|struct
name|_ffesymbol_retract_
block|{
name|ffesymbolRetract_
name|next
decl_stmt|;
name|ffesymbolRetractCommand_
name|command
decl_stmt|;
name|ffesymbol
name|live
decl_stmt|;
comment|/* Live symbol. */
name|ffesymbol
name|symbol
decl_stmt|;
comment|/* Backup copy of symbol. */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|ffebad
name|ffesymbol_check_token_
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|char
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffesymbol_kill_manifest_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffesymbol_new_
parameter_list|(
name|ffename
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffesymbol_unhook_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffesymbol_whine_state_
parameter_list|(
name|ffebad
name|bad
parameter_list|,
name|ffelexToken
name|t
parameter_list|,
name|char
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Manifest names for unnamed things (as tokens) so we make them only    once.  */
end_comment

begin_decl_stmt
specifier|static
name|ffelexToken
name|ffesymbol_token_blank_common_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffelexToken
name|ffesymbol_token_unnamed_main_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffelexToken
name|ffesymbol_token_unnamed_blockdata_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name spaces currently in force.  */
end_comment

begin_decl_stmt
specifier|static
name|ffenameSpace
name|ffesymbol_global_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffenameSpace
name|ffesymbol_local_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffenameSpace
name|ffesymbol_sfunc_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep track of retraction.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffesymbol_retractable_
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mallocPool
name|ffesymbol_retract_pool_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffesymbolRetract_
name|ffesymbol_retract_first_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffesymbolRetract_
modifier|*
name|ffesymbol_retract_list_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of state names. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ffesymbol_state_name_
index|[]
init|=
block|{
literal|"?"
block|,
literal|"@"
block|,
literal|"&"
block|,
literal|"$"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of attribute names. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ffesymbol_attr_name_
index|[]
init|=
block|{
define|#
directive|define
name|DEFATTR
parameter_list|(
name|ATTR
parameter_list|,
name|ATTRS
parameter_list|,
name|NAME
parameter_list|)
value|NAME,
include|#
directive|include
file|"symbol.def"
undef|#
directive|undef
name|DEFATTR
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Check whether the token text has any invalid characters.  If not,    return FALSE.  If so, if error messages inhibited, return TRUE    so caller knows to try again later, else report error and return    FALSE.  */
end_comment

begin_function
specifier|static
name|ffebad
name|ffesymbol_check_token_
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|char
modifier|*
name|c
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|ffeTokenLength
name|len
init|=
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|ffebad
name|bad
decl_stmt|;
name|ffeTokenLength
name|i
init|=
literal|0
decl_stmt|;
name|ffebad
name|skip_me
init|=
operator|(
operator|(
name|ffe_case_symbol
argument_list|()
operator|==
name|FFE_caseINITCAP
operator|)
condition|?
name|FFEBAD_SYMBOL_NOLOWER_INITCAP
else|:
name|FFEBAD
operator|+
literal|1
operator|)
decl_stmt|;
name|ffebad
name|stop_me
init|=
operator|(
operator|(
name|ffe_case_symbol
argument_list|()
operator|==
name|FFE_caseINITCAP
operator|)
condition|?
name|FFEBAD
else|:
name|FFEBAD
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|FFEBAD
return|;
name|bad
operator|=
name|ffesrc_bad_char_symbol_init
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|==
name|FFEBAD
condition|)
block|{
for|for
control|(
operator|++
name|i
operator|,
operator|++
name|p
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
operator|,
operator|++
name|p
control|)
block|{
name|bad
operator|=
name|ffesrc_bad_char_symbol_noninit
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|==
name|skip_me
condition|)
continue|continue;
comment|/* Keep looking for good InitCap character. */
if|if
condition|(
name|bad
operator|==
name|stop_me
condition|)
break|break;
comment|/* Found good InitCap character. */
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
break|break;
comment|/* Bad character found. */
block|}
block|}
if|if
condition|(
name|bad
operator|!=
name|FFEBAD
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|len
condition|)
operator|*
name|c
operator|=
operator|*
operator|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
operator|)
expr_stmt|;
else|else
operator|*
name|c
operator|=
operator|*
name|p
expr_stmt|;
block|}
return|return
name|bad
return|;
block|}
end_function

begin_comment
comment|/* Kill manifest (g77-picked) names.  */
end_comment

begin_function
specifier|static
name|void
name|ffesymbol_kill_manifest_
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ffesymbol_token_blank_common_
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesymbol_token_blank_common_
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_token_unnamed_main_
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesymbol_token_unnamed_main_
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_token_unnamed_blockdata_
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffesymbol_token_unnamed_blockdata_
argument_list|)
expr_stmt|;
name|ffesymbol_token_blank_common_
operator|=
name|NULL
expr_stmt|;
name|ffesymbol_token_unnamed_main_
operator|=
name|NULL
expr_stmt|;
name|ffesymbol_token_unnamed_blockdata_
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make new symbol.     If the "retractable" flag is not set, just return the new symbol.    Else, add symbol to the "retract" list as a delete item, set    the "have_old" flag, and return the new symbol.  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffesymbol_new_
parameter_list|(
name|ffename
name|n
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbolRetract_
name|r
decl_stmt|;
name|assert
argument_list|(
name|n
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|malloc_new_ks
argument_list|(
name|FFESYMBOL_SPACE_POOL_
argument_list|,
literal|"FFESYMBOL"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|n
expr_stmt|;
name|s
operator|->
name|other_space_name
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|FFEGLOBAL_ENABLED
name|s
operator|->
name|global
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|s
operator|->
name|attrs
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|FFESYMBOL_stateNONE
expr_stmt|;
name|s
operator|->
name|info
operator|=
name|ffeinfo_new_null
argument_list|()
expr_stmt|;
name|s
operator|->
name|dims
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|extents
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|dim_syms
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|array_size
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|init
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|accretion
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|accretes
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|dummy_args
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|namelist
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|common_list
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|sfunc_expr
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|list_bottom
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|common
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|equiv
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|storage
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|hook
operator|=
name|FFECOM_symbolNULL
expr_stmt|;
name|s
operator|->
name|sfa_dummy_parent
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|func_result
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|check_state
operator|=
name|FFESYMBOL_checkstateNONE_
expr_stmt|;
name|s
operator|->
name|check_token
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|max_entry_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|num_entries
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|generic
operator|=
name|FFEINTRIN_genNONE
expr_stmt|;
name|s
operator|->
name|specific
operator|=
name|FFEINTRIN_specNONE
expr_stmt|;
name|s
operator|->
name|implementation
operator|=
name|FFEINTRIN_impNONE
expr_stmt|;
name|s
operator|->
name|is_save
operator|=
name|FALSE
expr_stmt|;
name|s
operator|->
name|is_init
operator|=
name|FALSE
expr_stmt|;
name|s
operator|->
name|do_iter
operator|=
name|FALSE
expr_stmt|;
name|s
operator|->
name|reported
operator|=
name|FALSE
expr_stmt|;
name|s
operator|->
name|explicit_where
operator|=
name|FALSE
expr_stmt|;
name|s
operator|->
name|namelisted
operator|=
name|FALSE
expr_stmt|;
name|s
operator|->
name|assigned
operator|=
name|FALSE
expr_stmt|;
name|ffename_set_symbol
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesymbol_retractable_
condition|)
block|{
name|s
operator|->
name|have_old
operator|=
name|FALSE
expr_stmt|;
return|return
name|s
return|;
block|}
name|r
operator|=
name|malloc_new_kp
argument_list|(
name|ffesymbol_retract_pool_
argument_list|,
literal|"FFESYMBOL retract"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|command
operator|=
name|FFESYMBOL_retractcommandDELETE_
expr_stmt|;
name|r
operator|->
name|live
operator|=
name|s
expr_stmt|;
name|r
operator|->
name|symbol
operator|=
name|NULL
expr_stmt|;
comment|/* No backup copy. */
operator|*
name|ffesymbol_retract_list_
operator|=
name|r
expr_stmt|;
name|ffesymbol_retract_list_
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|s
operator|->
name|have_old
operator|=
name|TRUE
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Unhook a symbol from its (soon-to-be-killed) name obj.     NULLify the names to which this symbol points.  Do other cleanup as    needed.  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffesymbol_unhook_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|s
operator|->
name|other_space_name
operator|=
name|s
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
operator|&
name|FFESYMBOL_attrsCBLOCK
operator|)
operator|||
operator|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_kindNAMELIST
operator|)
condition|)
name|ffebld_end_list
argument_list|(
name|ffesymbol_ptr_to_listbottom
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|check_state
operator|==
name|FFESYMBOL_checkstatePENDING_
condition|)
name|ffelex_token_kill
argument_list|(
name|s
operator|->
name|check_token
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Issue diagnostic about bad character in token representing user-defined    symbol name.	 */
end_comment

begin_function
specifier|static
name|void
name|ffesymbol_whine_state_
parameter_list|(
name|ffebad
name|bad
parameter_list|,
name|ffelexToken
name|t
parameter_list|,
name|char
name|c
parameter_list|)
block|{
name|char
name|badstr
index|[
literal|2
index|]
decl_stmt|;
name|badstr
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|badstr
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ffebad_start
argument_list|(
name|bad
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|badstr
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns a string representing the attributes set.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ffesymbol_attrs_string
parameter_list|(
name|ffesymbolAttrs
name|attrs
parameter_list|)
block|{
specifier|static
name|char
name|string
index|[
name|FFESYMBOL_attr
operator|*
literal|12
operator|+
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|ffesymbolAttr
name|attr
decl_stmt|;
name|p
operator|=
operator|&
name|string
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|attrs
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"NONE"
argument_list|)
expr_stmt|;
return|return
operator|&
name|string
index|[
literal|0
index|]
return|;
block|}
for|for
control|(
name|attr
operator|=
literal|0
init|;
name|attr
operator|<
name|FFESYMBOL_attr
condition|;
operator|++
name|attr
control|)
block|{
if|if
condition|(
name|attrs
operator|&
operator|(
operator|(
name|ffesymbolAttrs
operator|)
literal|1
operator|<<
name|attr
operator|)
condition|)
block|{
name|attrs
operator|&=
operator|~
operator|(
operator|(
name|ffesymbolAttrs
operator|)
literal|1
operator|<<
name|attr
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|ffesymbol_attr_name_
index|[
name|attr
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
operator|++
name|p
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'|'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|attrs
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"?0x%"
name|ffesymbolAttrs_f
literal|"x?"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
operator|&
name|string
index|[
literal|0
index|]
argument_list|)
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|string
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/* Check symbol's name for validity, considering that it might actually    be an intrinsic and thus should not be complained about just yet.  */
end_comment

begin_function
name|void
name|ffesymbol_check
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|,
name|bool
name|maybe_intrin
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|ffebad
name|bad
decl_stmt|;
name|ffeintrinGen
name|gen
decl_stmt|;
name|ffeintrinSpec
name|spec
decl_stmt|;
name|ffeintrinImp
name|imp
decl_stmt|;
if|if
condition|(
operator|!
name|ffesrc_check_symbol
argument_list|()
operator|||
operator|(
operator|(
name|s
operator|->
name|check_state
operator|!=
name|FFESYMBOL_checkstateNONE_
operator|)
operator|&&
operator|(
operator|(
name|s
operator|->
name|check_state
operator|!=
name|FFESYMBOL_checkstateINHIBITED_
operator|)
operator|||
name|ffebad_inhibit
argument_list|()
operator|)
operator|)
condition|)
return|return;
name|bad
operator|=
name|ffesymbol_check_token_
argument_list|(
name|t
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|==
name|FFEBAD
condition|)
block|{
name|s
operator|->
name|check_state
operator|=
name|FFESYMBOL_checkstateCHECKED_
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|maybe_intrin
operator|&&
name|ffeintrin_is_intrinsic
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
operator|&
name|gen
argument_list|,
operator|&
name|spec
argument_list|,
operator|&
name|imp
argument_list|)
condition|)
block|{
name|s
operator|->
name|check_state
operator|=
name|FFESYMBOL_checkstatePENDING_
expr_stmt|;
name|s
operator|->
name|check_token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ffebad_inhibit
argument_list|()
condition|)
block|{
name|s
operator|->
name|check_state
operator|=
name|FFESYMBOL_checkstateINHIBITED_
expr_stmt|;
return|return;
comment|/* Don't complain now, do it later. */
block|}
name|s
operator|->
name|check_state
operator|=
name|FFESYMBOL_checkstateCHECKED_
expr_stmt|;
name|ffesymbol_whine_state_
argument_list|(
name|bad
argument_list|,
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Declare a BLOCKDATA unit.     Retrieves or creates the ffesymbol for the specified BLOCKDATA (unnamed    if t is NULL).  Doesn't actually ensure the named item is a    BLOCKDATA; the caller must handle that.  */
end_comment

begin_function
name|ffesymbol
name|ffesymbol_declare_blockdataunit
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|ffewhereLine
name|wl
parameter_list|,
name|ffewhereColumn
name|wc
parameter_list|)
block|{
name|ffename
name|n
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|bool
name|user
init|=
operator|(
name|t
operator|!=
name|NULL
operator|)
decl_stmt|;
name|assert
argument_list|(
operator|!
name|ffesymbol_retractable_
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ffesymbol_token_unnamed_blockdata_
operator|==
name|NULL
condition|)
name|ffesymbol_token_unnamed_blockdata_
operator|=
name|ffelex_token_new_name
argument_list|(
name|FFETARGET_nameUNNAMED_BLOCK_DATA
argument_list|,
name|wl
argument_list|,
name|wc
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffesymbol_token_unnamed_blockdata_
expr_stmt|;
block|}
name|n
operator|=
name|ffename_lookup
argument_list|(
name|ffesymbol_local_
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
return|return
name|ffename_symbol
argument_list|(
name|n
argument_list|)
return|;
comment|/* This will become an error. */
name|n
operator|=
name|ffename_find
argument_list|(
name|ffesymbol_global_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffename_symbol
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|user
condition|)
name|ffesymbol_check
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|s
operator|=
name|ffesymbol_new_
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
condition|)
name|ffesymbol_check
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* A program unit name also is in the local name space. */
name|n
operator|=
name|ffename_find
argument_list|(
name|ffesymbol_local_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffename_set_symbol
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|other_space_name
operator|=
name|n
expr_stmt|;
name|ffeglobal_new_blockdata
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Detect conflicts, when 					   appropriate. */
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Declare a common block (named or unnamed).     Retrieves or creates the ffesymbol for the specified common block (blank    common if t is NULL).  Doesn't actually ensure the named item is a    common block; the caller must handle that.  */
end_comment

begin_function
name|ffesymbol
name|ffesymbol_declare_cblock
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|ffewhereLine
name|wl
parameter_list|,
name|ffewhereColumn
name|wc
parameter_list|)
block|{
name|ffename
name|n
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|bool
name|blank
decl_stmt|;
name|assert
argument_list|(
operator|!
name|ffesymbol_retractable_
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
name|blank
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ffesymbol_token_blank_common_
operator|==
name|NULL
condition|)
name|ffesymbol_token_blank_common_
operator|=
name|ffelex_token_new_name
argument_list|(
name|FFETARGET_nameBLANK_COMMON
argument_list|,
name|wl
argument_list|,
name|wc
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffesymbol_token_blank_common_
expr_stmt|;
block|}
else|else
name|blank
operator|=
name|FALSE
expr_stmt|;
name|n
operator|=
name|ffename_find
argument_list|(
name|ffesymbol_global_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffename_symbol
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|blank
condition|)
name|ffesymbol_check
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|s
operator|=
name|ffesymbol_new_
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blank
condition|)
name|ffesymbol_check
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffeglobal_new_common
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|blank
argument_list|)
expr_stmt|;
comment|/* Detect conflicts. */
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Declare a FUNCTION program unit (with distinct RESULT() name).     Retrieves or creates the ffesymbol for the specified function.  Doesn't    actually ensure the named item is a function; the caller must handle    that.     If FUNCTION with RESULT() is specified but the names are the same,    pretend as though RESULT() was not specified, and don't call this    function; use ffesymbol_declare_funcunit() instead.	*/
end_comment

begin_function
name|ffesymbol
name|ffesymbol_declare_funcnotresunit
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffename
name|n
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|ffesymbol_retractable_
argument_list|)
expr_stmt|;
name|n
operator|=
name|ffename_lookup
argument_list|(
name|ffesymbol_local_
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
return|return
name|ffename_symbol
argument_list|(
name|n
argument_list|)
return|;
comment|/* This will become an error. */
name|n
operator|=
name|ffename_find
argument_list|(
name|ffesymbol_global_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffename_symbol
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|ffesymbol_check
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|s
operator|=
name|ffesymbol_new_
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|ffesymbol_check
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* A FUNCTION program unit name also is in the local name space; handle it      here since RESULT() is a different name and is handled separately. */
name|n
operator|=
name|ffename_find
argument_list|(
name|ffesymbol_local_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffename_set_symbol
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|other_space_name
operator|=
name|n
expr_stmt|;
name|ffeglobal_new_function
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Detect conflicts, when appropriate. */
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Declare a function result.     Retrieves or creates the ffesymbol for the specified function result,    whether specified via a distinct RESULT() or by default in a FUNCTION or    ENTRY statement.  */
end_comment

begin_function
name|ffesymbol
name|ffesymbol_declare_funcresult
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffename
name|n
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|ffesymbol_retractable_
argument_list|)
expr_stmt|;
name|n
operator|=
name|ffename_find
argument_list|(
name|ffesymbol_local_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffename_symbol
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
return|return
name|s
return|;
return|return
name|ffesymbol_new_
argument_list|(
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Declare a FUNCTION program unit with no RESULT().     Retrieves or creates the ffesymbol for the specified function.  Doesn't    actually ensure the named item is a function; the caller must handle    that.     This is the function to call when the FUNCTION or ENTRY statement has    no separate and distinct name specified via RESULT().  That's because    this function enters the global name of the function in only the global    name space.	ffesymbol_declare_funcresult() must still be called to    declare the name for the function result in the local name space.  */
end_comment

begin_function
name|ffesymbol
name|ffesymbol_declare_funcunit
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffename
name|n
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|ffesymbol_retractable_
argument_list|)
expr_stmt|;
name|n
operator|=
name|ffename_find
argument_list|(
name|ffesymbol_global_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffename_symbol
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|ffesymbol_check
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|s
operator|=
name|ffesymbol_new_
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|ffesymbol_check
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffeglobal_new_function
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Detect conflicts. */
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Declare a local entity.     Retrieves or creates the ffesymbol for the specified local entity.    Set maybe_intrin TRUE if this name might turn out to name an    intrinsic (legitimately); otherwise if the name doesn't meet the    requirements for a user-defined symbol name, a diagnostic will be    issued right away rather than waiting until the intrinsicness of the    symbol is determined.  */
end_comment

begin_function
name|ffesymbol
name|ffesymbol_declare_local
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|bool
name|maybe_intrin
parameter_list|)
block|{
name|ffename
name|n
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we're parsing within a statement function definition, return the      symbol if already known (a dummy argument for the statement function).      Otherwise continue on, which means the symbol is declared within the      containing (local) program unit rather than the statement function      definition.  */
if|if
condition|(
operator|(
name|ffesymbol_sfunc_
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|n
operator|=
name|ffename_lookup
argument_list|(
name|ffesymbol_sfunc_
argument_list|,
name|t
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
return|return
name|ffename_symbol
argument_list|(
name|n
argument_list|)
return|;
name|n
operator|=
name|ffename_find
argument_list|(
name|ffesymbol_local_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffename_symbol
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|ffesymbol_check
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|maybe_intrin
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|s
operator|=
name|ffesymbol_new_
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|ffesymbol_check
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|maybe_intrin
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Declare a main program unit.     Retrieves or creates the ffesymbol for the specified main program unit    (unnamed main program unit if t is NULL).  Doesn't actually ensure the    named item is a program; the caller must handle that.  */
end_comment

begin_function
name|ffesymbol
name|ffesymbol_declare_programunit
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|ffewhereLine
name|wl
parameter_list|,
name|ffewhereColumn
name|wc
parameter_list|)
block|{
name|ffename
name|n
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|bool
name|user
init|=
operator|(
name|t
operator|!=
name|NULL
operator|)
decl_stmt|;
name|assert
argument_list|(
operator|!
name|ffesymbol_retractable_
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ffesymbol_token_unnamed_main_
operator|==
name|NULL
condition|)
name|ffesymbol_token_unnamed_main_
operator|=
name|ffelex_token_new_name
argument_list|(
name|FFETARGET_nameUNNAMED_MAIN
argument_list|,
name|wl
argument_list|,
name|wc
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffesymbol_token_unnamed_main_
expr_stmt|;
block|}
name|n
operator|=
name|ffename_lookup
argument_list|(
name|ffesymbol_local_
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
return|return
name|ffename_symbol
argument_list|(
name|n
argument_list|)
return|;
comment|/* This will become an error. */
name|n
operator|=
name|ffename_find
argument_list|(
name|ffesymbol_global_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffename_symbol
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|user
condition|)
name|ffesymbol_check
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|s
operator|=
name|ffesymbol_new_
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
condition|)
name|ffesymbol_check
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* A program unit name also is in the local name space. */
name|n
operator|=
name|ffename_find
argument_list|(
name|ffesymbol_local_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffename_set_symbol
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|other_space_name
operator|=
name|n
expr_stmt|;
name|ffeglobal_new_program
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Detect conflicts. */
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Declare a statement-function dummy.     Retrieves or creates the ffesymbol for the specified statement    function dummy.  Also ensures that it has a link to the parent (local)    ffesymbol with the same name, creating it if necessary.  */
end_comment

begin_function
name|ffesymbol
name|ffesymbol_declare_sfdummy
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffename
name|n
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbol
name|sp
decl_stmt|;
comment|/* Parent symbol in local area. */
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|=
name|ffename_find
argument_list|(
name|ffesymbol_local_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|sp
operator|=
name|ffename_symbol
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|sp
operator|=
name|ffesymbol_new_
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|ffesymbol_check
argument_list|(
name|sp
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|n
operator|=
name|ffename_find
argument_list|(
name|ffesymbol_sfunc_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffename_symbol
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|ffesymbol_new_
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|sfa_dummy_parent
operator|=
name|sp
expr_stmt|;
block|}
else|else
name|assert
argument_list|(
name|s
operator|->
name|sfa_dummy_parent
operator|==
name|sp
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Declare a subroutine program unit.     Retrieves or creates the ffesymbol for the specified subroutine    Doesn't actually ensure the named item is a subroutine; the caller must    handle that.  */
end_comment

begin_function
name|ffesymbol
name|ffesymbol_declare_subrunit
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffename
name|n
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|assert
argument_list|(
operator|!
name|ffesymbol_retractable_
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|=
name|ffename_lookup
argument_list|(
name|ffesymbol_local_
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
return|return
name|ffename_symbol
argument_list|(
name|n
argument_list|)
return|;
comment|/* This will become an error. */
name|n
operator|=
name|ffename_find
argument_list|(
name|ffesymbol_global_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffename_symbol
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|ffesymbol_check
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|s
operator|=
name|ffesymbol_new_
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|ffesymbol_check
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* A program unit name also is in the local name space. */
name|n
operator|=
name|ffename_find
argument_list|(
name|ffesymbol_local_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffename_set_symbol
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|other_space_name
operator|=
name|n
expr_stmt|;
name|ffeglobal_new_subroutine
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Detect conflicts, when 					   appropriate. */
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Call given fn with all local/global symbols.     ffesymbol (*fn) (ffesymbol s);    ffesymbol_drive (fn);  */
end_comment

begin_function
name|void
name|ffesymbol_drive
parameter_list|(
name|ffesymbol
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|ffesymbol
parameter_list|)
parameter_list|)
block|{
name|assert
argument_list|(
name|ffesymbol_sfunc_
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Might be ok, but not for current 					   uses. */
name|ffename_space_drive_symbol
argument_list|(
name|ffesymbol_local_
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|ffename_space_drive_symbol
argument_list|(
name|ffesymbol_global_
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call given fn with all sfunc-only symbols.     ffesymbol (*fn) (ffesymbol s);    ffesymbol_drive_sfnames (fn);  */
end_comment

begin_function
name|void
name|ffesymbol_drive_sfnames
parameter_list|(
name|ffesymbol
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|ffesymbol
parameter_list|)
parameter_list|)
block|{
name|ffename_space_drive_symbol
argument_list|(
name|ffesymbol_sfunc_
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Produce generic error message about a symbol.     For now, just output error message using symbol's name and pointing to    the token.  */
end_comment

begin_function
name|void
name|ffesymbol_error
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|t
operator|!=
name|NULL
operator|)
operator|&&
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_SYMERR
argument_list|)
condition|)
block|{
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffesymbol_where_line
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where_column
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ffesymbol_attr
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_attrANY
argument_list|)
condition|)
return|return;
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* May need to back up to previous version. */
if|if
condition|(
operator|(
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
operator|&
name|FFESYMBOL_attrsCBLOCK
operator|)
operator|||
operator|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_kindNAMELIST
operator|)
condition|)
name|ffebld_end_list
argument_list|(
name|ffesymbol_ptr_to_listbottom
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_attr
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_attrANY
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|check_state
operator|==
name|FFESYMBOL_checkstatePENDING_
condition|)
name|ffelex_token_kill
argument_list|(
name|s
operator|->
name|check_token
argument_list|)
expr_stmt|;
name|s
operator|->
name|check_state
operator|=
name|FFESYMBOL_checkstateCHECKED_
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ffesymbol_init_0
parameter_list|(
name|void
parameter_list|)
block|{
name|ffesymbolAttrs
name|attrs
init|=
name|FFESYMBOL_attrsetNONE
decl_stmt|;
name|assert
argument_list|(
name|FFESYMBOL_state
operator|==
name|ARRAY_SIZE
argument_list|(
name|ffesymbol_state_name_
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|FFESYMBOL_attr
operator|==
name|ARRAY_SIZE
argument_list|(
name|ffesymbol_attr_name_
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|attrs
operator|==
name|FFESYMBOL_attrsetNONE
argument_list|)
expr_stmt|;
name|attrs
operator|=
operator|(
operator|(
name|ffesymbolAttrs
operator|)
literal|1
operator|<<
name|FFESYMBOL_attr
operator|)
expr_stmt|;
name|assert
argument_list|(
name|attrs
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ffesymbol_init_1
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|FFESYMBOL_globalCURRENT_
operator|==
name|FFESYMBOL_globalFILE_
name|ffesymbol_global_
operator|=
name|ffename_space_new
argument_list|(
name|ffe_pool_file
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ffesymbol_init_2
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ffesymbol_init_3
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|FFESYMBOL_globalCURRENT_
operator|==
name|FFESYMBOL_globalPROGUNIT_
name|ffesymbol_global_
operator|=
name|ffename_space_new
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ffesymbol_local_
operator|=
name|ffename_space_new
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ffesymbol_init_4
parameter_list|(
name|void
parameter_list|)
block|{
name|ffesymbol_sfunc_
operator|=
name|ffename_space_new
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up a local entity.     Retrieves the ffesymbol for the specified local entity, or returns NULL    if no local entity by that name exists.  */
end_comment

begin_function
name|ffesymbol
name|ffesymbol_lookup_local
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffename
name|n
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|=
name|ffename_lookup
argument_list|(
name|ffesymbol_local_
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|s
operator|=
name|ffename_symbol
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|s
return|;
comment|/* May be NULL here, too. */
block|}
end_function

begin_comment
comment|/* Registers the symbol as one that is referenced by the    current program unit.  Currently applies only to    symbols known to have global interest (globals and    intrinsics).     s is the (global/intrinsic) symbol referenced; t is the    referencing token; explicit is TRUE if the reference    is, e.g., INTRINSIC FOO.  */
end_comment

begin_function
name|void
name|ffesymbol_reference
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|,
name|bool
name|explicit
parameter_list|)
block|{
name|ffename
name|gn
decl_stmt|;
name|ffesymbol
name|gs
init|=
name|NULL
decl_stmt|;
name|ffeinfoKind
name|kind
decl_stmt|;
name|ffeinfoWhere
name|where
decl_stmt|;
name|bool
name|okay
decl_stmt|;
if|if
condition|(
name|ffesymbol_retractable_
condition|)
return|return;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|t
operator|=
name|ffename_token
argument_list|(
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Use the first reference in this program unit. */
name|kind
operator|=
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|where
operator|=
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
operator|==
name|FFEINFO_whereINTRINSIC
condition|)
block|{
name|ffeglobal_ref_intrinsic
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|explicit
operator|||
name|s
operator|->
name|explicit_where
operator|||
name|ffeintrin_is_standard
argument_list|(
name|s
operator|->
name|generic
argument_list|,
name|s
operator|->
name|specific
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|where
operator|!=
name|FFEINFO_whereGLOBAL
operator|)
operator|&&
operator|(
operator|(
name|where
operator|!=
name|FFEINFO_whereLOCAL
operator|)
operator|||
operator|(
operator|(
name|kind
operator|!=
name|FFEINFO_kindFUNCTION
operator|)
operator|&&
operator|(
name|kind
operator|!=
name|FFEINFO_kindSUBROUTINE
operator|)
operator|)
operator|)
condition|)
return|return;
name|gn
operator|=
name|ffename_lookup
argument_list|(
name|ffesymbol_global_
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|!=
name|NULL
condition|)
name|gs
operator|=
name|ffename_symbol
argument_list|(
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gs
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|gs
operator|!=
name|s
operator|)
condition|)
block|{
comment|/* We have just discovered another global symbol with the same name 	 but a different `nature'.  Complain.  Note that COMMON /FOO/ can 	 coexist with local symbol FOO, e.g. local variable, just not with 	 CALL FOO, hence the separate namespaces.  */
name|ffesymbol_error
argument_list|(
name|gs
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|FFEINFO_kindBLOCKDATA
case|:
name|okay
operator|=
name|ffeglobal_ref_blockdata
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindSUBROUTINE
case|:
name|okay
operator|=
name|ffeglobal_ref_subroutine
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindFUNCTION
case|:
name|okay
operator|=
name|ffeglobal_ref_function
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindNONE
case|:
name|okay
operator|=
name|ffeglobal_ref_external
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad kind in global ref"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|okay
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resolve symbol that has become known intrinsic or non-intrinsic.  */
end_comment

begin_function
name|void
name|ffesymbol_resolve_intrin
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|ffebad
name|bad
decl_stmt|;
if|if
condition|(
operator|!
name|ffesrc_check_symbol
argument_list|()
condition|)
return|return;
if|if
condition|(
name|s
operator|->
name|check_state
operator|!=
name|FFESYMBOL_checkstatePENDING_
condition|)
return|return;
if|if
condition|(
name|ffebad_inhibit
argument_list|()
condition|)
return|return;
comment|/* We'll get back to this later. */
if|if
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereINTRINSIC
condition|)
block|{
name|bad
operator|=
name|ffesymbol_check_token_
argument_list|(
name|s
operator|->
name|check_token
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|bad
operator|!=
name|FFEBAD
argument_list|)
expr_stmt|;
comment|/* How did this suddenly become ok? */
name|ffesymbol_whine_state_
argument_list|(
name|bad
argument_list|,
name|s
operator|->
name|check_token
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|check_state
operator|=
name|FFESYMBOL_checkstateCHECKED_
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|s
operator|->
name|check_token
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Retract or cancel retract list.  */
end_comment

begin_function
name|void
name|ffesymbol_retract
parameter_list|(
name|bool
name|retract
parameter_list|)
block|{
name|ffesymbolRetract_
name|r
decl_stmt|;
name|ffename
name|name
decl_stmt|;
name|ffename
name|other_space_name
decl_stmt|;
name|ffesymbol
name|ls
decl_stmt|;
name|ffesymbol
name|os
decl_stmt|;
name|assert
argument_list|(
name|ffesymbol_retractable_
argument_list|)
expr_stmt|;
name|ffesymbol_retractable_
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|r
operator|=
name|ffesymbol_retract_first_
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|ls
operator|=
name|r
operator|->
name|live
expr_stmt|;
name|os
operator|=
name|r
operator|->
name|symbol
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|command
condition|)
block|{
case|case
name|FFESYMBOL_retractcommandDELETE_
case|:
if|if
condition|(
name|retract
condition|)
block|{
name|ffecom_sym_retract
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|name
operator|=
name|ls
operator|->
name|name
expr_stmt|;
name|other_space_name
operator|=
name|ls
operator|->
name|other_space_name
expr_stmt|;
name|ffesymbol_unhook_
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|FFESYMBOL_SPACE_POOL_
argument_list|,
name|ls
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ls
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|ffename_set_symbol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|other_space_name
operator|!=
name|NULL
condition|)
name|ffename_set_symbol
argument_list|(
name|other_space_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffecom_sym_commit
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|ls
operator|->
name|have_old
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|FFESYMBOL_retractcommandRETRACT_
case|:
if|if
condition|(
name|retract
condition|)
block|{
name|ffecom_sym_retract
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|ffesymbol_unhook_
argument_list|(
name|ls
argument_list|)
expr_stmt|;
operator|*
name|ls
operator|=
operator|*
name|os
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|FFESYMBOL_SPACE_POOL_
argument_list|,
name|os
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|os
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffecom_sym_commit
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|ffesymbol_unhook_
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|FFESYMBOL_SPACE_POOL_
argument_list|,
name|os
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|ls
operator|->
name|have_old
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad command"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return retractable flag.  */
end_comment

begin_function
name|bool
name|ffesymbol_retractable
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ffesymbol_retractable_
return|;
block|}
end_function

begin_comment
comment|/* Set retractable flag, retract pool.     Between this call and ffesymbol_retract, any changes made to existing    symbols cause the previous versions of those symbols to be saved, and any    newly created symbols to have their previous nonexistence saved.  When    ffesymbol_retract is called, this information either is used to retract    the changes and new symbols, or is discarded.  */
end_comment

begin_function
name|void
name|ffesymbol_set_retractable
parameter_list|(
name|mallocPool
name|pool
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|ffesymbol_retractable_
argument_list|)
expr_stmt|;
name|ffesymbol_retractable_
operator|=
name|TRUE
expr_stmt|;
name|ffesymbol_retract_pool_
operator|=
name|pool
expr_stmt|;
name|ffesymbol_retract_list_
operator|=
operator|&
name|ffesymbol_retract_first_
expr_stmt|;
name|ffesymbol_retract_first_
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Existing symbol about to be changed; save?     Call this function before changing a symbol if it is possible that    the current actions may need to be undone (i.e. one of several possible    statement forms are being used to analyze the current system).     If the "retractable" flag is not set, just return.    Else, if the symbol's "have_old" flag is set, just return.    Else, make a copy of the symbol and add it to the "retract" list, set    the "have_old" flag, and return.  */
end_comment

begin_function
name|void
name|ffesymbol_signal_change
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|ffesymbolRetract_
name|r
decl_stmt|;
name|ffesymbol
name|sym
decl_stmt|;
if|if
condition|(
operator|!
name|ffesymbol_retractable_
operator|||
name|s
operator|->
name|have_old
condition|)
return|return;
name|r
operator|=
name|malloc_new_kp
argument_list|(
name|ffesymbol_retract_pool_
argument_list|,
literal|"FFESYMBOL retract"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|command
operator|=
name|FFESYMBOL_retractcommandRETRACT_
expr_stmt|;
name|r
operator|->
name|live
operator|=
name|s
expr_stmt|;
name|r
operator|->
name|symbol
operator|=
name|sym
operator|=
name|malloc_new_ks
argument_list|(
name|FFESYMBOL_SPACE_POOL_
argument_list|,
literal|"FFESYMBOL"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sym
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|sym
operator|=
operator|*
name|s
expr_stmt|;
comment|/* Make an exact copy of the symbol in case 				   we need it back. */
name|sym
operator|->
name|info
operator|=
name|ffeinfo_use
argument_list|(
name|s
operator|->
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|check_state
operator|==
name|FFESYMBOL_checkstatePENDING_
condition|)
name|sym
operator|->
name|check_token
operator|=
name|ffelex_token_use
argument_list|(
name|s
operator|->
name|check_token
argument_list|)
expr_stmt|;
operator|*
name|ffesymbol_retract_list_
operator|=
name|r
expr_stmt|;
name|ffesymbol_retract_list_
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|s
operator|->
name|have_old
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the string based on the state.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ffesymbol_state_string
parameter_list|(
name|ffesymbolState
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|>=
name|ARRAY_SIZE
argument_list|(
name|ffesymbol_state_name_
argument_list|)
condition|)
return|return
literal|"?\?\?"
return|;
return|return
name|ffesymbol_state_name_
index|[
name|state
index|]
return|;
block|}
end_function

begin_function
name|void
name|ffesymbol_terminate_0
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ffesymbol_terminate_1
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|FFESYMBOL_globalCURRENT_
operator|==
name|FFESYMBOL_globalFILE_
name|ffename_space_drive_symbol
argument_list|(
name|ffesymbol_global_
argument_list|,
name|ffesymbol_unhook_
argument_list|)
expr_stmt|;
name|ffename_space_kill
argument_list|(
name|ffesymbol_global_
argument_list|)
expr_stmt|;
name|ffesymbol_global_
operator|=
name|NULL
expr_stmt|;
name|ffesymbol_kill_manifest_
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ffesymbol_terminate_2
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|FFESYMBOL_globalCURRENT_
operator|==
name|FFESYMBOL_globalPROGUNIT_
name|ffesymbol_kill_manifest_
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ffesymbol_terminate_3
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|FFESYMBOL_globalCURRENT_
operator|==
name|FFESYMBOL_globalPROGUNIT_
name|ffename_space_drive_symbol
argument_list|(
name|ffesymbol_global_
argument_list|,
name|ffesymbol_unhook_
argument_list|)
expr_stmt|;
name|ffename_space_kill
argument_list|(
name|ffesymbol_global_
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ffename_space_drive_symbol
argument_list|(
name|ffesymbol_local_
argument_list|,
name|ffesymbol_unhook_
argument_list|)
expr_stmt|;
name|ffename_space_kill
argument_list|(
name|ffesymbol_local_
argument_list|)
expr_stmt|;
if|#
directive|if
name|FFESYMBOL_globalCURRENT_
operator|==
name|FFESYMBOL_globalPROGUNIT_
name|ffesymbol_global_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|ffesymbol_local_
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ffesymbol_terminate_4
parameter_list|(
name|void
parameter_list|)
block|{
name|ffename_space_drive_symbol
argument_list|(
name|ffesymbol_sfunc_
argument_list|,
name|ffesymbol_unhook_
argument_list|)
expr_stmt|;
name|ffename_space_kill
argument_list|(
name|ffesymbol_sfunc_
argument_list|)
expr_stmt|;
name|ffesymbol_sfunc_
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update INIT info to TRUE and all equiv/storage too.     If INIT flag is TRUE, does nothing.	Else sets it to TRUE and calls    on the ffeequiv and ffestorag modules to update their INIT flags if    the<s> symbol has those objects, and also updates the common area if    it exists.  */
end_comment

begin_function
name|void
name|ffesymbol_update_init
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|ffebld
name|item
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|is_init
condition|)
return|return;
name|s
operator|->
name|is_init
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|equiv
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|ffeequiv_is_init
argument_list|(
name|s
operator|->
name|equiv
argument_list|)
condition|)
name|ffeequiv_update_init
argument_list|(
name|s
operator|->
name|equiv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|storage
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|ffestorag_is_init
argument_list|(
name|s
operator|->
name|storage
argument_list|)
condition|)
name|ffestorag_update_init
argument_list|(
name|s
operator|->
name|storage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|common
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|!
name|ffesymbol_is_init
argument_list|(
name|s
operator|->
name|common
argument_list|)
operator|)
condition|)
name|ffesymbol_update_init
argument_list|(
name|s
operator|->
name|common
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|s
operator|->
name|common_list
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|ffesymbol_is_init
argument_list|(
name|ffebld_symter
argument_list|(
name|ffebld_head
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
condition|)
name|ffesymbol_update_init
argument_list|(
name|ffebld_symter
argument_list|(
name|ffebld_head
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update SAVE info to TRUE and all equiv/storage too.     If SAVE flag is TRUE, does nothing.	Else sets it to TRUE and calls    on the ffeequiv and ffestorag modules to update their SAVE flags if    the<s> symbol has those objects, and also updates the common area if    it exists.  */
end_comment

begin_function
name|void
name|ffesymbol_update_save
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|ffebld
name|item
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|is_save
condition|)
return|return;
name|s
operator|->
name|is_save
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|equiv
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|ffeequiv_is_save
argument_list|(
name|s
operator|->
name|equiv
argument_list|)
condition|)
name|ffeequiv_update_save
argument_list|(
name|s
operator|->
name|equiv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|storage
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|ffestorag_is_save
argument_list|(
name|s
operator|->
name|storage
argument_list|)
condition|)
name|ffestorag_update_save
argument_list|(
name|s
operator|->
name|storage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|common
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|!
name|ffesymbol_is_save
argument_list|(
name|s
operator|->
name|common
argument_list|)
operator|)
condition|)
name|ffesymbol_update_save
argument_list|(
name|s
operator|->
name|common
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|s
operator|->
name|common_list
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|ffesymbol_is_save
argument_list|(
name|ffebld_symter
argument_list|(
name|ffebld_head
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
condition|)
name|ffesymbol_update_save
argument_list|(
name|ffebld_symter
argument_list|(
name|ffebld_head
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

