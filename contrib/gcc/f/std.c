begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* std.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995, 1996, 2000 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       st.c     Description:       Implements the various statements and such like.     Modifications:       21-Nov-91	 JCB  2.0 	 Split out actual code generation to ffeste. */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"std.h"
end_include

begin_include
include|#
directive|include
file|"bld.h"
end_include

begin_include
include|#
directive|include
file|"com.h"
end_include

begin_include
include|#
directive|include
file|"lab.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"sta.h"
end_include

begin_include
include|#
directive|include
file|"ste.h"
end_include

begin_include
include|#
directive|include
file|"stp.h"
end_include

begin_include
include|#
directive|include
file|"str.h"
end_include

begin_include
include|#
directive|include
file|"sts.h"
end_include

begin_include
include|#
directive|include
file|"stt.h"
end_include

begin_include
include|#
directive|include
file|"stv.h"
end_include

begin_include
include|#
directive|include
file|"stw.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_define
define|#
directive|define
name|FFESTD_COPY_EASY_
value|1
end_define

begin_comment
comment|/* 1 for only one _subr_copy_xyz_ fn. */
end_comment

begin_define
define|#
directive|define
name|FFESTD_IS_END_OPTIMIZED_
value|1
end_define

begin_comment
comment|/* 0=always gen STOP/RETURN before 					   END. */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|FFESTD_stateletSIMPLE_
block|,
comment|/* Expecting simple/start. */
name|FFESTD_stateletATTRIB_
block|,
comment|/* Expecting attrib/item/itemstart. */
name|FFESTD_stateletITEM_
block|,
comment|/* Expecting item/itemstart/finish. */
name|FFESTD_stateletITEMVALS_
block|,
comment|/* Expecting itemvalue/itemendvals. */
name|FFESTD_
block|}
name|ffestdStatelet_
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|FFESTD_stmtidENDDOLOOP_
block|,
name|FFESTD_stmtidENDLOGIF_
block|,
name|FFESTD_stmtidEXECLABEL_
block|,
name|FFESTD_stmtidFORMATLABEL_
block|,
name|FFESTD_stmtidR737A_
block|,
comment|/* let */
name|FFESTD_stmtidR803_
block|,
comment|/* IF-block */
name|FFESTD_stmtidR804_
block|,
comment|/* ELSE IF */
name|FFESTD_stmtidR805_
block|,
comment|/* ELSE */
name|FFESTD_stmtidR806_
block|,
comment|/* END IF */
name|FFESTD_stmtidR807_
block|,
comment|/* IF-logical */
name|FFESTD_stmtidR809_
block|,
comment|/* SELECT CASE */
name|FFESTD_stmtidR810_
block|,
comment|/* CASE */
name|FFESTD_stmtidR811_
block|,
comment|/* END SELECT */
name|FFESTD_stmtidR819A_
block|,
comment|/* DO-iterative */
name|FFESTD_stmtidR819B_
block|,
comment|/* DO WHILE */
name|FFESTD_stmtidR825_
block|,
comment|/* END DO */
name|FFESTD_stmtidR834_
block|,
comment|/* CYCLE */
name|FFESTD_stmtidR835_
block|,
comment|/* EXIT */
name|FFESTD_stmtidR836_
block|,
comment|/* GOTO */
name|FFESTD_stmtidR837_
block|,
comment|/* GOTO-computed */
name|FFESTD_stmtidR838_
block|,
comment|/* ASSIGN */
name|FFESTD_stmtidR839_
block|,
comment|/* GOTO-assigned */
name|FFESTD_stmtidR840_
block|,
comment|/* IF-arithmetic */
name|FFESTD_stmtidR841_
block|,
comment|/* CONTINUE */
name|FFESTD_stmtidR842_
block|,
comment|/* STOP */
name|FFESTD_stmtidR843_
block|,
comment|/* PAUSE */
name|FFESTD_stmtidR904_
block|,
comment|/* OPEN */
name|FFESTD_stmtidR907_
block|,
comment|/* CLOSE */
name|FFESTD_stmtidR909_
block|,
comment|/* READ */
name|FFESTD_stmtidR910_
block|,
comment|/* WRITE */
name|FFESTD_stmtidR911_
block|,
comment|/* PRINT */
name|FFESTD_stmtidR919_
block|,
comment|/* BACKSPACE */
name|FFESTD_stmtidR920_
block|,
comment|/* ENDFILE */
name|FFESTD_stmtidR921_
block|,
comment|/* REWIND */
name|FFESTD_stmtidR923A_
block|,
comment|/* INQUIRE */
name|FFESTD_stmtidR923B_
block|,
comment|/* INQUIRE-iolength */
name|FFESTD_stmtidR1001_
block|,
comment|/* FORMAT */
name|FFESTD_stmtidR1103_
block|,
comment|/* END_PROGRAM */
name|FFESTD_stmtidR1112_
block|,
comment|/* END_BLOCK_DATA */
name|FFESTD_stmtidR1212_
block|,
comment|/* CALL */
name|FFESTD_stmtidR1221_
block|,
comment|/* END_FUNCTION */
name|FFESTD_stmtidR1225_
block|,
comment|/* END_SUBROUTINE */
name|FFESTD_stmtidR1226_
block|,
comment|/* ENTRY */
name|FFESTD_stmtidR1227_
block|,
comment|/* RETURN */
if|#
directive|if
name|FFESTR_VXT
name|FFESTD_stmtidV018_
block|,
comment|/* REWRITE */
name|FFESTD_stmtidV019_
block|,
comment|/* ACCEPT */
endif|#
directive|endif
name|FFESTD_stmtidV020_
block|,
comment|/* TYPE */
if|#
directive|if
name|FFESTR_VXT
name|FFESTD_stmtidV021_
block|,
comment|/* DELETE */
name|FFESTD_stmtidV022_
block|,
comment|/* UNLOCK */
name|FFESTD_stmtidV023_
block|,
comment|/* ENCODE */
name|FFESTD_stmtidV024_
block|,
comment|/* DECODE */
name|FFESTD_stmtidV025start_
block|,
comment|/* DEFINEFILE (start) */
name|FFESTD_stmtidV025item_
block|,
comment|/* (DEFINEFILE item) */
name|FFESTD_stmtidV025finish_
block|,
comment|/* (DEFINEFILE finish) */
name|FFESTD_stmtidV026_
block|,
comment|/* FIND */
endif|#
directive|endif
name|FFESTD_stmtid_
block|,   }
name|ffestdStmtId_
typedef|;
end_typedef

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|_ffestd_expr_item_
modifier|*
name|ffestdExprItem_
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|_ffestd_stmt_
modifier|*
name|ffestdStmt_
typedef|;
end_typedef

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_struct
struct|struct
name|_ffestd_expr_item_
block|{
name|ffestdExprItem_
name|next
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
name|ffelexToken
name|token
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_ffestd_stmt_
block|{
name|ffestdStmt_
name|next
decl_stmt|;
name|ffestdStmt_
name|previous
decl_stmt|;
name|ffestdStmtId_
name|id
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|filelinenum
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|ffestw
name|block
decl_stmt|;
block|}
name|enddoloop
struct|;
struct|struct
block|{
name|ffelab
name|label
decl_stmt|;
block|}
name|execlabel
struct|;
struct|struct
block|{
name|ffelab
name|label
decl_stmt|;
block|}
name|formatlabel
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffebld
name|dest
decl_stmt|;
name|ffebld
name|source
decl_stmt|;
block|}
name|R737A
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestw
name|block
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
block|}
name|R803
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestw
name|block
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
block|}
name|R804
struct|;
struct|struct
block|{
name|ffestw
name|block
decl_stmt|;
block|}
name|R805
struct|;
struct|struct
block|{
name|ffestw
name|block
decl_stmt|;
block|}
name|R806
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
block|}
name|R807
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestw
name|block
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
block|}
name|R809
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestw
name|block
decl_stmt|;
name|unsigned
name|long
name|casenum
decl_stmt|;
block|}
name|R810
struct|;
struct|struct
block|{
name|ffestw
name|block
decl_stmt|;
block|}
name|R811
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestw
name|block
decl_stmt|;
name|ffelab
name|label
decl_stmt|;
name|ffebld
name|var
decl_stmt|;
name|ffebld
name|start
decl_stmt|;
name|ffelexToken
name|start_token
decl_stmt|;
name|ffebld
name|end
decl_stmt|;
name|ffelexToken
name|end_token
decl_stmt|;
name|ffebld
name|incr
decl_stmt|;
name|ffelexToken
name|incr_token
decl_stmt|;
block|}
name|R819A
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestw
name|block
decl_stmt|;
name|ffelab
name|label
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
block|}
name|R819B
struct|;
struct|struct
block|{
name|ffestw
name|block
decl_stmt|;
block|}
name|R834
struct|;
struct|struct
block|{
name|ffestw
name|block
decl_stmt|;
block|}
name|R835
struct|;
struct|struct
block|{
name|ffelab
name|label
decl_stmt|;
block|}
name|R836
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffelab
modifier|*
name|labels
decl_stmt|;
name|int
name|count
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
block|}
name|R837
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffelab
name|label
decl_stmt|;
name|ffebld
name|target
decl_stmt|;
block|}
name|R838
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffebld
name|target
decl_stmt|;
block|}
name|R839
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
name|ffelab
name|neg
decl_stmt|;
name|ffelab
name|zero
decl_stmt|;
name|ffelab
name|pos
decl_stmt|;
block|}
name|R840
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
block|}
name|R842
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
block|}
name|R843
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpOpenStmt
modifier|*
name|params
decl_stmt|;
block|}
name|R904
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpCloseStmt
modifier|*
name|params
decl_stmt|;
block|}
name|R907
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpReadStmt
modifier|*
name|params
decl_stmt|;
name|bool
name|only_format
decl_stmt|;
name|ffestvUnit
name|unit
decl_stmt|;
name|ffestvFormat
name|format
decl_stmt|;
name|bool
name|rec
decl_stmt|;
name|bool
name|key
decl_stmt|;
name|ffestdExprItem_
name|list
decl_stmt|;
block|}
name|R909
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpWriteStmt
modifier|*
name|params
decl_stmt|;
name|ffestvUnit
name|unit
decl_stmt|;
name|ffestvFormat
name|format
decl_stmt|;
name|bool
name|rec
decl_stmt|;
name|ffestdExprItem_
name|list
decl_stmt|;
block|}
name|R910
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpPrintStmt
modifier|*
name|params
decl_stmt|;
name|ffestvFormat
name|format
decl_stmt|;
name|ffestdExprItem_
name|list
decl_stmt|;
block|}
name|R911
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpBeruStmt
modifier|*
name|params
decl_stmt|;
block|}
name|R919
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpBeruStmt
modifier|*
name|params
decl_stmt|;
block|}
name|R920
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpBeruStmt
modifier|*
name|params
decl_stmt|;
block|}
name|R921
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpInquireStmt
modifier|*
name|params
decl_stmt|;
name|bool
name|by_file
decl_stmt|;
block|}
name|R923A
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpInquireStmt
modifier|*
name|params
decl_stmt|;
name|ffestdExprItem_
name|list
decl_stmt|;
block|}
name|R923B
struct|;
struct|struct
block|{
name|ffestsHolder
name|str
decl_stmt|;
block|}
name|R1001
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
block|}
name|R1212
struct|;
struct|struct
block|{
name|ffesymbol
name|entry
decl_stmt|;
name|int
name|entrynum
decl_stmt|;
block|}
name|R1226
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestw
name|block
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
block|}
name|R1227
struct|;
if|#
directive|if
name|FFESTR_VXT
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpRewriteStmt
modifier|*
name|params
decl_stmt|;
name|ffestvFormat
name|format
decl_stmt|;
name|ffestdExprItem_
name|list
decl_stmt|;
block|}
name|V018
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpAcceptStmt
modifier|*
name|params
decl_stmt|;
name|ffestvFormat
name|format
decl_stmt|;
name|ffestdExprItem_
name|list
decl_stmt|;
block|}
name|V019
struct|;
endif|#
directive|endif
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpTypeStmt
modifier|*
name|params
decl_stmt|;
name|ffestvFormat
name|format
decl_stmt|;
name|ffestdExprItem_
name|list
decl_stmt|;
block|}
name|V020
struct|;
if|#
directive|if
name|FFESTR_VXT
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpDeleteStmt
modifier|*
name|params
decl_stmt|;
block|}
name|V021
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpBeruStmt
modifier|*
name|params
decl_stmt|;
block|}
name|V022
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpVxtcodeStmt
modifier|*
name|params
decl_stmt|;
name|ffestdExprItem_
name|list
decl_stmt|;
block|}
name|V023
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpVxtcodeStmt
modifier|*
name|params
decl_stmt|;
name|ffestdExprItem_
name|list
decl_stmt|;
block|}
name|V024
struct|;
struct|struct
block|{
name|ffebld
name|u
decl_stmt|;
name|ffebld
name|m
decl_stmt|;
name|ffebld
name|n
decl_stmt|;
name|ffebld
name|asv
decl_stmt|;
block|}
name|V025item
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
block|}
name|V025finish
struct|;
struct|struct
block|{
name|mallocPool
name|pool
decl_stmt|;
name|ffestpFindStmt
modifier|*
name|params
decl_stmt|;
block|}
name|V026
struct|;
endif|#
directive|endif
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_decl_stmt
specifier|static
name|ffestdStatelet_
name|ffestd_statelet_
init|=
name|FFESTD_stateletSIMPLE_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ffestd_block_level_
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Block level for reachableness. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffestd_is_reachable_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Is the current stmt reachable?  */
end_comment

begin_decl_stmt
specifier|static
name|ffelab
name|ffestd_label_formatdef_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffestdExprItem_
modifier|*
name|ffestd_expr_list_
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|ffestdStmt_
name|first
decl_stmt|;
name|ffestdStmt_
name|last
decl_stmt|;
block|}
name|ffestd_stmt_list_
init|=
block|{
name|NULL
block|,
name|NULL
block|}
struct|;
end_struct

begin_comment
comment|/* # ENTRY statements pending. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ffestd_2pass_entrypoints_
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_function_decl
specifier|static
name|void
name|ffestd_stmt_append_
parameter_list|(
name|ffestdStmt_
name|stmt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestdStmt_
name|ffestd_stmt_new_
parameter_list|(
name|ffestdStmtId_
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestd_stmt_pass_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTD_COPY_EASY_
end_if

begin_function_decl
specifier|static
name|ffestpInquireStmt
modifier|*
name|ffestd_subr_copy_easy_
parameter_list|(
name|ffestpInquireIx
name|max
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ffestd_subr_vxt_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|void
name|ffestd_subr_f90_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ffestd_subr_labels_
parameter_list|(
name|bool
name|unexpected
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestd_R1001dump_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestd_R1001dump_1005_1_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestd_R1001dump_1005_2_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestd_R1001dump_1005_3_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestd_R1001dump_1005_4_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestd_R1001dump_1005_5_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestd_R1001dump_1010_1_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestd_R1001dump_1010_2_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestd_R1001dump_1010_3_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestd_R1001dump_1010_4_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestd_R1001dump_1010_5_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestd_R1001error_
parameter_list|(
name|ffesttFormatList
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestd_R1001rtexpr_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
name|ffebld
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Internal macros. */
end_comment

begin_define
define|#
directive|define
name|ffestd_subr_line_now_
parameter_list|()
define|\
value|ffeste_set_line (ffelex_token_where_filename (ffesta_tokens[0]), \ 		   ffelex_token_where_filelinenum (ffesta_tokens[0]))
end_define

begin_define
define|#
directive|define
name|ffestd_subr_line_restore_
parameter_list|(
name|s
parameter_list|)
define|\
value|ffeste_set_line ((s)->filename, (s)->filelinenum)
end_define

begin_define
define|#
directive|define
name|ffestd_subr_line_save_
parameter_list|(
name|s
parameter_list|)
define|\
value|((s)->filename = ffelex_token_where_filename (ffesta_tokens[0]),	   \    (s)->filelinenum = ffelex_token_where_filelinenum (ffesta_tokens[0]))
end_define

begin_define
define|#
directive|define
name|ffestd_check_simple_
parameter_list|()
define|\
value|assert(ffestd_statelet_ == FFESTD_stateletSIMPLE_)
end_define

begin_define
define|#
directive|define
name|ffestd_check_start_
parameter_list|()
define|\
value|assert(ffestd_statelet_ == FFESTD_stateletSIMPLE_); \       ffestd_statelet_ = FFESTD_stateletATTRIB_
end_define

begin_define
define|#
directive|define
name|ffestd_check_attrib_
parameter_list|()
define|\
value|assert(ffestd_statelet_ == FFESTD_stateletATTRIB_)
end_define

begin_define
define|#
directive|define
name|ffestd_check_item_
parameter_list|()
define|\
value|assert(ffestd_statelet_ == FFESTD_stateletATTRIB_	 \ 	    || ffestd_statelet_ == FFESTD_stateletITEM_); \       ffestd_statelet_ = FFESTD_stateletITEM_
end_define

begin_define
define|#
directive|define
name|ffestd_check_item_startvals_
parameter_list|()
define|\
value|assert(ffestd_statelet_ == FFESTD_stateletATTRIB_	 \ 	    || ffestd_statelet_ == FFESTD_stateletITEM_); \       ffestd_statelet_ = FFESTD_stateletITEMVALS_
end_define

begin_define
define|#
directive|define
name|ffestd_check_item_value_
parameter_list|()
define|\
value|assert(ffestd_statelet_ == FFESTD_stateletITEMVALS_)
end_define

begin_define
define|#
directive|define
name|ffestd_check_item_endvals_
parameter_list|()
define|\
value|assert(ffestd_statelet_ == FFESTD_stateletITEMVALS_); \       ffestd_statelet_ = FFESTD_stateletITEM_
end_define

begin_define
define|#
directive|define
name|ffestd_check_finish_
parameter_list|()
define|\
value|assert(ffestd_statelet_ == FFESTD_stateletATTRIB_	 \ 	    || ffestd_statelet_ == FFESTD_stateletITEM_); \       ffestd_statelet_ = FFESTD_stateletSIMPLE_
end_define

begin_if
if|#
directive|if
name|FFESTD_COPY_EASY_
end_if

begin_define
define|#
directive|define
name|ffestd_subr_copy_accept_
parameter_list|()
value|(ffestpAcceptStmt *) \       ffestd_subr_copy_easy_((ffestpInquireIx) FFESTP_acceptix)
end_define

begin_define
define|#
directive|define
name|ffestd_subr_copy_beru_
parameter_list|()
value|(ffestpBeruStmt *) \       ffestd_subr_copy_easy_((ffestpInquireIx) FFESTP_beruix)
end_define

begin_define
define|#
directive|define
name|ffestd_subr_copy_close_
parameter_list|()
value|(ffestpCloseStmt *) \       ffestd_subr_copy_easy_((ffestpInquireIx) FFESTP_closeix)
end_define

begin_define
define|#
directive|define
name|ffestd_subr_copy_delete_
parameter_list|()
value|(ffestpDeleteStmt *) \       ffestd_subr_copy_easy_((ffestpInquireIx) FFESTP_deleteix)
end_define

begin_define
define|#
directive|define
name|ffestd_subr_copy_find_
parameter_list|()
value|(ffestpFindStmt *) \       ffestd_subr_copy_easy_((ffestpInquireIx) FFESTP_findix)
end_define

begin_define
define|#
directive|define
name|ffestd_subr_copy_inquire_
parameter_list|()
value|(ffestpInquireStmt *) \       ffestd_subr_copy_easy_((ffestpInquireIx) FFESTP_inquireix)
end_define

begin_define
define|#
directive|define
name|ffestd_subr_copy_open_
parameter_list|()
value|(ffestpOpenStmt *) \       ffestd_subr_copy_easy_((ffestpInquireIx) FFESTP_openix)
end_define

begin_define
define|#
directive|define
name|ffestd_subr_copy_print_
parameter_list|()
value|(ffestpPrintStmt *) \       ffestd_subr_copy_easy_((ffestpInquireIx) FFESTP_printix)
end_define

begin_define
define|#
directive|define
name|ffestd_subr_copy_read_
parameter_list|()
value|(ffestpReadStmt *) \       ffestd_subr_copy_easy_((ffestpInquireIx) FFESTP_readix)
end_define

begin_define
define|#
directive|define
name|ffestd_subr_copy_rewrite_
parameter_list|()
value|(ffestpRewriteStmt *) \       ffestd_subr_copy_easy_((ffestpInquireIx) FFESTP_rewriteix)
end_define

begin_define
define|#
directive|define
name|ffestd_subr_copy_type_
parameter_list|()
value|(ffestpTypeStmt *) \       ffestd_subr_copy_easy_((ffestpInquireIx) FFESTP_typeix)
end_define

begin_define
define|#
directive|define
name|ffestd_subr_copy_vxtcode_
parameter_list|()
value|(ffestpVxtcodeStmt *) \       ffestd_subr_copy_easy_((ffestpInquireIx) FFESTP_vxtcodeix)
end_define

begin_define
define|#
directive|define
name|ffestd_subr_copy_write_
parameter_list|()
value|(ffestpWriteStmt *) \       ffestd_subr_copy_easy_((ffestpInquireIx) FFESTP_writeix)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* ffestd_stmt_append_ -- Append statement to end of stmt list     ffestd_stmt_append_(ffestd_stmt_new_(FFESTD_stmtidR737A_));	*/
end_comment

begin_function
specifier|static
name|void
name|ffestd_stmt_append_
parameter_list|(
name|ffestdStmt_
name|stmt
parameter_list|)
block|{
name|stmt
operator|->
name|next
operator|=
operator|(
name|ffestdStmt_
operator|)
operator|&
name|ffestd_stmt_list_
operator|.
name|first
expr_stmt|;
name|stmt
operator|->
name|previous
operator|=
name|ffestd_stmt_list_
operator|.
name|last
expr_stmt|;
name|stmt
operator|->
name|next
operator|->
name|previous
operator|=
name|stmt
expr_stmt|;
name|stmt
operator|->
name|previous
operator|->
name|next
operator|=
name|stmt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_stmt_new_ -- Make new statement with given id     ffestdStmt_ stmt;    stmt = ffestd_stmt_new_(FFESTD_stmtidR737A_);  */
end_comment

begin_function
specifier|static
name|ffestdStmt_
name|ffestd_stmt_new_
parameter_list|(
name|ffestdStmtId_
name|id
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|stmt
operator|=
name|malloc_new_kp
argument_list|(
name|ffe_pool_any_unit
argument_list|()
argument_list|,
literal|"ffestdStmt_"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|id
operator|=
name|id
expr_stmt|;
return|return
name|stmt
return|;
block|}
end_function

begin_comment
comment|/* ffestd_stmt_pass_ -- Pass all statements on list to ffeste     ffestd_stmt_pass_();	 */
end_comment

begin_function
specifier|static
name|void
name|ffestd_stmt_pass_
parameter_list|()
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestdExprItem_
name|expr
decl_stmt|;
comment|/* For traversing lists. */
name|bool
name|okay
init|=
operator|(
name|TREE_CODE
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|ERROR_MARK
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|ffestd_2pass_entrypoints_
operator|!=
literal|0
operator|)
operator|&&
name|okay
condition|)
block|{
name|tree
name|which
init|=
name|ffecom_which_entrypoint_decl
argument_list|()
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|tree
name|label
decl_stmt|;
name|int
name|pushok
decl_stmt|;
name|int
name|ents
init|=
name|ffestd_2pass_entrypoints_
decl_stmt|;
name|tree
name|duplicate
decl_stmt|;
name|expand_start_case
argument_list|(
literal|0
argument_list|,
name|which
argument_list|,
name|TREE_TYPE
argument_list|(
name|which
argument_list|)
argument_list|,
literal|"entrypoint dispatch"
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_list_
operator|.
name|first
expr_stmt|;
do|do
block|{
while|while
condition|(
name|stmt
operator|->
name|id
operator|!=
name|FFESTD_stmtidR1226_
condition|)
name|stmt
operator|=
name|stmt
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|stmt
operator|->
name|u
operator|.
name|R1226
operator|.
name|entry
operator|!=
name|NULL
condition|)
block|{
name|value
operator|=
name|build_int_2
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R1226
operator|.
name|entrynum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Yes, we really want to build a null LABEL_DECL here and not 		 put it on any list.  That's what pushcase wants, so that's 		 what it gets!  */
name|label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pushok
operator|=
name|pushcase
argument_list|(
name|value
argument_list|,
name|convert
argument_list|,
name|label
argument_list|,
operator|&
name|duplicate
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pushok
operator|==
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|ffecom_temp_label
argument_list|()
expr_stmt|;
name|TREE_USED
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_goto
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|ffesymbol_hook
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R1226
operator|.
name|entry
argument_list|)
operator|.
name|length_tree
operator|=
name|label
expr_stmt|;
block|}
name|stmt
operator|=
name|stmt
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ents
operator|!=
literal|0
condition|)
do|;
name|expand_end_case
argument_list|(
name|which
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|stmt
operator|=
name|ffestd_stmt_list_
operator|.
name|first
init|;
name|stmt
operator|!=
operator|(
name|ffestdStmt_
operator|)
operator|&
name|ffestd_stmt_list_
operator|.
name|first
condition|;
name|stmt
operator|=
name|stmt
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|stmt
operator|->
name|id
condition|)
block|{
case|case
name|FFESTD_stmtidENDDOLOOP_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_do
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|enddoloop
operator|.
name|block
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|enddoloop
operator|.
name|block
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidENDLOGIF_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_end_R807
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidEXECLABEL_
case|:
if|if
condition|(
name|okay
condition|)
name|ffeste_labeldef_branch
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|execlabel
operator|.
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidFORMATLABEL_
case|:
if|if
condition|(
name|okay
condition|)
name|ffeste_labeldef_format
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|formatlabel
operator|.
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR737A_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R737A
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R737A
operator|.
name|dest
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R737A
operator|.
name|source
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R737A
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR803_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R803
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R803
operator|.
name|block
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R803
operator|.
name|expr
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R803
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR804_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R804
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R803
operator|.
name|block
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R804
operator|.
name|expr
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R804
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR805_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R805
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R803
operator|.
name|block
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR806_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R806
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R806
operator|.
name|block
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R806
operator|.
name|block
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR807_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R807
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R807
operator|.
name|expr
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R807
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR809_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R809
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R809
operator|.
name|block
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R809
operator|.
name|expr
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R809
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR810_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R810
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R810
operator|.
name|block
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R810
operator|.
name|casenum
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R810
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR811_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R811
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R811
operator|.
name|block
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|ffestw_select
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R811
operator|.
name|block
argument_list|)
operator|->
name|pool
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R811
operator|.
name|block
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR819A_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R819A
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|block
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|label
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|var
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|start
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|start_token
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|end
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|end_token
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|incr
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|incr_token
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|start_token
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|end_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|incr_token
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|incr_token
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR819B_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R819B
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R819B
operator|.
name|block
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R819B
operator|.
name|label
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R819B
operator|.
name|expr
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R819B
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR825_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R825
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR834_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R834
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R834
operator|.
name|block
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR835_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R835
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R835
operator|.
name|block
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR836_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R836
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R836
operator|.
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR837_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R837
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R837
operator|.
name|labels
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R837
operator|.
name|count
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R837
operator|.
name|expr
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R837
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR838_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R838
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R838
operator|.
name|label
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R838
operator|.
name|target
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R838
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR839_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R839
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R839
operator|.
name|target
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R839
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR840_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R840
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R840
operator|.
name|expr
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R840
operator|.
name|neg
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R840
operator|.
name|zero
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R840
operator|.
name|pos
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R840
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR841_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R841
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR842_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R842
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R842
operator|.
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|->
name|u
operator|.
name|R842
operator|.
name|pool
operator|!=
name|NULL
condition|)
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R842
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR843_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R843
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R843
operator|.
name|expr
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R843
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR904_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R904
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R904
operator|.
name|params
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R904
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR907_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R907
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R907
operator|.
name|params
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R907
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR909_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R909_start
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|params
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|only_format
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|unit
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|format
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|rec
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|key
argument_list|)
expr_stmt|;
for|for
control|(
name|expr
operator|=
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|list
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|okay
condition|)
name|ffeste_R909_item
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|expr
operator|->
name|token
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|expr
operator|->
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|okay
condition|)
name|ffeste_R909_finish
argument_list|()
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR910_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R910_start
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R910
operator|.
name|params
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R910
operator|.
name|unit
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R910
operator|.
name|format
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R910
operator|.
name|rec
argument_list|)
expr_stmt|;
for|for
control|(
name|expr
operator|=
name|stmt
operator|->
name|u
operator|.
name|R910
operator|.
name|list
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|okay
condition|)
name|ffeste_R910_item
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|expr
operator|->
name|token
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|expr
operator|->
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|okay
condition|)
name|ffeste_R910_finish
argument_list|()
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R910
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR911_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R911_start
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R911
operator|.
name|params
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R911
operator|.
name|format
argument_list|)
expr_stmt|;
for|for
control|(
name|expr
operator|=
name|stmt
operator|->
name|u
operator|.
name|R911
operator|.
name|list
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|okay
condition|)
name|ffeste_R911_item
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|expr
operator|->
name|token
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|expr
operator|->
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|okay
condition|)
name|ffeste_R911_finish
argument_list|()
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R911
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR919_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R919
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R919
operator|.
name|params
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R919
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR920_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R920
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R920
operator|.
name|params
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R920
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR921_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R921
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R921
operator|.
name|params
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R921
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR923A_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R923A
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R923A
operator|.
name|params
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R923A
operator|.
name|by_file
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R923A
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR923B_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R923B_start
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R923B
operator|.
name|params
argument_list|)
expr_stmt|;
for|for
control|(
name|expr
operator|=
name|stmt
operator|->
name|u
operator|.
name|R923B
operator|.
name|list
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|okay
condition|)
name|ffeste_R923B_item
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|okay
condition|)
name|ffeste_R923B_finish
argument_list|()
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R923B
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR1001_
case|:
if|if
condition|(
name|okay
condition|)
name|ffeste_R1001
argument_list|(
operator|&
name|stmt
operator|->
name|u
operator|.
name|R1001
operator|.
name|str
argument_list|)
expr_stmt|;
name|ffests_kill
argument_list|(
operator|&
name|stmt
operator|->
name|u
operator|.
name|R1001
operator|.
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR1103_
case|:
if|if
condition|(
name|okay
condition|)
name|ffeste_R1103
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR1112_
case|:
if|if
condition|(
name|okay
condition|)
name|ffeste_R1112
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR1212_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R1212
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R1212
operator|.
name|expr
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R1212
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR1221_
case|:
if|if
condition|(
name|okay
condition|)
name|ffeste_R1221
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR1225_
case|:
if|if
condition|(
name|okay
condition|)
name|ffeste_R1225
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidR1226_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|->
name|u
operator|.
name|R1226
operator|.
name|entry
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|okay
condition|)
name|ffeste_R1226
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R1226
operator|.
name|entry
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FFESTD_stmtidR1227_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_R1227
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R1227
operator|.
name|block
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|R1227
operator|.
name|expr
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R1227
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTD_stmtidV018_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_V018_start
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V018
operator|.
name|params
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|V018
operator|.
name|format
argument_list|)
expr_stmt|;
for|for
control|(
name|expr
operator|=
name|stmt
operator|->
name|u
operator|.
name|V018
operator|.
name|list
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|okay
condition|)
name|ffeste_V018_item
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|okay
condition|)
name|ffeste_V018_finish
argument_list|()
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V018
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidV019_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_V019_start
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V019
operator|.
name|params
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|V019
operator|.
name|format
argument_list|)
expr_stmt|;
for|for
control|(
name|expr
operator|=
name|stmt
operator|->
name|u
operator|.
name|V019
operator|.
name|list
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|okay
condition|)
name|ffeste_V019_item
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|okay
condition|)
name|ffeste_V019_finish
argument_list|()
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V019
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FFESTD_stmtidV020_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_V020_start
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V020
operator|.
name|params
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|V020
operator|.
name|format
argument_list|)
expr_stmt|;
for|for
control|(
name|expr
operator|=
name|stmt
operator|->
name|u
operator|.
name|V020
operator|.
name|list
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|okay
condition|)
name|ffeste_V020_item
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|okay
condition|)
name|ffeste_V020_finish
argument_list|()
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V020
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFESTR_VXT
case|case
name|FFESTD_stmtidV021_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_V021
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V021
operator|.
name|params
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V021
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidV023_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_V023_start
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V023
operator|.
name|params
argument_list|)
expr_stmt|;
for|for
control|(
name|expr
operator|=
name|stmt
operator|->
name|u
operator|.
name|V023
operator|.
name|list
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|okay
condition|)
name|ffeste_V023_item
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|okay
condition|)
name|ffeste_V023_finish
argument_list|()
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V023
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidV024_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_V024_start
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V024
operator|.
name|params
argument_list|)
expr_stmt|;
for|for
control|(
name|expr
operator|=
name|stmt
operator|->
name|u
operator|.
name|V024
operator|.
name|list
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|okay
condition|)
name|ffeste_V024_item
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|okay
condition|)
name|ffeste_V024_finish
argument_list|()
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V024
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidV025start_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_V025_start
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidV025item_
case|:
if|if
condition|(
name|okay
condition|)
name|ffeste_V025_item
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V025item
operator|.
name|u
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|V025item
operator|.
name|m
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|V025item
operator|.
name|n
argument_list|,
name|stmt
operator|->
name|u
operator|.
name|V025item
operator|.
name|asv
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidV025finish_
case|:
if|if
condition|(
name|okay
condition|)
name|ffeste_V025_finish
argument_list|()
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V025finish
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTD_stmtidV026_
case|:
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|okay
condition|)
name|ffeste_V026
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V026
operator|.
name|params
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|V026
operator|.
name|pool
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad stmt->id"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ffestd_subr_copy_easy_ -- Copy I/O statement data structure     ffestd_subr_copy_easy_();     Copies all data except tokens in the I/O data structure into a new    structure that lasts as long as the output pool for the current    statement.  Assumes that they are    overlaid with each other (union) in stp.h and the typing    and structure references assume (though not necessarily dangerous if    FALSE) that INQUIRE has the most file elements.  */
end_comment

begin_if
if|#
directive|if
name|FFESTD_COPY_EASY_
end_if

begin_function
specifier|static
name|ffestpInquireStmt
modifier|*
name|ffestd_subr_copy_easy_
parameter_list|(
name|ffestpInquireIx
name|max
parameter_list|)
block|{
name|ffestpInquireStmt
modifier|*
name|stmt
decl_stmt|;
name|ffestpInquireIx
name|ix
decl_stmt|;
name|stmt
operator|=
operator|(
name|ffestpInquireStmt
operator|*
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_output_pool
argument_list|,
literal|"FFESTD easy"
argument_list|,
sizeof|sizeof
argument_list|(
name|ffestpFile
argument_list|)
operator|*
name|max
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|max
condition|;
operator|++
name|ix
control|)
block|{
if|if
condition|(
operator|(
name|stmt
operator|->
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|=
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|kw_or_val_present
operator|)
operator|&&
operator|(
name|stmt
operator|->
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|value_present
operator|=
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|value_present
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|stmt
operator|->
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|value_is_label
operator|=
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|value_is_label
operator|)
condition|)
name|stmt
operator|->
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|u
operator|.
name|label
operator|=
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|u
operator|.
name|label
expr_stmt|;
else|else
name|stmt
operator|->
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|u
operator|.
name|expr
operator|=
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|ix
index|]
operator|.
name|u
operator|.
name|expr
expr_stmt|;
block|}
block|}
return|return
name|stmt
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_subr_labels_ -- Handle any undefined labels     ffestd_subr_labels_(FALSE);     For every undefined label, generate an error message and either define    label as a FORMAT() statement (for FORMAT labels) or as a STOP statement    (for all other labels).  */
end_comment

begin_function
specifier|static
name|void
name|ffestd_subr_labels_
parameter_list|(
name|bool
name|unexpected
parameter_list|)
block|{
name|ffelab
name|l
decl_stmt|;
name|ffelabHandle
name|h
decl_stmt|;
name|ffelabNumber
name|undef
decl_stmt|;
name|ffesttFormatList
name|f
decl_stmt|;
name|undef
operator|=
name|ffelab_number
argument_list|()
operator|-
name|ffestv_num_label_defines_
expr_stmt|;
for|for
control|(
name|h
operator|=
name|ffelab_handle_first
argument_list|()
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|ffelab_handle_next
argument_list|(
name|h
argument_list|)
control|)
block|{
name|l
operator|=
name|ffelab_handle_target
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffewhere_line_is_unknown
argument_list|(
name|ffelab_definition_line
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Undefined label. */
name|assert
argument_list|(
operator|!
name|unexpected
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|undef
operator|>
literal|0
argument_list|)
expr_stmt|;
name|undef
operator|--
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_UNDEF_LABEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelab_type
argument_list|(
name|l
argument_list|)
operator|==
name|FFELAB_typeLOOPEND
condition|)
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_doref_line
argument_list|(
name|l
argument_list|)
argument_list|,
name|ffelab_doref_column
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ffelab_type
argument_list|(
name|l
argument_list|)
operator|!=
name|FFELAB_typeANY
condition|)
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|l
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ffewhere_line_is_unknown
argument_list|(
name|ffelab_firstref_line
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|l
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ffewhere_line_is_unknown
argument_list|(
name|ffelab_doref_line
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_doref_line
argument_list|(
name|l
argument_list|)
argument_list|,
name|ffelab_doref_column
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_definition_line
argument_list|(
name|l
argument_list|)
argument_list|,
name|ffelab_definition_column
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffelab_type
argument_list|(
name|l
argument_list|)
condition|)
block|{
case|case
name|FFELAB_typeFORMAT
case|:
name|ffelab_set_definition_line
argument_list|(
name|l
argument_list|,
name|ffewhere_line_use
argument_list|(
name|ffelab_firstref_line
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffelab_set_definition_column
argument_list|(
name|l
argument_list|,
name|ffewhere_column_use
argument_list|(
name|ffelab_firstref_column
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffestv_num_label_defines_
operator|++
expr_stmt|;
name|f
operator|=
name|ffestt_formatlist_create
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestd_labeldef_format
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ffestd_R1001
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ffestt_formatlist_kill
argument_list|(
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeASSIGNABLE
case|:
name|ffelab_set_definition_line
argument_list|(
name|l
argument_list|,
name|ffewhere_line_use
argument_list|(
name|ffelab_firstref_line
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffelab_set_definition_column
argument_list|(
name|l
argument_list|,
name|ffewhere_column_use
argument_list|(
name|ffelab_firstref_column
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffestv_num_label_defines_
operator|++
expr_stmt|;
name|ffelab_set_type
argument_list|(
name|l
argument_list|,
name|FFELAB_typeNOTLOOP
argument_list|)
expr_stmt|;
name|ffelab_set_blocknum
argument_list|(
name|l
argument_list|,
name|ffestw_blocknum
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffestd_labeldef_notloop
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ffestd_R842
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeNOTLOOP
case|:
name|ffelab_set_definition_line
argument_list|(
name|l
argument_list|,
name|ffewhere_line_use
argument_list|(
name|ffelab_firstref_line
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffelab_set_definition_column
argument_list|(
name|l
argument_list|,
name|ffewhere_column_use
argument_list|(
name|ffelab_firstref_column
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffestv_num_label_defines_
operator|++
expr_stmt|;
name|ffelab_set_blocknum
argument_list|(
name|l
argument_list|,
name|ffestw_blocknum
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffestd_labeldef_notloop
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ffestd_R842
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad label type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFELAB_typeUNKNOWN
case|:
case|case
name|FFELAB_typeANY
case|:
break|break;
block|}
block|}
block|}
name|ffelab_handle_done
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|undef
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_subr_f90_ -- Report error about lack of full F90 support     ffestd_subr_f90_();	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|void
name|ffestd_subr_f90_
parameter_list|()
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_F90
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_subr_vxt_ -- Report error about lack of full VXT support     ffestd_subr_vxt_();	*/
end_comment

begin_function
specifier|static
name|void
name|ffestd_subr_vxt_
parameter_list|()
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_VXT_UNSUPPORTED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_begin_uses -- Start a bunch of USE statements     ffestd_begin_uses();     Invoked before handling the first USE statement in a block of one or    more USE statements.	 _end_uses_(bool ok) is invoked before handling    the first statement after the block (there are no BEGIN USE and END USE    statements, but the semantics of USE statements effectively requires    handling them as a single block rather than one statement at a time).  */
end_comment

begin_function
name|void
name|ffestd_begin_uses
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* ffestd_do -- End of statement following DO-term-stmt etc     ffestd_do(TRUE);     Also invoked by _labeldef_branch_finish_ (or, in cases    of errors, other _labeldef_ functions) when the label definition is    for a DO-target (LOOPEND) label, once per matching/outstanding DO    block on the stack.	These cases invoke this function with ok==TRUE, so    only forced stack popping (via ffestd_eof_()) invokes it with ok==FALSE.  */
end_comment

begin_function
name|void
name|ffestd_do
parameter_list|(
name|bool
name|ok
name|UNUSED
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidENDDOLOOP_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|enddoloop
operator|.
name|block
operator|=
name|ffestw_stack_top
argument_list|()
expr_stmt|;
operator|--
name|ffestd_block_level_
expr_stmt|;
name|assert
argument_list|(
name|ffestd_block_level_
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_end_uses -- End a bunch of USE statements     ffestd_end_uses(TRUE);     ok==TRUE means simply not popping due to ffestd_eof_()    being called, because there is no formal END USES statement in Fortran.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestd_end_uses
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* ffestd_end_R740 -- End a WHERE(-THEN)     ffestd_end_R740(TRUE);  */
end_comment

begin_function
name|void
name|ffestd_end_R740
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
return|return;
comment|/* F90. */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_end_R807 -- End of statement following logical IF     ffestd_end_R807(TRUE);     Applies ONLY to logical IF, not to IF-THEN.	For example, does not    ffelex_token_kill the construct name for an IF-THEN block (the name    field is invalid for logical IF).  ok==TRUE iff statement following    logical IF (substatement) is valid; else, statement is invalid or    stack forcibly popped due to ffestd_eof_().	*/
end_comment

begin_function
name|void
name|ffestd_end_R807
parameter_list|(
name|bool
name|ok
name|UNUSED
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidENDLOGIF_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
operator|--
name|ffestd_block_level_
expr_stmt|;
name|assert
argument_list|(
name|ffestd_block_level_
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_exec_begin -- Executable statements can start coming in now     ffestd_exec_begin();	 */
end_comment

begin_function
name|void
name|ffestd_exec_begin
parameter_list|()
block|{
name|ffecom_exec_transition
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestd_2pass_entrypoints_
operator|!=
literal|0
condition|)
block|{
comment|/* Process pending ENTRY statements now that 				   info filled in. */
name|ffestdStmt_
name|stmt
decl_stmt|;
name|int
name|ents
init|=
name|ffestd_2pass_entrypoints_
decl_stmt|;
name|stmt
operator|=
name|ffestd_stmt_list_
operator|.
name|first
expr_stmt|;
do|do
block|{
while|while
condition|(
name|stmt
operator|->
name|id
operator|!=
name|FFESTD_stmtidR1226_
condition|)
name|stmt
operator|=
name|stmt
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|ffecom_2pass_advise_entrypoint
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R1226
operator|.
name|entry
argument_list|)
condition|)
block|{
name|stmt
operator|->
name|u
operator|.
name|R1226
operator|.
name|entry
operator|=
name|NULL
expr_stmt|;
operator|--
name|ffestd_2pass_entrypoints_
expr_stmt|;
block|}
name|stmt
operator|=
name|stmt
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ents
operator|!=
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/* ffestd_exec_end -- Executable statements can no longer come in now     ffestd_exec_end();  */
end_comment

begin_function
name|void
name|ffestd_exec_end
parameter_list|()
block|{
name|int
name|old_lineno
init|=
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
name|ffecom_end_transition
argument_list|()
expr_stmt|;
name|ffestd_stmt_pass_
argument_list|()
expr_stmt|;
name|ffecom_finish_progunit
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestd_2pass_entrypoints_
operator|!=
literal|0
condition|)
block|{
name|int
name|ents
init|=
name|ffestd_2pass_entrypoints_
decl_stmt|;
name|ffestdStmt_
name|stmt
init|=
name|ffestd_stmt_list_
operator|.
name|first
decl_stmt|;
do|do
block|{
while|while
condition|(
name|stmt
operator|->
name|id
operator|!=
name|FFESTD_stmtidR1226_
condition|)
name|stmt
operator|=
name|stmt
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|stmt
operator|->
name|u
operator|.
name|R1226
operator|.
name|entry
operator|!=
name|NULL
condition|)
block|{
name|ffestd_subr_line_restore_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffecom_2pass_do_entrypoint
argument_list|(
name|stmt
operator|->
name|u
operator|.
name|R1226
operator|.
name|entry
argument_list|)
expr_stmt|;
block|}
name|stmt
operator|=
name|stmt
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ents
operator|!=
literal|0
condition|)
do|;
block|}
name|ffestd_stmt_list_
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|ffestd_stmt_list_
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
name|ffestd_2pass_entrypoints_
operator|=
literal|0
expr_stmt|;
name|lineno
operator|=
name|old_lineno
expr_stmt|;
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_init_3 -- Initialize for any program unit     ffestd_init_3();  */
end_comment

begin_function
name|void
name|ffestd_init_3
parameter_list|()
block|{
name|ffestd_stmt_list_
operator|.
name|first
operator|=
operator|(
name|ffestdStmt_
operator|)
operator|&
name|ffestd_stmt_list_
operator|.
name|first
expr_stmt|;
name|ffestd_stmt_list_
operator|.
name|last
operator|=
operator|(
name|ffestdStmt_
operator|)
operator|&
name|ffestd_stmt_list_
operator|.
name|first
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate "code" for "any" label def.  */
end_comment

begin_function
name|void
name|ffestd_labeldef_any
parameter_list|(
name|ffelab
name|label
name|UNUSED
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* ffestd_labeldef_branch -- Generate "code" for branch label def     ffestd_labeldef_branch(label);  */
end_comment

begin_function
name|void
name|ffestd_labeldef_branch
parameter_list|(
name|ffelab
name|label
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidEXECLABEL_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|execlabel
operator|.
name|label
operator|=
name|label
expr_stmt|;
name|ffestd_is_reachable_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_labeldef_format -- Generate "code" for FORMAT label def     ffestd_labeldef_format(label);  */
end_comment

begin_function
name|void
name|ffestd_labeldef_format
parameter_list|(
name|ffelab
name|label
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_label_formatdef_
operator|=
name|label
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidFORMATLABEL_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|formatlabel
operator|.
name|label
operator|=
name|label
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_labeldef_useless -- Generate "code" for useless label def     ffestd_labeldef_useless(label);  */
end_comment

begin_function
name|void
name|ffestd_labeldef_useless
parameter_list|(
name|ffelab
name|label
name|UNUSED
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* ffestd_R423A -- PRIVATE statement (in R422 derived-type statement)     ffestd_R423A();  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestd_R423A
parameter_list|()
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R423B -- SEQUENCE statement (in R422 derived-type-stmt)     ffestd_R423B();  */
end_comment

begin_function
name|void
name|ffestd_R423B
parameter_list|()
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R424 -- derived-TYPE-def statement     ffestd_R424(access_token,access_kw,name_token);     Handle a derived-type definition.  */
end_comment

begin_function
name|void
name|ffestd_R424
parameter_list|(
name|ffelexToken
name|access
parameter_list|,
name|ffestrOther
name|access_kw
parameter_list|,
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|FFESTD_F90
name|char
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|access
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"* TYPE %s\n"
argument_list|,
name|ffelex_token_text
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|access_kw
condition|)
block|{
case|case
name|FFESTR_otherPUBLIC
case|:
name|a
operator|=
literal|"PUBLIC"
expr_stmt|;
break|break;
case|case
name|FFESTR_otherPRIVATE
case|:
name|a
operator|=
literal|"PRIVATE"
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"* TYPE,%s: %s\n"
argument_list|,
name|a
argument_list|,
name|ffelex_token_text
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R425 -- End a TYPE     ffestd_R425(TRUE);  */
end_comment

begin_function
name|void
name|ffestd_R425
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* ffestd_R519_start -- INTENT statement list begin     ffestd_R519_start();     Verify that INTENT is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestd_R519_start
parameter_list|(
name|ffestrOther
name|intent_kw
parameter_list|)
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|FFESTD_F90
name|char
modifier|*
name|a
decl_stmt|;
switch|switch
condition|(
name|intent_kw
condition|)
block|{
case|case
name|FFESTR_otherIN
case|:
name|a
operator|=
literal|"IN"
expr_stmt|;
break|break;
case|case
name|FFESTR_otherOUT
case|:
name|a
operator|=
literal|"OUT"
expr_stmt|;
break|break;
case|case
name|FFESTR_otherINOUT
case|:
name|a
operator|=
literal|"INOUT"
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"* INTENT (%s) "
argument_list|,
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R519_item -- INTENT statement for name     ffestd_R519_item(name_token);     Make sure name_token identifies a valid object to be INTENTed.  */
end_comment

begin_function
name|void
name|ffestd_R519_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"%s,"
argument_list|,
name|ffelex_token_text
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R519_finish -- INTENT statement list complete     ffestd_R519_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R519_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R520_start -- OPTIONAL statement list begin     ffestd_R520_start();     Verify that OPTIONAL is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestd_R520_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
literal|"* OPTIONAL "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R520_item -- OPTIONAL statement for name     ffestd_R520_item(name_token);     Make sure name_token identifies a valid object to be OPTIONALed.  */
end_comment

begin_function
name|void
name|ffestd_R520_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"%s,"
argument_list|,
name|ffelex_token_text
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R520_finish -- OPTIONAL statement list complete     ffestd_R520_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R520_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R521A -- PUBLIC statement     ffestd_R521A();     Verify that PUBLIC is valid here.  */
end_comment

begin_function
name|void
name|ffestd_R521A
parameter_list|()
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
literal|"* PUBLIC\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R521Astart -- PUBLIC statement list begin     ffestd_R521Astart();     Verify that PUBLIC is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestd_R521Astart
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
literal|"* PUBLIC "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R521Aitem -- PUBLIC statement for name     ffestd_R521Aitem(name_token);     Make sure name_token identifies a valid object to be PUBLICed.  */
end_comment

begin_function
name|void
name|ffestd_R521Aitem
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"%s,"
argument_list|,
name|ffelex_token_text
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R521Afinish -- PUBLIC statement list complete     ffestd_R521Afinish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R521Afinish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R521B -- PRIVATE statement     ffestd_R521B();     Verify that PRIVATE is valid here (outside a derived-type statement).  */
end_comment

begin_function
name|void
name|ffestd_R521B
parameter_list|()
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
literal|"* PRIVATE_outside_of_R422_derived_type_def\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R521Bstart -- PRIVATE statement list begin     ffestd_R521Bstart();     Verify that PRIVATE is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestd_R521Bstart
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
literal|"* PRIVATE "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R521Bitem -- PRIVATE statement for name     ffestd_R521Bitem(name_token);     Make sure name_token identifies a valid object to be PRIVATEed.  */
end_comment

begin_function
name|void
name|ffestd_R521Bitem
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"%s,"
argument_list|,
name|ffelex_token_text
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R521Bfinish -- PRIVATE statement list complete     ffestd_R521Bfinish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R521Bfinish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_R522 -- SAVE statement with no list     ffestd_R522();     Verify that SAVE is valid here, and flag everything as SAVEd.  */
end_comment

begin_function
name|void
name|ffestd_R522
parameter_list|()
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R522start -- SAVE statement list begin     ffestd_R522start();     Verify that SAVE is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestd_R522start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R522item_object -- SAVE statement for object-name     ffestd_R522item_object(name_token);     Make sure name_token identifies a valid object to be SAVEd.	*/
end_comment

begin_function
name|void
name|ffestd_R522item_object
parameter_list|(
name|ffelexToken
name|name
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R522item_cblock -- SAVE statement for common-block-name     ffestd_R522item_cblock(name_token);     Make sure name_token identifies a valid common block to be SAVEd.  */
end_comment

begin_function
name|void
name|ffestd_R522item_cblock
parameter_list|(
name|ffelexToken
name|name
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R522finish -- SAVE statement list complete     ffestd_R522finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R522finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R524_start -- DIMENSION statement list begin     ffestd_R524_start(bool virtual);     Verify that DIMENSION is valid here, and begin accepting items in the list.	*/
end_comment

begin_function
name|void
name|ffestd_R524_start
parameter_list|(
name|bool
name|virtual
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R524_item -- DIMENSION statement for object-name     ffestd_R524_item(name_token,dim_list);     Make sure name_token identifies a valid object to be DIMENSIONd.  */
end_comment

begin_function
name|void
name|ffestd_R524_item
parameter_list|(
name|ffelexToken
name|name
name|UNUSED
parameter_list|,
name|ffesttDimList
name|dims
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R524_finish -- DIMENSION statement list complete     ffestd_R524_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R524_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R525_start -- ALLOCATABLE statement list begin     ffestd_R525_start();     Verify that ALLOCATABLE is valid here, and begin accepting items in the    list.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestd_R525_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
literal|"* ALLOCATABLE "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R525_item -- ALLOCATABLE statement for object-name     ffestd_R525_item(name_token,dim_list);     Make sure name_token identifies a valid object to be ALLOCATABLEd.  */
end_comment

begin_function
name|void
name|ffestd_R525_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
name|ffelex_token_text
argument_list|(
name|name
argument_list|)
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
if|if
condition|(
name|dims
operator|!=
name|NULL
condition|)
block|{
name|fputc
argument_list|(
literal|'('
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffestt_dimlist_dump
argument_list|(
name|dims
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R525_finish -- ALLOCATABLE statement list complete     ffestd_R525_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R525_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R526_start -- POINTER statement list begin     ffestd_R526_start();     Verify that POINTER is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestd_R526_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
literal|"* POINTER "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R526_item -- POINTER statement for object-name     ffestd_R526_item(name_token,dim_list);     Make sure name_token identifies a valid object to be POINTERd.  */
end_comment

begin_function
name|void
name|ffestd_R526_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
name|ffelex_token_text
argument_list|(
name|name
argument_list|)
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
if|if
condition|(
name|dims
operator|!=
name|NULL
condition|)
block|{
name|fputc
argument_list|(
literal|'('
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffestt_dimlist_dump
argument_list|(
name|dims
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R526_finish -- POINTER statement list complete     ffestd_R526_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R526_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R527_start -- TARGET statement list begin     ffestd_R527_start();     Verify that TARGET is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestd_R527_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
literal|"* TARGET "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R527_item -- TARGET statement for object-name     ffestd_R527_item(name_token,dim_list);     Make sure name_token identifies a valid object to be TARGETd.  */
end_comment

begin_function
name|void
name|ffestd_R527_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
name|ffelex_token_text
argument_list|(
name|name
argument_list|)
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
if|if
condition|(
name|dims
operator|!=
name|NULL
condition|)
block|{
name|fputc
argument_list|(
literal|'('
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffestt_dimlist_dump
argument_list|(
name|dims
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R527_finish -- TARGET statement list complete     ffestd_R527_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R527_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_R537_start -- PARAMETER statement list begin     ffestd_R537_start();     Verify that PARAMETER is valid here, and begin accepting items in the list.	*/
end_comment

begin_function
name|void
name|ffestd_R537_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R537_item -- PARAMETER statement assignment     ffestd_R537_item(dest,dest_token,source,source_token);     Make sure the source is a valid source for the destination; make the    assignment.	*/
end_comment

begin_function
name|void
name|ffestd_R537_item
parameter_list|(
name|ffebld
name|dest
name|UNUSED
parameter_list|,
name|ffebld
name|source
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R537_finish -- PARAMETER statement list complete     ffestd_R537_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R537_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R539 -- IMPLICIT NONE statement     ffestd_R539();     Verify that the IMPLICIT NONE statement is ok here and implement.  */
end_comment

begin_function
name|void
name|ffestd_R539
parameter_list|()
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R539start -- IMPLICIT statement     ffestd_R539start();     Verify that the IMPLICIT statement is ok here and implement.	 */
end_comment

begin_function
name|void
name|ffestd_R539start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R539item -- IMPLICIT statement specification (R540)     ffestd_R539item(...);     Verify that the type and letter list are all ok and implement.  */
end_comment

begin_function
name|void
name|ffestd_R539item
parameter_list|(
name|ffestpType
name|type
name|UNUSED
parameter_list|,
name|ffebld
name|kind
name|UNUSED
parameter_list|,
name|ffelexToken
name|kindt
name|UNUSED
parameter_list|,
name|ffebld
name|len
name|UNUSED
parameter_list|,
name|ffelexToken
name|lent
name|UNUSED
parameter_list|,
name|ffesttImpList
name|letters
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R539finish -- IMPLICIT statement     ffestd_R539finish();     Finish up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R539finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R542_start -- NAMELIST statement list begin     ffestd_R542_start();     Verify that NAMELIST is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestd_R542_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R542_item_nlist -- NAMELIST statement for group-name     ffestd_R542_item_nlist(groupname_token);     Make sure name_token identifies a valid object to be NAMELISTd.  */
end_comment

begin_function
name|void
name|ffestd_R542_item_nlist
parameter_list|(
name|ffelexToken
name|name
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R542_item_nitem -- NAMELIST statement for variable-name     ffestd_R542_item_nitem(name_token);     Make sure name_token identifies a valid object to be NAMELISTd.  */
end_comment

begin_function
name|void
name|ffestd_R542_item_nitem
parameter_list|(
name|ffelexToken
name|name
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R542_finish -- NAMELIST statement list complete     ffestd_R542_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R542_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R544_start -- EQUIVALENCE statement list begin     ffestd_R544_start();     Verify that EQUIVALENCE is valid here, and begin accepting items in the    list.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void ffestd_R544_start () {   ffestd_check_start_ (); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_R544_item -- EQUIVALENCE statement assignment     ffestd_R544_item(exprlist);     Make sure the equivalence is valid, then implement it.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void ffestd_R544_item (ffesttExprList exprlist) {   ffestd_check_item_ (); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_R544_finish -- EQUIVALENCE statement list complete     ffestd_R544_finish();     Just wrap up any local activities.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void ffestd_R544_finish () {   ffestd_check_finish_ (); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_R547_start -- COMMON statement list begin     ffestd_R547_start();     Verify that COMMON is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestd_R547_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R547_item_object -- COMMON statement for object-name     ffestd_R547_item_object(name_token,dim_list);     Make sure name_token identifies a valid object to be COMMONd.  */
end_comment

begin_function
name|void
name|ffestd_R547_item_object
parameter_list|(
name|ffelexToken
name|name
name|UNUSED
parameter_list|,
name|ffesttDimList
name|dims
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R547_item_cblock -- COMMON statement for common-block-name     ffestd_R547_item_cblock(name_token);     Make sure name_token identifies a valid common block to be COMMONd.	*/
end_comment

begin_function
name|void
name|ffestd_R547_item_cblock
parameter_list|(
name|ffelexToken
name|name
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R547_finish -- COMMON statement list complete     ffestd_R547_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R547_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R620 -- ALLOCATE statement     ffestd_R620(exprlist,stat,stat_token);     Make sure the expression list is valid, then implement it.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestd_R620
parameter_list|(
name|ffesttExprList
name|exprlist
parameter_list|,
name|ffebld
name|stat
parameter_list|)
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R624 -- NULLIFY statement     ffestd_R624(pointer_name_list);     Make sure pointer_name_list identifies valid pointers for a NULLIFY.	 */
end_comment

begin_function
name|void
name|ffestd_R624
parameter_list|(
name|ffesttExprList
name|pointers
parameter_list|)
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
literal|"+ NULLIFY ("
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pointers
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffestt_exprlist_dump
argument_list|(
name|pointers
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R625 -- DEALLOCATE statement     ffestd_R625(exprlist,stat,stat_token);     Make sure the equivalence is valid, then implement it.  */
end_comment

begin_function
name|void
name|ffestd_R625
parameter_list|(
name|ffesttExprList
name|exprlist
parameter_list|,
name|ffebld
name|stat
parameter_list|)
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_R737A -- Assignment statement outside of WHERE     ffestd_R737A(dest_expr,source_expr);	 */
end_comment

begin_function
name|void
name|ffestd_R737A
parameter_list|(
name|ffebld
name|dest
parameter_list|,
name|ffebld
name|source
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR737A_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R737A
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R737A
operator|.
name|dest
operator|=
name|dest
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R737A
operator|.
name|source
operator|=
name|source
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R737B -- Assignment statement inside of WHERE     ffestd_R737B(dest_expr,source_expr);	 */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestd_R737B
parameter_list|(
name|ffebld
name|dest
parameter_list|,
name|ffebld
name|source
parameter_list|)
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R738 -- Pointer assignment statement     ffestd_R738(dest_expr,source_expr,source_token);     Make sure the assignment is valid.  */
end_comment

begin_function
name|void
name|ffestd_R738
parameter_list|(
name|ffebld
name|dest
parameter_list|,
name|ffebld
name|source
parameter_list|)
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R740 -- WHERE statement     ffestd_R740(expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestd_R740
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R742 -- WHERE-construct statement     ffestd_R742(expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestd_R742
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R744 -- ELSE WHERE statement     ffestd_R744();     Make sure ffestd_kind_ identifies a WHERE block.    Implement the ELSE of the current WHERE block.  */
end_comment

begin_function
name|void
name|ffestd_R744
parameter_list|()
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
literal|"+ ELSE_WHERE\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R745 -- Implicit END WHERE statement.  */
end_comment

begin_function
name|void
name|ffestd_R745
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
literal|"+ END_WHERE\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
comment|/* Also see ffestd_R745. */
operator|--
name|ffestd_block_level_
expr_stmt|;
name|assert
argument_list|(
name|ffestd_block_level_
operator|>=
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Block IF (IF-THEN) statement.  */
end_comment

begin_function
name|void
name|ffestd_R803
parameter_list|(
name|ffelexToken
name|construct_name
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR803_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R803
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R803
operator|.
name|block
operator|=
name|ffestw_use
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R803
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
operator|++
name|ffestd_block_level_
expr_stmt|;
name|assert
argument_list|(
name|ffestd_block_level_
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ELSE IF statement.  */
end_comment

begin_function
name|void
name|ffestd_R804
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|name
name|UNUSED
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR804_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R804
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R804
operator|.
name|block
operator|=
name|ffestw_use
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R804
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ELSE statement.  */
end_comment

begin_function
name|void
name|ffestd_R805
parameter_list|(
name|ffelexToken
name|name
name|UNUSED
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR805_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R805
operator|.
name|block
operator|=
name|ffestw_use
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* END IF statement.  */
end_comment

begin_function
name|void
name|ffestd_R806
parameter_list|(
name|bool
name|ok
name|UNUSED
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR806_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R806
operator|.
name|block
operator|=
name|ffestw_use
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
expr_stmt|;
operator|--
name|ffestd_block_level_
expr_stmt|;
name|assert
argument_list|(
name|ffestd_block_level_
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R807 -- Logical IF statement     ffestd_R807(expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestd_R807
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR807_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R807
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R807
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
operator|++
name|ffestd_block_level_
expr_stmt|;
name|assert
argument_list|(
name|ffestd_block_level_
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R809 -- SELECT CASE statement     ffestd_R809(construct_name,expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestd_R809
parameter_list|(
name|ffelexToken
name|construct_name
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR809_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R809
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R809
operator|.
name|block
operator|=
name|ffestw_use
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R809
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
name|malloc_pool_use
argument_list|(
name|ffestw_select
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|->
name|pool
argument_list|)
expr_stmt|;
operator|++
name|ffestd_block_level_
expr_stmt|;
name|assert
argument_list|(
name|ffestd_block_level_
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R810 -- CASE statement     ffestd_R810(case_value_range_list,name);     If casenum is 0, it's CASE DEFAULT.	Else it's the case ranges at    the start of the first_stmt list in the select object at the top of    the stack that match casenum.  */
end_comment

begin_function
name|void
name|ffestd_R810
parameter_list|(
name|unsigned
name|long
name|casenum
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR810_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R810
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R810
operator|.
name|block
operator|=
name|ffestw_stack_top
argument_list|()
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R810
operator|.
name|casenum
operator|=
name|casenum
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R811 -- End a SELECT     ffestd_R811(TRUE);  */
end_comment

begin_function
name|void
name|ffestd_R811
parameter_list|(
name|bool
name|ok
name|UNUSED
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR811_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R811
operator|.
name|block
operator|=
name|ffestw_stack_top
argument_list|()
expr_stmt|;
operator|--
name|ffestd_block_level_
expr_stmt|;
name|assert
argument_list|(
name|ffestd_block_level_
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R819A -- Iterative DO statement     ffestd_R819A(construct_name,label_token,expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestd_R819A
parameter_list|(
name|ffelexToken
name|construct_name
name|UNUSED
parameter_list|,
name|ffelab
name|label
parameter_list|,
name|ffebld
name|var
parameter_list|,
name|ffebld
name|start
parameter_list|,
name|ffelexToken
name|start_token
parameter_list|,
name|ffebld
name|end
parameter_list|,
name|ffelexToken
name|end_token
parameter_list|,
name|ffebld
name|incr
parameter_list|,
name|ffelexToken
name|incr_token
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR819A_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|block
operator|=
name|ffestw_use
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|label
operator|=
name|label
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|var
operator|=
name|var
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|start_token
operator|=
name|ffelex_token_use
argument_list|(
name|start_token
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|end
operator|=
name|end
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|end_token
operator|=
name|ffelex_token_use
argument_list|(
name|end_token
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|incr
operator|=
name|incr
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R819A
operator|.
name|incr_token
operator|=
operator|(
name|incr_token
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|ffelex_token_use
argument_list|(
name|incr_token
argument_list|)
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
operator|++
name|ffestd_block_level_
expr_stmt|;
name|assert
argument_list|(
name|ffestd_block_level_
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R819B -- DO WHILE statement     ffestd_R819B(construct_name,label_token,expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestd_R819B
parameter_list|(
name|ffelexToken
name|construct_name
name|UNUSED
parameter_list|,
name|ffelab
name|label
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR819B_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R819B
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R819B
operator|.
name|block
operator|=
name|ffestw_use
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R819B
operator|.
name|label
operator|=
name|label
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R819B
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
operator|++
name|ffestd_block_level_
expr_stmt|;
name|assert
argument_list|(
name|ffestd_block_level_
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R825 -- END DO statement     ffestd_R825(name_token);     Make sure ffestd_kind_ identifies a DO block.  If not    NULL, make sure name_token gives the correct name.  Do whatever    is specific to seeing END DO with a DO-target label definition on it,    where the END DO is really treated as a CONTINUE (i.e. generate th    same code you would for CONTINUE).  ffestd_do handles the actual    generation of end-loop code.	 */
end_comment

begin_function
name|void
name|ffestd_R825
parameter_list|(
name|ffelexToken
name|name
name|UNUSED
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR825_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R834 -- CYCLE statement     ffestd_R834(name_token);     Handle a CYCLE within a loop.  */
end_comment

begin_function
name|void
name|ffestd_R834
parameter_list|(
name|ffestw
name|block
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR834_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R834
operator|.
name|block
operator|=
name|block
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R835 -- EXIT statement     ffestd_R835(name_token);     Handle a EXIT within a loop.	 */
end_comment

begin_function
name|void
name|ffestd_R835
parameter_list|(
name|ffestw
name|block
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR835_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R835
operator|.
name|block
operator|=
name|block
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R836 -- GOTO statement     ffestd_R836(label);     Make sure label_token identifies a valid label for a GOTO.  Update    that label's info to indicate it is the target of a GOTO.  */
end_comment

begin_function
name|void
name|ffestd_R836
parameter_list|(
name|ffelab
name|label
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR836_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R836
operator|.
name|label
operator|=
name|label
expr_stmt|;
if|if
condition|(
name|ffestd_block_level_
operator|==
literal|0
condition|)
name|ffestd_is_reachable_
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R837 -- Computed GOTO statement     ffestd_R837(labels,expr);     Make sure label_list identifies valid labels for a GOTO.  Update    each label's info to indicate it is the target of a GOTO.  */
end_comment

begin_function
name|void
name|ffestd_R837
parameter_list|(
name|ffelab
modifier|*
name|labels
parameter_list|,
name|int
name|count
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR837_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R837
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R837
operator|.
name|labels
operator|=
name|labels
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R837
operator|.
name|count
operator|=
name|count
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R837
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R838 -- ASSIGN statement     ffestd_R838(label_token,target_variable,target_token);     Make sure label_token identifies a valid label for an assignment.  Update    that label's info to indicate it is the source of an assignment.  Update    target_variable's info to indicate it is the target the assignment of that    label.  */
end_comment

begin_function
name|void
name|ffestd_R838
parameter_list|(
name|ffelab
name|label
parameter_list|,
name|ffebld
name|target
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR838_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R838
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R838
operator|.
name|label
operator|=
name|label
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R838
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R839 -- Assigned GOTO statement     ffestd_R839(target,labels);     Make sure label_list identifies valid labels for a GOTO.  Update    each label's info to indicate it is the target of a GOTO.  */
end_comment

begin_function
name|void
name|ffestd_R839
parameter_list|(
name|ffebld
name|target
parameter_list|,
name|ffelab
modifier|*
name|labels
name|UNUSED
parameter_list|,
name|int
name|count
name|UNUSED
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR839_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R839
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R839
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestd_block_level_
operator|==
literal|0
condition|)
name|ffestd_is_reachable_
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R840 -- Arithmetic IF statement     ffestd_R840(expr,expr_token,neg,zero,pos);     Make sure the labels are valid; implement.  */
end_comment

begin_function
name|void
name|ffestd_R840
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelab
name|neg
parameter_list|,
name|ffelab
name|zero
parameter_list|,
name|ffelab
name|pos
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR840_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R840
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R840
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R840
operator|.
name|neg
operator|=
name|neg
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R840
operator|.
name|zero
operator|=
name|zero
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R840
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestd_block_level_
operator|==
literal|0
condition|)
name|ffestd_is_reachable_
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R841 -- CONTINUE statement     ffestd_R841();  */
end_comment

begin_function
name|void
name|ffestd_R841
parameter_list|(
name|bool
name|in_where
name|UNUSED
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR841_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R842 -- STOP statement     ffestd_R842(expr);  */
end_comment

begin_function
name|void
name|ffestd_R842
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR842_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesta_outpooldisp
argument_list|()
operator|==
name|FFESTA_pooldispPRESERVE
condition|)
block|{
comment|/* This is a "spurious" (automatically-generated) STOP 	 that follows a previous STOP or other statement. 	 Make sure we don't have an expression in the pool, 	 and then mark that the pool has already been killed.  */
name|assert
argument_list|(
name|expr
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R842
operator|.
name|pool
operator|=
name|NULL
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R842
operator|.
name|expr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|stmt
operator|->
name|u
operator|.
name|R842
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R842
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffestd_block_level_
operator|==
literal|0
condition|)
name|ffestd_is_reachable_
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R843 -- PAUSE statement     ffestd_R843(expr,expr_token);     Make sure statement is valid here; implement.  expr and expr_token are    both NULL if there was no expression.  */
end_comment

begin_function
name|void
name|ffestd_R843
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR843_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R843
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R843
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R904 -- OPEN statement     ffestd_R904();     Make sure an OPEN is valid in the current context, and implement it.	 */
end_comment

begin_function
name|void
name|ffestd_R904
parameter_list|()
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
define|#
directive|define
name|specified
parameter_list|(
name|something
parameter_list|)
define|\
value|(ffestp_file.open.open_spec[something].kw_or_val_present)
comment|/* Warn if there are any thing we don't handle via f2c libraries. */
if|if
condition|(
name|specified
argument_list|(
name|FFESTP_openixACTION
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixASSOCIATEVARIABLE
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixBLOCKSIZE
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixBUFFERCOUNT
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixCARRIAGECONTROL
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixDEFAULTFILE
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixDELIM
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixDISPOSE
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixEXTENDSIZE
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixINITIALSIZE
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixKEY
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixMAXREC
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixNOSPANBLOCKS
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixORGANIZATION
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixPAD
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixPOSITION
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixREADONLY
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixRECORDTYPE
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixSHARED
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_openixUSEROPEN
argument_list|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_OPEN_UNSUPPORTED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
undef|#
directive|undef
name|specified
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR904_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R904
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R904
operator|.
name|params
operator|=
name|ffestd_subr_copy_open_
argument_list|()
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R907 -- CLOSE statement     ffestd_R907();     Make sure a CLOSE is valid in the current context, and implement it.	 */
end_comment

begin_function
name|void
name|ffestd_R907
parameter_list|()
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR907_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R907
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R907
operator|.
name|params
operator|=
name|ffestd_subr_copy_close_
argument_list|()
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R909_start -- READ(...) statement list begin     ffestd_R909_start(FALSE);     Verify that READ is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestd_R909_start
parameter_list|(
name|bool
name|only_format
parameter_list|,
name|ffestvUnit
name|unit
parameter_list|,
name|ffestvFormat
name|format
parameter_list|,
name|bool
name|rec
parameter_list|,
name|bool
name|key
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_start_
argument_list|()
expr_stmt|;
define|#
directive|define
name|specified
parameter_list|(
name|something
parameter_list|)
define|\
value|(ffestp_file.read.read_spec[something].kw_or_val_present)
comment|/* Warn if there are any thing we don't handle via f2c libraries. */
if|if
condition|(
name|specified
argument_list|(
name|FFESTP_readixADVANCE
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_readixEOR
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_readixKEYEQ
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_readixKEYGE
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_readixKEYGT
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_readixKEYID
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_readixNULLS
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_readixSIZE
argument_list|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_READ_UNSUPPORTED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
undef|#
directive|undef
name|specified
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR909_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|params
operator|=
name|ffestd_subr_copy_read_
argument_list|()
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|only_format
operator|=
name|only_format
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|unit
operator|=
name|unit
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|format
operator|=
name|format
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|rec
operator|=
name|rec
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|list
operator|=
name|NULL
expr_stmt|;
name|ffestd_expr_list_
operator|=
operator|&
name|stmt
operator|->
name|u
operator|.
name|R909
operator|.
name|list
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R909_item -- READ statement i/o item     ffestd_R909_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestd_R909_item
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestdExprItem_
name|item
decl_stmt|;
name|ffestd_check_item_
argument_list|()
expr_stmt|;
name|item
operator|=
operator|(
name|ffestdExprItem_
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_output_pool
argument_list|,
literal|"ffestdExprItem_"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|item
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
name|item
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|expr_token
argument_list|)
expr_stmt|;
operator|*
name|ffestd_expr_list_
operator|=
name|item
expr_stmt|;
name|ffestd_expr_list_
operator|=
operator|&
name|item
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R909_finish -- READ statement list complete     ffestd_R909_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R909_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R910_start -- WRITE(...) statement list begin     ffestd_R910_start();     Verify that WRITE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestd_R910_start
parameter_list|(
name|ffestvUnit
name|unit
parameter_list|,
name|ffestvFormat
name|format
parameter_list|,
name|bool
name|rec
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_start_
argument_list|()
expr_stmt|;
define|#
directive|define
name|specified
parameter_list|(
name|something
parameter_list|)
define|\
value|(ffestp_file.write.write_spec[something].kw_or_val_present)
comment|/* Warn if there are any thing we don't handle via f2c libraries. */
if|if
condition|(
name|specified
argument_list|(
name|FFESTP_writeixADVANCE
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_writeixEOR
argument_list|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_WRITE_UNSUPPORTED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
undef|#
directive|undef
name|specified
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR910_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R910
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R910
operator|.
name|params
operator|=
name|ffestd_subr_copy_write_
argument_list|()
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R910
operator|.
name|unit
operator|=
name|unit
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R910
operator|.
name|format
operator|=
name|format
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R910
operator|.
name|rec
operator|=
name|rec
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R910
operator|.
name|list
operator|=
name|NULL
expr_stmt|;
name|ffestd_expr_list_
operator|=
operator|&
name|stmt
operator|->
name|u
operator|.
name|R910
operator|.
name|list
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R910_item -- WRITE statement i/o item     ffestd_R910_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestd_R910_item
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestdExprItem_
name|item
decl_stmt|;
name|ffestd_check_item_
argument_list|()
expr_stmt|;
name|item
operator|=
operator|(
name|ffestdExprItem_
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_output_pool
argument_list|,
literal|"ffestdExprItem_"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|item
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
name|item
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|expr_token
argument_list|)
expr_stmt|;
operator|*
name|ffestd_expr_list_
operator|=
name|item
expr_stmt|;
name|ffestd_expr_list_
operator|=
operator|&
name|item
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R910_finish -- WRITE statement list complete     ffestd_R910_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R910_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R911_start -- PRINT statement list begin     ffestd_R911_start();     Verify that PRINT is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestd_R911_start
parameter_list|(
name|ffestvFormat
name|format
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR911_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R911
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R911
operator|.
name|params
operator|=
name|ffestd_subr_copy_print_
argument_list|()
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R911
operator|.
name|format
operator|=
name|format
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R911
operator|.
name|list
operator|=
name|NULL
expr_stmt|;
name|ffestd_expr_list_
operator|=
operator|&
name|stmt
operator|->
name|u
operator|.
name|R911
operator|.
name|list
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R911_item -- PRINT statement i/o item     ffestd_R911_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestd_R911_item
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestdExprItem_
name|item
decl_stmt|;
name|ffestd_check_item_
argument_list|()
expr_stmt|;
name|item
operator|=
operator|(
name|ffestdExprItem_
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_output_pool
argument_list|,
literal|"ffestdExprItem_"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|item
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
name|item
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|expr_token
argument_list|)
expr_stmt|;
operator|*
name|ffestd_expr_list_
operator|=
name|item
expr_stmt|;
name|ffestd_expr_list_
operator|=
operator|&
name|item
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R911_finish -- PRINT statement list complete     ffestd_R911_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R911_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R919 -- BACKSPACE statement     ffestd_R919();     Make sure a BACKSPACE is valid in the current context, and implement it.  */
end_comment

begin_function
name|void
name|ffestd_R919
parameter_list|()
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR919_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R919
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R919
operator|.
name|params
operator|=
name|ffestd_subr_copy_beru_
argument_list|()
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R920 -- ENDFILE statement     ffestd_R920();     Make sure a ENDFILE is valid in the current context, and implement it.  */
end_comment

begin_function
name|void
name|ffestd_R920
parameter_list|()
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR920_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R920
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R920
operator|.
name|params
operator|=
name|ffestd_subr_copy_beru_
argument_list|()
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R921 -- REWIND statement     ffestd_R921();     Make sure a REWIND is valid in the current context, and implement it.  */
end_comment

begin_function
name|void
name|ffestd_R921
parameter_list|()
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR921_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R921
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R921
operator|.
name|params
operator|=
name|ffestd_subr_copy_beru_
argument_list|()
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R923A -- INQUIRE statement (non-IOLENGTH version)     ffestd_R923A(bool by_file);     Make sure an INQUIRE is valid in the current context, and implement it.  */
end_comment

begin_function
name|void
name|ffestd_R923A
parameter_list|(
name|bool
name|by_file
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
define|#
directive|define
name|specified
parameter_list|(
name|something
parameter_list|)
define|\
value|(ffestp_file.inquire.inquire_spec[something].kw_or_val_present)
comment|/* Warn if there are any thing we don't handle via f2c libraries. */
if|if
condition|(
name|specified
argument_list|(
name|FFESTP_inquireixACTION
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_inquireixCARRIAGECONTROL
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_inquireixDEFAULTFILE
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_inquireixDELIM
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_inquireixKEYED
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_inquireixORGANIZATION
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_inquireixPAD
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_inquireixPOSITION
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_inquireixREAD
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_inquireixREADWRITE
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_inquireixRECORDTYPE
argument_list|)
operator|||
name|specified
argument_list|(
name|FFESTP_inquireixWRITE
argument_list|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INQUIRE_UNSUPPORTED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
undef|#
directive|undef
name|specified
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR923A_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R923A
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R923A
operator|.
name|params
operator|=
name|ffestd_subr_copy_inquire_
argument_list|()
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R923A
operator|.
name|by_file
operator|=
name|by_file
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R923B_start -- INQUIRE(IOLENGTH=expr) statement list begin     ffestd_R923B_start();     Verify that INQUIRE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestd_R923B_start
parameter_list|()
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR923B_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R923B
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R923B
operator|.
name|params
operator|=
name|ffestd_subr_copy_inquire_
argument_list|()
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R923B
operator|.
name|list
operator|=
name|NULL
expr_stmt|;
name|ffestd_expr_list_
operator|=
operator|&
name|stmt
operator|->
name|u
operator|.
name|R923B
operator|.
name|list
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R923B_item -- INQUIRE statement i/o item     ffestd_R923B_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestd_R923B_item
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestdExprItem_
name|item
decl_stmt|;
name|ffestd_check_item_
argument_list|()
expr_stmt|;
name|item
operator|=
operator|(
name|ffestdExprItem_
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_output_pool
argument_list|,
literal|"ffestdExprItem_"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|item
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
operator|*
name|ffestd_expr_list_
operator|=
name|item
expr_stmt|;
name|ffestd_expr_list_
operator|=
operator|&
name|item
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R923B_finish -- INQUIRE statement list complete     ffestd_R923B_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R923B_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1001 -- FORMAT statement     ffestd_R1001(format_list);  */
end_comment

begin_function
name|void
name|ffestd_R1001
parameter_list|(
name|ffesttFormatList
name|f
parameter_list|)
block|{
name|ffestsHolder
name|str
decl_stmt|;
name|ffests
name|s
init|=
operator|&
name|str
decl_stmt|;
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestd_label_formatdef_
operator|==
name|NULL
condition|)
return|return;
comment|/* Nothing to hook it up to (no label def). */
name|ffests_new
argument_list|(
name|s
argument_list|,
name|malloc_pool_image
argument_list|()
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|ffests_putc
argument_list|(
name|s
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|ffestd_R1001dump_
argument_list|(
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* Build the string in s. */
name|ffests_putc
argument_list|(
name|s
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR1001_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R1001
operator|.
name|str
operator|=
name|str
expr_stmt|;
name|ffestd_label_formatdef_
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1001dump_ -- Dump list of formats     ffesttFormatList list;    ffestd_R1001dump_(list,0);     The formats in the list are dumped.	*/
end_comment

begin_function
specifier|static
name|void
name|ffestd_R1001dump_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|list
parameter_list|)
block|{
name|ffesttFormatList
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|list
operator|->
name|next
init|;
name|next
operator|!=
name|list
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
if|if
condition|(
name|next
operator|!=
name|list
operator|->
name|next
condition|)
name|ffests_putc
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|next
operator|->
name|type
condition|)
block|{
case|case
name|FFESTP_formattypeI
case|:
name|ffestd_R1001dump_1005_3_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"I"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeB
case|:
name|ffestd_R1001error_
argument_list|(
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeO
case|:
name|ffestd_R1001dump_1005_3_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"O"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeZ
case|:
name|ffestd_R1001dump_1005_3_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"Z"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeF
case|:
name|ffestd_R1001dump_1005_4_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"F"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeE
case|:
name|ffestd_R1001dump_1005_5_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"E"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeEN
case|:
name|ffestd_R1001error_
argument_list|(
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeG
case|:
name|ffestd_R1001dump_1005_5_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"G"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeL
case|:
name|ffestd_R1001dump_1005_2_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"L"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeA
case|:
name|ffestd_R1001dump_1005_1_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"A"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeD
case|:
name|ffestd_R1001dump_1005_4_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeQ
case|:
name|ffestd_R1001error_
argument_list|(
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeDOLLAR
case|:
name|ffestd_R1001dump_1010_1_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"$"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeP
case|:
name|ffestd_R1001dump_1010_4_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"P"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeT
case|:
name|ffestd_R1001dump_1010_5_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeTL
case|:
name|ffestd_R1001dump_1010_5_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"TL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeTR
case|:
name|ffestd_R1001dump_1010_5_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"TR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeX
case|:
name|ffestd_R1001dump_1010_3_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"X"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeS
case|:
name|ffestd_R1001dump_1010_1_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"S"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeSP
case|:
name|ffestd_R1001dump_1010_1_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"SP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeSS
case|:
name|ffestd_R1001dump_1010_1_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"SS"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeBN
case|:
name|ffestd_R1001dump_1010_1_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"BN"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeBZ
case|:
name|ffestd_R1001dump_1010_1_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"BZ"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeSLASH
case|:
name|ffestd_R1001dump_1010_2_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeCOLON
case|:
name|ffestd_R1001dump_1010_1_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeR1016
case|:
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|next
operator|->
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCHARACTER
case|:
block|{
name|char
modifier|*
name|p
init|=
name|ffelex_token_text
argument_list|(
name|next
operator|->
name|t
argument_list|)
decl_stmt|;
name|ffeTokenLength
name|i
init|=
name|ffelex_token_length
argument_list|(
name|next
operator|->
name|t
argument_list|)
decl_stmt|;
name|ffests_putc
argument_list|(
name|s
argument_list|,
literal|'\002'
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\002'
condition|)
name|ffests_putc
argument_list|(
name|s
argument_list|,
literal|'\002'
argument_list|)
expr_stmt|;
name|ffests_putc
argument_list|(
name|s
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|ffests_putc
argument_list|(
name|s
argument_list|,
literal|'\002'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FFELEX_typeHOLLERITH
case|:
block|{
name|char
modifier|*
name|p
init|=
name|ffelex_token_text
argument_list|(
name|next
operator|->
name|t
argument_list|)
decl_stmt|;
name|ffeTokenLength
name|i
init|=
name|ffelex_token_length
argument_list|(
name|next
operator|->
name|t
argument_list|)
decl_stmt|;
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%"
name|ffeTokenLength_f
literal|"uH"
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|!=
literal|0
condition|)
block|{
name|ffests_putc
argument_list|(
name|s
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FFESTP_formattypeFORMAT
case|:
if|if
condition|(
name|next
operator|->
name|u
operator|.
name|R1003D
operator|.
name|R1004
operator|.
name|present
condition|)
block|{
if|if
condition|(
name|next
operator|->
name|u
operator|.
name|R1003D
operator|.
name|R1004
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|next
argument_list|,
name|next
operator|->
name|u
operator|.
name|R1003D
operator|.
name|R1004
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|next
operator|->
name|u
operator|.
name|R1003D
operator|.
name|R1004
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
block|}
name|ffests_putc
argument_list|(
name|s
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|ffestd_R1001dump_
argument_list|(
name|s
argument_list|,
name|next
operator|->
name|u
operator|.
name|R1003D
operator|.
name|format
argument_list|)
expr_stmt|;
name|ffests_putc
argument_list|(
name|s
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ffestd_R1001dump_1005_1_ -- Dump a particular format     ffesttFormatList f;    ffestd_R1001dump_1005_1_(f,"I");     The format is dumped with form [r]X[w].  */
end_comment

begin_function
specifier|static
name|void
name|ffestd_R1001dump_1005_1_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|present
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1009
operator|.
name|present
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|present
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
block|}
name|ffests_puts
argument_list|(
name|s
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|present
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffestd_R1001dump_1005_2_ -- Dump a particular format     ffesttFormatList f;    ffestd_R1001dump_1005_2_(f,"I");     The format is dumped with form [r]Xw.  */
end_comment

begin_function
specifier|static
name|void
name|ffestd_R1001dump_1005_2_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|present
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1009
operator|.
name|present
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|present
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|present
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
block|}
name|ffests_puts
argument_list|(
name|s
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1001dump_1005_3_ -- Dump a particular format     ffesttFormatList f;    ffestd_R1001dump_1005_3_(f,"I");     The format is dumped with form [r]Xw[.m].  */
end_comment

begin_function
specifier|static
name|void
name|ffestd_R1001dump_1005_3_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1009
operator|.
name|present
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|present
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|present
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
block|}
name|ffests_puts
argument_list|(
name|s
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|present
condition|)
block|{
name|ffests_putc
argument_list|(
name|s
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffestd_R1001dump_1005_4_ -- Dump a particular format     ffesttFormatList f;    ffestd_R1001dump_1005_4_(f,"I");     The format is dumped with form [r]Xw.d.  */
end_comment

begin_function
specifier|static
name|void
name|ffestd_R1001dump_1005_4_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1009
operator|.
name|present
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|present
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|present
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|present
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
block|}
name|ffests_puts
argument_list|(
name|s
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
name|ffests_putc
argument_list|(
name|s
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1001dump_1005_5_ -- Dump a particular format     ffesttFormatList f;    ffestd_R1001dump_1005_5_(f,"I");     The format is dumped with form [r]Xw.d[Ee].	*/
end_comment

begin_function
specifier|static
name|void
name|ffestd_R1001dump_1005_5_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|assert
argument_list|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|present
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|present
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|present
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
block|}
name|ffests_puts
argument_list|(
name|s
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
name|ffests_putc
argument_list|(
name|s
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1009
operator|.
name|present
condition|)
block|{
name|ffests_putc
argument_list|(
name|s
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1009
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1009
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1009
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffestd_R1001dump_1010_1_ -- Dump a particular format     ffesttFormatList f;    ffestd_R1001dump_1010_1_(f,"I");     The format is dumped with form X.  */
end_comment

begin_function
specifier|static
name|void
name|ffestd_R1001dump_1010_1_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|present
argument_list|)
expr_stmt|;
name|ffests_puts
argument_list|(
name|s
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1001dump_1010_2_ -- Dump a particular format     ffesttFormatList f;    ffestd_R1001dump_1010_2_(f,"I");     The format is dumped with form [r]X.	 */
end_comment

begin_function
specifier|static
name|void
name|ffestd_R1001dump_1010_2_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|present
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
block|}
name|ffests_puts
argument_list|(
name|s
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1001dump_1010_3_ -- Dump a particular format     ffesttFormatList f;    ffestd_R1001dump_1010_3_(f,"I");     The format is dumped with form nX.  */
end_comment

begin_function
specifier|static
name|void
name|ffestd_R1001dump_1010_3_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|assert
argument_list|(
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|present
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
name|ffests_puts
argument_list|(
name|s
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1001dump_1010_4_ -- Dump a particular format     ffesttFormatList f;    ffestd_R1001dump_1010_4_(f,"I");     The format is dumped with form kX.  Note that k is signed.  */
end_comment

begin_function
specifier|static
name|void
name|ffestd_R1001dump_1010_4_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|assert
argument_list|(
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|present
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%ld"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|signed_val
argument_list|)
expr_stmt|;
name|ffests_puts
argument_list|(
name|s
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1001dump_1010_5_ -- Dump a particular format     ffesttFormatList f;    ffestd_R1001dump_1010_5_(f,"I");     The format is dumped with form Xn.  */
end_comment

begin_function
specifier|static
name|void
name|ffestd_R1001dump_1010_5_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|assert
argument_list|(
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|present
argument_list|)
expr_stmt|;
name|ffests_puts
argument_list|(
name|s
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|rtexpr
condition|)
name|ffestd_R1001rtexpr_
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
else|else
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|f
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|u
operator|.
name|unsigned_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1001error_ -- Complain about FORMAT specification not supported     ffesttFormatList f;    ffestd_R1001error_(f);     An error message is produced.  */
end_comment

begin_function
specifier|static
name|void
name|ffestd_R1001error_
parameter_list|(
name|ffesttFormatList
name|f
parameter_list|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_UNSUPPORTED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|f
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|f
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffestd_R1001rtexpr_
parameter_list|(
name|ffests
name|s
parameter_list|,
name|ffesttFormatList
name|f
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGER4
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_VARIABLE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|f
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|f
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|val
decl_stmt|;
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|val
operator|=
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|val
operator|=
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|val
operator|=
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad INTEGER constant kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_kindtypeANY
case|:
return|return;
block|}
name|ffests_printf
argument_list|(
name|s
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffestd_R1102 -- PROGRAM statement     ffestd_R1102(name_token);     Make sure ffestd_kind_ identifies an empty block.  Make sure name_token    gives a valid name.	Implement the beginning of a main program.  */
end_comment

begin_function
name|void
name|ffestd_R1102
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|name
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|ffestd_block_level_
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ffestd_is_reachable_
operator|=
name|TRUE
expr_stmt|;
name|ffecom_notify_primary_entry
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffe_set_is_mainprog
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Is a main program. */
name|ffe_set_is_saveall
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Main program always has implicit SAVE. */
name|ffestw_set_sym
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1103 -- End a PROGRAM     ffestd_R1103();  */
end_comment

begin_function
name|void
name|ffestd_R1103
parameter_list|(
name|bool
name|ok
name|UNUSED
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|assert
argument_list|(
name|ffestd_block_level_
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|FFESTD_IS_END_OPTIMIZED_
operator|&&
name|ffestd_is_reachable_
condition|)
name|ffestd_R842
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Generate STOP. */
if|if
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|FFESTV_statePROGRAM5
condition|)
name|ffestd_subr_labels_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Handle any undefined labels. */
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR1103_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1105 -- MODULE statement     ffestd_R1105(name_token);     Make sure ffestd_kind_ identifies an empty block.  Make sure name_token    gives a valid name.	Implement the beginning of a module.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestd_R1105
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|assert
argument_list|(
name|ffestd_block_level_
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"* MODULE %s\n"
argument_list|,
name|ffelex_token_text
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R1106 -- End a MODULE     ffestd_R1106(TRUE);	*/
end_comment

begin_function
name|void
name|ffestd_R1106
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
name|assert
argument_list|(
name|ffestd_block_level_
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Generate any wrap-up code here (unlikely in MODULE!). */
if|if
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|FFESTV_stateMODULE5
condition|)
name|ffestd_subr_labels_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Handle any undefined labels (unlikely). */
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"< END_MODULE %s\n"
argument_list|,
name|ffelex_token_text
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R1107_start -- USE statement list begin     ffestd_R1107_start();     Verify that USE is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestd_R1107_start
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|bool
name|only
parameter_list|)
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"* USE %s,"
argument_list|,
name|ffelex_token_text
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NB 								   _shriek_begin_uses_. */
if|if
condition|(
name|only
condition|)
name|fputs
argument_list|(
literal|"only: "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R1107_item -- USE statement for name     ffestd_R1107_item(local_token,use_token);     Make sure name_token identifies a valid object to be USEed.	local_token    may be NULL if _start_ was called with only==TRUE.  */
end_comment

begin_function
name|void
name|ffestd_R1107_item
parameter_list|(
name|ffelexToken
name|local
parameter_list|,
name|ffelexToken
name|use
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|use
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
if|if
condition|(
name|local
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"%s=>"
argument_list|,
name|ffelex_token_text
argument_list|(
name|local
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"%s,"
argument_list|,
name|ffelex_token_text
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R1107_finish -- USE statement list complete     ffestd_R1107_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R1107_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_R1111 -- BLOCK DATA statement     ffestd_R1111(name_token);     Make sure ffestd_kind_ identifies no current program unit.  If not    NULL, make sure name_token gives a valid name.  Implement the beginning    of a block data program unit.  */
end_comment

begin_function
name|void
name|ffestd_R1111
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|name
name|UNUSED
parameter_list|)
block|{
name|assert
argument_list|(
name|ffestd_block_level_
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ffestd_is_reachable_
operator|=
name|TRUE
expr_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffecom_notify_primary_entry
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffestw_set_sym
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1112 -- End a BLOCK DATA     ffestd_R1112(TRUE);	*/
end_comment

begin_function
name|void
name|ffestd_R1112
parameter_list|(
name|bool
name|ok
name|UNUSED
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|assert
argument_list|(
name|ffestd_block_level_
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Generate any return-like code here (not likely for BLOCK DATA!). */
if|if
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|FFESTV_stateBLOCKDATA5
condition|)
name|ffestd_subr_labels_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Handle any undefined labels. */
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR1112_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1202 -- INTERFACE statement     ffestd_R1202(operator,defined_name);     Make sure ffestd_kind_ identifies an INTERFACE block.    Implement the end of the current interface.     06-Jun-90  JCB  1.1       Allow no operator or name to mean INTERFACE by itself; missed this       valid form when originally doing syntactic analysis code.	 */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestd_R1202
parameter_list|(
name|ffestpDefinedOperator
name|operator
parameter_list|,
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|FFESTD_F90
switch|switch
condition|(
name|operator
condition|)
block|{
case|case
name|FFESTP_definedoperatorNone
case|:
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|fputs
argument_list|(
literal|"* INTERFACE_unnamed\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"* INTERFACE %s\n"
argument_list|,
name|ffelex_token_text
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorOPERATOR
case|:
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"* INTERFACE_OPERATOR (.%s.)\n"
argument_list|,
name|ffelex_token_text
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorASSIGNMENT
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_ASSIGNMENT (=)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorPOWER
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (**)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorMULT
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (*)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorADD
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (+)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorCONCAT
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (//)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorDIVIDE
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (/)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorSUBTRACT
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (-)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorNOT
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (.not.)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorAND
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (.and.)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorOR
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (.or.)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorEQV
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (.eqv.)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorNEQV
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (.neqv.)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorEQ
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (==)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorNE
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (/=)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorLT
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (<)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorLE
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (<=)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorGT
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (>)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_definedoperatorGE
case|:
name|fputs
argument_list|(
literal|"* INTERFACE_OPERATOR (>=)\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R1203 -- End an INTERFACE     ffestd_R1203(TRUE);	*/
end_comment

begin_function
name|void
name|ffestd_R1203
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
literal|"* END_INTERFACE\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R1205_start -- MODULE PROCEDURE statement list begin     ffestd_R1205_start();     Verify that MODULE PROCEDURE is valid here, and begin accepting items in    the list.  */
end_comment

begin_function
name|void
name|ffestd_R1205_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
literal|"* MODULE_PROCEDURE "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R1205_item -- MODULE PROCEDURE statement for name     ffestd_R1205_item(name_token);     Make sure name_token identifies a valid object to be MODULE PROCEDUREed.  */
end_comment

begin_function
name|void
name|ffestd_R1205_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"%s,"
argument_list|,
name|ffelex_token_text
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestd_R1205_finish -- MODULE PROCEDURE statement list complete     ffestd_R1205_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R1205_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
return|return;
comment|/* F90. */
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_R1207_start -- EXTERNAL statement list begin     ffestd_R1207_start();     Verify that EXTERNAL is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestd_R1207_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1207_item -- EXTERNAL statement for name     ffestd_R1207_item(name_token);     Make sure name_token identifies a valid object to be EXTERNALd.  */
end_comment

begin_function
name|void
name|ffestd_R1207_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1207_finish -- EXTERNAL statement list complete     ffestd_R1207_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R1207_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1208_start -- INTRINSIC statement list begin     ffestd_R1208_start();     Verify that INTRINSIC is valid here, and begin accepting items in the list.	*/
end_comment

begin_function
name|void
name|ffestd_R1208_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1208_item -- INTRINSIC statement for name     ffestd_R1208_item(name_token);     Make sure name_token identifies a valid object to be INTRINSICd.  */
end_comment

begin_function
name|void
name|ffestd_R1208_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1208_finish -- INTRINSIC statement list complete     ffestd_R1208_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_R1208_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1212 -- CALL statement     ffestd_R1212(expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestd_R1212
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR1212_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R1212
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R1212
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1213 -- Defined assignment statement     ffestd_R1213(dest_expr,source_expr,source_token);     Make sure the assignment is valid.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestd_R1213
parameter_list|(
name|ffebld
name|dest
parameter_list|,
name|ffebld
name|source
parameter_list|)
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_R1219 -- FUNCTION statement     ffestd_R1219(funcname,arglist,ending_token,kind,kindt,len,lent, 	 recursive);     Make sure statement is valid here, register arguments for the    function name, and so on.     06-Jun-90  JCB  2.0       Added the kind, len, and recursive arguments.  */
end_comment

begin_function
name|void
name|ffestd_R1219
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|funcname
name|UNUSED
parameter_list|,
name|ffesttTokenList
name|args
name|UNUSED
parameter_list|,
name|ffestpType
name|type
name|UNUSED
parameter_list|,
name|ffebld
name|kind
name|UNUSED
parameter_list|,
name|ffelexToken
name|kindt
name|UNUSED
parameter_list|,
name|ffebld
name|len
name|UNUSED
parameter_list|,
name|ffelexToken
name|lent
name|UNUSED
parameter_list|,
name|bool
name|recursive
name|UNUSED
parameter_list|,
name|ffelexToken
name|result
name|UNUSED
parameter_list|,
name|bool
name|separate_result
name|UNUSED
parameter_list|)
block|{
name|assert
argument_list|(
name|ffestd_block_level_
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ffestd_is_reachable_
operator|=
name|TRUE
expr_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffecom_notify_primary_entry
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffestw_set_sym
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1221 -- End a FUNCTION     ffestd_R1221(TRUE);	*/
end_comment

begin_function
name|void
name|ffestd_R1221
parameter_list|(
name|bool
name|ok
name|UNUSED
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|assert
argument_list|(
name|ffestd_block_level_
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|FFESTD_IS_END_OPTIMIZED_
operator|&&
name|ffestd_is_reachable_
condition|)
name|ffestd_R1227
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Generate RETURN. */
if|if
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|FFESTV_stateFUNCTION5
condition|)
name|ffestd_subr_labels_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Handle any undefined labels. */
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR1221_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1223 -- SUBROUTINE statement     ffestd_R1223(subrname,arglist,ending_token,recursive_token);     Make sure statement is valid here, register arguments for the    subroutine name, and so on.     06-Jun-90  JCB  2.0       Added the recursive argument.  */
end_comment

begin_function
name|void
name|ffestd_R1223
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|subrname
name|UNUSED
parameter_list|,
name|ffesttTokenList
name|args
name|UNUSED
parameter_list|,
name|ffelexToken
name|final
name|UNUSED
parameter_list|,
name|bool
name|recursive
name|UNUSED
parameter_list|)
block|{
name|assert
argument_list|(
name|ffestd_block_level_
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ffestd_is_reachable_
operator|=
name|TRUE
expr_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffecom_notify_primary_entry
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffestw_set_sym
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1225 -- End a SUBROUTINE     ffestd_R1225(TRUE);	*/
end_comment

begin_function
name|void
name|ffestd_R1225
parameter_list|(
name|bool
name|ok
name|UNUSED
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|assert
argument_list|(
name|ffestd_block_level_
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|FFESTD_IS_END_OPTIMIZED_
operator|&&
name|ffestd_is_reachable_
condition|)
name|ffestd_R1227
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Generate RETURN. */
if|if
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|FFESTV_stateSUBROUTINE5
condition|)
name|ffestd_subr_labels_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Handle any undefined labels. */
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR1225_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1226 -- ENTRY statement     ffestd_R1226(entryname,arglist,ending_token);     Make sure we're in a SUBROUTINE or FUNCTION, register arguments for the    entry point name, and so on.	 */
end_comment

begin_function
name|void
name|ffestd_R1226
parameter_list|(
name|ffesymbol
name|entry
parameter_list|)
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffesta_seen_first_exec
operator|||
name|ffecom_2pass_advise_entrypoint
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR1226_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R1226
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R1226
operator|.
name|entrynum
operator|=
operator|++
name|ffestd_2pass_entrypoints_
expr_stmt|;
block|}
name|ffestd_is_reachable_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1227 -- RETURN statement     ffestd_R1227(expr);     Make sure statement is valid here; implement.  expr and expr_token are    both NULL if there was no expression.  */
end_comment

begin_function
name|void
name|ffestd_R1227
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR1227_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R1227
operator|.
name|pool
operator|=
name|ffesta_output_pool
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R1227
operator|.
name|block
operator|=
name|ffestw_stack_top
argument_list|()
expr_stmt|;
name|stmt
operator|->
name|u
operator|.
name|R1227
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestd_block_level_
operator|==
literal|0
condition|)
name|ffestd_is_reachable_
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1228 -- CONTAINS statement     ffestd_R1228();  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestd_R1228
parameter_list|()
block|{
name|assert
argument_list|(
name|ffestd_block_level_
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
comment|/* Generate RETURN/STOP code here */
name|ffestd_subr_labels_
argument_list|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|FFESTV_stateMODULE5
argument_list|)
expr_stmt|;
comment|/* Handle any undefined 						   labels. */
name|ffestd_subr_f90_
argument_list|()
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|FFESTD_F90
name|fputs
argument_list|(
literal|"- CONTAINS\n"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_R1229_start -- STMTFUNCTION statement begin     ffestd_R1229_start(func_name,func_arg_list,close_paren);     This function does not really need to do anything, since _finish_    gets all the info needed, and ffestc_R1229_start has already    done all the stuff that makes a two-phase operation (start and    finish) for handling statement functions necessary.     03-Jan-91  JCB  2.0       Do nothing, now that _finish_ does everything.  */
end_comment

begin_function
name|void
name|ffestd_R1229_start
parameter_list|(
name|ffelexToken
name|name
name|UNUSED
parameter_list|,
name|ffesttTokenList
name|args
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_R1229_finish -- STMTFUNCTION statement list complete     ffestd_R1229_finish(s);     The statement function's symbol is passed.  Its list of dummy args is    accessed via ffesymbol_dummyargs and its expansion expression (expr)    is accessed via ffesymbol_sfexpr.     If sfexpr is NULL, an error occurred parsing the expansion expression, so    just cancel the effects of ffestd_R1229_start and pretend nothing    happened.  Otherwise, install the expression as the expansion for the    statement function, then clean up.     03-Jan-91  JCB  2.0       Takes sfunc sym instead of just the expansion expression as an       argument, so this function can do all the work, and _start_ is just       a nicety than can do nothing in a back end.  */
end_comment

begin_function
name|void
name|ffestd_R1229_finish
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|ffebld
name|expr
init|=
name|ffesymbol_sfexpr
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return;
comment|/* Nothing to do, definition didn't work. */
comment|/* With gcc, cannot do anything here, because the backend hasn't even      (necessarily) been notified that we're compiling a program unit! */
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_S3P4 -- INCLUDE line     ffestd_S3P4(filename,filename_token);     Make sure INCLUDE not preceded by any semicolons or a label def; implement.	*/
end_comment

begin_function
name|void
name|ffestd_S3P4
parameter_list|(
name|ffebld
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|fi
decl_stmt|;
name|ffetargetCharacterDefault
name|buildname
decl_stmt|;
name|ffewhereFile
name|wf
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|filename
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|filename
argument_list|)
operator|!=
name|FFEBLD_opANY
condition|)
block|{
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|filename
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|filename
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|filename
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeCHARACTERDEFAULT
argument_list|)
expr_stmt|;
name|buildname
operator|=
name|ffebld_constant_characterdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|wf
operator|=
name|ffewhere_file_new
argument_list|(
name|ffetarget_text_characterdefault
argument_list|(
name|buildname
argument_list|)
argument_list|,
name|ffetarget_length_characterdefault
argument_list|(
name|buildname
argument_list|)
argument_list|)
expr_stmt|;
name|fi
operator|=
name|ffecom_open_include
argument_list|(
name|ffewhere_file_name
argument_list|(
name|wf
argument_list|)
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
name|ffewhere_file_kill
argument_list|(
name|wf
argument_list|)
expr_stmt|;
else|else
name|ffelex_set_include
argument_list|(
name|wf
argument_list|,
operator|(
name|ffelex_token_type
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
argument_list|,
name|fi
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffestd_V003_start -- STRUCTURE statement list begin     ffestd_V003_start(structure_name);     Verify that STRUCTURE is valid here, and begin accepting items in the list.	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
name|void
name|ffestd_V003_start
parameter_list|(
name|ffelexToken
name|structure_name
parameter_list|)
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_vxt_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V003_item -- STRUCTURE statement for object-name     ffestd_V003_item(name_token,dim_list);     Make sure name_token identifies a valid object to be STRUCTUREd.  */
end_comment

begin_function
name|void
name|ffestd_V003_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V003_finish -- STRUCTURE statement list complete     ffestd_V003_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_V003_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V004 -- End a STRUCTURE     ffestd_V004(TRUE);  */
end_comment

begin_function
name|void
name|ffestd_V004
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* ffestd_V009 -- UNION statement     ffestd_V009();  */
end_comment

begin_function
name|void
name|ffestd_V009
parameter_list|()
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V010 -- End a UNION     ffestd_V010(TRUE);  */
end_comment

begin_function
name|void
name|ffestd_V010
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* ffestd_V012 -- MAP statement     ffestd_V012();  */
end_comment

begin_function
name|void
name|ffestd_V012
parameter_list|()
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V013 -- End a MAP     ffestd_V013(TRUE);  */
end_comment

begin_function
name|void
name|ffestd_V013
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_V014_start -- VOLATILE statement list begin     ffestd_V014_start();     Verify that VOLATILE is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestd_V014_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V014_item_object -- VOLATILE statement for object-name     ffestd_V014_item_object(name_token);     Make sure name_token identifies a valid object to be VOLATILEd.  */
end_comment

begin_function
name|void
name|ffestd_V014_item_object
parameter_list|(
name|ffelexToken
name|name
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V014_item_cblock -- VOLATILE statement for common-block-name     ffestd_V014_item_cblock(name_token);     Make sure name_token identifies a valid common block to be VOLATILEd.  */
end_comment

begin_function
name|void
name|ffestd_V014_item_cblock
parameter_list|(
name|ffelexToken
name|name
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V014_finish -- VOLATILE statement list complete     ffestd_V014_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_V014_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V016_start -- RECORD statement list begin     ffestd_V016_start();     Verify that RECORD is valid here, and begin accepting items in the list.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
name|void
name|ffestd_V016_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V016_item_structure -- RECORD statement for common-block-name     ffestd_V016_item_structure(name_token);     Make sure name_token identifies a valid structure to be RECORDed.  */
end_comment

begin_function
name|void
name|ffestd_V016_item_structure
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V016_item_object -- RECORD statement for object-name     ffestd_V016_item_object(name_token,dim_list);     Make sure name_token identifies a valid object to be RECORDd.  */
end_comment

begin_function
name|void
name|ffestd_V016_item_object
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V016_finish -- RECORD statement list complete     ffestd_V016_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_V016_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V018_start -- REWRITE(...) statement list begin     ffestd_V018_start();     Verify that REWRITE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestd_V018_start
parameter_list|(
name|ffestvFormat
name|format
parameter_list|)
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_vxt_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V018_item -- REWRITE statement i/o item     ffestd_V018_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestd_V018_item
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V018_finish -- REWRITE statement list complete     ffestd_V018_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_V018_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V019_start -- ACCEPT statement list begin     ffestd_V019_start();     Verify that ACCEPT is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestd_V019_start
parameter_list|(
name|ffestvFormat
name|format
parameter_list|)
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_vxt_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V019_item -- ACCEPT statement i/o item     ffestd_V019_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestd_V019_item
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V019_finish -- ACCEPT statement list complete     ffestd_V019_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_V019_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_V020_start -- TYPE statement list begin     ffestd_V020_start();     Verify that TYPE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestd_V020_start
parameter_list|(
name|ffestvFormat
name|format
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_vxt_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V020_item -- TYPE statement i/o item     ffestd_V020_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestd_V020_item
parameter_list|(
name|ffebld
name|expr
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V020_finish -- TYPE statement list complete     ffestd_V020_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_V020_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V021 -- DELETE statement     ffestd_V021();     Make sure a DELETE is valid in the current context, and implement it.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
name|void
name|ffestd_V021
parameter_list|()
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffestd_subr_vxt_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V022 -- UNLOCK statement     ffestd_V022();     Make sure a UNLOCK is valid in the current context, and implement it.  */
end_comment

begin_function
name|void
name|ffestd_V022
parameter_list|()
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffestd_subr_vxt_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V023_start -- ENCODE(...) statement list begin     ffestd_V023_start();     Verify that ENCODE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestd_V023_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_vxt_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V023_item -- ENCODE statement i/o item     ffestd_V023_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestd_V023_item
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V023_finish -- ENCODE statement list complete     ffestd_V023_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_V023_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V024_start -- DECODE(...) statement list begin     ffestd_V024_start();     Verify that DECODE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestd_V024_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_vxt_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V024_item -- DECODE statement i/o item     ffestd_V024_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestd_V024_item
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V024_finish -- DECODE statement list complete     ffestd_V024_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_V024_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V025_start -- DEFINEFILE statement list begin     ffestd_V025_start();     Verify that DEFINEFILE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestd_V025_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_vxt_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V025_item -- DEFINE FILE statement item     ffestd_V025_item(u,ut,m,mt,n,nt,asv,asvt);     Implement item.  Treat each item kind of like a separate statement,    since there's really no need to treat them as an aggregate.	*/
end_comment

begin_function
name|void
name|ffestd_V025_item
parameter_list|(
name|ffebld
name|u
parameter_list|,
name|ffebld
name|m
parameter_list|,
name|ffebld
name|n
parameter_list|,
name|ffebld
name|asv
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V025_finish -- DEFINE FILE statement list complete     ffestd_V025_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_V025_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V026 -- FIND statement     ffestd_V026();     Make sure a FIND is valid in the current context, and implement it.	*/
end_comment

begin_function
name|void
name|ffestd_V026
parameter_list|()
block|{
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|ffestd_subr_vxt_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestd_V027_start -- VXT PARAMETER statement list begin     ffestd_V027_start();     Verify that PARAMETER is valid here, and begin accepting items in the list.	*/
end_comment

begin_function
name|void
name|ffestd_V027_start
parameter_list|()
block|{
name|ffestd_check_start_
argument_list|()
expr_stmt|;
name|ffestd_subr_vxt_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V027_item -- VXT PARAMETER statement assignment     ffestd_V027_item(dest,dest_token,source,source_token);     Make sure the source is a valid source for the destination; make the    assignment.	*/
end_comment

begin_function
name|void
name|ffestd_V027_item
parameter_list|(
name|ffelexToken
name|dest_token
name|UNUSED
parameter_list|,
name|ffebld
name|source
name|UNUSED
parameter_list|)
block|{
name|ffestd_check_item_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestd_V027_finish -- VXT PARAMETER statement list complete     ffestd_V027_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestd_V027_finish
parameter_list|()
block|{
name|ffestd_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Any executable statement.  */
end_comment

begin_function
name|void
name|ffestd_any
parameter_list|()
block|{
name|ffestdStmt_
name|stmt
decl_stmt|;
name|ffestd_check_simple_
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|ffestd_stmt_new_
argument_list|(
name|FFESTD_stmtidR841_
argument_list|)
expr_stmt|;
name|ffestd_stmt_append_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ffestd_subr_line_save_
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

