begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* storag.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995, 1996 Free Software Foundation, Inc.    Contributed by James Craig Burley (burley@gnu.org).  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       None     Description:       Maintains information on storage (memory) relationships between       COMMON, dummy, and local variables, plus their equivalences (dummies       don't have equivalences, however).     Modifications: */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"storag.h"
end_include

begin_include
include|#
directive|include
file|"data.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_decl_stmt
name|ffestoragList_
name|ffestorag_list_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_decl_stmt
specifier|static
name|ffetargetOffset
name|ffestorag_local_size_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #units allocated so far. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffestorag_reported_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reports happen only once. */
end_comment

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_comment
comment|/* Internal macros. */
end_comment

begin_define
define|#
directive|define
name|ffestorag_next_
parameter_list|(
name|s
parameter_list|)
value|((s)->next)
end_define

begin_define
define|#
directive|define
name|ffestorag_previous_
parameter_list|(
name|s
parameter_list|)
value|((s)->previous)
end_define

begin_escape
end_escape

begin_comment
comment|/* ffestorag_drive -- Drive fn from list of storage objects     ffestoragList sl;    void (*fn)(ffestorag mst,ffestorag st);    ffestorag mst;  // the master ffestorag object (or whatever)    ffestorag_drive(sl,fn,mst);     Calls (*fn)(mst,st) for every st in the list sl.  */
end_comment

begin_function
name|void
name|ffestorag_drive
parameter_list|(
name|ffestoragList
name|sl
parameter_list|,
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|ffestorag
name|mst
parameter_list|,
name|ffestorag
name|st
parameter_list|)
parameter_list|,
name|ffestorag
name|mst
parameter_list|)
block|{
name|ffestorag
name|st
decl_stmt|;
for|for
control|(
name|st
operator|=
name|sl
operator|->
name|first
init|;
name|st
operator|!=
operator|(
name|ffestorag
operator|)
operator|&
name|sl
operator|->
name|first
condition|;
name|st
operator|=
name|st
operator|->
name|next
control|)
call|(
modifier|*
name|fn
call|)
argument_list|(
name|mst
argument_list|,
name|st
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestorag_dump -- Dump information on storage object     ffestorag s;	 // the ffestorag object    ffestorag_dump(s);     Dumps information in the storage object.  */
end_comment

begin_function
name|void
name|ffestorag_dump
parameter_list|(
name|ffestorag
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"(no storage object)"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|s
operator|->
name|type
condition|)
block|{
case|case
name|FFESTORAG_typeCBLOCK
case|:
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"CBLOCK "
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTORAG_typeCOMMON
case|:
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"COMMON "
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTORAG_typeLOCAL
case|:
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"LOCAL "
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTORAG_typeEQUIV
case|:
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"EQUIV "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"?%d? "
argument_list|,
name|s
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
operator|->
name|symbol
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"\"%s\" "
argument_list|,
name|ffesymbol_text
argument_list|(
name|s
operator|->
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"at %"
name|ffetargetOffset_f
literal|"d size %"
name|ffetargetOffset_f
literal|"d, align loc%%%"
name|ffetargetAlign_f
literal|"u=%"
name|ffetargetAlign_f
literal|"u, bt=%s, kt=%s"
argument_list|,
name|s
operator|->
name|offset
argument_list|,
name|s
operator|->
name|size
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|alignment
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|modulo
argument_list|,
name|ffeinfo_basictype_string
argument_list|(
name|s
operator|->
name|basic_type
argument_list|)
argument_list|,
name|ffeinfo_kindtype_string
argument_list|(
name|s
operator|->
name|kind_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|equivs_
operator|.
name|first
operator|!=
operator|(
name|ffestorag
operator|)
operator|&
name|s
operator|->
name|equivs_
operator|.
name|first
condition|)
block|{
name|ffestorag
name|sq
decl_stmt|;
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|" with equivs"
argument_list|)
expr_stmt|;
for|for
control|(
name|sq
operator|=
name|s
operator|->
name|equivs_
operator|.
name|first
init|;
name|sq
operator|!=
operator|(
name|ffestorag
operator|)
operator|&
name|s
operator|->
name|equivs_
operator|.
name|first
condition|;
name|sq
operator|=
name|ffestorag_next_
argument_list|(
name|sq
argument_list|)
control|)
block|{
if|if
condition|(
name|ffestorag_previous_
argument_list|(
name|sq
argument_list|)
operator|==
operator|(
name|ffestorag
operator|)
operator|&
name|s
operator|->
name|equivs_
operator|.
name|first
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
else|else
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"%s"
argument_list|,
name|ffesymbol_text
argument_list|(
name|ffestorag_symbol
argument_list|(
name|sq
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ffestorag_init_2 -- Initialize for new program unit     ffestorag_init_2();	*/
end_comment

begin_function
name|void
name|ffestorag_init_2
parameter_list|()
block|{
name|ffestorag_list_
operator|.
name|first
operator|=
name|ffestorag_list_
operator|.
name|last
operator|=
operator|(
name|ffestorag
operator|)
operator|&
name|ffestorag_list_
operator|.
name|first
expr_stmt|;
name|ffestorag_local_size_
operator|=
literal|0
expr_stmt|;
name|ffestorag_reported_
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestorag_end_layout -- Do final layout for symbol     ffesymbol s;    ffestorag_end_layout(s);  */
end_comment

begin_function
name|void
name|ffestorag_end_layout
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
if|if
condition|(
name|ffesymbol_storage
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
comment|/* Already laid out. */
name|ffestorag_exec_layout
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Do what we have in common. */
if|#
directive|if
literal|0
block|assert (ffesymbol_storage (s) == NULL);
comment|/* I'd like to know what 						   cases miss going through 						   ffecom_sym_learned, and 						   why; I don't think we 						   should have to do the 						   exec_layout thing at all 						   here. */
comment|/* Now I think I know: we have to do exec_layout here, because equivalence      handling could encounter an error that takes a variable off of its      equivalence object (and vice versa), and we should then layout the var      as a local entity. */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestorag_exec_layout -- Do initial layout for symbol     ffesymbol s;    ffestorag_exec_layout(s);  */
end_comment

begin_function
name|void
name|ffestorag_exec_layout
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|ffetargetAlign
name|alignment
decl_stmt|;
name|ffetargetAlign
name|modulo
decl_stmt|;
name|ffetargetOffset
name|size
decl_stmt|;
name|ffetargetOffset
name|num_elements
decl_stmt|;
name|ffetargetAlign
name|pad
decl_stmt|;
name|ffestorag
name|st
decl_stmt|;
name|ffestorag
name|stv
decl_stmt|;
name|ffebld
name|list
decl_stmt|;
name|ffebld
name|item
decl_stmt|;
name|ffesymbol
name|var
decl_stmt|;
name|bool
name|init
decl_stmt|;
if|if
condition|(
name|ffesymbol_storage
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
comment|/* Already laid out. */
switch|switch
condition|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
condition|)
block|{
default|default:
return|return;
comment|/* Do nothing. */
case|case
name|FFEINFO_kindENTITY
case|:
switch|switch
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereLOCAL
case|:
if|if
condition|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
comment|/* Let ffeequiv handle this guy. */
if|if
condition|(
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
operator|==
literal|0
condition|)
name|num_elements
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ffebld_op
argument_list|(
name|ffesymbol_arraysize
argument_list|(
name|s
argument_list|)
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return;
comment|/* An adjustable local array, just like a dummy. */
name|num_elements
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|ffesymbol_arraysize
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffetarget_layout
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|,
operator|&
name|alignment
argument_list|,
operator|&
name|modulo
argument_list|,
operator|&
name|size
argument_list|,
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
name|st
operator|=
name|ffestorag_new
argument_list|(
name|ffestorag_list_master
argument_list|()
argument_list|)
expr_stmt|;
name|st
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
comment|/* Initializations happen at sym level. */
name|st
operator|->
name|init
operator|=
name|NULL
expr_stmt|;
name|st
operator|->
name|accretion
operator|=
name|NULL
expr_stmt|;
name|st
operator|->
name|symbol
operator|=
name|s
expr_stmt|;
name|st
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|st
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|alignment
operator|=
name|alignment
expr_stmt|;
name|st
operator|->
name|modulo
operator|=
name|modulo
expr_stmt|;
name|st
operator|->
name|type
operator|=
name|FFESTORAG_typeLOCAL
expr_stmt|;
name|st
operator|->
name|basic_type
operator|=
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|st
operator|->
name|kind_type
operator|=
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|st
operator|->
name|type_symbol
operator|=
name|s
expr_stmt|;
name|st
operator|->
name|is_save
operator|=
name|ffesymbol_is_save
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|st
operator|->
name|is_init
operator|=
name|ffesymbol_is_init
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_set_storage
argument_list|(
name|s
argument_list|,
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_is_init
argument_list|(
name|s
argument_list|)
condition|)
name|ffecom_notify_init_symbol
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Init completed before, but 						   we didn't have a storage 						   object for it; maybe back 						   end wants to see the sym 						   again now. */
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
case|case
name|FFEINFO_whereCOMMON
case|:
return|return;
comment|/* Allocate storage for entire common block 				   at once. */
case|case
name|FFEINFO_whereDUMMY
case|:
return|return;
comment|/* Don't do anything about dummies for now. */
case|case
name|FFEINFO_whereRESULT
case|:
case|case
name|FFEINFO_whereIMMEDIATE
case|:
case|case
name|FFEINFO_whereCONSTANT
case|:
case|case
name|FFEINFO_whereNONE
case|:
return|return;
comment|/* These don't get storage (esp. NONE, which 				   is UNCERTAIN). */
default|default:
name|assert
argument_list|(
literal|"bad ENTITY where"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|FFEINFO_kindCOMMON
case|:
name|assert
argument_list|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereLOCAL
argument_list|)
expr_stmt|;
name|st
operator|=
name|ffestorag_new
argument_list|(
name|ffestorag_list_master
argument_list|()
argument_list|)
expr_stmt|;
name|st
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
comment|/* Initializations happen here. */
name|st
operator|->
name|init
operator|=
name|NULL
expr_stmt|;
name|st
operator|->
name|accretion
operator|=
name|NULL
expr_stmt|;
name|st
operator|->
name|symbol
operator|=
name|s
expr_stmt|;
name|st
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|alignment
operator|=
literal|1
expr_stmt|;
name|st
operator|->
name|modulo
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|type
operator|=
name|FFESTORAG_typeCBLOCK
expr_stmt|;
if|if
condition|(
name|ffesymbol_commonlist
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|var
operator|=
name|ffebld_symter
argument_list|(
name|ffebld_head
argument_list|(
name|ffesymbol_commonlist
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|->
name|basic_type
operator|=
name|ffesymbol_basictype
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|st
operator|->
name|kind_type
operator|=
name|ffesymbol_kindtype
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|st
operator|->
name|type_symbol
operator|=
name|var
expr_stmt|;
block|}
else|else
block|{
comment|/* Special case for empty common area: 				   NONE/NONE means nothing. */
name|st
operator|->
name|basic_type
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
name|st
operator|->
name|kind_type
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
name|st
operator|->
name|type_symbol
operator|=
name|NULL
expr_stmt|;
block|}
name|st
operator|->
name|is_save
operator|=
name|ffesymbol_is_save
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|st
operator|->
name|is_init
operator|=
name|ffesymbol_is_init
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffe_is_mainprog
argument_list|()
condition|)
name|ffeglobal_save_common
argument_list|(
name|s
argument_list|,
name|st
operator|->
name|is_save
operator|||
name|ffe_is_saveall
argument_list|()
argument_list|,
name|ffesymbol_where_line
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where_column
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_storage
argument_list|(
name|s
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|init
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|list
operator|=
name|ffesymbol_commonlist
argument_list|(
name|s
argument_list|)
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
name|item
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|item
argument_list|)
operator|==
name|FFEBLD_opSYMTER
argument_list|)
expr_stmt|;
name|var
operator|=
name|ffebld_symter
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_basictype
argument_list|(
name|var
argument_list|)
operator|==
name|FFEINFO_basictypeANY
condition|)
continue|continue;
comment|/* Ignore any symbols that have errors. */
if|if
condition|(
name|ffesymbol_rank
argument_list|(
name|var
argument_list|)
operator|==
literal|0
condition|)
name|num_elements
operator|=
literal|1
expr_stmt|;
else|else
name|num_elements
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|ffesymbol_arraysize
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffetarget_layout
argument_list|(
name|ffesymbol_text
argument_list|(
name|var
argument_list|)
argument_list|,
operator|&
name|alignment
argument_list|,
operator|&
name|modulo
argument_list|,
operator|&
name|size
argument_list|,
name|ffesymbol_basictype
argument_list|(
name|var
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|var
argument_list|)
argument_list|,
name|ffesymbol_size
argument_list|(
name|var
argument_list|)
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
name|pad
operator|=
name|ffetarget_align
argument_list|(
operator|&
name|st
operator|->
name|alignment
argument_list|,
operator|&
name|st
operator|->
name|modulo
argument_list|,
name|st
operator|->
name|size
argument_list|,
name|alignment
argument_list|,
name|modulo
argument_list|)
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
block|{
comment|/* Warn about padding in the midst of a 				   common area. */
name|char
name|padding
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
operator|&
name|padding
index|[
literal|0
index|]
argument_list|,
literal|"%"
name|ffetargetAlign_f
literal|"u"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_COMMON_PAD
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|padding
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
operator|(
name|pad
operator|==
literal|1
operator|)
condition|?
name|FFECOM_SIZE_UNIT
else|:
name|FFECOM_SIZE_UNITS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffesymbol_where_line
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where_column
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|stv
operator|=
name|ffestorag_new
argument_list|(
name|ffestorag_list_master
argument_list|()
argument_list|)
expr_stmt|;
name|stv
operator|->
name|parent
operator|=
name|st
expr_stmt|;
comment|/* Initializations happen in COMMON block. */
name|stv
operator|->
name|init
operator|=
name|NULL
expr_stmt|;
name|stv
operator|->
name|accretion
operator|=
name|NULL
expr_stmt|;
name|stv
operator|->
name|symbol
operator|=
name|var
expr_stmt|;
name|stv
operator|->
name|size
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|!
name|ffetarget_offset_add
argument_list|(
operator|&
name|stv
operator|->
name|offset
argument_list|,
name|st
operator|->
name|size
argument_list|,
name|pad
argument_list|)
condition|)
block|{
comment|/* Common block size plus pad, complain if 				   overflow. */
name|ffetarget_offset_overflow
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ffetarget_offset_add
argument_list|(
operator|&
name|st
operator|->
name|size
argument_list|,
name|stv
operator|->
name|offset
argument_list|,
name|stv
operator|->
name|size
argument_list|)
condition|)
block|{
comment|/* Adjust size of common block, complain if 				   overflow. */
name|ffetarget_offset_overflow
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stv
operator|->
name|alignment
operator|=
name|alignment
expr_stmt|;
name|stv
operator|->
name|modulo
operator|=
name|modulo
expr_stmt|;
name|stv
operator|->
name|type
operator|=
name|FFESTORAG_typeCOMMON
expr_stmt|;
name|stv
operator|->
name|basic_type
operator|=
name|ffesymbol_basictype
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|stv
operator|->
name|kind_type
operator|=
name|ffesymbol_kindtype
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|stv
operator|->
name|type_symbol
operator|=
name|var
expr_stmt|;
name|stv
operator|->
name|is_save
operator|=
name|st
operator|->
name|is_save
expr_stmt|;
name|stv
operator|->
name|is_init
operator|=
name|st
operator|->
name|is_init
expr_stmt|;
name|ffesymbol_set_storage
argument_list|(
name|var
argument_list|,
name|stv
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|ffestorag_update
argument_list|(
name|st
argument_list|,
name|var
argument_list|,
name|ffesymbol_basictype
argument_list|(
name|var
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_is_init
argument_list|(
name|var
argument_list|)
condition|)
name|init
operator|=
name|TRUE
expr_stmt|;
comment|/* Must move inits over to COMMON's 				   ffestorag. */
block|}
if|if
condition|(
name|ffeequiv_layout_cblock
argument_list|(
name|st
argument_list|)
condition|)
name|init
operator|=
name|TRUE
expr_stmt|;
name|ffeglobal_pad_common
argument_list|(
name|s
argument_list|,
name|st
operator|->
name|modulo
argument_list|,
name|ffesymbol_where_line
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where_column
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|ffedata_gather
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* Gather subordinate inits into one init. */
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* ffestorag_new -- Create new ffestorag object, append to list     ffestorag s;    ffestoragList sl;    s = ffestorag_new(sl);  */
end_comment

begin_function
name|ffestorag
name|ffestorag_new
parameter_list|(
name|ffestoragList
name|sl
parameter_list|)
block|{
name|ffestorag
name|s
decl_stmt|;
name|s
operator|=
operator|(
name|ffestorag
operator|)
name|malloc_new_kp
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
literal|"ffestorag"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|next
operator|=
operator|(
name|ffestorag
operator|)
operator|&
name|sl
operator|->
name|first
expr_stmt|;
name|s
operator|->
name|previous
operator|=
name|sl
operator|->
name|last
expr_stmt|;
ifdef|#
directive|ifdef
name|FFECOM_storageHOOK
name|s
operator|->
name|hook
operator|=
name|FFECOM_storageNULL
expr_stmt|;
endif|#
directive|endif
name|s
operator|->
name|previous
operator|->
name|next
operator|=
name|s
expr_stmt|;
name|sl
operator|->
name|last
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|equivs_
operator|.
name|first
operator|=
name|s
operator|->
name|equivs_
operator|.
name|last
operator|=
operator|(
name|ffestorag
operator|)
operator|&
name|s
operator|->
name|equivs_
operator|.
name|first
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Report info on LOCAL non-sym-assoc'ed entities if needed.  */
end_comment

begin_function
name|void
name|ffestorag_report
parameter_list|()
block|{
name|ffestorag
name|s
decl_stmt|;
if|if
condition|(
name|ffestorag_reported_
condition|)
return|return;
for|for
control|(
name|s
operator|=
name|ffestorag_list_
operator|.
name|first
init|;
name|s
operator|!=
operator|(
name|ffestorag
operator|)
operator|&
name|ffestorag_list_
operator|.
name|first
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|symbol
operator|==
name|NULL
condition|)
block|{
name|ffestorag_reported_
operator|=
name|TRUE
expr_stmt|;
name|fputs
argument_list|(
literal|"Storage area: "
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffestorag_dump
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ffestorag_update -- Update type info for ffestorag object     ffestorag s;	 // existing object    ffeinfoBasictype bt;	 // basic type for newly added member of object    ffeinfoKindtype kt;	// kind type for it    ffestorag_update(s,bt,kt);     If the existing type for the storage object agrees with the new type    info, just returns.	If the basic types agree but not the kind types,    sets the kind type for the object to NONE.  If the basic types    disagree, sets the kind type to NONE, and the basic type to NONE if the    basic types both are not CHARACTER, otherwise to ANY.  If the basic    type for the object already is NONE, it is set to ANY if the new basic    type is CHARACTER.  Any time a transition is made to ANY and pedantic    mode is on, a message is issued that mixing CHARACTER and non-CHARACTER    stuff in the same COMMON/EQUIVALENCE is invalid.  */
end_comment

begin_function
name|void
name|ffestorag_update
parameter_list|(
name|ffestorag
name|s
parameter_list|,
name|ffesymbol
name|sym
parameter_list|,
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|basic_type
operator|==
name|bt
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|kind_type
operator|==
name|kt
condition|)
return|return;
name|s
operator|->
name|kind_type
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|s
operator|->
name|basic_type
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return;
comment|/* No need to do anything further. */
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|any
label|:
comment|/* :::::::::::::::::::: */
name|s
operator|->
name|basic_type
operator|=
name|FFEINFO_basictypeANY
expr_stmt|;
name|s
operator|->
name|kind_type
operator|=
name|FFEINFO_kindtypeANY
expr_stmt|;
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_MIXED_TYPES
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
operator|->
name|type_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return;
default|default:
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
goto|goto
name|any
goto|;
comment|/* :::::::::::::::::::: */
name|s
operator|->
name|basic_type
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
name|s
operator|->
name|kind_type
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Update INIT flag for storage object.     If the INIT flag for the<s> object is already TRUE, return.	 Else,    set it to TRUE and call ffe*_update_init for all contained objects.	*/
end_comment

begin_function
name|void
name|ffestorag_update_init
parameter_list|(
name|ffestorag
name|s
parameter_list|)
block|{
name|ffestorag
name|sq
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|is_init
condition|)
return|return;
name|s
operator|->
name|is_init
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|symbol
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|ffesymbol_is_init
argument_list|(
name|s
operator|->
name|symbol
argument_list|)
condition|)
name|ffesymbol_update_init
argument_list|(
name|s
operator|->
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|parent
operator|!=
name|NULL
condition|)
name|ffestorag_update_init
argument_list|(
name|s
operator|->
name|parent
argument_list|)
expr_stmt|;
for|for
control|(
name|sq
operator|=
name|s
operator|->
name|equivs_
operator|.
name|first
init|;
name|sq
operator|!=
operator|(
name|ffestorag
operator|)
operator|&
name|s
operator|->
name|equivs_
operator|.
name|first
condition|;
name|sq
operator|=
name|ffestorag_next_
argument_list|(
name|sq
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|sq
operator|->
name|is_init
condition|)
name|ffestorag_update_init
argument_list|(
name|sq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update SAVE flag for storage object.     If the SAVE flag for the<s> object is already TRUE, return.	 Else,    set it to TRUE and call ffe*_update_save for all contained objects.	*/
end_comment

begin_function
name|void
name|ffestorag_update_save
parameter_list|(
name|ffestorag
name|s
parameter_list|)
block|{
name|ffestorag
name|sq
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|is_save
condition|)
return|return;
name|s
operator|->
name|is_save
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|symbol
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|ffesymbol_is_save
argument_list|(
name|s
operator|->
name|symbol
argument_list|)
condition|)
name|ffesymbol_update_save
argument_list|(
name|s
operator|->
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|parent
operator|!=
name|NULL
condition|)
name|ffestorag_update_save
argument_list|(
name|s
operator|->
name|parent
argument_list|)
expr_stmt|;
for|for
control|(
name|sq
operator|=
name|s
operator|->
name|equivs_
operator|.
name|first
init|;
name|sq
operator|!=
operator|(
name|ffestorag
operator|)
operator|&
name|s
operator|->
name|equivs_
operator|.
name|first
condition|;
name|sq
operator|=
name|ffestorag_next_
argument_list|(
name|sq
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|sq
operator|->
name|is_save
condition|)
name|ffestorag_update_save
argument_list|(
name|sq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

