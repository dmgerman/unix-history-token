begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* data.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995, 1996 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:     Description:       Do the tough things for DATA statement (and INTEGER FOO/.../-style       initializations), like implied-DO and suchlike.     Modifications: */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"data.h"
end_include

begin_include
include|#
directive|include
file|"bit.h"
end_include

begin_include
include|#
directive|include
file|"bld.h"
end_include

begin_include
include|#
directive|include
file|"com.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"st.h"
end_include

begin_include
include|#
directive|include
file|"storag.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_comment
comment|/* I picked this value as one that, when plugged into a couple of small    but nearly identical test cases I have called BIG-0.f and BIG-1.f,    causes BIG-1.f to take about 10 times as long (elapsed) to compile    (in f771 only) as BIG-0.f.  These test cases differ in that BIG-0.f    doesn't put the one initialized variable in a common area that has    a large uninitialized array in it, while BIG-1.f does.  The size of    the array is this many elements, as long as they all are INTEGER    type.  Note that, as of 0.5.18, sparse cases are better handled,    so BIG-2.f now is used; it provides nonzero initial    values for all elements of the same array BIG-0 has.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FFEDATA_sizeTOO_BIG_INIT_
end_ifndef

begin_define
define|#
directive|define
name|FFEDATA_sizeTOO_BIG_INIT_
value|75*1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|_ffedata_convert_cache_
modifier|*
name|ffedataConvertCache_
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|_ffedata_impdo_
modifier|*
name|ffedataImpdo_
typedef|;
end_typedef

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_struct
struct|struct
name|_ffedata_convert_cache_
block|{
name|ffebld
name|converted
decl_stmt|;
comment|/* Results of converting expr to following 				   type. */
name|ffeinfoBasictype
name|basic_type
decl_stmt|;
name|ffeinfoKindtype
name|kind_type
decl_stmt|;
name|ffetargetCharacterSize
name|size
decl_stmt|;
name|ffeinfoRank
name|rank
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_ffedata_impdo_
block|{
name|ffedataImpdo_
name|outer
decl_stmt|;
comment|/* Enclosing IMPDO construct. */
name|ffebld
name|outer_list
decl_stmt|;
comment|/* Item after my IMPDO on the outer list. */
name|ffebld
name|my_list
decl_stmt|;
comment|/* Beginning of list in my IMPDO. */
name|ffesymbol
name|itervar
decl_stmt|;
comment|/* Iteration variable. */
name|ffetargetIntegerDefault
name|increment
decl_stmt|;
name|ffetargetIntegerDefault
name|final
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_decl_stmt
specifier|static
name|ffedataImpdo_
name|ffedata_stack_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffebld
name|ffedata_list_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ffedata_reinit_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* value_ should report REINIT error. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffedata_reported_error_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Error has been reported. */
end_comment

begin_decl_stmt
specifier|static
name|ffesymbol
name|ffedata_symbol_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symbol being initialized. */
end_comment

begin_decl_stmt
specifier|static
name|ffeinfoBasictype
name|ffedata_basictype_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Info on symbol. */
end_comment

begin_decl_stmt
specifier|static
name|ffeinfoKindtype
name|ffedata_kindtype_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffestorag
name|ffedata_storage_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-NULL, inits go into this parent. */
end_comment

begin_decl_stmt
specifier|static
name|ffeinfoBasictype
name|ffedata_storage_bt_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Info on storage. */
end_comment

begin_decl_stmt
specifier|static
name|ffeinfoKindtype
name|ffedata_storage_kt_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffetargetOffset
name|ffedata_storage_size_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of entire storage. */
end_comment

begin_decl_stmt
specifier|static
name|ffetargetAlign
name|ffedata_storage_units_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #units per storage unit. */
end_comment

begin_decl_stmt
specifier|static
name|ffetargetOffset
name|ffedata_arraysize_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of array being 						   inited. */
end_comment

begin_decl_stmt
specifier|static
name|ffetargetOffset
name|ffedata_expected_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements to 						   init. */
end_comment

begin_decl_stmt
specifier|static
name|ffetargetOffset
name|ffedata_number_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #elements inited so far. */
end_comment

begin_decl_stmt
specifier|static
name|ffetargetOffset
name|ffedata_offset_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset of next element. */
end_comment

begin_decl_stmt
specifier|static
name|ffetargetOffset
name|ffedata_symbolsize_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of entire sym. */
end_comment

begin_decl_stmt
specifier|static
name|ffetargetCharacterSize
name|ffedata_size_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of an element. */
end_comment

begin_decl_stmt
specifier|static
name|ffetargetCharacterSize
name|ffedata_charexpected_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #char to init. */
end_comment

begin_decl_stmt
specifier|static
name|ffetargetCharacterSize
name|ffedata_charnumber_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #chars inited. */
end_comment

begin_decl_stmt
specifier|static
name|ffetargetCharacterSize
name|ffedata_charoffset_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset of next char. */
end_comment

begin_decl_stmt
specifier|static
name|ffedataConvertCache_
name|ffedata_convert_cache_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fewer conversions. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ffedata_convert_cache_max_
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #entries available. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ffedata_convert_cache_use_
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #entries in use. */
end_comment

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_function_decl
specifier|static
name|bool
name|ffedata_advance_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffebld
name|ffedata_convert_
parameter_list|(
name|ffebld
name|source
parameter_list|,
name|ffelexToken
name|source_token
parameter_list|,
name|ffelexToken
name|dest_token
parameter_list|,
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|,
name|ffeinfoRank
name|rk
parameter_list|,
name|ffetargetCharacterSize
name|sz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffetargetInteger1
name|ffedata_eval_integer1_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffetargetOffset
name|ffedata_eval_offset_
parameter_list|(
name|ffebld
name|subscripts
parameter_list|,
name|ffebld
name|dims
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffetargetCharacterSize
name|ffedata_eval_substr_begin_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffetargetCharacterSize
name|ffedata_eval_substr_end_
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffetargetCharacterSize
name|min
parameter_list|,
name|ffetargetCharacterSize
name|max
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffedata_gather_
parameter_list|(
name|ffestorag
name|mst
parameter_list|,
name|ffestorag
name|st
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffedata_pop_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffedata_push_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffedata_value_
parameter_list|(
name|ffebld
name|value
parameter_list|,
name|ffelexToken
name|token
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Internal macros. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* ffedata_begin -- Initialize with list of targets     ffebld list;    ffedata_begin(list);	 // ITEM... list of SYMTERs, ARRAYs, SUBSTRs, ...     Remember the list.  After this call, 0...n calls to ffedata_value must    follow, and then a single call to ffedata_end.  */
end_comment

begin_function
name|void
name|ffedata_begin
parameter_list|(
name|ffebld
name|list
parameter_list|)
block|{
name|assert
argument_list|(
name|ffedata_list_
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ffedata_list_
operator|=
name|list
expr_stmt|;
name|ffedata_symbol_
operator|=
name|NULL
expr_stmt|;
name|ffedata_reported_error_
operator|=
name|FALSE
expr_stmt|;
name|ffedata_reinit_
operator|=
name|FALSE
expr_stmt|;
name|ffedata_advance_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffedata_end -- End of initialization sequence     if (ffedata_end(FALSE))        // everything's ok     Make sure the end of the list is valid here.	 */
end_comment

begin_function
name|bool
name|ffedata_end
parameter_list|(
name|bool
name|reported_error
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|reported_error
operator||=
name|ffedata_reported_error_
expr_stmt|;
comment|/* If still targets to initialize, too few initializers, so complain. */
if|if
condition|(
operator|(
name|ffedata_symbol_
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|reported_error
condition|)
block|{
name|reported_error
operator|=
name|TRUE
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_TOOFEW
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
comment|/* Pop off any impdo stacks (present only if ffedata_symbol_ != NULL). */
while|while
condition|(
name|ffedata_stack_
operator|!=
name|NULL
condition|)
name|ffedata_pop_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffedata_list_
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|reported_error
argument_list|)
expr_stmt|;
name|ffedata_list_
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ffedata_gather -- Gather previously disparate initializations into one place     ffestorag st;  // A typeCBLOCK or typeLOCAL aggregate.    ffedata_gather(st);     Prior to this call, st has no init or accretion info, but (presumably    at least one of) its subordinate storage areas has init or accretion    info.  After this call, none of the subordinate storage areas has inits,    because they've all been moved into the newly created init/accretion    info for st.	 During this call, conflicting inits produce only one    error message.  */
end_comment

begin_function
name|void
name|ffedata_gather
parameter_list|(
name|ffestorag
name|st
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffebld
name|b
decl_stmt|;
comment|/* Prepare info on the storage area we're putting init info into. */
name|ffetarget_aggregate_info
argument_list|(
operator|&
name|ffedata_storage_bt_
argument_list|,
operator|&
name|ffedata_storage_kt_
argument_list|,
operator|&
name|ffedata_storage_units_
argument_list|,
name|ffestorag_basictype
argument_list|(
name|st
argument_list|)
argument_list|,
name|ffestorag_kindtype
argument_list|(
name|st
argument_list|)
argument_list|)
expr_stmt|;
name|ffedata_storage_size_
operator|=
name|ffestorag_size
argument_list|(
name|st
argument_list|)
operator|/
name|ffedata_storage_units_
expr_stmt|;
name|assert
argument_list|(
name|ffestorag_size
argument_list|(
name|st
argument_list|)
operator|%
name|ffedata_storage_units_
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* If a CBLOCK, gather all the init info for its explicit members. */
if|if
condition|(
operator|(
name|ffestorag_type
argument_list|(
name|st
argument_list|)
operator|==
name|FFESTORAG_typeCBLOCK
operator|)
operator|&&
operator|(
name|ffestorag_symbol
argument_list|(
name|st
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|s
operator|=
name|ffestorag_symbol
argument_list|(
name|st
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|ffesymbol_commonlist
argument_list|(
name|s
argument_list|)
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|ffebld_trail
argument_list|(
name|b
argument_list|)
control|)
name|ffedata_gather_
argument_list|(
name|st
argument_list|,
name|ffesymbol_storage
argument_list|(
name|ffebld_symter
argument_list|(
name|ffebld_head
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* For CBLOCK or LOCAL, gather all the init info for equivalenced members. */
name|ffestorag_drive
argument_list|(
name|ffestorag_list_equivs
argument_list|(
name|st
argument_list|)
argument_list|,
name|ffedata_gather_
argument_list|,
name|st
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffedata_value -- Provide some number of initial values     ffebld value;    ffelexToken t;  // Points to the value.    if (ffedata_value(1,value,t))        // Everything's ok     Makes sure the value is ok, then remembers it according to the list    provided to ffedata_begin.  As many instances of the value may be    supplied as desired, as indicated by the first argument.  */
end_comment

begin_function
name|bool
name|ffedata_value
parameter_list|(
name|ffetargetIntegerDefault
name|rpt
parameter_list|,
name|ffebld
name|value
parameter_list|,
name|ffelexToken
name|token
parameter_list|)
block|{
name|ffetargetIntegerDefault
name|i
decl_stmt|;
comment|/* Maybe ignore zero values, to speed up compiling, even though we lose      checking for multiple initializations for now.  */
if|if
condition|(
operator|!
name|ffe_is_zeros
argument_list|()
operator|&&
operator|(
name|value
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|value
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|&&
name|ffebld_constant_is_zero
argument_list|(
name|ffebld_conter
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
name|value
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|value
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|value
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
condition|)
name|value
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* Must be a constant. */
name|assert
argument_list|(
name|value
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|value
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
block|}
comment|/* Later we can optimize certain cases by seeing that the target array can      take some number of values, and provide this number to _value_. */
if|if
condition|(
name|rpt
operator|==
literal|1
condition|)
name|ffedata_convert_cache_use_
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Don't bother caching. */
else|else
name|ffedata_convert_cache_use_
operator|=
literal|0
expr_stmt|;
comment|/* Maybe use the cache. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rpt
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|ffedata_symbol_
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|ffesymbol_is_init
argument_list|(
name|ffedata_symbol_
argument_list|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|ffedata_symbol_
argument_list|)
expr_stmt|;
name|ffesymbol_update_init
argument_list|(
name|ffedata_symbol_
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|||
name|ffe_is_90
argument_list|()
condition|)
name|ffesymbol_update_save
argument_list|(
name|ffedata_symbol_
argument_list|)
expr_stmt|;
if|#
directive|if
name|FFEGLOBAL_ENABLED
if|if
condition|(
name|ffesymbol_common
argument_list|(
name|ffedata_symbol_
argument_list|)
operator|!=
name|NULL
condition|)
name|ffeglobal_init_common
argument_list|(
name|ffesymbol_common
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|,
name|token
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ffesymbol_signal_unreported
argument_list|(
name|ffedata_symbol_
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ffedata_value_
argument_list|(
name|value
argument_list|,
name|token
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ffedata_advance_ -- Advance initialization target to next item in list     if (ffedata_advance_())        // everything's ok     Sets common info to characterize the next item in the list.	Handles    IMPDO constructs accordingly.  Does not handle advances within a single    item, as in the common extension "DATA CHARTYPE/33,34,35/", where    CHARTYPE is CHARACTER*3, for example.  */
end_comment

begin_function
specifier|static
name|bool
name|ffedata_advance_
parameter_list|()
block|{
name|ffebld
name|next
decl_stmt|;
comment|/* Come here after handling an IMPDO. */
name|tail_recurse
label|:
comment|/* :::::::::::::::::::: */
comment|/* Assume we're not going to find a new target for now. */
name|ffedata_symbol_
operator|=
name|NULL
expr_stmt|;
comment|/* If at the end of the list, we're done. */
if|if
condition|(
name|ffedata_list_
operator|==
name|NULL
condition|)
block|{
name|ffetargetIntegerDefault
name|newval
decl_stmt|;
if|if
condition|(
name|ffedata_stack_
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* No IMPDO in progress, we is done! */
comment|/* Iterate the IMPDO. */
name|newval
operator|=
name|ffesymbol_value
argument_list|(
name|ffedata_stack_
operator|->
name|itervar
argument_list|)
operator|+
name|ffedata_stack_
operator|->
name|increment
expr_stmt|;
comment|/* See if we're still in the loop. */
if|if
condition|(
operator|(
operator|(
name|ffedata_stack_
operator|->
name|increment
operator|>
literal|0
operator|)
condition|?
name|newval
operator|>
name|ffedata_stack_
operator|->
name|final
else|:
name|newval
operator|<
name|ffedata_stack_
operator|->
name|final
operator|)
operator|||
operator|(
operator|(
operator|(
name|ffesymbol_value
argument_list|(
name|ffedata_stack_
operator|->
name|itervar
argument_list|)
operator|<
literal|0
operator|)
operator|==
operator|(
name|ffedata_stack_
operator|->
name|increment
operator|<
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|ffesymbol_value
argument_list|(
name|ffedata_stack_
operator|->
name|itervar
argument_list|)
operator|<
literal|0
operator|)
operator|!=
operator|(
name|newval
operator|<
literal|0
operator|)
operator|)
operator|)
condition|)
comment|/* Overflow/underflow? */
block|{
comment|/* Done with the loop. */
name|ffedata_list_
operator|=
name|ffedata_stack_
operator|->
name|outer_list
expr_stmt|;
comment|/* Restore list. */
name|ffedata_pop_
argument_list|()
expr_stmt|;
comment|/* Pop me off the impdo stack. */
block|}
else|else
block|{
comment|/* Still in the loop, reset the list and 				   update the iter var. */
name|ffedata_list_
operator|=
name|ffedata_stack_
operator|->
name|my_list
expr_stmt|;
comment|/* Reset list. */
name|ffesymbol_set_value
argument_list|(
name|ffedata_stack_
operator|->
name|itervar
argument_list|,
name|newval
argument_list|)
expr_stmt|;
block|}
goto|goto
name|tail_recurse
goto|;
comment|/* :::::::::::::::::::: */
block|}
comment|/* Move to the next item in the list. */
name|next
operator|=
name|ffebld_head
argument_list|(
name|ffedata_list_
argument_list|)
expr_stmt|;
name|ffedata_list_
operator|=
name|ffebld_trail
argument_list|(
name|ffedata_list_
argument_list|)
expr_stmt|;
comment|/* Really shouldn't happen. */
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* See what kind of target this is. */
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|next
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opSYMTER
case|:
comment|/* Simple reference to scalar or array. */
name|ffedata_symbol_
operator|=
name|ffebld_symter
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|ffedata_storage_
operator|=
operator|(
name|ffesymbol_storage
argument_list|(
name|ffedata_symbol_
argument_list|)
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|ffestorag_parent
argument_list|(
name|ffesymbol_storage
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffedata_storage_
operator|!=
name|NULL
condition|)
block|{
name|ffetarget_aggregate_info
argument_list|(
operator|&
name|ffedata_storage_bt_
argument_list|,
operator|&
name|ffedata_storage_kt_
argument_list|,
operator|&
name|ffedata_storage_units_
argument_list|,
name|ffestorag_basictype
argument_list|(
name|ffedata_storage_
argument_list|)
argument_list|,
name|ffestorag_kindtype
argument_list|(
name|ffedata_storage_
argument_list|)
argument_list|)
expr_stmt|;
name|ffedata_storage_size_
operator|=
name|ffestorag_size
argument_list|(
name|ffedata_storage_
argument_list|)
operator|/
name|ffedata_storage_units_
expr_stmt|;
name|assert
argument_list|(
name|ffestorag_size
argument_list|(
name|ffedata_storage_
argument_list|)
operator|%
name|ffedata_storage_units_
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ffesymbol_init
argument_list|(
name|ffedata_symbol_
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|ffesymbol_accretion
argument_list|(
name|ffedata_symbol_
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ffedata_storage_
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffestorag_init
argument_list|(
name|ffedata_storage_
argument_list|)
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|ffebad_start (FFEBAD_DATA_REINIT); 	  ffest_ffebad_here_current_stmt (0); 	  ffebad_string (ffesymbol_text (ffedata_symbol_)); 	  ffebad_finish (); 	  ffedata_reported_error_ = TRUE; 	  return FALSE;
else|#
directive|else
name|ffedata_reinit_
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
endif|#
directive|endif
block|}
name|ffedata_basictype_
operator|=
name|ffesymbol_basictype
argument_list|(
name|ffedata_symbol_
argument_list|)
expr_stmt|;
name|ffedata_kindtype_
operator|=
name|ffesymbol_kindtype
argument_list|(
name|ffedata_symbol_
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_rank
argument_list|(
name|ffedata_symbol_
argument_list|)
operator|==
literal|0
condition|)
name|ffedata_arraysize_
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|ffebld
name|size
init|=
name|ffesymbol_arraysize
argument_list|(
name|ffedata_symbol_
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|size
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|size
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|size
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|size
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|ffedata_arraysize_
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffedata_expected_
operator|=
name|ffedata_arraysize_
expr_stmt|;
name|ffedata_number_
operator|=
literal|0
expr_stmt|;
name|ffedata_offset_
operator|=
literal|0
expr_stmt|;
name|ffedata_size_
operator|=
operator|(
name|ffedata_basictype_
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
condition|?
name|ffesymbol_size
argument_list|(
name|ffedata_symbol_
argument_list|)
else|:
literal|1
expr_stmt|;
name|ffedata_symbolsize_
operator|=
name|ffedata_size_
operator|*
name|ffedata_arraysize_
expr_stmt|;
name|ffedata_charexpected_
operator|=
name|ffedata_size_
expr_stmt|;
name|ffedata_charnumber_
operator|=
literal|0
expr_stmt|;
name|ffedata_charoffset_
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FFEBLD_opARRAYREF
case|:
comment|/* Reference to element of array. */
name|ffedata_symbol_
operator|=
name|ffebld_symter
argument_list|(
name|ffebld_left
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|ffedata_storage_
operator|=
operator|(
name|ffesymbol_storage
argument_list|(
name|ffedata_symbol_
argument_list|)
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|ffestorag_parent
argument_list|(
name|ffesymbol_storage
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffedata_storage_
operator|!=
name|NULL
condition|)
block|{
name|ffetarget_aggregate_info
argument_list|(
operator|&
name|ffedata_storage_bt_
argument_list|,
operator|&
name|ffedata_storage_kt_
argument_list|,
operator|&
name|ffedata_storage_units_
argument_list|,
name|ffestorag_basictype
argument_list|(
name|ffedata_storage_
argument_list|)
argument_list|,
name|ffestorag_kindtype
argument_list|(
name|ffedata_storage_
argument_list|)
argument_list|)
expr_stmt|;
name|ffedata_storage_size_
operator|=
name|ffestorag_size
argument_list|(
name|ffedata_storage_
argument_list|)
operator|/
name|ffedata_storage_units_
expr_stmt|;
name|assert
argument_list|(
name|ffestorag_size
argument_list|(
name|ffedata_storage_
argument_list|)
operator|%
name|ffedata_storage_units_
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ffesymbol_init
argument_list|(
name|ffedata_symbol_
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ffedata_storage_
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffestorag_init
argument_list|(
name|ffedata_storage_
argument_list|)
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|ffebad_start (FFEBAD_DATA_REINIT); 	  ffest_ffebad_here_current_stmt (0); 	  ffebad_string (ffesymbol_text (ffedata_symbol_)); 	  ffebad_finish (); 	  ffedata_reported_error_ = TRUE; 	  return FALSE;
else|#
directive|else
name|ffedata_reinit_
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
endif|#
directive|endif
block|}
name|ffedata_basictype_
operator|=
name|ffesymbol_basictype
argument_list|(
name|ffedata_symbol_
argument_list|)
expr_stmt|;
name|ffedata_kindtype_
operator|=
name|ffesymbol_kindtype
argument_list|(
name|ffedata_symbol_
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_rank
argument_list|(
name|ffedata_symbol_
argument_list|)
operator|==
literal|0
condition|)
name|ffedata_arraysize_
operator|=
literal|1
expr_stmt|;
comment|/* Shouldn't happen in this case... */
else|else
block|{
name|ffebld
name|size
init|=
name|ffesymbol_arraysize
argument_list|(
name|ffedata_symbol_
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|size
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|size
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|size
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|size
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|ffedata_arraysize_
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffedata_expected_
operator|=
literal|1
expr_stmt|;
name|ffedata_number_
operator|=
literal|0
expr_stmt|;
name|ffedata_offset_
operator|=
name|ffedata_eval_offset_
argument_list|(
name|ffebld_right
argument_list|(
name|next
argument_list|)
argument_list|,
name|ffesymbol_dims
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
name|ffedata_size_
operator|=
operator|(
name|ffedata_basictype_
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
condition|?
name|ffesymbol_size
argument_list|(
name|ffedata_symbol_
argument_list|)
else|:
literal|1
expr_stmt|;
name|ffedata_symbolsize_
operator|=
name|ffedata_size_
operator|*
name|ffedata_arraysize_
expr_stmt|;
name|ffedata_charexpected_
operator|=
name|ffedata_size_
expr_stmt|;
name|ffedata_charnumber_
operator|=
literal|0
expr_stmt|;
name|ffedata_charoffset_
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FFEBLD_opSUBSTR
case|:
comment|/* Substring reference to scalar or array 				   element. */
block|{
name|bool
name|arrayref
init|=
name|ffebld_op
argument_list|(
name|ffebld_left
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opARRAYREF
decl_stmt|;
name|ffebld
name|colon
init|=
name|ffebld_right
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|colon
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffedata_symbol_
operator|=
name|ffebld_symter
argument_list|(
name|ffebld_left
argument_list|(
name|arrayref
condition|?
name|ffebld_left
argument_list|(
name|next
argument_list|)
else|:
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|ffedata_storage_
operator|=
operator|(
name|ffesymbol_storage
argument_list|(
name|ffedata_symbol_
argument_list|)
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|ffestorag_parent
argument_list|(
name|ffesymbol_storage
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffedata_storage_
operator|!=
name|NULL
condition|)
block|{
name|ffetarget_aggregate_info
argument_list|(
operator|&
name|ffedata_storage_bt_
argument_list|,
operator|&
name|ffedata_storage_kt_
argument_list|,
operator|&
name|ffedata_storage_units_
argument_list|,
name|ffestorag_basictype
argument_list|(
name|ffedata_storage_
argument_list|)
argument_list|,
name|ffestorag_kindtype
argument_list|(
name|ffedata_storage_
argument_list|)
argument_list|)
expr_stmt|;
name|ffedata_storage_size_
operator|=
name|ffestorag_size
argument_list|(
name|ffedata_storage_
argument_list|)
operator|/
name|ffedata_storage_units_
expr_stmt|;
name|assert
argument_list|(
name|ffestorag_size
argument_list|(
name|ffedata_storage_
argument_list|)
operator|%
name|ffedata_storage_units_
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ffesymbol_init
argument_list|(
name|ffedata_symbol_
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ffedata_storage_
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffestorag_init
argument_list|(
name|ffedata_storage_
argument_list|)
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|ffebad_start (FFEBAD_DATA_REINIT); 	    ffest_ffebad_here_current_stmt (0); 	    ffebad_string (ffesymbol_text (ffedata_symbol_)); 	    ffebad_finish (); 	    ffedata_reported_error_ = TRUE; 	    return FALSE;
else|#
directive|else
name|ffedata_reinit_
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
endif|#
directive|endif
block|}
name|ffedata_basictype_
operator|=
name|ffesymbol_basictype
argument_list|(
name|ffedata_symbol_
argument_list|)
expr_stmt|;
name|ffedata_kindtype_
operator|=
name|ffesymbol_kindtype
argument_list|(
name|ffedata_symbol_
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_rank
argument_list|(
name|ffedata_symbol_
argument_list|)
operator|==
literal|0
condition|)
name|ffedata_arraysize_
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|ffebld
name|size
init|=
name|ffesymbol_arraysize
argument_list|(
name|ffedata_symbol_
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|size
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|size
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|size
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|size
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|ffedata_arraysize_
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffedata_expected_
operator|=
name|arrayref
condition|?
literal|1
else|:
name|ffedata_arraysize_
expr_stmt|;
name|ffedata_number_
operator|=
literal|0
expr_stmt|;
name|ffedata_offset_
operator|=
name|arrayref
condition|?
name|ffedata_eval_offset_
argument_list|(
name|ffebld_right
argument_list|(
name|ffebld_left
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|,
name|ffesymbol_dims
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
else|:
literal|0
expr_stmt|;
name|ffedata_size_
operator|=
name|ffesymbol_size
argument_list|(
name|ffedata_symbol_
argument_list|)
expr_stmt|;
name|ffedata_symbolsize_
operator|=
name|ffedata_size_
operator|*
name|ffedata_arraysize_
expr_stmt|;
name|ffedata_charnumber_
operator|=
literal|0
expr_stmt|;
name|ffedata_charoffset_
operator|=
name|ffedata_eval_substr_begin_
argument_list|(
name|ffebld_head
argument_list|(
name|colon
argument_list|)
argument_list|)
expr_stmt|;
name|ffedata_charexpected_
operator|=
name|ffedata_eval_substr_end_
argument_list|(
name|ffebld_head
argument_list|(
name|ffebld_trail
argument_list|(
name|colon
argument_list|)
argument_list|)
argument_list|,
name|ffedata_charoffset_
argument_list|,
name|ffedata_size_
argument_list|)
operator|-
name|ffedata_charoffset_
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|FFEBLD_opIMPDO
case|:
comment|/* Implied-DO construct. */
block|{
name|ffebld
name|itervar
decl_stmt|;
name|ffebld
name|start
decl_stmt|;
name|ffebld
name|end
decl_stmt|;
name|ffebld
name|incr
decl_stmt|;
name|ffebld
name|item
init|=
name|ffebld_right
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|itervar
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|start
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|end
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|incr
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|ffedata_push_
argument_list|()
expr_stmt|;
name|ffedata_stack_
operator|->
name|outer_list
operator|=
name|ffedata_list_
expr_stmt|;
name|ffedata_stack_
operator|->
name|my_list
operator|=
name|ffedata_list_
operator|=
name|ffebld_left
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|itervar
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|itervar
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|ffedata_stack_
operator|->
name|itervar
operator|=
name|ffebld_symter
argument_list|(
name|itervar
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|start
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|start
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|ffesymbol_set_value
argument_list|(
name|ffedata_stack_
operator|->
name|itervar
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|end
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|end
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|ffedata_stack_
operator|->
name|final
operator|=
name|ffedata_eval_integer1_
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|incr
operator|==
name|NULL
condition|)
name|ffedata_stack_
operator|->
name|increment
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|incr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|incr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|ffedata_stack_
operator|->
name|increment
operator|=
name|ffedata_eval_integer1_
argument_list|(
name|incr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffedata_stack_
operator|->
name|increment
operator|==
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_ZERO
argument_list|)
expr_stmt|;
name|ffest_ffebad_here_current_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffedata_stack_
operator|->
name|itervar
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffedata_pop_
argument_list|()
expr_stmt|;
name|ffedata_reported_error_
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
operator|(
name|ffedata_stack_
operator|->
name|increment
operator|>
literal|0
operator|)
condition|?
name|ffesymbol_value
argument_list|(
name|ffedata_stack_
operator|->
name|itervar
argument_list|)
operator|>
name|ffedata_stack_
operator|->
name|final
else|:
name|ffesymbol_value
argument_list|(
name|ffedata_stack_
operator|->
name|itervar
argument_list|)
operator|<
name|ffedata_stack_
operator|->
name|final
condition|)
block|{
name|ffedata_reported_error_
operator|=
name|TRUE
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_EMPTY
argument_list|)
expr_stmt|;
name|ffest_ffebad_here_current_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffedata_stack_
operator|->
name|itervar
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffedata_pop_
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
goto|goto
name|tail_recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEBLD_opANY
case|:
name|ffedata_reported_error_
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
default|default:
name|assert
argument_list|(
literal|"bad op"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ffedata_convert_ -- Convert source expression to given type using cache     ffebld source;    ffelexToken source_token;    ffelexToken dest_token;  // Any appropriate token for "destination".    ffeinfoBasictype bt;    ffeinfoKindtype kt;    ffetargetCharactersize sz;    source = ffedata_convert_(source,source_token,dest_token,bt,kt,sz);     Like ffeexpr_convert, but calls it only if necessary (if the converted    expression doesn't already exist in the cache) and then puts the result    in the cache.  */
end_comment

begin_function
specifier|static
name|ffebld
name|ffedata_convert_
parameter_list|(
name|ffebld
name|source
parameter_list|,
name|ffelexToken
name|source_token
parameter_list|,
name|ffelexToken
name|dest_token
parameter_list|,
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|,
name|ffeinfoRank
name|rk
parameter_list|,
name|ffetargetCharacterSize
name|sz
parameter_list|)
block|{
name|ffebld
name|converted
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|max
decl_stmt|;
name|ffedataConvertCache_
name|cache
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ffedata_convert_cache_use_
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|bt
operator|==
name|ffedata_convert_cache_
index|[
name|i
index|]
operator|.
name|basic_type
operator|)
operator|&&
operator|(
name|kt
operator|==
name|ffedata_convert_cache_
index|[
name|i
index|]
operator|.
name|kind_type
operator|)
operator|&&
operator|(
name|sz
operator|==
name|ffedata_convert_cache_
index|[
name|i
index|]
operator|.
name|size
operator|)
operator|&&
operator|(
name|rk
operator|==
name|ffedata_convert_cache_
index|[
name|i
index|]
operator|.
name|rank
operator|)
condition|)
return|return
name|ffedata_convert_cache_
index|[
name|i
index|]
operator|.
name|converted
return|;
name|converted
operator|=
name|ffeexpr_convert
argument_list|(
name|source
argument_list|,
name|source_token
argument_list|,
name|dest_token
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|,
name|rk
argument_list|,
name|sz
argument_list|,
name|FFEEXPR_contextDATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffedata_convert_cache_use_
operator|>=
name|ffedata_convert_cache_max_
condition|)
block|{
if|if
condition|(
name|ffedata_convert_cache_max_
operator|==
literal|0
condition|)
name|max
operator|=
literal|4
expr_stmt|;
else|else
name|max
operator|=
name|ffedata_convert_cache_max_
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|max
operator|>
name|ffedata_convert_cache_max_
condition|)
block|{
name|cache
operator|=
operator|(
name|ffedataConvertCache_
operator|)
name|malloc_new_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFEDATA cache"
argument_list|,
name|max
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cache
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffedata_convert_cache_max_
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|cache
argument_list|,
name|ffedata_convert_cache_
argument_list|,
name|ffedata_convert_cache_max_
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cache
argument_list|)
argument_list|)
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
name|ffedata_convert_cache_
argument_list|,
name|ffedata_convert_cache_max_
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cache
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffedata_convert_cache_
operator|=
name|cache
expr_stmt|;
name|ffedata_convert_cache_max_
operator|=
name|max
expr_stmt|;
block|}
else|else
return|return
name|converted
return|;
comment|/* In case int overflows! */
block|}
name|i
operator|=
name|ffedata_convert_cache_use_
operator|++
expr_stmt|;
name|ffedata_convert_cache_
index|[
name|i
index|]
operator|.
name|converted
operator|=
name|converted
expr_stmt|;
name|ffedata_convert_cache_
index|[
name|i
index|]
operator|.
name|basic_type
operator|=
name|bt
expr_stmt|;
name|ffedata_convert_cache_
index|[
name|i
index|]
operator|.
name|kind_type
operator|=
name|kt
expr_stmt|;
name|ffedata_convert_cache_
index|[
name|i
index|]
operator|.
name|size
operator|=
name|sz
expr_stmt|;
name|ffedata_convert_cache_
index|[
name|i
index|]
operator|.
name|rank
operator|=
name|rk
expr_stmt|;
return|return
name|converted
return|;
block|}
end_function

begin_comment
comment|/* ffedata_eval_integer1_ -- Evaluate expression     ffetargetIntegerDefault result;    ffebld expr;	 // must be kindtypeINTEGER1.     result = ffedata_eval_integer1_(expr);     Evalues the expression (which yields a kindtypeINTEGER1 result) and    returns the result.	*/
end_comment

begin_function
specifier|static
name|ffetargetIntegerDefault
name|ffedata_eval_integer1_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffetargetInteger1
name|result
decl_stmt|;
name|ffebad
name|error
decl_stmt|;
name|assert
argument_list|(
name|expr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opCONTER
case|:
return|return
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
case|case
name|FFEBLD_opSYMTER
case|:
return|return
name|ffesymbol_value
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
case|case
name|FFEBLD_opUPLUS
case|:
return|return
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
case|case
name|FFEBLD_opUMINUS
case|:
name|error
operator|=
name|ffetarget_uminus_integer1
argument_list|(
operator|&
name|result
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opADD
case|:
name|error
operator|=
name|ffetarget_add_integer1
argument_list|(
operator|&
name|result
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opSUBTRACT
case|:
name|error
operator|=
name|ffetarget_subtract_integer1
argument_list|(
operator|&
name|result
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opMULTIPLY
case|:
name|error
operator|=
name|ffetarget_multiply_integer1
argument_list|(
operator|&
name|result
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opDIVIDE
case|:
name|error
operator|=
name|ffetarget_divide_integer1
argument_list|(
operator|&
name|result
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opPOWER
case|:
block|{
name|ffebld
name|r
init|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|r
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|r
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_kindtypeINTEGERDEFAULT
operator|)
condition|)
name|error
operator|=
name|FFEBAD_DATA_EVAL
expr_stmt|;
else|else
name|error
operator|=
name|ffetarget_power_integerdefault_integerdefault
argument_list|(
operator|&
name|result
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
comment|/* Only for character basictype. */
block|case FFEBLD_opCONCATENATE:       error =;       break;
endif|#
directive|endif
case|case
name|FFEBLD_opNOT
case|:
name|error
operator|=
name|ffetarget_not_integer1
argument_list|(
operator|&
name|result
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* Only for logical basictype. */
block|case FFEBLD_opLT:       error =;       break;      case FFEBLD_opLE:       error =;       break;      case FFEBLD_opEQ:       error =;       break;      case FFEBLD_opNE:       error =;       break;      case FFEBLD_opGT:       error =;       break;      case FFEBLD_opGE:       error =;       break;
endif|#
directive|endif
case|case
name|FFEBLD_opAND
case|:
name|error
operator|=
name|ffetarget_and_integer1
argument_list|(
operator|&
name|result
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opOR
case|:
name|error
operator|=
name|ffetarget_or_integer1
argument_list|(
operator|&
name|result
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opXOR
case|:
name|error
operator|=
name|ffetarget_xor_integer1
argument_list|(
operator|&
name|result
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opEQV
case|:
name|error
operator|=
name|ffetarget_eqv_integer1
argument_list|(
operator|&
name|result
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opNEQV
case|:
name|error
operator|=
name|ffetarget_neqv_integer1
argument_list|(
operator|&
name|result
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opPAREN
case|:
return|return
name|ffedata_eval_integer1_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
if|#
directive|if
literal|0
comment|/* ~~ no idea how to do this */
block|case FFEBLD_opPERCENT_LOC:       error =;       break;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* not allowed by ANSI, but perhaps as an 				   extension someday? */
block|case FFEBLD_opCONVERT:       switch (ffeinfo_basictype (ffebld_info (ffebld_left (expr)))) 	{ 	case FFEINFO_basictypeINTEGER: 	  switch (ffeinfo_kindtype (ffebld_info (ffebld_left (expr)))) 	    { 	    default: 	      error = FFEBAD_DATA_EVAL; 	      break; 	    } 	  break;  	case FFEINFO_basictypeREAL: 	  switch (ffeinfo_kindtype (ffebld_info (ffebld_left (expr)))) 	    { 	    default: 	      error = FFEBAD_DATA_EVAL; 	      break; 	    } 	  break; 	}       break;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* not valid ops */
block|case FFEBLD_opREPEAT:       error =;       break;      case FFEBLD_opBOUNDS:       error =;       break;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* not allowed by ANSI, but perhaps as an 				   extension someday? */
block|case FFEBLD_opFUNCREF:       error =;       break;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* not valid ops */
block|case FFEBLD_opSUBRREF:       error =;       break;      case FFEBLD_opARRAYREF:       error =;       break;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* not valid for integer1 */
block|case FFEBLD_opSUBSTR:       error =;       break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|FFEBAD_DATA_EVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|!=
name|FFEBAD
condition|)
block|{
name|ffebad_start
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|ffest_ffebad_here_current_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* ffedata_eval_offset_ -- Evaluate offset info array     ffetargetOffset offset;  // 0...max-1.    ffebld subscripts;  // an opITEM list of subscript exprs.    ffebld dims;	 // an opITEM list of opBOUNDS exprs.     result = ffedata_eval_offset_(expr);     Evalues the expression (which yields a kindtypeINTEGER1 result) and    returns the result.	*/
end_comment

begin_function
specifier|static
name|ffetargetOffset
name|ffedata_eval_offset_
parameter_list|(
name|ffebld
name|subscripts
parameter_list|,
name|ffebld
name|dims
parameter_list|)
block|{
name|ffetargetIntegerDefault
name|offset
init|=
literal|0
decl_stmt|;
name|ffetargetIntegerDefault
name|width
init|=
literal|1
decl_stmt|;
name|ffetargetIntegerDefault
name|value
decl_stmt|;
name|ffetargetIntegerDefault
name|lowbound
decl_stmt|;
name|ffetargetIntegerDefault
name|highbound
decl_stmt|;
name|ffetargetOffset
name|final
decl_stmt|;
name|ffebld
name|subscript
decl_stmt|;
name|ffebld
name|dim
decl_stmt|;
name|ffebld
name|low
decl_stmt|;
name|ffebld
name|high
decl_stmt|;
name|int
name|rank
init|=
literal|0
decl_stmt|;
name|bool
name|ok
decl_stmt|;
while|while
condition|(
name|subscripts
operator|!=
name|NULL
condition|)
block|{
operator|++
name|rank
expr_stmt|;
name|assert
argument_list|(
name|dims
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|subscript
operator|=
name|ffebld_head
argument_list|(
name|subscripts
argument_list|)
expr_stmt|;
name|dim
operator|=
name|ffebld_head
argument_list|(
name|dims
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|subscript
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|subscript
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGER1
argument_list|)
expr_stmt|;
name|value
operator|=
name|ffedata_eval_integer1_
argument_list|(
name|subscript
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|dim
argument_list|)
operator|==
name|FFEBLD_opBOUNDS
argument_list|)
expr_stmt|;
name|low
operator|=
name|ffebld_left
argument_list|(
name|dim
argument_list|)
expr_stmt|;
name|high
operator|=
name|ffebld_right
argument_list|(
name|dim
argument_list|)
expr_stmt|;
if|if
condition|(
name|low
operator|==
name|NULL
condition|)
name|lowbound
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|low
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|low
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|lowbound
operator|=
name|ffedata_eval_integer1_
argument_list|(
name|low
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|high
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|high
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|highbound
operator|=
name|ffedata_eval_integer1_
argument_list|(
name|high
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|<
name|lowbound
operator|)
operator|||
operator|(
name|value
operator|>
name|highbound
operator|)
condition|)
block|{
name|char
name|rankstr
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|rankstr
argument_list|,
literal|"%d"
argument_list|,
name|rank
argument_list|)
expr_stmt|;
name|value
operator|=
name|lowbound
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_SUBSCRIPT
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|rankstr
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|subscripts
operator|=
name|ffebld_trail
argument_list|(
name|subscripts
argument_list|)
expr_stmt|;
name|dims
operator|=
name|ffebld_trail
argument_list|(
name|dims
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|width
operator|*
operator|(
name|value
operator|-
name|lowbound
operator|)
expr_stmt|;
if|if
condition|(
name|subscripts
operator|!=
name|NULL
condition|)
name|width
operator|*=
name|highbound
operator|-
name|lowbound
operator|+
literal|1
expr_stmt|;
block|}
name|assert
argument_list|(
name|dims
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ok
operator|=
name|ffetarget_offset
argument_list|(
operator|&
name|final
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
return|return
name|final
return|;
block|}
end_function

begin_comment
comment|/* ffedata_eval_substr_begin_ -- Evaluate begin-point of substr reference     ffetargetCharacterSize beginpoint;    ffebld endval;  // head(colon).     beginpoint = ffedata_eval_substr_end_(endval);     If beginval is NULL, returns 0.  Otherwise makes sure beginval is    kindtypeINTEGERDEFAULT, makes sure its value is> 0,    and returns its value minus one, or issues an error message.	 */
end_comment

begin_function
specifier|static
name|ffetargetCharacterSize
name|ffedata_eval_substr_begin_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffetargetIntegerDefault
name|val
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|val
operator|=
name|ffedata_eval_integer1_
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|1
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_RANGE
argument_list|)
expr_stmt|;
name|ffest_ffebad_here_current_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffedata_reported_error_
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|val
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ffedata_eval_substr_end_ -- Evaluate end-point of substr reference     ffetargetCharacterSize endpoint;    ffebld endval;  // head(trail(colon)).    ffetargetCharacterSize min;	// beginpoint of substr reference.    ffetargetCharacterSize max;	// size of entity.     endpoint = ffedata_eval_substr_end_(endval,dflt);     If endval is NULL, returns max.  Otherwise makes sure endval is    kindtypeINTEGERDEFAULT, makes sure its value is> min and<= max,    and returns its value minus one, or issues an error message.	 */
end_comment

begin_function
specifier|static
name|ffetargetCharacterSize
name|ffedata_eval_substr_end_
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffetargetCharacterSize
name|min
parameter_list|,
name|ffetargetCharacterSize
name|max
parameter_list|)
block|{
name|ffetargetIntegerDefault
name|val
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return
name|max
operator|-
literal|1
return|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGER1
argument_list|)
expr_stmt|;
name|val
operator|=
name|ffedata_eval_integer1_
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|<
operator|(
name|ffetargetIntegerDefault
operator|)
name|min
operator|)
operator|||
operator|(
name|val
operator|>
operator|(
name|ffetargetIntegerDefault
operator|)
name|max
operator|)
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_RANGE
argument_list|)
expr_stmt|;
name|ffest_ffebad_here_current_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffedata_reported_error_
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|val
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ffedata_gather_ -- Gather initial values for sym into master sym inits     ffestorag mst;  // A typeCBLOCK or typeLOCAL aggregate.    ffestorag st;  // A typeCOMMON or typeEQUIV member.    ffedata_gather_(mst,st);     If st has any initialization info, transfer that info into mst and    clear st's info.  */
end_comment

begin_function
specifier|static
name|void
name|ffedata_gather_
parameter_list|(
name|ffestorag
name|mst
parameter_list|,
name|ffestorag
name|st
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbol
name|s_whine
decl_stmt|;
comment|/* Symbol to complain about in diagnostics. */
name|ffebld
name|b
decl_stmt|;
name|ffetargetOffset
name|offset
decl_stmt|;
name|ffetargetOffset
name|units_expected
decl_stmt|;
name|ffebitCount
name|actual
decl_stmt|;
name|ffebldConstantArray
name|array
decl_stmt|;
name|ffebld
name|accter
decl_stmt|;
name|ffetargetCopyfunc
name|fn
decl_stmt|;
name|void
modifier|*
name|ptr1
decl_stmt|;
name|void
modifier|*
name|ptr2
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|ffeinfoBasictype
name|ign_bt
decl_stmt|;
name|ffeinfoKindtype
name|ign_kt
decl_stmt|;
name|ffetargetAlign
name|units
decl_stmt|;
name|ffebit
name|bits
decl_stmt|;
name|ffetargetOffset
name|source_offset
decl_stmt|;
name|bool
name|whine
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
return|return;
comment|/* Nothing to do. */
name|s
operator|=
name|ffestorag_symbol
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Must have a corresponding symbol (else how 				   inited?). */
name|assert
argument_list|(
name|ffestorag_init
argument_list|(
name|st
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* No init info on storage itself. */
name|assert
argument_list|(
name|ffestorag_accretion
argument_list|(
name|st
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|b
operator|=
name|ffesymbol_init
argument_list|(
name|s
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|b
operator|=
name|ffesymbol_accretion
argument_list|(
name|s
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|b
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
operator|||
operator|(
operator|(
name|ffebld_op
argument_list|(
name|b
argument_list|)
operator|==
name|FFEBLD_opCONVERT
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|ffebld_left
argument_list|(
name|b
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
operator|)
condition|)
return|return;
comment|/* Nothing to do. */
comment|/* b now holds the init/accretion expr. */
name|ffesymbol_set_init
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffesymbol_set_accretion
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffesymbol_set_accretes
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s_whine
operator|=
name|ffestorag_symbol
argument_list|(
name|mst
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_whine
operator|==
name|NULL
condition|)
name|s_whine
operator|=
name|s
expr_stmt|;
comment|/* Make sure we haven't fully accreted during an array init. */
if|if
condition|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_MULTIPLE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffewhere_line_unknown
argument_list|()
argument_list|,
name|ffewhere_column_unknown
argument_list|()
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s_whine
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return;
block|}
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Calculate offset for aggregate area. */
name|ffedata_charexpected_
operator|=
operator|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
condition|?
name|ffebld_size
argument_list|(
name|b
argument_list|)
else|:
literal|1
expr_stmt|;
name|ffetarget_aggregate_info
argument_list|(
operator|&
name|ign_bt
argument_list|,
operator|&
name|ign_kt
argument_list|,
operator|&
name|units
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|)
expr_stmt|;
comment|/* Find out unit size of source datum. */
name|assert
argument_list|(
name|units
operator|%
name|ffedata_storage_units_
operator|==
literal|0
argument_list|)
expr_stmt|;
name|units_expected
operator|=
name|ffedata_charexpected_
operator|*
name|units
operator|/
name|ffedata_storage_units_
expr_stmt|;
name|offset
operator|=
operator|(
name|ffestorag_offset
argument_list|(
name|st
argument_list|)
operator|-
name|ffestorag_offset
argument_list|(
name|mst
argument_list|)
operator|)
operator|/
name|ffedata_storage_units_
expr_stmt|;
comment|/* Does an accretion array exist?  If not, create it. */
if|if
condition|(
name|ffestorag_accretion
argument_list|(
name|mst
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|FFEDATA_sizeTOO_BIG_INIT_
operator|!=
literal|0
if|if
condition|(
name|ffedata_storage_size_
operator|>=
name|FFEDATA_sizeTOO_BIG_INIT_
condition|)
block|{
name|char
name|bignum
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
operator|&
name|bignum
index|[
literal|0
index|]
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|ffedata_storage_size_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_TOO_BIG_INIT
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffesymbol_where_line
argument_list|(
name|s_whine
argument_list|)
argument_list|,
name|ffesymbol_where_column
argument_list|(
name|s_whine
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s_whine
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|bignum
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|array
operator|=
name|ffebld_constantarray_new
argument_list|(
name|ffedata_storage_bt_
argument_list|,
name|ffedata_storage_kt_
argument_list|,
name|ffedata_storage_size_
argument_list|)
expr_stmt|;
name|accter
operator|=
name|ffebld_new_accter
argument_list|(
name|array
argument_list|,
name|ffebit_new
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
name|ffedata_storage_size_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|accter
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffedata_storage_bt_
argument_list|,
name|ffedata_storage_kt_
argument_list|,
literal|1
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
operator|(
name|ffedata_basictype_
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
condition|?
literal|1
else|:
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffestorag_set_accretion
argument_list|(
name|mst
argument_list|,
name|accter
argument_list|)
expr_stmt|;
name|ffestorag_set_accretes
argument_list|(
name|mst
argument_list|,
name|ffedata_storage_size_
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|accter
operator|=
name|ffestorag_accretion
argument_list|(
name|mst
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffedata_storage_size_
operator|==
operator|(
name|ffetargetOffset
operator|)
name|ffebld_accter_size
argument_list|(
name|accter
argument_list|)
argument_list|)
expr_stmt|;
name|array
operator|=
name|ffebld_accter
argument_list|(
name|accter
argument_list|)
expr_stmt|;
block|}
comment|/* Put value in accretion array at desired offset. */
name|fn
operator|=
name|ffetarget_aggregate_ptr_memcpy
argument_list|(
name|ffedata_storage_bt_
argument_list|,
name|ffedata_storage_kt_
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|b
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opCONTER
case|:
name|ffebld_constantarray_prepare
argument_list|(
operator|&
name|ptr1
argument_list|,
operator|&
name|ptr2
argument_list|,
operator|&
name|size
argument_list|,
name|array
argument_list|,
name|ffedata_storage_bt_
argument_list|,
name|ffedata_storage_kt_
argument_list|,
name|offset
argument_list|,
name|ffebld_constant_ptr_to_union
argument_list|(
name|ffebld_conter
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fn
call|)
argument_list|(
name|ptr1
argument_list|,
name|ptr2
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Does the appropriate memcpy-like 				   operation. */
name|ffebit_count
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|accter
argument_list|)
argument_list|,
name|offset
argument_list|,
name|FALSE
argument_list|,
name|units_expected
argument_list|,
operator|&
name|actual
argument_list|)
expr_stmt|;
comment|/* How many FALSE? */
if|if
condition|(
name|units_expected
operator|!=
operator|(
name|ffetargetOffset
operator|)
name|actual
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_MULTIPLE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffewhere_line_unknown
argument_list|()
argument_list|,
name|ffewhere_column_unknown
argument_list|()
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestorag_set_accretes
argument_list|(
name|mst
argument_list|,
name|ffestorag_accretes
argument_list|(
name|mst
argument_list|)
operator|-
name|actual
argument_list|)
expr_stmt|;
comment|/* Decrement # of values 						   actually accreted. */
name|ffebit_set
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|accter
argument_list|)
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|units_expected
argument_list|)
expr_stmt|;
comment|/* If done accreting for this storage area, establish as initialized. */
if|if
condition|(
name|ffestorag_accretes
argument_list|(
name|mst
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ffestorag_set_init
argument_list|(
name|mst
argument_list|,
name|accter
argument_list|)
expr_stmt|;
name|ffestorag_set_accretion
argument_list|(
name|mst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffebit_kill
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_op
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|,
name|FFEBLD_opARRTER
argument_list|)
expr_stmt|;
name|ffebld_set_arrter
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|,
name|ffebld_accter
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_arrter_set_size
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|,
name|ffedata_storage_size_
argument_list|)
expr_stmt|;
name|ffebld_arrter_set_pad
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffecom_notify_init_storage
argument_list|(
name|mst
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|FFEBLD_opARRTER
case|:
name|ffebld_constantarray_preparray
argument_list|(
operator|&
name|ptr1
argument_list|,
operator|&
name|ptr2
argument_list|,
operator|&
name|size
argument_list|,
name|array
argument_list|,
name|ffedata_storage_bt_
argument_list|,
name|ffedata_storage_kt_
argument_list|,
name|offset
argument_list|,
name|ffebld_arrter
argument_list|(
name|b
argument_list|)
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|)
expr_stmt|;
name|size
operator|*=
name|ffebld_arrter_size
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|units_expected
operator|*=
name|ffebld_arrter_size
argument_list|(
name|b
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fn
call|)
argument_list|(
name|ptr1
argument_list|,
name|ptr2
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Does the appropriate memcpy-like 				   operation. */
name|ffebit_count
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|accter
argument_list|)
argument_list|,
name|offset
argument_list|,
name|FALSE
argument_list|,
name|units_expected
argument_list|,
operator|&
name|actual
argument_list|)
expr_stmt|;
comment|/* How many FALSE? */
if|if
condition|(
name|units_expected
operator|!=
operator|(
name|ffetargetOffset
operator|)
name|actual
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_MULTIPLE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffewhere_line_unknown
argument_list|()
argument_list|,
name|ffewhere_column_unknown
argument_list|()
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestorag_set_accretes
argument_list|(
name|mst
argument_list|,
name|ffestorag_accretes
argument_list|(
name|mst
argument_list|)
operator|-
name|actual
argument_list|)
expr_stmt|;
comment|/* Decrement # of values 						   actually accreted. */
name|ffebit_set
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|accter
argument_list|)
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|units_expected
argument_list|)
expr_stmt|;
comment|/* If done accreting for this storage area, establish as initialized. */
if|if
condition|(
name|ffestorag_accretes
argument_list|(
name|mst
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ffestorag_set_init
argument_list|(
name|mst
argument_list|,
name|accter
argument_list|)
expr_stmt|;
name|ffestorag_set_accretion
argument_list|(
name|mst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffebit_kill
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_op
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|,
name|FFEBLD_opARRTER
argument_list|)
expr_stmt|;
name|ffebld_set_arrter
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|,
name|ffebld_accter
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_arrter_set_size
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|,
name|ffedata_storage_size_
argument_list|)
expr_stmt|;
name|ffebld_arrter_set_pad
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffecom_notify_init_storage
argument_list|(
name|mst
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|FFEBLD_opACCTER
case|:
name|ffebld_constantarray_preparray
argument_list|(
operator|&
name|ptr1
argument_list|,
operator|&
name|ptr2
argument_list|,
operator|&
name|size
argument_list|,
name|array
argument_list|,
name|ffedata_storage_bt_
argument_list|,
name|ffedata_storage_kt_
argument_list|,
name|offset
argument_list|,
name|ffebld_accter
argument_list|(
name|b
argument_list|)
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|)
expr_stmt|;
name|bits
operator|=
name|ffebld_accter_bits
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|source_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ffetargetOffset
name|unexp
decl_stmt|;
name|ffetargetOffset
name|siz
decl_stmt|;
name|ffebitCount
name|length
decl_stmt|;
name|bool
name|value
decl_stmt|;
name|ffebit_test
argument_list|(
name|bits
argument_list|,
name|source_offset
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
break|break;
comment|/* Exit the loop early. */
name|siz
operator|=
name|size
operator|*
name|length
expr_stmt|;
name|unexp
operator|=
name|units_expected
operator|*
name|length
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
call|(
modifier|*
name|fn
call|)
argument_list|(
name|ptr1
argument_list|,
name|ptr2
argument_list|,
name|siz
argument_list|)
expr_stmt|;
comment|/* Does memcpy-like operation. */
name|ffebit_count
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|accter
argument_list|)
argument_list|,
comment|/* How many FALSE? */
name|offset
argument_list|,
name|FALSE
argument_list|,
name|unexp
argument_list|,
operator|&
name|actual
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|whine
operator|&&
operator|(
name|unexp
operator|!=
operator|(
name|ffetargetOffset
operator|)
name|actual
operator|)
condition|)
block|{
name|whine
operator|=
name|TRUE
expr_stmt|;
comment|/* Don't whine more than once for one gather. */
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_MULTIPLE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffewhere_line_unknown
argument_list|()
argument_list|,
name|ffewhere_column_unknown
argument_list|()
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestorag_set_accretes
argument_list|(
name|mst
argument_list|,
name|ffestorag_accretes
argument_list|(
name|mst
argument_list|)
operator|-
name|actual
argument_list|)
expr_stmt|;
comment|/* Decrement # of values 							   actually accreted. */
name|ffebit_set
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|accter
argument_list|)
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|unexp
argument_list|)
expr_stmt|;
block|}
name|source_offset
operator|+=
name|length
expr_stmt|;
name|offset
operator|+=
name|unexp
expr_stmt|;
name|ptr1
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr1
operator|)
operator|+
name|siz
expr_stmt|;
name|ptr2
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr2
operator|)
operator|+
name|siz
expr_stmt|;
block|}
comment|/* If done accreting for this storage area, establish as initialized. */
if|if
condition|(
name|ffestorag_accretes
argument_list|(
name|mst
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ffestorag_set_init
argument_list|(
name|mst
argument_list|,
name|accter
argument_list|)
expr_stmt|;
name|ffestorag_set_accretion
argument_list|(
name|mst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffebit_kill
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_op
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|,
name|FFEBLD_opARRTER
argument_list|)
expr_stmt|;
name|ffebld_set_arrter
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|,
name|ffebld_accter
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_arrter_set_size
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|,
name|ffedata_storage_size_
argument_list|)
expr_stmt|;
name|ffebld_arrter_set_pad
argument_list|(
name|ffestorag_init
argument_list|(
name|mst
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffecom_notify_init_storage
argument_list|(
name|mst
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
name|assert
argument_list|(
literal|"bad init op in gather_"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* ffedata_pop_ -- Pop an impdo stack entry     ffedata_pop_();  */
end_comment

begin_function
specifier|static
name|void
name|ffedata_pop_
parameter_list|()
block|{
name|ffedataImpdo_
name|victim
init|=
name|ffedata_stack_
decl_stmt|;
name|assert
argument_list|(
name|victim
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffedata_stack_
operator|=
name|ffedata_stack_
operator|->
name|outer
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
name|victim
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|victim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffedata_push_ -- Push an impdo stack entry     ffedata_push_();  */
end_comment

begin_function
specifier|static
name|void
name|ffedata_push_
parameter_list|()
block|{
name|ffedataImpdo_
name|baby
decl_stmt|;
name|baby
operator|=
name|malloc_new_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
literal|"ffedataImpdo_"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baby
argument_list|)
argument_list|)
expr_stmt|;
name|baby
operator|->
name|outer
operator|=
name|ffedata_stack_
expr_stmt|;
name|ffedata_stack_
operator|=
name|baby
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffedata_value_ -- Provide an initial value     ffebld value;    ffelexToken t;  // Points to the value.    if (ffedata_value(value,t))        // Everything's ok     Makes sure the value is ok, then remembers it according to the list    provided to ffedata_begin.  */
end_comment

begin_function
specifier|static
name|bool
name|ffedata_value_
parameter_list|(
name|ffebld
name|value
parameter_list|,
name|ffelexToken
name|token
parameter_list|)
block|{
comment|/* If already reported an error, don't do anything. */
if|if
condition|(
name|ffedata_reported_error_
condition|)
return|return
name|FALSE
return|;
comment|/* If the value is an error marker, remember we've seen one and do nothing      else. */
if|if
condition|(
operator|(
name|value
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|value
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
condition|)
block|{
name|ffedata_reported_error_
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If too many values (no more targets), complain. */
if|if
condition|(
name|ffedata_symbol_
operator|==
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_TOOMANY
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffedata_reported_error_
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If ffedata_advance_ wanted to register a complaint, do it now      that we have the token to point at instead of just the start      of the whole statement.  */
if|if
condition|(
name|ffedata_reinit_
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_REINIT
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffedata_reported_error_
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|#
directive|if
name|FFEGLOBAL_ENABLED
if|if
condition|(
name|ffesymbol_common
argument_list|(
name|ffedata_symbol_
argument_list|)
operator|!=
name|NULL
condition|)
name|ffeglobal_init_common
argument_list|(
name|ffesymbol_common
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|,
name|token
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Convert value to desired type. */
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffedata_convert_cache_use_
operator|==
operator|-
literal|1
condition|)
name|value
operator|=
name|ffeexpr_convert
argument_list|(
name|value
argument_list|,
name|token
argument_list|,
name|NULL
argument_list|,
name|ffedata_basictype_
argument_list|,
name|ffedata_kindtype_
argument_list|,
literal|0
argument_list|,
operator|(
name|ffedata_basictype_
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
condition|?
name|ffedata_charexpected_
else|:
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextDATA
argument_list|)
expr_stmt|;
else|else
comment|/* Use the cache. */
name|value
operator|=
name|ffedata_convert_
argument_list|(
name|value
argument_list|,
name|token
argument_list|,
name|NULL
argument_list|,
name|ffedata_basictype_
argument_list|,
name|ffedata_kindtype_
argument_list|,
literal|0
argument_list|,
operator|(
name|ffedata_basictype_
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
condition|?
name|ffedata_charexpected_
else|:
name|FFETARGET_charactersizeNONE
argument_list|)
expr_stmt|;
block|}
comment|/* If we couldn't, bug out. */
if|if
condition|(
operator|(
name|value
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|value
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
condition|)
block|{
name|ffedata_reported_error_
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Handle the case where initializes go to a parent's storage area. */
if|if
condition|(
name|ffedata_storage_
operator|!=
name|NULL
condition|)
block|{
name|ffetargetOffset
name|offset
decl_stmt|;
name|ffetargetOffset
name|units_expected
decl_stmt|;
name|ffebitCount
name|actual
decl_stmt|;
name|ffebldConstantArray
name|array
decl_stmt|;
name|ffebld
name|accter
decl_stmt|;
name|ffetargetCopyfunc
name|fn
decl_stmt|;
name|void
modifier|*
name|ptr1
decl_stmt|;
name|void
modifier|*
name|ptr2
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|ffeinfoBasictype
name|ign_bt
decl_stmt|;
name|ffeinfoKindtype
name|ign_kt
decl_stmt|;
name|ffetargetAlign
name|units
decl_stmt|;
comment|/* Make sure we haven't fully accreted during an array init. */
if|if
condition|(
name|ffestorag_init
argument_list|(
name|ffedata_storage_
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_MULTIPLE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffedata_reported_error_
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Calculate offset. */
name|offset
operator|=
name|ffedata_offset_
operator|*
name|ffedata_size_
operator|+
name|ffedata_charoffset_
expr_stmt|;
comment|/* Is offset within range?  If not, whine, but don't do anything else. */
if|if
condition|(
name|offset
operator|+
name|ffedata_charexpected_
operator|-
literal|1
operator|>
name|ffedata_symbolsize_
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_RANGE
argument_list|)
expr_stmt|;
name|ffest_ffebad_here_current_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffedata_reported_error_
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Now calculate offset for aggregate area. */
name|ffetarget_aggregate_info
argument_list|(
operator|&
name|ign_bt
argument_list|,
operator|&
name|ign_kt
argument_list|,
operator|&
name|units
argument_list|,
name|ffedata_basictype_
argument_list|,
name|ffedata_kindtype_
argument_list|)
expr_stmt|;
comment|/* Find out unit size of 							   source datum. */
name|assert
argument_list|(
name|units
operator|%
name|ffedata_storage_units_
operator|==
literal|0
argument_list|)
expr_stmt|;
name|units_expected
operator|=
name|ffedata_charexpected_
operator|*
name|units
operator|/
name|ffedata_storage_units_
expr_stmt|;
name|offset
operator|*=
name|units
operator|/
name|ffedata_storage_units_
expr_stmt|;
name|offset
operator|+=
operator|(
name|ffestorag_offset
argument_list|(
name|ffesymbol_storage
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
operator|-
name|ffestorag_offset
argument_list|(
name|ffedata_storage_
argument_list|)
operator|)
operator|/
name|ffedata_storage_units_
expr_stmt|;
name|assert
argument_list|(
name|offset
operator|+
name|units_expected
operator|-
literal|1
operator|<=
name|ffedata_storage_size_
argument_list|)
expr_stmt|;
comment|/* Does an accretion array exist?	 If not, create it. */
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffestorag_accretion
argument_list|(
name|ffedata_storage_
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|FFEDATA_sizeTOO_BIG_INIT_
operator|!=
literal|0
if|if
condition|(
name|ffedata_storage_size_
operator|>=
name|FFEDATA_sizeTOO_BIG_INIT_
condition|)
block|{
name|char
name|bignum
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
operator|&
name|bignum
index|[
literal|0
index|]
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|ffedata_storage_size_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_TOO_BIG_INIT
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|bignum
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|array
operator|=
name|ffebld_constantarray_new
argument_list|(
name|ffedata_storage_bt_
argument_list|,
name|ffedata_storage_kt_
argument_list|,
name|ffedata_storage_size_
argument_list|)
expr_stmt|;
name|accter
operator|=
name|ffebld_new_accter
argument_list|(
name|array
argument_list|,
name|ffebit_new
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
name|ffedata_storage_size_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|accter
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffedata_storage_bt_
argument_list|,
name|ffedata_storage_kt_
argument_list|,
literal|1
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
operator|(
name|ffedata_basictype_
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
condition|?
literal|1
else|:
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffestorag_set_accretion
argument_list|(
name|ffedata_storage_
argument_list|,
name|accter
argument_list|)
expr_stmt|;
name|ffestorag_set_accretes
argument_list|(
name|ffedata_storage_
argument_list|,
name|ffedata_storage_size_
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|accter
operator|=
name|ffestorag_accretion
argument_list|(
name|ffedata_storage_
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffedata_storage_size_
operator|==
operator|(
name|ffetargetOffset
operator|)
name|ffebld_accter_size
argument_list|(
name|accter
argument_list|)
argument_list|)
expr_stmt|;
name|array
operator|=
name|ffebld_accter
argument_list|(
name|accter
argument_list|)
expr_stmt|;
block|}
comment|/* Put value in accretion array at desired offset. */
name|fn
operator|=
name|ffetarget_aggregate_ptr_memcpy
argument_list|(
name|ffedata_storage_bt_
argument_list|,
name|ffedata_storage_kt_
argument_list|,
name|ffedata_basictype_
argument_list|,
name|ffedata_kindtype_
argument_list|)
expr_stmt|;
name|ffebld_constantarray_prepare
argument_list|(
operator|&
name|ptr1
argument_list|,
operator|&
name|ptr2
argument_list|,
operator|&
name|size
argument_list|,
name|array
argument_list|,
name|ffedata_storage_bt_
argument_list|,
name|ffedata_storage_kt_
argument_list|,
name|offset
argument_list|,
name|ffebld_constant_ptr_to_union
argument_list|(
name|ffebld_conter
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|ffedata_basictype_
argument_list|,
name|ffedata_kindtype_
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fn
call|)
argument_list|(
name|ptr1
argument_list|,
name|ptr2
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Does the appropriate memcpy-like 					   operation. */
name|ffebit_count
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|accter
argument_list|)
argument_list|,
name|offset
argument_list|,
name|FALSE
argument_list|,
name|units_expected
argument_list|,
operator|&
name|actual
argument_list|)
expr_stmt|;
comment|/* How many FALSE? */
if|if
condition|(
name|units_expected
operator|!=
operator|(
name|ffetargetOffset
operator|)
name|actual
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_MULTIPLE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestorag_set_accretes
argument_list|(
name|ffedata_storage_
argument_list|,
name|ffestorag_accretes
argument_list|(
name|ffedata_storage_
argument_list|)
operator|-
name|actual
argument_list|)
expr_stmt|;
comment|/* Decrement # of values 						   actually accreted. */
name|ffebit_set
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|accter
argument_list|)
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|units_expected
argument_list|)
expr_stmt|;
comment|/* If done accreting for this storage area, establish as 	     initialized. */
if|if
condition|(
name|ffestorag_accretes
argument_list|(
name|ffedata_storage_
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ffestorag_set_init
argument_list|(
name|ffedata_storage_
argument_list|,
name|accter
argument_list|)
expr_stmt|;
name|ffestorag_set_accretion
argument_list|(
name|ffedata_storage_
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffebit_kill
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|ffestorag_init
argument_list|(
name|ffedata_storage_
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_op
argument_list|(
name|ffestorag_init
argument_list|(
name|ffedata_storage_
argument_list|)
argument_list|,
name|FFEBLD_opARRTER
argument_list|)
expr_stmt|;
name|ffebld_set_arrter
argument_list|(
name|ffestorag_init
argument_list|(
name|ffedata_storage_
argument_list|)
argument_list|,
name|ffebld_accter
argument_list|(
name|ffestorag_init
argument_list|(
name|ffedata_storage_
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_arrter_set_size
argument_list|(
name|ffestorag_init
argument_list|(
name|ffedata_storage_
argument_list|)
argument_list|,
name|ffedata_storage_size_
argument_list|)
expr_stmt|;
name|ffebld_arrter_set_pad
argument_list|(
name|ffestorag_init
argument_list|(
name|ffedata_storage_
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffecom_notify_init_storage
argument_list|(
name|ffedata_storage_
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If still accreting, adjust specs accordingly and return. */
if|if
condition|(
operator|++
name|ffedata_number_
operator|<
name|ffedata_expected_
condition|)
block|{
operator|++
name|ffedata_offset_
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|ffedata_advance_
argument_list|()
return|;
block|}
comment|/* Figure out where the value goes -- in an accretion array or directly      into the final initial-value slot for the symbol. */
if|if
condition|(
operator|(
name|ffedata_number_
operator|!=
literal|0
operator|)
operator|||
operator|(
name|ffedata_arraysize_
operator|>
literal|1
operator|)
operator|||
operator|(
name|ffedata_charnumber_
operator|!=
literal|0
operator|)
operator|||
operator|(
name|ffedata_size_
operator|>
name|ffedata_charexpected_
operator|)
condition|)
block|{
comment|/* Accrete this value. */
name|ffetargetOffset
name|offset
decl_stmt|;
name|ffebitCount
name|actual
decl_stmt|;
name|ffebldConstantArray
name|array
decl_stmt|;
name|ffebld
name|accter
init|=
name|NULL
decl_stmt|;
comment|/* Calculate offset. */
name|offset
operator|=
name|ffedata_offset_
operator|*
name|ffedata_size_
operator|+
name|ffedata_charoffset_
expr_stmt|;
comment|/* Is offset within range?  If not, whine, but don't do anything else. */
if|if
condition|(
name|offset
operator|+
name|ffedata_charexpected_
operator|-
literal|1
operator|>
name|ffedata_symbolsize_
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_RANGE
argument_list|)
expr_stmt|;
name|ffest_ffebad_here_current_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffedata_reported_error_
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Does an accretion array exist?	 If not, create it. */
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffesymbol_accretion
argument_list|(
name|ffedata_symbol_
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|FFEDATA_sizeTOO_BIG_INIT_
operator|!=
literal|0
if|if
condition|(
name|ffedata_symbolsize_
operator|>=
name|FFEDATA_sizeTOO_BIG_INIT_
condition|)
block|{
name|char
name|bignum
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
operator|&
name|bignum
index|[
literal|0
index|]
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|ffedata_symbolsize_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_TOO_BIG_INIT
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|bignum
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|array
operator|=
name|ffebld_constantarray_new
argument_list|(
name|ffedata_basictype_
argument_list|,
name|ffedata_kindtype_
argument_list|,
name|ffedata_symbolsize_
argument_list|)
expr_stmt|;
name|accter
operator|=
name|ffebld_new_accter
argument_list|(
name|array
argument_list|,
name|ffebit_new
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
name|ffedata_symbolsize_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|accter
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffedata_basictype_
argument_list|,
name|ffedata_kindtype_
argument_list|,
literal|1
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
operator|(
name|ffedata_basictype_
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
condition|?
literal|1
else|:
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_accretion
argument_list|(
name|ffedata_symbol_
argument_list|,
name|accter
argument_list|)
expr_stmt|;
name|ffesymbol_set_accretes
argument_list|(
name|ffedata_symbol_
argument_list|,
name|ffedata_symbolsize_
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|accter
operator|=
name|ffesymbol_accretion
argument_list|(
name|ffedata_symbol_
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffedata_symbolsize_
operator|==
operator|(
name|ffetargetOffset
operator|)
name|ffebld_accter_size
argument_list|(
name|accter
argument_list|)
argument_list|)
expr_stmt|;
name|array
operator|=
name|ffebld_accter
argument_list|(
name|accter
argument_list|)
expr_stmt|;
block|}
comment|/* Put value in accretion array at desired offset. */
name|ffebld_constantarray_put
argument_list|(
name|array
argument_list|,
name|ffedata_basictype_
argument_list|,
name|ffedata_kindtype_
argument_list|,
name|offset
argument_list|,
name|ffebld_constant_union
argument_list|(
name|ffebld_conter
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebit_count
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|accter
argument_list|)
argument_list|,
name|offset
argument_list|,
name|FALSE
argument_list|,
name|ffedata_charexpected_
argument_list|,
operator|&
name|actual
argument_list|)
expr_stmt|;
comment|/* How many FALSE? */
if|if
condition|(
name|actual
operator|!=
operator|(
name|unsigned
name|long
name|int
operator|)
name|ffedata_charexpected_
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DATA_MULTIPLE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffesymbol_set_accretes
argument_list|(
name|ffedata_symbol_
argument_list|,
name|ffesymbol_accretes
argument_list|(
name|ffedata_symbol_
argument_list|)
operator|-
name|actual
argument_list|)
expr_stmt|;
comment|/* Decrement # of values 						   actually accreted. */
name|ffebit_set
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|accter
argument_list|)
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|ffedata_charexpected_
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|ffedata_symbol_
argument_list|)
expr_stmt|;
block|}
comment|/* If still accreting, adjust specs accordingly and return. */
if|if
condition|(
operator|++
name|ffedata_number_
operator|<
name|ffedata_expected_
condition|)
block|{
operator|++
name|ffedata_offset_
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Else, if done accreting for this symbol, establish as initialized. */
if|if
condition|(
operator|(
name|value
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffesymbol_accretes
argument_list|(
name|ffedata_symbol_
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ffesymbol_set_init
argument_list|(
name|ffedata_symbol_
argument_list|,
name|accter
argument_list|)
expr_stmt|;
name|ffesymbol_set_accretion
argument_list|(
name|ffedata_symbol_
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffebit_kill
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|ffesymbol_init
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_op
argument_list|(
name|ffesymbol_init
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|,
name|FFEBLD_opARRTER
argument_list|)
expr_stmt|;
name|ffebld_set_arrter
argument_list|(
name|ffesymbol_init
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|,
name|ffebld_accter
argument_list|(
name|ffesymbol_init
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_arrter_set_size
argument_list|(
name|ffesymbol_init
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|,
name|ffedata_symbolsize_
argument_list|)
expr_stmt|;
name|ffebld_arrter_set_pad
argument_list|(
name|ffestorag_init
argument_list|(
name|ffedata_symbol_
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffecom_notify_init_symbol
argument_list|(
name|ffedata_symbol_
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
comment|/* Simple, direct, one-shot assignment. */
name|ffesymbol_set_init
argument_list|(
name|ffedata_symbol_
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|ffecom_notify_init_symbol
argument_list|(
name|ffedata_symbol_
argument_list|)
expr_stmt|;
block|}
comment|/* Call on advance function to get next target in list. */
return|return
name|ffedata_advance_
argument_list|()
return|;
block|}
end_function

end_unit

