begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* bad.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       None     Description:       Handles the displaying of diagnostic messages regarding the user's source       files.     Modifications: */
end_comment

begin_comment
comment|/* If there's a %E or %4 in the messages, set this to at least 5,    for example.  */
end_comment

begin_define
define|#
directive|define
name|FFEBAD_MAX_
value|6
end_define

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"bad.h"
end_include

begin_include
include|#
directive|include
file|"flags.j"
end_include

begin_include
include|#
directive|include
file|"com.h"
end_include

begin_include
include|#
directive|include
file|"toplev.j"
end_include

begin_include
include|#
directive|include
file|"where.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_decl_stmt
name|bool
name|ffebad_is_inhibited_
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_define
define|#
directive|define
name|FFEBAD_LONG_MSGS_
value|1
end_define

begin_comment
comment|/* 0 to use short (or same) messages. */
end_comment

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_struct
struct|struct
name|_ffebad_message_
block|{
name|ffebadSeverity
name|severity
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Static objects accessed by functions in this module.	 */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|_ffebad_message_
name|ffebad_messages_
index|[]
init|=
block|{
define|#
directive|define
name|FFEBAD_MSGS1
parameter_list|(
name|KWD
parameter_list|,
name|SEV
parameter_list|,
name|MSG
parameter_list|)
value|{ SEV, MSG },
if|#
directive|if
name|FFEBAD_LONG_MSGS_
operator|==
literal|0
define|#
directive|define
name|FFEBAD_MSGS2
parameter_list|(
name|KWD
parameter_list|,
name|SEV
parameter_list|,
name|LMSG
parameter_list|,
name|SMSG
parameter_list|)
value|{ SEV, SMSG },
else|#
directive|else
define|#
directive|define
name|FFEBAD_MSGS2
parameter_list|(
name|KWD
parameter_list|,
name|SEV
parameter_list|,
name|LMSG
parameter_list|,
name|SMSG
parameter_list|)
value|{ SEV, LMSG },
endif|#
directive|endif
include|#
directive|include
file|"bad.def"
undef|#
directive|undef
name|FFEBAD_MSGS1
undef|#
directive|undef
name|FFEBAD_MSGS2
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|ffewhereLine
name|line
decl_stmt|;
name|ffewhereColumn
name|col
decl_stmt|;
name|ffebadIndex
name|tag
decl_stmt|;
block|}
name|ffebad_here_
index|[
name|FFEBAD_MAX_
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ffebad_string_
index|[
name|FFEBAD_MAX_
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffebadIndex
name|ffebad_order_
index|[
name|FFEBAD_MAX_
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffebad
name|ffebad_errnum_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffebadSeverity
name|ffebad_severity_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ffebad_message_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ffebad_index_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffebadIndex
name|ffebad_places_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ffebad_is_temp_inhibited_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Effective setting of 					   _is_inhibited_ for this 					   _start/_finish invocation. */
end_comment

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_function_decl
specifier|static
name|int
name|ffebad_bufputs_
parameter_list|(
name|char
name|buf
index|[]
parameter_list|,
name|int
name|bufi
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Internal macros. */
end_comment

begin_define
define|#
directive|define
name|ffebad_bufflush_
parameter_list|(
name|buf
parameter_list|,
name|bufi
parameter_list|)
define|\
value|(((buf)[bufi] = '\0'), fputs ((buf), stderr), 0)
end_define

begin_define
define|#
directive|define
name|ffebad_bufputc_
parameter_list|(
name|buf
parameter_list|,
name|bufi
parameter_list|,
name|c
parameter_list|)
define|\
value|(((bufi) == ARRAY_SIZE (buf)) \    ? (ffebad_bufflush_ ((buf), (bufi)), ((buf)[0] = (c)), 1) \    : (((buf)[bufi] = (c)), (bufi) + 1))
end_define

begin_escape
end_escape

begin_function
specifier|static
name|int
name|ffebad_bufputs_
parameter_list|(
name|char
name|buf
index|[]
parameter_list|,
name|int
name|bufi
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|s
control|)
name|bufi
operator|=
name|ffebad_bufputc_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
return|return
name|bufi
return|;
block|}
end_function

begin_comment
comment|/* ffebad_init_0 -- Initialize     ffebad_init_0();  */
end_comment

begin_function
name|void
name|ffebad_init_0
parameter_list|()
block|{
name|assert
argument_list|(
name|FFEBAD
operator|==
name|ARRAY_SIZE
argument_list|(
name|ffebad_messages_
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ffebadSeverity
name|ffebad_severity
parameter_list|(
name|ffebad
name|errnum
parameter_list|)
block|{
return|return
name|ffebad_messages_
index|[
name|errnum
index|]
operator|.
name|severity
return|;
block|}
end_function

begin_comment
comment|/* ffebad_start_ -- Start displaying an error message     ffebad_start(FFEBAD_SOME_ERROR_CODE);     Call ffebad_start to establish the message, ffebad_here and ffebad_string    to send run-time data to it as necessary, then ffebad_finish when through    to actually get it to print (to stderr).     Note: ffebad_start(errnum) turns into ffebad_start_(FALSE,errnum).  No    outside caller should call ffebad_start_ directly (as indicated by the    trailing underscore).     Call ffebad_start to start a normal message, one that might be inhibited    by the current state of statement guessing.	Call ffebad_start_lex    instead to start a message that is global to all statement guesses and    happens only once for all guesses (i.e. the lexer).     sev and message are overrides for the severity and messages when errnum    is FFEBAD, meaning the caller didn't want to have to put a message in    bad.def to produce a diagnostic.  */
end_comment

begin_function
name|bool
name|ffebad_start_
parameter_list|(
name|bool
name|lex_override
parameter_list|,
name|ffebad
name|errnum
parameter_list|,
name|ffebadSeverity
name|sev
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|unsigned
name|char
name|i
decl_stmt|;
if|if
condition|(
name|ffebad_is_inhibited_
operator|&&
operator|!
name|lex_override
condition|)
block|{
name|ffebad_is_temp_inhibited_
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|errnum
operator|!=
name|FFEBAD
condition|)
block|{
name|ffebad_severity_
operator|=
name|ffebad_messages_
index|[
name|errnum
index|]
operator|.
name|severity
expr_stmt|;
name|ffebad_message_
operator|=
name|ffebad_messages_
index|[
name|errnum
index|]
operator|.
name|message
expr_stmt|;
block|}
else|else
block|{
name|ffebad_severity_
operator|=
name|sev
expr_stmt|;
name|ffebad_message_
operator|=
name|message
expr_stmt|;
block|}
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
block|{
specifier|extern
name|int
name|inhibit_warnings
decl_stmt|;
comment|/* From toplev.c. */
switch|switch
condition|(
name|ffebad_severity_
condition|)
block|{
comment|/* Tell toplev.c about this message. */
case|case
name|FFEBAD_severityINFORMATIONAL
case|:
case|case
name|FFEBAD_severityTRIVIAL
case|:
if|if
condition|(
name|inhibit_warnings
condition|)
block|{
comment|/* User wants no warnings. */
name|ffebad_is_temp_inhibited_
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Fall through.  */
case|case
name|FFEBAD_severityWARNING
case|:
case|case
name|FFEBAD_severityPECULIAR
case|:
case|case
name|FFEBAD_severityPEDANTIC
case|:
if|if
condition|(
operator|(
name|ffebad_severity_
operator|!=
name|FFEBAD_severityPEDANTIC
operator|)
operator|||
operator|!
name|flag_pedantic_errors
condition|)
block|{
if|if
condition|(
name|count_error
argument_list|(
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* User wants no warnings. */
name|ffebad_is_temp_inhibited_
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
block|}
comment|/* Fall through (PEDANTIC&& flag_pedantic_errors).  */
case|case
name|FFEBAD_severityFATAL
case|:
case|case
name|FFEBAD_severityWEIRD
case|:
case|case
name|FFEBAD_severitySEVERE
case|:
case|case
name|FFEBAD_severityDISASTER
case|:
name|count_error
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* FFECOM_targetCURRENT == FFECOM_targetGCC */
name|ffebad_is_temp_inhibited_
operator|=
name|FALSE
expr_stmt|;
name|ffebad_errnum_
operator|=
name|errnum
expr_stmt|;
name|ffebad_index_
operator|=
literal|0
expr_stmt|;
name|ffebad_places_
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FFEBAD_MAX_
condition|;
operator|++
name|i
control|)
block|{
name|ffebad_string_
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ffebad_here_
index|[
name|i
index|]
operator|.
name|line
operator|=
name|ffewhere_line_unknown
argument_list|()
expr_stmt|;
name|ffebad_here_
index|[
name|i
index|]
operator|.
name|col
operator|=
name|ffewhere_column_unknown
argument_list|()
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ffebad_here -- Establish source location of some diagnostic concern     ffebad_here(ffebadIndex i,ffewhereLine line,ffewhereColumn col);     Call ffebad_start to establish the message, ffebad_here and ffebad_string    to send run-time data to it as necessary, then ffebad_finish when through    to actually get it to print (to stderr).  */
end_comment

begin_function
name|void
name|ffebad_here
parameter_list|(
name|ffebadIndex
name|index
parameter_list|,
name|ffewhereLine
name|line
parameter_list|,
name|ffewhereColumn
name|col
parameter_list|)
block|{
name|ffewhereLineNumber
name|line_num
decl_stmt|;
name|ffewhereLineNumber
name|ln
decl_stmt|;
name|ffewhereColumnNumber
name|col_num
decl_stmt|;
name|ffewhereColumnNumber
name|cn
decl_stmt|;
name|ffebadIndex
name|i
decl_stmt|;
name|ffebadIndex
name|j
decl_stmt|;
if|if
condition|(
name|ffebad_is_temp_inhibited_
condition|)
return|return;
name|assert
argument_list|(
name|index
operator|<
name|FFEBAD_MAX_
argument_list|)
expr_stmt|;
name|ffebad_here_
index|[
name|index
index|]
operator|.
name|line
operator|=
name|ffewhere_line_use
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|ffebad_here_
index|[
name|index
index|]
operator|.
name|col
operator|=
name|ffewhere_column_use
argument_list|(
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffewhere_line_is_unknown
argument_list|(
name|line
argument_list|)
operator|||
name|ffewhere_column_is_unknown
argument_list|(
name|col
argument_list|)
condition|)
block|{
name|ffebad_here_
index|[
name|index
index|]
operator|.
name|tag
operator|=
name|FFEBAD_MAX_
expr_stmt|;
return|return;
block|}
name|ffebad_here_
index|[
name|index
index|]
operator|.
name|tag
operator|=
literal|0
expr_stmt|;
comment|/* For now, though it shouldn't matter. */
comment|/* Sort the source line/col points into the order they occur in the source      file.  Deal with duplicates appropriately. */
name|line_num
operator|=
name|ffewhere_line_number
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|col_num
operator|=
name|ffewhere_column_number
argument_list|(
name|col
argument_list|)
expr_stmt|;
comment|/* Determine where in the ffebad_order_ array this new place should go. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ffebad_places_
condition|;
operator|++
name|i
control|)
block|{
name|ln
operator|=
name|ffewhere_line_number
argument_list|(
name|ffebad_here_
index|[
name|ffebad_order_
index|[
name|i
index|]
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
name|cn
operator|=
name|ffewhere_column_number
argument_list|(
name|ffebad_here_
index|[
name|ffebad_order_
index|[
name|i
index|]
index|]
operator|.
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_num
operator|<
name|ln
condition|)
break|break;
if|if
condition|(
name|line_num
operator|==
name|ln
condition|)
block|{
if|if
condition|(
name|col_num
operator|==
name|cn
condition|)
block|{
name|ffebad_here_
index|[
name|index
index|]
operator|.
name|tag
operator|=
name|i
expr_stmt|;
return|return;
comment|/* Shouldn't go in, has equivalent. */
block|}
elseif|else
if|if
condition|(
name|col_num
operator|<
name|cn
condition|)
break|break;
block|}
block|}
comment|/* Before putting new place in ffebad_order_[i], first increment all tags      that are i or greater. */
if|if
condition|(
name|i
operator|!=
name|ffebad_places_
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FFEBAD_MAX_
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|ffebad_here_
index|[
name|j
index|]
operator|.
name|tag
operator|>=
name|i
condition|)
operator|++
name|ffebad_here_
index|[
name|j
index|]
operator|.
name|tag
expr_stmt|;
block|}
block|}
comment|/* Then slide all ffebad_order_[] entries at and above i up one entry. */
for|for
control|(
name|j
operator|=
name|ffebad_places_
init|;
name|j
operator|>
name|i
condition|;
operator|--
name|j
control|)
name|ffebad_order_
index|[
name|j
index|]
operator|=
name|ffebad_order_
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Finally can put new info in ffebad_order_[i]. */
name|ffebad_order_
index|[
name|i
index|]
operator|=
name|index
expr_stmt|;
name|ffebad_here_
index|[
name|index
index|]
operator|.
name|tag
operator|=
name|i
expr_stmt|;
operator|++
name|ffebad_places_
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Establish string for next index (always in order) of message     ffebad_string(const char *string);     Call ffebad_start to establish the message, ffebad_here and ffebad_string    to send run-time data to it as necessary, then ffebad_finish when through    to actually get it to print (to stderr).  Note: don't trash the string    until after calling ffebad_finish, since we just maintain a pointer to    the argument passed in until then.  */
end_comment

begin_function
name|void
name|ffebad_string
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
if|if
condition|(
name|ffebad_is_temp_inhibited_
condition|)
return|return;
name|assert
argument_list|(
name|ffebad_index_
operator|!=
name|FFEBAD_MAX_
argument_list|)
expr_stmt|;
name|ffebad_string_
index|[
name|ffebad_index_
operator|++
index|]
operator|=
name|string
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffebad_finish -- Display error message with where& run-time info     ffebad_finish();     Call ffebad_start to establish the message, ffebad_here and ffebad_string    to send run-time data to it as necessary, then ffebad_finish when through    to actually get it to print (to stderr).  */
end_comment

begin_function
name|void
name|ffebad_finish
parameter_list|()
block|{
define|#
directive|define
name|MAX_SPACES
value|132
specifier|static
specifier|const
name|char
modifier|*
name|spaces
init|=
literal|"...>\ \040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\ \040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\ \040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\ \040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\ \040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\ \040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\ \040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\ \040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\ \040\040\040"
decl_stmt|;
comment|/* MAX_SPACES - 1 spaces. */
name|ffewhereLineNumber
name|last_line_num
decl_stmt|;
name|ffewhereLineNumber
name|ln
decl_stmt|;
name|ffewhereLineNumber
name|rn
decl_stmt|;
name|ffewhereColumnNumber
name|last_col_num
decl_stmt|;
name|ffewhereColumnNumber
name|cn
decl_stmt|;
name|ffewhereColumnNumber
name|cnt
decl_stmt|;
name|ffewhereLine
name|l
decl_stmt|;
name|ffebadIndex
name|bi
decl_stmt|;
name|unsigned
name|short
name|i
decl_stmt|;
name|char
name|pointer
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|fn
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|bufi
decl_stmt|;
name|int
name|index
decl_stmt|;
if|if
condition|(
name|ffebad_is_temp_inhibited_
condition|)
return|return;
switch|switch
condition|(
name|ffebad_severity_
condition|)
block|{
case|case
name|FFEBAD_severityINFORMATIONAL
case|:
name|s
operator|=
literal|"note:"
expr_stmt|;
break|break;
case|case
name|FFEBAD_severityWARNING
case|:
name|s
operator|=
literal|"warning:"
expr_stmt|;
break|break;
case|case
name|FFEBAD_severitySEVERE
case|:
name|s
operator|=
literal|"fatal:"
expr_stmt|;
break|break;
default|default:
name|s
operator|=
literal|""
expr_stmt|;
break|break;
block|}
comment|/* Display the annoying source references. */
name|last_line_num
operator|=
literal|0
expr_stmt|;
name|last_col_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bi
operator|=
literal|0
init|;
name|bi
operator|<
name|ffebad_places_
condition|;
operator|++
name|bi
control|)
block|{
if|if
condition|(
name|ffebad_places_
operator|==
literal|1
condition|)
name|pointer
operator|=
literal|'^'
expr_stmt|;
else|else
name|pointer
operator|=
literal|'1'
operator|+
name|bi
expr_stmt|;
name|l
operator|=
name|ffebad_here_
index|[
name|ffebad_order_
index|[
name|bi
index|]
index|]
operator|.
name|line
expr_stmt|;
name|ln
operator|=
name|ffewhere_line_number
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|rn
operator|=
name|ffewhere_line_filelinenum
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|cn
operator|=
name|ffewhere_column_number
argument_list|(
name|ffebad_here_
index|[
name|ffebad_order_
index|[
name|bi
index|]
index|]
operator|.
name|col
argument_list|)
expr_stmt|;
name|fn
operator|=
name|ffewhere_line_filename
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|last_line_num
condition|)
block|{
if|if
condition|(
name|bi
operator|!=
literal|0
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetGCC
name|report_error_function
argument_list|(
name|fn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FFECOM_targetCURRENT == FFECOM_targetGCC */
name|fprintf
argument_list|(
name|stderr
argument_list|,
if|#
directive|if
literal|0
argument_list|"Line %" ffewhereLineNumber_f "u of %s:\n   %s\n   %s%c", 		   rn, fn,
else|#
directive|else
comment|/* the trailing space on the<file>:<line>: line 		      fools emacs19 compilation mode into finding the 		      report */
literal|"%s:%"
name|ffewhereLineNumber_f
literal|"u: %s\n   %s\n   %s%c"
argument_list|,
name|fn
argument_list|,
name|rn
argument_list|,
endif|#
directive|endif
name|s
argument_list|,
name|ffewhere_line_content
argument_list|(
name|l
argument_list|)
argument_list|,
operator|&
name|spaces
index|[
name|cn
operator|>
name|MAX_SPACES
condition|?
literal|0
else|:
name|MAX_SPACES
operator|-
name|cn
operator|+
literal|4
index|]
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
name|last_line_num
operator|=
name|ln
expr_stmt|;
name|last_col_num
operator|=
name|cn
expr_stmt|;
name|s
operator|=
literal|"(continued):"
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|=
name|cn
operator|-
name|last_col_num
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%c"
argument_list|,
operator|&
name|spaces
index|[
name|cnt
operator|>
name|MAX_SPACES
condition|?
literal|0
else|:
name|MAX_SPACES
operator|-
name|cnt
operator|+
literal|4
index|]
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
name|last_col_num
operator|=
name|cn
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ffebad_places_
operator|==
literal|0
condition|)
block|{
comment|/* Didn't output "warning:" string, capitalize it for message.  */
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
operator|&&
name|ISALPHA
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
operator|&&
name|ISLOWER
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|char
name|c
decl_stmt|;
name|c
operator|=
name|toupper
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c%s "
argument_list|,
name|c
argument_list|,
operator|&
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* Release the ffewhere info. */
for|for
control|(
name|bi
operator|=
literal|0
init|;
name|bi
operator|<
name|FFEBAD_MAX_
condition|;
operator|++
name|bi
control|)
block|{
name|ffewhere_line_kill
argument_list|(
name|ffebad_here_
index|[
name|bi
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|ffebad_here_
index|[
name|bi
index|]
operator|.
name|col
argument_list|)
expr_stmt|;
block|}
comment|/* Now display the message. */
name|bufi
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|ffebad_message_
index|[
name|i
index|]
operator|)
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
name|c
operator|=
name|ffebad_message_
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
operator|&&
name|ISUPPER
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|index
operator|=
name|c
operator|-
literal|'A'
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|FFEBAD_MAX_
operator|)
condition|)
block|{
name|bufi
operator|=
name|ffebad_bufputs_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
literal|"[REPORT BUG!!] %"
argument_list|)
expr_stmt|;
name|bufi
operator|=
name|ffebad_bufputc_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|ffebad_string_
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|bufi
operator|=
name|ffebad_bufputs_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
literal|"[REPORT BUG!!]"
argument_list|)
expr_stmt|;
else|else
name|bufi
operator|=
name|ffebad_bufputs_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|index
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|FFEBAD_MAX_
operator|)
condition|)
block|{
name|bufi
operator|=
name|ffebad_bufputs_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
literal|"[REPORT BUG!!] %"
argument_list|)
expr_stmt|;
name|bufi
operator|=
name|ffebad_bufputc_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pointer
operator|=
name|ffebad_here_
index|[
name|index
index|]
operator|.
name|tag
operator|+
literal|'1'
expr_stmt|;
if|if
condition|(
name|pointer
operator|==
name|FFEBAD_MAX_
operator|+
literal|'1'
condition|)
name|pointer
operator|=
literal|'?'
expr_stmt|;
elseif|else
if|if
condition|(
name|ffebad_places_
operator|==
literal|1
condition|)
name|pointer
operator|=
literal|'^'
expr_stmt|;
name|bufi
operator|=
name|ffebad_bufputc_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|bufi
operator|=
name|ffebad_bufputc_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
name|bufi
operator|=
name|ffebad_bufputc_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
name|bufi
operator|=
name|ffebad_bufputc_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
else|else
block|{
name|bufi
operator|=
name|ffebad_bufputs_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
literal|"[REPORT BUG!!]"
argument_list|)
expr_stmt|;
name|bufi
operator|=
name|ffebad_bufputc_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
name|bufi
operator|=
name|ffebad_bufputc_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|bufi
operator|=
name|ffebad_bufputc_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|bufi
operator|=
name|ffebad_bufputc_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|bufi
operator|=
name|ffebad_bufflush_
argument_list|(
name|buf
argument_list|,
name|bufi
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

