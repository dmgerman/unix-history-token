begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* stw.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       None (despite the name, it doesn't really depend on ffest*)     Description:       Provides abstraction and stack mechanism to track the block structure       of a Fortran program.     Modifications: */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"stw.h"
end_include

begin_include
include|#
directive|include
file|"bld.h"
end_include

begin_include
include|#
directive|include
file|"com.h"
end_include

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"lab.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"sta.h"
end_include

begin_include
include|#
directive|include
file|"stv.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_include
include|#
directive|include
file|"where.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_decl_stmt
name|ffestw
name|ffestw_stack_top_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_comment
comment|/* Internal macros. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* ffestw_display_state -- DEBUGGING; display current block state     ffestw_display_state();  */
end_comment

begin_function
name|void
name|ffestw_display_state
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|ffestw_stack_top_
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffe_is_ffedebug
argument_list|()
condition|)
return|return;
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"; block %lu, state "
argument_list|,
name|ffestw_stack_top_
operator|->
name|blocknum_
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffestw_stack_top_
operator|->
name|state_
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|fputs
argument_list|(
literal|"NIL"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_statePROGRAM0
case|:
name|fputs
argument_list|(
literal|"PROGRAM0"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_statePROGRAM1
case|:
name|fputs
argument_list|(
literal|"PROGRAM1"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_statePROGRAM2
case|:
name|fputs
argument_list|(
literal|"PROGRAM2"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_statePROGRAM3
case|:
name|fputs
argument_list|(
literal|"PROGRAM3"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_statePROGRAM4
case|:
name|fputs
argument_list|(
literal|"PROGRAM4"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_statePROGRAM5
case|:
name|fputs
argument_list|(
literal|"PROGRAM5"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
name|fputs
argument_list|(
literal|"SUBROUTINE0"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSUBROUTINE1
case|:
name|fputs
argument_list|(
literal|"SUBROUTINE1"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSUBROUTINE2
case|:
name|fputs
argument_list|(
literal|"SUBROUTINE2"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSUBROUTINE3
case|:
name|fputs
argument_list|(
literal|"SUBROUTINE3"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSUBROUTINE4
case|:
name|fputs
argument_list|(
literal|"SUBROUTINE4"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSUBROUTINE5
case|:
name|fputs
argument_list|(
literal|"SUBROUTINE5"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateFUNCTION0
case|:
name|fputs
argument_list|(
literal|"FUNCTION0"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateFUNCTION1
case|:
name|fputs
argument_list|(
literal|"FUNCTION1"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateFUNCTION2
case|:
name|fputs
argument_list|(
literal|"FUNCTION2"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateFUNCTION3
case|:
name|fputs
argument_list|(
literal|"FUNCTION3"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateFUNCTION4
case|:
name|fputs
argument_list|(
literal|"FUNCTION4"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateFUNCTION5
case|:
name|fputs
argument_list|(
literal|"FUNCTION5"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateMODULE0
case|:
name|fputs
argument_list|(
literal|"MODULE0"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateMODULE1
case|:
name|fputs
argument_list|(
literal|"MODULE1"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateMODULE2
case|:
name|fputs
argument_list|(
literal|"MODULE2"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateMODULE3
case|:
name|fputs
argument_list|(
literal|"MODULE3"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateMODULE4
case|:
name|fputs
argument_list|(
literal|"MODULE4"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateMODULE5
case|:
name|fputs
argument_list|(
literal|"MODULE5"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateBLOCKDATA0
case|:
name|fputs
argument_list|(
literal|"BLOCKDATA0"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateBLOCKDATA1
case|:
name|fputs
argument_list|(
literal|"BLOCKDATA1"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateBLOCKDATA2
case|:
name|fputs
argument_list|(
literal|"BLOCKDATA2"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateBLOCKDATA3
case|:
name|fputs
argument_list|(
literal|"BLOCKDATA3"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateBLOCKDATA4
case|:
name|fputs
argument_list|(
literal|"BLOCKDATA4"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateBLOCKDATA5
case|:
name|fputs
argument_list|(
literal|"BLOCKDATA5"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateUSE
case|:
name|fputs
argument_list|(
literal|"USE"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateTYPE
case|:
name|fputs
argument_list|(
literal|"TYPE"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateINTERFACE0
case|:
name|fputs
argument_list|(
literal|"INTERFACE0"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateINTERFACE1
case|:
name|fputs
argument_list|(
literal|"INTERFACE1"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSTRUCTURE
case|:
name|fputs
argument_list|(
literal|"STRUCTURE"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateUNION
case|:
name|fputs
argument_list|(
literal|"UNION"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateMAP
case|:
name|fputs
argument_list|(
literal|"MAP"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateWHERETHEN
case|:
name|fputs
argument_list|(
literal|"WHERETHEN"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateWHERE
case|:
name|fputs
argument_list|(
literal|"WHERE"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateIFTHEN
case|:
name|fputs
argument_list|(
literal|"IFTHEN"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateIF
case|:
name|fputs
argument_list|(
literal|"IF"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateDO
case|:
name|fputs
argument_list|(
literal|"DO"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSELECT0
case|:
name|fputs
argument_list|(
literal|"SELECT0"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSELECT1
case|:
name|fputs
argument_list|(
literal|"SELECT1"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad state"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffestw_stack_top_
operator|->
name|top_do_
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
literal|" (within DO)"
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestw_init_0 -- Initialize ffestw structures     ffestw_init_0();  */
end_comment

begin_function
name|void
name|ffestw_init_0
parameter_list|()
block|{
name|ffestw
name|b
decl_stmt|;
name|ffestw_stack_top_
operator|=
name|b
operator|=
operator|(
name|ffestw
operator|)
name|malloc_new_kp
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFESTW stack base"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|uses_
operator|=
literal|0
expr_stmt|;
comment|/* catch if anyone uses, kills,&c this 				   block. */
name|b
operator|->
name|next_
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|previous_
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|top_do_
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|blocknum_
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|shriek_
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|state_
operator|=
name|FFESTV_stateNIL
expr_stmt|;
name|b
operator|->
name|line_
operator|=
name|ffewhere_line_unknown
argument_list|()
expr_stmt|;
name|b
operator|->
name|col_
operator|=
name|ffewhere_column_unknown
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestw_kill -- Kill block     ffestw b;    ffestw_kill(b);  */
end_comment

begin_function
name|void
name|ffestw_kill
parameter_list|(
name|ffestw
name|b
parameter_list|)
block|{
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|->
name|uses_
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|b
operator|->
name|uses_
operator|!=
literal|0
condition|)
return|return;
name|ffewhere_line_kill
argument_list|(
name|b
operator|->
name|line_
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|b
operator|->
name|col_
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestw_new -- Create block     ffestw b;    b = ffestw_new();  */
end_comment

begin_function
name|ffestw
name|ffestw_new
parameter_list|(
name|void
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|b
operator|=
operator|(
name|ffestw
operator|)
name|malloc_new_kp
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFESTW"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|uses_
operator|=
literal|1
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* ffestw_pop -- Pop block off stack     ffestw_pop();  */
end_comment

begin_function
name|ffestw
name|ffestw_pop
parameter_list|(
name|void
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffestw
name|oldb
init|=
name|ffestw_stack_top_
decl_stmt|;
name|assert
argument_list|(
name|oldb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_stack_top_
operator|=
name|b
operator|=
name|ffestw_stack_top_
operator|->
name|previous_
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffewhere_line_is_unknown
argument_list|(
name|b
operator|->
name|line_
argument_list|)
operator|||
name|ffewhere_column_is_unknown
argument_list|(
name|b
operator|->
name|col_
argument_list|)
operator|)
operator|&&
operator|(
name|ffesta_tokens
index|[
literal|0
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|assert
argument_list|(
name|b
operator|->
name|state_
operator|==
name|FFESTV_stateNIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffewhere_line_is_unknown
argument_list|(
name|b
operator|->
name|line_
argument_list|)
condition|)
name|b
operator|->
name|line_
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffewhere_column_is_unknown
argument_list|(
name|b
operator|->
name|col_
argument_list|)
condition|)
name|b
operator|->
name|col_
operator|=
name|ffewhere_column_use
argument_list|(
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|oldb
return|;
block|}
end_function

begin_comment
comment|/* ffestw_push -- Push block onto stack, return its address     ffestw b;  // NULL if new block to be obtained first.    ffestw_push(b);     Returns address of block if desired, also updates ffestw_stack_top_    to point to it.     30-Oct-91  JCB  2.0       Takes block as arg, or NULL if new block needed.	*/
end_comment

begin_function
name|ffestw
name|ffestw_push
parameter_list|(
name|ffestw
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
name|b
operator|=
name|ffestw_new
argument_list|()
expr_stmt|;
name|b
operator|->
name|next_
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|previous_
operator|=
name|ffestw_stack_top_
expr_stmt|;
name|b
operator|->
name|line_
operator|=
name|ffewhere_line_unknown
argument_list|()
expr_stmt|;
name|b
operator|->
name|col_
operator|=
name|ffewhere_column_unknown
argument_list|()
expr_stmt|;
name|ffestw_stack_top_
operator|=
name|b
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* ffestw_update -- Update current block line/col info     ffestw_update();     Updates block to point to current statement.	 */
end_comment

begin_function
name|ffestw
name|ffestw_update
parameter_list|(
name|ffestw
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|b
operator|=
name|ffestw_stack_top_
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffesta_tokens
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
return|return
name|b
return|;
name|ffewhere_line_kill
argument_list|(
name|b
operator|->
name|line_
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|b
operator|->
name|col_
argument_list|)
expr_stmt|;
name|b
operator|->
name|line_
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|col_
operator|=
name|ffewhere_column_use
argument_list|(
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* ffestw_use -- Mark extra use of block     ffestw b;    b = ffestw_use(b);  // will always return original copy of b     Increments use counter for b.  */
end_comment

begin_function
name|ffestw
name|ffestw_use
parameter_list|(
name|ffestw
name|b
parameter_list|)
block|{
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|->
name|uses_
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|++
name|b
operator|->
name|uses_
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

end_unit

