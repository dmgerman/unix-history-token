begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* stu.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"bld.h"
end_include

begin_include
include|#
directive|include
file|"com.h"
end_include

begin_include
include|#
directive|include
file|"equiv.h"
end_include

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"implic.h"
end_include

begin_include
include|#
directive|include
file|"intrin.h"
end_include

begin_include
include|#
directive|include
file|"stu.h"
end_include

begin_include
include|#
directive|include
file|"storag.h"
end_include

begin_include
include|#
directive|include
file|"sta.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_function_decl
specifier|static
name|void
name|ffestu_list_exec_transition_
parameter_list|(
name|ffebld
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffestu_symter_end_transition_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffestu_symter_exec_transition_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffestu_dummies_transition_
parameter_list|(
name|ffesymbol
function_decl|(
modifier|*
name|symfunc
function_decl|)
parameter_list|(
name|ffesymbol
parameter_list|)
parameter_list|,
name|ffebld
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Internal macros. */
end_comment

begin_define
define|#
directive|define
name|ffestu_equiv_
parameter_list|(
name|s
parameter_list|)
value|(((ffesymbol_equiv (s) == NULL)		      \   || (ffeequiv_common (ffesymbol_equiv (s)) == NULL)) ? FFEINFO_whereLOCAL    \   : FFEINFO_whereCOMMON)
end_define

begin_escape
end_escape

begin_comment
comment|/* Update symbol info just before end of unit.  */
end_comment

begin_function
name|ffesymbol
name|ffestu_sym_end_transition
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|ffeinfoKind
name|skd
decl_stmt|;
name|ffeinfoWhere
name|swh
decl_stmt|;
name|ffeinfoKind
name|nkd
decl_stmt|;
name|ffeinfoWhere
name|nwh
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffesymbolState
name|ss
decl_stmt|;
name|ffesymbolState
name|ns
decl_stmt|;
name|bool
name|needs_type
init|=
name|TRUE
decl_stmt|;
comment|/* Implicit type assignment might be 				   necessary. */
name|assert
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ss
operator|=
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|skd
operator|=
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|swh
operator|=
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ss
condition|)
block|{
case|case
name|FFESYMBOL_stateUNCERTAIN
case|:
if|if
condition|(
operator|(
name|swh
operator|==
name|FFEINFO_whereDUMMY
operator|)
operator|&&
operator|(
name|ffesymbol_numentries
argument_list|(
name|s
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Not actually in any dummy list! */
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|swh
operator|==
name|FFEINFO_whereLOCAL
operator|)
operator|||
operator|(
name|swh
operator|==
name|FFEINFO_whereNONE
operator|)
operator|)
operator|&&
operator|(
name|skd
operator|==
name|FFEINFO_kindENTITY
operator|)
operator|&&
name|ffestu_symter_end_transition_
argument_list|(
name|ffesymbol_dims
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Bad dimension expressions. */
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
break|break;
case|case
name|FFESYMBOL_stateUNDERSTOOD
case|:
if|if
condition|(
operator|(
name|swh
operator|==
name|FFEINFO_whereLOCAL
operator|)
operator|&&
operator|(
operator|(
name|skd
operator|==
name|FFEINFO_kindFUNCTION
operator|)
operator|||
operator|(
name|skd
operator|==
name|FFEINFO_kindSUBROUTINE
operator|)
operator|)
condition|)
block|{
name|int
name|n_args
decl_stmt|;
name|ffebld
name|list
decl_stmt|;
name|ffebld
name|item
decl_stmt|;
name|ffeglobalArgSummary
name|as
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|bool
name|array
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|ffestu_dummies_transition_
argument_list|(
name|ffecom_sym_end_transition
argument_list|,
name|ffesymbol_dummyargs
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|n_args
operator|=
name|ffebld_list_length
argument_list|(
name|ffesymbol_dummyargs
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffeglobal_proc_def_nargs
argument_list|(
name|s
argument_list|,
name|n_args
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|ffesymbol_dummyargs
argument_list|(
name|s
argument_list|)
operator|,
name|n_args
operator|=
literal|0
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
operator|,
operator|++
name|n_args
control|)
block|{
name|item
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|array
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
block|{
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|array
operator|=
operator|(
name|ffeinfo_rank
argument_list|(
name|ffebld_info
argument_list|(
name|item
argument_list|)
argument_list|)
operator|>
literal|0
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|item
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opSTAR
case|:
name|as
operator|=
name|FFEGLOBAL_argsummaryALTRTN
expr_stmt|;
break|break;
case|case
name|FFEBLD_opSYMTER
case|:
name|name
operator|=
name|ffesymbol_text
argument_list|(
name|ffebld_symter
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|as
operator|=
name|FFEGLOBAL_argsummaryNONE
expr_stmt|;
switch|switch
condition|(
name|ffeinfo_kind
argument_list|(
name|ffebld_info
argument_list|(
name|item
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_kindFUNCTION
case|:
name|as
operator|=
name|FFEGLOBAL_argsummaryFUNC
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindSUBROUTINE
case|:
name|as
operator|=
name|FFEGLOBAL_argsummarySUBR
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindNONE
case|:
name|as
operator|=
name|FFEGLOBAL_argsummaryPROC
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|as
operator|!=
name|FFEGLOBAL_argsummaryNONE
condition|)
break|break;
comment|/* Fall through.  */
default|default:
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
name|as
operator|=
name|FFEGLOBAL_argsummaryDESCR
expr_stmt|;
else|else
name|as
operator|=
name|FFEGLOBAL_argsummaryREF
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|as
operator|=
name|FFEGLOBAL_argsummaryNONE
expr_stmt|;
name|bt
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
name|kt
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
block|}
name|ffeglobal_proc_def_arg
argument_list|(
name|s
argument_list|,
name|n_args
argument_list|,
name|name
argument_list|,
name|as
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|,
name|array
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|swh
operator|==
name|FFEINFO_whereDUMMY
condition|)
block|{
if|if
condition|(
name|ffesymbol_numentries
argument_list|(
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Not actually in any dummy list! */
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
name|ffestu_symter_end_transition_
argument_list|(
name|ffesymbol_dims
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Bad dimension expressions. */
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|swh
operator|==
name|FFEINFO_whereLOCAL
operator|)
operator|&&
name|ffestu_symter_end_transition_
argument_list|(
name|ffesymbol_dims
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Bad dimension expressions. */
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|ffestorag_end_layout
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
return|return
name|s
return|;
default|default:
name|assert
argument_list|(
literal|"bad status"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|ns
operator|=
name|FFESYMBOL_stateUNDERSTOOD
expr_stmt|;
name|na
operator|=
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|nkd
operator|=
name|skd
expr_stmt|;
name|nwh
operator|=
name|swh
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
name|nwh
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
else|else
comment|/* Not TYPE. */
block|{
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
block|{
comment|/* Not TYPE. */
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
comment|/* FUNCTION/SUBROUTINE. */
name|needs_type
operator|=
name|FALSE
expr_stmt|;
comment|/* Don't assign type to SUBROUTINE! */
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsACTUALARG
condition|)
block|{
comment|/* Not DUMMY or TYPE. */
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
comment|/* FUNCTION/SUBROUTINE. */
name|needs_type
operator|=
name|FALSE
expr_stmt|;
comment|/* Don't assign type to SUBROUTINE! */
block|}
else|else
comment|/* Not ACTUALARG, DUMMY, or TYPE. */
block|{
comment|/* This is an assumption, essentially. */
name|nkd
operator|=
name|FFEINFO_kindBLOCKDATA
expr_stmt|;
name|nwh
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
name|needs_type
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Honestly, this appears to be a guess.  I can't find anyplace in the 	 standard that makes clear whether this unreferenced dummy argument 	 is an ENTITY or a FUNCTION.  And yet, for the f2c interface, picking 	 one is critical for CHARACTER entities because it determines whether 	 to expect an additional argument specifying the length of an ENTITY 	 that is not expected (or needed) for a FUNCTION.  HOWEVER, F90 makes 	 this guess a correct one, and it does seem that the Section 18 Notes 	 in Appendix B of F77 make it clear the F77 standard at least 	 intended to make this guess correct as well, so this seems ok.  */
name|nkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsARRAY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestu_symter_end_transition_
argument_list|(
name|ffesymbol_dims
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsADJUSTABLE
condition|)
block|{
comment|/* Not actually in any dummy list! */
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
operator|&&
name|ffebad_start_msg
argument_list|(
literal|"Local adjustable symbol `%A' at %0"
argument_list|,
name|FFEBAD_severityPEDANTIC
argument_list|)
condition|)
block|{
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffesymbol_where_line
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where_column
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|nwh
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsSFARG
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|nwh
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsTYPE
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANYLEN
condition|)
block|{
comment|/* Can't touch this. */
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffestorag_end_layout
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
return|return
name|s
return|;
block|}
name|nkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|nwh
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
else|else
name|assert
argument_list|(
literal|"unexpected attribute set"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
comment|/* Establish new info. */
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|ns
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
name|nkd
argument_list|,
name|nwh
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_type
operator|&&
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|s
argument_list|)
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffestorag_end_layout
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* ffestu_sym_exec_transition -- Update symbol just before first exec stmt     ffesymbol s;    ffestu_sym_exec_transition(s);  */
end_comment

begin_function
name|ffesymbol
name|ffestu_sym_exec_transition
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|ffeinfoKind
name|skd
decl_stmt|;
name|ffeinfoWhere
name|swh
decl_stmt|;
name|ffeinfoKind
name|nkd
decl_stmt|;
name|ffeinfoWhere
name|nwh
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffesymbolState
name|ss
decl_stmt|;
name|ffesymbolState
name|ns
decl_stmt|;
name|ffeintrinGen
name|gen
decl_stmt|;
name|ffeintrinSpec
name|spec
decl_stmt|;
name|ffeintrinImp
name|imp
decl_stmt|;
name|bool
name|needs_type
init|=
name|TRUE
decl_stmt|;
comment|/* Implicit type assignment might be 				   necessary. */
name|bool
name|resolve_intrin
init|=
name|TRUE
decl_stmt|;
comment|/* Might need to resolve intrinsic. */
name|assert
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|skd
operator|=
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|swh
operator|=
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ss
operator|=
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ss
condition|)
block|{
case|case
name|FFESYMBOL_stateNONE
case|:
return|return
name|s
return|;
comment|/* Assume caller will handle it. */
case|case
name|FFESYMBOL_stateSEEN
case|:
break|break;
case|case
name|FFESYMBOL_stateUNCERTAIN
case|:
name|ffestorag_exec_layout
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
comment|/* Already processed this one, or not 				   necessary. */
case|case
name|FFESYMBOL_stateUNDERSTOOD
case|:
if|if
condition|(
name|skd
operator|==
name|FFEINFO_kindNAMELIST
condition|)
block|{
name|ffebld_end_list
argument_list|(
name|ffesymbol_ptr_to_listbottom
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffestu_list_exec_transition_
argument_list|(
name|ffesymbol_namelist
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|swh
operator|==
name|FFEINFO_whereLOCAL
operator|)
operator|&&
operator|(
operator|(
name|skd
operator|==
name|FFEINFO_kindFUNCTION
operator|)
operator|||
operator|(
name|skd
operator|==
name|FFEINFO_kindSUBROUTINE
operator|)
operator|)
condition|)
block|{
name|ffestu_dummies_transition_
argument_list|(
name|ffecom_sym_exec_transition
argument_list|,
name|ffesymbol_dummyargs
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|skd
operator|==
name|FFEINFO_kindFUNCTION
operator|)
operator|&&
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|s
argument_list|)
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffestorag_exec_layout
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
return|return
name|s
return|;
default|default:
name|assert
argument_list|(
literal|"bad status"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|ns
operator|=
name|FFESYMBOL_stateUNDERSTOOD
expr_stmt|;
comment|/* Only a few UNCERTAIN exceptions. */
name|na
operator|=
name|sa
expr_stmt|;
name|nkd
operator|=
name|skd
expr_stmt|;
name|nwh
operator|=
name|swh
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsCOMMON
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|nkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|nwh
operator|=
name|FFEINFO_whereCOMMON
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsRESULT
condition|)
block|{
comment|/* Result variable for function. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsRESULT
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|nkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|nwh
operator|=
name|FFEINFO_whereRESULT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsSFUNC
condition|)
block|{
comment|/* Statement function. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsSFUNC
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|nkd
operator|=
name|FFEINFO_kindFUNCTION
expr_stmt|;
name|nwh
operator|=
name|FFEINFO_whereCONSTANT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
block|{
name|nkd
operator|=
name|FFEINFO_kindFUNCTION
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
name|nwh
operator|=
name|FFEINFO_whereDUMMY
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ffesta_is_entry_valid
condition|)
block|{
name|nwh
operator|=
name|FFEINFO_whereNONE
expr_stmt|;
comment|/* DUMMY, GLOBAL. */
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
block|}
else|else
name|nwh
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
block|}
block|}
else|else
comment|/* No TYPE. */
block|{
name|nkd
operator|=
name|FFEINFO_kindNONE
expr_stmt|;
comment|/* FUNCTION, SUBROUTINE, BLOCKDATA. */
name|needs_type
operator|=
name|FALSE
expr_stmt|;
comment|/* Only gets type if FUNCTION. */
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
name|nwh
operator|=
name|FFEINFO_whereDUMMY
expr_stmt|;
comment|/* Not BLOCKDATA. */
else|else
block|{
if|if
condition|(
name|ffesta_is_entry_valid
condition|)
name|nwh
operator|=
name|FFEINFO_whereNONE
expr_stmt|;
comment|/* DUMMY, GLOBAL. */
else|else
name|nwh
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTABLE
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsADJUSTS
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsANYLEN
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsANYSIZE
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsARRAY
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsDUMMY
comment|/* Have it. */
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Possible. */
name|nwh
operator|=
name|FFEINFO_whereDUMMY
expr_stmt|;
if|if
condition|(
name|ffestu_symter_exec_transition_
argument_list|(
name|ffesymbol_dims
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
if|if
condition|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsSFARG
operator|)
condition|)
name|nkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
comment|/* Still okay. */
block|{
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
operator|)
condition|)
name|needs_type
operator|=
name|FALSE
expr_stmt|;
comment|/* Don't assign type to SUBROUTINE! */
name|nkd
operator|=
name|FFEINFO_kindNONE
expr_stmt|;
comment|/* ENTITY, FUNCTION, SUBROUTINE. */
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsADJUSTS
condition|)
block|{
comment|/* Must be DUMMY or COMMON at some point. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsDUMMY
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTS
comment|/* Have it. */
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEQUIV
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsINIT
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsNAMELIST
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsSFARG
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Possible. */
name|nkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsEQUIV
condition|)
block|{
if|if
condition|(
operator|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeequiv_common
argument_list|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Not equiv'd into COMMON. */
else|else
name|nwh
operator|=
name|FFEINFO_whereCOMMON
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ffesta_is_entry_valid
operator|||
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator|)
operator|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
else|else
name|nwh
operator|=
name|FFEINFO_whereDUMMY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsSAVE
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsSAVE
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|nkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|nwh
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsEQUIV
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsCOMMON
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTS
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsARRAY
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsEQUIV
comment|/* Have it. */
operator||
name|FFESYMBOL_attrsINIT
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsNAMELIST
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsSAVE
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsSFARG
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Possible. */
name|nkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|nwh
operator|=
name|ffestu_equiv_
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsNAMELIST
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsSAVE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsARRAY
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsNAMELIST
comment|/* Have it. */
operator||
name|FFESYMBOL_attrsSAVE
operator||
name|FFESYMBOL_attrsSFARG
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Possible. */
name|nkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|nwh
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsINIT
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsSAVE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsARRAY
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
comment|/* Have it. */
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsSAVE
operator||
name|FFESYMBOL_attrsSFARG
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Possible. */
name|nkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|nwh
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsSFARG
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsRESULT
operator||
name|FFESYMBOL_attrsSAVE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsRESULT
operator||
name|FFESYMBOL_attrsSAVE
operator||
name|FFESYMBOL_attrsSFARG
comment|/* Have it. */
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Possible. */
name|nkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
if|if
condition|(
name|ffesta_is_entry_valid
condition|)
block|{
name|nwh
operator|=
name|FFEINFO_whereNONE
expr_stmt|;
comment|/* DUMMY, LOCAL. */
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
block|}
else|else
name|nwh
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYSIZE
operator|)
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsANYSIZE
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|nkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
if|if
condition|(
name|ffestu_symter_exec_transition_
argument_list|(
name|ffesymbol_dims
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
if|if
condition|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsANYSIZE
operator|)
condition|)
name|nwh
operator|=
name|FFEINFO_whereDUMMY
expr_stmt|;
elseif|else
if|if
condition|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYSIZE
operator|)
condition|)
comment|/* Still okay.  */
block|{
name|nwh
operator|=
name|FFEINFO_whereNONE
expr_stmt|;
comment|/* DUMMY, LOCAL. */
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsARRAY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYSIZE
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsSAVE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
comment|/* Possible. */
operator||
name|FFESYMBOL_attrsANYSIZE
operator||
name|FFESYMBOL_attrsARRAY
comment|/* Have it. */
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsSAVE
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Possible. */
name|nkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANYLEN
condition|)
block|{
name|assert
argument_list|(
name|ffesta_is_entry_valid
argument_list|)
expr_stmt|;
comment|/* Already diagnosed. */
name|nwh
operator|=
name|FFEINFO_whereDUMMY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ffesta_is_entry_valid
condition|)
block|{
name|nwh
operator|=
name|FFEINFO_whereNONE
expr_stmt|;
comment|/* DUMMY, LOCAL. */
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
block|}
else|else
name|nwh
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANYLEN
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYSIZE
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsRESULT
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
comment|/* Have it. */
operator||
name|FFESYMBOL_attrsANYSIZE
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsRESULT
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Have it too. */
if|if
condition|(
name|ffesta_is_entry_valid
condition|)
block|{
name|nkd
operator|=
name|FFEINFO_kindNONE
expr_stmt|;
comment|/* ENTITY, FUNCTION. */
name|nwh
operator|=
name|FFEINFO_whereNONE
expr_stmt|;
comment|/* DUMMY, INTRINSIC, RESULT. */
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
name|resolve_intrin
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffeintrin_is_intrinsic
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
operator|&
name|gen
argument_list|,
operator|&
name|spec
argument_list|,
operator|&
name|imp
argument_list|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_set_generic
argument_list|(
name|s
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|ffesymbol_set_specific
argument_list|(
name|s
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|ffesymbol_set_implementation
argument_list|(
name|s
argument_list|,
name|imp
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindNONE
argument_list|,
name|FFEINFO_whereINTRINSIC
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffestorag_exec_layout
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
return|return
name|s
return|;
block|}
else|else
block|{
comment|/* SPECIAL: can't have CHAR*(*) var in 				   PROGRAM/BLOCKDATA, unless it isn't 				   referenced anywhere in the code. */
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Can't touch this. */
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffestorag_exec_layout
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
return|return
name|s
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsANYSIZE
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsRESULT
operator||
name|FFESYMBOL_attrsSAVE
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsSFUNC
operator|)
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsANYSIZE
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsINTRINSIC
comment|/* UNDERSTOOD. */
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsRESULT
operator||
name|FFESYMBOL_attrsSAVE
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsSFUNC
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Have it. */
name|nkd
operator|=
name|FFEINFO_kindNONE
expr_stmt|;
comment|/* ENTITY, FUNCTION. */
name|nwh
operator|=
name|FFEINFO_whereNONE
expr_stmt|;
comment|/* DUMMY, GLOBAL, INTRINSIC, LOCAL, RESULT. */
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
name|resolve_intrin
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsCBLOCK
operator||
name|FFESYMBOL_attrsSAVECBLOCK
operator|)
condition|)
block|{
comment|/* COMMON block. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsCBLOCK
operator||
name|FFESYMBOL_attrsSAVECBLOCK
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsCBLOCK
condition|)
name|ffebld_end_list
argument_list|(
name|ffesymbol_ptr_to_listbottom
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ffesymbol_set_commonlist
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestu_list_exec_transition_
argument_list|(
name|ffesymbol_commonlist
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|nkd
operator|=
name|FFEINFO_kindCOMMON
expr_stmt|;
name|nwh
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
name|needs_type
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* First seen in stmt func definition. */
name|assert
argument_list|(
name|sa
operator|==
name|FFESYMBOL_attrsetNONE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|"Why are we here again?"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* ~~~~~ */
name|nkd
operator|=
name|FFEINFO_kindNONE
expr_stmt|;
comment|/* ENTITY, FUNCTION. */
name|nwh
operator|=
name|FFEINFO_whereNONE
expr_stmt|;
comment|/* DUMMY, GLOBAL, LOCAL. */
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
comment|/* Will get repromoted by caller. */
name|needs_type
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
operator|&&
operator|(
name|needs_type
operator|||
operator|(
name|nkd
operator|!=
name|skd
operator|)
operator|||
operator|(
name|nwh
operator|!=
name|swh
operator|)
operator|||
operator|(
name|na
operator|!=
name|sa
operator|)
operator|||
operator|(
name|ns
operator|!=
name|ss
operator|)
operator|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
comment|/* Establish new info. */
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffesymbol_common
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|ffesymbol_set_common
argument_list|(
name|s
argument_list|,
name|ffeequiv_common
argument_list|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
name|nkd
argument_list|,
name|nwh
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_type
operator|&&
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|s
argument_list|)
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|resolve_intrin
condition|)
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffestorag_exec_layout
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* ffestu_list_exec_transition_ -- Update SYMTERs in ITEM list w/in symbol     ffebld list;    ffestu_list_exec_transition_(list);     list contains an FFEBLD_opITEM list of SYMTERs (possibly STARs and    other things, too, but we'll ignore the known ones).	 For each SYMTER,    we run sym_exec_transition_ on the corresponding ffesymbol (a recursive    call, since that's the function that's calling us) to update it's    information.	 Then we copy that information into the SYMTER.     Make sure we don't get called recursively ourselves!	 */
end_comment

begin_function
specifier|static
name|void
name|ffestu_list_exec_transition_
parameter_list|(
name|ffebld
name|list
parameter_list|)
block|{
specifier|static
name|bool
name|in_progress
init|=
name|FALSE
decl_stmt|;
name|ffebld
name|item
decl_stmt|;
name|ffesymbol
name|symbol
decl_stmt|;
name|assert
argument_list|(
operator|!
name|in_progress
argument_list|)
expr_stmt|;
name|in_progress
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|item
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Try next item. */
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|item
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opSTAR
case|:
break|break;
case|case
name|FFEBLD_opSYMTER
case|:
name|symbol
operator|=
name|ffebld_symter
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|==
name|NULL
condition|)
break|break;
comment|/* Detached from stmt func dummy list. */
name|symbol
operator|=
name|ffecom_sym_exec_transition
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffesymbol_kind
argument_list|(
name|symbol
argument_list|)
operator|!=
name|FFEINFO_kindNONE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffesymbol_where
argument_list|(
name|symbol
argument_list|)
operator|!=
name|FFEINFO_whereNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|item
argument_list|,
name|ffesymbol_info
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Unexpected item on list"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|in_progress
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestu_symter_end_transition_ -- Update SYMTERs in expr w/in symbol     ffebld expr;    ffestu_symter_end_transition_(expr);     Any SYMTER in expr's tree with whereNONE gets updated to the    (recursively transitioned) sym it identifies (DUMMY or COMMON).  */
end_comment

begin_function
specifier|static
name|bool
name|ffestu_symter_end_transition_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffesymbol
name|symbol
decl_stmt|;
name|bool
name|any
init|=
name|FALSE
decl_stmt|;
comment|/* Label used for tail recursion (reset expr and go here instead of calling      self). */
name|tail
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return
name|any
return|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opITEM
case|:
while|while
condition|(
name|ffebld_trail
argument_list|(
name|expr
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffestu_symter_end_transition_
argument_list|(
name|ffebld_head
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|any
operator|=
name|TRUE
expr_stmt|;
name|expr
operator|=
name|ffebld_trail
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|ffebld_head
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|tail
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEBLD_opSYMTER
case|:
name|symbol
operator|=
name|ffecom_sym_end_transition
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|symbol
operator|!=
name|NULL
operator|)
operator|&&
name|ffesymbol_attr
argument_list|(
name|symbol
argument_list|,
name|FFESYMBOL_attrANY
argument_list|)
condition|)
name|any
operator|=
name|TRUE
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffesymbol_info
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opANY
case|:
return|return
name|TRUE
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|ffebld_arity
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|ffestu_symter_end_transition_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|any
operator|=
name|TRUE
expr_stmt|;
name|expr
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|tail
goto|;
comment|/* :::::::::::::::::::: */
case|case
literal|1
case|:
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|tail
goto|;
comment|/* :::::::::::::::::::: */
default|default:
break|break;
block|}
return|return
name|any
return|;
block|}
end_function

begin_comment
comment|/* ffestu_symter_exec_transition_ -- Update SYMTERs in expr w/in symbol     ffebld expr;    ffestu_symter_exec_transition_(expr);     Any SYMTER in expr's tree with whereNONE gets updated to the    (recursively transitioned) sym it identifies (DUMMY or COMMON).  */
end_comment

begin_function
specifier|static
name|bool
name|ffestu_symter_exec_transition_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffesymbol
name|symbol
decl_stmt|;
name|bool
name|any
init|=
name|FALSE
decl_stmt|;
comment|/* Label used for tail recursion (reset expr and go here instead of calling      self). */
name|tail
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return
name|any
return|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opITEM
case|:
while|while
condition|(
name|ffebld_trail
argument_list|(
name|expr
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffestu_symter_exec_transition_
argument_list|(
name|ffebld_head
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|any
operator|=
name|TRUE
expr_stmt|;
name|expr
operator|=
name|ffebld_trail
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|ffebld_head
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|tail
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEBLD_opSYMTER
case|:
name|symbol
operator|=
name|ffecom_sym_exec_transition
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|symbol
operator|!=
name|NULL
operator|)
operator|&&
name|ffesymbol_attr
argument_list|(
name|symbol
argument_list|,
name|FFESYMBOL_attrANY
argument_list|)
condition|)
name|any
operator|=
name|TRUE
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffesymbol_info
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opANY
case|:
return|return
name|TRUE
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|ffebld_arity
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|ffestu_symter_exec_transition_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|any
operator|=
name|TRUE
expr_stmt|;
name|expr
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|tail
goto|;
comment|/* :::::::::::::::::::: */
case|case
literal|1
case|:
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|tail
goto|;
comment|/* :::::::::::::::::::: */
default|default:
break|break;
block|}
return|return
name|any
return|;
block|}
end_function

begin_comment
comment|/* ffestu_dummies_transition_ -- Update SYMTERs in ITEM list w/in entry     ffebld list;    ffesymbol symfunc(ffesymbol s);    if (ffestu_dummies_transition_(symfunc,list))        // One or more items are still UNCERTAIN.     list contains an FFEBLD_opITEM list of SYMTERs (possibly STARs and    other things, too, but we'll ignore the known ones).	 For each SYMTER,    we run symfunc on the corresponding ffesymbol (a recursive    call, since that's the function that's calling us) to update it's    information.	 Then we copy that information into the SYMTER.     Return TRUE if any of the SYMTER's has incomplete information.     Make sure we don't get called recursively ourselves!	 */
end_comment

begin_function
specifier|static
name|bool
name|ffestu_dummies_transition_
parameter_list|(
name|ffesymbol
function_decl|(
modifier|*
name|symfunc
function_decl|)
parameter_list|(
name|ffesymbol
parameter_list|)
parameter_list|,
name|ffebld
name|list
parameter_list|)
block|{
specifier|static
name|bool
name|in_progress
init|=
name|FALSE
decl_stmt|;
name|ffebld
name|item
decl_stmt|;
name|ffesymbol
name|symbol
decl_stmt|;
name|bool
name|uncertain
init|=
name|FALSE
decl_stmt|;
name|assert
argument_list|(
operator|!
name|in_progress
argument_list|)
expr_stmt|;
name|in_progress
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|item
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Try next item. */
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|item
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opSTAR
case|:
break|break;
case|case
name|FFEBLD_opSYMTER
case|:
name|symbol
operator|=
name|ffebld_symter
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|==
name|NULL
condition|)
break|break;
comment|/* Detached from stmt func dummy list. */
name|symbol
operator|=
call|(
modifier|*
name|symfunc
call|)
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|symbol
argument_list|)
operator|==
name|FFESYMBOL_stateUNCERTAIN
condition|)
name|uncertain
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|ffesymbol_kind
argument_list|(
name|symbol
argument_list|)
operator|!=
name|FFEINFO_kindNONE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffesymbol_where
argument_list|(
name|symbol
argument_list|)
operator|!=
name|FFEINFO_whereNONE
argument_list|)
expr_stmt|;
block|}
name|ffebld_set_info
argument_list|(
name|item
argument_list|,
name|ffesymbol_info
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Unexpected item on list"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|in_progress
operator|=
name|FALSE
expr_stmt|;
return|return
name|uncertain
return|;
block|}
end_function

end_unit

