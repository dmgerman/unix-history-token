begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* bld.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995, 1996, 2003, 2004 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       None     Description:       The primary "output" of the FFE includes ffebld objects, which       connect expressions, operators, and operands together, along with       connecting lists of expressions together for argument or dimension       lists.     Modifications:       30-Aug-92	 JCB  1.1 	 Change names of some things for consistency. */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"bld.h"
end_include

begin_include
include|#
directive|include
file|"bit.h"
end_include

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"where.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_comment
comment|/* Externals defined here.  */
end_comment

begin_decl_stmt
specifier|const
name|ffebldArity
name|ffebld_arity_op_
index|[
operator|(
name|int
operator|)
name|FFEBLD_op
index|]
init|=
block|{
define|#
directive|define
name|FFEBLD_OP
parameter_list|(
name|KWD
parameter_list|,
name|NAME
parameter_list|,
name|ARITY
parameter_list|)
value|ARITY,
include|#
directive|include
file|"bld-op.def"
undef|#
directive|undef
name|FFEBLD_OP
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|_ffebld_pool_stack_
name|ffebld_pool_stack_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_comment
comment|/* Static objects accessed by functions in this module.	 */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_character1_
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFETARGET_okCOMPLEX1
end_if

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_complex1_
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFETARGET_okCOMPLEX2
end_if

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_complex2_
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFETARGET_okCOMPLEX3
end_if

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_complex3_
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFETARGET_okINTEGER1
end_if

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_integer1_
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFETARGET_okINTEGER2
end_if

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_integer2_
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFETARGET_okINTEGER3
end_if

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_integer3_
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFETARGET_okINTEGER4
end_if

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_integer4_
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFETARGET_okLOGICAL1
end_if

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_logical1_
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFETARGET_okLOGICAL2
end_if

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_logical2_
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFETARGET_okLOGICAL3
end_if

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_logical3_
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFETARGET_okLOGICAL4
end_if

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_logical4_
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFETARGET_okREAL1
end_if

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_real1_
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFETARGET_okREAL2
end_if

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_real2_
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFETARGET_okREAL3
end_if

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_real3_
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_hollerith_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffebldConstant
name|ffebld_constant_typeless_
index|[
name|FFEBLD_constTYPELESS_LAST
operator|-
name|FFEBLD_constTYPELESS_FIRST
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ffebld_op_string_
index|[]
init|=
block|{
define|#
directive|define
name|FFEBLD_OP
parameter_list|(
name|KWD
parameter_list|,
name|NAME
parameter_list|,
name|ARITY
parameter_list|)
value|NAME,
include|#
directive|include
file|"bld-op.def"
undef|#
directive|undef
name|FFEBLD_OP
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_comment
comment|/* Internal macros. */
end_comment

begin_define
define|#
directive|define
name|integerdefault_
value|CATX(integer,FFETARGET_ktINTEGERDEFAULT)
end_define

begin_define
define|#
directive|define
name|logicaldefault_
value|CATX(logical,FFETARGET_ktLOGICALDEFAULT)
end_define

begin_define
define|#
directive|define
name|realdefault_
value|CATX(real,FFETARGET_ktREALDEFAULT)
end_define

begin_define
define|#
directive|define
name|realdouble_
value|CATX(real,FFETARGET_ktREALDOUBLE)
end_define

begin_define
define|#
directive|define
name|realquad_
value|CATX(real,FFETARGET_ktREALQUAD)
end_define

begin_escape
end_escape

begin_comment
comment|/* ffebld_constant_cmp -- Compare two constants a la strcmp     ffebldConstant c1, c2;    if (ffebld_constant_cmp(c1,c2) == 0)        // they're equal, else they're not.     Returns -1 if c1< c2, 0 if c1 == c2, +1 if c1 == c2.  */
end_comment

begin_function
name|int
name|ffebld_constant_cmp
parameter_list|(
name|ffebldConstant
name|c1
parameter_list|,
name|ffebldConstant
name|c2
parameter_list|)
block|{
if|if
condition|(
name|c1
operator|==
name|c2
condition|)
return|return
literal|0
return|;
name|assert
argument_list|(
name|ffebld_constant_type
argument_list|(
name|c1
argument_list|)
operator|==
name|ffebld_constant_type
argument_list|(
name|c2
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffebld_constant_type
argument_list|(
name|c1
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEBLD_constINTEGER1
case|:
return|return
name|ffetarget_cmp_integer1
argument_list|(
name|ffebld_constant_integer1
argument_list|(
name|c1
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|c2
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEBLD_constINTEGER2
case|:
return|return
name|ffetarget_cmp_integer2
argument_list|(
name|ffebld_constant_integer2
argument_list|(
name|c1
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|c2
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEBLD_constINTEGER3
case|:
return|return
name|ffetarget_cmp_integer3
argument_list|(
name|ffebld_constant_integer3
argument_list|(
name|c1
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|c2
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEBLD_constINTEGER4
case|:
return|return
name|ffetarget_cmp_integer4
argument_list|(
name|ffebld_constant_integer4
argument_list|(
name|c1
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|c2
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEBLD_constLOGICAL1
case|:
return|return
name|ffetarget_cmp_logical1
argument_list|(
name|ffebld_constant_logical1
argument_list|(
name|c1
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|c2
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEBLD_constLOGICAL2
case|:
return|return
name|ffetarget_cmp_logical2
argument_list|(
name|ffebld_constant_logical2
argument_list|(
name|c1
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|c2
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEBLD_constLOGICAL3
case|:
return|return
name|ffetarget_cmp_logical3
argument_list|(
name|ffebld_constant_logical3
argument_list|(
name|c1
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|c2
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEBLD_constLOGICAL4
case|:
return|return
name|ffetarget_cmp_logical4
argument_list|(
name|ffebld_constant_logical4
argument_list|(
name|c1
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|c2
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEBLD_constREAL1
case|:
return|return
name|ffetarget_cmp_real1
argument_list|(
name|ffebld_constant_real1
argument_list|(
name|c1
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|c2
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEBLD_constREAL2
case|:
return|return
name|ffetarget_cmp_real2
argument_list|(
name|ffebld_constant_real2
argument_list|(
name|c1
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|c2
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEBLD_constREAL3
case|:
return|return
name|ffetarget_cmp_real3
argument_list|(
name|ffebld_constant_real3
argument_list|(
name|c1
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|c2
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEBLD_constCHARACTER1
case|:
return|return
name|ffetarget_cmp_character1
argument_list|(
name|ffebld_constant_character1
argument_list|(
name|c1
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|c2
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad constant type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffebld_constant_is_magical -- Determine if integer is "magical"     ffebldConstant c;    if (ffebld_constant_is_magical(c))        // it is 2**(n-1), where n is # bits in ffetargetIntegerDefault type        // (this test is important for 2's-complement machines only).  */
end_comment

begin_function
name|bool
name|ffebld_constant_is_magical
parameter_list|(
name|ffebldConstant
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|ffebld_constant_type
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_constINTEGERDEFAULT
case|:
return|return
name|ffetarget_integerdefault_is_magical
argument_list|(
name|ffebld_constant_integer1
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Determine if constant is zero.  Used to ensure step count    for DO loops isn't zero, also to determine if values will    be binary zeros, so not entirely portable at this point.  */
end_comment

begin_function
name|bool
name|ffebld_constant_is_zero
parameter_list|(
name|ffebldConstant
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|ffebld_constant_type
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEBLD_constINTEGER1
case|:
return|return
name|ffebld_constant_integer1
argument_list|(
name|c
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEBLD_constINTEGER2
case|:
return|return
name|ffebld_constant_integer2
argument_list|(
name|c
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEBLD_constINTEGER3
case|:
return|return
name|ffebld_constant_integer3
argument_list|(
name|c
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEBLD_constINTEGER4
case|:
return|return
name|ffebld_constant_integer4
argument_list|(
name|c
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEBLD_constLOGICAL1
case|:
return|return
name|ffebld_constant_logical1
argument_list|(
name|c
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEBLD_constLOGICAL2
case|:
return|return
name|ffebld_constant_logical2
argument_list|(
name|c
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEBLD_constLOGICAL3
case|:
return|return
name|ffebld_constant_logical3
argument_list|(
name|c
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEBLD_constLOGICAL4
case|:
return|return
name|ffebld_constant_logical4
argument_list|(
name|c
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEBLD_constREAL1
case|:
return|return
name|ffetarget_iszero_real1
argument_list|(
name|ffebld_constant_real1
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEBLD_constREAL2
case|:
return|return
name|ffetarget_iszero_real2
argument_list|(
name|ffebld_constant_real2
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEBLD_constREAL3
case|:
return|return
name|ffetarget_iszero_real3
argument_list|(
name|ffebld_constant_real3
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEBLD_constCOMPLEX1
case|:
return|return
name|ffetarget_iszero_real1
argument_list|(
name|ffebld_constant_complex1
argument_list|(
name|c
argument_list|)
operator|.
name|real
argument_list|)
operator|&&
name|ffetarget_iszero_real1
argument_list|(
name|ffebld_constant_complex1
argument_list|(
name|c
argument_list|)
operator|.
name|imaginary
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEBLD_constCOMPLEX2
case|:
return|return
name|ffetarget_iszero_real2
argument_list|(
name|ffebld_constant_complex2
argument_list|(
name|c
argument_list|)
operator|.
name|real
argument_list|)
operator|&&
name|ffetarget_iszero_real2
argument_list|(
name|ffebld_constant_complex2
argument_list|(
name|c
argument_list|)
operator|.
name|imaginary
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEBLD_constCOMPLEX3
case|:
return|return
name|ffetarget_iszero_real3
argument_list|(
name|ffebld_constant_complex3
argument_list|(
name|c
argument_list|)
operator|.
name|real
argument_list|)
operator|&&
name|ffetarget_iszero_real3
argument_list|(
name|ffebld_constant_complex3
argument_list|(
name|c
argument_list|)
operator|.
name|imaginary
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEBLD_constCHARACTER1
case|:
return|return
name|ffetarget_iszero_character1
argument_list|(
name|ffebld_constant_character1
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
case|case
name|FFEBLD_constHOLLERITH
case|:
return|return
name|ffetarget_iszero_hollerith
argument_list|(
name|ffebld_constant_hollerith
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
case|case
name|FFEBLD_constBINARY_MIL
case|:
case|case
name|FFEBLD_constBINARY_VXT
case|:
case|case
name|FFEBLD_constOCTAL_MIL
case|:
case|case
name|FFEBLD_constOCTAL_VXT
case|:
case|case
name|FFEBLD_constHEX_X_MIL
case|:
case|case
name|FFEBLD_constHEX_X_VXT
case|:
case|case
name|FFEBLD_constHEX_Z_MIL
case|:
case|case
name|FFEBLD_constHEX_Z_VXT
case|:
return|return
name|ffetarget_iszero_typeless
argument_list|(
name|ffebld_constant_typeless
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffebld_constant_new_character1 -- Return character1 constant object from token     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_character1
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffetargetCharacter1
name|val
decl_stmt|;
name|ffetarget_character1
argument_list|(
operator|&
name|val
argument_list|,
name|t
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_character1_val
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_character1_val -- Return an character1 constant object     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCHARACTER1
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_character1_val
parameter_list|(
name|ffetargetCharacter1
name|val
parameter_list|)
block|{
name|ffebldConstant
name|nc
decl_stmt|;
name|ffebldConstant
name|P
decl_stmt|;
name|ffebldConstant
name|Q
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
name|P
operator|=
name|ffebld_constant_character1_
expr_stmt|;
name|Q
operator|=
name|P
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
block|{
comment|/* make this node the root */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constCHARACTER1"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constCHARACTER1
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|character1
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|ffebld_constant_character1_
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
else|else
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
expr_stmt|;
name|cmp
operator|=
name|ffetarget_cmp_character1
argument_list|(
name|val
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|P
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|llink
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|rlink
expr_stmt|;
else|else
return|return
name|P
return|;
block|}
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constCHARACTER1"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constCHARACTER1
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|character1
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|Q
operator|->
name|llink
operator|=
name|nc
expr_stmt|;
else|else
name|Q
operator|->
name|rlink
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_complex1 -- Return complex1 constant object from token     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCOMPLEX1
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_complex1
parameter_list|(
name|ffebldConstant
name|real
parameter_list|,
name|ffebldConstant
name|imaginary
parameter_list|)
block|{
name|ffetargetComplex1
name|val
decl_stmt|;
name|val
operator|.
name|real
operator|=
name|ffebld_constant_real1
argument_list|(
name|real
argument_list|)
expr_stmt|;
name|val
operator|.
name|imaginary
operator|=
name|ffebld_constant_real1
argument_list|(
name|imaginary
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_complex1_val
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_complex1_val -- Return a complex1 constant object     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCOMPLEX1
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_complex1_val
parameter_list|(
name|ffetargetComplex1
name|val
parameter_list|)
block|{
name|ffebldConstant
name|nc
decl_stmt|;
name|ffebldConstant
name|P
decl_stmt|;
name|ffebldConstant
name|Q
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
name|P
operator|=
name|ffebld_constant_complex1_
expr_stmt|;
name|Q
operator|=
name|P
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
block|{
comment|/* make this node the root */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constCOMPLEX1"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constCOMPLEX1
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|complex1
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|ffebld_constant_complex1_
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
else|else
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
expr_stmt|;
name|cmp
operator|=
name|ffetarget_cmp_real1
argument_list|(
name|val
operator|.
name|real
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|P
argument_list|)
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
name|cmp
operator|=
name|ffetarget_cmp_real1
argument_list|(
name|val
operator|.
name|imaginary
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|P
argument_list|)
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|llink
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|rlink
expr_stmt|;
else|else
return|return
name|P
return|;
block|}
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constCOMPLEX1"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constCOMPLEX1
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|complex1
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|Q
operator|->
name|llink
operator|=
name|nc
expr_stmt|;
else|else
name|Q
operator|->
name|rlink
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_complex2 -- Return complex2 constant object from token     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCOMPLEX2
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_complex2
parameter_list|(
name|ffebldConstant
name|real
parameter_list|,
name|ffebldConstant
name|imaginary
parameter_list|)
block|{
name|ffetargetComplex2
name|val
decl_stmt|;
name|val
operator|.
name|real
operator|=
name|ffebld_constant_real2
argument_list|(
name|real
argument_list|)
expr_stmt|;
name|val
operator|.
name|imaginary
operator|=
name|ffebld_constant_real2
argument_list|(
name|imaginary
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_complex2_val
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_complex2_val -- Return a complex2 constant object     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okCOMPLEX2
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_complex2_val
parameter_list|(
name|ffetargetComplex2
name|val
parameter_list|)
block|{
name|ffebldConstant
name|nc
decl_stmt|;
name|ffebldConstant
name|P
decl_stmt|;
name|ffebldConstant
name|Q
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
name|P
operator|=
name|ffebld_constant_complex2_
expr_stmt|;
name|Q
operator|=
name|P
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
block|{
comment|/* make this node the root */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constCOMPLEX2"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constCOMPLEX2
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|complex2
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|ffebld_constant_complex2_
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
else|else
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
expr_stmt|;
name|cmp
operator|=
name|ffetarget_cmp_real2
argument_list|(
name|val
operator|.
name|real
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|P
argument_list|)
operator|.
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
name|cmp
operator|=
name|ffetarget_cmp_real2
argument_list|(
name|val
operator|.
name|imaginary
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|P
argument_list|)
operator|.
name|imaginary
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|llink
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|rlink
expr_stmt|;
else|else
return|return
name|P
return|;
block|}
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constCOMPLEX2"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constCOMPLEX2
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|complex2
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|Q
operator|->
name|llink
operator|=
name|nc
expr_stmt|;
else|else
name|Q
operator|->
name|rlink
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_hollerith -- Return hollerith constant object from token     See prototype.  */
end_comment

begin_function
name|ffebldConstant
name|ffebld_constant_new_hollerith
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffetargetHollerith
name|val
decl_stmt|;
name|ffetarget_hollerith
argument_list|(
operator|&
name|val
argument_list|,
name|t
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_hollerith_val
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constant_new_hollerith_val -- Return an hollerith constant object     See prototype.  */
end_comment

begin_function
name|ffebldConstant
name|ffebld_constant_new_hollerith_val
parameter_list|(
name|ffetargetHollerith
name|val
parameter_list|)
block|{
name|ffebldConstant
name|nc
decl_stmt|;
name|ffebldConstant
name|P
decl_stmt|;
name|ffebldConstant
name|Q
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
name|P
operator|=
name|ffebld_constant_hollerith_
expr_stmt|;
name|Q
operator|=
name|P
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
block|{
comment|/* make this node the root */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constHOLLERITH"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constHOLLERITH
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|hollerith
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|ffebld_constant_hollerith_
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
else|else
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
expr_stmt|;
name|cmp
operator|=
name|ffetarget_cmp_hollerith
argument_list|(
name|val
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|P
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|llink
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|rlink
expr_stmt|;
else|else
return|return
name|P
return|;
block|}
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constHOLLERITH"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constHOLLERITH
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|hollerith
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|Q
operator|->
name|llink
operator|=
name|nc
expr_stmt|;
else|else
name|Q
operator|->
name|rlink
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constant_new_integer1 -- Return integer1 constant object from token     See prototype.     Parses the token as a decimal integer constant, thus it must be an    FFELEX_typeNUMBER.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okINTEGER1
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_integer1
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffetargetInteger1
name|val
decl_stmt|;
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNUMBER
argument_list|)
expr_stmt|;
name|ffetarget_integer1
argument_list|(
operator|&
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_integer1_val
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_integer1_val -- Return an integer1 constant object     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okINTEGER1
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_integer1_val
parameter_list|(
name|ffetargetInteger1
name|val
parameter_list|)
block|{
name|ffebldConstant
name|nc
decl_stmt|;
name|ffebldConstant
name|P
decl_stmt|;
name|ffebldConstant
name|Q
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
name|P
operator|=
name|ffebld_constant_integer1_
expr_stmt|;
name|Q
operator|=
name|P
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
block|{
comment|/* make this node the root */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constINTEGER1"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constINTEGER1
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|integer1
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|ffebld_constant_integer1_
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
else|else
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
expr_stmt|;
name|cmp
operator|=
name|ffetarget_cmp_integer1
argument_list|(
name|val
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|P
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|llink
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|rlink
expr_stmt|;
else|else
return|return
name|P
return|;
block|}
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constINTEGER1"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constINTEGER1
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|integer1
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|Q
operator|->
name|llink
operator|=
name|nc
expr_stmt|;
else|else
name|Q
operator|->
name|rlink
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_integer2_val -- Return an integer2 constant object     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okINTEGER2
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_integer2_val
parameter_list|(
name|ffetargetInteger2
name|val
parameter_list|)
block|{
name|ffebldConstant
name|nc
decl_stmt|;
name|ffebldConstant
name|P
decl_stmt|;
name|ffebldConstant
name|Q
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
name|P
operator|=
name|ffebld_constant_integer2_
expr_stmt|;
name|Q
operator|=
name|P
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
block|{
comment|/* make this node the root */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constINTEGER2"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constINTEGER2
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|integer2
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|ffebld_constant_integer2_
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
else|else
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
expr_stmt|;
name|cmp
operator|=
name|ffetarget_cmp_integer2
argument_list|(
name|val
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|P
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|llink
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|rlink
expr_stmt|;
else|else
return|return
name|P
return|;
block|}
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constINTEGER2"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constINTEGER2
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|integer2
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|Q
operator|->
name|llink
operator|=
name|nc
expr_stmt|;
else|else
name|Q
operator|->
name|rlink
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_integer3_val -- Return an integer3 constant object     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okINTEGER3
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_integer3_val
parameter_list|(
name|ffetargetInteger3
name|val
parameter_list|)
block|{
name|ffebldConstant
name|nc
decl_stmt|;
name|ffebldConstant
name|P
decl_stmt|;
name|ffebldConstant
name|Q
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
name|P
operator|=
name|ffebld_constant_integer3_
expr_stmt|;
name|Q
operator|=
name|P
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
block|{
comment|/* make this node the root */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constINTEGER3"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constINTEGER3
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|integer3
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|ffebld_constant_integer3_
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
else|else
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
expr_stmt|;
name|cmp
operator|=
name|ffetarget_cmp_integer3
argument_list|(
name|val
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|P
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|llink
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|rlink
expr_stmt|;
else|else
return|return
name|P
return|;
block|}
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constINTEGER3"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constINTEGER3
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|integer3
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|Q
operator|->
name|llink
operator|=
name|nc
expr_stmt|;
else|else
name|Q
operator|->
name|rlink
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_integer4_val -- Return an integer4 constant object     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okINTEGER4
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_integer4_val
parameter_list|(
name|ffetargetInteger4
name|val
parameter_list|)
block|{
name|ffebldConstant
name|nc
decl_stmt|;
name|ffebldConstant
name|P
decl_stmt|;
name|ffebldConstant
name|Q
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
name|P
operator|=
name|ffebld_constant_integer4_
expr_stmt|;
name|Q
operator|=
name|P
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
block|{
comment|/* make this node the root */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constINTEGER4"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constINTEGER4
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|integer4
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|ffebld_constant_integer4_
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
else|else
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
expr_stmt|;
name|cmp
operator|=
name|ffetarget_cmp_integer4
argument_list|(
name|val
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|P
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|llink
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|rlink
expr_stmt|;
else|else
return|return
name|P
return|;
block|}
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constINTEGER4"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constINTEGER4
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|integer4
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|Q
operator|->
name|llink
operator|=
name|nc
expr_stmt|;
else|else
name|Q
operator|->
name|rlink
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_integerbinary -- Return binary constant object from token     See prototype.     Parses the token as a binary integer constant, thus it must be an    FFELEX_typeNUMBER.  */
end_comment

begin_function
name|ffebldConstant
name|ffebld_constant_new_integerbinary
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffetargetIntegerDefault
name|val
decl_stmt|;
name|assert
argument_list|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNUMBER
operator|)
argument_list|)
expr_stmt|;
name|ffetarget_integerbinary
argument_list|(
operator|&
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_integerdefault_val
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constant_new_integerhex -- Return hex constant object from token     See prototype.     Parses the token as a hex integer constant, thus it must be an    FFELEX_typeNUMBER.  */
end_comment

begin_function
name|ffebldConstant
name|ffebld_constant_new_integerhex
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffetargetIntegerDefault
name|val
decl_stmt|;
name|assert
argument_list|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNUMBER
operator|)
argument_list|)
expr_stmt|;
name|ffetarget_integerhex
argument_list|(
operator|&
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_integerdefault_val
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constant_new_integeroctal -- Return octal constant object from token     See prototype.     Parses the token as a octal integer constant, thus it must be an    FFELEX_typeNUMBER.  */
end_comment

begin_function
name|ffebldConstant
name|ffebld_constant_new_integeroctal
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffetargetIntegerDefault
name|val
decl_stmt|;
name|assert
argument_list|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNUMBER
operator|)
argument_list|)
expr_stmt|;
name|ffetarget_integeroctal
argument_list|(
operator|&
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_integerdefault_val
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constant_new_logical1 -- Return logical1 constant object from token     See prototype.     Parses the token as a decimal logical constant, thus it must be an    FFELEX_typeNUMBER.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okLOGICAL1
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_logical1
parameter_list|(
name|bool
name|truth
parameter_list|)
block|{
name|ffetargetLogical1
name|val
decl_stmt|;
name|ffetarget_logical1
argument_list|(
operator|&
name|val
argument_list|,
name|truth
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_logical1_val
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_logical1_val -- Return a logical1 constant object     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okLOGICAL1
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_logical1_val
parameter_list|(
name|ffetargetLogical1
name|val
parameter_list|)
block|{
name|ffebldConstant
name|nc
decl_stmt|;
name|ffebldConstant
name|P
decl_stmt|;
name|ffebldConstant
name|Q
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
name|P
operator|=
name|ffebld_constant_logical1_
expr_stmt|;
name|Q
operator|=
name|P
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
block|{
comment|/* make this node the root */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constLOGICAL1"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constLOGICAL1
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|logical1
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|ffebld_constant_logical1_
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
else|else
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
expr_stmt|;
name|cmp
operator|=
name|ffetarget_cmp_logical1
argument_list|(
name|val
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|P
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|llink
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|rlink
expr_stmt|;
else|else
return|return
name|P
return|;
block|}
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constLOGICAL1"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constLOGICAL1
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|logical1
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|Q
operator|->
name|llink
operator|=
name|nc
expr_stmt|;
else|else
name|Q
operator|->
name|rlink
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_logical2_val -- Return a logical2 constant object     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okLOGICAL2
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_logical2_val
parameter_list|(
name|ffetargetLogical2
name|val
parameter_list|)
block|{
name|ffebldConstant
name|nc
decl_stmt|;
name|ffebldConstant
name|P
decl_stmt|;
name|ffebldConstant
name|Q
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
name|P
operator|=
name|ffebld_constant_logical2_
expr_stmt|;
name|Q
operator|=
name|P
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
block|{
comment|/* make this node the root */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constLOGICAL2"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constLOGICAL2
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|logical2
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|ffebld_constant_logical2_
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
else|else
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
expr_stmt|;
name|cmp
operator|=
name|ffetarget_cmp_logical2
argument_list|(
name|val
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|P
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|llink
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|rlink
expr_stmt|;
else|else
return|return
name|P
return|;
block|}
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constLOGICAL2"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constLOGICAL2
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|logical2
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|Q
operator|->
name|llink
operator|=
name|nc
expr_stmt|;
else|else
name|Q
operator|->
name|rlink
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_logical3_val -- Return a logical3 constant object     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okLOGICAL3
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_logical3_val
parameter_list|(
name|ffetargetLogical3
name|val
parameter_list|)
block|{
name|ffebldConstant
name|nc
decl_stmt|;
name|ffebldConstant
name|P
decl_stmt|;
name|ffebldConstant
name|Q
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
name|P
operator|=
name|ffebld_constant_logical3_
expr_stmt|;
name|Q
operator|=
name|P
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
block|{
comment|/* make this node the root */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constLOGICAL3"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constLOGICAL3
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|logical3
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|ffebld_constant_logical3_
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
else|else
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
expr_stmt|;
name|cmp
operator|=
name|ffetarget_cmp_logical3
argument_list|(
name|val
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|P
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|llink
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|rlink
expr_stmt|;
else|else
return|return
name|P
return|;
block|}
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constLOGICAL3"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constLOGICAL3
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|logical3
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|Q
operator|->
name|llink
operator|=
name|nc
expr_stmt|;
else|else
name|Q
operator|->
name|rlink
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_logical4_val -- Return a logical4 constant object     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okLOGICAL4
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_logical4_val
parameter_list|(
name|ffetargetLogical4
name|val
parameter_list|)
block|{
name|ffebldConstant
name|nc
decl_stmt|;
name|ffebldConstant
name|P
decl_stmt|;
name|ffebldConstant
name|Q
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
name|P
operator|=
name|ffebld_constant_logical4_
expr_stmt|;
name|Q
operator|=
name|P
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
block|{
comment|/* make this node the root */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constLOGICAL4"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constLOGICAL4
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|logical4
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|ffebld_constant_logical4_
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
else|else
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
expr_stmt|;
name|cmp
operator|=
name|ffetarget_cmp_logical4
argument_list|(
name|val
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|P
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|llink
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|rlink
expr_stmt|;
else|else
return|return
name|P
return|;
block|}
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constLOGICAL4"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constLOGICAL4
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|logical4
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|Q
operator|->
name|llink
operator|=
name|nc
expr_stmt|;
else|else
name|Q
operator|->
name|rlink
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_real1 -- Return real1 constant object from token     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okREAL1
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_real1
parameter_list|(
name|ffelexToken
name|integer
parameter_list|,
name|ffelexToken
name|decimal
parameter_list|,
name|ffelexToken
name|fraction
parameter_list|,
name|ffelexToken
name|exponent
parameter_list|,
name|ffelexToken
name|exponent_sign
parameter_list|,
name|ffelexToken
name|exponent_digits
parameter_list|)
block|{
name|ffetargetReal1
name|val
decl_stmt|;
name|ffetarget_real1
argument_list|(
operator|&
name|val
argument_list|,
name|integer
argument_list|,
name|decimal
argument_list|,
name|fraction
argument_list|,
name|exponent
argument_list|,
name|exponent_sign
argument_list|,
name|exponent_digits
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_real1_val
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_real1_val -- Return an real1 constant object     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okREAL1
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_real1_val
parameter_list|(
name|ffetargetReal1
name|val
parameter_list|)
block|{
name|ffebldConstant
name|nc
decl_stmt|;
name|ffebldConstant
name|P
decl_stmt|;
name|ffebldConstant
name|Q
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
name|P
operator|=
name|ffebld_constant_real1_
expr_stmt|;
name|Q
operator|=
name|P
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
block|{
comment|/* make this node the root */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constREAL1"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constREAL1
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|real1
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|ffebld_constant_real1_
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
else|else
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
expr_stmt|;
name|cmp
operator|=
name|ffetarget_cmp_real1
argument_list|(
name|val
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|P
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|llink
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|rlink
expr_stmt|;
else|else
return|return
name|P
return|;
block|}
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constREAL1"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constREAL1
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|real1
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|Q
operator|->
name|llink
operator|=
name|nc
expr_stmt|;
else|else
name|Q
operator|->
name|rlink
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_real2 -- Return real2 constant object from token     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okREAL2
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_real2
parameter_list|(
name|ffelexToken
name|integer
parameter_list|,
name|ffelexToken
name|decimal
parameter_list|,
name|ffelexToken
name|fraction
parameter_list|,
name|ffelexToken
name|exponent
parameter_list|,
name|ffelexToken
name|exponent_sign
parameter_list|,
name|ffelexToken
name|exponent_digits
parameter_list|)
block|{
name|ffetargetReal2
name|val
decl_stmt|;
name|ffetarget_real2
argument_list|(
operator|&
name|val
argument_list|,
name|integer
argument_list|,
name|decimal
argument_list|,
name|fraction
argument_list|,
name|exponent
argument_list|,
name|exponent_sign
argument_list|,
name|exponent_digits
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_real2_val
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_real2_val -- Return an real2 constant object     See prototype.  */
end_comment

begin_if
if|#
directive|if
name|FFETARGET_okREAL2
end_if

begin_function
name|ffebldConstant
name|ffebld_constant_new_real2_val
parameter_list|(
name|ffetargetReal2
name|val
parameter_list|)
block|{
name|ffebldConstant
name|nc
decl_stmt|;
name|ffebldConstant
name|P
decl_stmt|;
name|ffebldConstant
name|Q
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
name|P
operator|=
name|ffebld_constant_real2_
expr_stmt|;
name|Q
operator|=
name|P
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
block|{
comment|/* make this node the root */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constREAL2"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constREAL1
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|real2
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|ffebld_constant_real2_
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
else|else
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
expr_stmt|;
name|cmp
operator|=
name|ffetarget_cmp_real2
argument_list|(
name|val
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|P
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|llink
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|rlink
expr_stmt|;
else|else
return|return
name|P
return|;
block|}
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constREAL2"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|FFEBLD_constREAL2
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|real2
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|Q
operator|->
name|llink
operator|=
name|nc
expr_stmt|;
else|else
name|Q
operator|->
name|rlink
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffebld_constant_new_typeless_bm -- Return typeless constant object from token     See prototype.     Parses the token as a decimal integer constant, thus it must be an    FFELEX_typeNUMBER.  */
end_comment

begin_function
name|ffebldConstant
name|ffebld_constant_new_typeless_bm
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffetargetTypeless
name|val
decl_stmt|;
name|ffetarget_binarymil
argument_list|(
operator|&
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_typeless_val
argument_list|(
name|FFEBLD_constBINARY_MIL
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constant_new_typeless_bv -- Return typeless constant object from token     See prototype.     Parses the token as a decimal integer constant, thus it must be an    FFELEX_typeNUMBER.  */
end_comment

begin_function
name|ffebldConstant
name|ffebld_constant_new_typeless_bv
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffetargetTypeless
name|val
decl_stmt|;
name|ffetarget_binaryvxt
argument_list|(
operator|&
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_typeless_val
argument_list|(
name|FFEBLD_constBINARY_VXT
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constant_new_typeless_hxm -- Return typeless constant object from token     See prototype.     Parses the token as a decimal integer constant, thus it must be an    FFELEX_typeNUMBER.  */
end_comment

begin_function
name|ffebldConstant
name|ffebld_constant_new_typeless_hxm
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffetargetTypeless
name|val
decl_stmt|;
name|ffetarget_hexxmil
argument_list|(
operator|&
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_typeless_val
argument_list|(
name|FFEBLD_constHEX_X_MIL
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constant_new_typeless_hxv -- Return typeless constant object from token     See prototype.     Parses the token as a decimal integer constant, thus it must be an    FFELEX_typeNUMBER.  */
end_comment

begin_function
name|ffebldConstant
name|ffebld_constant_new_typeless_hxv
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffetargetTypeless
name|val
decl_stmt|;
name|ffetarget_hexxvxt
argument_list|(
operator|&
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_typeless_val
argument_list|(
name|FFEBLD_constHEX_X_VXT
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constant_new_typeless_hzm -- Return typeless constant object from token     See prototype.     Parses the token as a decimal integer constant, thus it must be an    FFELEX_typeNUMBER.  */
end_comment

begin_function
name|ffebldConstant
name|ffebld_constant_new_typeless_hzm
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffetargetTypeless
name|val
decl_stmt|;
name|ffetarget_hexzmil
argument_list|(
operator|&
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_typeless_val
argument_list|(
name|FFEBLD_constHEX_Z_MIL
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constant_new_typeless_hzv -- Return typeless constant object from token     See prototype.     Parses the token as a decimal integer constant, thus it must be an    FFELEX_typeNUMBER.  */
end_comment

begin_function
name|ffebldConstant
name|ffebld_constant_new_typeless_hzv
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffetargetTypeless
name|val
decl_stmt|;
name|ffetarget_hexzvxt
argument_list|(
operator|&
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_typeless_val
argument_list|(
name|FFEBLD_constHEX_Z_VXT
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constant_new_typeless_om -- Return typeless constant object from token     See prototype.     Parses the token as a decimal integer constant, thus it must be an    FFELEX_typeNUMBER.  */
end_comment

begin_function
name|ffebldConstant
name|ffebld_constant_new_typeless_om
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffetargetTypeless
name|val
decl_stmt|;
name|ffetarget_octalmil
argument_list|(
operator|&
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_typeless_val
argument_list|(
name|FFEBLD_constOCTAL_MIL
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constant_new_typeless_ov -- Return typeless constant object from token     See prototype.     Parses the token as a decimal integer constant, thus it must be an    FFELEX_typeNUMBER.  */
end_comment

begin_function
name|ffebldConstant
name|ffebld_constant_new_typeless_ov
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffetargetTypeless
name|val
decl_stmt|;
name|ffetarget_octalvxt
argument_list|(
operator|&
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|ffebld_constant_new_typeless_val
argument_list|(
name|FFEBLD_constOCTAL_VXT
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constant_new_typeless_val -- Return a typeless constant object     See prototype.  */
end_comment

begin_function
name|ffebldConstant
name|ffebld_constant_new_typeless_val
parameter_list|(
name|ffebldConst
name|type
parameter_list|,
name|ffetargetTypeless
name|val
parameter_list|)
block|{
name|ffebldConstant
name|nc
decl_stmt|;
name|ffebldConstant
name|P
decl_stmt|;
name|ffebldConstant
name|Q
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
name|P
operator|=
name|ffebld_constant_typeless_
index|[
name|type
operator|-
name|FFEBLD_constTYPELESS_FIRST
index|]
expr_stmt|;
name|Q
operator|=
name|P
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
block|{
comment|/* make this node the root */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constTYPELESS"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|type
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|typeless
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
name|ffebld_constant_typeless_
index|[
name|type
operator|-
name|FFEBLD_constTYPELESS_FIRST
index|]
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
else|else
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
expr_stmt|;
name|cmp
operator|=
name|ffetarget_cmp_typeless
argument_list|(
name|val
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|P
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|llink
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|P
operator|=
name|P
operator|->
name|rlink
expr_stmt|;
else|else
return|return
name|P
return|;
block|}
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"FFEBLD_constTYPELESS"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|consttype
operator|=
name|type
expr_stmt|;
name|nc
operator|->
name|u
operator|.
name|typeless
operator|=
name|val
expr_stmt|;
name|nc
operator|->
name|hook
operator|=
name|FFECOM_constantNULL
expr_stmt|;
name|nc
operator|->
name|llink
operator|=
name|NULL
expr_stmt|;
name|nc
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|Q
operator|->
name|llink
operator|=
name|nc
expr_stmt|;
else|else
name|Q
operator|->
name|rlink
operator|=
name|nc
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constantarray_get -- Get a value from an array of constants     See prototype.  */
end_comment

begin_function
name|ffebldConstantUnion
name|ffebld_constantarray_get
parameter_list|(
name|ffebldConstantArray
name|array
parameter_list|,
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|,
name|ffetargetOffset
name|offset
parameter_list|)
block|{
name|ffebldConstantUnion
name|u
decl_stmt|;
switch|switch
condition|(
name|bt
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|u
operator|.
name|integer1
operator|=
operator|*
operator|(
name|array
operator|.
name|integer1
operator|+
name|offset
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|u
operator|.
name|integer2
operator|=
operator|*
operator|(
name|array
operator|.
name|integer2
operator|+
name|offset
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|u
operator|.
name|integer3
operator|=
operator|*
operator|(
name|array
operator|.
name|integer3
operator|+
name|offset
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|u
operator|.
name|integer4
operator|=
operator|*
operator|(
name|array
operator|.
name|integer4
operator|+
name|offset
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad INTEGER kindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|u
operator|.
name|logical1
operator|=
operator|*
operator|(
name|array
operator|.
name|logical1
operator|+
name|offset
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|u
operator|.
name|logical2
operator|=
operator|*
operator|(
name|array
operator|.
name|logical2
operator|+
name|offset
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|u
operator|.
name|logical3
operator|=
operator|*
operator|(
name|array
operator|.
name|logical3
operator|+
name|offset
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|u
operator|.
name|logical4
operator|=
operator|*
operator|(
name|array
operator|.
name|logical4
operator|+
name|offset
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad LOGICAL kindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|u
operator|.
name|real1
operator|=
operator|*
operator|(
name|array
operator|.
name|real1
operator|+
name|offset
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|u
operator|.
name|real2
operator|=
operator|*
operator|(
name|array
operator|.
name|real2
operator|+
name|offset
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|u
operator|.
name|real3
operator|=
operator|*
operator|(
name|array
operator|.
name|real3
operator|+
name|offset
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad REAL kindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|u
operator|.
name|complex1
operator|=
operator|*
operator|(
name|array
operator|.
name|complex1
operator|+
name|offset
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|u
operator|.
name|complex2
operator|=
operator|*
operator|(
name|array
operator|.
name|complex2
operator|+
name|offset
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|u
operator|.
name|complex3
operator|=
operator|*
operator|(
name|array
operator|.
name|complex3
operator|+
name|offset
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad COMPLEX kindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
name|u
operator|.
name|character1
operator|.
name|length
operator|=
literal|1
expr_stmt|;
name|u
operator|.
name|character1
operator|.
name|text
operator|=
name|array
operator|.
name|character1
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad CHARACTER kindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad basictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|u
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constantarray_new -- Make an array of constants     See prototype.  */
end_comment

begin_function
name|ffebldConstantArray
name|ffebld_constantarray_new
parameter_list|(
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|,
name|ffetargetOffset
name|size
parameter_list|)
block|{
name|ffebldConstantArray
name|ptr
decl_stmt|;
switch|switch
condition|(
name|bt
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|ptr
operator|.
name|integer1
operator|=
name|malloc_new_zkp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"ffebldConstantArray"
argument_list|,
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|ffetargetInteger1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|ptr
operator|.
name|integer2
operator|=
name|malloc_new_zkp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"ffebldConstantArray"
argument_list|,
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|ffetargetInteger2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|ptr
operator|.
name|integer3
operator|=
name|malloc_new_zkp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"ffebldConstantArray"
argument_list|,
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|ffetargetInteger3
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|ptr
operator|.
name|integer4
operator|=
name|malloc_new_zkp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"ffebldConstantArray"
argument_list|,
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|ffetargetInteger4
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad INTEGER kindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|ptr
operator|.
name|logical1
operator|=
name|malloc_new_zkp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"ffebldConstantArray"
argument_list|,
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|ffetargetLogical1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|ptr
operator|.
name|logical2
operator|=
name|malloc_new_zkp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"ffebldConstantArray"
argument_list|,
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|ffetargetLogical2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|ptr
operator|.
name|logical3
operator|=
name|malloc_new_zkp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"ffebldConstantArray"
argument_list|,
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|ffetargetLogical3
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|ptr
operator|.
name|logical4
operator|=
name|malloc_new_zkp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"ffebldConstantArray"
argument_list|,
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|ffetargetLogical4
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad LOGICAL kindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|ptr
operator|.
name|real1
operator|=
name|malloc_new_zkp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"ffebldConstantArray"
argument_list|,
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|ffetargetReal1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|ptr
operator|.
name|real2
operator|=
name|malloc_new_zkp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"ffebldConstantArray"
argument_list|,
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|ffetargetReal2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|ptr
operator|.
name|real3
operator|=
name|malloc_new_zkp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"ffebldConstantArray"
argument_list|,
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|ffetargetReal3
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad REAL kindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|ptr
operator|.
name|complex1
operator|=
name|malloc_new_zkp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"ffebldConstantArray"
argument_list|,
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|ffetargetComplex1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|ptr
operator|.
name|complex2
operator|=
name|malloc_new_zkp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"ffebldConstantArray"
argument_list|,
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|ffetargetComplex2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|ptr
operator|.
name|complex3
operator|=
name|malloc_new_zkp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"ffebldConstantArray"
argument_list|,
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|ffetargetComplex3
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad COMPLEX kindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
name|ptr
operator|.
name|character1
operator|=
name|malloc_new_zkp
argument_list|(
name|ffebld_constant_pool
argument_list|()
argument_list|,
literal|"ffebldConstantArray"
argument_list|,
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|ffetargetCharacterUnit1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad CHARACTER kindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad basictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* ffebld_constantarray_preparray -- Prepare for copy between arrays     See prototype.     Like _prepare, but the source is an array instead of a single-value    constant.  */
end_comment

begin_function
name|void
name|ffebld_constantarray_preparray
parameter_list|(
name|void
modifier|*
modifier|*
name|aptr
parameter_list|,
name|void
modifier|*
modifier|*
name|cptr
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|ffebldConstantArray
name|array
parameter_list|,
name|ffeinfoBasictype
name|abt
parameter_list|,
name|ffeinfoKindtype
name|akt
parameter_list|,
name|ffetargetOffset
name|offset
parameter_list|,
name|ffebldConstantArray
name|source_array
parameter_list|,
name|ffeinfoBasictype
name|cbt
parameter_list|,
name|ffeinfoKindtype
name|ckt
parameter_list|)
block|{
switch|switch
condition|(
name|abt
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|akt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|integer1
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|integer2
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|integer3
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|integer4
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad INTEGER akindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|akt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|logical1
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|logical2
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|logical3
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|logical4
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad LOGICAL akindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|akt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|real1
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|real2
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|real3
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad REAL akindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|akt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|complex1
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|complex2
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|complex3
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad COMPLEX akindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|akt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|character1
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad CHARACTER akindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad abasictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|cbt
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ckt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
operator|*
name|cptr
operator|=
name|source_array
operator|.
name|integer1
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|source_array
operator|.
name|integer1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
operator|*
name|cptr
operator|=
name|source_array
operator|.
name|integer2
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|source_array
operator|.
name|integer2
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
operator|*
name|cptr
operator|=
name|source_array
operator|.
name|integer3
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|source_array
operator|.
name|integer3
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
operator|*
name|cptr
operator|=
name|source_array
operator|.
name|integer4
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|source_array
operator|.
name|integer4
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad INTEGER ckindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|ckt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
operator|*
name|cptr
operator|=
name|source_array
operator|.
name|logical1
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|source_array
operator|.
name|logical1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
operator|*
name|cptr
operator|=
name|source_array
operator|.
name|logical2
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|source_array
operator|.
name|logical2
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
operator|*
name|cptr
operator|=
name|source_array
operator|.
name|logical3
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|source_array
operator|.
name|logical3
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
operator|*
name|cptr
operator|=
name|source_array
operator|.
name|logical4
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|source_array
operator|.
name|logical4
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad LOGICAL ckindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ckt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
operator|*
name|cptr
operator|=
name|source_array
operator|.
name|real1
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|source_array
operator|.
name|real1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
operator|*
name|cptr
operator|=
name|source_array
operator|.
name|real2
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|source_array
operator|.
name|real2
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
operator|*
name|cptr
operator|=
name|source_array
operator|.
name|real3
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|source_array
operator|.
name|real3
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad REAL ckindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ckt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
operator|*
name|cptr
operator|=
name|source_array
operator|.
name|complex1
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|source_array
operator|.
name|complex1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
operator|*
name|cptr
operator|=
name|source_array
operator|.
name|complex2
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|source_array
operator|.
name|complex2
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
operator|*
name|cptr
operator|=
name|source_array
operator|.
name|complex3
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|source_array
operator|.
name|complex3
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad COMPLEX ckindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|ckt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
operator|*
name|cptr
operator|=
name|source_array
operator|.
name|character1
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|source_array
operator|.
name|character1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad CHARACTER ckindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad cbasictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffebld_constantarray_prepare -- Prepare for copy between value and array     See prototype.     Like _put, but just returns the pointers to the beginnings of the    array and the constant and returns the size (the amount of info to    copy).  The idea is that the caller can use memcpy to accomplish the    same thing as _put (though slower), or the caller can use a different    function that swaps bytes, words, etc for a different target machine.    Also, the type of the array may be different from the type of the    constant; the array type is used to determine the meaning (scale) of    the offset field (to calculate the array pointer), the constant type is    used to determine the constant pointer and the size (amount of info to    copy).  */
end_comment

begin_function
name|void
name|ffebld_constantarray_prepare
parameter_list|(
name|void
modifier|*
modifier|*
name|aptr
parameter_list|,
name|void
modifier|*
modifier|*
name|cptr
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|ffebldConstantArray
name|array
parameter_list|,
name|ffeinfoBasictype
name|abt
parameter_list|,
name|ffeinfoKindtype
name|akt
parameter_list|,
name|ffetargetOffset
name|offset
parameter_list|,
name|ffebldConstantUnion
modifier|*
name|constant
parameter_list|,
name|ffeinfoBasictype
name|cbt
parameter_list|,
name|ffeinfoKindtype
name|ckt
parameter_list|)
block|{
switch|switch
condition|(
name|abt
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|akt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|integer1
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|integer2
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|integer3
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|integer4
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad INTEGER akindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|akt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|logical1
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|logical2
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|logical3
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|logical4
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad LOGICAL akindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|akt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|real1
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|real2
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|real3
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad REAL akindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|akt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|complex1
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|complex2
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|complex3
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad COMPLEX akindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|akt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
operator|*
name|aptr
operator|=
name|array
operator|.
name|character1
operator|+
name|offset
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad CHARACTER akindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad abasictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|cbt
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ckt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
operator|*
name|cptr
operator|=
operator|&
name|constant
operator|->
name|integer1
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
name|constant
operator|->
name|integer1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
operator|*
name|cptr
operator|=
operator|&
name|constant
operator|->
name|integer2
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
name|constant
operator|->
name|integer2
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
operator|*
name|cptr
operator|=
operator|&
name|constant
operator|->
name|integer3
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
name|constant
operator|->
name|integer3
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
operator|*
name|cptr
operator|=
operator|&
name|constant
operator|->
name|integer4
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
name|constant
operator|->
name|integer4
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad INTEGER ckindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|ckt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
operator|*
name|cptr
operator|=
operator|&
name|constant
operator|->
name|logical1
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
name|constant
operator|->
name|logical1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
operator|*
name|cptr
operator|=
operator|&
name|constant
operator|->
name|logical2
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
name|constant
operator|->
name|logical2
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
operator|*
name|cptr
operator|=
operator|&
name|constant
operator|->
name|logical3
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
name|constant
operator|->
name|logical3
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
operator|*
name|cptr
operator|=
operator|&
name|constant
operator|->
name|logical4
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
name|constant
operator|->
name|logical4
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad LOGICAL ckindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ckt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
operator|*
name|cptr
operator|=
operator|&
name|constant
operator|->
name|real1
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
name|constant
operator|->
name|real1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
operator|*
name|cptr
operator|=
operator|&
name|constant
operator|->
name|real2
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
name|constant
operator|->
name|real2
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
operator|*
name|cptr
operator|=
operator|&
name|constant
operator|->
name|real3
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
name|constant
operator|->
name|real3
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad REAL ckindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ckt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
operator|*
name|cptr
operator|=
operator|&
name|constant
operator|->
name|complex1
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
name|constant
operator|->
name|complex1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
operator|*
name|cptr
operator|=
operator|&
name|constant
operator|->
name|complex2
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
name|constant
operator|->
name|complex2
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
operator|*
name|cptr
operator|=
operator|&
name|constant
operator|->
name|complex3
expr_stmt|;
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
name|constant
operator|->
name|complex3
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad COMPLEX ckindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|ckt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
operator|*
name|cptr
operator|=
name|ffetarget_text_character1
argument_list|(
name|constant
operator|->
name|character1
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|ffetarget_length_character1
argument_list|(
name|constant
operator|->
name|character1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad CHARACTER ckindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad cbasictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffebld_constantarray_put -- Put a value into an array of constants     See prototype.  */
end_comment

begin_function
name|void
name|ffebld_constantarray_put
parameter_list|(
name|ffebldConstantArray
name|array
parameter_list|,
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|,
name|ffetargetOffset
name|offset
parameter_list|,
name|ffebldConstantUnion
name|constant
parameter_list|)
block|{
switch|switch
condition|(
name|bt
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
operator|*
operator|(
name|array
operator|.
name|integer1
operator|+
name|offset
operator|)
operator|=
name|constant
operator|.
name|integer1
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
operator|*
operator|(
name|array
operator|.
name|integer2
operator|+
name|offset
operator|)
operator|=
name|constant
operator|.
name|integer2
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
operator|*
operator|(
name|array
operator|.
name|integer3
operator|+
name|offset
operator|)
operator|=
name|constant
operator|.
name|integer3
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
operator|*
operator|(
name|array
operator|.
name|integer4
operator|+
name|offset
operator|)
operator|=
name|constant
operator|.
name|integer4
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad INTEGER kindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
operator|*
operator|(
name|array
operator|.
name|logical1
operator|+
name|offset
operator|)
operator|=
name|constant
operator|.
name|logical1
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
operator|*
operator|(
name|array
operator|.
name|logical2
operator|+
name|offset
operator|)
operator|=
name|constant
operator|.
name|logical2
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
operator|*
operator|(
name|array
operator|.
name|logical3
operator|+
name|offset
operator|)
operator|=
name|constant
operator|.
name|logical3
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
operator|*
operator|(
name|array
operator|.
name|logical4
operator|+
name|offset
operator|)
operator|=
name|constant
operator|.
name|logical4
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad LOGICAL kindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
operator|*
operator|(
name|array
operator|.
name|real1
operator|+
name|offset
operator|)
operator|=
name|constant
operator|.
name|real1
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
operator|*
operator|(
name|array
operator|.
name|real2
operator|+
name|offset
operator|)
operator|=
name|constant
operator|.
name|real2
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
operator|*
operator|(
name|array
operator|.
name|real3
operator|+
name|offset
operator|)
operator|=
name|constant
operator|.
name|real3
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad REAL kindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
operator|*
operator|(
name|array
operator|.
name|complex1
operator|+
name|offset
operator|)
operator|=
name|constant
operator|.
name|complex1
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
operator|*
operator|(
name|array
operator|.
name|complex2
operator|+
name|offset
operator|)
operator|=
name|constant
operator|.
name|complex2
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
operator|*
operator|(
name|array
operator|.
name|complex3
operator|+
name|offset
operator|)
operator|=
name|constant
operator|.
name|complex3
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad COMPLEX kindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
name|memcpy
argument_list|(
name|array
operator|.
name|character1
operator|+
name|offset
argument_list|,
name|ffetarget_text_character1
argument_list|(
name|constant
operator|.
name|character1
argument_list|)
argument_list|,
name|ffetarget_length_character1
argument_list|(
name|constant
operator|.
name|character1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad CHARACTER kindtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad basictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffebld_init_0 -- Initialize the module     ffebld_init_0();  */
end_comment

begin_function
name|void
name|ffebld_init_0
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|FFEBLD_op
operator|==
name|ARRAY_SIZE
argument_list|(
name|ffebld_op_string_
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|FFEBLD_op
operator|==
name|ARRAY_SIZE
argument_list|(
name|ffebld_arity_op_
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffebld_init_1 -- Initialize the module for a file     ffebld_init_1();  */
end_comment

begin_function
name|void
name|ffebld_init_1
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|FFEBLD_whereconstCURRENT_
operator|==
name|FFEBLD_whereconstFILE_
name|int
name|i
decl_stmt|;
if|#
directive|if
name|FFETARGET_okCHARACTER1
name|ffebld_constant_character1_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX1
name|ffebld_constant_complex1_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
name|ffebld_constant_complex2_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
name|ffebld_constant_complex3_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER1
name|ffebld_constant_integer1_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
name|ffebld_constant_integer2_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
name|ffebld_constant_integer3_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
name|ffebld_constant_integer4_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL1
name|ffebld_constant_logical1_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
name|ffebld_constant_logical2_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
name|ffebld_constant_logical3_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
name|ffebld_constant_logical4_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL1
name|ffebld_constant_real1_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
name|ffebld_constant_real2_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
name|ffebld_constant_real3_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|ffebld_constant_hollerith_
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FFEBLD_constTYPELESS_FIRST
init|;
name|i
operator|<=
name|FFEBLD_constTYPELESS_LAST
condition|;
operator|++
name|i
control|)
name|ffebld_constant_typeless_
index|[
name|i
operator|-
name|FFEBLD_constTYPELESS_FIRST
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffebld_init_2 -- Initialize the module     ffebld_init_2();  */
end_comment

begin_function
name|void
name|ffebld_init_2
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|FFEBLD_whereconstCURRENT_
operator|==
name|FFEBLD_whereconstPROGUNIT_
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|ffebld_pool_stack_
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|ffebld_pool_stack_
operator|.
name|pool
operator|=
name|ffe_pool_program_unit
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFEBLD_whereconstCURRENT_
operator|==
name|FFEBLD_whereconstPROGUNIT_
if|#
directive|if
name|FFETARGET_okCHARACTER1
name|ffebld_constant_character1_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX1
name|ffebld_constant_complex1_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
name|ffebld_constant_complex2_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
name|ffebld_constant_complex3_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER1
name|ffebld_constant_integer1_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
name|ffebld_constant_integer2_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
name|ffebld_constant_integer3_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
name|ffebld_constant_integer4_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL1
name|ffebld_constant_logical1_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
name|ffebld_constant_logical2_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
name|ffebld_constant_logical3_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
name|ffebld_constant_logical4_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL1
name|ffebld_constant_real1_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
name|ffebld_constant_real2_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
name|ffebld_constant_real3_
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|ffebld_constant_hollerith_
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FFEBLD_constTYPELESS_FIRST
init|;
name|i
operator|<=
name|FFEBLD_constTYPELESS_LAST
condition|;
operator|++
name|i
control|)
name|ffebld_constant_typeless_
index|[
name|i
operator|-
name|FFEBLD_constTYPELESS_FIRST
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffebld_list_length -- Return # of opITEMs in list     ffebld list;	 // Must be NULL or opITEM    ffebldListLength length;    length = ffebld_list_length(list);     Returns 0 if list is NULL, 1 if it's ffebld_trail is NULL, and so on.  */
end_comment

begin_function
name|ffebldListLength
name|ffebld_list_length
parameter_list|(
name|ffebld
name|list
parameter_list|)
block|{
name|ffebldListLength
name|length
decl_stmt|;
for|for
control|(
name|length
operator|=
literal|0
init|;
name|list
operator|!=
name|NULL
condition|;
operator|++
name|length
operator|,
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
empty_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* ffebld_new_accter -- Create an ffebld object that is an array     ffebld x;    ffebldConstantArray a;    ffebit b;    x = ffebld_new_accter(a,b);	*/
end_comment

begin_function
name|ffebld
name|ffebld_new_accter
parameter_list|(
name|ffebldConstantArray
name|a
parameter_list|,
name|ffebit
name|b
parameter_list|)
block|{
name|ffebld
name|x
decl_stmt|;
name|x
operator|=
name|ffebld_new
argument_list|()
expr_stmt|;
name|x
operator|->
name|op
operator|=
name|FFEBLD_opACCTER
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|accter
operator|.
name|array
operator|=
name|a
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|accter
operator|.
name|bits
operator|=
name|b
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|accter
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* ffebld_new_arrter -- Create an ffebld object that is an array     ffebld x;    ffebldConstantArray a;    ffetargetOffset size;    x = ffebld_new_arrter(a,size);  */
end_comment

begin_function
name|ffebld
name|ffebld_new_arrter
parameter_list|(
name|ffebldConstantArray
name|a
parameter_list|,
name|ffetargetOffset
name|size
parameter_list|)
block|{
name|ffebld
name|x
decl_stmt|;
name|x
operator|=
name|ffebld_new
argument_list|()
expr_stmt|;
name|x
operator|->
name|op
operator|=
name|FFEBLD_opARRTER
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|arrter
operator|.
name|array
operator|=
name|a
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|arrter
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|arrter
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* ffebld_new_conter_with_orig -- Create an ffebld object that is a constant     ffebld x;    ffebldConstant c;    x = ffebld_new_conter_with_orig(c,NULL);  */
end_comment

begin_function
name|ffebld
name|ffebld_new_conter_with_orig
parameter_list|(
name|ffebldConstant
name|c
parameter_list|,
name|ffebld
name|o
parameter_list|)
block|{
name|ffebld
name|x
decl_stmt|;
name|x
operator|=
name|ffebld_new
argument_list|()
expr_stmt|;
name|x
operator|->
name|op
operator|=
name|FFEBLD_opCONTER
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|conter
operator|.
name|expr
operator|=
name|c
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|conter
operator|.
name|orig
operator|=
name|o
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|conter
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* ffebld_new_item -- Create an ffebld item object     ffebld x,y,z;    x = ffebld_new_item(y,z);  */
end_comment

begin_function
name|ffebld
name|ffebld_new_item
parameter_list|(
name|ffebld
name|head
parameter_list|,
name|ffebld
name|trail
parameter_list|)
block|{
name|ffebld
name|x
decl_stmt|;
name|x
operator|=
name|ffebld_new
argument_list|()
expr_stmt|;
name|x
operator|->
name|op
operator|=
name|FFEBLD_opITEM
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|item
operator|.
name|head
operator|=
name|head
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|item
operator|.
name|trail
operator|=
name|trail
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* ffebld_new_labter -- Create an ffebld object that is a label     ffebld x;    ffelab l;    x = ffebld_new_labter(c);  */
end_comment

begin_function
name|ffebld
name|ffebld_new_labter
parameter_list|(
name|ffelab
name|l
parameter_list|)
block|{
name|ffebld
name|x
decl_stmt|;
name|x
operator|=
name|ffebld_new
argument_list|()
expr_stmt|;
name|x
operator|->
name|op
operator|=
name|FFEBLD_opLABTER
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|labter
operator|=
name|l
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* ffebld_new_labtok -- Create object that is a label's NUMBER token     ffebld x;    ffelexToken t;    x = ffebld_new_labter(c);     Like the other ffebld_new_ functions, the    supplied argument is stored exactly as is: ffelex_token_use is NOT    called, so the token is "consumed", if one is indeed supplied (it may    be NULL).  */
end_comment

begin_function
name|ffebld
name|ffebld_new_labtok
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebld
name|x
decl_stmt|;
name|x
operator|=
name|ffebld_new
argument_list|()
expr_stmt|;
name|x
operator|->
name|op
operator|=
name|FFEBLD_opLABTOK
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|labtok
operator|=
name|t
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* ffebld_new_none -- Create an ffebld object with no arguments     ffebld x;    x = ffebld_new_none(FFEBLD_opWHATEVER);  */
end_comment

begin_function
name|ffebld
name|ffebld_new_none
parameter_list|(
name|ffebldOp
name|o
parameter_list|)
block|{
name|ffebld
name|x
decl_stmt|;
name|x
operator|=
name|ffebld_new
argument_list|()
expr_stmt|;
name|x
operator|->
name|op
operator|=
name|o
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* ffebld_new_one -- Create an ffebld object with one argument     ffebld x,y;    x = ffebld_new_one(FFEBLD_opWHATEVER,y);  */
end_comment

begin_function
name|ffebld
name|ffebld_new_one
parameter_list|(
name|ffebldOp
name|o
parameter_list|,
name|ffebld
name|left
parameter_list|)
block|{
name|ffebld
name|x
decl_stmt|;
name|x
operator|=
name|ffebld_new
argument_list|()
expr_stmt|;
name|x
operator|->
name|op
operator|=
name|o
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|nonter
operator|.
name|left
operator|=
name|left
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|nonter
operator|.
name|hook
operator|=
name|FFECOM_nonterNULL
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* ffebld_new_symter -- Create an ffebld object that is a symbol     ffebld x;    ffesymbol s;    ffeintrinGen gen;	// Generic intrinsic id, if any    ffeintrinSpec spec;	// Specific intrinsic id, if any    ffeintrinImp imp;	// Implementation intrinsic id, if any    x = ffebld_new_symter (s, gen, spec, imp);  */
end_comment

begin_function
name|ffebld
name|ffebld_new_symter
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffeintrinGen
name|gen
parameter_list|,
name|ffeintrinSpec
name|spec
parameter_list|,
name|ffeintrinImp
name|imp
parameter_list|)
block|{
name|ffebld
name|x
decl_stmt|;
name|x
operator|=
name|ffebld_new
argument_list|()
expr_stmt|;
name|x
operator|->
name|op
operator|=
name|FFEBLD_opSYMTER
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|symter
operator|.
name|symbol
operator|=
name|s
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|symter
operator|.
name|generic
operator|=
name|gen
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|symter
operator|.
name|specific
operator|=
name|spec
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|symter
operator|.
name|implementation
operator|=
name|imp
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|symter
operator|.
name|do_iter
operator|=
name|FALSE
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* ffebld_new_two -- Create an ffebld object with two arguments     ffebld x,y,z;    x = ffebld_new_two(FFEBLD_opWHATEVER,y,z);  */
end_comment

begin_function
name|ffebld
name|ffebld_new_two
parameter_list|(
name|ffebldOp
name|o
parameter_list|,
name|ffebld
name|left
parameter_list|,
name|ffebld
name|right
parameter_list|)
block|{
name|ffebld
name|x
decl_stmt|;
name|x
operator|=
name|ffebld_new
argument_list|()
expr_stmt|;
name|x
operator|->
name|op
operator|=
name|o
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|nonter
operator|.
name|left
operator|=
name|left
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|nonter
operator|.
name|right
operator|=
name|right
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|nonter
operator|.
name|hook
operator|=
name|FFECOM_nonterNULL
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* ffebld_pool_pop -- Pop ffebld's pool stack     ffebld_pool_pop();  */
end_comment

begin_function
name|void
name|ffebld_pool_pop
parameter_list|(
name|void
parameter_list|)
block|{
name|ffebldPoolstack_
name|ps
decl_stmt|;
name|assert
argument_list|(
name|ffebld_pool_stack_
operator|.
name|next
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ps
operator|=
name|ffebld_pool_stack_
operator|.
name|next
expr_stmt|;
name|ffebld_pool_stack_
operator|.
name|next
operator|=
name|ps
operator|->
name|next
expr_stmt|;
name|ffebld_pool_stack_
operator|.
name|pool
operator|=
name|ps
operator|->
name|pool
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
name|ps
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ps
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffebld_pool_push -- Push ffebld's pool stack     ffebld_pool_push();	*/
end_comment

begin_function
name|void
name|ffebld_pool_push
parameter_list|(
name|mallocPool
name|pool
parameter_list|)
block|{
name|ffebldPoolstack_
name|ps
decl_stmt|;
name|ps
operator|=
name|malloc_new_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"Pool stack"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ps
argument_list|)
argument_list|)
expr_stmt|;
name|ps
operator|->
name|next
operator|=
name|ffebld_pool_stack_
operator|.
name|next
expr_stmt|;
name|ps
operator|->
name|pool
operator|=
name|ffebld_pool_stack_
operator|.
name|pool
expr_stmt|;
name|ffebld_pool_stack_
operator|.
name|next
operator|=
name|ps
expr_stmt|;
name|ffebld_pool_stack_
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffebld_op_string -- Return short string describing op     ffebldOp o;    ffebld_op_string(o);     Returns a short string (uppercase) containing the name of the op.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ffebld_op_string
parameter_list|(
name|ffebldOp
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|>=
name|ARRAY_SIZE
argument_list|(
name|ffebld_op_string_
argument_list|)
condition|)
return|return
literal|"?\?\?"
return|;
return|return
name|ffebld_op_string_
index|[
name|o
index|]
return|;
block|}
end_function

begin_comment
comment|/* ffebld_size_max -- Return maximum possible size of CHARACTER-type expr     ffetargetCharacterSize sz;    ffebld b;    sz = ffebld_size_max (b);     Like ffebld_size_known, but if that would return NONE and the expression    is opSUBSTR, opCONVERT, opPAREN, or opCONCATENATE, returns ffebld_size_max    of the subexpression(s).  */
end_comment

begin_function
name|ffetargetCharacterSize
name|ffebld_size_max
parameter_list|(
name|ffebld
name|b
parameter_list|)
block|{
name|ffetargetCharacterSize
name|sz
decl_stmt|;
name|recurse
label|:
comment|/* :::::::::::::::::::: */
name|sz
operator|=
name|ffebld_size_known
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|!=
name|FFETARGET_charactersizeNONE
condition|)
return|return
name|sz
return|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|b
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opSUBSTR
case|:
case|case
name|FFEBLD_opCONVERT
case|:
case|case
name|FFEBLD_opPAREN
case|:
name|b
operator|=
name|ffebld_left
argument_list|(
name|b
argument_list|)
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEBLD_opCONCATENATE
case|:
name|sz
operator|=
name|ffebld_size_max
argument_list|(
name|ffebld_left
argument_list|(
name|b
argument_list|)
argument_list|)
operator|+
name|ffebld_size_max
argument_list|(
name|ffebld_right
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sz
return|;
default|default:
return|return
name|sz
return|;
block|}
block|}
end_function

end_unit

