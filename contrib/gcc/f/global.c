begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* global.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995, 1997 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:     Description:       Manages information kept across individual program units within a single       source file.  This includes reporting errors when a name is defined       multiple times (for example, two program units named FOO) and when a       COMMON block is given initial data in more than one program unit.     Modifications: */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_if
if|#
directive|if
name|FFEGLOBAL_ENABLED
end_if

begin_decl_stmt
specifier|static
name|ffenameSpace
name|ffeglobal_filewide_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ffeglobal_type_string_
index|[]
init|=
block|{
index|[
name|FFEGLOBAL_typeNONE
index|]
literal|"??"
block|,
index|[
name|FFEGLOBAL_typeMAIN
index|]
literal|"main program"
block|,
index|[
name|FFEGLOBAL_typeEXT
index|]
literal|"external"
block|,
index|[
name|FFEGLOBAL_typeSUBR
index|]
literal|"subroutine"
block|,
index|[
name|FFEGLOBAL_typeFUNC
index|]
literal|"function"
block|,
index|[
name|FFEGLOBAL_typeBDATA
index|]
literal|"block data"
block|,
index|[
name|FFEGLOBAL_typeCOMMON
index|]
literal|"common block"
block|,
index|[
name|FFEGLOBAL_typeANY
index|]
literal|"?any?"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_comment
comment|/* Internal macros. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Call given fn with all globals     ffeglobal (*fn)(ffeglobal g);    ffeglobal_drive(fn);	 */
end_comment

begin_if
if|#
directive|if
name|FFEGLOBAL_ENABLED
end_if

begin_function
name|void
name|ffeglobal_drive
parameter_list|(
name|ffeglobal
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|ffeglobal
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|ffeglobal_filewide_
operator|!=
name|NULL
condition|)
name|ffename_space_drive_global
argument_list|(
name|ffeglobal_filewide_
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffeglobal_new_ -- Make new global     ffename n;    ffeglobal g;    g = ffeglobal_new_(n);  */
end_comment

begin_if
if|#
directive|if
name|FFEGLOBAL_ENABLED
end_if

begin_function
specifier|static
name|ffeglobal
name|ffeglobal_new_
parameter_list|(
name|ffename
name|n
parameter_list|)
block|{
name|ffeglobal
name|g
decl_stmt|;
name|assert
argument_list|(
name|n
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
name|ffeglobal
operator|)
name|malloc_new_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFEGLOBAL"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|g
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|n
operator|=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|FFECOM_globalHOOK
name|g
operator|->
name|hook
operator|=
name|FFECOM_globalNULL
expr_stmt|;
endif|#
directive|endif
name|g
operator|->
name|tick
operator|=
literal|0
expr_stmt|;
name|ffename_set_global
argument_list|(
name|n
argument_list|,
name|g
argument_list|)
expr_stmt|;
return|return
name|g
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffeglobal_init_1 -- Initialize per file     ffeglobal_init_1();	*/
end_comment

begin_function
name|void
name|ffeglobal_init_1
parameter_list|()
block|{
if|#
directive|if
name|FFEGLOBAL_ENABLED
if|if
condition|(
name|ffeglobal_filewide_
operator|!=
name|NULL
condition|)
name|ffename_space_kill
argument_list|(
name|ffeglobal_filewide_
argument_list|)
expr_stmt|;
name|ffeglobal_filewide_
operator|=
name|ffename_space_new
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffeglobal_init_common -- Initial value specified for common block     ffesymbol s;	 // the ffesymbol for the common block    ffelexToken t;  // the token with the point of initialization    ffeglobal_init_common(s,t);     For back ends where file-wide global symbols are not maintained, does    nothing.  Otherwise, makes sure this common block hasn't already been    initialized in a previous program unit, and flag that it's been    initialized in this one.  */
end_comment

begin_function
name|void
name|ffeglobal_init_common
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
if|#
directive|if
name|FFEGLOBAL_ENABLED
name|ffeglobal
name|g
decl_stmt|;
name|g
operator|=
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|==
name|NULL
operator|)
operator|||
operator|(
name|g
operator|->
name|type
operator|!=
name|FFEGLOBAL_typeCOMMON
operator|)
condition|)
return|return;
if|if
condition|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeANY
condition|)
return|return;
if|if
condition|(
name|g
operator|->
name|tick
operator|==
name|ffe_count_2
condition|)
return|return;
if|if
condition|(
name|g
operator|->
name|tick
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|initt
operator|!=
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_COMMON_ALREADY_INIT
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|initt
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|initt
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
comment|/* Complain about just one attempt to reinit per program unit, but 	 continue referring back to the first such successful attempt.  */
block|}
else|else
block|{
if|if
condition|(
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|blank
condition|)
block|{
comment|/* Not supposed to initialize blank common, though it works.  */
name|ffebad_start
argument_list|(
name|FFEBAD_COMMON_BLANK_INIT
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|initt
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|g
operator|->
name|tick
operator|=
name|ffe_count_2
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffeglobal_new_common -- New common block     ffesymbol s;	 // the ffesymbol for the new common block    ffelexToken t;  // the token with the name of the common block    bool blank;	// TRUE if blank common    ffeglobal_new_common(s,t,blank);     For back ends where file-wide global symbols are not maintained, does    nothing.  Otherwise, makes sure this symbol hasn't been seen before or    is known as a common block.	*/
end_comment

begin_function
name|void
name|ffeglobal_new_common
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|,
name|bool
name|blank
parameter_list|)
block|{
if|#
directive|if
name|FFEGLOBAL_ENABLED
name|ffename
name|n
decl_stmt|;
name|ffeglobal
name|g
decl_stmt|;
if|if
condition|(
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|n
operator|=
name|ffename_find
argument_list|(
name|ffeglobal_filewide_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|g
operator|=
name|ffename_global
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g
operator|=
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|g
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeANY
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|g
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|g
operator|->
name|type
operator|!=
name|FFEGLOBAL_typeNONE
operator|)
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeCOMMON
condition|)
block|{
comment|/* The names match, so the "blankness" should match too!  */
name|assert
argument_list|(
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|blank
operator|==
name|blank
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This global name has already been established, 	     but as something other than a common block.  */
if|if
condition|(
name|ffe_is_globals
argument_list|()
operator|||
name|ffe_is_warn_globals
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|ffe_is_globals
argument_list|()
condition|?
name|FFEBAD_FILEWIDE_ALREADY_SEEN
else|:
name|FFEBAD_FILEWIDE_ALREADY_SEEN_W
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|g
operator|->
name|type
operator|=
name|FFEGLOBAL_typeANY
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|g
operator|=
name|ffeglobal_new_
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|g
operator|->
name|intrinsic
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g
operator|->
name|intrinsic
operator|&&
operator|!
name|g
operator|->
name|explicit_intrinsic
operator|&&
name|ffe_is_warn_globals
argument_list|()
condition|)
block|{
comment|/* Common name previously used as intrinsic.  Though it works, 	     warn, because the intrinsic reference might have been intended 	     as a ref to an external procedure, but g77's vast list of 	     intrinsics happened to snarf the name.  */
name|ffebad_start
argument_list|(
name|FFEBAD_INTRINSIC_GLOBAL
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"common block"
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"intrinsic"
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|g
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|g
operator|->
name|type
operator|=
name|FFEGLOBAL_typeCOMMON
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|have_pad
operator|=
name|FALSE
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|have_save
operator|=
name|FALSE
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|have_size
operator|=
name|FALSE
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|blank
operator|=
name|blank
expr_stmt|;
block|}
name|ffesymbol_set_global
argument_list|(
name|s
argument_list|,
name|g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffeglobal_new_progunit_ -- New program unit     ffesymbol s;	 // the ffesymbol for the new unit    ffelexToken t;  // the token with the name of the unit    ffeglobalType type;	// the type of the new unit    ffeglobal_new_progunit_(s,t,type);     For back ends where file-wide global symbols are not maintained, does    nothing.  Otherwise, makes sure this symbol hasn't been seen before.	 */
end_comment

begin_function
name|void
name|ffeglobal_new_progunit_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|,
name|ffeglobalType
name|type
parameter_list|)
block|{
if|#
directive|if
name|FFEGLOBAL_ENABLED
name|ffename
name|n
decl_stmt|;
name|ffeglobal
name|g
decl_stmt|;
name|n
operator|=
name|ffename_find
argument_list|(
name|ffeglobal_filewide_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|g
operator|=
name|ffename_global
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeANY
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|g
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeMAIN
operator|)
operator|||
operator|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeSUBR
operator|)
operator|||
operator|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeFUNC
operator|)
operator|||
operator|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeBDATA
operator|)
operator|)
operator|&&
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|defined
condition|)
block|{
comment|/* This program unit has already been defined.  */
if|if
condition|(
name|ffe_is_globals
argument_list|()
operator|||
name|ffe_is_warn_globals
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|ffe_is_globals
argument_list|()
condition|?
name|FFEBAD_FILEWIDE_ALREADY_SEEN
else|:
name|FFEBAD_FILEWIDE_ALREADY_SEEN_W
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|g
operator|->
name|type
operator|=
name|FFEGLOBAL_typeANY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|g
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|g
operator|->
name|type
operator|!=
name|FFEGLOBAL_typeNONE
operator|)
operator|&&
operator|(
name|g
operator|->
name|type
operator|!=
name|FFEGLOBAL_typeEXT
operator|)
operator|&&
operator|(
name|g
operator|->
name|type
operator|!=
name|type
operator|)
condition|)
block|{
comment|/* A reference to this program unit has been seen, but its 	 context disagrees about the new definition regarding 	 what kind of program unit it is.  (E.g. `call foo' followed 	 by `function foo'.)  But `external foo' alone doesn't mean 	 disagreement with either a function or subroutine, though 	 g77 normally interprets it as a request to force-load 	 a block data program unit by that name (to cope with libs).  */
if|if
condition|(
name|ffe_is_globals
argument_list|()
operator|||
name|ffe_is_warn_globals
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|ffe_is_globals
argument_list|()
condition|?
name|FFEBAD_FILEWIDE_DISAGREEMENT
else|:
name|FFEBAD_FILEWIDE_DISAGREEMENT_W
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffeglobal_type_string_
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffeglobal_type_string_
index|[
name|g
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|g
operator|->
name|type
operator|=
name|FFEGLOBAL_typeANY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|g
operator|=
name|ffeglobal_new_
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|g
operator|->
name|intrinsic
operator|=
name|FALSE
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
operator|=
operator|-
literal|1
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|other_t
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_basictypeNONE
operator|)
operator|&&
operator|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeFUNC
operator|)
operator|&&
operator|(
operator|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|!=
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|bt
operator|)
operator|||
operator|(
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
operator|!=
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|kt
operator|)
operator|||
operator|(
operator|(
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
operator|!=
name|FFETARGET_charactersizeNONE
operator|)
operator|&&
operator|(
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
operator|!=
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|sz
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* The previous reference and this new function definition 	     disagree about the type of the function.  I (Burley) think 	     this rarely occurs, because when this code is reached, 	     the type info doesn't appear to be filled in yet.  */
if|if
condition|(
name|ffe_is_globals
argument_list|()
operator|||
name|ffe_is_warn_globals
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|ffe_is_globals
argument_list|()
condition|?
name|FFEBAD_FILEWIDE_TYPE_MISMATCH
else|:
name|FFEBAD_FILEWIDE_TYPE_MISMATCH_W
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|g
operator|->
name|type
operator|=
name|FFEGLOBAL_typeANY
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|g
operator|->
name|intrinsic
operator|&&
operator|!
name|g
operator|->
name|explicit_intrinsic
operator|&&
name|ffe_is_warn_globals
argument_list|()
condition|)
block|{
comment|/* This name, previously used as an intrinsic, now is known 	     to also be a global procedure name.  Warn, since the previous 	     use as an intrinsic might have been intended to refer to 	     this procedure.  */
name|ffebad_start
argument_list|(
name|FFEBAD_INTRINSIC_GLOBAL
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"global"
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"intrinsic"
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|g
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|->
name|tick
operator|==
literal|0
operator|)
operator|||
operator|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|bt
operator|==
name|FFEINFO_basictypeNONE
operator|)
operator|||
operator|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|kt
operator|==
name|FFEINFO_kindtypeNONE
operator|)
condition|)
block|{
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|bt
operator|=
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|kt
operator|=
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|sz
operator|=
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* If there's a known disagreement about the kind of program 	 unit, then don't even bother tracking arglist argreement.  */
if|if
condition|(
operator|(
name|g
operator|->
name|tick
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|g
operator|->
name|type
operator|!=
name|type
operator|)
condition|)
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
operator|=
operator|-
literal|1
expr_stmt|;
name|g
operator|->
name|tick
operator|=
name|ffe_count_2
expr_stmt|;
name|g
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|defined
operator|=
name|TRUE
expr_stmt|;
block|}
name|ffesymbol_set_global
argument_list|(
name|s
argument_list|,
name|g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffeglobal_pad_common -- Check initial padding of common area     ffesymbol s;	 // the common area    ffetargetAlign pad;	// the initial padding    ffeglobal_pad_common(s,pad,ffesymbol_where_line(s), 	 ffesymbol_where_column(s));     In global-enabled mode, make sure the padding agrees with any existing    padding established for the common area, otherwise complain.    In global-disabled mode, warn about nonzero padding.	 */
end_comment

begin_function
name|void
name|ffeglobal_pad_common
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffetargetAlign
name|pad
parameter_list|,
name|ffewhereLine
name|wl
parameter_list|,
name|ffewhereColumn
name|wc
parameter_list|)
block|{
if|#
directive|if
name|FFEGLOBAL_ENABLED
name|ffeglobal
name|g
decl_stmt|;
name|g
operator|=
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|==
name|NULL
operator|)
operator|||
operator|(
name|g
operator|->
name|type
operator|!=
name|FFEGLOBAL_typeCOMMON
operator|)
condition|)
return|return;
comment|/* Let someone else catch this! */
if|if
condition|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeANY
condition|)
return|return;
if|if
condition|(
operator|!
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|have_pad
condition|)
block|{
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|have_pad
operator|=
name|TRUE
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|pad
operator|=
name|pad
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|pad_where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|wl
argument_list|)
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|pad_where_col
operator|=
name|ffewhere_column_use
argument_list|(
name|wc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
block|{
name|char
name|padding
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
operator|&
name|padding
index|[
literal|0
index|]
argument_list|,
literal|"%"
name|ffetargetAlign_f
literal|"u"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_COMMON_INIT_PAD
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|padding
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
operator|(
name|pad
operator|==
literal|1
operator|)
condition|?
name|FFECOM_SIZE_UNIT
else|:
name|FFECOM_SIZE_UNITS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|wl
argument_list|,
name|wc
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|pad
operator|!=
name|pad
condition|)
block|{
name|char
name|padding_1
index|[
literal|20
index|]
decl_stmt|;
name|char
name|padding_2
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
operator|&
name|padding_1
index|[
literal|0
index|]
argument_list|,
literal|"%"
name|ffetargetAlign_f
literal|"u"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|padding_2
index|[
literal|0
index|]
argument_list|,
literal|"%"
name|ffetargetAlign_f
literal|"u"
argument_list|,
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|pad
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_COMMON_DIFF_PAD
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|padding_1
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|wl
argument_list|,
name|wc
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|padding_2
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
operator|(
name|pad
operator|==
literal|1
operator|)
condition|?
name|FFECOM_SIZE_UNIT
else|:
name|FFECOM_SIZE_UNITS
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
operator|(
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|pad
operator|==
literal|1
operator|)
condition|?
name|FFECOM_SIZE_UNIT
else|:
name|FFECOM_SIZE_UNITS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|pad_where_line
argument_list|,
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|pad_where_col
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|pad
operator|<
name|pad
condition|)
block|{
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|pad
operator|=
name|pad
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|pad_where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|wl
argument_list|)
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|pad_where_col
operator|=
name|ffewhere_column_use
argument_list|(
name|wc
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Collect info for a global's argument.  */
end_comment

begin_function
name|void
name|ffeglobal_proc_def_arg
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|int
name|argno
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ffeglobalArgSummary
name|as
parameter_list|,
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|,
name|bool
name|array
parameter_list|)
block|{
name|ffeglobal
name|g
init|=
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|ffeglobalArgInfo_
name|ai
decl_stmt|;
name|assert
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeANY
condition|)
return|return;
name|assert
argument_list|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|argno
operator|>=
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
condition|)
return|return;
comment|/* Already complained about this discrepancy. */
name|ai
operator|=
operator|&
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|arg_info
index|[
name|argno
index|]
expr_stmt|;
comment|/* Maybe warn about previous references.  */
if|if
condition|(
operator|(
name|ai
operator|->
name|t
operator|!=
name|NULL
operator|)
operator|&&
name|ffe_is_warn_globals
argument_list|()
condition|)
block|{
specifier|const
name|char
modifier|*
name|refwhy
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|defwhy
init|=
name|NULL
decl_stmt|;
name|bool
name|warn
init|=
name|FALSE
decl_stmt|;
switch|switch
condition|(
name|as
condition|)
block|{
case|case
name|FFEGLOBAL_argsummaryREF
case|:
if|if
condition|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryREF
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryNONE
operator|)
operator|&&
operator|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryDESCR
operator|)
comment|/* Choose better message. */
operator|||
operator|(
name|ai
operator|->
name|bt
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
operator|||
operator|(
name|ai
operator|->
name|bt
operator|==
name|bt
operator|)
operator|)
condition|)
block|{
name|warn
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"passed by reference"
expr_stmt|;
block|}
break|break;
case|case
name|FFEGLOBAL_argsummaryDESCR
case|:
if|if
condition|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryDESCR
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryNONE
operator|)
operator|&&
operator|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryREF
operator|)
comment|/* Choose better message. */
operator|||
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
operator|||
operator|(
name|ai
operator|->
name|bt
operator|==
name|bt
operator|)
operator|)
condition|)
block|{
name|warn
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"passed by descriptor"
expr_stmt|;
block|}
break|break;
case|case
name|FFEGLOBAL_argsummaryPROC
case|:
if|if
condition|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryPROC
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummarySUBR
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryFUNC
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryNONE
operator|)
condition|)
block|{
name|warn
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"a procedure"
expr_stmt|;
block|}
break|break;
case|case
name|FFEGLOBAL_argsummarySUBR
case|:
if|if
condition|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryPROC
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummarySUBR
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryNONE
operator|)
condition|)
block|{
name|warn
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"a subroutine"
expr_stmt|;
block|}
break|break;
case|case
name|FFEGLOBAL_argsummaryFUNC
case|:
if|if
condition|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryPROC
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryFUNC
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryNONE
operator|)
condition|)
block|{
name|warn
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"a function"
expr_stmt|;
block|}
break|break;
case|case
name|FFEGLOBAL_argsummaryALTRTN
case|:
if|if
condition|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryALTRTN
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryNONE
operator|)
condition|)
block|{
name|warn
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"an alternate-return label"
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|refwhy
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|defwhy
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* Fill in the def info.  */
switch|switch
condition|(
name|ai
operator|->
name|as
condition|)
block|{
case|case
name|FFEGLOBAL_argsummaryNONE
case|:
name|defwhy
operator|=
literal|"omitted"
expr_stmt|;
break|break;
case|case
name|FFEGLOBAL_argsummaryVAL
case|:
name|defwhy
operator|=
literal|"passed by value"
expr_stmt|;
break|break;
case|case
name|FFEGLOBAL_argsummaryREF
case|:
name|defwhy
operator|=
literal|"passed by reference"
expr_stmt|;
break|break;
case|case
name|FFEGLOBAL_argsummaryDESCR
case|:
name|defwhy
operator|=
literal|"passed by descriptor"
expr_stmt|;
break|break;
case|case
name|FFEGLOBAL_argsummaryPROC
case|:
name|defwhy
operator|=
literal|"a procedure"
expr_stmt|;
break|break;
case|case
name|FFEGLOBAL_argsummarySUBR
case|:
name|defwhy
operator|=
literal|"a subroutine"
expr_stmt|;
break|break;
case|case
name|FFEGLOBAL_argsummaryFUNC
case|:
name|defwhy
operator|=
literal|"a function"
expr_stmt|;
break|break;
case|case
name|FFEGLOBAL_argsummaryALTRTN
case|:
name|defwhy
operator|=
literal|"an alternate-return label"
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case FFEGLOBAL_argsummaryPTR: 	      defwhy = "a pointer"; 	      break;
endif|#
directive|endif
default|default:
name|defwhy
operator|=
literal|"???"
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|warn
operator|&&
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeHOLLERITH
operator|)
operator|&&
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeTYPELESS
operator|)
operator|&&
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeNONE
operator|)
operator|&&
operator|(
name|ai
operator|->
name|bt
operator|!=
name|FFEINFO_basictypeHOLLERITH
operator|)
operator|&&
operator|(
name|ai
operator|->
name|bt
operator|!=
name|FFEINFO_basictypeTYPELESS
operator|)
operator|&&
operator|(
name|ai
operator|->
name|bt
operator|!=
name|FFEINFO_basictypeNONE
operator|)
condition|)
block|{
comment|/* Check types.  */
if|if
condition|(
operator|(
name|bt
operator|!=
name|ai
operator|->
name|bt
operator|)
operator|&&
operator|(
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|||
operator|(
name|ai
operator|->
name|bt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|)
operator|&&
operator|(
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|||
operator|(
name|ai
operator|->
name|bt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|)
condition|)
block|{
name|warn
operator|=
name|TRUE
expr_stmt|;
comment|/* We can cope with these differences. */
name|refwhy
operator|=
literal|"one type"
expr_stmt|;
name|defwhy
operator|=
literal|"some other type"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|warn
operator|&&
operator|(
name|kt
operator|!=
name|ai
operator|->
name|kt
operator|)
condition|)
block|{
name|warn
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"one precision"
expr_stmt|;
name|defwhy
operator|=
literal|"some other precision"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|warn
condition|)
block|{
name|char
name|num
index|[
literal|60
index|]
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|sprintf
argument_list|(
operator|&
name|num
index|[
literal|0
index|]
argument_list|,
literal|"%d"
argument_list|,
name|argno
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|<
literal|30
condition|)
name|sprintf
argument_list|(
operator|&
name|num
index|[
literal|0
index|]
argument_list|,
literal|"%d (named `%s')"
argument_list|,
name|argno
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
operator|&
name|num
index|[
literal|0
index|]
argument_list|,
literal|"%d (named `%.*s...')"
argument_list|,
name|argno
operator|+
literal|1
argument_list|,
literal|30
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|ffebad_start
argument_list|(
name|FFEBAD_FILEWIDE_ARG_W
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|refwhy
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|defwhy
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ai
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ai
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Define this argument.  */
if|if
condition|(
name|ai
operator|->
name|t
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ai
operator|->
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|as
operator|!=
name|FFEGLOBAL_argsummaryPROC
operator|)
operator|||
operator|(
name|ai
operator|->
name|t
operator|==
name|NULL
operator|)
condition|)
name|ai
operator|->
name|as
operator|=
name|as
expr_stmt|;
comment|/* Otherwise leave SUBR/FUNC info intact. */
name|ai
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|g
operator|->
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|ai
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|ai
operator|->
name|name
operator|=
name|malloc_new_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"ffeglobalArgInfo_ name"
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ai
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|ai
operator|->
name|bt
operator|=
name|bt
expr_stmt|;
name|ai
operator|->
name|kt
operator|=
name|kt
expr_stmt|;
name|ai
operator|->
name|array
operator|=
name|array
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Collect info on #args a global accepts.  */
end_comment

begin_function
name|void
name|ffeglobal_proc_def_nargs
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|int
name|n_args
parameter_list|)
block|{
name|ffeglobal
name|g
init|=
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeANY
condition|)
return|return;
if|if
condition|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
operator|==
name|n_args
condition|)
return|return;
if|if
condition|(
name|ffe_is_warn_globals
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_FILEWIDE_NARGS_W
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
operator|>
name|n_args
condition|)
name|ffebad_string
argument_list|(
literal|"few"
argument_list|)
expr_stmt|;
else|else
name|ffebad_string
argument_list|(
literal|"many"
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|other_t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|other_t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* This is new info we can use in cross-checking future references      and a possible future definition.  */
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
operator|=
name|n_args
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|other_t
operator|=
name|NULL
expr_stmt|;
comment|/* No other reference yet. */
if|if
condition|(
name|n_args
operator|==
literal|0
condition|)
block|{
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|arg_info
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|arg_info
operator|=
operator|(
name|ffeglobalArgInfo_
operator|)
name|malloc_new_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"ffeglobalArgInfo_"
argument_list|,
name|n_args
operator|*
sizeof|sizeof
argument_list|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|arg_info
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|n_args
operator|--
operator|>
literal|0
condition|)
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|arg_info
index|[
name|n_args
index|]
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verify that the info for a global's argument is valid.  */
end_comment

begin_function
name|bool
name|ffeglobal_proc_ref_arg
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|int
name|argno
parameter_list|,
name|ffeglobalArgSummary
name|as
parameter_list|,
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|,
name|bool
name|array
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeglobal
name|g
init|=
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|ffeglobalArgInfo_
name|ai
decl_stmt|;
name|assert
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeANY
condition|)
return|return
name|FALSE
return|;
name|assert
argument_list|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|argno
operator|>=
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
condition|)
return|return
name|TRUE
return|;
comment|/* Already complained about this discrepancy. */
name|ai
operator|=
operator|&
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|arg_info
index|[
name|argno
index|]
expr_stmt|;
comment|/* Warn about previous references.  */
if|if
condition|(
name|ai
operator|->
name|t
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|refwhy
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|defwhy
init|=
name|NULL
decl_stmt|;
name|bool
name|fail
init|=
name|FALSE
decl_stmt|;
name|bool
name|warn
init|=
name|FALSE
decl_stmt|;
switch|switch
condition|(
name|as
condition|)
block|{
case|case
name|FFEGLOBAL_argsummaryNONE
case|:
if|if
condition|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|defined
condition|)
block|{
name|fail
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"omitted"
expr_stmt|;
name|defwhy
operator|=
literal|"not optional"
expr_stmt|;
block|}
break|break;
case|case
name|FFEGLOBAL_argsummaryVAL
case|:
if|if
condition|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryVAL
condition|)
block|{
name|fail
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"passed by value"
expr_stmt|;
block|}
break|break;
case|case
name|FFEGLOBAL_argsummaryREF
case|:
if|if
condition|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryREF
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryNONE
operator|)
operator|&&
operator|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryDESCR
operator|)
comment|/* Choose better message. */
operator|||
operator|(
name|ai
operator|->
name|bt
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
operator|||
operator|(
name|ai
operator|->
name|bt
operator|==
name|bt
operator|)
operator|)
condition|)
block|{
name|fail
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"passed by reference"
expr_stmt|;
block|}
break|break;
case|case
name|FFEGLOBAL_argsummaryDESCR
case|:
if|if
condition|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryDESCR
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryNONE
operator|)
operator|&&
operator|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryREF
operator|)
comment|/* Choose better message. */
operator|||
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
operator|||
operator|(
name|ai
operator|->
name|bt
operator|==
name|bt
operator|)
operator|)
condition|)
block|{
name|fail
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"passed by descriptor"
expr_stmt|;
block|}
break|break;
case|case
name|FFEGLOBAL_argsummaryPROC
case|:
if|if
condition|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryPROC
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummarySUBR
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryFUNC
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryNONE
operator|)
condition|)
block|{
name|fail
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"a procedure"
expr_stmt|;
block|}
break|break;
case|case
name|FFEGLOBAL_argsummarySUBR
case|:
if|if
condition|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryPROC
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummarySUBR
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryNONE
operator|)
condition|)
block|{
name|fail
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"a subroutine"
expr_stmt|;
block|}
break|break;
case|case
name|FFEGLOBAL_argsummaryFUNC
case|:
if|if
condition|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryPROC
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryFUNC
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryNONE
operator|)
condition|)
block|{
name|fail
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"a function"
expr_stmt|;
block|}
break|break;
case|case
name|FFEGLOBAL_argsummaryALTRTN
case|:
if|if
condition|(
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryALTRTN
operator|)
operator|&&
operator|(
name|ai
operator|->
name|as
operator|!=
name|FFEGLOBAL_argsummaryNONE
operator|)
condition|)
block|{
name|fail
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"an alternate-return label"
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
block|case FFEGLOBAL_argsummaryPTR: 	  if ((ai->as != FFEGLOBAL_argsummaryPTR)&& (ai->as != FFEGLOBAL_argsummaryNONE)) 	    { 	      fail = TRUE; 	      refwhy = "a pointer"; 	    } 	  break;
endif|#
directive|endif
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|refwhy
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|defwhy
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* Fill in the def info.  */
switch|switch
condition|(
name|ai
operator|->
name|as
condition|)
block|{
case|case
name|FFEGLOBAL_argsummaryNONE
case|:
name|defwhy
operator|=
literal|"omitted"
expr_stmt|;
break|break;
case|case
name|FFEGLOBAL_argsummaryVAL
case|:
name|defwhy
operator|=
literal|"passed by value"
expr_stmt|;
break|break;
case|case
name|FFEGLOBAL_argsummaryREF
case|:
name|defwhy
operator|=
literal|"passed by reference"
expr_stmt|;
break|break;
case|case
name|FFEGLOBAL_argsummaryDESCR
case|:
name|defwhy
operator|=
literal|"passed by descriptor"
expr_stmt|;
break|break;
case|case
name|FFEGLOBAL_argsummaryPROC
case|:
name|defwhy
operator|=
literal|"a procedure"
expr_stmt|;
break|break;
case|case
name|FFEGLOBAL_argsummarySUBR
case|:
name|defwhy
operator|=
literal|"a subroutine"
expr_stmt|;
break|break;
case|case
name|FFEGLOBAL_argsummaryFUNC
case|:
name|defwhy
operator|=
literal|"a function"
expr_stmt|;
break|break;
case|case
name|FFEGLOBAL_argsummaryALTRTN
case|:
name|defwhy
operator|=
literal|"an alternate-return label"
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case FFEGLOBAL_argsummaryPTR: 	      defwhy = "a pointer"; 	      break;
endif|#
directive|endif
default|default:
name|defwhy
operator|=
literal|"???"
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|fail
operator|&&
operator|!
name|warn
operator|&&
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeHOLLERITH
operator|)
operator|&&
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeTYPELESS
operator|)
operator|&&
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeNONE
operator|)
operator|&&
operator|(
name|ai
operator|->
name|bt
operator|!=
name|FFEINFO_basictypeHOLLERITH
operator|)
operator|&&
operator|(
name|ai
operator|->
name|bt
operator|!=
name|FFEINFO_basictypeNONE
operator|)
operator|&&
operator|(
name|ai
operator|->
name|bt
operator|!=
name|FFEINFO_basictypeTYPELESS
operator|)
condition|)
block|{
comment|/* Check types.  */
if|if
condition|(
operator|(
name|bt
operator|!=
name|ai
operator|->
name|bt
operator|)
operator|&&
operator|(
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|||
operator|(
name|ai
operator|->
name|bt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|)
operator|&&
operator|(
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|||
operator|(
name|ai
operator|->
name|bt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|bt
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|ai
operator|->
name|bt
operator|==
name|FFEINFO_basictypeLOGICAL
operator|)
operator|)
operator|||
operator|(
operator|(
name|bt
operator|==
name|FFEINFO_basictypeLOGICAL
operator|)
operator|&&
operator|(
name|ai
operator|->
name|bt
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|)
condition|)
name|warn
operator|=
name|TRUE
expr_stmt|;
comment|/* We can cope with these differences. */
else|else
name|fail
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"one type"
expr_stmt|;
name|defwhy
operator|=
literal|"some other type"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fail
operator|&&
operator|!
name|warn
operator|&&
operator|(
name|kt
operator|!=
name|ai
operator|->
name|kt
operator|)
condition|)
block|{
name|fail
operator|=
name|TRUE
expr_stmt|;
name|refwhy
operator|=
literal|"one precision"
expr_stmt|;
name|defwhy
operator|=
literal|"some other precision"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fail
operator|&&
operator|!
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|defined
condition|)
block|{
comment|/* No point failing if we're worried only about invocations.  */
name|fail
operator|=
name|FALSE
expr_stmt|;
name|warn
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|fail
operator|&&
operator|!
name|ffe_is_globals
argument_list|()
condition|)
block|{
name|warn
operator|=
name|TRUE
expr_stmt|;
name|fail
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|fail
operator|||
operator|(
name|warn
operator|&&
name|ffe_is_warn_globals
argument_list|()
operator|)
condition|)
block|{
name|char
name|num
index|[
literal|60
index|]
decl_stmt|;
if|if
condition|(
name|ai
operator|->
name|name
operator|==
name|NULL
condition|)
name|sprintf
argument_list|(
operator|&
name|num
index|[
literal|0
index|]
argument_list|,
literal|"%d"
argument_list|,
name|argno
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strlen
argument_list|(
name|ai
operator|->
name|name
argument_list|)
operator|<
literal|30
condition|)
name|sprintf
argument_list|(
operator|&
name|num
index|[
literal|0
index|]
argument_list|,
literal|"%d (named `%s')"
argument_list|,
name|argno
operator|+
literal|1
argument_list|,
name|ai
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
operator|&
name|num
index|[
literal|0
index|]
argument_list|,
literal|"%d (named `%.*s...')"
argument_list|,
name|argno
operator|+
literal|1
argument_list|,
literal|30
argument_list|,
name|ai
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|ffebad_start
argument_list|(
name|fail
condition|?
name|FFEBAD_FILEWIDE_ARG
else|:
name|FFEBAD_FILEWIDE_ARG_W
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|refwhy
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|defwhy
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ai
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ai
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
operator|(
name|fail
condition|?
name|FALSE
else|:
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|warn
condition|)
return|return
name|TRUE
return|;
block|}
comment|/* Define this argument.  */
if|if
condition|(
name|ai
operator|->
name|t
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ai
operator|->
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|as
operator|!=
name|FFEGLOBAL_argsummaryPROC
operator|)
operator|||
operator|(
name|ai
operator|->
name|t
operator|==
name|NULL
operator|)
condition|)
name|ai
operator|->
name|as
operator|=
name|as
expr_stmt|;
name|ai
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|g
operator|->
name|t
argument_list|)
expr_stmt|;
name|ai
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|ai
operator|->
name|bt
operator|=
name|bt
expr_stmt|;
name|ai
operator|->
name|kt
operator|=
name|kt
expr_stmt|;
name|ai
operator|->
name|array
operator|=
name|array
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bool
name|ffeglobal_proc_ref_nargs
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|int
name|n_args
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeglobal
name|g
init|=
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeANY
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
operator|==
name|n_args
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|defined
operator|&&
name|ffe_is_globals
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_FILEWIDE_NARGS
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
operator|>
name|n_args
condition|)
name|ffebad_string
argument_list|(
literal|"few"
argument_list|)
expr_stmt|;
else|else
name|ffebad_string
argument_list|(
literal|"many"
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|ffe_is_warn_globals
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_FILEWIDE_NARGS_W
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
operator|>
name|n_args
condition|)
name|ffebad_string
argument_list|(
literal|"few"
argument_list|)
expr_stmt|;
else|else
name|ffebad_string
argument_list|(
literal|"many"
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|TRUE
return|;
comment|/* Don't replace the info we already have. */
block|}
comment|/* This is new info we can use in cross-checking future references      and a possible future definition.  */
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
operator|=
name|n_args
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|other_t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Make this "the" place we found the global, since it has the most info.  */
if|if
condition|(
name|g
operator|->
name|t
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|g
operator|->
name|t
argument_list|)
expr_stmt|;
name|g
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_args
operator|==
literal|0
condition|)
block|{
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|arg_info
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|arg_info
operator|=
operator|(
name|ffeglobalArgInfo_
operator|)
name|malloc_new_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"ffeglobalArgInfo_"
argument_list|,
name|n_args
operator|*
sizeof|sizeof
argument_list|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|arg_info
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|n_args
operator|--
operator|>
literal|0
condition|)
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|arg_info
index|[
name|n_args
index|]
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return a global for a promoted symbol (one that has heretofore    been assumed to be local, but since discovered to be global).  */
end_comment

begin_function
name|ffeglobal
name|ffeglobal_promoted
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
if|#
directive|if
name|FFEGLOBAL_ENABLED
name|ffename
name|n
decl_stmt|;
name|ffeglobal
name|g
decl_stmt|;
name|assert
argument_list|(
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|=
name|ffename_find
argument_list|(
name|ffeglobal_filewide_
argument_list|,
name|ffename_token
argument_list|(
name|ffesymbol_name
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|=
name|ffename_global
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|g
return|;
else|#
directive|else
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Register a reference to an intrinsic.  Such a reference is always    valid, though a warning might be in order if the same name has    already been used for a global.  */
end_comment

begin_function
name|void
name|ffeglobal_ref_intrinsic
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|,
name|bool
name|explicit
parameter_list|)
block|{
if|#
directive|if
name|FFEGLOBAL_ENABLED
name|ffename
name|n
decl_stmt|;
name|ffeglobal
name|g
decl_stmt|;
if|if
condition|(
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|n
operator|=
name|ffename_find
argument_list|(
name|ffeglobal_filewide_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|g
operator|=
name|ffename_global
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g
operator|=
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|g
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeANY
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|g
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|g
operator|->
name|type
operator|!=
name|FFEGLOBAL_typeNONE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
operator|&&
operator|!
name|g
operator|->
name|intrinsic
operator|&&
name|ffe_is_warn_globals
argument_list|()
condition|)
block|{
comment|/* This name, previously used as a global, now is used 	     for an intrinsic.  Warn, since this new use as an 	     intrinsic might have been intended to refer to 	     the global procedure.  */
name|ffebad_start
argument_list|(
name|FFEBAD_INTRINSIC_GLOBAL
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"intrinsic"
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"global"
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|g
operator|=
name|ffeglobal_new_
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|g
operator|->
name|tick
operator|=
name|ffe_count_2
expr_stmt|;
name|g
operator|->
name|type
operator|=
name|FFEGLOBAL_typeNONE
expr_stmt|;
name|g
operator|->
name|intrinsic
operator|=
name|TRUE
expr_stmt|;
name|g
operator|->
name|explicit_intrinsic
operator|=
name|explicit
expr_stmt|;
name|g
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g
operator|->
name|intrinsic
operator|&&
operator|(
name|explicit
operator|!=
name|g
operator|->
name|explicit_intrinsic
operator|)
operator|&&
operator|(
name|g
operator|->
name|tick
operator|!=
name|ffe_count_2
operator|)
operator|&&
name|ffe_is_warn_globals
argument_list|()
condition|)
block|{
comment|/* An earlier reference to this intrinsic disagrees with 	     this reference vis-a-vis explicit `intrinsic foo', 	     which suggests that the one relying on implicit 	     intrinsicacity might have actually intended to refer 	     to a global of the same name.  */
name|ffebad_start
argument_list|(
name|FFEBAD_INTRINSIC_EXPIMP
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|explicit
condition|?
literal|"explicit"
else|:
literal|"implicit"
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|explicit
condition|?
literal|"implicit"
else|:
literal|"explicit"
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|g
operator|->
name|intrinsic
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|explicit
condition|)
name|g
operator|->
name|explicit_intrinsic
operator|=
name|TRUE
expr_stmt|;
name|ffesymbol_set_global
argument_list|(
name|s
argument_list|,
name|g
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Register a reference to a global.  Returns TRUE if the reference    is valid.  */
end_comment

begin_function
name|bool
name|ffeglobal_ref_progunit_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|,
name|ffeglobalType
name|type
parameter_list|)
block|{
if|#
directive|if
name|FFEGLOBAL_ENABLED
name|ffename
name|n
init|=
name|NULL
decl_stmt|;
name|ffeglobal
name|g
decl_stmt|;
comment|/* It is never really _known_ that an EXTERNAL statement      names a BLOCK DATA by just looking at the program unit,      so override a different notion here.  */
if|if
condition|(
name|type
operator|==
name|FFEGLOBAL_typeBDATA
condition|)
name|type
operator|=
name|FFEGLOBAL_typeEXT
expr_stmt|;
name|g
operator|=
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|n
operator|=
name|ffename_find
argument_list|(
name|ffeglobal_filewide_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|g
operator|=
name|ffename_global
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|!=
name|NULL
condition|)
name|ffesymbol_set_global
argument_list|(
name|s
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|g
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeANY
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|(
name|g
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|g
operator|->
name|type
operator|!=
name|FFEGLOBAL_typeNONE
operator|)
operator|&&
operator|(
name|g
operator|->
name|type
operator|!=
name|FFEGLOBAL_typeEXT
operator|)
operator|&&
operator|(
name|g
operator|->
name|type
operator|!=
name|type
operator|)
operator|&&
operator|(
name|type
operator|!=
name|FFEGLOBAL_typeEXT
operator|)
condition|)
block|{
comment|/* Disagreement about (fully refined) class of program unit 	 (main, subroutine, function, block data).  Treat EXTERNAL/ 	 COMMON disagreements distinctly.  */
if|if
condition|(
operator|(
operator|(
operator|(
name|type
operator|==
name|FFEGLOBAL_typeBDATA
operator|)
operator|&&
operator|(
name|g
operator|->
name|type
operator|!=
name|FFEGLOBAL_typeCOMMON
operator|)
operator|)
operator|||
operator|(
operator|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeBDATA
operator|)
operator|&&
operator|(
name|type
operator|!=
name|FFEGLOBAL_typeCOMMON
operator|)
operator|&&
operator|!
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|defined
operator|)
operator|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This is likely to just annoy people. */
block|if (ffe_is_warn_globals ()) 	    {
comment|/* Warn about EXTERNAL of a COMMON name, though it works.  */
block|ffebad_start (FFEBAD_FILEWIDE_TIFF); 	      ffebad_string (ffelex_token_text (t)); 	      ffebad_string (ffeglobal_type_string_[type]); 	      ffebad_string (ffeglobal_type_string_[g->type]); 	      ffebad_here (0, ffelex_token_where_line (t), 			   ffelex_token_where_column (t)); 	      ffebad_here (1, ffelex_token_where_line (g->t), 			   ffelex_token_where_column (g->t)); 	      ffebad_finish (); 	    }
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|ffe_is_globals
argument_list|()
operator|||
name|ffe_is_warn_globals
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|ffe_is_globals
argument_list|()
condition|?
name|FFEBAD_FILEWIDE_DISAGREEMENT
else|:
name|FFEBAD_FILEWIDE_DISAGREEMENT_W
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffeglobal_type_string_
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffeglobal_type_string_
index|[
name|g
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|g
operator|->
name|type
operator|=
name|FFEGLOBAL_typeANY
expr_stmt|;
return|return
operator|(
operator|!
name|ffe_is_globals
argument_list|()
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|g
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|type
operator|==
name|FFEGLOBAL_typeFUNC
operator|)
condition|)
block|{
comment|/* If just filling in this function's type, do so.  */
if|if
condition|(
operator|(
name|g
operator|->
name|tick
operator|==
name|ffe_count_2
operator|)
operator|&&
operator|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_basictypeNONE
operator|)
operator|&&
operator|(
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_kindtypeNONE
operator|)
condition|)
block|{
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|bt
operator|=
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|kt
operator|=
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|sz
operator|=
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure there is type agreement.  */
if|if
condition|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeFUNC
operator|&&
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|bt
operator|!=
name|FFEINFO_basictypeNONE
operator|&&
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_basictypeNONE
operator|&&
operator|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|!=
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|bt
operator|||
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
operator|!=
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|kt
comment|/* CHARACTER*n disagreements matter only once a 		 definition is involved, since the definition might 		 be CHARACTER*(*), which accepts all references.  */
operator|||
operator|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|defined
operator|&&
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
operator|!=
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|sz
operator|&&
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
operator|!=
name|FFETARGET_charactersizeNONE
operator|&&
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|sz
operator|!=
name|FFETARGET_charactersizeNONE
operator|)
operator|)
condition|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Type mismatch between function reference/definition and 	     this subsequent reference (which might just be the filling-in 	     of type info for the definition, but we can't reach here 	     if that's the case and there was a previous definition).  	     It's an error given a previous definition, since that 	     implies inlining can crash the compiler, unless the user 	     asked for no such inlining.  */
name|error
operator|=
operator|(
name|g
operator|->
name|tick
operator|!=
name|ffe_count_2
operator|&&
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|defined
operator|&&
name|ffe_is_globals
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|ffe_is_warn_globals
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|error
condition|?
name|FFEBAD_FILEWIDE_TYPE_MISMATCH
else|:
name|FFEBAD_FILEWIDE_TYPE_MISMATCH_W
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|tick
operator|==
name|ffe_count_2
condition|)
block|{
comment|/* Current reference fills in type info for definition. 		     The current token doesn't necessarily point to the actual 		     definition of the function, so use the definition pointer 		     and the pointer to the pre-definition type info.  */
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|other_t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|other_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Current reference is not a filling-in of a current 		     definition.  The current token is fine, as is 		     the previous-mention token.  */
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffebad_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|g
operator|->
name|type
operator|=
name|FFEGLOBAL_typeANY
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|g
operator|=
name|ffeglobal_new_
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|g
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|g
operator|->
name|tick
operator|=
name|ffe_count_2
expr_stmt|;
name|g
operator|->
name|intrinsic
operator|=
name|FALSE
expr_stmt|;
name|g
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|defined
operator|=
name|FALSE
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|bt
operator|=
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|kt
operator|=
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|sz
operator|=
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
operator|=
operator|-
literal|1
expr_stmt|;
name|ffesymbol_set_global
argument_list|(
name|s
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g
operator|->
name|intrinsic
operator|&&
operator|!
name|g
operator|->
name|explicit_intrinsic
operator|&&
operator|(
name|g
operator|->
name|tick
operator|!=
name|ffe_count_2
operator|)
operator|&&
name|ffe_is_warn_globals
argument_list|()
condition|)
block|{
comment|/* Now known as a global, this name previously was seen as an 	 intrinsic.  Warn, in case the previous reference was intended 	 for the same global.  */
name|ffebad_start
argument_list|(
name|FFEBAD_INTRINSIC_GLOBAL
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"global"
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"intrinsic"
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|g
operator|->
name|type
operator|!=
name|type
operator|)
operator|&&
operator|(
name|type
operator|!=
name|FFEGLOBAL_typeEXT
operator|)
condition|)
block|{
comment|/* We've learned more, so point to where we learned it.  */
name|g
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|g
operator|->
name|type
operator|=
name|type
expr_stmt|;
ifdef|#
directive|ifdef
name|FFECOM_globalHOOK
name|g
operator|->
name|hook
operator|=
name|FFECOM_globalNULL
expr_stmt|;
comment|/* Discard previous _DECL. */
endif|#
directive|endif
name|g
operator|->
name|u
operator|.
name|proc
operator|.
name|n_args
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|TRUE
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffeglobal_save_common -- Check SAVE status of common area     ffesymbol s;	 // the common area    bool save;  // TRUE if SAVEd, FALSE otherwise    ffeglobal_save_common(s,save,ffesymbol_where_line(s), 	 ffesymbol_where_column(s));     In global-enabled mode, make sure the save info agrees with any existing    info established for the common area, otherwise complain.    In global-disabled mode, do nothing.	 */
end_comment

begin_function
name|void
name|ffeglobal_save_common
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|bool
name|save
parameter_list|,
name|ffewhereLine
name|wl
parameter_list|,
name|ffewhereColumn
name|wc
parameter_list|)
block|{
if|#
directive|if
name|FFEGLOBAL_ENABLED
name|ffeglobal
name|g
decl_stmt|;
name|g
operator|=
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|==
name|NULL
operator|)
operator|||
operator|(
name|g
operator|->
name|type
operator|!=
name|FFEGLOBAL_typeCOMMON
operator|)
condition|)
return|return;
comment|/* Let someone else catch this! */
if|if
condition|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeANY
condition|)
return|return;
if|if
condition|(
operator|!
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|have_save
condition|)
block|{
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|have_save
operator|=
name|TRUE
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|save
operator|=
name|save
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|save_where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|wl
argument_list|)
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|save_where_col
operator|=
name|ffewhere_column_use
argument_list|(
name|wc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|save
operator|!=
name|save
operator|)
operator|&&
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_COMMON_DIFF_SAVE
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
name|save
condition|?
literal|0
else|:
literal|1
argument_list|,
name|wl
argument_list|,
name|wc
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
name|save
condition|?
literal|1
else|:
literal|0
argument_list|,
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|pad_where_line
argument_list|,
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|pad_where_col
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffeglobal_size_common -- Establish size of COMMON area     ffesymbol s;	 // the common area    ffetargetOffset size;  // size in units    if (ffeglobal_size_common(s,size))  // new size is largest seen     In global-enabled mode, set the size if it current size isn't known or is    smaller than new size, and for non-blank common, complain if old size    is different from new.  Return TRUE if the new size is the largest seen    for this COMMON area (or if no size was known for it previously).    In global-disabled mode, do nothing.	 */
end_comment

begin_if
if|#
directive|if
name|FFEGLOBAL_ENABLED
end_if

begin_function
name|bool
name|ffeglobal_size_common
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffetargetOffset
name|size
parameter_list|)
block|{
name|ffeglobal
name|g
decl_stmt|;
name|g
operator|=
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|==
name|NULL
operator|)
operator|||
operator|(
name|g
operator|->
name|type
operator|!=
name|FFEGLOBAL_typeCOMMON
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|g
operator|->
name|type
operator|==
name|FFEGLOBAL_typeANY
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|have_size
condition|)
block|{
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|have_size
operator|=
name|TRUE
expr_stmt|;
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|size
operator|=
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|(
name|g
operator|->
name|tick
operator|>
literal|0
operator|)
operator|&&
operator|(
name|g
operator|->
name|tick
operator|<
name|ffe_count_2
operator|)
operator|&&
operator|(
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|size
operator|<
name|size
operator|)
condition|)
block|{
name|char
name|oldsize
index|[
literal|40
index|]
decl_stmt|;
name|char
name|newsize
index|[
literal|40
index|]
decl_stmt|;
comment|/* Common block initialized in a previous program unit, which 	 effectively freezes its size, but now the program is trying 	 to enlarge it.  */
name|sprintf
argument_list|(
operator|&
name|oldsize
index|[
literal|0
index|]
argument_list|,
literal|"%"
name|ffetargetOffset_f
literal|"d"
argument_list|,
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|size
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|newsize
index|[
literal|0
index|]
argument_list|,
literal|"%"
name|ffetargetOffset_f
literal|"d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_COMMON_ENLARGED
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|oldsize
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|newsize
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
operator|(
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|size
operator|==
literal|1
operator|)
condition|?
name|FFECOM_SIZE_UNIT
else|:
name|FFECOM_SIZE_UNITS
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
operator|(
name|size
operator|==
literal|1
operator|)
condition|?
name|FFECOM_SIZE_UNIT
else|:
name|FFECOM_SIZE_UNITS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|initt
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|initt
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffesymbol_where_line
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where_column
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|size
operator|!=
name|size
operator|)
operator|&&
operator|!
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|blank
condition|)
block|{
name|char
name|oldsize
index|[
literal|40
index|]
decl_stmt|;
name|char
name|newsize
index|[
literal|40
index|]
decl_stmt|;
comment|/* Warn about this even if not -pedantic, because putting all 	 program units in a single source file is the only way to 	 detect this.  Apparently UNIX-model linkers neither handle 	 nor report when they make a common unit smaller than 	 requested, such as when the smaller-declared version is 	 initialized and the larger-declared version is not.  So 	 if people complain about strange overwriting, we can tell 	 them to put all their code in a single file and compile 	 that way.  Warnings about differing sizes must therefore 	 always be issued.  */
name|sprintf
argument_list|(
operator|&
name|oldsize
index|[
literal|0
index|]
argument_list|,
literal|"%"
name|ffetargetOffset_f
literal|"d"
argument_list|,
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|size
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|newsize
index|[
literal|0
index|]
argument_list|,
literal|"%"
name|ffetargetOffset_f
literal|"d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_COMMON_DIFF_SIZE
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|oldsize
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|newsize
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
operator|(
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|size
operator|==
literal|1
operator|)
condition|?
name|FFECOM_SIZE_UNIT
else|:
name|FFECOM_SIZE_UNITS
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
operator|(
name|size
operator|==
literal|1
operator|)
condition|?
name|FFECOM_SIZE_UNIT
else|:
name|FFECOM_SIZE_UNITS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|g
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffesymbol_where_line
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where_column
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|size
condition|)
block|{
name|g
operator|->
name|u
operator|.
name|common
operator|.
name|size
operator|=
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|ffeglobal_terminate_1
parameter_list|()
block|{ }
end_function

end_unit

