begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* stt.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995, 1997 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       None     Description:       Manages lists of tokens and related info for parsing.     Modifications: */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"stt.h"
end_include

begin_include
include|#
directive|include
file|"bld.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"sta.h"
end_include

begin_include
include|#
directive|include
file|"stp.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_comment
comment|/* Internal macros. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* ffestt_caselist_append -- Append case to list of cases     ffesttCaseList list;    ffelexToken t;    ffestt_caselist_append(list,range,case1,case2,t);     list must have already been created by ffestt_caselist_create.  The    list is allocated out of the scratch pool.  The token is consumed.  */
end_comment

begin_function
name|void
name|ffestt_caselist_append
parameter_list|(
name|ffesttCaseList
name|list
parameter_list|,
name|bool
name|range
parameter_list|,
name|ffebld
name|case1
parameter_list|,
name|ffebld
name|case2
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesttCaseList
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|ffesttCaseList
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_scratch_pool
argument_list|,
literal|"FFEST case list"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
operator|->
name|previous
operator|->
name|next
expr_stmt|;
name|new
operator|->
name|previous
operator|=
name|list
operator|->
name|previous
expr_stmt|;
name|new
operator|->
name|next
operator|->
name|previous
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|previous
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|expr1
operator|=
name|case1
expr_stmt|;
name|new
operator|->
name|expr2
operator|=
name|case2
expr_stmt|;
name|new
operator|->
name|range
operator|=
name|range
expr_stmt|;
name|new
operator|->
name|t
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestt_caselist_create -- Create new list of cases     ffesttCaseList list;    list = ffestt_caselist_create();     The list is allocated out of the scratch pool.  */
end_comment

begin_function
name|ffesttCaseList
name|ffestt_caselist_create
parameter_list|()
block|{
name|ffesttCaseList
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|ffesttCaseList
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_scratch_pool
argument_list|,
literal|"FFEST case list root"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|new
operator|->
name|previous
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|t
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|expr1
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|expr2
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|range
operator|=
name|FALSE
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* ffestt_caselist_dump -- Dump list of cases     ffesttCaseList list;    ffestt_caselist_dump(list);     The cases in the list are dumped with commas separating them.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
end_if

begin_function
name|void
name|ffestt_caselist_dump
parameter_list|(
name|ffesttCaseList
name|list
parameter_list|)
block|{
name|ffesttCaseList
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|list
operator|->
name|next
init|;
name|next
operator|!=
name|list
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
if|if
condition|(
name|next
operator|!=
name|list
operator|->
name|next
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|expr1
operator|!=
name|NULL
condition|)
name|ffebld_dump
argument_list|(
name|next
operator|->
name|expr1
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|range
condition|)
block|{
name|fputc
argument_list|(
literal|':'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|expr2
operator|!=
name|NULL
condition|)
name|ffebld_dump
argument_list|(
name|next
operator|->
name|expr2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestt_caselist_kill -- Kill list of cases     ffesttCaseList list;    ffestt_caselist_kill(list);     The tokens on the list are killed.     02-Mar-90  JCB  1.1       Don't kill the list itself or change it, since it will be trashed when       ffesta_scratch_pool is killed anyway, so kill only the lex tokens.  */
end_comment

begin_function
name|void
name|ffestt_caselist_kill
parameter_list|(
name|ffesttCaseList
name|list
parameter_list|)
block|{
name|ffesttCaseList
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|list
operator|->
name|next
init|;
name|next
operator|!=
name|list
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|ffelex_token_kill
argument_list|(
name|next
operator|->
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffestt_dimlist_append -- Append dim to list of dims     ffesttDimList list;    ffelexToken t;    ffestt_dimlist_append(list,lower,upper,t);     list must have already been created by ffestt_dimlist_create.  The    list is allocated out of the scratch pool.  The token is consumed.  */
end_comment

begin_function
name|void
name|ffestt_dimlist_append
parameter_list|(
name|ffesttDimList
name|list
parameter_list|,
name|ffebld
name|lower
parameter_list|,
name|ffebld
name|upper
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesttDimList
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|ffesttDimList
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_scratch_pool
argument_list|,
literal|"FFEST dim list"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
operator|->
name|previous
operator|->
name|next
expr_stmt|;
name|new
operator|->
name|previous
operator|=
name|list
operator|->
name|previous
expr_stmt|;
name|new
operator|->
name|next
operator|->
name|previous
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|previous
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|lower
operator|=
name|lower
expr_stmt|;
name|new
operator|->
name|upper
operator|=
name|upper
expr_stmt|;
name|new
operator|->
name|t
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert list of dims into ffebld format.     ffesttDimList list;    ffeinfoRank rank;    ffebld array_size;    ffebld extents;    ffestt_dimlist_as_expr (list,&rank,&array_size,&extents);     The dims in the list are converted to a list of ITEMs; the rank of the    array, an expression representing the array size, a list of extent    expressions, and the list of ITEMs are returned.     If is_ugly_assumed, treat a final dimension with no lower bound    and an upper bound of 1 as a * bound.  */
end_comment

begin_function
name|ffebld
name|ffestt_dimlist_as_expr
parameter_list|(
name|ffesttDimList
name|list
parameter_list|,
name|ffeinfoRank
modifier|*
name|rank
parameter_list|,
name|ffebld
modifier|*
name|array_size
parameter_list|,
name|ffebld
modifier|*
name|extents
parameter_list|,
name|bool
name|is_ugly_assumed
parameter_list|)
block|{
name|ffesttDimList
name|next
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
name|ffebld
name|as
decl_stmt|;
name|ffebld
name|ex
decl_stmt|;
comment|/* List of extents. */
name|ffebld
name|ext
decl_stmt|;
comment|/* Extent of a given dimension. */
name|ffebldListBottom
name|bottom
decl_stmt|;
name|ffeinfoRank
name|r
decl_stmt|;
name|ffeinfoKindtype
name|nkt
decl_stmt|;
name|ffetargetIntegerDefault
name|low
decl_stmt|;
name|ffetargetIntegerDefault
name|high
decl_stmt|;
name|bool
name|zero
init|=
name|FALSE
decl_stmt|;
comment|/* Zero-size array. */
name|bool
name|any
init|=
name|FALSE
decl_stmt|;
name|bool
name|star
init|=
name|FALSE
decl_stmt|;
comment|/* Adjustable array. */
name|assert
argument_list|(
name|list
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
name|ffebld_init_list
argument_list|(
operator|&
name|expr
argument_list|,
operator|&
name|bottom
argument_list|)
expr_stmt|;
for|for
control|(
name|next
operator|=
name|list
operator|->
name|next
init|;
name|next
operator|!=
name|list
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
operator|++
name|r
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|next
operator|->
name|lower
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|next
operator|->
name|lower
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|next
operator|->
name|upper
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
condition|)
block|{
if|if
condition|(
name|next
operator|->
name|lower
operator|==
name|NULL
condition|)
name|low
operator|=
literal|1
expr_stmt|;
else|else
name|low
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|next
operator|->
name|lower
argument_list|)
argument_list|)
expr_stmt|;
name|high
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|next
operator|->
name|upper
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|low
operator|>
name|high
condition|)
name|zero
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|next
operator|->
name|next
operator|==
name|list
operator|)
operator|&&
name|is_ugly_assumed
operator|&&
operator|(
name|next
operator|->
name|lower
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|high
operator|==
literal|1
operator|)
operator|&&
operator|(
name|ffebld_conter_orig
argument_list|(
name|next
operator|->
name|upper
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|star
operator|=
name|TRUE
expr_stmt|;
name|ffebld_append_item
argument_list|(
operator|&
name|bottom
argument_list|,
name|ffebld_new_bounds
argument_list|(
name|NULL
argument_list|,
name|ffebld_new_star
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|next
operator|->
name|lower
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|next
operator|->
name|lower
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|next
operator|->
name|upper
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
condition|)
name|any
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|next
operator|->
name|upper
argument_list|)
operator|==
name|FFEBLD_opSTAR
condition|)
name|star
operator|=
name|TRUE
expr_stmt|;
name|ffebld_append_item
argument_list|(
operator|&
name|bottom
argument_list|,
name|ffebld_new_bounds
argument_list|(
name|next
operator|->
name|lower
argument_list|,
name|next
operator|->
name|upper
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffebld_end_list
argument_list|(
operator|&
name|bottom
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero
condition|)
block|{
name|as
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_integerdefault_val
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|as
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ex
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|any
condition|)
block|{
name|as
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|as
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
name|ex
operator|=
name|ffebld_copy
argument_list|(
name|as
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|star
condition|)
block|{
name|as
operator|=
name|ffebld_new_star
argument_list|()
expr_stmt|;
name|ex
operator|=
name|ffebld_new_star
argument_list|()
expr_stmt|;
comment|/* ~~Should really be list as below. */
block|}
else|else
block|{
name|as
operator|=
name|NULL
expr_stmt|;
name|ffebld_init_list
argument_list|(
operator|&
name|ex
argument_list|,
operator|&
name|bottom
argument_list|)
expr_stmt|;
for|for
control|(
name|next
operator|=
name|list
operator|->
name|next
init|;
name|next
operator|!=
name|list
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|next
operator|->
name|lower
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ffebld_op
argument_list|(
name|next
operator|->
name|lower
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|&&
operator|(
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|next
operator|->
name|lower
argument_list|)
argument_list|)
operator|==
literal|1
operator|)
operator|)
condition|)
name|ext
operator|=
name|ffebld_copy
argument_list|(
name|next
operator|->
name|upper
argument_list|)
expr_stmt|;
else|else
block|{
name|ext
operator|=
name|ffebld_new_subtract
argument_list|(
name|next
operator|->
name|upper
argument_list|,
name|next
operator|->
name|lower
argument_list|)
expr_stmt|;
name|nkt
operator|=
name|ffeinfo_kindtype_max
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|next
operator|->
name|lower
argument_list|)
argument_list|)
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|next
operator|->
name|upper
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|ext
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
operator|(
operator|(
name|ffebld_op
argument_list|(
name|ffebld_left
argument_list|(
name|ext
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|ffebld_right
argument_list|(
name|ext
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|)
condition|?
name|FFEINFO_whereCONSTANT
else|:
name|FFEINFO_whereFLEETING
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_left
argument_list|(
name|ext
argument_list|,
name|ffeexpr_convert_expr
argument_list|(
name|ffebld_left
argument_list|(
name|ext
argument_list|)
argument_list|,
name|next
operator|->
name|t
argument_list|,
name|ext
argument_list|,
name|next
operator|->
name|t
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_right
argument_list|(
name|ext
argument_list|,
name|ffeexpr_convert_expr
argument_list|(
name|ffebld_right
argument_list|(
name|ext
argument_list|)
argument_list|,
name|next
operator|->
name|t
argument_list|,
name|ext
argument_list|,
name|next
operator|->
name|t
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|ext
operator|=
name|ffeexpr_collapse_subtract
argument_list|(
name|ext
argument_list|,
name|next
operator|->
name|t
argument_list|)
expr_stmt|;
name|nkt
operator|=
name|ffeinfo_kindtype_max
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ext
argument_list|)
argument_list|)
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|ext
operator|=
name|ffebld_new_add
argument_list|(
name|ext
argument_list|,
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_integerdefault_val
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|ffebld_right
argument_list|(
name|ext
argument_list|)
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|ext
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
operator|(
name|ffebld_op
argument_list|(
name|ffebld_left
argument_list|(
name|ext
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
condition|?
name|FFEINFO_whereCONSTANT
else|:
name|FFEINFO_whereFLEETING
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_left
argument_list|(
name|ext
argument_list|,
name|ffeexpr_convert_expr
argument_list|(
name|ffebld_left
argument_list|(
name|ext
argument_list|)
argument_list|,
name|next
operator|->
name|t
argument_list|,
name|ext
argument_list|,
name|next
operator|->
name|t
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_right
argument_list|(
name|ext
argument_list|,
name|ffeexpr_convert_expr
argument_list|(
name|ffebld_right
argument_list|(
name|ext
argument_list|)
argument_list|,
name|next
operator|->
name|t
argument_list|,
name|ext
argument_list|,
name|next
operator|->
name|t
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|ext
operator|=
name|ffeexpr_collapse_add
argument_list|(
name|ext
argument_list|,
name|next
operator|->
name|t
argument_list|)
expr_stmt|;
block|}
name|ffebld_append_item
argument_list|(
operator|&
name|bottom
argument_list|,
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|==
name|NULL
condition|)
name|as
operator|=
name|ext
expr_stmt|;
else|else
block|{
name|nkt
operator|=
name|ffeinfo_kindtype_max
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|as
argument_list|)
argument_list|)
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ext
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|as
operator|=
name|ffebld_new_multiply
argument_list|(
name|as
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|as
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
operator|(
operator|(
name|ffebld_op
argument_list|(
name|ffebld_left
argument_list|(
name|as
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|ffebld_right
argument_list|(
name|as
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|)
condition|?
name|FFEINFO_whereCONSTANT
else|:
name|FFEINFO_whereFLEETING
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_left
argument_list|(
name|as
argument_list|,
name|ffeexpr_convert_expr
argument_list|(
name|ffebld_left
argument_list|(
name|as
argument_list|)
argument_list|,
name|next
operator|->
name|t
argument_list|,
name|as
argument_list|,
name|next
operator|->
name|t
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_right
argument_list|(
name|as
argument_list|,
name|ffeexpr_convert_expr
argument_list|(
name|ffebld_right
argument_list|(
name|as
argument_list|)
argument_list|,
name|next
operator|->
name|t
argument_list|,
name|as
argument_list|,
name|next
operator|->
name|t
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|as
operator|=
name|ffeexpr_collapse_multiply
argument_list|(
name|as
argument_list|,
name|next
operator|->
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|ffebld_end_list
argument_list|(
operator|&
name|bottom
argument_list|)
expr_stmt|;
name|as
operator|=
name|ffeexpr_convert
argument_list|(
name|as
argument_list|,
name|list
operator|->
name|next
operator|->
name|t
argument_list|,
name|NULL
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
block|}
operator|*
name|rank
operator|=
name|r
expr_stmt|;
operator|*
name|array_size
operator|=
name|as
expr_stmt|;
operator|*
name|extents
operator|=
name|ex
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffestt_dimlist_create -- Create new list of dims     ffesttDimList list;    list = ffestt_dimlist_create();     The list is allocated out of the scratch pool.  */
end_comment

begin_function
name|ffesttDimList
name|ffestt_dimlist_create
parameter_list|()
block|{
name|ffesttDimList
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|ffesttDimList
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_scratch_pool
argument_list|,
literal|"FFEST dim list root"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|new
operator|->
name|previous
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|t
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|lower
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|upper
operator|=
name|NULL
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* ffestt_dimlist_dump -- Dump list of dims     ffesttDimList list;    ffestt_dimlist_dump(list);     The dims in the list are dumped with commas separating them.	 */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
end_if

begin_function
name|void
name|ffestt_dimlist_dump
parameter_list|(
name|ffesttDimList
name|list
parameter_list|)
block|{
name|ffesttDimList
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|list
operator|->
name|next
init|;
name|next
operator|!=
name|list
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
if|if
condition|(
name|next
operator|!=
name|list
operator|->
name|next
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|lower
operator|!=
name|NULL
condition|)
name|ffebld_dump
argument_list|(
name|next
operator|->
name|lower
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|':'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|upper
operator|!=
name|NULL
condition|)
name|ffebld_dump
argument_list|(
name|next
operator|->
name|upper
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestt_dimlist_kill -- Kill list of dims     ffesttDimList list;    ffestt_dimlist_kill(list);     The tokens on the list are killed.  */
end_comment

begin_function
name|void
name|ffestt_dimlist_kill
parameter_list|(
name|ffesttDimList
name|list
parameter_list|)
block|{
name|ffesttDimList
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|list
operator|->
name|next
init|;
name|next
operator|!=
name|list
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|ffelex_token_kill
argument_list|(
name|next
operator|->
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine type of list of dimensions.     Return KNOWN for all-constant bounds, ADJUSTABLE for constant    and variable but no * bounds, ASSUMED for constant and * but    not variable bounds, ADJUSTABLEASSUMED for constant and variable    and * bounds.     If is_ugly_assumed, treat a final dimension with no lower bound    and an upper bound of 1 as a * bound.  */
end_comment

begin_function
name|ffestpDimtype
name|ffestt_dimlist_type
parameter_list|(
name|ffesttDimList
name|list
parameter_list|,
name|bool
name|is_ugly_assumed
parameter_list|)
block|{
name|ffesttDimList
name|next
decl_stmt|;
name|ffestpDimtype
name|type
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
name|FFESTP_dimtypeNONE
return|;
name|type
operator|=
name|FFESTP_dimtypeKNOWN
expr_stmt|;
for|for
control|(
name|next
operator|=
name|list
operator|->
name|next
init|;
name|next
operator|!=
name|list
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|bool
name|ugly_assumed
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|(
name|next
operator|->
name|next
operator|==
name|list
operator|)
operator|&&
name|is_ugly_assumed
operator|&&
operator|(
name|next
operator|->
name|lower
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|next
operator|->
name|upper
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|next
operator|->
name|upper
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|&&
operator|(
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|next
operator|->
name|upper
argument_list|)
argument_list|)
operator|==
literal|1
operator|)
operator|&&
operator|(
name|ffebld_conter_orig
argument_list|(
name|next
operator|->
name|upper
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|ugly_assumed
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|lower
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffebld_op
argument_list|(
name|next
operator|->
name|lower
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|FFESTP_dimtypeASSUMED
condition|)
name|type
operator|=
name|FFESTP_dimtypeADJUSTABLEASSUMED
expr_stmt|;
else|else
name|type
operator|=
name|FFESTP_dimtypeADJUSTABLE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|next
operator|->
name|upper
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ugly_assumed
operator|||
operator|(
name|ffebld_op
argument_list|(
name|next
operator|->
name|upper
argument_list|)
operator|==
name|FFEBLD_opSTAR
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|FFESTP_dimtypeADJUSTABLE
condition|)
name|type
operator|=
name|FFESTP_dimtypeADJUSTABLEASSUMED
expr_stmt|;
else|else
name|type
operator|=
name|FFESTP_dimtypeASSUMED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|next
operator|->
name|upper
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
name|type
operator|=
name|FFESTP_dimtypeADJUSTABLE
expr_stmt|;
block|}
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* ffestt_exprlist_append -- Append expr to list of exprs     ffesttExprList list;    ffelexToken t;    ffestt_exprlist_append(list,expr,t);     list must have already been created by ffestt_exprlist_create.  The    list is allocated out of the scratch pool.  The token is consumed.  */
end_comment

begin_function
name|void
name|ffestt_exprlist_append
parameter_list|(
name|ffesttExprList
name|list
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesttExprList
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|ffesttExprList
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_scratch_pool
argument_list|,
literal|"FFEST expr list"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
operator|->
name|previous
operator|->
name|next
expr_stmt|;
name|new
operator|->
name|previous
operator|=
name|list
operator|->
name|previous
expr_stmt|;
name|new
operator|->
name|next
operator|->
name|previous
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|previous
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
name|new
operator|->
name|t
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestt_exprlist_create -- Create new list of exprs     ffesttExprList list;    list = ffestt_exprlist_create();     The list is allocated out of the scratch pool.  */
end_comment

begin_function
name|ffesttExprList
name|ffestt_exprlist_create
parameter_list|()
block|{
name|ffesttExprList
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|ffesttExprList
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_scratch_pool
argument_list|,
literal|"FFEST expr list root"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|new
operator|->
name|previous
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|expr
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|t
operator|=
name|NULL
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* ffestt_exprlist_drive -- Drive list of token pairs into function     ffesttExprList list;    void fn(ffebld expr,ffelexToken t);    ffestt_exprlist_drive(list,fn);     The expr/token pairs in the list are passed to the function one pair    at a time.  */
end_comment

begin_function
name|void
name|ffestt_exprlist_drive
parameter_list|(
name|ffesttExprList
name|list
parameter_list|,
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|ffebld
parameter_list|,
name|ffelexToken
parameter_list|)
parameter_list|)
block|{
name|ffesttExprList
name|next
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|next
operator|=
name|list
operator|->
name|next
init|;
name|next
operator|!=
name|list
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
call|(
modifier|*
name|fn
call|)
argument_list|(
name|next
operator|->
name|expr
argument_list|,
name|next
operator|->
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffestt_exprlist_dump -- Dump list of exprs     ffesttExprList list;    ffestt_exprlist_dump(list);     The exprs in the list are dumped with commas separating them.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
end_if

begin_function
name|void
name|ffestt_exprlist_dump
parameter_list|(
name|ffesttExprList
name|list
parameter_list|)
block|{
name|ffesttExprList
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|list
operator|->
name|next
init|;
name|next
operator|!=
name|list
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
if|if
condition|(
name|next
operator|!=
name|list
operator|->
name|next
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|ffebld_dump
argument_list|(
name|next
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestt_exprlist_kill -- Kill list of exprs     ffesttExprList list;    ffestt_exprlist_kill(list);     The tokens on the list are killed.     02-Mar-90  JCB  1.1       Don't kill the list itself or change it, since it will be trashed when       ffesta_scratch_pool is killed anyway, so kill only the lex tokens.  */
end_comment

begin_function
name|void
name|ffestt_exprlist_kill
parameter_list|(
name|ffesttExprList
name|list
parameter_list|)
block|{
name|ffesttExprList
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|list
operator|->
name|next
init|;
name|next
operator|!=
name|list
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|ffelex_token_kill
argument_list|(
name|next
operator|->
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffestt_formatlist_append -- Append null format to list of formats     ffesttFormatList list, new;    new = ffestt_formatlist_append(list);     list must have already been created by ffestt_formatlist_create.  The    new item is allocated out of the scratch pool.  The caller must initialize    it appropriately.  */
end_comment

begin_function
name|ffesttFormatList
name|ffestt_formatlist_append
parameter_list|(
name|ffesttFormatList
name|list
parameter_list|)
block|{
name|ffesttFormatList
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|ffesttFormatList
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_scratch_pool
argument_list|,
literal|"FFEST format list"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
operator|->
name|previous
operator|->
name|next
expr_stmt|;
name|new
operator|->
name|previous
operator|=
name|list
operator|->
name|previous
expr_stmt|;
name|new
operator|->
name|next
operator|->
name|previous
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|previous
operator|->
name|next
operator|=
name|new
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* ffestt_formatlist_create -- Create new list of formats     ffesttFormatList list;    list = ffestt_formatlist_create(NULL);     The list is allocated out of the scratch pool.  */
end_comment

begin_function
name|ffesttFormatList
name|ffestt_formatlist_create
parameter_list|(
name|ffesttFormatList
name|parent
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesttFormatList
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|ffesttFormatList
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_scratch_pool
argument_list|,
literal|"FFEST format list root"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|new
operator|->
name|previous
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|FFESTP_formattypeNone
expr_stmt|;
name|new
operator|->
name|t
operator|=
name|t
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|root
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* ffestt_formatlist_kill -- Kill tokens on list of formats     ffesttFormatList list;    ffestt_formatlist_kill(list);     The tokens on the list are killed.  */
end_comment

begin_function
name|void
name|ffestt_formatlist_kill
parameter_list|(
name|ffesttFormatList
name|list
parameter_list|)
block|{
name|ffesttFormatList
name|next
decl_stmt|;
comment|/* Always kill from the very top on down. */
while|while
condition|(
name|list
operator|->
name|u
operator|.
name|root
operator|.
name|parent
operator|!=
name|NULL
condition|)
name|list
operator|=
name|list
operator|->
name|u
operator|.
name|root
operator|.
name|parent
operator|->
name|next
expr_stmt|;
comment|/* Kill first token for this list. */
if|if
condition|(
name|list
operator|->
name|t
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|list
operator|->
name|t
argument_list|)
expr_stmt|;
comment|/* Kill each item in this list. */
for|for
control|(
name|next
operator|=
name|list
operator|->
name|next
init|;
name|next
operator|!=
name|list
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|ffelex_token_kill
argument_list|(
name|next
operator|->
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|next
operator|->
name|type
condition|)
block|{
case|case
name|FFESTP_formattypeI
case|:
case|case
name|FFESTP_formattypeB
case|:
case|case
name|FFESTP_formattypeO
case|:
case|case
name|FFESTP_formattypeZ
case|:
case|case
name|FFESTP_formattypeF
case|:
case|case
name|FFESTP_formattypeE
case|:
case|case
name|FFESTP_formattypeEN
case|:
case|case
name|FFESTP_formattypeG
case|:
case|case
name|FFESTP_formattypeL
case|:
case|case
name|FFESTP_formattypeA
case|:
case|case
name|FFESTP_formattypeD
case|:
if|if
condition|(
name|next
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|t
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|next
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1004
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|t
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|next
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1006
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|t
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|next
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1007_or_R1008
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1009
operator|.
name|t
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|next
operator|->
name|u
operator|.
name|R1005
operator|.
name|R1009
operator|.
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeQ
case|:
case|case
name|FFESTP_formattypeDOLLAR
case|:
case|case
name|FFESTP_formattypeP
case|:
case|case
name|FFESTP_formattypeT
case|:
case|case
name|FFESTP_formattypeTL
case|:
case|case
name|FFESTP_formattypeTR
case|:
case|case
name|FFESTP_formattypeX
case|:
case|case
name|FFESTP_formattypeS
case|:
case|case
name|FFESTP_formattypeSP
case|:
case|case
name|FFESTP_formattypeSS
case|:
case|case
name|FFESTP_formattypeBN
case|:
case|case
name|FFESTP_formattypeBZ
case|:
case|case
name|FFESTP_formattypeSLASH
case|:
case|case
name|FFESTP_formattypeCOLON
case|:
if|if
condition|(
name|next
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|t
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|next
operator|->
name|u
operator|.
name|R1010
operator|.
name|val
operator|.
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_formattypeR1016
case|:
break|break;
comment|/* Nothing more to do. */
case|case
name|FFESTP_formattypeFORMAT
case|:
if|if
condition|(
name|next
operator|->
name|u
operator|.
name|R1003D
operator|.
name|R1004
operator|.
name|t
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|next
operator|->
name|u
operator|.
name|R1003D
operator|.
name|R1004
operator|.
name|t
argument_list|)
expr_stmt|;
name|next
operator|->
name|u
operator|.
name|R1003D
operator|.
name|format
operator|->
name|u
operator|.
name|root
operator|.
name|parent
operator|=
name|NULL
expr_stmt|;
comment|/* Parent already dying. */
name|ffestt_formatlist_kill
argument_list|(
name|next
operator|->
name|u
operator|.
name|R1003D
operator|.
name|format
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ffestt_implist_append -- Append token pair to list of token pairs     ffesttImpList list;    ffelexToken t;    ffestt_implist_append(list,start_token,end_token);     list must have already been created by ffestt_implist_create.  The    list is allocated out of the scratch pool.  The tokens are consumed.	 */
end_comment

begin_function
name|void
name|ffestt_implist_append
parameter_list|(
name|ffesttImpList
name|list
parameter_list|,
name|ffelexToken
name|first
parameter_list|,
name|ffelexToken
name|last
parameter_list|)
block|{
name|ffesttImpList
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|ffesttImpList
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_scratch_pool
argument_list|,
literal|"FFEST token list"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
operator|->
name|previous
operator|->
name|next
expr_stmt|;
name|new
operator|->
name|previous
operator|=
name|list
operator|->
name|previous
expr_stmt|;
name|new
operator|->
name|next
operator|->
name|previous
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|previous
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|first
operator|=
name|first
expr_stmt|;
name|new
operator|->
name|last
operator|=
name|last
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestt_implist_create -- Create new list of token pairs     ffesttImpList list;    list = ffestt_implist_create();     The list is allocated out of the scratch pool.  */
end_comment

begin_function
name|ffesttImpList
name|ffestt_implist_create
parameter_list|()
block|{
name|ffesttImpList
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|ffesttImpList
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_scratch_pool
argument_list|,
literal|"FFEST token list root"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|new
operator|->
name|previous
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* ffestt_implist_drive -- Drive list of token pairs into function     ffesttImpList list;    void fn(ffelexToken first,ffelexToken last);    ffestt_implist_drive(list,fn);     The token pairs in the list are passed to the function one pair at a time.  */
end_comment

begin_function
name|void
name|ffestt_implist_drive
parameter_list|(
name|ffesttImpList
name|list
parameter_list|,
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|ffelexToken
parameter_list|,
name|ffelexToken
parameter_list|)
parameter_list|)
block|{
name|ffesttImpList
name|next
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|next
operator|=
name|list
operator|->
name|next
init|;
name|next
operator|!=
name|list
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
call|(
modifier|*
name|fn
call|)
argument_list|(
name|next
operator|->
name|first
argument_list|,
name|next
operator|->
name|last
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffestt_implist_dump -- Dump list of token pairs     ffesttImpList list;    ffestt_implist_dump(list);     The token pairs in the list are dumped with commas separating them.	*/
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
end_if

begin_function
name|void
name|ffestt_implist_dump
parameter_list|(
name|ffesttImpList
name|list
parameter_list|)
block|{
name|ffesttImpList
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|list
operator|->
name|next
init|;
name|next
operator|!=
name|list
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
if|if
condition|(
name|next
operator|!=
name|list
operator|->
name|next
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|next
operator|->
name|first
argument_list|)
operator|==
name|FFELEX_typeNAME
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|ffelex_token_text
argument_list|(
name|next
operator|->
name|first
argument_list|)
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|last
operator|!=
name|NULL
condition|)
block|{
name|fputc
argument_list|(
literal|'-'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|next
operator|->
name|last
argument_list|)
operator|==
name|FFELEX_typeNAME
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|ffelex_token_text
argument_list|(
name|next
operator|->
name|last
argument_list|)
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestt_implist_kill -- Kill list of token pairs     ffesttImpList list;    ffestt_implist_kill(list);     The tokens on the list are killed.  */
end_comment

begin_function
name|void
name|ffestt_implist_kill
parameter_list|(
name|ffesttImpList
name|list
parameter_list|)
block|{
name|ffesttImpList
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|list
operator|->
name|next
init|;
name|next
operator|!=
name|list
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|ffelex_token_kill
argument_list|(
name|next
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|last
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|next
operator|->
name|last
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffestt_tokenlist_append -- Append token to list of tokens     ffesttTokenList tl;    ffelexToken t;    ffestt_tokenlist_append(tl,t);     tl must have already been created by ffestt_tokenlist_create.  The    list is allocated out of the scratch pool.  The token is consumed.  */
end_comment

begin_function
name|void
name|ffestt_tokenlist_append
parameter_list|(
name|ffesttTokenList
name|tl
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesttTokenItem
name|ti
decl_stmt|;
name|ti
operator|=
operator|(
name|ffesttTokenItem
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_scratch_pool
argument_list|,
literal|"FFEST token item"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ti
argument_list|)
argument_list|)
expr_stmt|;
name|ti
operator|->
name|next
operator|=
operator|(
name|ffesttTokenItem
operator|)
operator|&
name|tl
operator|->
name|first
expr_stmt|;
name|ti
operator|->
name|previous
operator|=
name|tl
operator|->
name|last
expr_stmt|;
name|ti
operator|->
name|next
operator|->
name|previous
operator|=
name|ti
expr_stmt|;
name|ti
operator|->
name|previous
operator|->
name|next
operator|=
name|ti
expr_stmt|;
name|ti
operator|->
name|t
operator|=
name|t
expr_stmt|;
operator|++
name|tl
operator|->
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestt_tokenlist_create -- Create new list of tokens     ffesttTokenList tl;    tl = ffestt_tokenlist_create();     The list is allocated out of the scratch pool.  */
end_comment

begin_function
name|ffesttTokenList
name|ffestt_tokenlist_create
parameter_list|()
block|{
name|ffesttTokenList
name|tl
decl_stmt|;
name|tl
operator|=
operator|(
name|ffesttTokenList
operator|)
name|malloc_new_kp
argument_list|(
name|ffesta_scratch_pool
argument_list|,
literal|"FFEST token list"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tl
argument_list|)
argument_list|)
expr_stmt|;
name|tl
operator|->
name|first
operator|=
name|tl
operator|->
name|last
operator|=
operator|(
name|ffesttTokenItem
operator|)
operator|&
name|tl
operator|->
name|first
expr_stmt|;
name|tl
operator|->
name|count
operator|=
literal|0
expr_stmt|;
return|return
name|tl
return|;
block|}
end_function

begin_comment
comment|/* ffestt_tokenlist_drive -- Drive list of tokens     ffesttTokenList tl;    void fn(ffelexToken t);    ffestt_tokenlist_drive(tl,fn);     The tokens in the list are passed to the given function.  */
end_comment

begin_function
name|void
name|ffestt_tokenlist_drive
parameter_list|(
name|ffesttTokenList
name|tl
parameter_list|,
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|ffelexToken
parameter_list|)
parameter_list|)
block|{
name|ffesttTokenItem
name|ti
decl_stmt|;
if|if
condition|(
name|tl
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|ti
operator|=
name|tl
operator|->
name|first
init|;
name|ti
operator|!=
operator|(
name|ffesttTokenItem
operator|)
operator|&
name|tl
operator|->
name|first
condition|;
name|ti
operator|=
name|ti
operator|->
name|next
control|)
block|{
call|(
modifier|*
name|fn
call|)
argument_list|(
name|ti
operator|->
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffestt_tokenlist_dump -- Dump list of tokens     ffesttTokenList tl;    ffestt_tokenlist_dump(tl);     The tokens in the list are dumped with commas separating them.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_targetCURRENT
operator|==
name|FFECOM_targetFFE
end_if

begin_function
name|void
name|ffestt_tokenlist_dump
parameter_list|(
name|ffesttTokenList
name|tl
parameter_list|)
block|{
name|ffesttTokenItem
name|ti
decl_stmt|;
for|for
control|(
name|ti
operator|=
name|tl
operator|->
name|first
init|;
name|ti
operator|!=
operator|(
name|ffesttTokenItem
operator|)
operator|&
name|tl
operator|->
name|first
condition|;
name|ti
operator|=
name|ti
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ti
operator|!=
name|tl
operator|->
name|first
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|ti
operator|->
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNUMBER
case|:
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
name|fputs
argument_list|(
name|ffelex_token_text
argument_list|(
name|ti
operator|->
name|t
argument_list|)
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELEX_typeASTERISK
case|:
name|fputc
argument_list|(
literal|'*'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'?'
argument_list|,
name|dmpout
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestt_tokenlist_handle -- Handle list of tokens     ffesttTokenList tl;    ffelexHandler handler;    handler = ffestt_tokenlist_handle(tl,handler);     The tokens in the list are passed to the handler(s).	 */
end_comment

begin_function
name|ffelexHandler
name|ffestt_tokenlist_handle
parameter_list|(
name|ffesttTokenList
name|tl
parameter_list|,
name|ffelexHandler
name|handler
parameter_list|)
block|{
name|ffesttTokenItem
name|ti
decl_stmt|;
for|for
control|(
name|ti
operator|=
name|tl
operator|->
name|first
init|;
name|ti
operator|!=
operator|(
name|ffesttTokenItem
operator|)
operator|&
name|tl
operator|->
name|first
condition|;
name|ti
operator|=
name|ti
operator|->
name|next
control|)
name|handler
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|handler
argument_list|)
argument_list|(
name|ti
operator|->
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|handler
return|;
block|}
end_function

begin_comment
comment|/* ffestt_tokenlist_kill -- Kill list of tokens     ffesttTokenList tl;    ffestt_tokenlist_kill(tl);     The tokens on the list are killed.     02-Mar-90  JCB  1.1       Don't kill the list itself or change it, since it will be trashed when       ffesta_scratch_pool is killed anyway, so kill only the lex tokens.  */
end_comment

begin_function
name|void
name|ffestt_tokenlist_kill
parameter_list|(
name|ffesttTokenList
name|tl
parameter_list|)
block|{
name|ffesttTokenItem
name|ti
decl_stmt|;
for|for
control|(
name|ti
operator|=
name|tl
operator|->
name|first
init|;
name|ti
operator|!=
operator|(
name|ffesttTokenItem
operator|)
operator|&
name|tl
operator|->
name|first
condition|;
name|ti
operator|=
name|ti
operator|->
name|next
control|)
block|{
name|ffelex_token_kill
argument_list|(
name|ti
operator|->
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

