begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* intrin.c -- Recognize references to intrinsics    Copyright (C) 1995, 1996, 1997, 1998, 2002,    2003 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"intrin.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"src.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_struct
struct|struct
name|_ffeintrin_name_
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name_uc
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name_lc
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name_ic
decl_stmt|;
specifier|const
name|ffeintrinGen
name|generic
decl_stmt|;
specifier|const
name|ffeintrinSpec
name|specific
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_ffeintrin_gen_
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Name as seen in program. */
specifier|const
name|ffeintrinSpec
name|specs
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_ffeintrin_spec_
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Uppercase name as seen in source code, 				   lowercase if no source name, "none" if no 				   name at all (NONE case). */
specifier|const
name|bool
name|is_actualarg
decl_stmt|;
comment|/* Ok to pass as actual arg if -pedantic. */
specifier|const
name|ffeintrinFamily
name|family
decl_stmt|;
specifier|const
name|ffeintrinImp
name|implementation
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_ffeintrin_imp_
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Name of implementation. */
specifier|const
name|ffecomGfrt
name|gfrt_direct
decl_stmt|;
comment|/* library routine, direct-callable form. */
specifier|const
name|ffecomGfrt
name|gfrt_f2c
decl_stmt|;
comment|/* library routine, f2c-callable form. */
specifier|const
name|ffecomGfrt
name|gfrt_gnu
decl_stmt|;
comment|/* library routine, gnu-callable form. */
specifier|const
name|char
modifier|*
specifier|const
name|control
decl_stmt|;
specifier|const
name|char
name|y2kbad
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|ffebad
name|ffeintrin_check_
parameter_list|(
name|ffeintrinImp
name|imp
parameter_list|,
name|ffebldOp
name|op
parameter_list|,
name|ffebld
name|args
parameter_list|,
name|ffeinfoBasictype
modifier|*
name|xbt
parameter_list|,
name|ffeinfoKindtype
modifier|*
name|xkt
parameter_list|,
name|ffetargetCharacterSize
modifier|*
name|xsz
parameter_list|,
name|bool
modifier|*
name|check_intrin
parameter_list|,
name|ffelexToken
name|t
parameter_list|,
name|bool
name|commit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffeintrin_check_any_
parameter_list|(
name|ffebld
name|arglist
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ffeintrin_cmp_name_
parameter_list|(
specifier|const
name|void
modifier|*
name|name
parameter_list|,
specifier|const
name|void
modifier|*
name|intrinsic
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|_ffeintrin_name_
name|ffeintrin_names_
index|[]
init|=
block|{
comment|/* Alpha order. */
define|#
directive|define
name|DEFNAME
parameter_list|(
name|UPPER
parameter_list|,
name|LOWER
parameter_list|,
name|MIXED
parameter_list|,
name|GEN
parameter_list|,
name|SPEC
parameter_list|)
define|\
value|{ UPPER, LOWER, MIXED, FFEINTRIN_ ## GEN, FFEINTRIN_ ## SPEC },
define|#
directive|define
name|DEFGEN
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|SPEC1
parameter_list|,
name|SPEC2
parameter_list|)
define|#
directive|define
name|DEFSPEC
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|CALLABLE
parameter_list|,
name|FAMILY
parameter_list|,
name|IMP
parameter_list|)
define|#
directive|define
name|DEFIMP
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|)
define|#
directive|define
name|DEFIMPY
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|,
name|Y2KBAD
parameter_list|)
include|#
directive|include
file|"intrin.def"
undef|#
directive|undef
name|DEFNAME
undef|#
directive|undef
name|DEFGEN
undef|#
directive|undef
name|DEFSPEC
undef|#
directive|undef
name|DEFIMP
undef|#
directive|undef
name|DEFIMPY
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|_ffeintrin_gen_
name|ffeintrin_gens_
index|[]
init|=
block|{
define|#
directive|define
name|DEFNAME
parameter_list|(
name|UPPER
parameter_list|,
name|LOWER
parameter_list|,
name|MIXED
parameter_list|,
name|GEN
parameter_list|,
name|SPEC
parameter_list|)
define|#
directive|define
name|DEFGEN
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|SPEC1
parameter_list|,
name|SPEC2
parameter_list|)
define|\
value|{ NAME, { SPEC1, SPEC2, }, },
define|#
directive|define
name|DEFSPEC
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|CALLABLE
parameter_list|,
name|FAMILY
parameter_list|,
name|IMP
parameter_list|)
define|#
directive|define
name|DEFIMP
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|)
define|#
directive|define
name|DEFIMPY
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|,
name|Y2KBAD
parameter_list|)
include|#
directive|include
file|"intrin.def"
undef|#
directive|undef
name|DEFNAME
undef|#
directive|undef
name|DEFGEN
undef|#
directive|undef
name|DEFSPEC
undef|#
directive|undef
name|DEFIMP
undef|#
directive|undef
name|DEFIMPY
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|_ffeintrin_imp_
name|ffeintrin_imps_
index|[]
init|=
block|{
define|#
directive|define
name|DEFNAME
parameter_list|(
name|UPPER
parameter_list|,
name|LOWER
parameter_list|,
name|MIXED
parameter_list|,
name|GEN
parameter_list|,
name|SPEC
parameter_list|)
define|#
directive|define
name|DEFGEN
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|SPEC1
parameter_list|,
name|SPEC2
parameter_list|)
define|#
directive|define
name|DEFSPEC
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|CALLABLE
parameter_list|,
name|FAMILY
parameter_list|,
name|IMP
parameter_list|)
define|#
directive|define
name|DEFIMP
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|)
define|\
value|{ NAME, FFECOM_gfrt ## GFRTDIRECT, FFECOM_gfrt ## GFRTF2C, \ 	FFECOM_gfrt ## GFRTGNU, CONTROL, FALSE },
define|#
directive|define
name|DEFIMPY
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|,
name|Y2KBAD
parameter_list|)
define|\
value|{ NAME, FFECOM_gfrt ## GFRTDIRECT, FFECOM_gfrt ## GFRTF2C, \ 	FFECOM_gfrt ## GFRTGNU, CONTROL, Y2KBAD },
include|#
directive|include
file|"intrin.def"
undef|#
directive|undef
name|DEFNAME
undef|#
directive|undef
name|DEFGEN
undef|#
directive|undef
name|DEFSPEC
undef|#
directive|undef
name|DEFIMP
undef|#
directive|undef
name|DEFIMPY
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|_ffeintrin_spec_
name|ffeintrin_specs_
index|[]
init|=
block|{
define|#
directive|define
name|DEFNAME
parameter_list|(
name|UPPER
parameter_list|,
name|LOWER
parameter_list|,
name|MIXED
parameter_list|,
name|GEN
parameter_list|,
name|SPEC
parameter_list|)
define|#
directive|define
name|DEFGEN
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|SPEC1
parameter_list|,
name|SPEC2
parameter_list|)
define|#
directive|define
name|DEFSPEC
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|CALLABLE
parameter_list|,
name|FAMILY
parameter_list|,
name|IMP
parameter_list|)
define|\
value|{ NAME, CALLABLE, FAMILY, IMP, },
define|#
directive|define
name|DEFIMP
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|)
define|#
directive|define
name|DEFIMPY
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|,
name|Y2KBAD
parameter_list|)
include|#
directive|include
file|"intrin.def"
undef|#
directive|undef
name|DEFGEN
undef|#
directive|undef
name|DEFSPEC
undef|#
directive|undef
name|DEFIMP
undef|#
directive|undef
name|DEFIMPY
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|ffebad
name|ffeintrin_check_
parameter_list|(
name|ffeintrinImp
name|imp
parameter_list|,
name|ffebldOp
name|op
parameter_list|,
name|ffebld
name|args
parameter_list|,
name|ffeinfoBasictype
modifier|*
name|xbt
parameter_list|,
name|ffeinfoKindtype
modifier|*
name|xkt
parameter_list|,
name|ffetargetCharacterSize
modifier|*
name|xsz
parameter_list|,
name|bool
modifier|*
name|check_intrin
parameter_list|,
name|ffelexToken
name|t
parameter_list|,
name|bool
name|commit
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|ffeintrin_imps_
index|[
name|imp
index|]
operator|.
name|control
decl_stmt|;
name|bool
name|subr
init|=
operator|(
name|c
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|argc
decl_stmt|;
name|ffebld
name|arg
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|ffetargetCharacterSize
name|sz
init|=
name|FFETARGET_charactersizeNONE
decl_stmt|;
name|ffeinfoKindtype
name|firstarg_kt
decl_stmt|;
name|bool
name|need_col
decl_stmt|;
name|ffeinfoBasictype
name|col_bt
init|=
name|FFEINFO_basictypeNONE
decl_stmt|;
name|ffeinfoKindtype
name|col_kt
init|=
name|FFEINFO_kindtypeNONE
decl_stmt|;
name|int
name|colon
init|=
operator|(
name|c
index|[
literal|2
index|]
operator|==
literal|':'
operator|)
condition|?
literal|2
else|:
literal|3
decl_stmt|;
name|int
name|argno
decl_stmt|;
comment|/* Check procedure type (function vs. subroutine) against      invocation.  */
if|if
condition|(
name|op
operator|==
name|FFEBLD_opSUBRREF
condition|)
block|{
if|if
condition|(
operator|!
name|subr
condition|)
return|return
name|FFEBAD_INTRINSIC_IS_FUNC
return|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|FFEBLD_opFUNCREF
condition|)
block|{
if|if
condition|(
name|subr
condition|)
return|return
name|FFEBAD_INTRINSIC_IS_SUBR
return|;
block|}
else|else
return|return
name|FFEBAD_INTRINSIC_REF
return|;
comment|/* Check the arglist for validity.  */
if|if
condition|(
operator|(
name|args
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_head
argument_list|(
name|args
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|firstarg_kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_head
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|firstarg_kt
operator|=
name|FFEINFO_kindtype
expr_stmt|;
for|for
control|(
name|argc
operator|=
operator|&
name|c
index|[
name|colon
operator|+
literal|3
index|]
operator|,
name|arg
operator|=
name|args
init|;
operator|*
name|argc
operator|!=
literal|'\0'
condition|;
control|)
block|{
name|char
name|optional
init|=
literal|'\0'
decl_stmt|;
name|char
name|required
init|=
literal|'\0'
decl_stmt|;
name|char
name|extra
init|=
literal|'\0'
decl_stmt|;
name|char
name|basic
decl_stmt|;
name|char
name|kind
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|elements
decl_stmt|;
name|bool
name|lastarg_complex
init|=
name|FALSE
decl_stmt|;
comment|/* We don't do anything with keywords yet.  */
do|do
block|{ 	}
do|while
condition|(
operator|*
operator|(
operator|++
name|argc
operator|)
operator|!=
literal|'='
condition|)
do|;
operator|++
name|argc
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argc
operator|==
literal|'?'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'!'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'*'
operator|)
condition|)
name|optional
operator|=
operator|*
operator|(
name|argc
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argc
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'n'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'p'
operator|)
condition|)
name|required
operator|=
operator|*
operator|(
name|argc
operator|++
operator|)
expr_stmt|;
name|basic
operator|=
operator|*
operator|(
name|argc
operator|++
operator|)
expr_stmt|;
name|kind
operator|=
operator|*
operator|(
name|argc
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|argc
operator|==
literal|'['
condition|)
block|{
name|length
operator|=
operator|*
operator|++
name|argc
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|argc
operator|!=
literal|']'
condition|)
name|length
operator|=
literal|10
operator|*
name|length
operator|+
operator|(
operator|*
operator|(
name|argc
operator|++
operator|)
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|argc
expr_stmt|;
block|}
else|else
name|length
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|argc
operator|==
literal|'('
condition|)
block|{
name|elements
operator|=
operator|*
operator|++
name|argc
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|argc
operator|!=
literal|')'
condition|)
name|elements
operator|=
literal|10
operator|*
name|elements
operator|+
operator|(
operator|*
operator|(
name|argc
operator|++
operator|)
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|argc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|argc
operator|==
literal|'&'
condition|)
block|{
name|elements
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|argc
expr_stmt|;
block|}
else|else
name|elements
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argc
operator|==
literal|'&'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'i'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'w'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'x'
operator|)
condition|)
name|extra
operator|=
operator|*
operator|(
name|argc
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|argc
operator|==
literal|','
condition|)
operator|++
name|argc
expr_stmt|;
comment|/* Break out of this loop only when current arg spec completely 	 processed.  */
do|do
block|{
name|bool
name|okay
decl_stmt|;
name|ffebld
name|a
decl_stmt|;
name|ffeinfo
name|i
decl_stmt|;
name|bool
name|anynum
decl_stmt|;
name|ffeinfoBasictype
name|abt
init|=
name|FFEINFO_basictypeNONE
decl_stmt|;
name|ffeinfoKindtype
name|akt
init|=
name|FFEINFO_kindtypeNONE
decl_stmt|;
if|if
condition|(
operator|(
name|arg
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_head
argument_list|(
name|arg
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|required
operator|!=
literal|'\0'
condition|)
return|return
name|FFEBAD_INTRINSIC_TOOFEW
return|;
if|if
condition|(
name|optional
operator|==
literal|'\0'
condition|)
return|return
name|FFEBAD_INTRINSIC_TOOFEW
return|;
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
name|arg
operator|=
name|ffebld_trail
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
comment|/* Try next argspec. */
block|}
name|a
operator|=
name|ffebld_head
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|i
operator|=
name|ffebld_info
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|anynum
operator|=
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeHOLLERITH
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeTYPELESS
operator|)
expr_stmt|;
comment|/* See how well the arg matches up to the spec.  */
switch|switch
condition|(
name|basic
condition|)
block|{
case|case
literal|'A'
case|:
name|okay
operator|=
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
operator|&&
operator|(
operator|(
name|length
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|ffeinfo_size
argument_list|(
name|i
argument_list|)
operator|==
operator|(
name|ffetargetCharacterSize
operator|)
name|length
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
expr_stmt|;
name|abt
operator|=
name|FFEINFO_basictypeCOMPLEX
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
expr_stmt|;
name|abt
operator|=
name|FFEINFO_basictypeINTEGER
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeLOGICAL
operator|)
expr_stmt|;
name|abt
operator|=
name|FFEINFO_basictypeLOGICAL
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeREAL
operator|)
expr_stmt|;
name|abt
operator|=
name|FFEINFO_basictypeREAL
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeLOGICAL
operator|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeREAL
operator|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeREAL
operator|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeREAL
operator|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|okay
operator|=
operator|(
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|==
name|FFEBLD_opLABTER
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|==
name|FFEBLD_opLABTOK
operator|)
operator|)
expr_stmt|;
name|elements
operator|=
operator|-
literal|1
expr_stmt|;
name|extra
operator|=
literal|'-'
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|okay
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeNONE
operator|)
operator|&&
operator|(
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindtypeNONE
operator|)
operator|&&
operator|(
name|ffeinfo_kind
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindSUBROUTINE
operator|)
operator|)
operator|||
operator|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
operator|)
operator|&&
operator|(
name|ffeinfo_kind
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindFUNCTION
operator|)
operator|)
operator|||
operator|(
name|ffeinfo_kind
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindNONE
operator|)
operator|)
operator|&&
operator|(
operator|(
name|ffeinfo_where
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_whereDUMMY
operator|)
operator|||
operator|(
name|ffeinfo_where
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_whereGLOBAL
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|ffeinfo_kind
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindENTITY
operator|)
operator|)
operator|)
expr_stmt|;
name|elements
operator|=
operator|-
literal|1
expr_stmt|;
name|extra
operator|=
literal|'-'
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
default|default:
name|okay
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|akt
operator|=
operator|(
name|kind
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeLOGICAL
operator|)
condition|)
block|{
switch|switch
condition|(
name|akt
condition|)
block|{
comment|/* Translate to internal kinds for now! */
default|default:
break|break;
case|case
literal|2
case|:
name|akt
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|akt
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|akt
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|akt
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|akt
operator|=
name|ffecom_pointer_kind
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|okay
operator|&=
name|anynum
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
operator|==
name|akt
operator|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|okay
operator|&=
name|anynum
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
operator|==
name|firstarg_kt
operator|)
expr_stmt|;
name|akt
operator|=
operator|(
name|firstarg_kt
operator|==
name|FFEINFO_kindtype
operator|)
condition|?
name|FFEINFO_kindtypeNONE
else|:
name|firstarg_kt
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* Accept integers and logicals not wider than the default integer/logical.  */
if|if
condition|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
condition|)
block|{
name|okay
operator|&=
name|anynum
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGER1
operator|||
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGER2
operator|||
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGER3
operator|)
expr_stmt|;
name|akt
operator|=
name|FFEINFO_kindtypeINTEGER1
expr_stmt|;
comment|/* The default.  */
block|}
elseif|else
if|if
condition|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeLOGICAL
condition|)
block|{
name|okay
operator|&=
name|anynum
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindtypeLOGICAL1
operator|||
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindtypeLOGICAL2
operator|||
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindtypeLOGICAL3
operator|)
expr_stmt|;
name|akt
operator|=
name|FFEINFO_kindtypeLOGICAL1
expr_stmt|;
comment|/* The default.  */
block|}
break|break;
case|case
literal|'*'
case|:
default|default:
break|break;
block|}
switch|switch
condition|(
name|elements
condition|)
block|{
name|ffebld
name|b
decl_stmt|;
case|case
operator|-
literal|1
case|:
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|ffeinfo_rank
argument_list|(
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|okay
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|ffeinfo_rank
argument_list|(
name|i
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
operator|||
operator|(
operator|(
name|b
operator|=
name|ffesymbol_arraysize
argument_list|(
name|ffebld_symter
argument_list|(
name|a
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|b
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_kindtypeINTEGERDEFAULT
operator|)
operator|||
operator|(
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|elements
operator|)
condition|)
name|okay
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|extra
condition|)
block|{
case|case
literal|'&'
case|:
if|if
condition|(
operator|(
name|ffeinfo_kind
argument_list|(
name|i
argument_list|)
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|!=
name|FFEBLD_opSUBSTR
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|!=
name|FFEBLD_opARRAYREF
operator|)
operator|)
condition|)
name|okay
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
if|if
condition|(
operator|(
name|ffeinfo_kind
argument_list|(
name|i
argument_list|)
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|!=
name|FFEBLD_opARRAYREF
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|!=
name|FFEBLD_opSUBSTR
operator|)
operator|)
condition|)
name|okay
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
case|case
literal|'i'
case|:
break|break;
default|default:
if|if
condition|(
name|ffeinfo_kind
argument_list|(
name|i
argument_list|)
operator|!=
name|FFEINFO_kindENTITY
condition|)
name|okay
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|optional
operator|==
literal|'!'
operator|)
operator|&&
name|lastarg_complex
condition|)
name|okay
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|okay
condition|)
block|{
comment|/* If it wasn't optional, it's an error, 		 else maybe it could match a later argspec.  */
if|if
condition|(
name|optional
operator|==
literal|'\0'
condition|)
return|return
name|FFEBAD_INTRINSIC_REF
return|;
break|break;
comment|/* Try next argspec. */
block|}
name|lastarg_complex
operator|=
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
expr_stmt|;
if|if
condition|(
name|anynum
condition|)
block|{
comment|/* If we know dummy arg type, convert to that now.  */
if|if
condition|(
operator|(
name|abt
operator|!=
name|FFEINFO_basictypeNONE
operator|)
operator|&&
operator|(
name|akt
operator|!=
name|FFEINFO_kindtypeNONE
operator|)
operator|&&
name|commit
condition|)
block|{
comment|/* We have a known type, convert hollerith/typeless 		     to it.  */
name|a
operator|=
name|ffeexpr_convert
argument_list|(
name|a
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|abt
argument_list|,
name|akt
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|ffebld_set_head
argument_list|(
name|arg
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
name|arg
operator|=
name|ffebld_trail
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Arg accepted, now move on. */
if|if
condition|(
name|optional
operator|==
literal|'*'
condition|)
continue|continue;
comment|/* Go ahead and try another arg. */
if|if
condition|(
name|required
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|(
name|required
operator|==
literal|'n'
operator|)
operator|||
operator|(
name|required
operator|==
literal|'+'
operator|)
condition|)
block|{
name|optional
operator|=
literal|'*'
expr_stmt|;
name|required
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|required
operator|==
literal|'p'
condition|)
name|required
operator|=
literal|'n'
expr_stmt|;
block|}
do|while
condition|(
name|TRUE
condition|)
do|;
block|}
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
return|return
name|FFEBAD_INTRINSIC_TOOMANY
return|;
comment|/* Set up the initial type for the return value of the function.  */
name|need_col
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|c
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'A'
case|:
name|bt
operator|=
name|FFEINFO_basictypeCHARACTER
expr_stmt|;
name|sz
operator|=
operator|(
name|c
index|[
literal|2
index|]
operator|==
literal|'*'
operator|)
condition|?
name|FFETARGET_charactersizeNONE
else|:
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|bt
operator|=
name|FFEINFO_basictypeCOMPLEX
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|bt
operator|=
name|FFEINFO_basictypeINTEGER
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|bt
operator|=
name|FFEINFO_basictypeLOGICAL
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|bt
operator|=
name|FFEINFO_basictypeREAL
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
case|case
literal|'F'
case|:
case|case
literal|'N'
case|:
case|case
literal|'S'
case|:
name|need_col
operator|=
name|TRUE
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'-'
case|:
default|default:
name|bt
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|c
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|kt
operator|=
operator|(
name|c
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bt
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|bt
operator|==
name|FFEINFO_basictypeLOGICAL
operator|)
condition|)
block|{
switch|switch
condition|(
name|kt
condition|)
block|{
comment|/* Translate to internal kinds for now! */
default|default:
break|break;
case|case
literal|2
case|:
name|kt
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|kt
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|kt
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|kt
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|kt
operator|=
name|ffecom_pointer_kind
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|ffe_is_90
argument_list|()
condition|)
name|need_col
operator|=
name|TRUE
expr_stmt|;
name|kt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|need_col
operator|=
name|TRUE
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'-'
case|:
default|default:
name|kt
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
break|break;
block|}
comment|/* Determine collective type of COL, if there is one.  */
if|if
condition|(
name|need_col
operator|||
name|c
index|[
name|colon
operator|+
literal|1
index|]
operator|!=
literal|'-'
condition|)
block|{
name|bool
name|okay
init|=
name|TRUE
decl_stmt|;
name|bool
name|have_anynum
init|=
name|FALSE
decl_stmt|;
name|int
name|arg_count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|args
operator|,
name|arg_count
operator|=
literal|0
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|ffebld_trail
argument_list|(
name|arg
argument_list|)
operator|,
name|arg_count
operator|++
control|)
block|{
name|ffebld
name|a
init|=
name|ffebld_head
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|ffeinfo
name|i
decl_stmt|;
name|bool
name|anynum
decl_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
continue|continue;
name|i
operator|=
name|ffebld_info
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
index|[
name|colon
operator|+
literal|1
index|]
operator|!=
literal|'*'
operator|&&
operator|(
name|c
index|[
name|colon
operator|+
literal|1
index|]
operator|-
literal|'0'
operator|)
operator|!=
name|arg_count
condition|)
continue|continue;
name|anynum
operator|=
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeHOLLERITH
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeTYPELESS
operator|)
expr_stmt|;
if|if
condition|(
name|anynum
condition|)
block|{
name|have_anynum
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|col_bt
operator|==
name|FFEINFO_basictypeNONE
operator|)
operator|&&
operator|(
name|col_kt
operator|==
name|FFEINFO_kindtypeNONE
operator|)
condition|)
block|{
name|col_bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|col_kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffeexpr_type_combine
argument_list|(
operator|&
name|col_bt
argument_list|,
operator|&
name|col_kt
argument_list|,
name|col_bt
argument_list|,
name|col_kt
argument_list|,
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|col_bt
operator|==
name|FFEINFO_basictypeNONE
operator|)
operator|||
operator|(
name|col_kt
operator|==
name|FFEINFO_kindtypeNONE
operator|)
condition|)
return|return
name|FFEBAD_INTRINSIC_REF
return|;
block|}
block|}
if|if
condition|(
name|have_anynum
operator|&&
operator|(
operator|(
name|col_bt
operator|==
name|FFEINFO_basictypeNONE
operator|)
operator|||
operator|(
name|col_kt
operator|==
name|FFEINFO_kindtypeNONE
operator|)
operator|)
condition|)
block|{
comment|/* No type, but have hollerith/typeless.  Use type of return 	     value to determine type of COL.  */
switch|switch
condition|(
name|c
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'A'
case|:
return|return
name|FFEBAD_INTRINSIC_REF
return|;
case|case
literal|'B'
case|:
case|case
literal|'I'
case|:
case|case
literal|'L'
case|:
if|if
condition|(
operator|(
name|col_bt
operator|!=
name|FFEINFO_basictypeNONE
operator|)
operator|&&
operator|(
name|col_bt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
condition|)
return|return
name|FFEBAD_INTRINSIC_REF
return|;
comment|/* Fall through.  */
case|case
literal|'N'
case|:
case|case
literal|'S'
case|:
case|case
literal|'-'
case|:
default|default:
name|col_bt
operator|=
name|FFEINFO_basictypeINTEGER
expr_stmt|;
name|col_kt
operator|=
name|FFEINFO_kindtypeINTEGER1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
operator|(
name|col_bt
operator|!=
name|FFEINFO_basictypeNONE
operator|)
operator|&&
operator|(
name|col_bt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
condition|)
return|return
name|FFEBAD_INTRINSIC_REF
return|;
name|col_bt
operator|=
name|FFEINFO_basictypeCOMPLEX
expr_stmt|;
name|col_kt
operator|=
name|FFEINFO_kindtypeREAL1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
operator|(
name|col_bt
operator|!=
name|FFEINFO_basictypeNONE
operator|)
operator|&&
operator|(
name|col_bt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
condition|)
return|return
name|FFEBAD_INTRINSIC_REF
return|;
comment|/* Fall through.  */
case|case
literal|'F'
case|:
name|col_bt
operator|=
name|FFEINFO_basictypeREAL
expr_stmt|;
name|col_kt
operator|=
name|FFEINFO_kindtypeREAL1
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|c
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'B'
case|:
name|okay
operator|=
operator|(
name|col_bt
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|col_bt
operator|==
name|FFEINFO_basictypeLOGICAL
operator|)
expr_stmt|;
if|if
condition|(
name|need_col
condition|)
name|bt
operator|=
name|col_bt
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|okay
operator|=
operator|(
name|col_bt
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|||
operator|(
name|col_bt
operator|==
name|FFEINFO_basictypeREAL
operator|)
expr_stmt|;
if|if
condition|(
name|need_col
condition|)
name|bt
operator|=
name|col_bt
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|okay
operator|=
operator|(
name|col_bt
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|||
operator|(
name|col_bt
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|col_bt
operator|==
name|FFEINFO_basictypeREAL
operator|)
expr_stmt|;
if|if
condition|(
name|need_col
condition|)
name|bt
operator|=
name|col_bt
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|okay
operator|=
operator|(
name|col_bt
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|col_bt
operator|==
name|FFEINFO_basictypeREAL
operator|)
operator|||
operator|(
name|col_bt
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
expr_stmt|;
if|if
condition|(
name|need_col
condition|)
name|bt
operator|=
operator|(
operator|(
name|col_bt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
condition|?
name|col_bt
else|:
name|FFEINFO_basictypeREAL
operator|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|c
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'='
case|:
if|if
condition|(
name|need_col
condition|)
name|kt
operator|=
name|col_kt
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|col_bt
operator|==
name|FFEINFO_basictypeCOMPLEX
condition|)
block|{
if|if
condition|(
name|col_kt
operator|!=
name|FFEINFO_kindtypeREALDEFAULT
condition|)
operator|*
name|check_intrin
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|need_col
condition|)
name|kt
operator|=
name|col_kt
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|okay
condition|)
return|return
name|FFEBAD_INTRINSIC_REF
return|;
block|}
comment|/* Now, convert args in the arglist to the final type of the COL.  */
for|for
control|(
name|argno
operator|=
literal|0
operator|,
name|argc
operator|=
operator|&
name|c
index|[
name|colon
operator|+
literal|3
index|]
operator|,
name|arg
operator|=
name|args
init|;
operator|*
name|argc
operator|!=
literal|'\0'
condition|;
operator|++
name|argno
control|)
block|{
name|char
name|optional
init|=
literal|'\0'
decl_stmt|;
name|char
name|required
init|=
literal|'\0'
decl_stmt|;
name|char
name|extra
init|=
literal|'\0'
decl_stmt|;
name|char
name|basic
decl_stmt|;
name|char
name|kind
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|elements
decl_stmt|;
name|bool
name|lastarg_complex
init|=
name|FALSE
decl_stmt|;
comment|/* We don't do anything with keywords yet.  */
do|do
block|{ 	}
do|while
condition|(
operator|*
operator|(
operator|++
name|argc
operator|)
operator|!=
literal|'='
condition|)
do|;
operator|++
name|argc
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argc
operator|==
literal|'?'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'!'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'*'
operator|)
condition|)
name|optional
operator|=
operator|*
operator|(
name|argc
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argc
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'n'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'p'
operator|)
condition|)
name|required
operator|=
operator|*
operator|(
name|argc
operator|++
operator|)
expr_stmt|;
name|basic
operator|=
operator|*
operator|(
name|argc
operator|++
operator|)
expr_stmt|;
name|kind
operator|=
operator|*
operator|(
name|argc
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|argc
operator|==
literal|'['
condition|)
block|{
name|length
operator|=
operator|*
operator|++
name|argc
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|argc
operator|!=
literal|']'
condition|)
name|length
operator|=
literal|10
operator|*
name|length
operator|+
operator|(
operator|*
operator|(
name|argc
operator|++
operator|)
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|argc
expr_stmt|;
block|}
else|else
name|length
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|argc
operator|==
literal|'('
condition|)
block|{
name|elements
operator|=
operator|*
operator|++
name|argc
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|argc
operator|!=
literal|')'
condition|)
name|elements
operator|=
literal|10
operator|*
name|elements
operator|+
operator|(
operator|*
operator|(
name|argc
operator|++
operator|)
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|argc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|argc
operator|==
literal|'&'
condition|)
block|{
name|elements
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|argc
expr_stmt|;
block|}
else|else
name|elements
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argc
operator|==
literal|'&'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'i'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'w'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'x'
operator|)
condition|)
name|extra
operator|=
operator|*
operator|(
name|argc
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|argc
operator|==
literal|','
condition|)
operator|++
name|argc
expr_stmt|;
comment|/* Break out of this loop only when current arg spec completely 	 processed.  */
do|do
block|{
name|bool
name|okay
decl_stmt|;
name|ffebld
name|a
decl_stmt|;
name|ffeinfo
name|i
decl_stmt|;
name|bool
name|anynum
decl_stmt|;
name|ffeinfoBasictype
name|abt
init|=
name|FFEINFO_basictypeNONE
decl_stmt|;
name|ffeinfoKindtype
name|akt
init|=
name|FFEINFO_kindtypeNONE
decl_stmt|;
if|if
condition|(
operator|(
name|arg
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_head
argument_list|(
name|arg
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
name|arg
operator|=
name|ffebld_trail
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
comment|/* Try next argspec. */
block|}
name|a
operator|=
name|ffebld_head
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|i
operator|=
name|ffebld_info
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|anynum
operator|=
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeHOLLERITH
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeTYPELESS
operator|)
expr_stmt|;
comment|/* Determine what the default type for anynum would be.  */
if|if
condition|(
name|anynum
condition|)
block|{
switch|switch
condition|(
name|c
index|[
name|colon
operator|+
literal|1
index|]
condition|)
block|{
case|case
literal|'-'
case|:
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|argno
operator|!=
operator|(
name|c
index|[
name|colon
operator|+
literal|1
index|]
operator|-
literal|'0'
operator|)
condition|)
break|break;
case|case
literal|'*'
case|:
name|abt
operator|=
name|col_bt
expr_stmt|;
name|akt
operator|=
name|col_kt
expr_stmt|;
break|break;
block|}
block|}
comment|/* Again, match arg up to the spec.  We go through all of 	     this again to properly follow the contour of optional 	     arguments.  Probably this level of flexibility is not 	     needed, perhaps it's even downright naughty.  */
switch|switch
condition|(
name|basic
condition|)
block|{
case|case
literal|'A'
case|:
name|okay
operator|=
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
operator|&&
operator|(
operator|(
name|length
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|ffeinfo_size
argument_list|(
name|i
argument_list|)
operator|==
operator|(
name|ffetargetCharacterSize
operator|)
name|length
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
expr_stmt|;
name|abt
operator|=
name|FFEINFO_basictypeCOMPLEX
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
expr_stmt|;
name|abt
operator|=
name|FFEINFO_basictypeINTEGER
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeLOGICAL
operator|)
expr_stmt|;
name|abt
operator|=
name|FFEINFO_basictypeLOGICAL
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeREAL
operator|)
expr_stmt|;
name|abt
operator|=
name|FFEINFO_basictypeREAL
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeLOGICAL
operator|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeREAL
operator|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeREAL
operator|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|okay
operator|=
name|anynum
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeREAL
operator|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|okay
operator|=
operator|(
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|==
name|FFEBLD_opLABTER
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|==
name|FFEBLD_opLABTOK
operator|)
operator|)
expr_stmt|;
name|elements
operator|=
operator|-
literal|1
expr_stmt|;
name|extra
operator|=
literal|'-'
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|okay
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeNONE
operator|)
operator|&&
operator|(
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindtypeNONE
operator|)
operator|&&
operator|(
name|ffeinfo_kind
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindSUBROUTINE
operator|)
operator|)
operator|||
operator|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
operator|)
operator|&&
operator|(
name|ffeinfo_kind
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindFUNCTION
operator|)
operator|)
operator|||
operator|(
name|ffeinfo_kind
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindNONE
operator|)
operator|)
operator|&&
operator|(
operator|(
name|ffeinfo_where
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_whereDUMMY
operator|)
operator|||
operator|(
name|ffeinfo_where
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_whereGLOBAL
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|ffeinfo_kind
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_kindENTITY
operator|)
operator|)
operator|)
expr_stmt|;
name|elements
operator|=
operator|-
literal|1
expr_stmt|;
name|extra
operator|=
literal|'-'
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
default|default:
name|okay
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|akt
operator|=
operator|(
name|kind
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeLOGICAL
operator|)
condition|)
block|{
switch|switch
condition|(
name|akt
condition|)
block|{
comment|/* Translate to internal kinds for now! */
default|default:
break|break;
case|case
literal|2
case|:
name|akt
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|akt
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|akt
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|akt
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|akt
operator|=
name|ffecom_pointer_kind
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|okay
operator|&=
name|anynum
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
operator|==
name|akt
operator|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|okay
operator|&=
name|anynum
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|i
argument_list|)
operator|==
name|firstarg_kt
operator|)
expr_stmt|;
name|akt
operator|=
operator|(
name|firstarg_kt
operator|==
name|FFEINFO_kindtype
operator|)
condition|?
name|FFEINFO_kindtypeNONE
else|:
name|firstarg_kt
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
default|default:
break|break;
block|}
switch|switch
condition|(
name|elements
condition|)
block|{
name|ffebld
name|b
decl_stmt|;
case|case
operator|-
literal|1
case|:
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|ffeinfo_rank
argument_list|(
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|okay
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|ffeinfo_rank
argument_list|(
name|i
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
operator|||
operator|(
operator|(
name|b
operator|=
name|ffesymbol_arraysize
argument_list|(
name|ffebld_symter
argument_list|(
name|a
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|b
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_kindtypeINTEGERDEFAULT
operator|)
operator|||
operator|(
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|elements
operator|)
condition|)
name|okay
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|extra
condition|)
block|{
case|case
literal|'&'
case|:
if|if
condition|(
operator|(
name|ffeinfo_kind
argument_list|(
name|i
argument_list|)
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|!=
name|FFEBLD_opSUBSTR
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|!=
name|FFEBLD_opARRAYREF
operator|)
operator|)
condition|)
name|okay
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
if|if
condition|(
operator|(
name|ffeinfo_kind
argument_list|(
name|i
argument_list|)
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|!=
name|FFEBLD_opARRAYREF
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|a
argument_list|)
operator|!=
name|FFEBLD_opSUBSTR
operator|)
operator|)
condition|)
name|okay
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
case|case
literal|'i'
case|:
break|break;
default|default:
if|if
condition|(
name|ffeinfo_kind
argument_list|(
name|i
argument_list|)
operator|!=
name|FFEINFO_kindENTITY
condition|)
name|okay
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|optional
operator|==
literal|'!'
operator|)
operator|&&
name|lastarg_complex
condition|)
name|okay
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|okay
condition|)
block|{
comment|/* If it wasn't optional, it's an error, 		 else maybe it could match a later argspec.  */
if|if
condition|(
name|optional
operator|==
literal|'\0'
condition|)
return|return
name|FFEBAD_INTRINSIC_REF
return|;
break|break;
comment|/* Try next argspec. */
block|}
name|lastarg_complex
operator|=
operator|(
name|ffeinfo_basictype
argument_list|(
name|i
argument_list|)
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
expr_stmt|;
if|if
condition|(
name|anynum
operator|&&
name|commit
condition|)
block|{
comment|/* If we know dummy arg type, convert to that now.  */
if|if
condition|(
name|abt
operator|==
name|FFEINFO_basictypeNONE
condition|)
name|abt
operator|=
name|FFEINFO_basictypeINTEGER
expr_stmt|;
if|if
condition|(
name|akt
operator|==
name|FFEINFO_kindtypeNONE
condition|)
name|akt
operator|=
name|FFEINFO_kindtypeINTEGER1
expr_stmt|;
comment|/* We have a known type, convert hollerith/typeless to it.  */
name|a
operator|=
name|ffeexpr_convert
argument_list|(
name|a
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|abt
argument_list|,
name|akt
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|ffebld_set_head
argument_list|(
name|arg
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
index|[
name|colon
operator|+
literal|1
index|]
operator|==
literal|'*'
operator|)
operator|&&
name|commit
condition|)
block|{
comment|/* This is where we promote types to the consensus 		 type for the COL.  Maybe this is where -fpedantic 		 should issue a warning as well.  */
name|a
operator|=
name|ffeexpr_convert
argument_list|(
name|a
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|col_bt
argument_list|,
name|col_kt
argument_list|,
literal|0
argument_list|,
name|ffeinfo_size
argument_list|(
name|i
argument_list|)
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|ffebld_set_head
argument_list|(
name|arg
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
name|ffebld_trail
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Arg accepted, now move on. */
if|if
condition|(
name|optional
operator|==
literal|'*'
condition|)
continue|continue;
comment|/* Go ahead and try another arg. */
if|if
condition|(
name|required
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|(
name|required
operator|==
literal|'n'
operator|)
operator|||
operator|(
name|required
operator|==
literal|'+'
operator|)
condition|)
block|{
name|optional
operator|=
literal|'*'
expr_stmt|;
name|required
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|required
operator|==
literal|'p'
condition|)
name|required
operator|=
literal|'n'
expr_stmt|;
block|}
do|while
condition|(
name|TRUE
condition|)
do|;
block|}
operator|*
name|xbt
operator|=
name|bt
expr_stmt|;
operator|*
name|xkt
operator|=
name|kt
expr_stmt|;
operator|*
name|xsz
operator|=
name|sz
expr_stmt|;
return|return
name|FFEBAD
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ffeintrin_check_any_
parameter_list|(
name|ffebld
name|arglist
parameter_list|)
block|{
name|ffebld
name|item
decl_stmt|;
for|for
control|(
init|;
name|arglist
operator|!=
name|NULL
condition|;
name|arglist
operator|=
name|ffebld_trail
argument_list|(
name|arglist
argument_list|)
control|)
block|{
name|item
operator|=
name|ffebld_head
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|item
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|item
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Compare a forced-to-uppercase name with a known-upper-case name.  */
end_comment

begin_function
specifier|static
name|int
name|upcasecmp_
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|ucname
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|name
operator|!=
literal|0
operator|&&
operator|*
name|ucname
operator|!=
literal|0
condition|;
name|name
operator|++
operator|,
name|ucname
operator|++
control|)
block|{
name|int
name|i
init|=
name|TOUPPER
argument_list|(
operator|*
name|name
argument_list|)
operator|-
operator|*
name|ucname
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|i
return|;
block|}
return|return
operator|*
name|name
operator|-
operator|*
name|ucname
return|;
block|}
end_function

begin_comment
comment|/* Compare name to intrinsic's name.    The intrinsics table is sorted on the upper case entries; so first    compare irrespective of case on the `uc' entry.  If it matches,    compare according to the setting of intrinsics case comparison mode.  */
end_comment

begin_function
specifier|static
name|int
name|ffeintrin_cmp_name_
parameter_list|(
specifier|const
name|void
modifier|*
name|name
parameter_list|,
specifier|const
name|void
modifier|*
name|intrinsic
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|uc
init|=
operator|(
operator|(
specifier|const
expr|struct
name|_ffeintrin_name_
operator|*
operator|)
name|intrinsic
operator|)
operator|->
name|name_uc
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|lc
init|=
operator|(
operator|(
specifier|const
expr|struct
name|_ffeintrin_name_
operator|*
operator|)
name|intrinsic
operator|)
operator|->
name|name_lc
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|ic
init|=
operator|(
operator|(
specifier|const
expr|struct
name|_ffeintrin_name_
operator|*
operator|)
name|intrinsic
operator|)
operator|->
name|name_ic
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|upcasecmp_
argument_list|(
name|name
argument_list|,
name|uc
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|ffe_case_intrin
argument_list|()
condition|)
block|{
case|case
name|FFE_caseLOWER
case|:
return|return
name|strcmp
argument_list|(
name|name
argument_list|,
name|lc
argument_list|)
return|;
case|case
name|FFE_caseINITCAP
case|:
return|return
name|strcmp
argument_list|(
name|name
argument_list|,
name|ic
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Return basic type of intrinsic implementation, based on its    run-time implementation *only*.  (This is used only when    the type of an intrinsic name is needed without having a    list of arguments, i.e. an interface signature, such as when    passing the intrinsic itself, or really the run-time-library    function, as an argument.)     If there's no eligible intrinsic implementation, there must be    a bug somewhere else; no such reference should have been permitted    to go this far.  (Well, this might be wrong.)  */
end_comment

begin_function
name|ffeinfoBasictype
name|ffeintrin_basictype
parameter_list|(
name|ffeintrinSpec
name|spec
parameter_list|)
block|{
name|ffeintrinImp
name|imp
decl_stmt|;
name|ffecomGfrt
name|gfrt
decl_stmt|;
name|assert
argument_list|(
name|spec
operator|<
name|FFEINTRIN_spec
argument_list|)
expr_stmt|;
name|imp
operator|=
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|implementation
expr_stmt|;
name|assert
argument_list|(
name|imp
operator|<
name|FFEINTRIN_imp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_f2c
argument_list|()
condition|)
name|gfrt
operator|=
name|ffeintrin_imps_
index|[
name|imp
index|]
operator|.
name|gfrt_f2c
expr_stmt|;
else|else
name|gfrt
operator|=
name|ffeintrin_imps_
index|[
name|imp
index|]
operator|.
name|gfrt_gnu
expr_stmt|;
name|assert
argument_list|(
name|gfrt
operator|!=
name|FFECOM_gfrt
argument_list|)
expr_stmt|;
return|return
name|ffecom_gfrt_basictype
argument_list|(
name|gfrt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return family to which specific intrinsic belongs.  */
end_comment

begin_function
name|ffeintrinFamily
name|ffeintrin_family
parameter_list|(
name|ffeintrinSpec
name|spec
parameter_list|)
block|{
if|if
condition|(
name|spec
operator|>=
name|FFEINTRIN_spec
condition|)
return|return
name|FALSE
return|;
return|return
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|family
return|;
block|}
end_function

begin_comment
comment|/* Check and fill in info on func/subr ref node.     ffebld expr;			// FUNCREF or SUBRREF with no info (caller 				// gets it from the modified info structure).    ffeinfo info;		// Already filled in, will be overwritten.    ffelexToken token;		// Used for error message.    ffeintrin_fulfill_generic (&expr,&info, token);     Based on the generic id, figure out which specific procedure is meant and    pick that one.  Else return an error, a la _specific.  */
end_comment

begin_function
name|void
name|ffeintrin_fulfill_generic
parameter_list|(
name|ffebld
modifier|*
name|expr
parameter_list|,
name|ffeinfo
modifier|*
name|info
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebld
name|symter
decl_stmt|;
name|ffebldOp
name|op
decl_stmt|;
name|ffeintrinGen
name|gen
decl_stmt|;
name|ffeintrinSpec
name|spec
init|=
name|FFEINTRIN_specNONE
decl_stmt|;
name|ffeinfoBasictype
name|bt
init|=
name|FFEINFO_basictypeNONE
decl_stmt|;
name|ffeinfoKindtype
name|kt
init|=
name|FFEINFO_kindtypeNONE
decl_stmt|;
name|ffetargetCharacterSize
name|sz
init|=
name|FFETARGET_charactersizeNONE
decl_stmt|;
name|ffeintrinImp
name|imp
decl_stmt|;
name|ffeintrinSpec
name|tspec
decl_stmt|;
name|ffeintrinImp
name|nimp
init|=
name|FFEINTRIN_impNONE
decl_stmt|;
name|ffebad
name|error
decl_stmt|;
name|bool
name|any
init|=
name|FALSE
decl_stmt|;
name|bool
name|highly_specific
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|op
operator|=
name|ffebld_op
argument_list|(
operator|*
name|expr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|op
operator|==
name|FFEBLD_opFUNCREF
operator|)
operator|||
operator|(
name|op
operator|==
name|FFEBLD_opSUBRREF
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|ffebld_left
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opSYMTER
argument_list|)
expr_stmt|;
name|gen
operator|=
name|ffebld_symter_generic
argument_list|(
name|ffebld_left
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|gen
operator|!=
name|FFEINTRIN_genNONE
argument_list|)
expr_stmt|;
name|imp
operator|=
name|FFEINTRIN_impNONE
expr_stmt|;
name|error
operator|=
name|FFEBAD
expr_stmt|;
name|any
operator|=
name|ffeintrin_check_any_
argument_list|(
name|ffebld_right
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|specs
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|tspec
operator|=
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|specs
index|[
name|i
index|]
operator|)
operator|!=
name|FFEINTRIN_specNONE
operator|)
operator|&&
operator|!
name|any
condition|;
operator|++
name|i
control|)
block|{
name|ffeintrinImp
name|timp
init|=
name|ffeintrin_specs_
index|[
name|tspec
index|]
operator|.
name|implementation
decl_stmt|;
name|ffeinfoBasictype
name|tbt
decl_stmt|;
name|ffeinfoKindtype
name|tkt
decl_stmt|;
name|ffetargetCharacterSize
name|tsz
decl_stmt|;
name|ffeIntrinsicState
name|state
init|=
name|ffeintrin_state_family
argument_list|(
name|ffeintrin_specs_
index|[
name|tspec
index|]
operator|.
name|family
argument_list|)
decl_stmt|;
name|ffebad
name|terror
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|FFE_intrinsicstateDELETED
condition|)
continue|continue;
if|if
condition|(
name|timp
operator|!=
name|FFEINTRIN_impNONE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ffeintrin_imps_
index|[
name|timp
index|]
operator|.
name|control
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|!=
operator|!
operator|(
name|ffebld_op
argument_list|(
operator|*
name|expr
argument_list|)
operator|==
name|FFEBLD_opSUBRREF
operator|)
condition|)
continue|continue;
comment|/* Form of reference must match form of specific. */
block|}
if|if
condition|(
name|state
operator|==
name|FFE_intrinsicstateDISABLED
condition|)
name|terror
operator|=
name|FFEBAD_INTRINSIC_DISABLED
expr_stmt|;
elseif|else
if|if
condition|(
name|timp
operator|==
name|FFEINTRIN_impNONE
condition|)
name|terror
operator|=
name|FFEBAD_INTRINSIC_UNIMPL
expr_stmt|;
else|else
block|{
name|terror
operator|=
name|ffeintrin_check_
argument_list|(
name|timp
argument_list|,
name|ffebld_op
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|,
name|ffebld_right
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|,
operator|&
name|tbt
argument_list|,
operator|&
name|tkt
argument_list|,
operator|&
name|tsz
argument_list|,
name|NULL
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|terror
operator|==
name|FFEBAD
condition|)
block|{
if|if
condition|(
name|imp
operator|!=
name|FFEINTRIN_impNONE
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INTRINSIC_AMBIG
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffeintrin_specs_
index|[
name|tspec
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ffebld_symter_specific
argument_list|(
name|ffebld_left
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|)
operator|==
name|tspec
condition|)
name|highly_specific
operator|=
name|TRUE
expr_stmt|;
name|imp
operator|=
name|timp
expr_stmt|;
name|spec
operator|=
name|tspec
expr_stmt|;
name|bt
operator|=
name|tbt
expr_stmt|;
name|kt
operator|=
name|tkt
expr_stmt|;
name|sz
operator|=
name|tkt
expr_stmt|;
name|error
operator|=
name|terror
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|terror
operator|!=
name|FFEBAD
condition|)
block|{
comment|/* This error has precedence over others. */
if|if
condition|(
operator|(
name|error
operator|==
name|FFEBAD_INTRINSIC_DISABLED
operator|)
operator|||
operator|(
name|error
operator|==
name|FFEBAD_INTRINSIC_UNIMPL
operator|)
condition|)
name|error
operator|=
name|FFEBAD
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
name|FFEBAD
condition|)
name|error
operator|=
name|terror
expr_stmt|;
block|}
if|if
condition|(
name|any
operator|||
operator|(
name|imp
operator|==
name|FFEINTRIN_impNONE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|any
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|FFEBAD
condition|)
name|error
operator|=
name|FFEBAD_INTRINSIC_REF
expr_stmt|;
name|ffebad_start
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
operator|*
name|expr
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
operator|*
name|info
operator|=
name|ffeinfo_new_any
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|highly_specific
operator|&&
operator|(
name|nimp
operator|!=
name|FFEINTRIN_impNONE
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lineno=%ld, gen=%s, imp=%s, timp=%s\n"
argument_list|,
operator|(
name|long
operator|)
name|input_line
argument_list|,
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|name
argument_list|,
name|ffeintrin_imps_
index|[
name|imp
index|]
operator|.
name|name
argument_list|,
name|ffeintrin_imps_
index|[
name|nimp
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|"Ambiguous generic reference"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|error
operator|=
name|ffeintrin_check_
argument_list|(
name|imp
argument_list|,
name|ffebld_op
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|,
name|ffebld_right
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|,
operator|&
name|bt
argument_list|,
operator|&
name|kt
argument_list|,
operator|&
name|sz
argument_list|,
name|NULL
argument_list|,
name|t
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
name|FFEBAD
argument_list|)
expr_stmt|;
operator|*
name|info
operator|=
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereFLEETING
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|symter
operator|=
name|ffebld_left
argument_list|(
operator|*
name|expr
argument_list|)
expr_stmt|;
name|ffebld_symter_set_specific
argument_list|(
name|symter
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|ffebld_symter_set_implementation
argument_list|(
name|symter
argument_list|,
name|imp
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|symter
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
operator|(
name|bt
operator|==
name|FFEINFO_basictypeNONE
operator|)
condition|?
name|FFEINFO_kindSUBROUTINE
else|:
name|FFEINFO_kindFUNCTION
argument_list|,
name|FFEINFO_whereINTRINSIC
argument_list|,
name|sz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffesymbol_attrs
argument_list|(
name|ffebld_symter
argument_list|(
name|symter
argument_list|)
argument_list|)
operator|&
name|FFESYMBOL_attrsTYPE
operator|)
operator|&&
operator|(
operator|(
operator|(
name|bt
operator|!=
name|ffesymbol_basictype
argument_list|(
name|ffebld_symter
argument_list|(
name|symter
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|kt
operator|!=
name|ffesymbol_kindtype
argument_list|(
name|ffebld_symter
argument_list|(
name|symter
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|sz
operator|!=
name|FFETARGET_charactersizeNONE
operator|)
operator|&&
operator|(
name|sz
operator|!=
name|ffesymbol_size
argument_list|(
name|ffebld_symter
argument_list|(
name|symter
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INTRINSIC_TYPE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ffeintrin_imps_
index|[
name|imp
index|]
operator|.
name|y2kbad
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INTRINSIC_Y2KBAD
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check and fill in info on func/subr ref node.     ffebld expr;			// FUNCREF or SUBRREF with no info (caller 				// gets it from the modified info structure).    ffeinfo info;		// Already filled in, will be overwritten.    bool check_intrin;           // May be omitted, else set TRUE if intrinsic needs checking.    ffelexToken token;		// Used for error message.    ffeintrin_fulfill_specific (&expr,&info,&check_intrin, token);     Based on the specific id, determine whether the arg list is valid    (number, type, rank, and kind of args) and fill in the info structure    accordingly.	 Currently don't rewrite the expression, but perhaps    someday do so for constant collapsing, except when an error occurs,    in which case it is overwritten with ANY and info is also overwritten    accordingly.	 */
end_comment

begin_function
name|void
name|ffeintrin_fulfill_specific
parameter_list|(
name|ffebld
modifier|*
name|expr
parameter_list|,
name|ffeinfo
modifier|*
name|info
parameter_list|,
name|bool
modifier|*
name|check_intrin
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebld
name|symter
decl_stmt|;
name|ffebldOp
name|op
decl_stmt|;
name|ffeintrinGen
name|gen
decl_stmt|;
name|ffeintrinSpec
name|spec
decl_stmt|;
name|ffeintrinImp
name|imp
decl_stmt|;
name|ffeinfoBasictype
name|bt
init|=
name|FFEINFO_basictypeNONE
decl_stmt|;
name|ffeinfoKindtype
name|kt
init|=
name|FFEINFO_kindtypeNONE
decl_stmt|;
name|ffetargetCharacterSize
name|sz
init|=
name|FFETARGET_charactersizeNONE
decl_stmt|;
name|ffeIntrinsicState
name|state
decl_stmt|;
name|ffebad
name|error
decl_stmt|;
name|bool
name|any
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|op
operator|=
name|ffebld_op
argument_list|(
operator|*
name|expr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|op
operator|==
name|FFEBLD_opFUNCREF
operator|)
operator|||
operator|(
name|op
operator|==
name|FFEBLD_opSUBRREF
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|ffebld_left
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opSYMTER
argument_list|)
expr_stmt|;
name|gen
operator|=
name|ffebld_symter_generic
argument_list|(
name|ffebld_left
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|spec
operator|=
name|ffebld_symter_specific
argument_list|(
name|ffebld_left
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|spec
operator|!=
name|FFEINTRIN_specNONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
operator|!=
name|FFEINTRIN_genNONE
condition|)
name|name
operator|=
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|name
expr_stmt|;
else|else
name|name
operator|=
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|name
expr_stmt|;
name|state
operator|=
name|ffeintrin_state_family
argument_list|(
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|family
argument_list|)
expr_stmt|;
name|imp
operator|=
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|implementation
expr_stmt|;
if|if
condition|(
name|check_intrin
operator|!=
name|NULL
condition|)
operator|*
name|check_intrin
operator|=
name|FALSE
expr_stmt|;
name|any
operator|=
name|ffeintrin_check_any_
argument_list|(
name|ffebld_right
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|FFE_intrinsicstateDISABLED
condition|)
name|error
operator|=
name|FFEBAD_INTRINSIC_DISABLED
expr_stmt|;
elseif|else
if|if
condition|(
name|imp
operator|==
name|FFEINTRIN_impNONE
condition|)
name|error
operator|=
name|FFEBAD_INTRINSIC_UNIMPL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|any
condition|)
block|{
name|error
operator|=
name|ffeintrin_check_
argument_list|(
name|imp
argument_list|,
name|ffebld_op
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|,
name|ffebld_right
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|,
operator|&
name|bt
argument_list|,
operator|&
name|kt
argument_list|,
operator|&
name|sz
argument_list|,
name|check_intrin
argument_list|,
name|t
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|FFEBAD
expr_stmt|;
comment|/* Not really needed, but quiet -Wuninitialized. */
if|if
condition|(
name|any
operator|||
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|any
condition|)
block|{
name|ffebad_start
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
operator|*
name|expr
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
operator|*
name|info
operator|=
name|ffeinfo_new_any
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|*
name|info
operator|=
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereFLEETING
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|symter
operator|=
name|ffebld_left
argument_list|(
operator|*
name|expr
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|symter
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
operator|(
name|bt
operator|==
name|FFEINFO_basictypeNONE
operator|)
condition|?
name|FFEINFO_kindSUBROUTINE
else|:
name|FFEINFO_kindFUNCTION
argument_list|,
name|FFEINFO_whereINTRINSIC
argument_list|,
name|sz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffesymbol_attrs
argument_list|(
name|ffebld_symter
argument_list|(
name|symter
argument_list|)
argument_list|)
operator|&
name|FFESYMBOL_attrsTYPE
operator|)
operator|&&
operator|(
operator|(
operator|(
name|bt
operator|!=
name|ffesymbol_basictype
argument_list|(
name|ffebld_symter
argument_list|(
name|symter
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|kt
operator|!=
name|ffesymbol_kindtype
argument_list|(
name|ffebld_symter
argument_list|(
name|symter
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|sz
operator|!=
name|ffesymbol_size
argument_list|(
name|ffebld_symter
argument_list|(
name|symter
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INTRINSIC_TYPE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ffeintrin_imps_
index|[
name|imp
index|]
operator|.
name|y2kbad
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INTRINSIC_Y2KBAD
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return run-time index of intrinsic implementation as direct call.  */
end_comment

begin_function
name|ffecomGfrt
name|ffeintrin_gfrt_direct
parameter_list|(
name|ffeintrinImp
name|imp
parameter_list|)
block|{
name|assert
argument_list|(
name|imp
operator|<
name|FFEINTRIN_imp
argument_list|)
expr_stmt|;
return|return
name|ffeintrin_imps_
index|[
name|imp
index|]
operator|.
name|gfrt_direct
return|;
block|}
end_function

begin_comment
comment|/* Return run-time index of intrinsic implementation as actual argument.  */
end_comment

begin_function
name|ffecomGfrt
name|ffeintrin_gfrt_indirect
parameter_list|(
name|ffeintrinImp
name|imp
parameter_list|)
block|{
name|assert
argument_list|(
name|imp
operator|<
name|FFEINTRIN_imp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffe_is_f2c
argument_list|()
condition|)
return|return
name|ffeintrin_imps_
index|[
name|imp
index|]
operator|.
name|gfrt_gnu
return|;
return|return
name|ffeintrin_imps_
index|[
name|imp
index|]
operator|.
name|gfrt_f2c
return|;
block|}
end_function

begin_function
name|void
name|ffeintrin_init_0
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|;
specifier|const
name|char
modifier|*
name|p2
decl_stmt|;
specifier|const
name|char
modifier|*
name|p3
decl_stmt|;
name|int
name|colon
decl_stmt|;
if|if
condition|(
operator|!
name|ffe_is_do_internal_checks
argument_list|()
condition|)
return|return;
name|assert
argument_list|(
name|FFEINTRIN_gen
operator|==
name|ARRAY_SIZE
argument_list|(
name|ffeintrin_gens_
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|FFEINTRIN_imp
operator|==
name|ARRAY_SIZE
argument_list|(
name|ffeintrin_imps_
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|FFEINTRIN_spec
operator|==
name|ARRAY_SIZE
argument_list|(
name|ffeintrin_specs_
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffeintrin_names_
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
comment|/* Make sure binary-searched list is in alpha 				   order. */
if|if
condition|(
name|strcmp
argument_list|(
name|ffeintrin_names_
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|name_uc
argument_list|,
name|ffeintrin_names_
index|[
name|i
index|]
operator|.
name|name_uc
argument_list|)
operator|>=
literal|0
condition|)
name|assert
argument_list|(
literal|"name list out of order"
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffeintrin_names_
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|assert
argument_list|(
operator|(
name|ffeintrin_names_
index|[
name|i
index|]
operator|.
name|generic
operator|==
name|FFEINTRIN_genNONE
operator|)
operator|||
operator|(
name|ffeintrin_names_
index|[
name|i
index|]
operator|.
name|specific
operator|==
name|FFEINTRIN_specNONE
operator|)
argument_list|)
expr_stmt|;
name|p1
operator|=
name|ffeintrin_names_
index|[
name|i
index|]
operator|.
name|name_uc
expr_stmt|;
name|p2
operator|=
name|ffeintrin_names_
index|[
name|i
index|]
operator|.
name|name_lc
expr_stmt|;
name|p3
operator|=
name|ffeintrin_names_
index|[
name|i
index|]
operator|.
name|name_ic
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p1
operator|!=
literal|'\0'
operator|&&
operator|*
name|p2
operator|!=
literal|'\0'
operator|&&
operator|*
name|p3
operator|!=
literal|'\0'
condition|;
operator|++
name|p1
operator|,
operator|++
name|p2
operator|,
operator|++
name|p3
control|)
block|{
if|if
condition|(
operator|(
name|ISDIGIT
argument_list|(
operator|*
name|p1
argument_list|)
operator|||
operator|(
operator|*
name|p1
operator|==
literal|'_'
operator|)
operator|)
operator|&&
operator|(
operator|*
name|p1
operator|==
operator|*
name|p2
operator|)
operator|&&
operator|(
operator|*
name|p1
operator|==
operator|*
name|p3
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ISUPPER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p1
argument_list|)
operator|||
operator|!
name|ISLOWER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p2
argument_list|)
operator|||
operator|(
operator|*
name|p1
operator|!=
name|TOUPPER
argument_list|(
operator|*
name|p2
argument_list|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|p3
operator|!=
operator|*
name|p1
operator|)
operator|&&
operator|(
operator|*
name|p3
operator|!=
operator|*
name|p2
operator|)
operator|)
condition|)
break|break;
block|}
name|assert
argument_list|(
operator|(
operator|*
name|p1
operator|==
operator|*
name|p2
operator|)
operator|&&
operator|(
operator|*
name|p1
operator|==
operator|*
name|p3
operator|)
operator|&&
operator|(
operator|*
name|p1
operator|==
literal|'\0'
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffeintrin_imps_
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|ffeintrin_imps_
index|[
name|i
index|]
operator|.
name|control
decl_stmt|;
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'A'
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'C'
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'I'
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'L'
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'R'
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'B'
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'F'
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'N'
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'S'
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad return-base-type\n"
argument_list|,
name|ffeintrin_imps_
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|c
index|[
literal|1
index|]
operator|!=
literal|'-'
operator|)
operator|&&
operator|(
name|c
index|[
literal|1
index|]
operator|!=
literal|'='
operator|)
operator|&&
operator|(
operator|(
name|c
index|[
literal|1
index|]
operator|<
literal|'1'
operator|)
operator|||
operator|(
name|c
index|[
literal|1
index|]
operator|>
literal|'9'
operator|)
operator|)
operator|&&
operator|(
name|c
index|[
literal|1
index|]
operator|!=
literal|'C'
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad return-kind-type\n"
argument_list|,
name|ffeintrin_imps_
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
name|colon
operator|=
literal|2
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
index|[
literal|2
index|]
operator|!=
literal|'*'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad return-modifier\n"
argument_list|,
name|ffeintrin_imps_
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|colon
operator|=
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
index|[
name|colon
index|]
operator|!=
literal|':'
operator|)
operator|||
operator|(
name|c
index|[
name|colon
operator|+
literal|2
index|]
operator|!=
literal|':'
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad control\n"
argument_list|,
name|ffeintrin_imps_
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|c
index|[
name|colon
operator|+
literal|1
index|]
operator|!=
literal|'-'
operator|)
operator|&&
operator|(
name|c
index|[
name|colon
operator|+
literal|1
index|]
operator|!=
literal|'*'
operator|)
operator|&&
operator|(
operator|!
name|ISDIGIT
argument_list|(
name|c
index|[
name|colon
operator|+
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad COL-spec\n"
argument_list|,
name|ffeintrin_imps_
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|c
operator|+=
operator|(
name|colon
operator|+
literal|3
operator|)
expr_stmt|;
while|while
condition|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
while|while
condition|(
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'='
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|','
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
operator|++
name|c
expr_stmt|;
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'='
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad keyword\n"
argument_list|,
name|ffeintrin_imps_
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|c
index|[
literal|1
index|]
operator|==
literal|'?'
operator|)
operator|||
operator|(
name|c
index|[
literal|1
index|]
operator|==
literal|'!'
operator|)
operator|||
operator|(
name|c
index|[
literal|1
index|]
operator|==
literal|'+'
operator|)
operator|||
operator|(
name|c
index|[
literal|1
index|]
operator|==
literal|'*'
operator|)
operator|||
operator|(
name|c
index|[
literal|1
index|]
operator|==
literal|'n'
operator|)
operator|||
operator|(
name|c
index|[
literal|1
index|]
operator|==
literal|'p'
operator|)
condition|)
operator|++
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
index|[
literal|1
index|]
operator|!=
literal|'-'
operator|)
operator|&&
operator|(
name|c
index|[
literal|1
index|]
operator|!=
literal|'A'
operator|)
operator|&&
operator|(
name|c
index|[
literal|1
index|]
operator|!=
literal|'C'
operator|)
operator|&&
operator|(
name|c
index|[
literal|1
index|]
operator|!=
literal|'I'
operator|)
operator|&&
operator|(
name|c
index|[
literal|1
index|]
operator|!=
literal|'L'
operator|)
operator|&&
operator|(
name|c
index|[
literal|1
index|]
operator|!=
literal|'R'
operator|)
operator|&&
operator|(
name|c
index|[
literal|1
index|]
operator|!=
literal|'B'
operator|)
operator|&&
operator|(
name|c
index|[
literal|1
index|]
operator|!=
literal|'F'
operator|)
operator|&&
operator|(
name|c
index|[
literal|1
index|]
operator|!=
literal|'N'
operator|)
operator|&&
operator|(
name|c
index|[
literal|1
index|]
operator|!=
literal|'S'
operator|)
operator|&&
operator|(
name|c
index|[
literal|1
index|]
operator|!=
literal|'g'
operator|)
operator|&&
operator|(
name|c
index|[
literal|1
index|]
operator|!=
literal|'s'
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad arg-base-type\n"
argument_list|,
name|ffeintrin_imps_
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|c
index|[
literal|2
index|]
operator|!=
literal|'*'
operator|)
operator|&&
operator|(
operator|(
name|c
index|[
literal|2
index|]
operator|<
literal|'1'
operator|)
operator|||
operator|(
name|c
index|[
literal|2
index|]
operator|>
literal|'9'
operator|)
operator|)
operator|&&
operator|(
name|c
index|[
literal|2
index|]
operator|!=
literal|'A'
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad arg-kind-type\n"
argument_list|,
name|ffeintrin_imps_
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
index|[
literal|3
index|]
operator|==
literal|'['
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|ISDIGIT
argument_list|(
name|c
index|[
literal|4
index|]
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|c
index|[
literal|5
index|]
operator|!=
literal|']'
operator|)
operator|&&
operator|(
operator|++
name|c
operator|,
operator|!
name|ISDIGIT
argument_list|(
name|c
index|[
literal|4
index|]
argument_list|)
operator|||
operator|(
name|c
index|[
literal|5
index|]
operator|!=
literal|']'
operator|)
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad arg-len\n"
argument_list|,
name|ffeintrin_imps_
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|c
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|c
index|[
literal|3
index|]
operator|==
literal|'('
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|ISDIGIT
argument_list|(
name|c
index|[
literal|4
index|]
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|c
index|[
literal|5
index|]
operator|!=
literal|')'
operator|)
operator|&&
operator|(
operator|++
name|c
operator|,
operator|!
name|ISDIGIT
argument_list|(
name|c
index|[
literal|4
index|]
argument_list|)
operator|||
operator|(
name|c
index|[
literal|5
index|]
operator|!=
literal|')'
operator|)
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad arg-rank\n"
argument_list|,
name|ffeintrin_imps_
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|c
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
index|[
literal|3
index|]
operator|==
literal|'&'
operator|)
operator|&&
operator|(
name|c
index|[
literal|4
index|]
operator|==
literal|'&'
operator|)
condition|)
operator|++
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
index|[
literal|3
index|]
operator|==
literal|'&'
operator|)
operator|||
operator|(
name|c
index|[
literal|3
index|]
operator|==
literal|'i'
operator|)
operator|||
operator|(
name|c
index|[
literal|3
index|]
operator|==
literal|'w'
operator|)
operator|||
operator|(
name|c
index|[
literal|3
index|]
operator|==
literal|'x'
operator|)
condition|)
operator|++
name|c
expr_stmt|;
if|if
condition|(
name|c
index|[
literal|3
index|]
operator|==
literal|','
condition|)
block|{
name|c
operator|+=
literal|4
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
index|[
literal|3
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad arg-list\n"
argument_list|,
name|ffeintrin_imps_
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Determine whether intrinsic is okay as an actual argument.  */
end_comment

begin_function
name|bool
name|ffeintrin_is_actualarg
parameter_list|(
name|ffeintrinSpec
name|spec
parameter_list|)
block|{
name|ffeIntrinsicState
name|state
decl_stmt|;
if|if
condition|(
name|spec
operator|>=
name|FFEINTRIN_spec
condition|)
return|return
name|FALSE
return|;
name|state
operator|=
name|ffeintrin_state_family
argument_list|(
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|family
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|ffe_is_pedantic
argument_list|()
operator|||
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|is_actualarg
operator|)
operator|&&
operator|(
name|ffe_is_f2c
argument_list|()
condition|?
operator|(
name|ffeintrin_imps_
index|[
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|implementation
index|]
operator|.
name|gfrt_f2c
operator|!=
name|FFECOM_gfrt
operator|)
else|:
operator|(
name|ffeintrin_imps_
index|[
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|implementation
index|]
operator|.
name|gfrt_gnu
operator|!=
name|FFECOM_gfrt
operator|)
operator|)
operator|&&
operator|(
operator|(
name|state
operator|==
name|FFE_intrinsicstateENABLED
operator|)
operator|||
operator|(
name|state
operator|==
name|FFE_intrinsicstateHIDDEN
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if name is intrinsic, return info.     const char *name;		// C-string name of possible intrinsic.    ffelexToken t;		// NULL if no diagnostic to be given.    bool explicit;		// TRUE if INTRINSIC name.    ffeintrinGen gen;		// (TRUE only) Generic id of intrinsic.    ffeintrinSpec spec;		// (TRUE only) Specific id of intrinsic.    ffeintrinImp imp;		// (TRUE only) Implementation id of intrinsic.    if (ffeintrin_is_intrinsic (name, t, explicit,&gen,&spec,&imp)) 				// is an intrinsic, use gen, spec, imp, and 				// kind accordingly.  */
end_comment

begin_function
name|bool
name|ffeintrin_is_intrinsic
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ffelexToken
name|t
parameter_list|,
name|bool
name|explicit
parameter_list|,
name|ffeintrinGen
modifier|*
name|xgen
parameter_list|,
name|ffeintrinSpec
modifier|*
name|xspec
parameter_list|,
name|ffeintrinImp
modifier|*
name|ximp
parameter_list|)
block|{
name|struct
name|_ffeintrin_name_
modifier|*
name|intrinsic
decl_stmt|;
name|ffeintrinGen
name|gen
decl_stmt|;
name|ffeintrinSpec
name|spec
decl_stmt|;
name|ffeintrinImp
name|imp
decl_stmt|;
name|ffeIntrinsicState
name|state
decl_stmt|;
name|bool
name|disabled
init|=
name|FALSE
decl_stmt|;
name|bool
name|unimpl
init|=
name|FALSE
decl_stmt|;
name|intrinsic
operator|=
name|bsearch
argument_list|(
name|name
argument_list|,
operator|&
name|ffeintrin_names_
index|[
literal|0
index|]
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|ffeintrin_names_
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_ffeintrin_name_
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ffeintrin_cmp_name_
argument_list|)
expr_stmt|;
if|if
condition|(
name|intrinsic
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|gen
operator|=
name|intrinsic
operator|->
name|generic
expr_stmt|;
name|spec
operator|=
name|intrinsic
operator|->
name|specific
expr_stmt|;
name|imp
operator|=
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|implementation
expr_stmt|;
comment|/* Generic is okay only if at least one of its specifics is okay.  */
if|if
condition|(
name|gen
operator|!=
name|FFEINTRIN_genNONE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ffeintrinSpec
name|tspec
decl_stmt|;
name|bool
name|ok
init|=
name|FALSE
decl_stmt|;
name|name
operator|=
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|specs
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|tspec
operator|=
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|specs
index|[
name|i
index|]
operator|)
operator|!=
name|FFEINTRIN_specNONE
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|state
operator|=
name|ffeintrin_state_family
argument_list|(
name|ffeintrin_specs_
index|[
name|tspec
index|]
operator|.
name|family
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|FFE_intrinsicstateDELETED
condition|)
continue|continue;
if|if
condition|(
name|state
operator|==
name|FFE_intrinsicstateDISABLED
condition|)
block|{
name|disabled
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ffeintrin_specs_
index|[
name|tspec
index|]
operator|.
name|implementation
operator|==
name|FFEINTRIN_impNONE
condition|)
block|{
name|unimpl
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|state
operator|==
name|FFE_intrinsicstateENABLED
operator|)
operator|||
operator|(
name|explicit
operator|&&
operator|(
name|state
operator|==
name|FFE_intrinsicstateHIDDEN
operator|)
operator|)
condition|)
block|{
name|ok
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
name|gen
operator|=
name|FFEINTRIN_genNONE
expr_stmt|;
block|}
comment|/* Specific is okay only if not: unimplemented, disabled, deleted, or      hidden and not explicit.  */
if|if
condition|(
name|spec
operator|!=
name|FFEINTRIN_specNONE
condition|)
block|{
if|if
condition|(
name|gen
operator|!=
name|FFEINTRIN_genNONE
condition|)
name|name
operator|=
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|name
expr_stmt|;
else|else
name|name
operator|=
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|name
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|state
operator|=
name|ffeintrin_state_family
argument_list|(
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|family
argument_list|)
operator|)
operator|==
name|FFE_intrinsicstateDELETED
operator|)
operator|||
operator|(
operator|!
name|explicit
operator|&&
operator|(
name|state
operator|==
name|FFE_intrinsicstateHIDDEN
operator|)
operator|)
condition|)
name|spec
operator|=
name|FFEINTRIN_specNONE
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|FFE_intrinsicstateDISABLED
condition|)
block|{
name|disabled
operator|=
name|TRUE
expr_stmt|;
name|spec
operator|=
name|FFEINTRIN_specNONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|imp
operator|==
name|FFEINTRIN_impNONE
condition|)
block|{
name|unimpl
operator|=
name|TRUE
expr_stmt|;
name|spec
operator|=
name|FFEINTRIN_specNONE
expr_stmt|;
block|}
block|}
comment|/* If neither is okay, not an intrinsic.  */
if|if
condition|(
operator|(
name|gen
operator|==
name|FFEINTRIN_genNONE
operator|)
operator|&&
operator|(
name|spec
operator|==
name|FFEINTRIN_specNONE
operator|)
condition|)
block|{
comment|/* Here is where we produce a diagnostic about a reference to a 	 disabled or unimplemented intrinsic, if the diagnostic is desired.  */
if|if
condition|(
operator|(
name|disabled
operator|||
name|unimpl
operator|)
operator|&&
operator|(
name|t
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|disabled
condition|?
name|FFEBAD_INTRINSIC_DISABLED
else|:
name|FFEBAD_INTRINSIC_UNIMPLW
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
comment|/* Determine whether intrinsic is function or subroutine.  If no specific      id, scan list of possible specifics for generic to get consensus.  If      not unanimous, or clear from the context, return NONE.  */
if|if
condition|(
name|spec
operator|==
name|FFEINTRIN_specNONE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ffeintrinSpec
name|tspec
decl_stmt|;
name|ffeintrinImp
name|timp
decl_stmt|;
name|bool
name|at_least_one_ok
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|specs
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|tspec
operator|=
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|specs
index|[
name|i
index|]
operator|)
operator|!=
name|FFEINTRIN_specNONE
operator|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|state
operator|=
name|ffeintrin_state_family
argument_list|(
name|ffeintrin_specs_
index|[
name|tspec
index|]
operator|.
name|family
argument_list|)
operator|)
operator|==
name|FFE_intrinsicstateDELETED
operator|)
operator|||
operator|(
name|state
operator|==
name|FFE_intrinsicstateDISABLED
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|timp
operator|=
name|ffeintrin_specs_
index|[
name|tspec
index|]
operator|.
name|implementation
operator|)
operator|==
name|FFEINTRIN_impNONE
condition|)
continue|continue;
name|at_least_one_ok
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|at_least_one_ok
condition|)
block|{
operator|*
name|xgen
operator|=
name|FFEINTRIN_genNONE
expr_stmt|;
operator|*
name|xspec
operator|=
name|FFEINTRIN_specNONE
expr_stmt|;
operator|*
name|ximp
operator|=
name|FFEINTRIN_impNONE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
operator|*
name|xgen
operator|=
name|gen
expr_stmt|;
operator|*
name|xspec
operator|=
name|spec
expr_stmt|;
operator|*
name|ximp
operator|=
name|imp
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if intrinsic is standard F77 (or, if -ff90, F90).  */
end_comment

begin_function
name|bool
name|ffeintrin_is_standard
parameter_list|(
name|ffeintrinGen
name|gen
parameter_list|,
name|ffeintrinSpec
name|spec
parameter_list|)
block|{
if|if
condition|(
name|spec
operator|==
name|FFEINTRIN_specNONE
condition|)
block|{
if|if
condition|(
name|gen
operator|==
name|FFEINTRIN_genNONE
condition|)
return|return
name|FALSE
return|;
name|spec
operator|=
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|specs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|FFEINTRIN_specNONE
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|family
operator|==
name|FFEINTRIN_familyF77
operator|)
operator|||
operator|(
name|ffe_is_90
argument_list|()
operator|&&
operator|(
operator|(
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|family
operator|==
name|FFEINTRIN_familyF90
operator|)
operator|||
operator|(
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|family
operator|==
name|FFEINTRIN_familyMIL
operator|)
operator|||
operator|(
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|family
operator|==
name|FFEINTRIN_familyASC
operator|)
operator|)
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return kind type of intrinsic implementation.  See ffeintrin_basictype,    its sibling.  */
end_comment

begin_function
name|ffeinfoKindtype
name|ffeintrin_kindtype
parameter_list|(
name|ffeintrinSpec
name|spec
parameter_list|)
block|{
name|ffeintrinImp
name|imp
decl_stmt|;
name|ffecomGfrt
name|gfrt
decl_stmt|;
name|assert
argument_list|(
name|spec
operator|<
name|FFEINTRIN_spec
argument_list|)
expr_stmt|;
name|imp
operator|=
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|implementation
expr_stmt|;
name|assert
argument_list|(
name|imp
operator|<
name|FFEINTRIN_imp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_f2c
argument_list|()
condition|)
name|gfrt
operator|=
name|ffeintrin_imps_
index|[
name|imp
index|]
operator|.
name|gfrt_f2c
expr_stmt|;
else|else
name|gfrt
operator|=
name|ffeintrin_imps_
index|[
name|imp
index|]
operator|.
name|gfrt_gnu
expr_stmt|;
name|assert
argument_list|(
name|gfrt
operator|!=
name|FFECOM_gfrt
argument_list|)
expr_stmt|;
return|return
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return name of generic intrinsic.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ffeintrin_name_generic
parameter_list|(
name|ffeintrinGen
name|gen
parameter_list|)
block|{
name|assert
argument_list|(
name|gen
operator|<
name|FFEINTRIN_gen
argument_list|)
expr_stmt|;
return|return
name|ffeintrin_gens_
index|[
name|gen
index|]
operator|.
name|name
return|;
block|}
end_function

begin_comment
comment|/* Return name of intrinsic implementation.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ffeintrin_name_implementation
parameter_list|(
name|ffeintrinImp
name|imp
parameter_list|)
block|{
name|assert
argument_list|(
name|imp
operator|<
name|FFEINTRIN_imp
argument_list|)
expr_stmt|;
return|return
name|ffeintrin_imps_
index|[
name|imp
index|]
operator|.
name|name
return|;
block|}
end_function

begin_comment
comment|/* Return external/internal name of specific intrinsic.	 */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ffeintrin_name_specific
parameter_list|(
name|ffeintrinSpec
name|spec
parameter_list|)
block|{
name|assert
argument_list|(
name|spec
operator|<
name|FFEINTRIN_spec
argument_list|)
expr_stmt|;
return|return
name|ffeintrin_specs_
index|[
name|spec
index|]
operator|.
name|name
return|;
block|}
end_function

begin_comment
comment|/* Return state of family.  */
end_comment

begin_function
name|ffeIntrinsicState
name|ffeintrin_state_family
parameter_list|(
name|ffeintrinFamily
name|family
parameter_list|)
block|{
name|ffeIntrinsicState
name|state
decl_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|FFEINTRIN_familyNONE
case|:
return|return
name|FFE_intrinsicstateDELETED
return|;
case|case
name|FFEINTRIN_familyF77
case|:
return|return
name|FFE_intrinsicstateENABLED
return|;
case|case
name|FFEINTRIN_familyASC
case|:
name|state
operator|=
name|ffe_intrinsic_state_f2c
argument_list|()
expr_stmt|;
name|state
operator|=
name|ffe_state_max
argument_list|(
name|state
argument_list|,
name|ffe_intrinsic_state_f90
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|state
return|;
case|case
name|FFEINTRIN_familyMIL
case|:
name|state
operator|=
name|ffe_intrinsic_state_vxt
argument_list|()
expr_stmt|;
name|state
operator|=
name|ffe_state_max
argument_list|(
name|state
argument_list|,
name|ffe_intrinsic_state_f90
argument_list|()
argument_list|)
expr_stmt|;
name|state
operator|=
name|ffe_state_max
argument_list|(
name|state
argument_list|,
name|ffe_intrinsic_state_mil
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|state
return|;
case|case
name|FFEINTRIN_familyGNU
case|:
name|state
operator|=
name|ffe_intrinsic_state_gnu
argument_list|()
expr_stmt|;
return|return
name|state
return|;
case|case
name|FFEINTRIN_familyF90
case|:
name|state
operator|=
name|ffe_intrinsic_state_f90
argument_list|()
expr_stmt|;
return|return
name|state
return|;
case|case
name|FFEINTRIN_familyVXT
case|:
name|state
operator|=
name|ffe_intrinsic_state_vxt
argument_list|()
expr_stmt|;
return|return
name|state
return|;
case|case
name|FFEINTRIN_familyFVZ
case|:
name|state
operator|=
name|ffe_intrinsic_state_f2c
argument_list|()
expr_stmt|;
name|state
operator|=
name|ffe_state_max
argument_list|(
name|state
argument_list|,
name|ffe_intrinsic_state_vxt
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|state
return|;
case|case
name|FFEINTRIN_familyF2C
case|:
name|state
operator|=
name|ffe_intrinsic_state_f2c
argument_list|()
expr_stmt|;
return|return
name|state
return|;
case|case
name|FFEINTRIN_familyF2U
case|:
name|state
operator|=
name|ffe_intrinsic_state_unix
argument_list|()
expr_stmt|;
return|return
name|state
return|;
case|case
name|FFEINTRIN_familyBADU77
case|:
name|state
operator|=
name|ffe_intrinsic_state_badu77
argument_list|()
expr_stmt|;
return|return
name|state
return|;
default|default:
name|assert
argument_list|(
literal|"bad family"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FFE_intrinsicstateDELETED
return|;
block|}
block|}
end_function

end_unit

