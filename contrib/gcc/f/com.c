begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* com.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       None     Description:       Contains compiler-specific functions.     Modifications: */
end_comment

begin_comment
comment|/* Understanding this module means understanding the interface between    the g77 front end and the gcc back end (or, perhaps, some other    back end).  In here are the functions called by the front end proper    to notify whatever back end is in place about certain things, and    also the back-end-specific functions.  It's a bear to deal with, so    lately I've been trying to simplify things, especially with regard    to the gcc-back-end-specific stuff.     Building expressions generally seems quite easy, but building decls    has been challenging and is undergoing revision.  gcc has several    kinds of decls:     TYPE_DECL -- a type (int, float, struct, function, etc.)    CONST_DECL -- a constant of some type other than function    LABEL_DECL -- a variable or a constant?    PARM_DECL -- an argument to a function (a variable that is a dummy)    RESULT_DECL -- the return value of a function (a variable)    VAR_DECL -- other variable (can hold a ptr-to-function, struct, int, etc.)    FUNCTION_DECL -- a function (either the actual function or an extern ref)    FIELD_DECL -- a field in a struct or union (goes into types)     g77 has a set of functions that somewhat parallels the gcc front end    when it comes to building decls:     Internal Function (one we define, not just declare as extern):    if (is_nested) push_f_function_context ();    start_function (get_identifier ("function_name"), function_type, 		   is_nested, is_public);    // for each arg, build PARM_DECL and call push_parm_decl (decl) with it;    store_parm_decls (is_main_program);    ffecom_start_compstmt ();    // for stmts and decls inside function, do appropriate things;    ffecom_end_compstmt ();    finish_function (is_nested);    if (is_nested) pop_f_function_context ();     Everything Else:    tree d;    tree init;    // fill in external, public, static,&c for decl, and    // set DECL_INITIAL to error_mark_node if going to initialize    // set is_top_level TRUE only if not at top level and decl    // must go in top level (i.e. not within current function decl context)    d = start_decl (decl, is_top_level);    init = ...;	// if have initializer    finish_decl (d, init, is_top_level);  */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_comment
comment|/* Must follow tree.h so TREE_CODE is defined! */
end_comment

begin_include
include|#
directive|include
file|"convert.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"langhooks-def.h"
end_include

begin_comment
comment|/* VMS-specific definitions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<descrip.h>
end_include

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_comment
comment|/* Open arg for Read/Only  */
end_comment

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_comment
comment|/* Open arg for Write/Only */
end_comment

begin_define
define|#
directive|define
name|read
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
value|VMS_read (fd,buf,size)
end_define

begin_define
define|#
directive|define
name|write
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
value|VMS_write (fd,buf,size)
end_define

begin_define
define|#
directive|define
name|open
parameter_list|(
name|fname
parameter_list|,
name|mode
parameter_list|,
name|prot
parameter_list|)
value|VMS_open (fname,mode,prot)
end_define

begin_define
define|#
directive|define
name|fopen
parameter_list|(
name|fname
parameter_list|,
name|mode
parameter_list|)
value|VMS_fopen (fname,mode)
end_define

begin_define
define|#
directive|define
name|freopen
parameter_list|(
name|fname
parameter_list|,
name|mode
parameter_list|,
name|ofile
parameter_list|)
value|VMS_freopen (fname,mode,ofile)
end_define

begin_define
define|#
directive|define
name|strncat
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|cnt
parameter_list|)
value|VMS_strncat (dst,src,cnt)
end_define

begin_define
define|#
directive|define
name|fstat
parameter_list|(
name|fd
parameter_list|,
name|stbuf
parameter_list|)
value|VMS_fstat (fd,stbuf)
end_define

begin_decl_stmt
specifier|static
name|int
name|VMS_fstat
argument_list|()
decl_stmt|,
name|VMS_stat
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|VMS_strncat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|VMS_read
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|VMS_write
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|VMS_open
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|VMS_fopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|VMS_freopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hack_vms_include_specification
parameter_list|()
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
label|:
literal|16
operator|,
operator|:
literal|16
operator|,
operator|:
literal|16
expr_stmt|;
block|}
name|vms_ino_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ino_t
value|vms_ino_t
end_define

begin_define
define|#
directive|define
name|INCLUDE_LEN_FUDGE
value|10
end_define

begin_comment
comment|/* leave room for VMS syntax conversion */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_define
define|#
directive|define
name|FFECOM_DETERMINE_TYPES
value|1
end_define

begin_comment
comment|/* for com.h */
end_comment

begin_include
include|#
directive|include
file|"com.h"
end_include

begin_include
include|#
directive|include
file|"bad.h"
end_include

begin_include
include|#
directive|include
file|"bld.h"
end_include

begin_include
include|#
directive|include
file|"equiv.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"implic.h"
end_include

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"src.h"
end_include

begin_include
include|#
directive|include
file|"st.h"
end_include

begin_include
include|#
directive|include
file|"storag.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"type.h"
end_include

begin_comment
comment|/* Externals defined here.  */
end_comment

begin_comment
comment|/* Stream for reading from the input file.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|finput
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These definitions parallel those in c-decl.c so that code from that    module can be used pretty much as is.  Much of these defs aren't    otherwise used, i.e. by g77 code per se, except some of them are used    to build some of them that are.  The ones that are global (i.e. not    "static") are those that ste.c and such might use (directly    or by using com macros that reference them in their definitions).  */
end_comment

begin_decl_stmt
name|tree
name|string_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The rest of these are inventions for g77, though there might be    similar things in the C front end.  As they are found, these    inventions should be renamed to be canonical.  Note that only    the ones currently required to be global are so.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|ffecom_tree_fun_type_void
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_integer_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Abbrev for _tree_type[blah][blah]. */
end_comment

begin_decl_stmt
name|tree
name|ffecom_integer_zero_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Like *_*_* with g77's integer type. */
end_comment

begin_decl_stmt
name|tree
name|ffecom_integer_one_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* " */
end_comment

begin_decl_stmt
name|tree
name|ffecom_tree_type
index|[
name|FFEINFO_basictype
index|]
index|[
name|FFEINFO_kindtype
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _fun_type things are the f2c-specific versions.  For -fno-f2c,    just use build_function_type and build_pointer_type on the    appropriate _tree_type array element.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|ffecom_tree_fun_type
index|[
name|FFEINFO_basictype
index|]
index|[
name|FFEINFO_kindtype
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_tree_ptr_to_fun_type
index|[
name|FFEINFO_basictype
index|]
index|[
name|FFEINFO_kindtype
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_tree_subr_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_tree_ptr_to_subr_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_tree_blockdata_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_tree_xargc_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ffecomSymbol
name|ffecom_symbol_null_
init|=
block|{
name|NULL_TREE
block|,
name|NULL_TREE
block|,
name|NULL_TREE
block|,
name|NULL_TREE
block|,
name|false
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ffeinfoKindtype
name|ffecom_pointer_kind_
init|=
name|FFEINFO_basictypeNONE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ffeinfoKindtype
name|ffecom_label_kind_
init|=
name|FFEINFO_basictypeNONE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ffecom_f2c_typecode_
index|[
name|FFEINFO_basictype
index|]
index|[
name|FFEINFO_kindtype
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_ptr_to_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_address_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_real_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_ptr_to_real_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_doublereal_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_complex_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_doublecomplex_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_longint_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_logical_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_flag_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_ftnlen_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_ftnlen_zero_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_ftnlen_one_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_ftnlen_two_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_ptr_to_ftnlen_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_ftnint_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ffecom_f2c_ptr_to_ftnint_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FFECOM_sizeMAXSTACKITEM
end_ifndef

begin_define
define|#
directive|define
name|FFECOM_sizeMAXSTACKITEM
value|32*1024
end_define

begin_comment
comment|/* Keep user-declared things 					   larger than this # bytes 					   off stack if possible. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For systems that have large enough stacks, they should define    this to 0, and here, for ease of use later on, we just undefine    it if it is 0.  */
end_comment

begin_if
if|#
directive|if
name|FFECOM_sizeMAXSTACKITEM
operator|==
literal|0
end_if

begin_undef
undef|#
directive|undef
name|FFECOM_sizeMAXSTACKITEM
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
enum|enum
block|{
name|FFECOM_rttypeVOID_
block|,
name|FFECOM_rttypeVOIDSTAR_
block|,
comment|/* C's `void *' type. */
name|FFECOM_rttypeFTNINT_
block|,
comment|/* f2c's `ftnint' type. */
name|FFECOM_rttypeINTEGER_
block|,
comment|/* f2c's `integer' type. */
name|FFECOM_rttypeLONGINT_
block|,
comment|/* f2c's `longint' type. */
name|FFECOM_rttypeLOGICAL_
block|,
comment|/* f2c's `logical' type. */
name|FFECOM_rttypeREAL_F2C_
block|,
comment|/* f2c's `real' returned as `double'. */
name|FFECOM_rttypeREAL_GNU_
block|,
comment|/* `real' returned as such. */
name|FFECOM_rttypeCOMPLEX_F2C_
block|,
comment|/* f2c's `complex' returned via 1st arg. */
name|FFECOM_rttypeCOMPLEX_GNU_
block|,
comment|/* f2c's `complex' returned directly. */
name|FFECOM_rttypeDOUBLE_
block|,
comment|/* C's `double' type. */
name|FFECOM_rttypeDOUBLEREAL_
block|,
comment|/* f2c's `doublereal' type. */
name|FFECOM_rttypeDBLCMPLX_F2C_
block|,
comment|/* f2c's `doublecomplex' returned via 1st arg. */
name|FFECOM_rttypeDBLCMPLX_GNU_
block|,
comment|/* f2c's `doublecomplex' returned directly. */
name|FFECOM_rttypeCHARACTER_
block|,
comment|/* f2c `char *'/`ftnlen' pair. */
name|FFECOM_rttype_
block|}
name|ffecomRttype_
typedef|;
end_typedef

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|_ffecom_concat_list_
name|ffecomConcatList_
typedef|;
end_typedef

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_struct
struct|struct
name|_ffecom_concat_list_
block|{
name|ffebld
modifier|*
name|exprs
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|max
decl_stmt|;
name|ffetargetCharacterSize
name|minlen
decl_stmt|;
name|ffetargetCharacterSize
name|maxlen
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ffecom_init_decl_processing
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|tree
name|ffecom_arglist_expr_
parameter_list|(
specifier|const
name|char
modifier|*
name|argstring
parameter_list|,
name|ffebld
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_widest_expr_type_
parameter_list|(
name|ffebld
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffecom_overlap_
parameter_list|(
name|tree
name|dest_decl
parameter_list|,
name|tree
name|dest_offset
parameter_list|,
name|tree
name|dest_size
parameter_list|,
name|tree
name|source_tree
parameter_list|,
name|ffebld
name|source
parameter_list|,
name|bool
name|scalar_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffecom_args_overlapping_
parameter_list|(
name|tree
name|dest_tree
parameter_list|,
name|ffebld
name|dest
parameter_list|,
name|tree
name|args
parameter_list|,
name|tree
name|callee_commons
parameter_list|,
name|bool
name|scalar_args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_build_f2c_string_
parameter_list|(
name|int
name|i
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_call_
parameter_list|(
name|tree
name|fn
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|,
name|bool
name|is_f2c_complex
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|args
parameter_list|,
name|tree
name|dest_tree
parameter_list|,
name|ffebld
name|dest
parameter_list|,
name|bool
modifier|*
name|dest_used
parameter_list|,
name|tree
name|callee_commons
parameter_list|,
name|bool
name|scalar_args
parameter_list|,
name|tree
name|hook
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_call_binop_
parameter_list|(
name|tree
name|fn
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|,
name|bool
name|is_f2c_complex
parameter_list|,
name|tree
name|type
parameter_list|,
name|ffebld
name|left
parameter_list|,
name|ffebld
name|right
parameter_list|,
name|tree
name|dest_tree
parameter_list|,
name|ffebld
name|dest
parameter_list|,
name|bool
modifier|*
name|dest_used
parameter_list|,
name|tree
name|callee_commons
parameter_list|,
name|bool
name|scalar_args
parameter_list|,
name|bool
name|ref
parameter_list|,
name|tree
name|hook
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_char_args_x_
parameter_list|(
name|tree
modifier|*
name|xitem
parameter_list|,
name|tree
modifier|*
name|length
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|bool
name|with_null
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_check_size_overflow_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_char_enhance_arg_
parameter_list|(
name|tree
modifier|*
name|xtype
parameter_list|,
name|ffesymbol
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffecomConcatList_
name|ffecom_concat_list_gather_
parameter_list|(
name|ffecomConcatList_
name|catlist
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffetargetCharacterSize
name|max
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_concat_list_kill_
parameter_list|(
name|ffecomConcatList_
name|catlist
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffecomConcatList_
name|ffecom_concat_list_new_
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffetargetCharacterSize
name|max
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_debug_kludge_
parameter_list|(
name|tree
name|aggr
parameter_list|,
specifier|const
name|char
modifier|*
name|aggr_type
parameter_list|,
name|ffesymbol
name|member
parameter_list|,
name|tree
name|member_type
parameter_list|,
name|ffetargetOffset
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_do_entry_
parameter_list|(
name|ffesymbol
name|fn
parameter_list|,
name|int
name|entrynum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_expr_
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|tree
name|dest_tree
parameter_list|,
name|ffebld
name|dest
parameter_list|,
name|bool
modifier|*
name|dest_used
parameter_list|,
name|bool
name|assignp
parameter_list|,
name|bool
name|widenp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_expr_intrinsic_
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|tree
name|dest_tree
parameter_list|,
name|ffebld
name|dest
parameter_list|,
name|bool
modifier|*
name|dest_used
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_expr_power_integer_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_expr_transform_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_f2c_make_type_
parameter_list|(
name|tree
modifier|*
name|type
parameter_list|,
name|int
name|tcode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_f2c_set_lio_code_
parameter_list|(
name|ffeinfoBasictype
name|bt
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffeglobal
name|ffecom_finish_global_
parameter_list|(
name|ffeglobal
name|global
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffecom_finish_symbol_transform_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_get_appended_identifier_
parameter_list|(
name|char
name|us
parameter_list|,
specifier|const
name|char
modifier|*
name|text
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_get_external_identifier_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_get_identifier_
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_gen_sfuncdef_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ffecom_gfrt_args_
parameter_list|(
name|ffecomGfrt
name|ix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_gfrt_tree_
parameter_list|(
name|ffecomGfrt
name|ix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_init_zero_
parameter_list|(
name|tree
name|decl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_intrinsic_ichar_
parameter_list|(
name|tree
name|tree_type
parameter_list|,
name|ffebld
name|arg
parameter_list|,
name|tree
modifier|*
name|maybe_tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_intrinsic_len_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_let_char_
parameter_list|(
name|tree
name|dest_tree
parameter_list|,
name|tree
name|dest_length
parameter_list|,
name|ffetargetCharacterSize
name|dest_size
parameter_list|,
name|ffebld
name|source
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_make_gfrt_
parameter_list|(
name|ffecomGfrt
name|ix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_member_phase1_
parameter_list|(
name|ffestorag
name|mst
parameter_list|,
name|ffestorag
name|st
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_member_phase2_
parameter_list|(
name|ffestorag
name|mst
parameter_list|,
name|ffestorag
name|st
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_prepare_let_char_
parameter_list|(
name|ffetargetCharacterSize
name|dest_size
parameter_list|,
name|ffebld
name|source
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_push_dummy_decls_
parameter_list|(
name|ffebld
name|dumlist
parameter_list|,
name|bool
name|stmtfunc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_start_progunit_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffecom_sym_transform_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffecom_sym_transform_assign_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_transform_common_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_transform_equiv_
parameter_list|(
name|ffestorag
name|st
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_transform_namelist_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_tree_canonize_ptr_
parameter_list|(
name|tree
modifier|*
name|decl
parameter_list|,
name|tree
modifier|*
name|offset
parameter_list|,
name|tree
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_tree_canonize_ref_
parameter_list|(
name|tree
modifier|*
name|decl
parameter_list|,
name|tree
modifier|*
name|offset
parameter_list|,
name|tree
modifier|*
name|size
parameter_list|,
name|tree
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_tree_divide_
parameter_list|(
name|tree
name|tree_type
parameter_list|,
name|tree
name|left
parameter_list|,
name|tree
name|right
parameter_list|,
name|tree
name|dest_tree
parameter_list|,
name|ffebld
name|dest
parameter_list|,
name|bool
modifier|*
name|dest_used
parameter_list|,
name|tree
name|hook
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_type_localvar_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_type_namelist_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_type_vardesc_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_vardesc_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_vardesc_array_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_vardesc_dims_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_convert_narrow_
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ffecom_convert_widen_
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* These are static functions that parallel those found in the C front    end and thus have the same names.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|bison_rule_compstmt_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bison_rule_pushlevel_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_block
parameter_list|(
name|tree
name|block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|duplicate_decls
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|,
name|bool
name|is_top_level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_function
parameter_list|(
name|int
name|nested
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|lang_printable_name
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_name_current_level
parameter_list|(
name|tree
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|binding_level
modifier|*
name|make_binding_level
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pop_f_function_context
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_f_function_context
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_parm_decl
parameter_list|(
name|tree
name|parm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|pushdecl_top_level
parameter_list|(
name|tree
name|decl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kept_level_p
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|storedecls
parameter_list|(
name|tree
name|decls
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_parm_decls
parameter_list|(
name|int
name|is_main_program
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|start_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
name|is_top_level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_function
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|nested
parameter_list|,
name|int
name|public
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_file_
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffecom_close_include_
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ffecom_decode_include_option_
parameter_list|(
name|char
modifier|*
name|spec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|ffecom_open_include_
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|ffewhereLine
name|l
parameter_list|,
name|ffewhereColumn
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_decl_stmt
specifier|static
name|ffesymbol
name|ffecom_primary_entry_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffesymbol
name|ffecom_nested_entry_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffeinfoKind
name|ffecom_primary_entry_kind_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ffecom_primary_entry_is_proc_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_outer_function_decl_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_previous_function_decl_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_which_entrypoint_decl_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_float_zero_
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_float_half_
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_double_zero_
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_double_half_
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_func_result_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For functions. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|ffecom_func_length_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For CHARACTER fns. */
end_comment

begin_decl_stmt
specifier|static
name|ffebld
name|ffecom_list_blockdata_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffebld
name|ffecom_list_common_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffebld
name|ffecom_master_arglist_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffeinfoBasictype
name|ffecom_master_bt_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffeinfoKindtype
name|ffecom_master_kt_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffetargetCharacterSize
name|ffecom_master_size_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ffecom_num_fns_
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ffecom_num_entrypoints_
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ffecom_is_altreturning_
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_multi_type_node_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_multi_retval_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ffecom_multi_fields_
index|[
name|FFEINFO_basictype
index|]
index|[
name|FFEINFO_kindtype
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ffecom_member_namelisted_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _member_phase1_ namelisted? */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffecom_doing_entry_
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ffecom_transform_only_dummies_
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ffecom_typesize_pointer_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ffecom_typesize_integer1_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds pointer-to-function expressions.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|ffecom_gfrt_
index|[
name|FFECOM_gfrt
index|]
init|=
block|{
define|#
directive|define
name|DEFGFRT
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|ARGS
parameter_list|,
name|VOLATILE
parameter_list|,
name|COMPLEX
parameter_list|,
name|CONST
parameter_list|)
value|NULL_TREE,
include|#
directive|include
file|"com-rt.def"
undef|#
directive|undef
name|DEFGFRT
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the external names of the functions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ffecom_gfrt_name_
index|[
name|FFECOM_gfrt
index|]
init|=
block|{
define|#
directive|define
name|DEFGFRT
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|ARGS
parameter_list|,
name|VOLATILE
parameter_list|,
name|COMPLEX
parameter_list|,
name|CONST
parameter_list|)
value|NAME,
include|#
directive|include
file|"com-rt.def"
undef|#
directive|undef
name|DEFGFRT
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether the function returns.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bool
name|ffecom_gfrt_volatile_
index|[
name|FFECOM_gfrt
index|]
init|=
block|{
define|#
directive|define
name|DEFGFRT
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|ARGS
parameter_list|,
name|VOLATILE
parameter_list|,
name|COMPLEX
parameter_list|,
name|CONST
parameter_list|)
value|VOLATILE,
include|#
directive|include
file|"com-rt.def"
undef|#
directive|undef
name|DEFGFRT
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether the function returns type complex.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bool
name|ffecom_gfrt_complex_
index|[
name|FFECOM_gfrt
index|]
init|=
block|{
define|#
directive|define
name|DEFGFRT
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|ARGS
parameter_list|,
name|VOLATILE
parameter_list|,
name|COMPLEX
parameter_list|,
name|CONST
parameter_list|)
value|COMPLEX,
include|#
directive|include
file|"com-rt.def"
undef|#
directive|undef
name|DEFGFRT
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether the function is const    (i.e., has no side effects and only depends on its arguments).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bool
name|ffecom_gfrt_const_
index|[
name|FFECOM_gfrt
index|]
init|=
block|{
define|#
directive|define
name|DEFGFRT
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|ARGS
parameter_list|,
name|VOLATILE
parameter_list|,
name|COMPLEX
parameter_list|,
name|CONST
parameter_list|)
value|CONST,
include|#
directive|include
file|"com-rt.def"
undef|#
directive|undef
name|DEFGFRT
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type code for the function return value.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|ffecomRttype_
name|ffecom_gfrt_type_
index|[
name|FFECOM_gfrt
index|]
init|=
block|{
define|#
directive|define
name|DEFGFRT
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|ARGS
parameter_list|,
name|VOLATILE
parameter_list|,
name|COMPLEX
parameter_list|,
name|CONST
parameter_list|)
value|TYPE,
include|#
directive|include
file|"com-rt.def"
undef|#
directive|undef
name|DEFGFRT
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String of codes for the function's arguments.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ffecom_gfrt_argstring_
index|[
name|FFECOM_gfrt
index|]
init|=
block|{
define|#
directive|define
name|DEFGFRT
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|ARGS
parameter_list|,
name|VOLATILE
parameter_list|,
name|COMPLEX
parameter_list|,
name|CONST
parameter_list|)
value|ARGS,
include|#
directive|include
file|"com-rt.def"
undef|#
directive|undef
name|DEFGFRT
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal macros. */
end_comment

begin_comment
comment|/* We let tm.h override the types used here, to handle trivial differences    such as the choice of unsigned int or long unsigned int for size_t.    When machines start needing nontrivial differences in the size type,    it would be best to do something here to figure out automatically    from other information what type to use.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_TYPE
end_ifndef

begin_define
define|#
directive|define
name|SIZE_TYPE
value|"long unsigned int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ffecom_concat_list_count_
parameter_list|(
name|catlist
parameter_list|)
value|((catlist).count)
end_define

begin_define
define|#
directive|define
name|ffecom_concat_list_expr_
parameter_list|(
name|catlist
parameter_list|,
name|i
parameter_list|)
value|((catlist).exprs[(i)])
end_define

begin_define
define|#
directive|define
name|ffecom_concat_list_maxlen_
parameter_list|(
name|catlist
parameter_list|)
value|((catlist).maxlen)
end_define

begin_define
define|#
directive|define
name|ffecom_concat_list_minlen_
parameter_list|(
name|catlist
parameter_list|)
value|((catlist).minlen)
end_define

begin_define
define|#
directive|define
name|ffecom_char_args_
parameter_list|(
name|i
parameter_list|,
name|l
parameter_list|,
name|e
parameter_list|)
value|ffecom_char_args_x_((i),(l),(e),FALSE)
end_define

begin_define
define|#
directive|define
name|ffecom_char_args_with_null_
parameter_list|(
name|i
parameter_list|,
name|l
parameter_list|,
name|e
parameter_list|)
value|ffecom_char_args_x_((i),(l),(e),TRUE)
end_define

begin_comment
comment|/* For each binding contour we allocate a binding_level structure  * which records the names defined in that contour.  * Contours include:  *  0) the global one  *  1) one for each function definition,  *     where internal declarations of the parameters appear.  *  * The current meaning of a name can be found by searching the levels from  * the current one out to the global one.  */
end_comment

begin_comment
comment|/* Note that the information in the `names' component of the global contour    is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */
end_comment

begin_struct
struct|struct
name|binding_level
block|{
comment|/* A chain of _DECL nodes for all variables, constants, functions,        and typedef types.  These are in the reverse of the order supplied.      */
name|tree
name|names
decl_stmt|;
comment|/* For each level (except not the global one),        a chain of BLOCK nodes for all the levels        that were entered and exited one level down.  */
name|tree
name|blocks
decl_stmt|;
comment|/* The BLOCK node for this level, if one has been preallocated.        If 0, the BLOCK is allocated (if needed) when the level is popped.  */
name|tree
name|this_block
decl_stmt|;
comment|/* The binding level which this one is contained in (inherits from).  */
name|struct
name|binding_level
modifier|*
name|level_chain
decl_stmt|;
comment|/* 0: no ffecom_prepare_* functions called at this level yet;        1: ffecom_prepare* functions called, except not ffecom_prepare_end;        2: ffecom_prepare_end called.  */
name|int
name|prep_state
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NULL_BINDING_LEVEL
value|(struct binding_level *) NULL
end_define

begin_comment
comment|/* The binding level currently in effect.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|current_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A chain of binding_level structures awaiting reuse.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|free_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The outermost binding level, for names of file scope.    This is created when the compiler is started and exists    through the entire run.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|global_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Binding level structures are initialized by copying this one.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|binding_level
name|clear_binding_level
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL_BINDING_LEVEL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Language-dependent contents of an identifier.  */
end_comment

begin_struct
struct|struct
name|lang_identifier
block|{
name|struct
name|tree_identifier
name|ignore
decl_stmt|;
name|tree
name|global_value
decl_stmt|,
name|local_value
decl_stmt|,
name|label_value
decl_stmt|;
name|bool
name|invented
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Macros for access to language-specific slots in an identifier.  */
end_comment

begin_comment
comment|/* Each of these slots contains a DECL node or null.  */
end_comment

begin_comment
comment|/* This represents the value which the identifier has in the    file-scope namespace.  */
end_comment

begin_define
define|#
directive|define
name|IDENTIFIER_GLOBAL_VALUE
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(((struct lang_identifier *)(NODE))->global_value)
end_define

begin_comment
comment|/* This represents the value which the identifier has in the current    scope.  */
end_comment

begin_define
define|#
directive|define
name|IDENTIFIER_LOCAL_VALUE
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(((struct lang_identifier *)(NODE))->local_value)
end_define

begin_comment
comment|/* This represents the value which the identifier has as a label in    the current label scope.  */
end_comment

begin_define
define|#
directive|define
name|IDENTIFIER_LABEL_VALUE
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(((struct lang_identifier *)(NODE))->label_value)
end_define

begin_comment
comment|/* This is nonzero if the identifier was "made up" by g77 code.  */
end_comment

begin_define
define|#
directive|define
name|IDENTIFIER_INVENTED
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(((struct lang_identifier *)(NODE))->invented)
end_define

begin_comment
comment|/* In identifiers, C uses the following fields in a special way:    TREE_PUBLIC	      to record that there was a previous local extern decl.    TREE_USED	      to record that such a decl was used.    TREE_ADDRESSABLE   to record that the address of such a decl was used.  */
end_comment

begin_comment
comment|/* A list (chain of TREE_LIST nodes) of all LABEL_DECLs in the function    that have names.  Here so we can clear out their names' definitions    at the end of the function.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|named_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of LABEL_DECLs from outer contexts that are currently shadowed.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|shadowed_labels
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return the subscript expression, modified to do range-checking.     `array' is the array to be checked against.    `element' is the subscript expression to check.    `dim' is the dimension number (starting at 0).    `total_dims' is the total number of dimensions (0 for CHARACTER substring). */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_subscript_check_
parameter_list|(
name|tree
name|array
parameter_list|,
name|tree
name|element
parameter_list|,
name|int
name|dim
parameter_list|,
name|int
name|total_dims
parameter_list|,
specifier|const
name|char
modifier|*
name|array_name
parameter_list|)
block|{
name|tree
name|low
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|array
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|high
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|array
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|cond
decl_stmt|;
name|tree
name|die
decl_stmt|;
name|tree
name|args
decl_stmt|;
if|if
condition|(
name|element
operator|==
name|error_mark_node
condition|)
return|return
name|element
return|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|low
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|low
argument_list|)
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
argument_list|)
condition|)
name|element
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|low
argument_list|)
argument_list|,
name|element
argument_list|)
expr_stmt|;
else|else
block|{
name|low
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
argument_list|,
name|low
argument_list|)
expr_stmt|;
if|if
condition|(
name|high
condition|)
name|high
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
argument_list|,
name|high
argument_list|)
expr_stmt|;
block|}
block|}
name|element
operator|=
name|ffecom_save_tree
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_dims
operator|==
literal|0
condition|)
block|{
comment|/* Special handling for substring range checks.  Fortran allows the          end subscript< begin subscript, which means that expressions like        string(1:0) are valid (and yield a null string).  In view of this,        enforce two simpler conditions:           1) element<=high for end-substring;           2) element>=low for start-substring.        Run-time character movement will enforce remaining conditions.         More complicated checks would be better, but present structure only        provides one index element at a time, so it is not possible to        enforce a check of both i and j in string(i:j).  If it were, the        complete set of rules would read,          if ( ((j<i)&& ((low<=i<=high) || (low<=j<=high))) ||               ((low<=i<=high)&& (low<=j<=high)) )            ok ;          else            range error ;       */
if|if
condition|(
name|dim
condition|)
name|cond
operator|=
name|ffecom_2
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|element
argument_list|,
name|high
argument_list|)
expr_stmt|;
else|else
name|cond
operator|=
name|ffecom_2
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|low
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Array reference substring range checking.  */
name|cond
operator|=
name|ffecom_2
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|low
argument_list|,
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|high
condition|)
block|{
name|cond
operator|=
name|ffecom_2
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|cond
argument_list|,
name|ffecom_2
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|element
argument_list|,
name|high
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|proc
decl_stmt|;
name|char
modifier|*
name|var
decl_stmt|;
name|tree
name|arg3
decl_stmt|;
name|tree
name|arg2
decl_stmt|;
name|tree
name|arg1
decl_stmt|;
name|tree
name|arg4
decl_stmt|;
switch|switch
condition|(
name|total_dims
condition|)
block|{
case|case
literal|0
case|:
name|var
operator|=
name|concat
argument_list|(
name|array_name
argument_list|,
literal|"["
argument_list|,
operator|(
name|dim
condition|?
literal|"end"
else|:
literal|"start"
operator|)
argument_list|,
literal|"-substring]"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|var
argument_list|)
operator|+
literal|1
expr_stmt|;
name|arg1
operator|=
name|build_string
argument_list|(
name|len
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|var
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|len
operator|=
name|strlen
argument_list|(
name|array_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|arg1
operator|=
name|build_string
argument_list|(
name|len
argument_list|,
name|array_name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|var
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|array_name
argument_list|)
operator|+
literal|40
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|var
argument_list|,
literal|"%s[subscript-%d-of-%d]"
argument_list|,
name|array_name
argument_list|,
name|dim
operator|+
literal|1
argument_list|,
name|total_dims
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|var
argument_list|)
operator|+
literal|1
expr_stmt|;
name|arg1
operator|=
name|build_string
argument_list|(
name|len
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|var
argument_list|)
expr_stmt|;
break|break;
block|}
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|=
name|build_type_variant
argument_list|(
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_range_type
argument_list|(
name|integer_type_node
argument_list|,
name|integer_one_node
argument_list|,
name|build_int_2
argument_list|(
name|len
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|arg1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|arg1
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
comment|/* s_rnge adds one to the element to print it, so bias against        that -- want to print a faithful *subscript* value.  */
name|arg2
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnint_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
argument_list|,
name|element
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|proc
operator|=
name|concat
argument_list|(
name|input_filename
argument_list|,
literal|"/"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|proc
argument_list|)
operator|+
literal|1
expr_stmt|;
name|arg3
operator|=
name|build_string
argument_list|(
name|len
argument_list|,
name|proc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
operator|=
name|build_type_variant
argument_list|(
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_range_type
argument_list|(
name|integer_type_node
argument_list|,
name|integer_one_node
argument_list|,
name|build_int_2
argument_list|(
name|len
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|arg3
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|arg3
argument_list|)
operator|=
literal|1
expr_stmt|;
name|arg3
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
argument_list|)
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|arg4
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnint_type_node
argument_list|,
name|build_int_2
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|arg4
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg4
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg3
argument_list|)
operator|=
name|arg4
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg2
argument_list|)
operator|=
name|arg3
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg1
argument_list|)
operator|=
name|arg2
expr_stmt|;
name|args
operator|=
name|arg1
expr_stmt|;
block|}
name|die
operator|=
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtRANGE
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|die
argument_list|)
operator|=
literal|1
expr_stmt|;
name|element
operator|=
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
argument_list|,
name|cond
argument_list|,
name|element
argument_list|,
name|die
argument_list|)
expr_stmt|;
return|return
name|element
return|;
block|}
end_function

begin_comment
comment|/* Return the computed element of an array reference.     `item' is NULL_TREE, or the transformed pointer to the array.    `expr' is the original opARRAYREF expression, which is transformed      if `item' is NULL_TREE.    `want_ptr' is non-zero if a pointer to the element, instead of      the element itself, is to be returned.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_arrayref_
parameter_list|(
name|tree
name|item
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|int
name|want_ptr
parameter_list|)
block|{
name|ffebld
name|dims
index|[
name|FFECOM_dimensionsMAX
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|total_dims
decl_stmt|;
name|int
name|flatten
init|=
name|ffe_is_flatten_arrays
argument_list|()
decl_stmt|;
name|int
name|need_ptr
decl_stmt|;
name|tree
name|array
decl_stmt|;
name|tree
name|element
decl_stmt|;
name|tree
name|tree_type
decl_stmt|;
name|tree
name|tree_type_x
decl_stmt|;
specifier|const
name|char
modifier|*
name|array_name
decl_stmt|;
name|ffetype
name|type
decl_stmt|;
name|ffebld
name|list
decl_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opSYMTER
condition|)
name|array_name
operator|=
name|ffesymbol_text
argument_list|(
name|ffebld_symter
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|array_name
operator|=
literal|"[expr?]"
expr_stmt|;
comment|/* Build up ARRAY_REFs in reverse order (since we're column major      here in Fortran land). */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|list
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
init|;
name|list
operator|!=
name|NULL
condition|;
operator|++
name|i
operator|,
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
name|dims
index|[
name|i
index|]
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffeinfo_type
argument_list|(
name|ffebld_basictype
argument_list|(
name|dims
index|[
name|i
index|]
argument_list|)
argument_list|,
name|ffebld_kindtype
argument_list|(
name|dims
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flatten
operator|&&
name|ffecom_typesize_pointer_
operator|>
name|ffecom_typesize_integer1_
operator|&&
name|ffetype_size
argument_list|(
name|type
argument_list|)
operator|>
name|ffecom_typesize_integer1_
condition|)
comment|/* E.g. ARRAY(INDEX), given INTEGER*8 INDEX, on a system with 64-bit 	   pointers and 32-bit integers.  Do the full 64-bit pointer 	   arithmetic, for codes using arrays for nonstandard heap-like 	   work.  */
name|flatten
operator|=
literal|1
expr_stmt|;
block|}
name|total_dims
operator|=
name|i
expr_stmt|;
name|need_ptr
operator|=
name|want_ptr
operator|||
name|flatten
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
block|{
if|if
condition|(
name|need_ptr
condition|)
name|item
operator|=
name|ffecom_ptr_to_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|item
operator|=
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|error_mark_node
condition|)
return|return
name|item
return|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_whereFLEETING
operator|&&
operator|!
name|mark_addressable
argument_list|(
name|item
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|item
operator|==
name|error_mark_node
condition|)
return|return
name|item
return|;
if|if
condition|(
name|need_ptr
condition|)
block|{
name|tree
name|min
decl_stmt|;
for|for
control|(
operator|--
name|i
operator|,
name|array
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
operator|,
name|array
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
control|)
block|{
name|min
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|array
argument_list|)
argument_list|)
expr_stmt|;
name|element
operator|=
name|ffecom_expr_
argument_list|(
name|dims
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_bounds_check
condition|)
name|element
operator|=
name|ffecom_subscript_check_
argument_list|(
name|array
argument_list|,
name|element
argument_list|,
name|i
argument_list|,
name|total_dims
argument_list|,
name|array_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
name|error_mark_node
condition|)
return|return
name|element
return|;
comment|/* Widen integral arithmetic as desired while preserving 	     signedness.  */
name|tree_type
operator|=
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|tree_type_x
operator|=
name|tree_type
expr_stmt|;
if|if
condition|(
name|tree_type
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|tree_type
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|TYPE_PRECISION
argument_list|(
name|tree_type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
condition|)
name|tree_type_x
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|tree_type
argument_list|)
condition|?
name|usizetype
else|:
name|ssizetype
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|min
argument_list|)
operator|!=
name|tree_type_x
condition|)
name|min
operator|=
name|convert
argument_list|(
name|tree_type_x
argument_list|,
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
operator|!=
name|tree_type_x
condition|)
name|element
operator|=
name|convert
argument_list|(
name|tree_type_x
argument_list|,
name|element
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|,
name|item
argument_list|,
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|tree_type_x
argument_list|,
name|element
argument_list|,
name|min
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|want_ptr
condition|)
block|{
name|item
operator|=
name|ffecom_1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
operator|--
name|i
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|array
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|element
operator|=
name|ffecom_expr_
argument_list|(
name|dims
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_bounds_check
condition|)
name|element
operator|=
name|ffecom_subscript_check_
argument_list|(
name|array
argument_list|,
name|element
argument_list|,
name|i
argument_list|,
name|total_dims
argument_list|,
name|array_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
name|error_mark_node
condition|)
return|return
name|element
return|;
comment|/* Widen integral arithmetic as desired while preserving 	     signedness.  */
name|tree_type
operator|=
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|tree_type_x
operator|=
name|tree_type
expr_stmt|;
if|if
condition|(
name|tree_type
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|tree_type
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|TYPE_PRECISION
argument_list|(
name|tree_type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
condition|)
name|tree_type_x
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|tree_type
argument_list|)
condition|?
name|usizetype
else|:
name|ssizetype
operator|)
expr_stmt|;
name|element
operator|=
name|convert
argument_list|(
name|tree_type_x
argument_list|,
name|element
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_2
argument_list|(
name|ARRAY_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|item
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|item
return|;
block|}
end_function

begin_comment
comment|/* This is like gcc's stabilize_reference -- in fact, most of the code    comes from that -- but it handles the situation where the reference    is going to have its subparts picked at, and it shouldn't change    (or trigger extra invocations of functions in the subtrees) due to    this.  save_expr is a bit overzealous, because we don't need the    entire thing calculated and saved like a temp.  So, for DECLs, no    change is needed, because these are stable aggregates, and ARRAY_REF    and such might well be stable too, but for things like calculations,    we do need to calculate a snapshot of a value before picking at it.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_stabilize_aggregate_
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
comment|/* No action is needed in this case.  */
return|return
name|ref
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDIRECT_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|INDIRECT_REF
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|COMPONENT_REF
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_FIELD_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|BIT_FIELD_REF
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RTL_EXPR
case|:
name|abort
argument_list|()
expr_stmt|;
default|default:
return|return
name|save_expr
argument_list|(
name|ref
argument_list|)
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
block|}
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* A rip-off of gcc's convert.c convert_to_complex function,    reworked to handle complex implemented as C structures    (RECORD_TYPE with two fields, real and imaginary `r' and `i').  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_convert_to_complex_
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|subtype
decl_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|subtype
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|==
name|REAL_TYPE
operator|||
name|form
operator|==
name|INTEGER_TYPE
operator|||
name|form
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|expr
operator|=
name|convert
argument_list|(
name|subtype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|ffecom_2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|form
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|elt_type
init|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|elt_type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|subtype
argument_list|)
condition|)
return|return
name|expr
return|;
else|else
block|{
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|ffecom_2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|form
operator|==
name|POINTER_TYPE
operator|||
name|form
operator|==
name|REFERENCE_TYPE
condition|)
name|error
argument_list|(
literal|"pointer value used where a complex was expected"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"aggregate value used where a complex was expected"
argument_list|)
expr_stmt|;
return|return
name|ffecom_2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like gcc's convert(), but crashes if widening might happen.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_convert_narrow_
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|e
init|=
name|expr
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|e
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|assert
argument_list|(
literal|"void value not ignored as it ought to be"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|assert
argument_list|(
name|code
operator|!=
name|VOID_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|!=
name|RECORD_TYPE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
condition|)
name|assert
argument_list|(
literal|"converting COMPLEX to REAL"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|code
operator|!=
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|assert
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|convert_to_integer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|convert_to_pointer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|REAL_TYPE
condition|)
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|convert_to_real
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|convert_to_complex
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
argument_list|)
expr_stmt|;
comment|/* Check that at least the first field name agrees.  */
name|assert
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|e
return|;
return|return
name|fold
argument_list|(
name|ffecom_convert_to_complex_
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
name|assert
argument_list|(
literal|"conversion to non-scalar type requested"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Like gcc's convert(), but crashes if narrowing might happen.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_convert_widen_
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|e
init|=
name|expr
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|e
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|assert
argument_list|(
literal|"void value not ignored as it ought to be"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|assert
argument_list|(
name|code
operator|!=
name|VOID_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|!=
name|RECORD_TYPE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
condition|)
name|assert
argument_list|(
literal|"narrowing COMPLEX to REAL"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|code
operator|!=
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|assert
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|convert_to_integer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|convert_to_pointer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|REAL_TYPE
condition|)
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|convert_to_real
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|convert_to_complex
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
argument_list|)
expr_stmt|;
comment|/* Check that at least the first field name agrees.  */
name|assert
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|e
return|;
return|return
name|fold
argument_list|(
name|ffecom_convert_to_complex_
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
name|assert
argument_list|(
literal|"conversion to non-scalar type requested"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Handles making a COMPLEX type, either the standard    (but buggy?) gbe way, or the safer (but less elegant?)    f2c way.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_make_complex_type_
parameter_list|(
name|tree
name|subtype
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|realfield
decl_stmt|;
name|tree
name|imagfield
decl_stmt|;
if|if
condition|(
name|ffe_is_emulate_complex
argument_list|()
condition|)
block|{
name|type
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|realfield
operator|=
name|ffecom_decl_field
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|,
literal|"r"
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
name|imagfield
operator|=
name|ffecom_decl_field
argument_list|(
name|type
argument_list|,
name|realfield
argument_list|,
literal|"i"
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|realfield
expr_stmt|;
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|subtype
expr_stmt|;
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Chooses either the gbe or the f2c way to build a    complex constant.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_build_complex_constant_
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|realpart
parameter_list|,
name|tree
name|imagpart
parameter_list|)
block|{
name|tree
name|bothparts
decl_stmt|;
if|if
condition|(
name|ffe_is_emulate_complex
argument_list|()
condition|)
block|{
name|bothparts
operator|=
name|build_tree_list
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
name|realpart
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|bothparts
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|imagpart
argument_list|)
expr_stmt|;
name|bothparts
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|bothparts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bothparts
operator|=
name|build_complex
argument_list|(
name|type
argument_list|,
name|realpart
argument_list|,
name|imagpart
argument_list|)
expr_stmt|;
block|}
return|return
name|bothparts
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|ffecom_arglist_expr_
parameter_list|(
specifier|const
name|char
modifier|*
name|c
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
name|tree
name|list
decl_stmt|;
name|tree
modifier|*
name|plist
init|=
operator|&
name|list
decl_stmt|;
name|tree
name|trail
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Append char length args here. */
name|tree
modifier|*
name|ptrail
init|=
operator|&
name|trail
decl_stmt|;
name|tree
name|length
decl_stmt|;
name|ffebld
name|exprh
decl_stmt|;
name|tree
name|item
decl_stmt|;
name|bool
name|ptr
init|=
name|FALSE
decl_stmt|;
name|tree
name|wanted
init|=
name|NULL_TREE
decl_stmt|;
specifier|static
specifier|const
name|char
name|zed
index|[]
init|=
literal|"0"
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|c
operator|=
operator|&
name|zed
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|expr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|ptr
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|==
literal|'&'
condition|)
block|{
name|ptr
operator|=
name|TRUE
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
operator|(
name|c
operator|++
operator|)
condition|)
block|{
case|case
literal|'\0'
case|:
name|ptr
operator|=
name|TRUE
expr_stmt|;
name|wanted
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|assert
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|wanted
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|wanted
operator|=
name|ffecom_f2c_complex_type_node
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|wanted
operator|=
name|ffecom_f2c_doublereal_type_node
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|wanted
operator|=
name|ffecom_f2c_doublecomplex_type_node
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|wanted
operator|=
name|ffecom_f2c_real_type_node
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|wanted
operator|=
name|ffecom_f2c_integer_type_node
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|wanted
operator|=
name|ffecom_f2c_longint_type_node
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad argstring code"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|wanted
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
block|}
name|exprh
operator|=
name|ffebld_head
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|exprh
operator|==
name|NULL
condition|)
name|wanted
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|(
name|wanted
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|ptr
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|ffecom_tree_type
index|[
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|exprh
argument_list|)
argument_list|)
index|]
index|[
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|exprh
argument_list|)
argument_list|)
index|]
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|wanted
argument_list|)
operator|)
operator|)
condition|)
operator|*
name|plist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ffecom_arg_ptr_to_expr
argument_list|(
name|exprh
argument_list|,
operator|&
name|length
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|item
operator|=
name|ffecom_arg_expr
argument_list|(
name|exprh
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_convert_widen_
argument_list|(
name|wanted
argument_list|,
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
name|item
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
operator|*
name|plist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
name|plist
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|plist
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_trail
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|NULL_TREE
condition|)
block|{
operator|*
name|ptrail
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ptrail
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|ptrail
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We've run out of args in the call; if the implementation expects      more, supply null pointers for them, which the implementation can      check to see if an arg was omitted. */
while|while
condition|(
operator|*
name|c
operator|!=
literal|'\0'
operator|&&
operator|*
name|c
operator|!=
literal|'0'
condition|)
block|{
if|if
condition|(
operator|*
name|c
operator|==
literal|'&'
condition|)
operator|++
name|c
expr_stmt|;
else|else
name|assert
argument_list|(
literal|"missing arg to run-time routine!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|c
operator|++
operator|)
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|'a'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
break|break;
default|default:
name|assert
argument_list|(
literal|"bad arg string code"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|plist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|null_pointer_node
argument_list|)
expr_stmt|;
name|plist
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|plist
argument_list|)
expr_stmt|;
block|}
operator|*
name|plist
operator|=
name|trail
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|ffecom_widest_expr_type_
parameter_list|(
name|ffebld
name|list
parameter_list|)
block|{
name|ffebld
name|item
decl_stmt|;
name|ffebld
name|widest
init|=
name|NULL
decl_stmt|;
name|ffetype
name|type
decl_stmt|;
name|ffetype
name|widest_type
init|=
name|NULL
decl_stmt|;
name|tree
name|t
decl_stmt|;
for|for
control|(
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
name|item
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|widest
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|item
argument_list|)
argument_list|)
operator|!=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|widest
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
name|type
operator|=
name|ffeinfo_type
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|widest
operator|==
name|FFEINFO_kindtypeNONE
operator|)
operator|||
operator|(
name|ffetype_size
argument_list|(
name|type
argument_list|)
operator|>
name|ffetype_size
argument_list|(
name|widest_type
argument_list|)
operator|)
condition|)
block|{
name|widest
operator|=
name|item
expr_stmt|;
name|widest_type
operator|=
name|type
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|widest
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_tree_type
index|[
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|widest
argument_list|)
argument_list|)
index|]
index|[
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|widest
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Check whether a partial overlap between two expressions is possible.     Can *starting* to write a portion of expr1 change the value    computed (perhaps already, *partially*) by expr2?     Currently, this is a concern only for a COMPLEX expr1.  But if it    isn't in COMMON or local EQUIVALENCE, since we don't support    aliasing of arguments, it isn't a concern.  */
end_comment

begin_function
specifier|static
name|bool
name|ffecom_possible_partial_overlap_
parameter_list|(
name|ffebld
name|expr1
parameter_list|,
name|ffebld
name|expr2
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|ffesymbol
name|sym
decl_stmt|;
name|ffestorag
name|st
decl_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr1
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opSYMTER
case|:
name|sym
operator|=
name|ffebld_symter
argument_list|(
name|expr1
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opARRAYREF
case|:
if|if
condition|(
name|ffebld_op
argument_list|(
name|ffebld_left
argument_list|(
name|expr1
argument_list|)
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
condition|)
return|return
name|FALSE
return|;
name|sym
operator|=
name|ffebld_symter
argument_list|(
name|ffebld_left
argument_list|(
name|expr1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|ffesymbol_where
argument_list|(
name|sym
argument_list|)
operator|!=
name|FFEINFO_whereCOMMON
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|sym
argument_list|)
operator|!=
name|FFEINFO_whereLOCAL
operator|||
operator|!
operator|(
name|st
operator|=
name|ffesymbol_storage
argument_list|(
name|sym
argument_list|)
operator|)
operator|||
operator|!
name|ffestorag_parent
argument_list|(
name|st
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* It's in COMMON or local EQUIVALENCE.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Check whether dest and source might overlap.  ffebld versions of these    might or might not be passed, will be NULL if not.     The test is really whether source_tree is modifiable and, if modified,    might overlap destination such that the value(s) in the destination might    change before it is finally modified.  dest_* are the canonized    destination itself.  */
end_comment

begin_function
specifier|static
name|bool
name|ffecom_overlap_
parameter_list|(
name|tree
name|dest_decl
parameter_list|,
name|tree
name|dest_offset
parameter_list|,
name|tree
name|dest_size
parameter_list|,
name|tree
name|source_tree
parameter_list|,
name|ffebld
name|source
name|UNUSED
parameter_list|,
name|bool
name|scalar_arg
parameter_list|)
block|{
name|tree
name|source_decl
decl_stmt|;
name|tree
name|source_offset
decl_stmt|;
name|tree
name|source_size
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|source_tree
operator|==
name|NULL_TREE
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|source_tree
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|CONST_DECL
case|:
case|case
name|VAR_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|FFS_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|COMPLEX_EXPR
case|:
case|case
name|CONJ_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|LABEL_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
return|return
name|FALSE
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|ffecom_overlap_
argument_list|(
name|dest_decl
argument_list|,
name|dest_offset
argument_list|,
name|dest_size
argument_list|,
name|TREE_OPERAND
argument_list|(
name|source_tree
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|scalar_arg
argument_list|)
return|;
case|case
name|MODIFY_EXPR
case|:
return|return
name|ffecom_overlap_
argument_list|(
name|dest_decl
argument_list|,
name|dest_offset
argument_list|,
name|dest_size
argument_list|,
name|TREE_OPERAND
argument_list|(
name|source_tree
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|scalar_arg
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|source_tree
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|TRUE
return|;
name|ffecom_tree_canonize_ptr_
argument_list|(
operator|&
name|source_decl
argument_list|,
operator|&
name|source_offset
argument_list|,
name|source_tree
argument_list|)
expr_stmt|;
name|source_size
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|source_tree
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
return|return
name|ffecom_overlap_
argument_list|(
name|dest_decl
argument_list|,
name|dest_offset
argument_list|,
name|dest_size
argument_list|,
name|TREE_OPERAND
argument_list|(
name|source_tree
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|scalar_arg
argument_list|)
operator|||
name|ffecom_overlap_
argument_list|(
name|dest_decl
argument_list|,
name|dest_offset
argument_list|,
name|dest_size
argument_list|,
name|TREE_OPERAND
argument_list|(
name|source_tree
argument_list|,
literal|2
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|scalar_arg
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
name|ffecom_tree_canonize_ref_
argument_list|(
operator|&
name|source_decl
argument_list|,
operator|&
name|source_offset
argument_list|,
operator|&
name|source_size
argument_list|,
name|TREE_OPERAND
argument_list|(
name|source_tree
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|source_tree
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|TRUE
return|;
name|source_decl
operator|=
name|source_tree
expr_stmt|;
name|source_offset
operator|=
name|bitsize_zero_node
expr_stmt|;
name|source_size
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|source_tree
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVE_EXPR
case|:
case|case
name|REFERENCE_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|CALL_EXPR
case|:
default|default:
return|return
name|TRUE
return|;
block|}
comment|/* Come here when source_decl, source_offset, and source_size filled      in appropriately.  */
if|if
condition|(
name|source_decl
operator|==
name|NULL_TREE
condition|)
return|return
name|FALSE
return|;
comment|/* No decl involved, so no overlap. */
if|if
condition|(
name|source_decl
operator|!=
name|dest_decl
condition|)
return|return
name|FALSE
return|;
comment|/* Different decl, no overlap. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dest_size
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|TRUE
return|;
comment|/* Assignment into entire assumed-size 				   array?  Shouldn't happen.... */
name|t
operator|=
name|ffecom_2
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|dest_offset
argument_list|)
argument_list|,
name|dest_offset
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|dest_offset
argument_list|)
argument_list|,
name|dest_size
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|dest_offset
argument_list|)
argument_list|,
name|source_offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_onep
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Destination precedes source. */
if|if
condition|(
operator|!
name|scalar_arg
operator|||
operator|(
name|source_size
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|source_size
argument_list|)
operator|==
name|ERROR_MARK
operator|)
operator|||
name|integer_zerop
argument_list|(
name|source_size
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* No way to tell if dest follows source. */
name|t
operator|=
name|ffecom_2
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|source_offset
argument_list|)
argument_list|,
name|source_offset
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|source_offset
argument_list|)
argument_list|,
name|source_size
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|source_offset
argument_list|)
argument_list|,
name|dest_offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_onep
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Destination follows source. */
return|return
name|TRUE
return|;
comment|/* Destination and source overlap. */
block|}
end_function

begin_comment
comment|/* Check whether dest might overlap any of a list of arguments or is    in a COMMON area the callee might know about (and thus modify).  */
end_comment

begin_function
specifier|static
name|bool
name|ffecom_args_overlapping_
parameter_list|(
name|tree
name|dest_tree
parameter_list|,
name|ffebld
name|dest
name|UNUSED
parameter_list|,
name|tree
name|args
parameter_list|,
name|tree
name|callee_commons
parameter_list|,
name|bool
name|scalar_args
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|;
name|tree
name|dest_decl
decl_stmt|;
name|tree
name|dest_offset
decl_stmt|;
name|tree
name|dest_size
decl_stmt|;
name|ffecom_tree_canonize_ref_
argument_list|(
operator|&
name|dest_decl
argument_list|,
operator|&
name|dest_offset
argument_list|,
operator|&
name|dest_size
argument_list|,
name|dest_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_decl
operator|==
name|NULL_TREE
condition|)
return|return
name|FALSE
return|;
comment|/* Seems unlikely! */
comment|/* If the decl cannot be determined reliably, or if its in COMMON      and the callee isn't known to not futz with COMMON via other      means, overlap might happen.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|dest_decl
argument_list|)
operator|==
name|ERROR_MARK
operator|)
operator|||
operator|(
operator|(
name|callee_commons
operator|!=
name|NULL_TREE
operator|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|dest_decl
argument_list|)
operator|)
condition|)
return|return
name|TRUE
return|;
for|for
control|(
init|;
name|args
operator|!=
name|NULL_TREE
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
operator|)
operator|!=
name|NULL_TREE
operator|)
operator|&&
name|ffecom_overlap_
argument_list|(
name|dest_decl
argument_list|,
name|dest_offset
argument_list|,
name|dest_size
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|,
name|scalar_args
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Build a string for a variable name as used by NAMELIST.  This means that    if we're using the f2c library, we build an uppercase string, since    f2c does this.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_build_f2c_string_
parameter_list|(
name|int
name|i
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ffe_is_f2c_library
argument_list|()
condition|)
return|return
name|build_string
argument_list|(
name|i
argument_list|,
name|s
argument_list|)
return|;
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|space
index|[
literal|34
index|]
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|>
name|ARRAY_SIZE
argument_list|(
name|space
argument_list|)
condition|)
name|tmp
operator|=
name|malloc_new_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"f2c_string"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
operator|&
name|space
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|s
operator|,
name|q
operator|=
name|tmp
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
operator|,
operator|++
name|q
control|)
operator|*
name|q
operator|=
name|TOUPPER
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|t
operator|=
name|build_string
argument_list|(
name|i
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|>
name|ARRAY_SIZE
argument_list|(
name|space
argument_list|)
condition|)
name|malloc_kill_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
name|tmp
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns CALL_EXPR or equivalent with given type (pass NULL_TREE for    type to just get whatever the function returns), handling the    f2c value-returning convention, if required, by prepending    to the arglist a pointer to a temporary to receive the return value.	 */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_call_
parameter_list|(
name|tree
name|fn
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|,
name|bool
name|is_f2c_complex
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|args
parameter_list|,
name|tree
name|dest_tree
parameter_list|,
name|ffebld
name|dest
parameter_list|,
name|bool
modifier|*
name|dest_used
parameter_list|,
name|tree
name|callee_commons
parameter_list|,
name|bool
name|scalar_args
parameter_list|,
name|tree
name|hook
parameter_list|)
block|{
name|tree
name|item
decl_stmt|;
name|tree
name|tempvar
decl_stmt|;
if|if
condition|(
name|dest_used
operator|!=
name|NULL
condition|)
operator|*
name|dest_used
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|is_f2c_complex
condition|)
block|{
if|if
condition|(
operator|(
name|dest_used
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dest
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|!=
name|kt
operator|)
operator|||
operator|(
operator|(
name|type
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|dest_tree
argument_list|)
operator|!=
name|type
operator|)
operator|)
operator|||
name|ffecom_args_overlapping_
argument_list|(
name|dest_tree
argument_list|,
name|dest
argument_list|,
name|args
argument_list|,
name|callee_commons
argument_list|,
name|scalar_args
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HOHO
name|tempvar
operator|=
name|ffecom_make_tempvar
argument_list|(
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeCOMPLEX
index|]
index|[
name|kt
index|]
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|tempvar
operator|=
name|hook
expr_stmt|;
name|assert
argument_list|(
name|tempvar
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
operator|*
name|dest_used
operator|=
name|TRUE
expr_stmt|;
name|tempvar
operator|=
name|dest_tree
expr_stmt|;
name|type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|item
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tempvar
argument_list|)
argument_list|)
argument_list|,
name|tempvar
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
operator|=
name|args
expr_stmt|;
name|item
operator|=
name|ffecom_3s
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|,
name|item
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempvar
operator|!=
name|dest_tree
condition|)
name|item
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tempvar
argument_list|)
argument_list|,
name|item
argument_list|,
name|tempvar
argument_list|)
expr_stmt|;
block|}
else|else
name|item
operator|=
name|ffecom_3s
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
operator|!=
name|type
operator|)
condition|)
name|item
operator|=
name|ffecom_convert_narrow_
argument_list|(
name|type
argument_list|,
name|item
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
end_function

begin_comment
comment|/* Given two arguments, transform them and make a call to the given    function via ffecom_call_.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_call_binop_
parameter_list|(
name|tree
name|fn
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|,
name|bool
name|is_f2c_complex
parameter_list|,
name|tree
name|type
parameter_list|,
name|ffebld
name|left
parameter_list|,
name|ffebld
name|right
parameter_list|,
name|tree
name|dest_tree
parameter_list|,
name|ffebld
name|dest
parameter_list|,
name|bool
modifier|*
name|dest_used
parameter_list|,
name|tree
name|callee_commons
parameter_list|,
name|bool
name|scalar_args
parameter_list|,
name|bool
name|ref
parameter_list|,
name|tree
name|hook
parameter_list|)
block|{
name|tree
name|left_tree
decl_stmt|;
name|tree
name|right_tree
decl_stmt|;
name|tree
name|left_length
decl_stmt|;
name|tree
name|right_length
decl_stmt|;
if|if
condition|(
name|ref
condition|)
block|{
comment|/* Pass arguments by reference.  */
name|left_tree
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|left
argument_list|,
operator|&
name|left_length
argument_list|)
expr_stmt|;
name|right_tree
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|right
argument_list|,
operator|&
name|right_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Pass arguments by value.  */
name|left_tree
operator|=
name|ffecom_arg_expr
argument_list|(
name|left
argument_list|,
operator|&
name|left_length
argument_list|)
expr_stmt|;
name|right_tree
operator|=
name|ffecom_arg_expr
argument_list|(
name|right
argument_list|,
operator|&
name|right_length
argument_list|)
expr_stmt|;
block|}
name|left_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|left_tree
argument_list|)
expr_stmt|;
name|right_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|right_tree
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|left_tree
argument_list|)
operator|=
name|right_tree
expr_stmt|;
if|if
condition|(
name|left_length
operator|!=
name|NULL_TREE
condition|)
block|{
name|left_length
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|left_length
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|right_tree
argument_list|)
operator|=
name|left_length
expr_stmt|;
block|}
if|if
condition|(
name|right_length
operator|!=
name|NULL_TREE
condition|)
block|{
name|right_length
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|right_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|left_length
operator|!=
name|NULL_TREE
condition|)
name|TREE_CHAIN
argument_list|(
name|left_length
argument_list|)
operator|=
name|right_length
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|right_tree
argument_list|)
operator|=
name|right_length
expr_stmt|;
block|}
return|return
name|ffecom_call_
argument_list|(
name|fn
argument_list|,
name|kt
argument_list|,
name|is_f2c_complex
argument_list|,
name|type
argument_list|,
name|left_tree
argument_list|,
name|dest_tree
argument_list|,
name|dest
argument_list|,
name|dest_used
argument_list|,
name|callee_commons
argument_list|,
name|scalar_args
argument_list|,
name|hook
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return ptr/length args for char subexpression     Handles CHARACTER-type CONTER, SYMTER, SUBSTR, ARRAYREF, and FUNCREF    subexpressions by constructing the appropriate trees for the ptr-to-    character-text and length-of-character-text arguments in a calling    sequence.     Note that if with_null is TRUE, and the expression is an opCONTER,    a null byte is appended to the string.  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_char_args_x_
parameter_list|(
name|tree
modifier|*
name|xitem
parameter_list|,
name|tree
modifier|*
name|length
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|bool
name|with_null
parameter_list|)
block|{
name|tree
name|item
decl_stmt|;
name|tree
name|high
decl_stmt|;
name|ffetargetCharacter1
name|val
decl_stmt|;
name|ffetargetCharacterSize
name|newlen
decl_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opCONTER
case|:
name|val
operator|=
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|newlen
operator|=
name|ffetarget_length_character1
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|with_null
condition|)
block|{
comment|/* Begin FFETARGET-NULL-KLUDGE.  */
if|if
condition|(
name|newlen
operator|!=
literal|0
condition|)
operator|++
name|newlen
expr_stmt|;
block|}
operator|*
name|length
operator|=
name|build_int_2
argument_list|(
name|newlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|length
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
name|high
operator|=
name|build_int_2
argument_list|(
name|newlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|high
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
name|item
operator|=
name|build_string
argument_list|(
name|newlen
argument_list|,
name|ffetarget_text_character1
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* End FFETARGET-NULL-KLUDGE.  */
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
operator|=
name|build_type_variant
argument_list|(
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_range_type
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|ffecom_f2c_ftnlen_one_node
argument_list|,
name|high
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|item
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|item
argument_list|)
operator|=
literal|1
expr_stmt|;
name|item
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|,
name|item
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opSYMTER
case|:
block|{
name|ffesymbol
name|s
init|=
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|item
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL_TREE
condition|)
block|{
name|s
operator|=
name|ffecom_sym_transform_
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
block|}
if|if
condition|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_kindENTITY
condition|)
block|{
if|if
condition|(
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
operator|==
name|FFETARGET_charactersizeNONE
condition|)
operator|*
name|length
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|length_tree
expr_stmt|;
else|else
block|{
operator|*
name|length
operator|=
name|build_int_2
argument_list|(
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|length
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|item
operator|==
name|error_mark_node
condition|)
operator|*
name|length
operator|=
name|error_mark_node
expr_stmt|;
else|else
comment|/* FFEINFO_kindFUNCTION.  */
operator|*
name|length
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|addr
operator|&&
operator|(
name|item
operator|!=
name|error_mark_node
operator|)
condition|)
name|item
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FFEBLD_opARRAYREF
case|:
block|{
name|ffecom_char_args_
argument_list|(
operator|&
name|item
argument_list|,
name|length
argument_list|,
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|error_mark_node
operator|||
operator|*
name|length
operator|==
name|error_mark_node
condition|)
block|{
name|item
operator|=
operator|*
name|length
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
name|item
operator|=
name|ffecom_arrayref_
argument_list|(
name|item
argument_list|,
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FFEBLD_opSUBSTR
case|:
block|{
name|ffebld
name|start
decl_stmt|;
name|ffebld
name|end
decl_stmt|;
name|ffebld
name|thing
init|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|start_tree
decl_stmt|;
name|tree
name|end_tree
decl_stmt|;
specifier|const
name|char
modifier|*
name|char_name
decl_stmt|;
name|ffebld
name|left_symter
decl_stmt|;
name|tree
name|array
decl_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|thing
argument_list|)
operator|==
name|FFEBLD_opITEM
argument_list|)
expr_stmt|;
name|start
operator|=
name|ffebld_head
argument_list|(
name|thing
argument_list|)
expr_stmt|;
name|thing
operator|=
name|ffebld_trail
argument_list|(
name|thing
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_trail
argument_list|(
name|thing
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|end
operator|=
name|ffebld_head
argument_list|(
name|thing
argument_list|)
expr_stmt|;
comment|/* Determine name for pretty-printing range-check errors.  */
for|for
control|(
name|left_symter
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
init|;
name|left_symter
operator|&&
name|ffebld_op
argument_list|(
name|left_symter
argument_list|)
operator|==
name|FFEBLD_opARRAYREF
condition|;
name|left_symter
operator|=
name|ffebld_left
argument_list|(
name|left_symter
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|left_symter
argument_list|)
operator|==
name|FFEBLD_opSYMTER
condition|)
name|char_name
operator|=
name|ffesymbol_text
argument_list|(
name|ffebld_symter
argument_list|(
name|left_symter
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|char_name
operator|=
literal|"[expr?]"
expr_stmt|;
name|ffecom_char_args_
argument_list|(
operator|&
name|item
argument_list|,
name|length
argument_list|,
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|error_mark_node
operator|||
operator|*
name|length
operator|==
name|error_mark_node
condition|)
block|{
name|item
operator|=
operator|*
name|length
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
name|array
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ~~~~Handle INTEGER*8 start/end, a la FFEBLD_opARRAYREF.  */
if|if
condition|(
name|start
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
empty_stmt|;
else|else
block|{
name|end_tree
operator|=
name|ffecom_expr
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_bounds_check
condition|)
name|end_tree
operator|=
name|ffecom_subscript_check_
argument_list|(
name|array
argument_list|,
name|end_tree
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|char_name
argument_list|)
expr_stmt|;
name|end_tree
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|end_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_tree
operator|==
name|error_mark_node
condition|)
block|{
name|item
operator|=
operator|*
name|length
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
operator|*
name|length
operator|=
name|end_tree
expr_stmt|;
block|}
block|}
else|else
block|{
name|start_tree
operator|=
name|ffecom_expr
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_bounds_check
condition|)
name|start_tree
operator|=
name|ffecom_subscript_check_
argument_list|(
name|array
argument_list|,
name|start_tree
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|char_name
argument_list|)
expr_stmt|;
name|start_tree
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|start_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_tree
operator|==
name|error_mark_node
condition|)
block|{
name|item
operator|=
operator|*
name|length
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
name|start_tree
operator|=
name|ffecom_save_tree
argument_list|(
name|start_tree
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
argument_list|,
name|item
argument_list|,
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|start_tree
argument_list|)
argument_list|,
name|start_tree
argument_list|,
name|ffecom_f2c_ftnlen_one_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
block|{
operator|*
name|length
operator|=
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|ffecom_f2c_ftnlen_one_node
argument_list|,
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|,
operator|*
name|length
argument_list|,
name|start_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|end_tree
operator|=
name|ffecom_expr
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_bounds_check
condition|)
name|end_tree
operator|=
name|ffecom_subscript_check_
argument_list|(
name|array
argument_list|,
name|end_tree
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|char_name
argument_list|)
expr_stmt|;
name|end_tree
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|end_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_tree
operator|==
name|error_mark_node
condition|)
block|{
name|item
operator|=
operator|*
name|length
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
operator|*
name|length
operator|=
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|ffecom_f2c_ftnlen_one_node
argument_list|,
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|end_tree
argument_list|,
name|start_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|FFEBLD_opFUNCREF
case|:
block|{
name|ffesymbol
name|s
init|=
name|ffebld_symter
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tempvar
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|ffetargetCharacterSize
name|size
init|=
name|ffeinfo_size
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
name|ffecomGfrt
name|ix
decl_stmt|;
if|if
condition|(
name|size
operator|==
name|FFETARGET_charactersizeNONE
condition|)
comment|/* ~~Kludge alert!  This should someday be fixed. */
name|size
operator|=
literal|24
expr_stmt|;
operator|*
name|length
operator|=
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|length
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FFEINFO_whereINTRINSIC
condition|)
block|{
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
comment|/* Invocation of an intrinsic returning CHARACTER*1.  */
name|item
operator|=
name|ffecom_expr_intrinsic_
argument_list|(
name|expr
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|ix
operator|=
name|ffeintrin_gfrt_direct
argument_list|(
name|ffebld_symter_implementation
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ix
operator|!=
name|FFECOM_gfrt
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_gfrt_tree_
argument_list|(
name|ix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ix
operator|=
name|FFECOM_gfrt
expr_stmt|;
name|item
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL_TREE
condition|)
block|{
name|s
operator|=
name|ffecom_sym_transform_
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|==
name|error_mark_node
condition|)
block|{
name|item
operator|=
operator|*
name|length
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|addr
condition|)
name|item
operator|=
name|ffecom_1_fn
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HOHO
name|tempvar
operator|=
name|ffecom_push_tempvar
argument_list|(
name|char_type_node
argument_list|,
name|size
argument_list|,
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|#
directive|else
name|tempvar
operator|=
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tempvar
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tempvar
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tempvar
argument_list|)
argument_list|)
argument_list|,
name|tempvar
argument_list|)
expr_stmt|;
name|args
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|tempvar
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereCONSTANT
condition|)
comment|/* Sfunc args by value. */
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
operator|=
name|ffecom_list_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
operator|*
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereINTRINSIC
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
operator|=
name|ffecom_arglist_expr_
argument_list|(
name|ffecom_gfrt_args_
argument_list|(
name|ix
argument_list|)
argument_list|,
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
operator|=
name|ffecom_list_ptr_to_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|item
operator|=
name|ffecom_3s
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|item
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tempvar
argument_list|)
argument_list|,
name|item
argument_list|,
name|tempvar
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FFEBLD_opCONVERT
case|:
name|ffecom_char_args_
argument_list|(
operator|&
name|item
argument_list|,
name|length
argument_list|,
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|error_mark_node
operator|||
operator|*
name|length
operator|==
name|error_mark_node
condition|)
block|{
name|item
operator|=
operator|*
name|length
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ffebld_size_known
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFETARGET_charactersizeNONE
operator|)
operator|||
operator|(
name|ffebld_size_known
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|<
operator|(
name|ffebld_size
argument_list|(
name|expr
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Possible blank-padding needed, copy into 				   temporary. */
name|tree
name|tempvar
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|tree
name|newlen
decl_stmt|;
ifdef|#
directive|ifdef
name|HOHO
name|tempvar
operator|=
name|ffecom_make_tempvar
argument_list|(
name|char_type_node
argument_list|,
name|ffebld_size
argument_list|(
name|expr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|tempvar
operator|=
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tempvar
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tempvar
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tempvar
argument_list|)
argument_list|)
argument_list|,
name|tempvar
argument_list|)
expr_stmt|;
name|newlen
operator|=
name|build_int_2
argument_list|(
name|ffebld_size
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|newlen
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
name|args
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|tempvar
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
operator|*
name|length
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtCOPY
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|item
argument_list|)
operator|=
literal|1
expr_stmt|;
name|item
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tempvar
argument_list|)
argument_list|,
name|fold
argument_list|(
name|item
argument_list|)
argument_list|,
name|tempvar
argument_list|)
expr_stmt|;
operator|*
name|length
operator|=
name|newlen
expr_stmt|;
block|}
else|else
block|{
comment|/* Just truncate the length. */
operator|*
name|length
operator|=
name|build_int_2
argument_list|(
name|ffebld_size
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|length
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad op for single char arg expr"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|item
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
operator|*
name|xitem
operator|=
name|item
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check the size of the type to be sure it doesn't overflow the    "portable" capacities of the compiler back end.  `dummy' types    can generally overflow the normal sizes as long as the computations    themselves don't overflow.  A particular target of the back end    must still enforce its size requirements, though, and the back    end takes care of this in stor-layout.c.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_check_size_overflow_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|dummy
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|type
return|;
if|if
condition|(
operator|(
name|tree_int_cst_sgn
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|!
name|dummy
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_ARRAY_LARGE
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffesymbol_where_line
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where_column
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Builds a length argument (PARM_DECL).  Also wraps type in an array type    where the dimension info is (1:size) where<size> is ffesymbol_size(s) if    known, length_arg if not known (FFETARGET_charactersizeNONE).  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_char_enhance_arg_
parameter_list|(
name|tree
modifier|*
name|xtype
parameter_list|,
name|ffesymbol
name|s
parameter_list|)
block|{
name|ffetargetCharacterSize
name|sz
init|=
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|tree
name|highval
decl_stmt|;
name|tree
name|tlen
decl_stmt|;
name|tree
name|type
init|=
operator|*
name|xtype
decl_stmt|;
if|if
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereCONSTANT
condition|)
name|tlen
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* A statement function, no length passed. */
else|else
block|{
if|if
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereDUMMY
condition|)
name|tlen
operator|=
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_length_%s"
argument_list|,
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|tlen
operator|=
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_%s"
argument_list|,
literal|"length"
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|tlen
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|tlen
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sz
operator|==
name|FFETARGET_charactersizeNONE
condition|)
block|{
name|assert
argument_list|(
name|tlen
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|highval
operator|=
name|variable_size
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|highval
operator|=
name|build_int_2
argument_list|(
name|sz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|highval
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
block|}
name|type
operator|=
name|build_array_type
argument_list|(
name|type
argument_list|,
name|build_range_type
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|ffecom_f2c_ftnlen_one_node
argument_list|,
name|highval
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|xtype
operator|=
name|type
expr_stmt|;
return|return
name|tlen
return|;
block|}
end_function

begin_comment
comment|/* ffecom_concat_list_gather_ -- Gather list of concatenated string exprs     ffecomConcatList_ catlist;    ffebld expr;	 // expr of CHARACTER basictype.    ffetargetCharacterSize max;	// max chars to gather or _...NONE if no max    catlist = ffecom_concat_list_gather_(catlist,expr,max);     Scans expr for character subexpressions, updates and returns catlist    accordingly.	 */
end_comment

begin_function
specifier|static
name|ffecomConcatList_
name|ffecom_concat_list_gather_
parameter_list|(
name|ffecomConcatList_
name|catlist
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffetargetCharacterSize
name|max
parameter_list|)
block|{
name|ffetargetCharacterSize
name|sz
decl_stmt|;
name|recurse
label|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return
name|catlist
return|;
if|if
condition|(
operator|(
name|max
operator|!=
name|FFETARGET_charactersizeNONE
operator|)
operator|&&
operator|(
name|catlist
operator|.
name|minlen
operator|>=
name|max
operator|)
condition|)
return|return
name|catlist
return|;
comment|/* Don't append any more items. */
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opCONTER
case|:
case|case
name|FFEBLD_opSYMTER
case|:
case|case
name|FFEBLD_opARRAYREF
case|:
case|case
name|FFEBLD_opFUNCREF
case|:
case|case
name|FFEBLD_opSUBSTR
case|:
case|case
name|FFEBLD_opCONVERT
case|:
comment|/* Callers should strip this off beforehand 				   if they don't need to preserve it. */
if|if
condition|(
name|catlist
operator|.
name|count
operator|==
name|catlist
operator|.
name|max
condition|)
block|{
comment|/* Make a (larger) list. */
name|ffebld
modifier|*
name|newx
decl_stmt|;
name|int
name|newmax
decl_stmt|;
name|newmax
operator|=
operator|(
name|catlist
operator|.
name|max
operator|==
literal|0
operator|)
condition|?
literal|8
else|:
name|catlist
operator|.
name|max
operator|*
literal|2
expr_stmt|;
name|newx
operator|=
name|malloc_new_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"catlist"
argument_list|,
name|newmax
operator|*
sizeof|sizeof
argument_list|(
name|newx
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|catlist
operator|.
name|max
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|newx
argument_list|,
name|catlist
operator|.
name|exprs
argument_list|,
name|catlist
operator|.
name|max
operator|*
sizeof|sizeof
argument_list|(
name|newx
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
name|catlist
operator|.
name|exprs
argument_list|,
name|catlist
operator|.
name|max
operator|*
sizeof|sizeof
argument_list|(
name|newx
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|catlist
operator|.
name|max
operator|=
name|newmax
expr_stmt|;
name|catlist
operator|.
name|exprs
operator|=
name|newx
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sz
operator|=
name|ffebld_size_known
argument_list|(
name|expr
argument_list|)
operator|)
operator|!=
name|FFETARGET_charactersizeNONE
condition|)
name|catlist
operator|.
name|minlen
operator|+=
name|sz
expr_stmt|;
else|else
operator|++
name|catlist
operator|.
name|minlen
expr_stmt|;
comment|/* Not true for F90; can be 0 length. */
if|if
condition|(
operator|(
name|sz
operator|=
name|ffebld_size_max
argument_list|(
name|expr
argument_list|)
operator|)
operator|==
name|FFETARGET_charactersizeNONE
condition|)
name|catlist
operator|.
name|maxlen
operator|=
name|sz
expr_stmt|;
else|else
name|catlist
operator|.
name|maxlen
operator|+=
name|sz
expr_stmt|;
if|if
condition|(
operator|(
name|max
operator|!=
name|FFETARGET_charactersizeNONE
operator|)
operator|&&
operator|(
name|catlist
operator|.
name|minlen
operator|>
name|max
operator|)
condition|)
block|{
comment|/* This item overlaps (or is beyond) the end 				   of the destination. */
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opCONTER
case|:
case|case
name|FFEBLD_opSYMTER
case|:
case|case
name|FFEBLD_opARRAYREF
case|:
case|case
name|FFEBLD_opFUNCREF
case|:
case|case
name|FFEBLD_opSUBSTR
case|:
comment|/* ~~Do useful truncations here. */
break|break;
default|default:
name|assert
argument_list|(
literal|"op changed or inconsistent switches!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|catlist
operator|.
name|exprs
index|[
name|catlist
operator|.
name|count
operator|++
index|]
operator|=
name|expr
expr_stmt|;
return|return
name|catlist
return|;
case|case
name|FFEBLD_opPAREN
case|:
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEBLD_opCONCATENATE
case|:
name|catlist
operator|=
name|ffecom_concat_list_gather_
argument_list|(
name|catlist
argument_list|,
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
if|#
directive|if
literal|0
comment|/* Breaks passing small actual arg to larger 				   dummy arg of sfunc */
block|case FFEBLD_opCONVERT:       expr = ffebld_left (expr);       { 	ffetargetCharacterSize cmax;  	cmax = catlist.len + ffebld_size_known (expr);  	if ((max == FFETARGET_charactersizeNONE) || (max> cmax)) 	  max = cmax;       }       goto recurse;
comment|/* :::::::::::::::::::: */
endif|#
directive|endif
case|case
name|FFEBLD_opANY
case|:
return|return
name|catlist
return|;
default|default:
name|assert
argument_list|(
literal|"bad op in _gather_"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|catlist
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffecom_concat_list_kill_ -- Kill list of concatenated string exprs     ffecomConcatList_ catlist;    ffecom_concat_list_kill_(catlist);     Anything allocated within the list info is deallocated.  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_concat_list_kill_
parameter_list|(
name|ffecomConcatList_
name|catlist
parameter_list|)
block|{
if|if
condition|(
name|catlist
operator|.
name|max
operator|!=
literal|0
condition|)
name|malloc_kill_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
name|catlist
operator|.
name|exprs
argument_list|,
name|catlist
operator|.
name|max
operator|*
sizeof|sizeof
argument_list|(
name|catlist
operator|.
name|exprs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make list of concatenated string exprs.     Returns a flattened list of concatenated subexpressions given a    tree of such expressions.  */
end_comment

begin_function
specifier|static
name|ffecomConcatList_
name|ffecom_concat_list_new_
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffetargetCharacterSize
name|max
parameter_list|)
block|{
name|ffecomConcatList_
name|catlist
decl_stmt|;
name|catlist
operator|.
name|maxlen
operator|=
name|catlist
operator|.
name|minlen
operator|=
name|catlist
operator|.
name|max
operator|=
name|catlist
operator|.
name|count
operator|=
literal|0
expr_stmt|;
return|return
name|ffecom_concat_list_gather_
argument_list|(
name|catlist
argument_list|,
name|expr
argument_list|,
name|max
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Provide some kind of useful info on member of aggregate area,    since current g77/gcc technology does not provide debug info    on these members.  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_debug_kludge_
parameter_list|(
name|tree
name|aggr
parameter_list|,
specifier|const
name|char
modifier|*
name|aggr_type
parameter_list|,
name|ffesymbol
name|member
parameter_list|,
name|tree
name|member_type
name|UNUSED
parameter_list|,
name|ffetargetOffset
name|offset
parameter_list|)
block|{
name|tree
name|value
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
name|char
name|space
index|[
literal|120
index|]
decl_stmt|;
if|#
directive|if
literal|0
block|tree type_id;    for (type_id = member_type;        TREE_CODE (type_id) != IDENTIFIER_NODE;        )     {       switch (TREE_CODE (type_id)) 	{ 	case INTEGER_TYPE: 	case REAL_TYPE: 	  type_id = TYPE_NAME (type_id); 	  break;  	case ARRAY_TYPE: 	case COMPLEX_TYPE: 	  type_id = TREE_TYPE (type_id); 	  break;  	default: 	  assert ("no IDENTIFIER_NODE for type!" == NULL); 	  type_id = error_mark_node; 	  break; 	}     }
endif|#
directive|endif
if|if
condition|(
name|ffecom_transform_only_dummies_
operator|||
operator|!
name|ffe_is_debug_kludge
argument_list|()
condition|)
return|return;
comment|/* Can't do this yet, maybe later. */
name|len
operator|=
literal|60
operator|+
name|strlen
argument_list|(
name|aggr_type
argument_list|)
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|aggr
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|+ IDENTIFIER_LENGTH (type_id);
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|len
operator|)
operator|>=
name|ARRAY_SIZE
argument_list|(
name|space
argument_list|)
condition|)
name|buff
operator|=
name|malloc_new_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"debug_kludge"
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|buff
operator|=
operator|&
name|space
index|[
literal|0
index|]
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|buff
index|[
literal|0
index|]
argument_list|,
literal|"At (%s) `%s' plus %ld bytes"
argument_list|,
name|aggr_type
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|aggr
argument_list|)
argument_list|)
argument_list|,
operator|(
name|long
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
name|value
operator|=
name|build_string
argument_list|(
name|len
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|build_type_variant
argument_list|(
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_range_type
argument_list|(
name|integer_type_node
argument_list|,
name|integer_one_node
argument_list|,
name|build_int_2
argument_list|(
name|strlen
argument_list|(
name|buff
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_identifier_
argument_list|(
name|ffesymbol_text
argument_list|(
name|member
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't let -Wunused complain. */
name|decl
operator|=
name|start_decl
argument_list|(
name|decl
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|value
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|!=
operator|&
name|space
index|[
literal|0
index|]
condition|)
name|malloc_kill_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
name|buff
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffecom_do_entry_ -- Do compilation of a particular entrypoint     ffesymbol fn;  // the SUBROUTINE, FUNCTION, or ENTRY symbol itself    int i;  // entry# for this entrypoint (used by master fn)    ffecom_do_entrypoint_(s,i);     Makes a public entry point that calls our private master fn (already    compiled).  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_do_entry_
parameter_list|(
name|ffesymbol
name|fn
parameter_list|,
name|int
name|entrynum
parameter_list|)
block|{
name|ffebld
name|item
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* Type of function. */
name|tree
name|multi_retval
decl_stmt|;
comment|/* Var holding return value (union). */
name|tree
name|result
decl_stmt|;
comment|/* Var holding result. */
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|ffeglobal
name|g
decl_stmt|;
name|ffeglobalType
name|gt
decl_stmt|;
name|bool
name|charfunc
decl_stmt|;
comment|/* All entry points return same type 				   CHARACTER. */
name|bool
name|cmplxfunc
decl_stmt|;
comment|/* Use f2c way of returning COMPLEX. */
name|bool
name|multi
decl_stmt|;
comment|/* Master fn has multiple return types. */
name|bool
name|altreturning
init|=
name|FALSE
decl_stmt|;
comment|/* This entry point has alternate returns. */
name|int
name|old_lineno
init|=
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
name|input_filename
operator|=
name|ffesymbol_where_filename
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|ffesymbol_where_filelinenum
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|ffecom_doing_entry_
operator|=
name|TRUE
expr_stmt|;
comment|/* Don't bother with array dimensions. */
switch|switch
condition|(
name|ffecom_primary_entry_kind_
condition|)
block|{
case|case
name|FFEINFO_kindFUNCTION
case|:
comment|/* Determine actual return type for function. */
name|gt
operator|=
name|FFEGLOBAL_typeFUNC
expr_stmt|;
name|bt
operator|=
name|ffesymbol_basictype
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffesymbol_kindtype
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeNONE
condition|)
block|{
name|ffeimplic_establish_symbol
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_funcresult
argument_list|(
name|fn
argument_list|)
operator|!=
name|NULL
condition|)
name|ffeimplic_establish_symbol
argument_list|(
name|ffesymbol_funcresult
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|bt
operator|=
name|ffesymbol_basictype
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffesymbol_kindtype
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
name|charfunc
operator|=
name|TRUE
operator|,
name|cmplxfunc
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bt
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|&&
name|ffesymbol_is_f2c
argument_list|(
name|fn
argument_list|)
condition|)
name|charfunc
operator|=
name|FALSE
operator|,
name|cmplxfunc
operator|=
name|TRUE
expr_stmt|;
else|else
name|charfunc
operator|=
name|cmplxfunc
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|charfunc
condition|)
name|type
operator|=
name|ffecom_tree_fun_type_void
expr_stmt|;
elseif|else
if|if
condition|(
name|ffesymbol_is_f2c
argument_list|(
name|fn
argument_list|)
condition|)
name|type
operator|=
name|ffecom_tree_fun_type
index|[
name|bt
index|]
index|[
name|kt
index|]
expr_stmt|;
else|else
name|type
operator|=
name|build_function_type
argument_list|(
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
name|type
operator|=
name|ffecom_tree_fun_type_void
expr_stmt|;
comment|/* _sym_exec_transition. */
name|multi
operator|=
operator|(
name|ffecom_master_bt_
operator|==
name|FFEINFO_basictypeNONE
operator|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindSUBROUTINE
case|:
name|gt
operator|=
name|FFEGLOBAL_typeSUBR
expr_stmt|;
name|bt
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
name|kt
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
if|if
condition|(
name|ffecom_is_altreturning_
condition|)
block|{
comment|/* Am _I_ altreturning? */
for|for
control|(
name|item
operator|=
name|ffesymbol_dummyargs
argument_list|(
name|fn
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
if|if
condition|(
name|ffebld_op
argument_list|(
name|ffebld_head
argument_list|(
name|item
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opSTAR
condition|)
block|{
name|altreturning
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|altreturning
condition|)
name|type
operator|=
name|ffecom_tree_subr_type
expr_stmt|;
else|else
name|type
operator|=
name|ffecom_tree_fun_type_void
expr_stmt|;
block|}
else|else
name|type
operator|=
name|ffecom_tree_fun_type_void
expr_stmt|;
name|charfunc
operator|=
name|FALSE
expr_stmt|;
name|cmplxfunc
operator|=
name|FALSE
expr_stmt|;
name|multi
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"say what??"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_kindANY
case|:
name|gt
operator|=
name|FFEGLOBAL_typeANY
expr_stmt|;
name|bt
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
name|kt
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
name|charfunc
operator|=
name|FALSE
expr_stmt|;
name|cmplxfunc
operator|=
name|FALSE
expr_stmt|;
name|multi
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
comment|/* build_decl uses the current lineno and input_filename to set the decl      source info.  So, I've putzed with ffestd and ffeste code to update that      source info to point to the appropriate statement just before calling      ffecom_do_entrypoint (which calls this fn).  */
name|start_function
argument_list|(
name|ffecom_get_external_identifier_
argument_list|(
name|fn
argument_list|)
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
comment|/* nested/inline */
literal|1
argument_list|)
expr_stmt|;
comment|/* TREE_PUBLIC */
if|if
condition|(
operator|(
operator|(
name|g
operator|=
name|ffesymbol_global
argument_list|(
name|fn
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|gt
operator|)
operator|||
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|FFEGLOBAL_typeEXT
operator|)
operator|)
condition|)
block|{
name|ffeglobal_set_hook
argument_list|(
name|g
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
comment|/* Reset args in master arg list so they get retransitioned. */
for|for
control|(
name|item
operator|=
name|ffecom_master_arglist_
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
name|ffebld
name|arg
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|arg
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|arg
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
condition|)
continue|continue;
comment|/* Alternate return or some such thing. */
name|s
operator|=
name|ffebld_symter
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
operator|=
name|NULL_TREE
expr_stmt|;
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|length_tree
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Build dummy arg list for this entry point. */
if|if
condition|(
name|charfunc
operator|||
name|cmplxfunc
condition|)
block|{
comment|/* Prepend arg for where result goes. */
name|tree
name|type
decl_stmt|;
name|tree
name|length
decl_stmt|;
if|if
condition|(
name|charfunc
condition|)
name|type
operator|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeCHARACTER
index|]
index|[
name|kt
index|]
expr_stmt|;
else|else
name|type
operator|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeCOMPLEX
index|]
index|[
name|kt
index|]
expr_stmt|;
name|result
operator|=
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_%s"
argument_list|,
literal|"result"
argument_list|)
expr_stmt|;
comment|/* Make length arg _and_ enhance type info for CHAR arg itself.  */
if|if
condition|(
name|charfunc
condition|)
name|length
operator|=
name|ffecom_char_enhance_arg_
argument_list|(
operator|&
name|type
argument_list|,
name|fn
argument_list|)
expr_stmt|;
else|else
name|length
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Not ref'd if !charfunc. */
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|result
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|push_parm_decl
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|ffecom_func_result_
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|charfunc
condition|)
block|{
name|push_parm_decl
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|ffecom_func_length_
operator|=
name|length
expr_stmt|;
block|}
block|}
else|else
name|result
operator|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|ffecom_push_dummy_decls_
argument_list|(
name|ffesymbol_dummyargs
argument_list|(
name|fn
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ffecom_start_compstmt
argument_list|()
expr_stmt|;
comment|/* Disallow temp vars at this level.  */
name|current_binding_level
operator|->
name|prep_state
operator|=
literal|2
expr_stmt|;
comment|/* Make local var to hold return type for multi-type master fn. */
if|if
condition|(
name|multi
condition|)
block|{
name|multi_retval
operator|=
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_%s"
argument_list|,
literal|"multi_retval"
argument_list|)
expr_stmt|;
name|multi_retval
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|multi_retval
argument_list|,
name|ffecom_multi_type_node_
argument_list|)
expr_stmt|;
name|multi_retval
operator|=
name|start_decl
argument_list|(
name|multi_retval
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|multi_retval
argument_list|,
name|NULL_TREE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
name|multi_retval
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Not actually ref'd if !multi. */
comment|/* Here we emit the actual code for the entry point. */
block|{
name|ffebld
name|list
decl_stmt|;
name|ffebld
name|arg
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|tree
name|arglist
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|plist
init|=
operator|&
name|arglist
decl_stmt|;
name|tree
name|prepend
decl_stmt|;
name|tree
name|call
decl_stmt|;
name|tree
name|actarg
decl_stmt|;
name|tree
name|master_fn
decl_stmt|;
comment|/* Prepare actual arg list based on master arg list. */
for|for
control|(
name|list
operator|=
name|ffecom_master_arglist_
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
name|arg
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|arg
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
condition|)
continue|continue;
name|s
operator|=
name|ffebld_symter
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
operator|==
name|NULL_TREE
operator|||
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
operator|==
name|error_mark_node
condition|)
name|actarg
operator|=
name|null_pointer_node
expr_stmt|;
comment|/* We don't have this arg. */
else|else
name|actarg
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
operator|*
name|plist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|actarg
argument_list|)
expr_stmt|;
name|plist
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|plist
argument_list|)
expr_stmt|;
block|}
comment|/* This code appends the length arguments for character        variables/arrays.  */
for|for
control|(
name|list
operator|=
name|ffecom_master_arglist_
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
name|arg
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|arg
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
condition|)
continue|continue;
name|s
operator|=
name|ffebld_symter
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_basictypeCHARACTER
condition|)
continue|continue;
comment|/* Only looking for CHARACTER arguments. */
if|if
condition|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_kindENTITY
condition|)
continue|continue;
comment|/* Only looking for variables and arrays. */
if|if
condition|(
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|length_tree
operator|==
name|NULL_TREE
operator|||
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|length_tree
operator|==
name|error_mark_node
condition|)
name|actarg
operator|=
name|ffecom_f2c_ftnlen_zero_node
expr_stmt|;
comment|/* We don't have this arg. */
else|else
name|actarg
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|length_tree
expr_stmt|;
operator|*
name|plist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|actarg
argument_list|)
expr_stmt|;
name|plist
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|plist
argument_list|)
expr_stmt|;
block|}
comment|/* Prepend character-value return info to actual arg list. */
if|if
condition|(
name|charfunc
condition|)
block|{
name|prepend
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ffecom_func_result_
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|prepend
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ffecom_func_length_
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|prepend
argument_list|)
argument_list|)
operator|=
name|arglist
expr_stmt|;
name|arglist
operator|=
name|prepend
expr_stmt|;
block|}
comment|/* Prepend multi-type return value to actual arg list. */
if|if
condition|(
name|multi
condition|)
block|{
name|prepend
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|multi_retval
argument_list|)
argument_list|)
argument_list|,
name|multi_retval
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|prepend
argument_list|)
operator|=
name|arglist
expr_stmt|;
name|arglist
operator|=
name|prepend
expr_stmt|;
block|}
comment|/* Prepend my entry-point number to the actual arg list. */
name|prepend
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|entrynum
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|prepend
argument_list|)
operator|=
name|arglist
expr_stmt|;
name|arglist
operator|=
name|prepend
expr_stmt|;
comment|/* Build the call to the master function. */
name|master_fn
operator|=
name|ffecom_1_fn
argument_list|(
name|ffecom_previous_function_decl_
argument_list|)
expr_stmt|;
name|call
operator|=
name|ffecom_3s
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|master_fn
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|master_fn
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Decide whether the master function is a function or subroutine, and        handle the return value for my entry point. */
if|if
condition|(
name|charfunc
operator|||
operator|(
operator|(
name|ffecom_primary_entry_kind_
operator|==
name|FFEINFO_kindSUBROUTINE
operator|)
operator|&&
operator|!
name|altreturning
operator|)
condition|)
block|{
name|expand_expr_stmt
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|multi
operator|&&
name|cmplxfunc
condition|)
block|{
name|expand_expr_stmt
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|result
operator|=
name|ffecom_1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|result
argument_list|,
name|ffecom_2
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|multi_retval
argument_list|,
name|ffecom_multi_fields_
index|[
name|bt
index|]
index|[
name|kt
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|multi
condition|)
block|{
name|expand_expr_stmt
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|result
operator|=
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|result
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|COMPONENT_REF
argument_list|,
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
argument_list|,
name|multi_retval
argument_list|,
name|ffecom_multi_fields_
index|[
name|bt
index|]
index|[
name|kt
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_return
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmplxfunc
condition|)
block|{
name|result
operator|=
name|ffecom_1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|result
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|result
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|call
argument_list|)
argument_list|)
expr_stmt|;
name|expand_return
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
name|ffecom_end_compstmt
argument_list|()
expr_stmt|;
name|finish_function
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|old_lineno
expr_stmt|;
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
name|ffecom_doing_entry_
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transform expr into gcc tree with possible destination     Recursive descent on expr while making corresponding tree nodes and    attaching type info and such.  If destination supplied and compatible    with temporary that would be made in certain cases, temporary isn't    made, destination used instead, and dest_used flag set TRUE.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_expr_
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|tree
name|dest_tree
parameter_list|,
name|ffebld
name|dest
parameter_list|,
name|bool
modifier|*
name|dest_used
parameter_list|,
name|bool
name|assignp
parameter_list|,
name|bool
name|widenp
parameter_list|)
block|{
name|tree
name|item
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|dt
decl_stmt|;
comment|/* decl_tree for an ffesymbol. */
name|tree
name|tree_type
decl_stmt|,
name|tree_type_x
decl_stmt|;
name|tree
name|left
decl_stmt|,
name|right
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|assert
argument_list|(
name|expr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_used
operator|!=
name|NULL
condition|)
operator|*
name|dest_used
operator|=
name|FALSE
expr_stmt|;
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|tree_type
operator|=
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
expr_stmt|;
comment|/* Widen integral arithmetic as desired while preserving signedness.  */
name|tree_type_x
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|widenp
operator|&&
name|tree_type
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|tree_type
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|TYPE_PRECISION
argument_list|(
name|tree_type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
condition|)
name|tree_type_x
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|tree_type
argument_list|)
condition|?
name|usizetype
else|:
name|ssizetype
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opACCTER
case|:
block|{
name|ffebitCount
name|i
decl_stmt|;
name|ffebit
name|bits
init|=
name|ffebld_accter_bits
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|ffetargetOffset
name|source_offset
init|=
literal|0
decl_stmt|;
name|ffetargetOffset
name|dest_offset
init|=
name|ffebld_accter_pad
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|purpose
decl_stmt|;
name|assert
argument_list|(
name|dest_offset
operator|==
literal|0
operator|||
operator|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
operator|&&
name|kt
operator|==
name|FFEINFO_kindtypeCHARACTER1
operator|)
argument_list|)
expr_stmt|;
name|list
operator|=
name|item
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ffebldConstantUnion
name|cu
decl_stmt|;
name|ffebitCount
name|length
decl_stmt|;
name|bool
name|value
decl_stmt|;
name|ffebldConstantArray
name|ca
init|=
name|ffebld_accter
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|ffebit_test
argument_list|(
name|bits
argument_list|,
name|source_offset
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|value
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
name|cu
operator|=
name|ffebld_constantarray_get
argument_list|(
name|ca
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|,
name|source_offset
operator|+
name|i
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_constantunion
argument_list|(
operator|&
name|cu
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|,
name|tree_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|dest_offset
operator|!=
literal|0
condition|)
name|purpose
operator|=
name|build_int_2
argument_list|(
name|dest_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|purpose
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL_TREE
condition|)
name|list
operator|=
name|item
operator|=
name|build_tree_list
argument_list|(
name|purpose
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|purpose
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|item
operator|=
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|source_offset
operator|+=
name|length
expr_stmt|;
name|dest_offset
operator|+=
name|length
expr_stmt|;
block|}
block|}
name|item
operator|=
name|build_int_2
argument_list|(
operator|(
name|ffebld_accter_size
argument_list|(
name|expr
argument_list|)
operator|+
name|ffebld_accter_pad
argument_list|(
name|expr
argument_list|)
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffebit_kill
argument_list|(
name|ffebld_accter_bits
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
operator|=
name|ffecom_integer_type_node
expr_stmt|;
name|item
operator|=
name|build_array_type
argument_list|(
name|tree_type
argument_list|,
name|build_range_type
argument_list|(
name|ffecom_integer_type_node
argument_list|,
name|ffecom_integer_zero_node
argument_list|,
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|item
argument_list|,
name|NULL_TREE
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|list
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|list
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|list
return|;
case|case
name|FFEBLD_opARRTER
case|:
block|{
name|ffetargetOffset
name|i
decl_stmt|;
name|list
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|ffebld_arrter_pad
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
condition|)
name|item
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
operator|&&
name|kt
operator|==
name|FFEINFO_kindtypeCHARACTER1
argument_list|)
expr_stmt|;
comment|/* Becomes PURPOSE first time through loop.  */
name|item
operator|=
name|build_int_2
argument_list|(
name|ffebld_arrter_pad
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ffebld_arrter_size
argument_list|(
name|expr
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|ffebldConstantUnion
name|cu
init|=
name|ffebld_constantarray_get
argument_list|(
name|ffebld_arrter
argument_list|(
name|expr
argument_list|)
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|t
operator|=
name|ffecom_constantunion
argument_list|(
operator|&
name|cu
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|,
name|tree_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL_TREE
condition|)
comment|/* Assume item is PURPOSE first time through loop.  */
name|list
operator|=
name|item
operator|=
name|build_tree_list
argument_list|(
name|item
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|item
operator|=
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|item
operator|=
name|build_int_2
argument_list|(
operator|(
name|ffebld_arrter_size
argument_list|(
name|expr
argument_list|)
operator|+
name|ffebld_arrter_pad
argument_list|(
name|expr
argument_list|)
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
operator|=
name|ffecom_integer_type_node
expr_stmt|;
name|item
operator|=
name|build_array_type
argument_list|(
name|tree_type
argument_list|,
name|build_range_type
argument_list|(
name|ffecom_integer_type_node
argument_list|,
name|ffecom_integer_zero_node
argument_list|,
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|item
argument_list|,
name|NULL_TREE
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|list
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|list
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|list
return|;
case|case
name|FFEBLD_opCONTER
case|:
name|assert
argument_list|(
name|ffebld_conter_pad
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_constantunion
argument_list|(
operator|&
name|ffebld_constant_union
argument_list|(
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|,
name|tree_type
argument_list|)
expr_stmt|;
return|return
name|item
return|;
case|case
name|FFEBLD_opSYMTER
case|:
if|if
condition|(
operator|(
name|ffebld_symter_generic
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEINTRIN_genNONE
operator|)
operator|||
operator|(
name|ffebld_symter_specific
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEINTRIN_specNONE
operator|)
condition|)
return|return
name|ffecom_ptr_to_expr
argument_list|(
name|expr
argument_list|)
return|;
comment|/* Same as %REF(intrinsic). */
name|s
operator|=
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
if|if
condition|(
name|assignp
condition|)
block|{
comment|/* ASSIGN'ed-label expr. */
if|if
condition|(
name|ffe_is_ugly_assign
argument_list|()
condition|)
block|{
comment|/* User explicitly wants ASSIGN'ed variables to be at the same 		 memory address as the variables when used in non-ASSIGN 		 contexts.  That can make old, arcane, non-standard code 		 work, but don't try to do it when a pointer wouldn't fit 		 in the normal variable (take other approach, and warn, 		 instead).  */
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
block|{
name|s
operator|=
name|ffecom_sym_transform_
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|addr
condition|)
name|t
operator|=
name|ffecom_1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|assign_tree
operator|==
name|NULL_TREE
condition|)
block|{
name|ffebad_start_msg
argument_list|(
literal|"ASSIGN'ed label cannot fit into `%A' at %0 -- using wider sibling"
argument_list|,
name|FFEBAD_severityWARNING
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffesymbol_where_line
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where_column
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Don't use the normal variable's tree for ASSIGN, though mark 	     it as in the system header (housekeeping).  Use an explicit, 	     specially created sibling that is known to be wide enough 	     to hold pointers to labels.  */
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't let -Wunused complain. */
name|t
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|assign_tree
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
block|{
name|s
operator|=
name|ffecom_sym_transform_assign_
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|assign_tree
expr_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
block|{
name|s
operator|=
name|ffecom_sym_transform_
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|addr
condition|)
name|t
operator|=
name|ffecom_1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
case|case
name|FFEBLD_opARRAYREF
case|:
return|return
name|ffecom_arrayref_
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|FFEBLD_opUPLUS
case|:
name|left
operator|=
name|ffecom_expr_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|widenp
argument_list|)
expr_stmt|;
return|return
name|ffecom_1
argument_list|(
name|NOP_EXPR
argument_list|,
name|tree_type
argument_list|,
name|left
argument_list|)
return|;
case|case
name|FFEBLD_opPAREN
case|:
comment|/* ~~~Make sure Fortran rules respected here */
name|left
operator|=
name|ffecom_expr_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|widenp
argument_list|)
expr_stmt|;
return|return
name|ffecom_1
argument_list|(
name|NOP_EXPR
argument_list|,
name|tree_type
argument_list|,
name|left
argument_list|)
return|;
case|case
name|FFEBLD_opUMINUS
case|:
name|left
operator|=
name|ffecom_expr_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|widenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_type_x
condition|)
block|{
name|tree_type
operator|=
name|tree_type_x
expr_stmt|;
name|left
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
return|return
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|tree_type
argument_list|,
name|left
argument_list|)
return|;
case|case
name|FFEBLD_opADD
case|:
name|left
operator|=
name|ffecom_expr_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|widenp
argument_list|)
expr_stmt|;
name|right
operator|=
name|ffecom_expr_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|widenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_type_x
condition|)
block|{
name|tree_type
operator|=
name|tree_type_x
expr_stmt|;
name|left
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|right
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
return|return
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|tree_type
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
case|case
name|FFEBLD_opSUBTRACT
case|:
name|left
operator|=
name|ffecom_expr_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|widenp
argument_list|)
expr_stmt|;
name|right
operator|=
name|ffecom_expr_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|widenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_type_x
condition|)
block|{
name|tree_type
operator|=
name|tree_type_x
expr_stmt|;
name|left
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|right
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
return|return
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|tree_type
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
case|case
name|FFEBLD_opMULTIPLY
case|:
name|left
operator|=
name|ffecom_expr_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|widenp
argument_list|)
expr_stmt|;
name|right
operator|=
name|ffecom_expr_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|widenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_type_x
condition|)
block|{
name|tree_type
operator|=
name|tree_type_x
expr_stmt|;
name|left
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|right
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
return|return
name|ffecom_2
argument_list|(
name|MULT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
case|case
name|FFEBLD_opDIVIDE
case|:
name|left
operator|=
name|ffecom_expr_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|widenp
argument_list|)
expr_stmt|;
name|right
operator|=
name|ffecom_expr_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|widenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_type_x
condition|)
block|{
name|tree_type
operator|=
name|tree_type_x
expr_stmt|;
name|left
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|right
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
return|return
name|ffecom_tree_divide_
argument_list|(
name|tree_type
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|dest_tree
argument_list|,
name|dest
argument_list|,
name|dest_used
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
case|case
name|FFEBLD_opPOWER
case|:
block|{
name|ffebld
name|left
init|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|ffebld
name|right
init|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|ffecomGfrt
name|code
decl_stmt|;
name|ffeinfoKindtype
name|rtkt
decl_stmt|;
name|ffeinfoKindtype
name|ltkt
decl_stmt|;
name|bool
name|ref
init|=
name|TRUE
decl_stmt|;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|right
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
if|if
condition|(
literal|1
operator|||
name|optimize
condition|)
block|{
name|item
operator|=
name|ffecom_expr_power_integer_
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|NULL_TREE
condition|)
return|return
name|item
return|;
block|}
name|rtkt
operator|=
name|FFEINFO_kindtypeINTEGER1
expr_stmt|;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|left
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
if|if
condition|(
operator|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|left
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGER4
operator|)
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|right
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGER4
operator|)
condition|)
block|{
name|code
operator|=
name|FFECOM_gfrtPOW_QQ
expr_stmt|;
name|ltkt
operator|=
name|FFEINFO_kindtypeINTEGER4
expr_stmt|;
name|rtkt
operator|=
name|FFEINFO_kindtypeINTEGER4
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|FFECOM_gfrtPOW_II
expr_stmt|;
name|ltkt
operator|=
name|FFEINFO_kindtypeINTEGER1
expr_stmt|;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
if|if
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|left
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeREAL1
condition|)
block|{
name|code
operator|=
name|FFECOM_gfrtPOW_RI
expr_stmt|;
name|ltkt
operator|=
name|FFEINFO_kindtypeREAL1
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|FFECOM_gfrtPOW_DI
expr_stmt|;
name|ltkt
operator|=
name|FFEINFO_kindtypeREAL2
expr_stmt|;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
if|if
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|left
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeREAL1
condition|)
block|{
name|code
operator|=
name|FFECOM_gfrtPOW_CI
expr_stmt|;
comment|/* Overlapping result okay. */
name|ltkt
operator|=
name|FFEINFO_kindtypeREAL1
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|FFECOM_gfrtPOW_ZI
expr_stmt|;
comment|/* Overlapping result okay. */
name|ltkt
operator|=
name|FFEINFO_kindtypeREAL2
expr_stmt|;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad pow_*i"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|FFECOM_gfrtPOW_CI
expr_stmt|;
comment|/* Overlapping result okay. */
name|ltkt
operator|=
name|FFEINFO_kindtypeREAL1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|left
argument_list|)
argument_list|)
operator|!=
name|ltkt
condition|)
name|left
operator|=
name|ffeexpr_convert
argument_list|(
name|left
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|left
argument_list|)
argument_list|)
argument_list|,
name|ltkt
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|right
argument_list|)
argument_list|)
operator|!=
name|rtkt
condition|)
name|right
operator|=
name|ffeexpr_convert
argument_list|(
name|right
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|rtkt
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
if|if
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|left
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeREAL1
condition|)
name|left
operator|=
name|ffeexpr_convert
argument_list|(
name|left
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FFEINFO_basictypeREAL
argument_list|,
name|FFEINFO_kindtypeREALDOUBLE
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|right
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeREAL1
condition|)
name|right
operator|=
name|ffeexpr_convert
argument_list|(
name|right
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FFEINFO_basictypeREAL
argument_list|,
name|FFEINFO_kindtypeREALDOUBLE
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
comment|/* We used to call FFECOM_gfrtPOW_DD here, 	       which passes arguments by reference.  */
name|code
operator|=
name|FFECOM_gfrtL_POW
expr_stmt|;
comment|/* Pass arguments by value. */
name|ref
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
if|if
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|left
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeREAL1
condition|)
name|left
operator|=
name|ffeexpr_convert
argument_list|(
name|left
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FFEINFO_basictypeCOMPLEX
argument_list|,
name|FFEINFO_kindtypeREALDOUBLE
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|right
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeREAL1
condition|)
name|right
operator|=
name|ffeexpr_convert
argument_list|(
name|right
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FFEINFO_basictypeCOMPLEX
argument_list|,
name|FFEINFO_kindtypeREALDOUBLE
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|code
operator|=
name|FFECOM_gfrtPOW_ZZ
expr_stmt|;
comment|/* Overlapping result okay. */
name|ref
operator|=
name|TRUE
expr_stmt|;
comment|/* Pass arguments by reference. */
break|break;
default|default:
name|assert
argument_list|(
literal|"bad pow_x*"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|FFECOM_gfrtPOW_II
expr_stmt|;
break|break;
block|}
return|return
name|ffecom_call_binop_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|code
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|code
argument_list|)
argument_list|,
operator|(
name|ffe_is_f2c_library
argument_list|()
operator|&&
name|ffecom_gfrt_complex_
index|[
name|code
index|]
operator|)
argument_list|,
name|tree_type
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|dest_tree
argument_list|,
name|dest
argument_list|,
name|dest_used
argument_list|,
name|NULL_TREE
argument_list|,
name|FALSE
argument_list|,
name|ref
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
block|}
case|case
name|FFEBLD_opNOT
case|:
switch|switch
condition|(
name|bt
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|item
operator|=
name|ffecom_truth_value_invert
argument_list|(
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|item
argument_list|)
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
return|return
name|ffecom_1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
name|assert
argument_list|(
literal|"NOT bad basictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|error_mark_node
return|;
block|}
break|break;
case|case
name|FFEBLD_opFUNCREF
case|:
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_basictypeCHARACTER
argument_list|)
expr_stmt|;
comment|/* Fall through.	 */
case|case
name|FFEBLD_opSUBRREF
case|:
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FFEINFO_whereINTRINSIC
condition|)
block|{
comment|/* Invocation of an intrinsic. */
name|item
operator|=
name|ffecom_expr_intrinsic_
argument_list|(
name|expr
argument_list|,
name|dest_tree
argument_list|,
name|dest
argument_list|,
name|dest_used
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
name|s
operator|=
name|ffebld_symter
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|dt
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
if|if
condition|(
name|dt
operator|==
name|NULL_TREE
condition|)
block|{
name|s
operator|=
name|ffecom_sym_transform_
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dt
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
block|}
if|if
condition|(
name|dt
operator|==
name|error_mark_node
condition|)
return|return
name|dt
return|;
if|if
condition|(
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|addr
condition|)
name|item
operator|=
name|dt
expr_stmt|;
else|else
name|item
operator|=
name|ffecom_1_fn
argument_list|(
name|dt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereCONSTANT
condition|)
name|args
operator|=
name|ffecom_list_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|args
operator|=
name|ffecom_list_ptr_to_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|item
operator|=
name|ffecom_call_
argument_list|(
name|item
argument_list|,
name|kt
argument_list|,
name|ffesymbol_is_f2c
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
name|bt
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
operator|)
argument_list|,
name|tree_type
argument_list|,
name|args
argument_list|,
name|dest_tree
argument_list|,
name|dest
argument_list|,
name|dest_used
argument_list|,
name|error_mark_node
argument_list|,
name|FALSE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|item
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|item
return|;
case|case
name|FFEBLD_opAND
case|:
switch|switch
condition|(
name|bt
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|item
operator|=
name|ffecom_2
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|item
argument_list|)
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
return|return
name|ffecom_2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
name|assert
argument_list|(
literal|"AND bad basictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|error_mark_node
return|;
block|}
break|break;
case|case
name|FFEBLD_opOR
case|:
switch|switch
condition|(
name|bt
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|item
operator|=
name|ffecom_2
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|item
argument_list|)
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
return|return
name|ffecom_2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
name|assert
argument_list|(
literal|"OR bad basictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|error_mark_node
return|;
block|}
break|break;
case|case
name|FFEBLD_opXOR
case|:
case|case
name|FFEBLD_opNEQV
case|:
switch|switch
condition|(
name|bt
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|item
operator|=
name|ffecom_2
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_truth_value
argument_list|(
name|item
argument_list|)
argument_list|)
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
return|return
name|ffecom_2
argument_list|(
name|BIT_XOR_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
name|assert
argument_list|(
literal|"XOR/NEQV bad basictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|error_mark_node
return|;
block|}
break|break;
case|case
name|FFEBLD_opEQV
case|:
switch|switch
condition|(
name|bt
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|item
operator|=
name|ffecom_2
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_truth_value
argument_list|(
name|item
argument_list|)
argument_list|)
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
return|return
name|ffecom_1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_2
argument_list|(
name|BIT_XOR_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
name|assert
argument_list|(
literal|"EQV bad basictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|error_mark_node
return|;
block|}
break|break;
case|case
name|FFEBLD_opCONVERT
case|:
if|if
condition|(
name|ffebld_op
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|bt
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeREAL
case|:
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeLOGICAL
case|:
case|case
name|FFEINFO_basictypeREAL
case|:
name|item
operator|=
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* convert() takes care of converting to the subtype first, 		 at least in gcc-2.7.2. */
name|item
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|item
argument_list|)
expr_stmt|;
return|return
name|item
return|;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
name|assert
argument_list|(
literal|"CONVERT COMPLEX bad basictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|error_mark_node
return|;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"CONVERT bad basictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|error_mark_node
return|;
block|}
break|break;
case|case
name|FFEBLD_opLT
case|:
name|code
operator|=
name|LT_EXPR
expr_stmt|;
goto|goto
name|relational
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEBLD_opLE
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
goto|goto
name|relational
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEBLD_opEQ
case|:
name|code
operator|=
name|EQ_EXPR
expr_stmt|;
goto|goto
name|relational
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEBLD_opNE
case|:
name|code
operator|=
name|NE_EXPR
expr_stmt|;
goto|goto
name|relational
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEBLD_opGT
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
goto|goto
name|relational
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEBLD_opGE
case|:
name|code
operator|=
name|GE_EXPR
expr_stmt|;
name|relational
label|:
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeREAL
case|:
name|item
operator|=
name|ffecom_2
argument_list|(
name|code
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|item
argument_list|)
return|;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
name|assert
argument_list|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
argument_list|)
expr_stmt|;
block|{
name|tree
name|real_type
decl_stmt|;
name|tree
name|arg1
init|=
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|ffecom_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|arg1
operator|=
name|ffecom_save_tree
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|ffecom_save_tree
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|real_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|real_type
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|real_type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|real_type
operator|==
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|item
operator|=
name|ffecom_2
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|real_type
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|real_type
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|real_type
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|real_type
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
name|item
operator|=
name|ffecom_truth_value
argument_list|(
name|item
argument_list|)
expr_stmt|;
else|else
name|item
operator|=
name|ffecom_truth_value_invert
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|item
argument_list|)
return|;
block|}
case|case
name|FFEINFO_basictypeCHARACTER
case|:
block|{
name|ffebld
name|left
init|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|ffebld
name|right
init|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|left_tree
decl_stmt|;
name|tree
name|right_tree
decl_stmt|;
name|tree
name|left_length
decl_stmt|;
name|tree
name|right_length
decl_stmt|;
comment|/* f2c run-time functions do the implicit blank-padding for us, 	       so we don't usually have to implement blank-padding ourselves. 	       (The exception is when we pass an argument to a separately 	       compiled statement function -- if we know the arg is not the 	       same length as the dummy, we must truncate or extend it.	 If 	       we "inline" statement functions, that necessity goes away as 	       well.)  	       Strip off the CONVERT operators that blank-pad.  (Truncation by 	       CONVERT shouldn't happen here, but it can happen in 	       assignments.) */
while|while
condition|(
name|ffebld_op
argument_list|(
name|left
argument_list|)
operator|==
name|FFEBLD_opCONVERT
condition|)
name|left
operator|=
name|ffebld_left
argument_list|(
name|left
argument_list|)
expr_stmt|;
while|while
condition|(
name|ffebld_op
argument_list|(
name|right
argument_list|)
operator|==
name|FFEBLD_opCONVERT
condition|)
name|right
operator|=
name|ffebld_left
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|left_tree
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|left
argument_list|,
operator|&
name|left_length
argument_list|)
expr_stmt|;
name|right_tree
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|right
argument_list|,
operator|&
name|right_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|left_tree
operator|==
name|error_mark_node
operator|||
name|left_length
operator|==
name|error_mark_node
operator|||
name|right_tree
operator|==
name|error_mark_node
operator|||
name|right_length
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|(
name|ffebld_size_known
argument_list|(
name|left
argument_list|)
operator|==
literal|1
operator|)
operator|&&
operator|(
name|ffebld_size_known
argument_list|(
name|right
argument_list|)
operator|==
literal|1
operator|)
condition|)
block|{
name|left_tree
operator|=
name|ffecom_1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|left_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|left_tree
argument_list|)
expr_stmt|;
name|right_tree
operator|=
name|ffecom_1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|right_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|right_tree
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_2
argument_list|(
name|code
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|ARRAY_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|left_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|left_tree
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|ARRAY_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|right_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|right_tree
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|item
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|left_tree
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|right_tree
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|left_length
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|right_length
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtCMP
argument_list|,
name|item
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_2
argument_list|(
name|code
argument_list|,
name|integer_type_node
argument_list|,
name|item
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|item
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
return|return
name|item
return|;
default|default:
name|assert
argument_list|(
literal|"relational bad basictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|error_mark_node
return|;
block|}
break|break;
case|case
name|FFEBLD_opPERCENT_LOC
case|:
name|item
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|item
argument_list|)
return|;
case|case
name|FFEBLD_opITEM
case|:
case|case
name|FFEBLD_opSTAR
case|:
case|case
name|FFEBLD_opBOUNDS
case|:
case|case
name|FFEBLD_opREPEAT
case|:
case|case
name|FFEBLD_opLABTER
case|:
case|case
name|FFEBLD_opLABTOK
case|:
case|case
name|FFEBLD_opIMPDO
case|:
case|case
name|FFEBLD_opCONCATENATE
case|:
case|case
name|FFEBLD_opSUBSTR
case|:
default|default:
name|assert
argument_list|(
literal|"bad op"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEBLD_opANY
case|:
return|return
name|error_mark_node
return|;
block|}
if|#
directive|if
literal|1
name|assert
argument_list|(
literal|"didn't think anything got here anymore!!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
switch|switch
condition|(
name|ffebld_arity
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
name|TREE_OPERAND
argument_list|(
name|item
argument_list|,
literal|0
argument_list|)
operator|=
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|item
argument_list|,
literal|1
argument_list|)
operator|=
name|ffecom_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|item
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_OPERAND
argument_list|(
name|item
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
break|break;
case|case
literal|1
case|:
name|TREE_OPERAND
argument_list|(
name|item
argument_list|,
literal|0
argument_list|)
operator|=
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|item
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|fold
argument_list|(
name|item
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Returns the tree that does the intrinsic invocation.     Note: this function applies only to intrinsics returning    CHARACTER*1 or non-CHARACTER results, and to intrinsic    subroutines.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_expr_intrinsic_
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|tree
name|dest_tree
parameter_list|,
name|ffebld
name|dest
parameter_list|,
name|bool
modifier|*
name|dest_used
parameter_list|)
block|{
name|tree
name|expr_tree
decl_stmt|;
name|tree
name|saved_expr1
decl_stmt|;
comment|/* For those who need it. */
name|tree
name|saved_expr2
decl_stmt|;
comment|/* For those who need it. */
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|tree
name|tree_type
decl_stmt|;
name|tree
name|arg1_type
decl_stmt|;
name|tree
name|real_type
decl_stmt|;
comment|/* REAL type corresponding to COMPLEX. */
name|tree
name|tempvar
decl_stmt|;
name|ffebld
name|list
init|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
decl_stmt|;
comment|/* List of (some) args. */
name|ffebld
name|arg1
decl_stmt|;
comment|/* For handy reference. */
name|ffebld
name|arg2
decl_stmt|;
name|ffebld
name|arg3
decl_stmt|;
name|ffeintrinImp
name|codegen_imp
decl_stmt|;
name|ffecomGfrt
name|gfrt
decl_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opSYMTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_used
operator|!=
name|NULL
condition|)
operator|*
name|dest_used
operator|=
name|FALSE
expr_stmt|;
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|tree_type
operator|=
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
name|arg1
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|!=
name|NULL
operator|&&
name|ffebld_op
argument_list|(
name|arg1
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|(
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|arg2
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
operator|!=
name|NULL
operator|&&
name|ffebld_op
argument_list|(
name|arg2
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|(
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|arg3
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3
operator|!=
name|NULL
operator|&&
name|ffebld_op
argument_list|(
name|arg3
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
return|return
name|error_mark_node
return|;
block|}
else|else
name|arg3
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|arg2
operator|=
name|arg3
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|arg1
operator|=
name|arg2
operator|=
name|arg3
operator|=
name|NULL
expr_stmt|;
comment|/*<list> ends up at the opITEM of the 3rd arg, or NULL if there are< 3      args.  This is used by the MAX/MIN expansions. */
if|if
condition|(
name|arg1
operator|!=
name|NULL
condition|)
name|arg1_type
operator|=
name|ffecom_tree_type
index|[
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|arg1
argument_list|)
argument_list|)
index|]
index|[
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|arg1
argument_list|)
argument_list|)
index|]
expr_stmt|;
else|else
name|arg1_type
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Really not needed, but might catch bugs 				   here. */
comment|/* There are several ways for each of the cases in the following switch      statements to exit (from simplest to use to most complicated):       break;  (when expr_tree == NULL)       A standard call is made to the specific intrinsic just as if it had been      passed in as a dummy procedure and called as any old procedure.  This      method can produce slower code but in some cases it's the easiest way for      now.  However, if a (presumably faster) direct call is available,      that is used, so this is the easiest way in many more cases now.       gfrt = FFECOM_gfrtWHATEVER;      break;       gfrt contains the gfrt index of a library function to call, passing the      argument(s) by value rather than by reference.  Used when a more      careful choice of library function is needed than that provided      by the vanilla `break;'.       return expr_tree;       The expr_tree has been completely set up and is ready to be returned      as is.  No further actions are taken.  Use this when the tree is not      in the simple form for one of the arity_n labels.	 */
comment|/* For info on how the switch statement cases were written, see the files      enclosed in comments below the switch statement. */
name|codegen_imp
operator|=
name|ffebld_symter_implementation
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|gfrt
operator|=
name|ffeintrin_gfrt_direct
argument_list|(
name|codegen_imp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gfrt
operator|==
name|FFECOM_gfrt
condition|)
name|gfrt
operator|=
name|ffeintrin_gfrt_indirect
argument_list|(
name|codegen_imp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|codegen_imp
condition|)
block|{
case|case
name|FFEINTRIN_impABS
case|:
case|case
name|FFEINTRIN_impCABS
case|:
case|case
name|FFEINTRIN_impCDABS
case|:
case|case
name|FFEINTRIN_impDABS
case|:
case|case
name|FFEINTRIN_impIABS
case|:
if|if
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeCOMPLEX
condition|)
block|{
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL1
condition|)
name|gfrt
operator|=
name|FFECOM_gfrtCABS
expr_stmt|;
elseif|else
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL2
condition|)
name|gfrt
operator|=
name|FFECOM_gfrtCDABS
expr_stmt|;
break|break;
block|}
return|return
name|ffecom_1
argument_list|(
name|ABS_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impACOS
case|:
case|case
name|FFEINTRIN_impDACOS
case|:
break|break;
case|case
name|FFEINTRIN_impAIMAG
case|:
case|case
name|FFEINTRIN_impDIMAG
case|:
case|case
name|FFEINTRIN_impIMAGPART
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1_type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|arg1_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg1_type
argument_list|)
expr_stmt|;
else|else
name|arg1_type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|arg1_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|arg1_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impAINT
case|:
case|case
name|FFEINTRIN_impDINT
case|:
if|#
directive|if
literal|0
comment|/* ~~Someday implement FIX_TRUNC_EXPR yielding same type as arg.  */
block|return ffecom_1 (FIX_TRUNC_EXPR, tree_type, ffecom_expr (arg1));
else|#
directive|else
comment|/* in the meantime, must use floor to avoid range problems with ints */
comment|/* r__1 = r1>= 0 ? floor(r1) : -floor(-r1); */
name|saved_expr1
operator|=
name|ffecom_save_tree
argument_list|(
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|double_type_node
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|GE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|saved_expr1
argument_list|,
name|convert
argument_list|(
name|arg1_type
argument_list|,
name|ffecom_float_zero_
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtL_FLOOR
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|saved_expr1
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|double_type_node
argument_list|,
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtL_FLOOR
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|arg1_type
argument_list|,
name|saved_expr1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
case|case
name|FFEINTRIN_impANINT
case|:
case|case
name|FFEINTRIN_impDNINT
case|:
if|#
directive|if
literal|0
comment|/* This way of doing it won't handle real 				   numbers of large magnitudes. */
block|saved_expr1 = ffecom_save_tree (ffecom_expr (arg1));       expr_tree = convert (tree_type, 			   convert (integer_type_node, 				    ffecom_3 (COND_EXPR, tree_type, 					      ffecom_truth_value 					      (ffecom_2 (GE_EXPR, 							 integer_type_node, 							 saved_expr1, 						       ffecom_float_zero_)), 					      ffecom_2 (PLUS_EXPR, 							tree_type, 							saved_expr1, 							ffecom_float_half_), 					      ffecom_2 (MINUS_EXPR, 							tree_type, 							saved_expr1, 						     ffecom_float_half_))));       return expr_tree;
else|#
directive|else
comment|/* So we instead call floor. */
comment|/* r__1 = r1>= 0 ? floor(r1 + .5) : -floor(.5 - r1) */
name|saved_expr1
operator|=
name|ffecom_save_tree
argument_list|(
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|double_type_node
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|GE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|saved_expr1
argument_list|,
name|convert
argument_list|(
name|arg1_type
argument_list|,
name|ffecom_float_zero_
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtL_FLOOR
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg1_type
argument_list|,
name|saved_expr1
argument_list|,
name|convert
argument_list|(
name|arg1_type
argument_list|,
name|ffecom_float_half_
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|double_type_node
argument_list|,
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtL_FLOOR
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1_type
argument_list|,
name|convert
argument_list|(
name|arg1_type
argument_list|,
name|ffecom_float_half_
argument_list|)
argument_list|,
name|saved_expr1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
case|case
name|FFEINTRIN_impASIN
case|:
case|case
name|FFEINTRIN_impDASIN
case|:
case|case
name|FFEINTRIN_impATAN
case|:
case|case
name|FFEINTRIN_impDATAN
case|:
case|case
name|FFEINTRIN_impATAN2
case|:
case|case
name|FFEINTRIN_impDATAN2
case|:
break|break;
case|case
name|FFEINTRIN_impCHAR
case|:
case|case
name|FFEINTRIN_impACHAR
case|:
ifdef|#
directive|ifdef
name|HOHO
name|tempvar
operator|=
name|ffecom_make_tempvar
argument_list|(
name|char_type_node
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|tempvar
operator|=
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tempvar
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|{
name|tree
name|tmv
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tempvar
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|expr_tree
operator|=
name|ffecom_modify
argument_list|(
name|tmv
argument_list|,
name|ffecom_2
argument_list|(
name|ARRAY_REF
argument_list|,
name|tmv
argument_list|,
name|tempvar
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|convert
argument_list|(
name|tmv
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expr_tree
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tempvar
argument_list|)
argument_list|,
name|expr_tree
argument_list|,
name|tempvar
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr_tree
argument_list|)
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
expr_stmt|;
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impCMPLX
case|:
case|case
name|FFEINTRIN_impDCMPLX
case|:
if|if
condition|(
name|arg2
operator|==
name|NULL
condition|)
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
name|real_type
operator|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeREAL
index|]
index|[
name|kt
index|]
expr_stmt|;
return|return
name|ffecom_2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|real_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|real_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impCOMPLEX
case|:
return|return
name|ffecom_2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impCONJG
case|:
case|case
name|FFEINTRIN_impDCONJG
case|:
block|{
name|tree
name|arg1_tree
decl_stmt|;
name|real_type
operator|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeREAL
index|]
index|[
name|kt
index|]
expr_stmt|;
name|arg1_tree
operator|=
name|ffecom_save_tree
argument_list|(
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ffecom_2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|real_type
argument_list|,
name|arg1_tree
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|real_type
argument_list|,
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|real_type
argument_list|,
name|arg1_tree
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
case|case
name|FFEINTRIN_impCOS
case|:
case|case
name|FFEINTRIN_impCCOS
case|:
case|case
name|FFEINTRIN_impCDCOS
case|:
case|case
name|FFEINTRIN_impDCOS
case|:
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCOMPLEX
condition|)
block|{
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL1
condition|)
name|gfrt
operator|=
name|FFECOM_gfrtCCOS
expr_stmt|;
comment|/* Overlapping result okay. */
elseif|else
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL2
condition|)
name|gfrt
operator|=
name|FFECOM_gfrtCDCOS
expr_stmt|;
comment|/* Overlapping result okay. */
block|}
break|break;
case|case
name|FFEINTRIN_impCOSH
case|:
case|case
name|FFEINTRIN_impDCOSH
case|:
break|break;
case|case
name|FFEINTRIN_impDBLE
case|:
case|case
name|FFEINTRIN_impDFLOAT
case|:
case|case
name|FFEINTRIN_impDREAL
case|:
case|case
name|FFEINTRIN_impFLOAT
case|:
case|case
name|FFEINTRIN_impIDINT
case|:
case|case
name|FFEINTRIN_impIFIX
case|:
case|case
name|FFEINTRIN_impINT2
case|:
case|case
name|FFEINTRIN_impINT8
case|:
case|case
name|FFEINTRIN_impINT
case|:
case|case
name|FFEINTRIN_impLONG
case|:
case|case
name|FFEINTRIN_impREAL
case|:
case|case
name|FFEINTRIN_impSHORT
case|:
case|case
name|FFEINTRIN_impSNGL
case|:
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impDIM
case|:
case|case
name|FFEINTRIN_impDDIM
case|:
case|case
name|FFEINTRIN_impIDIM
case|:
name|saved_expr1
operator|=
name|ffecom_save_tree
argument_list|(
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|saved_expr2
operator|=
name|ffecom_save_tree
argument_list|(
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|GT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|saved_expr1
argument_list|,
name|saved_expr2
argument_list|)
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|tree_type
argument_list|,
name|saved_expr1
argument_list|,
name|saved_expr2
argument_list|)
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_float_zero_
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impDPROD
case|:
return|return
name|ffecom_2
argument_list|(
name|MULT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impEXP
case|:
case|case
name|FFEINTRIN_impCDEXP
case|:
case|case
name|FFEINTRIN_impCEXP
case|:
case|case
name|FFEINTRIN_impDEXP
case|:
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCOMPLEX
condition|)
block|{
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL1
condition|)
name|gfrt
operator|=
name|FFECOM_gfrtCEXP
expr_stmt|;
comment|/* Overlapping result okay. */
elseif|else
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL2
condition|)
name|gfrt
operator|=
name|FFECOM_gfrtCDEXP
expr_stmt|;
comment|/* Overlapping result okay. */
block|}
break|break;
case|case
name|FFEINTRIN_impICHAR
case|:
case|case
name|FFEINTRIN_impIACHAR
case|:
if|#
directive|if
literal|0
comment|/* The simple approach. */
block|ffecom_char_args_ (&expr_tree,&saved_expr1
comment|/* Ignored */
block|, arg1);       expr_tree 	= ffecom_1 (INDIRECT_REF, 		    TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (expr_tree))), 		    expr_tree);       expr_tree 	= ffecom_2 (ARRAY_REF, 		    TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (expr_tree))), 		    expr_tree, 		    integer_one_node);       return convert (tree_type, expr_tree);
else|#
directive|else
comment|/* The more interesting (and more optimal) approach. */
name|expr_tree
operator|=
name|ffecom_intrinsic_ichar_
argument_list|(
name|tree_type
argument_list|,
name|arg1
argument_list|,
operator|&
name|saved_expr1
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|saved_expr1
argument_list|,
name|expr_tree
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expr_tree
return|;
endif|#
directive|endif
case|case
name|FFEINTRIN_impINDEX
case|:
break|break;
case|case
name|FFEINTRIN_impLEN
case|:
if|#
directive|if
literal|0
block|break;
comment|/* The simple approach. */
else|#
directive|else
return|return
name|ffecom_intrinsic_len_
argument_list|(
name|arg1
argument_list|)
return|;
comment|/* The more optimal approach. */
endif|#
directive|endif
case|case
name|FFEINTRIN_impLGE
case|:
case|case
name|FFEINTRIN_impLGT
case|:
case|case
name|FFEINTRIN_impLLE
case|:
case|case
name|FFEINTRIN_impLLT
case|:
break|break;
case|case
name|FFEINTRIN_impLOG
case|:
case|case
name|FFEINTRIN_impALOG
case|:
case|case
name|FFEINTRIN_impCDLOG
case|:
case|case
name|FFEINTRIN_impCLOG
case|:
case|case
name|FFEINTRIN_impDLOG
case|:
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCOMPLEX
condition|)
block|{
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL1
condition|)
name|gfrt
operator|=
name|FFECOM_gfrtCLOG
expr_stmt|;
comment|/* Overlapping result okay. */
elseif|else
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL2
condition|)
name|gfrt
operator|=
name|FFECOM_gfrtCDLOG
expr_stmt|;
comment|/* Overlapping result okay. */
block|}
break|break;
case|case
name|FFEINTRIN_impLOG10
case|:
case|case
name|FFEINTRIN_impALOG10
case|:
case|case
name|FFEINTRIN_impDLOG10
case|:
if|if
condition|(
name|gfrt
operator|!=
name|FFECOM_gfrt
condition|)
break|break;
comment|/* Already picked one, stick with it. */
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL1
condition|)
comment|/* We used to call FFECOM_gfrtALOG10 here.  */
name|gfrt
operator|=
name|FFECOM_gfrtL_LOG10
expr_stmt|;
elseif|else
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL2
condition|)
comment|/* We used to call FFECOM_gfrtDLOG10 here.  */
name|gfrt
operator|=
name|FFECOM_gfrtL_LOG10
expr_stmt|;
break|break;
case|case
name|FFEINTRIN_impMAX
case|:
case|case
name|FFEINTRIN_impAMAX0
case|:
case|case
name|FFEINTRIN_impAMAX1
case|:
case|case
name|FFEINTRIN_impDMAX1
case|:
case|case
name|FFEINTRIN_impMAX0
case|:
case|case
name|FFEINTRIN_impMAX1
case|:
if|if
condition|(
name|bt
operator|!=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|arg1_type
operator|=
name|ffecom_widest_expr_type_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|arg1_type
operator|=
name|tree_type
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_2
argument_list|(
name|MAX_EXPR
argument_list|,
name|arg1_type
argument_list|,
name|convert
argument_list|(
name|arg1_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|arg1_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|ffebld_head
argument_list|(
name|list
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|ffebld_head
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
condition|)
continue|continue;
name|expr_tree
operator|=
name|ffecom_2
argument_list|(
name|MAX_EXPR
argument_list|,
name|arg1_type
argument_list|,
name|expr_tree
argument_list|,
name|convert
argument_list|(
name|arg1_type
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_head
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|expr_tree
argument_list|)
return|;
case|case
name|FFEINTRIN_impMIN
case|:
case|case
name|FFEINTRIN_impAMIN0
case|:
case|case
name|FFEINTRIN_impAMIN1
case|:
case|case
name|FFEINTRIN_impDMIN1
case|:
case|case
name|FFEINTRIN_impMIN0
case|:
case|case
name|FFEINTRIN_impMIN1
case|:
if|if
condition|(
name|bt
operator|!=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|arg1_type
operator|=
name|ffecom_widest_expr_type_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|arg1_type
operator|=
name|tree_type
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_2
argument_list|(
name|MIN_EXPR
argument_list|,
name|arg1_type
argument_list|,
name|convert
argument_list|(
name|arg1_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|arg1_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|ffebld_head
argument_list|(
name|list
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|ffebld_head
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
condition|)
continue|continue;
name|expr_tree
operator|=
name|ffecom_2
argument_list|(
name|MIN_EXPR
argument_list|,
name|arg1_type
argument_list|,
name|expr_tree
argument_list|,
name|convert
argument_list|(
name|arg1_type
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_head
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|expr_tree
argument_list|)
return|;
case|case
name|FFEINTRIN_impMOD
case|:
case|case
name|FFEINTRIN_impAMOD
case|:
case|case
name|FFEINTRIN_impDMOD
case|:
if|if
condition|(
name|bt
operator|!=
name|FFEINFO_basictypeREAL
condition|)
return|return
name|ffecom_2
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL1
condition|)
comment|/* We used to call FFECOM_gfrtAMOD here.  */
name|gfrt
operator|=
name|FFECOM_gfrtL_FMOD
expr_stmt|;
elseif|else
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL2
condition|)
comment|/* We used to call FFECOM_gfrtDMOD here.  */
name|gfrt
operator|=
name|FFECOM_gfrtL_FMOD
expr_stmt|;
break|break;
case|case
name|FFEINTRIN_impNINT
case|:
case|case
name|FFEINTRIN_impIDNINT
case|:
if|#
directive|if
literal|0
comment|/* ~~Ideally FIX_ROUND_EXPR would be implemented, but it ain't yet.  */
block|return ffecom_1 (FIX_ROUND_EXPR, tree_type, ffecom_expr (arg1));
else|#
directive|else
comment|/* i__1 = r1>= 0 ? floor(r1 + .5) : -floor(.5 - r1); */
name|saved_expr1
operator|=
name|ffecom_save_tree
argument_list|(
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|ffecom_integer_type_node
argument_list|,
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|arg1_type
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|GE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|saved_expr1
argument_list|,
name|convert
argument_list|(
name|arg1_type
argument_list|,
name|ffecom_float_zero_
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg1_type
argument_list|,
name|saved_expr1
argument_list|,
name|convert
argument_list|(
name|arg1_type
argument_list|,
name|ffecom_float_half_
argument_list|)
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1_type
argument_list|,
name|saved_expr1
argument_list|,
name|convert
argument_list|(
name|arg1_type
argument_list|,
name|ffecom_float_half_
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
case|case
name|FFEINTRIN_impSIGN
case|:
case|case
name|FFEINTRIN_impDSIGN
case|:
case|case
name|FFEINTRIN_impISIGN
case|:
block|{
name|tree
name|arg2_tree
init|=
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|saved_expr1
operator|=
name|ffecom_save_tree
argument_list|(
name|ffecom_1
argument_list|(
name|ABS_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|GE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg2_tree
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2_tree
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|saved_expr1
argument_list|,
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|tree_type
argument_list|,
name|saved_expr1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure SAVE_EXPRs get referenced early enough. */
name|expr_tree
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|saved_expr1
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impSIN
case|:
case|case
name|FFEINTRIN_impCDSIN
case|:
case|case
name|FFEINTRIN_impCSIN
case|:
case|case
name|FFEINTRIN_impDSIN
case|:
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCOMPLEX
condition|)
block|{
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL1
condition|)
name|gfrt
operator|=
name|FFECOM_gfrtCSIN
expr_stmt|;
comment|/* Overlapping result okay. */
elseif|else
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL2
condition|)
name|gfrt
operator|=
name|FFECOM_gfrtCDSIN
expr_stmt|;
comment|/* Overlapping result okay. */
block|}
break|break;
case|case
name|FFEINTRIN_impSINH
case|:
case|case
name|FFEINTRIN_impDSINH
case|:
break|break;
case|case
name|FFEINTRIN_impSQRT
case|:
case|case
name|FFEINTRIN_impCDSQRT
case|:
case|case
name|FFEINTRIN_impCSQRT
case|:
case|case
name|FFEINTRIN_impDSQRT
case|:
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCOMPLEX
condition|)
block|{
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL1
condition|)
name|gfrt
operator|=
name|FFECOM_gfrtCSQRT
expr_stmt|;
comment|/* Overlapping result okay. */
elseif|else
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeREAL2
condition|)
name|gfrt
operator|=
name|FFECOM_gfrtCDSQRT
expr_stmt|;
comment|/* Overlapping result okay. */
block|}
break|break;
case|case
name|FFEINTRIN_impTAN
case|:
case|case
name|FFEINTRIN_impDTAN
case|:
case|case
name|FFEINTRIN_impTANH
case|:
case|case
name|FFEINTRIN_impDTANH
case|:
break|break;
case|case
name|FFEINTRIN_impREALPART
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1_type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|arg1_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg1_type
argument_list|)
expr_stmt|;
else|else
name|arg1_type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|arg1_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|arg1_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impIAND
case|:
case|case
name|FFEINTRIN_impAND
case|:
return|return
name|ffecom_2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impIOR
case|:
case|case
name|FFEINTRIN_impOR
case|:
return|return
name|ffecom_2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impIEOR
case|:
case|case
name|FFEINTRIN_impXOR
case|:
return|return
name|ffecom_2
argument_list|(
name|BIT_XOR_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impLSHIFT
case|:
return|return
name|ffecom_2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impRSHIFT
case|:
return|return
name|ffecom_2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impNOT
case|:
return|return
name|ffecom_1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impBIT_SIZE
case|:
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|TYPE_SIZE
argument_list|(
name|arg1_type
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impBTEST
case|:
block|{
name|ffetargetLogical1
name|target_true
decl_stmt|;
name|ffetargetLogical1
name|target_false
decl_stmt|;
name|tree
name|true_tree
decl_stmt|;
name|tree
name|false_tree
decl_stmt|;
name|ffetarget_logical1
argument_list|(
operator|&
name|target_true
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ffetarget_logical1
argument_list|(
operator|&
name|target_false
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_true
operator|==
literal|1
condition|)
name|true_tree
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
else|else
name|true_tree
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|build_int_2
argument_list|(
name|target_true
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_false
operator|==
literal|0
condition|)
name|false_tree
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
else|else
name|false_tree
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|build_int_2
argument_list|(
name|target_false
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|arg1_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|arg1_type
argument_list|,
name|convert
argument_list|(
name|arg1_type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|arg1_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|false_tree
argument_list|,
name|true_tree
argument_list|)
return|;
block|}
case|case
name|FFEINTRIN_impIBCLR
case|:
return|return
name|ffecom_2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impIBITS
case|:
block|{
name|tree
name|arg3_tree
init|=
name|ffecom_save_tree
argument_list|(
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg3
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|uns_type
init|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeHOLLERITH
index|]
index|[
name|kt
index|]
decl_stmt|;
name|expr_tree
operator|=
name|ffecom_2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|uns_type
argument_list|,
name|ffecom_1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|uns_type
argument_list|,
name|convert
argument_list|(
name|uns_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TYPE_SIZE
argument_list|(
name|uns_type
argument_list|)
argument_list|,
name|arg3_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fix up, because the RSHIFT_EXPR above can't shift over TYPE_SIZE.  */
name|expr_tree
operator|=
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg3_tree
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|,
name|expr_tree
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impIBSET
case|:
return|return
name|ffecom_2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impISHFT
case|:
block|{
name|tree
name|arg1_tree
init|=
name|ffecom_save_tree
argument_list|(
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg2_tree
init|=
name|ffecom_save_tree
argument_list|(
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|uns_type
init|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeHOLLERITH
index|]
index|[
name|kt
index|]
decl_stmt|;
name|expr_tree
operator|=
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|GE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg2_tree
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|arg1_tree
argument_list|,
name|arg2_tree
argument_list|)
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|uns_type
argument_list|,
name|convert
argument_list|(
name|uns_type
argument_list|,
name|arg1_tree
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg2_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fix up, because {L|R}SHIFT_EXPR don't go over TYPE_SIZE bounds.  */
name|expr_tree
operator|=
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_1
argument_list|(
name|ABS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg2_tree
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|uns_type
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|expr_tree
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure SAVE_EXPRs get referenced early enough. */
name|expr_tree
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|arg1_tree
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|arg2_tree
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impISHFTC
case|:
block|{
name|tree
name|arg1_tree
init|=
name|ffecom_save_tree
argument_list|(
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg2_tree
init|=
name|ffecom_save_tree
argument_list|(
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg3_tree
init|=
operator|(
name|arg3
operator|==
name|NULL
operator|)
condition|?
name|TYPE_SIZE
argument_list|(
name|tree_type
argument_list|)
else|:
name|ffecom_save_tree
argument_list|(
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg3
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|shift_neg
decl_stmt|;
name|tree
name|shift_pos
decl_stmt|;
name|tree
name|mask_arg1
decl_stmt|;
name|tree
name|masked_arg1
decl_stmt|;
name|tree
name|uns_type
init|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeHOLLERITH
index|]
index|[
name|kt
index|]
decl_stmt|;
name|mask_arg1
operator|=
name|ffecom_2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|,
name|arg3_tree
argument_list|)
expr_stmt|;
comment|/* Fix up, because LSHIFT_EXPR above can't shift over TYPE_SIZE.  */
name|mask_arg1
operator|=
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg3_tree
argument_list|,
name|TYPE_SIZE
argument_list|(
name|uns_type
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|mask_arg1
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|mask_arg1
operator|=
name|ffecom_save_tree
argument_list|(
name|mask_arg1
argument_list|)
expr_stmt|;
name|masked_arg1
operator|=
name|ffecom_2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|arg1_tree
argument_list|,
name|ffecom_1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|mask_arg1
argument_list|)
argument_list|)
expr_stmt|;
name|masked_arg1
operator|=
name|ffecom_save_tree
argument_list|(
name|masked_arg1
argument_list|)
expr_stmt|;
name|shift_neg
operator|=
name|ffecom_2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|uns_type
argument_list|,
name|convert
argument_list|(
name|uns_type
argument_list|,
name|masked_arg1
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg2_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|arg1_tree
argument_list|,
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg2_tree
argument_list|,
name|arg3_tree
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|shift_pos
operator|=
name|ffecom_2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|arg1_tree
argument_list|,
name|arg2_tree
argument_list|)
argument_list|,
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|uns_type
argument_list|,
name|convert
argument_list|(
name|uns_type
argument_list|,
name|masked_arg1
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg3_tree
argument_list|,
name|arg2_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg2_tree
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|,
name|shift_neg
argument_list|,
name|shift_pos
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|mask_arg1
argument_list|,
name|arg1_tree
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|tree_type
argument_list|,
name|mask_arg1
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_1
argument_list|(
name|ABS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg2_tree
argument_list|)
argument_list|,
name|arg3_tree
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg2_tree
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|arg1_tree
argument_list|,
name|expr_tree
argument_list|)
expr_stmt|;
comment|/* Make sure SAVE_EXPRs get referenced early enough. */
name|expr_tree
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|arg1_tree
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|arg2_tree
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|mask_arg1
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|masked_arg1
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|arg3_tree
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impLOC
case|:
block|{
name|tree
name|arg1_tree
init|=
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|expr_tree
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1_tree
argument_list|)
argument_list|)
argument_list|,
name|arg1_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impMVBITS
case|:
block|{
name|tree
name|arg1_tree
decl_stmt|;
name|tree
name|arg2_tree
decl_stmt|;
name|tree
name|arg3_tree
decl_stmt|;
name|ffebld
name|arg4
init|=
name|ffebld_head
argument_list|(
name|ffebld_trail
argument_list|(
name|list
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg4_tree
decl_stmt|;
name|tree
name|arg4_type
decl_stmt|;
name|ffebld
name|arg5
init|=
name|ffebld_head
argument_list|(
name|ffebld_trail
argument_list|(
name|ffebld_trail
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg5_tree
decl_stmt|;
name|tree
name|prep_arg1
decl_stmt|;
name|tree
name|prep_arg4
decl_stmt|;
name|tree
name|arg5_plus_arg3
decl_stmt|;
name|arg2_tree
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
name|arg3_tree
operator|=
name|ffecom_save_tree
argument_list|(
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arg4_tree
operator|=
name|ffecom_expr_rw
argument_list|(
name|NULL_TREE
argument_list|,
name|arg4
argument_list|)
expr_stmt|;
name|arg4_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg4_tree
argument_list|)
expr_stmt|;
name|arg1_tree
operator|=
name|ffecom_save_tree
argument_list|(
name|convert
argument_list|(
name|arg4_type
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arg5_tree
operator|=
name|ffecom_save_tree
argument_list|(
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg5
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|prep_arg1
operator|=
name|ffecom_2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|ffecom_2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|ffecom_2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|arg1_tree
argument_list|,
name|arg2_tree
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|ffecom_2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|ffecom_1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|convert
argument_list|(
name|arg4_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|,
name|arg3_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|arg5_tree
argument_list|)
expr_stmt|;
name|arg5_plus_arg3
operator|=
name|ffecom_save_tree
argument_list|(
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|arg5_tree
argument_list|,
name|arg3_tree
argument_list|)
argument_list|)
expr_stmt|;
name|prep_arg4
operator|=
name|ffecom_2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|ffecom_1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|convert
argument_list|(
name|arg4_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|,
name|arg5_plus_arg3
argument_list|)
expr_stmt|;
comment|/* Fix up, because LSHIFT_EXPR above can't shift over TYPE_SIZE.  */
name|prep_arg4
operator|=
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg5_plus_arg3
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg5_plus_arg3
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|arg4_type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|prep_arg4
argument_list|,
name|convert
argument_list|(
name|arg4_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|prep_arg4
operator|=
name|ffecom_2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|arg4_tree
argument_list|,
name|ffecom_2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|prep_arg4
argument_list|,
name|ffecom_1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|ffecom_2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|ffecom_1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|convert
argument_list|(
name|arg4_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|,
name|arg5_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|prep_arg1
operator|=
name|ffecom_2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|prep_arg1
argument_list|,
name|prep_arg4
argument_list|)
expr_stmt|;
comment|/* Fix up (twice), because LSHIFT_EXPR above 	   can't shift over TYPE_SIZE.  */
name|prep_arg1
operator|=
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg3_tree
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3_tree
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|prep_arg1
argument_list|,
name|arg4_tree
argument_list|)
expr_stmt|;
name|prep_arg1
operator|=
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|arg4_type
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg3_tree
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3_tree
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|arg4_type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|prep_arg1
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_2s
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|arg4_tree
argument_list|,
name|prep_arg1
argument_list|)
expr_stmt|;
comment|/* Make sure SAVE_EXPRs get referenced early enough. */
name|expr_tree
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|arg1_tree
argument_list|,
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|arg3_tree
argument_list|,
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|arg5_tree
argument_list|,
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|arg5_plus_arg3
argument_list|,
name|expr_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|arg4_tree
argument_list|,
name|expr_tree
argument_list|)
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impDERF
case|:
case|case
name|FFEINTRIN_impERF
case|:
case|case
name|FFEINTRIN_impDERFC
case|:
case|case
name|FFEINTRIN_impERFC
case|:
break|break;
case|case
name|FFEINTRIN_impIARGC
case|:
comment|/* extern int xargc; i__1 = xargc - 1; */
name|expr_tree
operator|=
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ffecom_tree_xargc_
argument_list|)
argument_list|,
name|ffecom_tree_xargc_
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|ffecom_tree_xargc_
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impSIGNAL_func
case|:
case|case
name|FFEINTRIN_impSIGNAL_subr
case|:
block|{
name|tree
name|arg1_tree
decl_stmt|;
name|tree
name|arg2_tree
decl_stmt|;
name|tree
name|arg3_tree
decl_stmt|;
name|arg1_tree
operator|=
name|convert
argument_list|(
name|ffecom_f2c_integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|arg1_tree
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1_tree
argument_list|)
argument_list|)
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
comment|/* Pass procedure as a pointer to it, anything else by value.  */
if|if
condition|(
name|ffeinfo_kind
argument_list|(
name|ffebld_info
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindENTITY
condition|)
name|arg2_tree
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|arg2_tree
operator|=
name|ffecom_ptr_to_expr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|,
name|arg2_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3
operator|!=
name|NULL
condition|)
name|arg3_tree
operator|=
name|ffecom_expr_w
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
else|else
name|arg3_tree
operator|=
name|NULL_TREE
expr_stmt|;
name|arg1_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2_tree
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg1_tree
argument_list|)
operator|=
name|arg2_tree
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|FALSE
argument_list|,
operator|(
operator|(
name|codegen_imp
operator|==
name|FFEINTRIN_impSIGNAL_subr
operator|)
condition|?
name|NULL_TREE
else|:
name|tree_type
operator|)
argument_list|,
name|arg1_tree
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3_tree
operator|!=
name|NULL_TREE
condition|)
name|expr_tree
operator|=
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3_tree
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3_tree
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impALARM
case|:
block|{
name|tree
name|arg1_tree
decl_stmt|;
name|tree
name|arg2_tree
decl_stmt|;
name|tree
name|arg3_tree
decl_stmt|;
name|arg1_tree
operator|=
name|convert
argument_list|(
name|ffecom_f2c_integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|arg1_tree
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1_tree
argument_list|)
argument_list|)
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
comment|/* Pass procedure as a pointer to it, anything else by value.  */
if|if
condition|(
name|ffeinfo_kind
argument_list|(
name|ffebld_info
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindENTITY
condition|)
name|arg2_tree
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|arg2_tree
operator|=
name|ffecom_ptr_to_expr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|,
name|arg2_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3
operator|!=
name|NULL
condition|)
name|arg3_tree
operator|=
name|ffecom_expr_w
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
else|else
name|arg3_tree
operator|=
name|NULL_TREE
expr_stmt|;
name|arg1_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2_tree
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg1_tree
argument_list|)
operator|=
name|arg2_tree
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3_tree
operator|!=
name|NULL_TREE
condition|)
name|expr_tree
operator|=
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3_tree
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3_tree
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impCHDIR_subr
case|:
case|case
name|FFEINTRIN_impFDATE_subr
case|:
case|case
name|FFEINTRIN_impFGET_subr
case|:
case|case
name|FFEINTRIN_impFPUT_subr
case|:
case|case
name|FFEINTRIN_impGETCWD_subr
case|:
case|case
name|FFEINTRIN_impHOSTNM_subr
case|:
case|case
name|FFEINTRIN_impSYSTEM_subr
case|:
case|case
name|FFEINTRIN_impUNLINK_subr
case|:
block|{
name|tree
name|arg1_len
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|arg1_tree
decl_stmt|;
name|tree
name|arg2_tree
decl_stmt|;
name|arg1_tree
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|arg1
argument_list|,
operator|&
name|arg1_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
operator|!=
name|NULL
condition|)
name|arg2_tree
operator|=
name|ffecom_expr_w
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
else|else
name|arg2_tree
operator|=
name|NULL_TREE
expr_stmt|;
name|arg1_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|arg1_len
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_len
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg1_tree
argument_list|)
operator|=
name|arg1_len
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2_tree
operator|!=
name|NULL_TREE
condition|)
name|expr_tree
operator|=
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2_tree
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2_tree
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impEXIT
case|:
if|if
condition|(
name|arg1
operator|!=
name|NULL
condition|)
break|break;
name|expr_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|ffecom_integer_type_node
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|void_type_node
argument_list|,
name|expr_tree
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
case|case
name|FFEINTRIN_impFLUSH
case|:
if|if
condition|(
name|arg1
operator|==
name|NULL
condition|)
name|gfrt
operator|=
name|FFECOM_gfrtFLUSH
expr_stmt|;
else|else
name|gfrt
operator|=
name|FFECOM_gfrtFLUSH1
expr_stmt|;
break|break;
case|case
name|FFEINTRIN_impCHMOD_subr
case|:
case|case
name|FFEINTRIN_impLINK_subr
case|:
case|case
name|FFEINTRIN_impRENAME_subr
case|:
case|case
name|FFEINTRIN_impSYMLNK_subr
case|:
block|{
name|tree
name|arg1_len
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|arg1_tree
decl_stmt|;
name|tree
name|arg2_len
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|arg2_tree
decl_stmt|;
name|tree
name|arg3_tree
decl_stmt|;
name|arg1_tree
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|arg1
argument_list|,
operator|&
name|arg1_len
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|arg2
argument_list|,
operator|&
name|arg2_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3
operator|!=
name|NULL
condition|)
name|arg3_tree
operator|=
name|ffecom_expr_w
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
else|else
name|arg3_tree
operator|=
name|NULL_TREE
expr_stmt|;
name|arg1_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|arg1_len
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_len
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2_tree
argument_list|)
expr_stmt|;
name|arg2_len
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2_len
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg1_tree
argument_list|)
operator|=
name|arg2_tree
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg2_tree
argument_list|)
operator|=
name|arg1_len
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg1_len
argument_list|)
operator|=
name|arg2_len
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3_tree
operator|!=
name|NULL_TREE
condition|)
name|expr_tree
operator|=
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3_tree
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3_tree
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impLSTAT_subr
case|:
case|case
name|FFEINTRIN_impSTAT_subr
case|:
block|{
name|tree
name|arg1_len
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|arg1_tree
decl_stmt|;
name|tree
name|arg2_tree
decl_stmt|;
name|tree
name|arg3_tree
decl_stmt|;
name|arg1_tree
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|arg1
argument_list|,
operator|&
name|arg1_len
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|ffecom_ptr_to_expr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3
operator|!=
name|NULL
condition|)
name|arg3_tree
operator|=
name|ffecom_expr_w
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
else|else
name|arg3_tree
operator|=
name|NULL_TREE
expr_stmt|;
name|arg1_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|arg1_len
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_len
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2_tree
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg1_tree
argument_list|)
operator|=
name|arg2_tree
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg2_tree
argument_list|)
operator|=
name|arg1_len
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3_tree
operator|!=
name|NULL_TREE
condition|)
name|expr_tree
operator|=
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3_tree
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3_tree
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impFGETC_subr
case|:
case|case
name|FFEINTRIN_impFPUTC_subr
case|:
block|{
name|tree
name|arg1_tree
decl_stmt|;
name|tree
name|arg2_tree
decl_stmt|;
name|tree
name|arg2_len
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|arg3_tree
decl_stmt|;
name|arg1_tree
operator|=
name|convert
argument_list|(
name|ffecom_f2c_integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|arg1_tree
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1_tree
argument_list|)
argument_list|)
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|arg2
argument_list|,
operator|&
name|arg2_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3
operator|!=
name|NULL
condition|)
name|arg3_tree
operator|=
name|ffecom_expr_w
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
else|else
name|arg3_tree
operator|=
name|NULL_TREE
expr_stmt|;
name|arg1_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2_tree
argument_list|)
expr_stmt|;
name|arg2_len
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2_len
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg1_tree
argument_list|)
operator|=
name|arg2_tree
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg2_tree
argument_list|)
operator|=
name|arg2_len
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3_tree
operator|!=
name|NULL_TREE
condition|)
name|expr_tree
operator|=
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3_tree
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3_tree
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impFSTAT_subr
case|:
block|{
name|tree
name|arg1_tree
decl_stmt|;
name|tree
name|arg2_tree
decl_stmt|;
name|tree
name|arg3_tree
decl_stmt|;
name|arg1_tree
operator|=
name|convert
argument_list|(
name|ffecom_f2c_integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|arg1_tree
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1_tree
argument_list|)
argument_list|)
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ptr_to_integer_type_node
argument_list|,
name|ffecom_ptr_to_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3
operator|==
name|NULL
condition|)
name|arg3_tree
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|arg3_tree
operator|=
name|ffecom_expr_w
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|arg1_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2_tree
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg1_tree
argument_list|)
operator|=
name|arg2_tree
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3_tree
operator|!=
name|NULL_TREE
condition|)
block|{
name|expr_tree
operator|=
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3_tree
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3_tree
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impKILL_subr
case|:
block|{
name|tree
name|arg1_tree
decl_stmt|;
name|tree
name|arg2_tree
decl_stmt|;
name|tree
name|arg3_tree
decl_stmt|;
name|arg1_tree
operator|=
name|convert
argument_list|(
name|ffecom_f2c_integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|arg1_tree
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1_tree
argument_list|)
argument_list|)
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|convert
argument_list|(
name|ffecom_f2c_integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2_tree
argument_list|)
argument_list|)
argument_list|,
name|arg2_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3
operator|==
name|NULL
condition|)
name|arg3_tree
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|arg3_tree
operator|=
name|ffecom_expr_w
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|arg1_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2_tree
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg1_tree
argument_list|)
operator|=
name|arg2_tree
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3_tree
operator|!=
name|NULL_TREE
condition|)
block|{
name|expr_tree
operator|=
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3_tree
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3_tree
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impCTIME_subr
case|:
case|case
name|FFEINTRIN_impTTYNAM_subr
case|:
block|{
name|tree
name|arg1_len
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|arg1_tree
decl_stmt|;
name|tree
name|arg2_tree
decl_stmt|;
name|arg1_tree
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|arg2
argument_list|,
operator|&
name|arg1_len
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|convert
argument_list|(
operator|(
operator|(
name|codegen_imp
operator|==
name|FFEINTRIN_impCTIME_subr
operator|)
condition|?
name|ffecom_f2c_longint_type_node
else|:
name|ffecom_f2c_integer_type_node
operator|)
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2_tree
argument_list|)
argument_list|)
argument_list|,
name|arg2_tree
argument_list|)
expr_stmt|;
name|arg1_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|arg1_len
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_len
argument_list|)
expr_stmt|;
name|arg2_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2_tree
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg1_len
argument_list|)
operator|=
name|arg2_tree
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg1_tree
argument_list|)
operator|=
name|arg1_len
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impIRAND
case|:
case|case
name|FFEINTRIN_impRAND
case|:
comment|/* Arg defaults to 0 (normal random case) */
block|{
name|tree
name|arg1_tree
decl_stmt|;
if|if
condition|(
name|arg1
operator|==
name|NULL
condition|)
name|arg1_tree
operator|=
name|ffecom_integer_zero_node
expr_stmt|;
else|else
name|arg1_tree
operator|=
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg1_tree
operator|=
name|convert
argument_list|(
name|ffecom_f2c_integer_type_node
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|arg1_tree
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1_tree
argument_list|)
argument_list|)
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|arg1_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|FALSE
argument_list|,
operator|(
operator|(
name|codegen_imp
operator|==
name|FFEINTRIN_impIRAND
operator|)
condition|?
name|ffecom_f2c_integer_type_node
else|:
name|ffecom_f2c_real_type_node
operator|)
argument_list|,
name|arg1_tree
argument_list|,
name|dest_tree
argument_list|,
name|dest
argument_list|,
name|dest_used
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impFTELL_subr
case|:
case|case
name|FFEINTRIN_impUMASK_subr
case|:
block|{
name|tree
name|arg1_tree
decl_stmt|;
name|tree
name|arg2_tree
decl_stmt|;
name|arg1_tree
operator|=
name|convert
argument_list|(
name|ffecom_f2c_integer_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|arg1_tree
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1_tree
argument_list|)
argument_list|)
argument_list|,
name|arg1_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
operator|==
name|NULL
condition|)
name|arg2_tree
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|arg2_tree
operator|=
name|ffecom_expr_w
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL_TREE
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2_tree
operator|!=
name|NULL_TREE
condition|)
block|{
name|expr_tree
operator|=
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2_tree
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2_tree
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impCPU_TIME
case|:
case|case
name|FFEINTRIN_impSECOND_subr
case|:
block|{
name|tree
name|arg1_tree
decl_stmt|;
name|arg1_tree
operator|=
name|ffecom_expr_w
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1_tree
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
case|case
name|FFEINTRIN_impDTIME_subr
case|:
case|case
name|FFEINTRIN_impETIME_subr
case|:
block|{
name|tree
name|arg1_tree
decl_stmt|;
name|tree
name|result_tree
decl_stmt|;
name|result_tree
operator|=
name|ffecom_expr_w
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|arg1_tree
operator|=
name|ffecom_ptr_to_expr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL_TREE
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1_tree
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|result_tree
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_tree
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr_tree
return|;
comment|/* Straightforward calls of libf2c routines: */
case|case
name|FFEINTRIN_impABORT
case|:
case|case
name|FFEINTRIN_impACCESS
case|:
case|case
name|FFEINTRIN_impBESJ0
case|:
case|case
name|FFEINTRIN_impBESJ1
case|:
case|case
name|FFEINTRIN_impBESJN
case|:
case|case
name|FFEINTRIN_impBESY0
case|:
case|case
name|FFEINTRIN_impBESY1
case|:
case|case
name|FFEINTRIN_impBESYN
case|:
case|case
name|FFEINTRIN_impCHDIR_func
case|:
case|case
name|FFEINTRIN_impCHMOD_func
case|:
case|case
name|FFEINTRIN_impDATE
case|:
case|case
name|FFEINTRIN_impDATE_AND_TIME
case|:
case|case
name|FFEINTRIN_impDBESJ0
case|:
case|case
name|FFEINTRIN_impDBESJ1
case|:
case|case
name|FFEINTRIN_impDBESJN
case|:
case|case
name|FFEINTRIN_impDBESY0
case|:
case|case
name|FFEINTRIN_impDBESY1
case|:
case|case
name|FFEINTRIN_impDBESYN
case|:
case|case
name|FFEINTRIN_impDTIME_func
case|:
case|case
name|FFEINTRIN_impETIME_func
case|:
case|case
name|FFEINTRIN_impFGETC_func
case|:
case|case
name|FFEINTRIN_impFGET_func
case|:
case|case
name|FFEINTRIN_impFNUM
case|:
case|case
name|FFEINTRIN_impFPUTC_func
case|:
case|case
name|FFEINTRIN_impFPUT_func
case|:
case|case
name|FFEINTRIN_impFSEEK
case|:
case|case
name|FFEINTRIN_impFSTAT_func
case|:
case|case
name|FFEINTRIN_impFTELL_func
case|:
case|case
name|FFEINTRIN_impGERROR
case|:
case|case
name|FFEINTRIN_impGETARG
case|:
case|case
name|FFEINTRIN_impGETCWD_func
case|:
case|case
name|FFEINTRIN_impGETENV
case|:
case|case
name|FFEINTRIN_impGETGID
case|:
case|case
name|FFEINTRIN_impGETLOG
case|:
case|case
name|FFEINTRIN_impGETPID
case|:
case|case
name|FFEINTRIN_impGETUID
case|:
case|case
name|FFEINTRIN_impGMTIME
case|:
case|case
name|FFEINTRIN_impHOSTNM_func
case|:
case|case
name|FFEINTRIN_impIDATE_unix
case|:
case|case
name|FFEINTRIN_impIDATE_vxt
case|:
case|case
name|FFEINTRIN_impIERRNO
case|:
case|case
name|FFEINTRIN_impISATTY
case|:
case|case
name|FFEINTRIN_impITIME
case|:
case|case
name|FFEINTRIN_impKILL_func
case|:
case|case
name|FFEINTRIN_impLINK_func
case|:
case|case
name|FFEINTRIN_impLNBLNK
case|:
case|case
name|FFEINTRIN_impLSTAT_func
case|:
case|case
name|FFEINTRIN_impLTIME
case|:
case|case
name|FFEINTRIN_impMCLOCK8
case|:
case|case
name|FFEINTRIN_impMCLOCK
case|:
case|case
name|FFEINTRIN_impPERROR
case|:
case|case
name|FFEINTRIN_impRENAME_func
case|:
case|case
name|FFEINTRIN_impSECNDS
case|:
case|case
name|FFEINTRIN_impSECOND_func
case|:
case|case
name|FFEINTRIN_impSLEEP
case|:
case|case
name|FFEINTRIN_impSRAND
case|:
case|case
name|FFEINTRIN_impSTAT_func
case|:
case|case
name|FFEINTRIN_impSYMLNK_func
case|:
case|case
name|FFEINTRIN_impSYSTEM_CLOCK
case|:
case|case
name|FFEINTRIN_impSYSTEM_func
case|:
case|case
name|FFEINTRIN_impTIME8
case|:
case|case
name|FFEINTRIN_impTIME_unix
case|:
case|case
name|FFEINTRIN_impTIME_vxt
case|:
case|case
name|FFEINTRIN_impUMASK_func
case|:
case|case
name|FFEINTRIN_impUNLINK_func
case|:
break|break;
case|case
name|FFEINTRIN_impCTIME_func
case|:
comment|/* CHARACTER functions not handled here. */
case|case
name|FFEINTRIN_impFDATE_func
case|:
comment|/* CHARACTER functions not handled here. */
case|case
name|FFEINTRIN_impTTYNAM_func
case|:
comment|/* CHARACTER functions not handled here. */
case|case
name|FFEINTRIN_impNONE
case|:
case|case
name|FFEINTRIN_imp
case|:
comment|/* Hush up gcc warning. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No %s implementation.\n"
argument_list|,
name|ffeintrin_name_implementation
argument_list|(
name|ffebld_symter_implementation
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|"unimplemented intrinsic"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|assert
argument_list|(
name|gfrt
operator|!=
name|FFECOM_gfrt
argument_list|)
expr_stmt|;
comment|/* Must have an implementation! */
name|expr_tree
operator|=
name|ffecom_arglist_expr_
argument_list|(
name|ffecom_gfrt_args_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|gfrt
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|gfrt
argument_list|)
argument_list|,
operator|(
name|ffe_is_f2c_library
argument_list|()
operator|&&
name|ffecom_gfrt_complex_
index|[
name|gfrt
index|]
operator|)
argument_list|,
name|tree_type
argument_list|,
name|expr_tree
argument_list|,
name|dest_tree
argument_list|,
name|dest
argument_list|,
name|dest_used
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
comment|/* See bottom of this file for f2c transforms used to determine      many of the above implementations.  The info seems to confuse      Emacs's C mode indentation, which is why it's been moved to      the bottom of this source file.  */
block|}
end_function

begin_comment
comment|/* For power (exponentiation) where right-hand operand is type INTEGER,    generate in-line code to do it the fast way (which, if the operand    is a constant, might just mean a series of multiplies).  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_expr_power_integer_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|tree
name|l
init|=
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|r
init|=
name|ffecom_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ltype
init|=
name|TREE_TYPE
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|tree
name|rtype
init|=
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|error_mark_node
operator|||
name|r
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|int
name|sgn
init|=
name|tree_int_cst_sgn
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|sgn
operator|==
literal|0
condition|)
return|return
name|convert
argument_list|(
name|ltype
argument_list|,
name|integer_one_node
argument_list|)
return|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|ltype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|)
operator|&&
operator|(
name|sgn
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* Reciprocal of integer is either 0, -1, or 1, so after 	     calculating that (which we leave to the back end to do 	     or not do optimally), don't bother with any multiplying.  */
name|result
operator|=
name|ffecom_tree_divide_
argument_list|(
name|ltype
argument_list|,
name|convert
argument_list|(
name|ltype
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|l
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|rtype
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|r
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|result
operator|=
name|ffecom_1
argument_list|(
name|ABS_EXPR
argument_list|,
name|rtype
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
comment|/* Generate appropriate series of multiplies, preceded 	 by divide if the exponent is negative.  */
name|l
operator|=
name|save_expr
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgn
operator|<
literal|0
condition|)
block|{
name|l
operator|=
name|ffecom_tree_divide_
argument_list|(
name|ltype
argument_list|,
name|convert
argument_list|(
name|ltype
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|l
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|rtype
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|r
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* The "most negative" number.  */
name|r
operator|=
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|rtype
argument_list|,
name|ffecom_2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|rtype
argument_list|,
name|r
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|=
name|save_expr
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|ffecom_2
argument_list|(
name|MULT_EXPR
argument_list|,
name|ltype
argument_list|,
name|l
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|r
argument_list|)
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
name|result
operator|=
name|l
expr_stmt|;
else|else
name|result
operator|=
name|ffecom_2
argument_list|(
name|MULT_EXPR
argument_list|,
name|ltype
argument_list|,
name|result
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|ffecom_2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|rtype
argument_list|,
name|r
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|r
argument_list|)
condition|)
break|break;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|l
operator|=
name|save_expr
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|ffecom_2
argument_list|(
name|MULT_EXPR
argument_list|,
name|ltype
argument_list|,
name|l
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/* Though rhs isn't a constant, in-line code cannot be expanded      while transforming dummies      because the back end cannot be easily convinced to generate      stores (MODIFY_EXPR), handle temporaries, and so on before      all the appropriate rtx's have been generated for things like      dummy args referenced in rhs -- which doesn't happen until      store_parm_decls() is called (expand_function_start, I believe,      does the actual rtx-stuffing of PARM_DECLs).       So, in this case, let the caller generate the call to the      run-time-library function to evaluate the power for us.  */
if|if
condition|(
name|ffecom_transform_only_dummies_
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Right-hand operand not a constant, expand in-line code to figure      out how to do the multiplies,&c.       The returned expression is expressed this way in GNU C, where l and      r are the "inputs":       ({ typeof (r) rtmp = r; 	typeof (l) ltmp = l; 	typeof (l) result;  	if (rtmp == 0) 	  result = 1; 	else 	  { 	    if ((basetypeof (l) == basetypeof (int))&& (rtmp< 0)) 	      { 	        result = ((typeof (l)) 1) / ltmp; 	        if ((ltmp< 0)&& (((-rtmp)& 1) == 0)) 		  result = -result; 	      } 	    else 	      { 		result = 1; 		if ((basetypeof (l) != basetypeof (int))&& (rtmp< 0)) 		  { 		    ltmp = ((typeof (l)) 1) / ltmp; 		    rtmp = -rtmp; 		    if (rtmp< 0) 		      { 		        rtmp = -(rtmp>> 1); 		        ltmp *= ltmp; 		      } 		  } 		for (;;) 		  { 		    if (rtmp& 1) 		      result *= ltmp; 		    if ((rtmp>>= 1) == 0) 		      break; 		    ltmp *= ltmp; 		  } 	      } 	  } 	result;      })       Note that some of the above is compile-time collapsable, such as      the first part of the if statements that checks the base type of      l against int.  The if statements are phrased that way to suggest      an easy way to generate the if/else constructs here, knowing that      the back end should (and probably does) eliminate the resulting      dead code (either the int case or the non-int case), something      it couldn't do without the redundant phrasing, requiring explicit      dead-code elimination here, which would be kind of difficult to      read.  */
block|{
name|tree
name|rtmp
decl_stmt|;
name|tree
name|ltmp
decl_stmt|;
name|tree
name|divide
decl_stmt|;
name|tree
name|basetypeof_l_is_int
decl_stmt|;
name|tree
name|se
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|basetypeof_l_is_int
operator|=
name|build_int_2
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|ltype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|se
operator|=
name|expand_start_stmt_expr
argument_list|()
expr_stmt|;
name|ffecom_start_compstmt
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|HAHA
name|rtmp
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"power_r"
argument_list|,
name|rtype
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ltmp
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"power_l"
argument_list|,
name|ltype
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"power_res"
argument_list|,
name|ltype
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ltype
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ltype
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|divide
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"power_div"
argument_list|,
name|ltype
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|divide
operator|=
name|NULL_TREE
expr_stmt|;
else|#
directive|else
comment|/* HAHA */
block|{
name|tree
name|hook
decl_stmt|;
name|hook
operator|=
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|hook
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|hook
argument_list|)
operator|==
name|TREE_VEC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|hook
argument_list|)
operator|==
literal|4
argument_list|)
expr_stmt|;
name|rtmp
operator|=
name|TREE_VEC_ELT
argument_list|(
name|hook
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ltmp
operator|=
name|TREE_VEC_ELT
argument_list|(
name|hook
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TREE_VEC_ELT
argument_list|(
name|hook
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|divide
operator|=
name|TREE_VEC_ELT
argument_list|(
name|hook
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ltype
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ltype
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|assert
argument_list|(
name|divide
argument_list|)
expr_stmt|;
else|else
name|assert
argument_list|(
operator|!
name|divide
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAHA */
name|expand_expr_stmt
argument_list|(
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|rtmp
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|ltmp
argument_list|,
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|rtmp
argument_list|,
name|convert
argument_list|(
name|rtype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|result
argument_list|,
name|convert
argument_list|(
name|ltype
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_start_else
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|basetypeof_l_is_int
argument_list|)
condition|)
block|{
name|expand_start_cond
argument_list|(
name|ffecom_2
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|rtmp
argument_list|,
name|convert
argument_list|(
name|rtype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|result
argument_list|,
name|ffecom_tree_divide_
argument_list|(
name|ltype
argument_list|,
name|convert
argument_list|(
name|ltype
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|ltmp
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|divide
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ltmp
argument_list|,
name|convert
argument_list|(
name|ltype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|rtype
argument_list|,
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|rtype
argument_list|,
name|rtmp
argument_list|)
argument_list|,
name|convert
argument_list|(
name|rtype
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|rtype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|result
argument_list|,
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|ltype
argument_list|,
name|result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
name|expand_start_else
argument_list|()
expr_stmt|;
block|}
name|expand_expr_stmt
argument_list|(
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|result
argument_list|,
name|convert
argument_list|(
name|ltype
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ffecom_truth_value_invert
argument_list|(
name|basetypeof_l_is_int
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|rtmp
argument_list|,
name|convert
argument_list|(
name|rtype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|ltmp
argument_list|,
name|ffecom_tree_divide_
argument_list|(
name|ltype
argument_list|,
name|convert
argument_list|(
name|ltype
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|ltmp
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|divide
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|rtmp
argument_list|,
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|rtype
argument_list|,
name|rtmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|rtmp
argument_list|,
name|convert
argument_list|(
name|rtype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|rtmp
argument_list|,
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|rtype
argument_list|,
name|ffecom_2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|rtype
argument_list|,
name|rtmp
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|ltmp
argument_list|,
name|ffecom_2
argument_list|(
name|MULT_EXPR
argument_list|,
name|ltype
argument_list|,
name|ltmp
argument_list|,
name|ltmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
name|expand_start_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|rtype
argument_list|,
name|rtmp
argument_list|,
name|convert
argument_list|(
name|rtype
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|result
argument_list|,
name|ffecom_2
argument_list|(
name|MULT_EXPR
argument_list|,
name|ltype
argument_list|,
name|result
argument_list|,
name|ltmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
name|expand_exit_loop_if_false
argument_list|(
name|NULL
argument_list|,
name|ffecom_truth_value
argument_list|(
name|ffecom_modify
argument_list|(
name|rtype
argument_list|,
name|rtmp
argument_list|,
name|ffecom_2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|rtype
argument_list|,
name|rtmp
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|ltmp
argument_list|,
name|ffecom_2
argument_list|(
name|MULT_EXPR
argument_list|,
name|ltype
argument_list|,
name|ltmp
argument_list|,
name|ltmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|basetypeof_l_is_int
argument_list|)
condition|)
name|expand_end_cond
argument_list|()
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_end_compstmt
argument_list|()
expr_stmt|;
name|result
operator|=
name|expand_end_stmt_expr
argument_list|(
name|se
argument_list|)
expr_stmt|;
comment|/* This code comes from c-parse.in, after its expand_end_stmt_expr.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BLOCK
condition|)
block|{
comment|/* Make a BIND_EXPR for the BLOCK already made.  */
name|result
operator|=
name|build
argument_list|(
name|BIND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|result
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Remove the block from the tree at this point. 	   It gets put back at the proper place 	   when the BIND_EXPR is expanded.  */
name|delete_block
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|t
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* ffecom_expr_transform_ -- Transform symbols in expr     ffebld expr;	 // FFE expression.    ffecom_expr_transform_ (expr);     Recursive descent on expr while transforming any untransformed SYMTERs.  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_expr_transform_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|tail_recurse
label|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opSYMTER
case|:
name|s
operator|=
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|==
name|NULL_TREE
operator|)
operator|&&
operator|(
operator|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_kindNONE
operator|)
operator|||
operator|(
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereNONE
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereINTRINSIC
operator|)
operator|)
operator|)
condition|)
block|{
name|s
operator|=
name|ffecom_sym_transform_
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
comment|/* Sfunc expr non-dummy, 						   DIMENSION expr? */
block|}
break|break;
comment|/* Ok if (t == NULL) here. */
case|case
name|FFEBLD_opITEM
case|:
name|ffecom_expr_transform_
argument_list|(
name|ffebld_head
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_trail
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|tail_recurse
goto|;
comment|/* :::::::::::::::::::: */
default|default:
break|break;
block|}
switch|switch
condition|(
name|ffebld_arity
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
name|ffecom_expr_transform_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|tail_recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
literal|1
case|:
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|tail_recurse
goto|;
comment|/* :::::::::::::::::::: */
default|default:
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Make a type based on info in live f2c.h file.  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_f2c_make_type_
parameter_list|(
name|tree
modifier|*
name|type
parameter_list|,
name|int
name|tcode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
switch|switch
condition|(
name|tcode
condition|)
block|{
case|case
name|FFECOM_f2ccodeCHAR
case|:
operator|*
name|type
operator|=
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFECOM_f2ccodeSHORT
case|:
operator|*
name|type
operator|=
name|make_signed_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFECOM_f2ccodeINT
case|:
operator|*
name|type
operator|=
name|make_signed_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFECOM_f2ccodeLONG
case|:
operator|*
name|type
operator|=
name|make_signed_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFECOM_f2ccodeLONGLONG
case|:
operator|*
name|type
operator|=
name|make_signed_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFECOM_f2ccodeCHARPTR
case|:
operator|*
name|type
operator|=
name|build_pointer_type
argument_list|(
name|DEFAULT_SIGNED_CHAR
condition|?
name|signed_char_type_node
else|:
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFECOM_f2ccodeFLOAT
case|:
operator|*
name|type
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
operator|*
name|type
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
name|layout_type
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFECOM_f2ccodeDOUBLE
case|:
operator|*
name|type
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
operator|*
name|type
argument_list|)
operator|=
name|DOUBLE_TYPE_SIZE
expr_stmt|;
name|layout_type
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFECOM_f2ccodeLONGDOUBLE
case|:
operator|*
name|type
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
operator|*
name|type
argument_list|)
operator|=
name|LONG_DOUBLE_TYPE_SIZE
expr_stmt|;
name|layout_type
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFECOM_f2ccodeTWOREALS
case|:
operator|*
name|type
operator|=
name|ffecom_make_complex_type_
argument_list|(
name|ffecom_f2c_real_type_node
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFECOM_f2ccodeTWODOUBLEREALS
case|:
operator|*
name|type
operator|=
name|ffecom_make_complex_type_
argument_list|(
name|ffecom_f2c_doublereal_type_node
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"unexpected FFECOM_f2ccodeXYZZY!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|error_mark_node
expr_stmt|;
return|return;
block|}
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_f2c_%s"
argument_list|,
name|name
argument_list|)
argument_list|,
operator|*
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the f2c list-directed-I/O code for whatever (integral) type has the    given size.  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_f2c_set_lio_code_
parameter_list|(
name|ffeinfoBasictype
name|bt
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|tree
name|t
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
operator|(
name|size_t
operator|)
name|j
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffecom_tree_type
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|j
control|)
if|if
condition|(
operator|(
name|t
operator|=
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|j
index|]
operator|)
operator|!=
name|NULL_TREE
operator|&&
name|compare_tree_int
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|,
name|size
argument_list|)
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|code
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ffecom_f2c_typecode_
index|[
name|bt
index|]
index|[
name|j
index|]
operator|=
name|code
expr_stmt|;
name|code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish up globals after doing all program units in file     Need to handle only uninitialized COMMON areas.  */
end_comment

begin_function
specifier|static
name|ffeglobal
name|ffecom_finish_global_
parameter_list|(
name|ffeglobal
name|global
parameter_list|)
block|{
name|tree
name|cbtype
decl_stmt|;
name|tree
name|cbt
decl_stmt|;
name|tree
name|size
decl_stmt|;
if|if
condition|(
name|ffeglobal_type
argument_list|(
name|global
argument_list|)
operator|!=
name|FFEGLOBAL_typeCOMMON
condition|)
return|return
name|global
return|;
if|if
condition|(
name|ffeglobal_common_init
argument_list|(
name|global
argument_list|)
condition|)
return|return
name|global
return|;
name|cbt
operator|=
name|ffeglobal_hook
argument_list|(
name|global
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cbt
operator|==
name|NULL_TREE
operator|)
operator|||
operator|!
name|ffeglobal_common_have_size
argument_list|(
name|global
argument_list|)
condition|)
return|return
name|global
return|;
comment|/* No need to make common, never ref'd. */
name|DECL_EXTERNAL
argument_list|(
name|cbt
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Give the array a size now.  */
name|size
operator|=
name|build_int_2
argument_list|(
operator|(
name|ffeglobal_common_size
argument_list|(
name|global
argument_list|)
operator|+
name|ffeglobal_common_pad
argument_list|(
name|global
argument_list|)
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cbtype
operator|=
name|TREE_TYPE
argument_list|(
name|cbt
argument_list|)
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|cbtype
argument_list|)
operator|=
name|build_range_type
argument_list|(
name|integer_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
operator|=
name|TYPE_DOMAIN
argument_list|(
name|cbtype
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|cbtype
argument_list|)
expr_stmt|;
name|cbt
operator|=
name|start_decl
argument_list|(
name|cbt
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cbt
operator|==
name|ffeglobal_hook
argument_list|(
name|global
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|cbt
argument_list|,
name|NULL_TREE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|global
return|;
block|}
end_function

begin_comment
comment|/* Finish up any untransformed symbols.  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffecom_finish_symbol_transform_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
if|if
condition|(
operator|(
name|s
operator|==
name|NULL
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|ERROR_MARK
operator|)
condition|)
return|return
name|s
return|;
comment|/* It's easy to know to transform an untransformed symbol, to make sure      we put out debugging info for it.  But COMMON variables, unlike      EQUIVALENCE ones, aren't given declarations in addition to the      tree expressions that specify offsets, because COMMON variables      can be referenced in the outer scope where only dummy arguments      (PARM_DECLs) should really be seen.  To be safe, just don't do any      VAR_DECLs for COMMON variables when we transform them for real      use, and therefore we do all the VAR_DECL creating here.  */
if|if
condition|(
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_kindNONE
operator|||
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereNONE
operator|&&
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereINTRINSIC
operator|&&
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereDUMMY
operator|)
condition|)
comment|/* Not transformed, and not CHARACTER*(*), and not a dummy 	   argument, which can happen only if the entry point names 	   it "rides in on" are all invalidated for other reasons.  */
name|s
operator|=
name|ffecom_sym_transform_
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereCOMMON
operator|)
operator|&&
operator|(
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
operator|!=
name|error_mark_node
operator|)
condition|)
block|{
comment|/* This isn't working, at least for dbxout.  The .s file looks 	 okay to me (burley), but in gdb 4.9 at least, the variables 	 appear to reside somewhere outside of the common area, so 	 it doesn't make sense to mislead anyone by generating the info 	 on those variables until this is fixed.  NOTE: Same problem 	 with EQUIVALENCE, sadly...see similar #if later.  */
name|ffecom_member_phase2_
argument_list|(
name|ffesymbol_storage
argument_list|(
name|ffesymbol_common
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|,
name|ffesymbol_storage
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Append underscore(s) to name before calling get_identifier.  "us"    is nonzero if the name already contains an underscore and thus    needs two underscores appended.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_get_appended_identifier_
parameter_list|(
name|char
name|us
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|newname
operator|=
name|xmalloc
argument_list|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|)
operator|+
literal|1
operator|+
name|ffe_is_underscoring
argument_list|()
operator|+
name|us
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newname
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|newname
index|[
name|i
index|]
operator|=
literal|'_'
expr_stmt|;
name|newname
index|[
name|i
operator|+
name|us
index|]
operator|=
literal|'_'
expr_stmt|;
name|newname
index|[
name|i
operator|+
literal|1
operator|+
name|us
index|]
operator|=
literal|'\0'
expr_stmt|;
name|id
operator|=
name|get_identifier
argument_list|(
name|newname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_comment
comment|/* Decide whether to append underscore to name before calling    get_identifier.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_get_external_identifier_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|char
name|us
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|/* If name is a built-in name, just return it as is.  */
if|if
condition|(
operator|!
name|ffe_is_underscoring
argument_list|()
operator|||
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|FFETARGET_nameBLANK_COMMON
argument_list|)
operator|==
literal|0
operator|)
if|#
directive|if
name|FFETARGET_isENFORCED_MAIN_NAME
operator|||
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|FFETARGET_nameENFORCED_NAME
argument_list|)
operator|==
literal|0
operator|)
else|#
directive|else
operator|||
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|FFETARGET_nameUNNAMED_MAIN
argument_list|)
operator|==
literal|0
operator|)
endif|#
directive|endif
operator|||
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|FFETARGET_nameUNNAMED_BLOCK_DATA
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|get_identifier
argument_list|(
name|name
argument_list|)
return|;
name|us
operator|=
name|ffe_is_second_underscore
argument_list|()
condition|?
operator|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'_'
argument_list|)
operator|!=
name|NULL
operator|)
else|:
literal|0
expr_stmt|;
return|return
name|ffecom_get_appended_identifier_
argument_list|(
name|us
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Decide whether to append underscore to internal name before calling    get_identifier.     This is for non-external, top-function-context names only.  Transform    identifier so it doesn't conflict with the transformed result    of using a _different_ external name.  E.g. if "CALL FOO" is    transformed into "FOO_();", then the variable in "FOO_ = 3"    must be transformed into something that does not conflict, since    these two things should be independent.     The transformation is as follows.  If the name does not contain    an underscore, there is no possible conflict, so just return.    If the name does contain an underscore, then transform it just    like we transform an external identifier.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_get_identifier_
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* If name does not contain an underscore, just return it as is.  */
if|if
condition|(
operator|!
name|ffe_is_underscoring
argument_list|()
operator|||
operator|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'_'
argument_list|)
operator|==
name|NULL
operator|)
condition|)
return|return
name|get_identifier
argument_list|(
name|name
argument_list|)
return|;
return|return
name|ffecom_get_appended_identifier_
argument_list|(
name|ffe_is_second_underscore
argument_list|()
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffecom_gen_sfuncdef_ -- Generate definition of statement function     tree t;    ffesymbol s;	 // kindFUNCTION, whereIMMEDIATE.    t = ffecom_gen_sfuncdef_(s,ffesymbol_basictype(s), 	 ffesymbol_kindtype(s));     Call after setting up containing function and getting trees for all    other symbols.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_gen_sfuncdef_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|)
block|{
name|ffebld
name|expr
init|=
name|ffesymbol_sfexpr
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|func
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|bool
name|charfunc
init|=
operator|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
decl_stmt|;
specifier|static
name|bool
name|recurse
init|=
name|FALSE
decl_stmt|;
name|int
name|old_lineno
init|=
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
name|ffecom_nested_entry_
operator|=
name|s
expr_stmt|;
comment|/* For now, we don't have a handy pointer to where the sfunc is actually      defined, though that should be easy to add to an ffesymbol. (The      token/where info available might well point to the place where the type      of the sfunc is declared, especially if that precedes the place where      the sfunc itself is defined, which is typically the case.)  We should      put out a null pointer rather than point somewhere wrong, but I want to      see how it works at this point.  */
name|input_filename
operator|=
name|ffesymbol_where_filename
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|ffesymbol_where_filelinenum
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Pretransform the expression so any newly discovered things belong to the      outer program unit, not to the statement function. */
name|ffecom_expr_transform_
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Make sure no recursive invocation of this fn (a specific case of failing      to pretransform an sfunc's expression, i.e. where its expression      references another untransformed sfunc) happens. */
name|assert
argument_list|(
operator|!
name|recurse
argument_list|)
expr_stmt|;
name|recurse
operator|=
name|TRUE
expr_stmt|;
name|push_f_function_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|charfunc
condition|)
name|type
operator|=
name|void_type_node
expr_stmt|;
else|else
block|{
name|type
operator|=
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
comment|/* _sym_exec_transition reports 					   error. */
block|}
name|start_function
argument_list|(
name|ffecom_get_identifier_
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|,
name|build_function_type
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
literal|1
argument_list|,
comment|/* nested/inline */
literal|0
argument_list|)
expr_stmt|;
comment|/* TREE_PUBLIC */
comment|/* We don't worry about COMPLEX return values here, because this is      entirely internal to our code, and gcc has the ability to return COMPLEX      directly as a value.  */
if|if
condition|(
name|charfunc
condition|)
block|{
comment|/* Prepend arg for where result goes. */
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeCHARACTER
index|]
index|[
name|kt
index|]
expr_stmt|;
name|result
operator|=
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_%s"
argument_list|,
literal|"result"
argument_list|)
expr_stmt|;
name|ffecom_char_enhance_arg_
argument_list|(
operator|&
name|type
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Ignore returned length. */
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|result
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|push_parm_decl
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Not ref'd if !charfunc. */
name|ffecom_push_dummy_decls_
argument_list|(
name|ffesymbol_dummyargs
argument_list|(
name|s
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ffecom_start_compstmt
argument_list|()
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|charfunc
condition|)
block|{
name|ffetargetCharacterSize
name|sz
init|=
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|tree
name|result_length
decl_stmt|;
name|result_length
operator|=
name|build_int_2
argument_list|(
name|sz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|result_length
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
name|ffecom_prepare_let_char_
argument_list|(
name|sz
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
name|ffecom_let_char_
argument_list|(
name|result
argument_list|,
name|result_length
argument_list|,
name|sz
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ffecom_prepare_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
name|expand_return
argument_list|(
name|ffecom_modify
argument_list|(
name|NULL_TREE
argument_list|,
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ffecom_end_compstmt
argument_list|()
expr_stmt|;
name|func
operator|=
name|current_function_decl
expr_stmt|;
name|finish_function
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|pop_f_function_context
argument_list|()
expr_stmt|;
name|recurse
operator|=
name|FALSE
expr_stmt|;
name|lineno
operator|=
name|old_lineno
expr_stmt|;
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
name|ffecom_nested_entry_
operator|=
name|NULL
expr_stmt|;
return|return
name|func
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ffecom_gfrt_args_
parameter_list|(
name|ffecomGfrt
name|ix
parameter_list|)
block|{
return|return
name|ffecom_gfrt_argstring_
index|[
name|ix
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|ffecom_gfrt_tree_
parameter_list|(
name|ffecomGfrt
name|ix
parameter_list|)
block|{
if|if
condition|(
name|ffecom_gfrt_
index|[
name|ix
index|]
operator|==
name|NULL_TREE
condition|)
name|ffecom_make_gfrt_
argument_list|(
name|ix
argument_list|)
expr_stmt|;
return|return
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|ffecom_gfrt_
index|[
name|ix
index|]
argument_list|)
argument_list|)
argument_list|,
name|ffecom_gfrt_
index|[
name|ix
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return initialize-to-zero expression for this VAR_DECL.  */
end_comment

begin_comment
comment|/* A somewhat evil way to prevent the garbage collector    from collecting 'tree' structures.  */
end_comment

begin_define
define|#
directive|define
name|NUM_TRACKED_CHUNK
value|63
end_define

begin_struct
specifier|static
struct|struct
name|tree_ggc_tracker
block|{
name|struct
name|tree_ggc_tracker
modifier|*
name|next
decl_stmt|;
name|tree
name|trees
index|[
name|NUM_TRACKED_CHUNK
index|]
decl_stmt|;
block|}
modifier|*
name|tracker_head
init|=
name|NULL
struct|;
end_struct

begin_function
specifier|static
name|void
name|mark_tracker_head
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|tree_ggc_tracker
modifier|*
name|head
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|head
operator|=
operator|*
operator|(
expr|struct
name|tree_ggc_tracker
operator|*
operator|*
operator|)
name|arg
init|;
name|head
operator|!=
name|NULL
condition|;
name|head
operator|=
name|head
operator|->
name|next
control|)
block|{
name|ggc_mark
argument_list|(
name|head
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_TRACKED_CHUNK
condition|;
name|i
operator|++
control|)
name|ggc_mark_tree
argument_list|(
name|head
operator|->
name|trees
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ffecom_save_tree_forever
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tracker_head
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_TRACKED_CHUNK
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tracker_head
operator|->
name|trees
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|tracker_head
operator|->
name|trees
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
return|return;
block|}
block|{
comment|/* Need to allocate a new block.  */
name|struct
name|tree_ggc_tracker
modifier|*
name|old_head
init|=
name|tracker_head
decl_stmt|;
name|tracker_head
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tracker_head
argument_list|)
argument_list|)
expr_stmt|;
name|tracker_head
operator|->
name|next
operator|=
name|old_head
expr_stmt|;
name|tracker_head
operator|->
name|trees
index|[
literal|0
index|]
operator|=
name|t
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NUM_TRACKED_CHUNK
condition|;
name|i
operator|++
control|)
name|tracker_head
operator|->
name|trees
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|ffecom_init_zero_
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|init
decl_stmt|;
name|int
name|incremental
init|=
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|incremental
condition|)
block|{
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assemble_variable
argument_list|(
name|decl
argument_list|,
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|UNION_TYPE
operator|)
operator|&&
operator|!
name|incremental
condition|)
name|init
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|incremental
condition|)
block|{
name|init
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|assemble_zeros
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|init
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|ffecom_intrinsic_ichar_
parameter_list|(
name|tree
name|tree_type
parameter_list|,
name|ffebld
name|arg
parameter_list|,
name|tree
modifier|*
name|maybe_tree
parameter_list|)
block|{
name|tree
name|expr_tree
decl_stmt|;
name|tree
name|length_tree
decl_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opCONTER
case|:
comment|/* For F90, check 0-length. */
if|if
condition|(
name|ffetarget_length_character1
argument_list|(
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|maybe_tree
operator|=
name|integer_zero_node
expr_stmt|;
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
operator|*
name|maybe_tree
operator|=
name|integer_one_node
expr_stmt|;
name|expr_tree
operator|=
name|build_int_2
argument_list|(
operator|*
name|ffetarget_text_character1
argument_list|(
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr_tree
argument_list|)
operator|=
name|tree_type
expr_stmt|;
return|return
name|expr_tree
return|;
case|case
name|FFEBLD_opSYMTER
case|:
case|case
name|FFEBLD_opARRAYREF
case|:
case|case
name|FFEBLD_opFUNCREF
case|:
case|case
name|FFEBLD_opSUBSTR
case|:
name|ffecom_char_args_
argument_list|(
operator|&
name|expr_tree
argument_list|,
operator|&
name|length_tree
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|expr_tree
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|length_tree
operator|==
name|error_mark_node
operator|)
condition|)
block|{
operator|*
name|maybe_tree
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|integer_zerop
argument_list|(
name|length_tree
argument_list|)
condition|)
block|{
operator|*
name|maybe_tree
operator|=
name|integer_zero_node
expr_stmt|;
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
name|expr_tree
operator|=
name|ffecom_1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|expr_tree
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_2
argument_list|(
name|ARRAY_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|expr_tree
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|convert
argument_list|(
name|tree_type
argument_list|,
name|expr_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|length_tree
argument_list|)
operator|==
name|INTEGER_CST
condition|)
operator|*
name|maybe_tree
operator|=
name|integer_one_node
expr_stmt|;
else|else
comment|/* Must check length at run time.  */
operator|*
name|maybe_tree
operator|=
name|ffecom_truth_value
argument_list|(
name|ffecom_2
argument_list|(
name|GT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|length_tree
argument_list|,
name|ffecom_f2c_ftnlen_zero_node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expr_tree
return|;
case|case
name|FFEBLD_opPAREN
case|:
case|case
name|FFEBLD_opCONVERT
case|:
if|if
condition|(
name|ffeinfo_size
argument_list|(
name|ffebld_info
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|maybe_tree
operator|=
name|integer_zero_node
expr_stmt|;
return|return
name|convert
argument_list|(
name|tree_type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
return|return
name|ffecom_intrinsic_ichar_
argument_list|(
name|tree_type
argument_list|,
name|ffebld_left
argument_list|(
name|arg
argument_list|)
argument_list|,
name|maybe_tree
argument_list|)
return|;
case|case
name|FFEBLD_opCONCATENATE
case|:
block|{
name|tree
name|maybe_left
decl_stmt|;
name|tree
name|maybe_right
decl_stmt|;
name|tree
name|expr_left
decl_stmt|;
name|tree
name|expr_right
decl_stmt|;
name|expr_left
operator|=
name|ffecom_intrinsic_ichar_
argument_list|(
name|tree_type
argument_list|,
name|ffebld_left
argument_list|(
name|arg
argument_list|)
argument_list|,
operator|&
name|maybe_left
argument_list|)
expr_stmt|;
name|expr_right
operator|=
name|ffecom_intrinsic_ichar_
argument_list|(
name|tree_type
argument_list|,
name|ffebld_right
argument_list|(
name|arg
argument_list|)
argument_list|,
operator|&
name|maybe_right
argument_list|)
expr_stmt|;
operator|*
name|maybe_tree
operator|=
name|ffecom_2
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|maybe_left
argument_list|,
name|maybe_right
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|tree_type
argument_list|,
name|maybe_left
argument_list|,
name|expr_left
argument_list|,
name|expr_right
argument_list|)
expr_stmt|;
return|return
name|expr_tree
return|;
block|}
default|default:
name|assert
argument_list|(
literal|"bad op in ICHAR"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffecom_intrinsic_len_ -- Return length info for char arg (LEN())     tree length_arg;    ffebld expr;    length_arg = ffecom_intrinsic_len_ (expr);     Handles CHARACTER-type CONTER, SYMTER, SUBSTR, ARRAYREF, and FUNCREF    subexpressions by constructing the appropriate tree for the    length-of-character-text argument in a calling sequence.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_intrinsic_len_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffetargetCharacter1
name|val
decl_stmt|;
name|tree
name|length
decl_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opCONTER
case|:
name|val
operator|=
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|build_int_2
argument_list|(
name|ffetarget_length_character1
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|length
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
break|break;
case|case
name|FFEBLD_opSYMTER
case|:
block|{
name|ffesymbol
name|s
init|=
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|item
decl_stmt|;
name|item
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL_TREE
condition|)
block|{
name|s
operator|=
name|ffecom_sym_transform_
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
block|}
if|if
condition|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_kindENTITY
condition|)
block|{
if|if
condition|(
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
operator|==
name|FFETARGET_charactersizeNONE
condition|)
name|length
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|length_tree
expr_stmt|;
else|else
block|{
name|length
operator|=
name|build_int_2
argument_list|(
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|length
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|item
operator|==
name|error_mark_node
condition|)
name|length
operator|=
name|error_mark_node
expr_stmt|;
else|else
comment|/* FFEINFO_kindFUNCTION: */
name|length
operator|=
name|NULL_TREE
expr_stmt|;
block|}
break|break;
case|case
name|FFEBLD_opARRAYREF
case|:
name|length
operator|=
name|ffecom_intrinsic_len_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opSUBSTR
case|:
block|{
name|ffebld
name|start
decl_stmt|;
name|ffebld
name|end
decl_stmt|;
name|ffebld
name|thing
init|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|start_tree
decl_stmt|;
name|tree
name|end_tree
decl_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|thing
argument_list|)
operator|==
name|FFEBLD_opITEM
argument_list|)
expr_stmt|;
name|start
operator|=
name|ffebld_head
argument_list|(
name|thing
argument_list|)
expr_stmt|;
name|thing
operator|=
name|ffebld_trail
argument_list|(
name|thing
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_trail
argument_list|(
name|thing
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|end
operator|=
name|ffebld_head
argument_list|(
name|thing
argument_list|)
expr_stmt|;
name|length
operator|=
name|ffecom_intrinsic_len_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
name|error_mark_node
condition|)
break|break;
if|if
condition|(
name|start
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
empty_stmt|;
else|else
block|{
name|length
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|start_tree
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_tree
operator|==
name|error_mark_node
condition|)
block|{
name|length
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
block|{
name|length
operator|=
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|ffecom_f2c_ftnlen_one_node
argument_list|,
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|length
argument_list|,
name|start_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|end_tree
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_tree
operator|==
name|error_mark_node
condition|)
block|{
name|length
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
name|length
operator|=
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|ffecom_f2c_ftnlen_one_node
argument_list|,
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|end_tree
argument_list|,
name|start_tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|FFEBLD_opCONCATENATE
case|:
name|length
operator|=
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|ffecom_intrinsic_len_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|ffecom_intrinsic_len_
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opFUNCREF
case|:
case|case
name|FFEBLD_opCONVERT
case|:
name|length
operator|=
name|build_int_2
argument_list|(
name|ffebld_size
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|length
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad op for single char arg expr"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|length
operator|=
name|ffecom_f2c_ftnlen_zero_node
expr_stmt|;
break|break;
block|}
name|assert
argument_list|(
name|length
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* Handle CHARACTER assignments.     Generates code to do the assignment.	 Used by ordinary assignment    statement handler ffecom_let_stmt and by statement-function    handler to generate code for a statement function.  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_let_char_
parameter_list|(
name|tree
name|dest_tree
parameter_list|,
name|tree
name|dest_length
parameter_list|,
name|ffetargetCharacterSize
name|dest_size
parameter_list|,
name|ffebld
name|source
parameter_list|)
block|{
name|ffecomConcatList_
name|catlist
decl_stmt|;
name|tree
name|source_length
decl_stmt|;
name|tree
name|source_tree
decl_stmt|;
name|tree
name|expr_tree
decl_stmt|;
if|if
condition|(
operator|(
name|dest_tree
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|dest_length
operator|==
name|error_mark_node
operator|)
condition|)
return|return;
name|assert
argument_list|(
name|dest_tree
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dest_length
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Source might be an opCONVERT, which just means it is a different size      than the destination.  Since the underlying implementation here handles      that (directly or via the s_copy or s_cat run-time-library functions),      we don't need the "convenience" of an opCONVERT that tells us to      truncate or blank-pad, particularly since the resulting implementation      would probably be slower than otherwise. */
while|while
condition|(
name|ffebld_op
argument_list|(
name|source
argument_list|)
operator|==
name|FFEBLD_opCONVERT
condition|)
name|source
operator|=
name|ffebld_left
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|catlist
operator|=
name|ffecom_concat_list_new_
argument_list|(
name|source
argument_list|,
name|dest_size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffecom_concat_list_count_
argument_list|(
name|catlist
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Shouldn't happen, but in case it does... */
name|ffecom_concat_list_kill_
argument_list|(
name|catlist
argument_list|)
expr_stmt|;
name|source_tree
operator|=
name|null_pointer_node
expr_stmt|;
name|source_length
operator|=
name|ffecom_f2c_ftnlen_zero_node
expr_stmt|;
name|expr_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|dest_tree
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|expr_tree
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|source_tree
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|expr_tree
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|dest_length
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|expr_tree
argument_list|)
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|source_length
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtCOPY
argument_list|,
name|expr_tree
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|expr_tree
argument_list|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
comment|/* The (fairly) easy case. */
name|ffecom_char_args_
argument_list|(
operator|&
name|source_tree
argument_list|,
operator|&
name|source_length
argument_list|,
name|ffecom_concat_list_expr_
argument_list|(
name|catlist
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_concat_list_kill_
argument_list|(
name|catlist
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|source_tree
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|source_length
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|source_tree
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|source_length
operator|==
name|error_mark_node
operator|)
condition|)
return|return;
if|if
condition|(
name|dest_size
operator|==
literal|1
condition|)
block|{
name|dest_tree
operator|=
name|ffecom_1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dest_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|dest_tree
argument_list|)
expr_stmt|;
name|dest_tree
operator|=
name|ffecom_2
argument_list|(
name|ARRAY_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dest_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|dest_tree
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|source_tree
operator|=
name|ffecom_1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|source_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|source_tree
argument_list|)
expr_stmt|;
name|source_tree
operator|=
name|ffecom_2
argument_list|(
name|ARRAY_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|source_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|source_tree
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|dest_tree
argument_list|,
name|source_tree
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|expr_tree
argument_list|)
expr_stmt|;
return|return;
block|}
name|expr_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|dest_tree
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|expr_tree
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|source_tree
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|expr_tree
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|dest_length
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|expr_tree
argument_list|)
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|source_length
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtCOPY
argument_list|,
name|expr_tree
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|expr_tree
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Must actually concatenate things. */
break|break;
block|}
comment|/* Heavy-duty concatenation. */
block|{
name|int
name|count
init|=
name|ffecom_concat_list_count_
argument_list|(
name|catlist
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|lengths
decl_stmt|;
name|tree
name|items
decl_stmt|;
name|tree
name|length_array
decl_stmt|;
name|tree
name|item_array
decl_stmt|;
name|tree
name|citem
decl_stmt|;
name|tree
name|clength
decl_stmt|;
ifdef|#
directive|ifdef
name|HOHO
name|length_array
operator|=
name|lengths
operator|=
name|ffecom_push_tempvar
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|count
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|item_array
operator|=
name|items
operator|=
name|ffecom_push_tempvar
argument_list|(
name|ffecom_f2c_address_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|count
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|tree
name|hook
decl_stmt|;
name|hook
operator|=
name|ffebld_nonter_hook
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|hook
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|hook
argument_list|)
operator|==
name|TREE_VEC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|hook
argument_list|)
operator|==
literal|2
argument_list|)
expr_stmt|;
name|length_array
operator|=
name|lengths
operator|=
name|TREE_VEC_ELT
argument_list|(
name|hook
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|item_array
operator|=
name|items
operator|=
name|TREE_VEC_ELT
argument_list|(
name|hook
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|ffecom_char_args_
argument_list|(
operator|&
name|citem
argument_list|,
operator|&
name|clength
argument_list|,
name|ffecom_concat_list_expr_
argument_list|(
name|catlist
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|citem
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|clength
operator|==
name|error_mark_node
operator|)
condition|)
block|{
name|ffecom_concat_list_kill_
argument_list|(
name|catlist
argument_list|)
expr_stmt|;
return|return;
block|}
name|items
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|items
argument_list|)
argument_list|,
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|ARRAY_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|item_array
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|item_array
argument_list|,
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|citem
argument_list|)
argument_list|,
name|items
argument_list|)
expr_stmt|;
name|lengths
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lengths
argument_list|)
argument_list|,
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|ARRAY_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|length_array
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|length_array
argument_list|,
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|clength
argument_list|)
argument_list|,
name|lengths
argument_list|)
expr_stmt|;
block|}
name|expr_tree
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|dest_tree
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|expr_tree
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|items
argument_list|)
argument_list|)
argument_list|,
name|items
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|expr_tree
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|lengths
argument_list|)
argument_list|)
argument_list|,
name|lengths
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|expr_tree
argument_list|)
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ffecom_f2c_ptr_to_ftnlen_type_node
argument_list|,
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|build_int_2
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|expr_tree
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|dest_length
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtCAT
argument_list|,
name|expr_tree
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|expr_tree
argument_list|)
expr_stmt|;
block|}
name|ffecom_concat_list_kill_
argument_list|(
name|catlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffecom_make_gfrt_ -- Make initial info for run-time routine     ffecomGfrt ix;    ffecom_make_gfrt_(ix);     Assumes gfrt_[ix] is NULL_TREE, and replaces it with the FUNCTION_DECL    for the indicated run-time routine (ix).  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_make_gfrt_
parameter_list|(
name|ffecomGfrt
name|ix
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|ttype
decl_stmt|;
switch|switch
condition|(
name|ffecom_gfrt_type_
index|[
name|ix
index|]
condition|)
block|{
case|case
name|FFECOM_rttypeVOID_
case|:
name|ttype
operator|=
name|void_type_node
expr_stmt|;
break|break;
case|case
name|FFECOM_rttypeVOIDSTAR_
case|:
name|ttype
operator|=
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
expr_stmt|;
comment|/* `void *'. */
break|break;
case|case
name|FFECOM_rttypeFTNINT_
case|:
name|ttype
operator|=
name|ffecom_f2c_ftnint_type_node
expr_stmt|;
break|break;
case|case
name|FFECOM_rttypeINTEGER_
case|:
name|ttype
operator|=
name|ffecom_f2c_integer_type_node
expr_stmt|;
break|break;
case|case
name|FFECOM_rttypeLONGINT_
case|:
name|ttype
operator|=
name|ffecom_f2c_longint_type_node
expr_stmt|;
break|break;
case|case
name|FFECOM_rttypeLOGICAL_
case|:
name|ttype
operator|=
name|ffecom_f2c_logical_type_node
expr_stmt|;
break|break;
case|case
name|FFECOM_rttypeREAL_F2C_
case|:
name|ttype
operator|=
name|double_type_node
expr_stmt|;
break|break;
case|case
name|FFECOM_rttypeREAL_GNU_
case|:
name|ttype
operator|=
name|float_type_node
expr_stmt|;
break|break;
case|case
name|FFECOM_rttypeCOMPLEX_F2C_
case|:
name|ttype
operator|=
name|void_type_node
expr_stmt|;
break|break;
case|case
name|FFECOM_rttypeCOMPLEX_GNU_
case|:
name|ttype
operator|=
name|ffecom_f2c_complex_type_node
expr_stmt|;
break|break;
case|case
name|FFECOM_rttypeDOUBLE_
case|:
name|ttype
operator|=
name|double_type_node
expr_stmt|;
break|break;
case|case
name|FFECOM_rttypeDOUBLEREAL_
case|:
name|ttype
operator|=
name|ffecom_f2c_doublereal_type_node
expr_stmt|;
break|break;
case|case
name|FFECOM_rttypeDBLCMPLX_F2C_
case|:
name|ttype
operator|=
name|void_type_node
expr_stmt|;
break|break;
case|case
name|FFECOM_rttypeDBLCMPLX_GNU_
case|:
name|ttype
operator|=
name|ffecom_f2c_doublecomplex_type_node
expr_stmt|;
break|break;
case|case
name|FFECOM_rttypeCHARACTER_
case|:
name|ttype
operator|=
name|void_type_node
expr_stmt|;
break|break;
default|default:
name|ttype
operator|=
name|NULL
expr_stmt|;
name|assert
argument_list|(
literal|"bad rttype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|ttype
operator|=
name|build_function_type
argument_list|(
name|ttype
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|ffecom_gfrt_name_
index|[
name|ix
index|]
argument_list|)
argument_list|,
name|ttype
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
name|ffecom_gfrt_const_
index|[
name|ix
index|]
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
name|ffecom_gfrt_volatile_
index|[
name|ix
index|]
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Sanity check:  A function that's const cannot be volatile.  */
name|assert
argument_list|(
name|ffecom_gfrt_const_
index|[
name|ix
index|]
condition|?
operator|!
name|ffecom_gfrt_volatile_
index|[
name|ix
index|]
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* Sanity check: A function that's const cannot return complex.  */
name|assert
argument_list|(
name|ffecom_gfrt_const_
index|[
name|ix
index|]
condition|?
operator|!
name|ffecom_gfrt_complex_
index|[
name|ix
index|]
else|:
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|start_decl
argument_list|(
name|t
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ffecom_gfrt_
index|[
name|ix
index|]
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Phase 1 pass over each member of a COMMON/EQUIVALENCE group.  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_member_phase1_
parameter_list|(
name|ffestorag
name|mst
name|UNUSED
parameter_list|,
name|ffestorag
name|st
parameter_list|)
block|{
name|ffesymbol
name|s
init|=
name|ffestorag_symbol
argument_list|(
name|st
argument_list|)
decl_stmt|;
if|if
condition|(
name|ffesymbol_namelisted
argument_list|(
name|s
argument_list|)
condition|)
name|ffecom_member_namelisted_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Phase 2 pass over each member of a COMMON/EQUIVALENCE group.  Declare    the member so debugger will see it.  Otherwise nobody should be    referencing the member.  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_member_phase2_
parameter_list|(
name|ffestorag
name|mst
parameter_list|,
name|ffestorag
name|st
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|mt
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
operator|(
name|mst
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|mt
operator|=
name|ffestorag_hook
argument_list|(
name|mst
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mt
operator|==
name|error_mark_node
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|st
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|s
operator|=
name|ffestorag_symbol
argument_list|(
name|st
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
return|return;
name|type
operator|=
name|ffecom_type_localvar_
argument_list|(
name|s
argument_list|,
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
name|t
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_identifier_
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|mt
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|t
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|mt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ffestorag_modulo
argument_list|(
name|mst
argument_list|)
operator|+
name|ffestorag_offset
argument_list|(
name|st
argument_list|)
operator|-
name|ffestorag_offset
argument_list|(
name|mst
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|start_decl
argument_list|(
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare source expression for assignment into a destination perhaps known    to be of a specific size.  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_prepare_let_char_
parameter_list|(
name|ffetargetCharacterSize
name|dest_size
parameter_list|,
name|ffebld
name|source
parameter_list|)
block|{
name|ffecomConcatList_
name|catlist
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|ltmp
decl_stmt|;
name|tree
name|itmp
decl_stmt|;
name|tree
name|tempvar
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|ffebld_op
argument_list|(
name|source
argument_list|)
operator|==
name|FFEBLD_opCONVERT
condition|)
name|source
operator|=
name|ffebld_left
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|catlist
operator|=
name|ffecom_concat_list_new_
argument_list|(
name|source
argument_list|,
name|dest_size
argument_list|)
expr_stmt|;
name|count
operator|=
name|ffecom_concat_list_count_
argument_list|(
name|catlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|2
condition|)
block|{
name|ltmp
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"let_char_len"
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|itmp
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"let_char_item"
argument_list|,
name|ffecom_f2c_address_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|tempvar
operator|=
name|make_tree_vec
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|tempvar
argument_list|,
literal|0
argument_list|)
operator|=
name|ltmp
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|tempvar
argument_list|,
literal|1
argument_list|)
operator|=
name|itmp
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|ffecom_prepare_arg_ptr_to_expr
argument_list|(
name|ffecom_concat_list_expr_
argument_list|(
name|catlist
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_concat_list_kill_
argument_list|(
name|catlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempvar
condition|)
block|{
name|ffebld_nonter_set_hook
argument_list|(
name|source
argument_list|,
name|tempvar
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|prep_state
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffecom_push_dummy_decls_ -- Transform dummy args, push parm decls in order     Ignores STAR (alternate-return) dummies.  All other get exec-transitioned    (which generates their trees) and then their trees get push_parm_decl'd.     The second arg is TRUE if the dummies are for a statement function, in    which case lengths are not pushed for character arguments (since they are    always known by both the caller and the callee, though the code allows    for someday permitting CHAR*(*) stmtfunc dummies).  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_push_dummy_decls_
parameter_list|(
name|ffebld
name|dummy_list
parameter_list|,
name|bool
name|stmtfunc
parameter_list|)
block|{
name|ffebld
name|dummy
decl_stmt|;
name|ffebld
name|dumlist
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|ffecom_transform_only_dummies_
operator|=
name|TRUE
expr_stmt|;
comment|/* First push the parms corresponding to actual dummy "contents".  */
for|for
control|(
name|dumlist
operator|=
name|dummy_list
init|;
name|dumlist
operator|!=
name|NULL
condition|;
name|dumlist
operator|=
name|ffebld_trail
argument_list|(
name|dumlist
argument_list|)
control|)
block|{
name|dummy
operator|=
name|ffebld_head
argument_list|(
name|dumlist
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|dummy
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opSTAR
case|:
case|case
name|FFEBLD_opANY
case|:
continue|continue;
comment|/* Forget alternate returns. */
default|default:
break|break;
block|}
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|dummy
argument_list|)
operator|==
name|FFEBLD_opSYMTER
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffebld_symter
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|parm
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
if|if
condition|(
name|parm
operator|==
name|NULL_TREE
condition|)
block|{
name|s
operator|=
name|ffecom_sym_transform_
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|parm
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
name|assert
argument_list|(
name|parm
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parm
operator|!=
name|error_mark_node
condition|)
name|push_parm_decl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
comment|/* Then, for CHARACTER dummies, push the parms giving their lengths.  */
for|for
control|(
name|dumlist
operator|=
name|dummy_list
init|;
name|dumlist
operator|!=
name|NULL
condition|;
name|dumlist
operator|=
name|ffebld_trail
argument_list|(
name|dumlist
argument_list|)
control|)
block|{
name|dummy
operator|=
name|ffebld_head
argument_list|(
name|dumlist
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|dummy
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opSTAR
case|:
case|case
name|FFEBLD_opANY
case|:
continue|continue;
comment|/* Forget alternate returns, they mean 				   NOTHING! */
default|default:
break|break;
block|}
name|s
operator|=
name|ffebld_symter
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_basictypeCHARACTER
condition|)
continue|continue;
comment|/* Only looking for CHARACTER arguments. */
if|if
condition|(
name|stmtfunc
operator|&&
operator|(
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
operator|!=
name|FFETARGET_charactersizeNONE
operator|)
condition|)
continue|continue;
comment|/* Stmtfunc arg with known size needs no 				   length param. */
if|if
condition|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_kindENTITY
condition|)
continue|continue;
comment|/* Only looking for variables and arrays. */
name|parm
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|length_tree
expr_stmt|;
name|assert
argument_list|(
name|parm
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|!=
name|error_mark_node
condition|)
name|push_parm_decl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
name|ffecom_transform_only_dummies_
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffecom_start_progunit_ -- Beginning of program unit     Does GNU back end stuff necessary to teach it about the start of its    equivalent of a Fortran program unit.  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_start_progunit_
parameter_list|()
block|{
name|ffesymbol
name|fn
init|=
name|ffecom_primary_entry_
decl_stmt|;
name|ffebld
name|arglist
decl_stmt|;
name|tree
name|id
decl_stmt|;
comment|/* Identifier (name) of function. */
name|tree
name|type
decl_stmt|;
comment|/* Type of function. */
name|tree
name|result
decl_stmt|;
comment|/* Result of function. */
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|ffeglobal
name|g
decl_stmt|;
name|ffeglobalType
name|gt
decl_stmt|;
name|ffeglobalType
name|egt
init|=
name|FFEGLOBAL_type
decl_stmt|;
name|bool
name|charfunc
decl_stmt|;
name|bool
name|cmplxfunc
decl_stmt|;
name|bool
name|altentries
init|=
operator|(
name|ffecom_num_entrypoints_
operator|!=
literal|0
operator|)
decl_stmt|;
name|bool
name|multi
init|=
name|altentries
operator|&&
operator|(
name|ffecom_primary_entry_kind_
operator|==
name|FFEINFO_kindFUNCTION
operator|)
operator|&&
operator|(
name|ffecom_master_bt_
operator|==
name|FFEINFO_basictypeNONE
operator|)
decl_stmt|;
name|bool
name|main_program
init|=
name|FALSE
decl_stmt|;
name|int
name|old_lineno
init|=
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
name|assert
argument_list|(
name|fn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffesymbol_hook
argument_list|(
name|fn
argument_list|)
operator|.
name|decl_tree
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|ffesymbol_where_filename
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|ffesymbol_where_filelinenum
argument_list|(
name|fn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffecom_primary_entry_kind_
condition|)
block|{
case|case
name|FFEINFO_kindPROGRAM
case|:
name|main_program
operator|=
name|TRUE
expr_stmt|;
name|gt
operator|=
name|FFEGLOBAL_typeMAIN
expr_stmt|;
name|bt
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
name|kt
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
name|type
operator|=
name|ffecom_tree_fun_type_void
expr_stmt|;
name|charfunc
operator|=
name|FALSE
expr_stmt|;
name|cmplxfunc
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindBLOCKDATA
case|:
name|gt
operator|=
name|FFEGLOBAL_typeBDATA
expr_stmt|;
name|bt
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
name|kt
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
name|type
operator|=
name|ffecom_tree_fun_type_void
expr_stmt|;
name|charfunc
operator|=
name|FALSE
expr_stmt|;
name|cmplxfunc
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindFUNCTION
case|:
name|gt
operator|=
name|FFEGLOBAL_typeFUNC
expr_stmt|;
name|egt
operator|=
name|FFEGLOBAL_typeEXT
expr_stmt|;
name|bt
operator|=
name|ffesymbol_basictype
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffesymbol_kindtype
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeNONE
condition|)
block|{
name|ffeimplic_establish_symbol
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_funcresult
argument_list|(
name|fn
argument_list|)
operator|!=
name|NULL
condition|)
name|ffeimplic_establish_symbol
argument_list|(
name|ffesymbol_funcresult
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|bt
operator|=
name|ffesymbol_basictype
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffesymbol_kindtype
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|multi
condition|)
name|charfunc
operator|=
name|cmplxfunc
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
name|charfunc
operator|=
name|TRUE
operator|,
name|cmplxfunc
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bt
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|&&
name|ffesymbol_is_f2c
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|altentries
condition|)
name|charfunc
operator|=
name|FALSE
operator|,
name|cmplxfunc
operator|=
name|TRUE
expr_stmt|;
else|else
name|charfunc
operator|=
name|cmplxfunc
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|multi
operator|||
name|charfunc
condition|)
name|type
operator|=
name|ffecom_tree_fun_type_void
expr_stmt|;
elseif|else
if|if
condition|(
name|ffesymbol_is_f2c
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|altentries
condition|)
name|type
operator|=
name|ffecom_tree_fun_type
index|[
name|bt
index|]
index|[
name|kt
index|]
expr_stmt|;
else|else
name|type
operator|=
name|build_function_type
argument_list|(
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
name|type
operator|=
name|ffecom_tree_fun_type_void
expr_stmt|;
comment|/* _sym_exec_transition. */
break|break;
case|case
name|FFEINFO_kindSUBROUTINE
case|:
name|gt
operator|=
name|FFEGLOBAL_typeSUBR
expr_stmt|;
name|egt
operator|=
name|FFEGLOBAL_typeEXT
expr_stmt|;
name|bt
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
name|kt
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
if|if
condition|(
name|ffecom_is_altreturning_
condition|)
name|type
operator|=
name|ffecom_tree_subr_type
expr_stmt|;
else|else
name|type
operator|=
name|ffecom_tree_fun_type_void
expr_stmt|;
name|charfunc
operator|=
name|FALSE
expr_stmt|;
name|cmplxfunc
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"say what??"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_kindANY
case|:
name|gt
operator|=
name|FFEGLOBAL_typeANY
expr_stmt|;
name|bt
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
name|kt
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
name|charfunc
operator|=
name|FALSE
expr_stmt|;
name|cmplxfunc
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|altentries
condition|)
block|{
name|id
operator|=
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_masterfun_%s"
argument_list|,
name|ffesymbol_text
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|FFETARGET_isENFORCED_MAIN
elseif|else
if|if
condition|(
name|main_program
condition|)
name|id
operator|=
name|get_identifier
argument_list|(
name|FFETARGET_nameENFORCED_MAIN_NAME
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|id
operator|=
name|ffecom_get_external_identifier_
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|start_function
argument_list|(
name|id
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
comment|/* nested/inline */
operator|!
name|altentries
argument_list|)
expr_stmt|;
comment|/* TREE_PUBLIC */
name|TREE_USED
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Avoid spurious warning if altentries. */
if|if
condition|(
operator|!
name|altentries
operator|&&
operator|(
operator|(
name|g
operator|=
name|ffesymbol_global
argument_list|(
name|fn
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|gt
operator|)
operator|||
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|egt
operator|)
operator|)
condition|)
block|{
name|ffeglobal_set_hook
argument_list|(
name|g
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
comment|/* Arg handling needs exec-transitioned ffesymbols to work with.  But      exec-transitioning needs current_function_decl to be filled in.  So we      do these things in two phases. */
if|if
condition|(
name|altentries
condition|)
block|{
comment|/* 1st arg identifies which entrypoint. */
name|ffecom_which_entrypoint_decl_
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_%s"
argument_list|,
literal|"which_entrypoint"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|push_parm_decl
argument_list|(
name|ffecom_which_entrypoint_decl_
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|charfunc
operator|||
name|cmplxfunc
operator|||
name|multi
condition|)
block|{
comment|/* Arg for result (return value). */
name|tree
name|type
decl_stmt|;
name|tree
name|length
decl_stmt|;
if|if
condition|(
name|charfunc
condition|)
name|type
operator|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeCHARACTER
index|]
index|[
name|kt
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|cmplxfunc
condition|)
name|type
operator|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeCOMPLEX
index|]
index|[
name|kt
index|]
expr_stmt|;
else|else
name|type
operator|=
name|ffecom_multi_type_node_
expr_stmt|;
name|result
operator|=
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_%s"
argument_list|,
literal|"result"
argument_list|)
expr_stmt|;
comment|/* Make length arg _and_ enhance type info for CHAR arg itself.  */
if|if
condition|(
name|charfunc
condition|)
name|length
operator|=
name|ffecom_char_enhance_arg_
argument_list|(
operator|&
name|type
argument_list|,
name|fn
argument_list|)
expr_stmt|;
else|else
name|length
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Not ref'd if !charfunc. */
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|result
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|push_parm_decl
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|multi
condition|)
name|ffecom_multi_retval_
operator|=
name|result
expr_stmt|;
else|else
name|ffecom_func_result_
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|charfunc
condition|)
block|{
name|push_parm_decl
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|ffecom_func_length_
operator|=
name|length
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ffecom_primary_entry_is_proc_
condition|)
block|{
if|if
condition|(
name|altentries
condition|)
name|arglist
operator|=
name|ffecom_master_arglist_
expr_stmt|;
else|else
name|arglist
operator|=
name|ffesymbol_dummyargs
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|ffecom_push_dummy_decls_
argument_list|(
name|arglist
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|store_parm_decls
argument_list|(
name|main_program
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|ffecom_start_compstmt
argument_list|()
expr_stmt|;
comment|/* Disallow temp vars at this level.  */
name|current_binding_level
operator|->
name|prep_state
operator|=
literal|2
expr_stmt|;
name|lineno
operator|=
name|old_lineno
expr_stmt|;
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
comment|/* This handles any symbols still untransformed, in case -g specified.      This used to be done in ffecom_finish_progunit, but it turns out to      be necessary to do it here so that statement functions are      expanded before code.  But don't bother for BLOCK DATA.  */
if|if
condition|(
name|ffecom_primary_entry_kind_
operator|!=
name|FFEINFO_kindBLOCKDATA
condition|)
name|ffesymbol_drive
argument_list|(
name|ffecom_finish_symbol_transform_
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffecom_sym_transform_ -- Transform FFE sym into backend sym     ffesymbol s;    ffecom_sym_transform_(s);     The ffesymbol_hook info for s is updated with appropriate backend info    on the symbol.  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffecom_sym_transform_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Transformed thingy. */
name|tree
name|tlen
decl_stmt|;
comment|/* Length if CHAR*(*). */
name|bool
name|addr
decl_stmt|;
comment|/* Is t the address of the thingy? */
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|ffeglobal
name|g
decl_stmt|;
name|int
name|old_lineno
init|=
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
comment|/* Must ensure special ASSIGN variables are declared at top of outermost      block, else they'll end up in the innermost block when their first      ASSIGN is seen, which leaves them out of scope when they're the      subject of a GOTO or I/O statement.       We make this variable even if -fugly-assign.  Just let it go unused,      in case it turns out there are cases where we really want to use this      variable anyway (e.g. ASSIGN to INTEGER*2 variable).  */
if|if
condition|(
operator|!
name|ffecom_transform_only_dummies_
operator|&&
name|ffesymbol_assigned
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|assign_tree
condition|)
name|s
operator|=
name|ffecom_sym_transform_assign_
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_sfdummyparent
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|input_filename
operator|=
name|ffesymbol_where_filename
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|ffesymbol_where_filelinenum
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffesymbol
name|sf
init|=
name|ffesymbol_sfdummyparent
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|input_filename
operator|=
name|ffesymbol_where_filename
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|ffesymbol_where_filelinenum
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|NULL_TREE
expr_stmt|;
name|tlen
operator|=
name|NULL_TREE
expr_stmt|;
name|addr
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_kindNONE
case|:
switch|switch
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereDUMMY
case|:
comment|/* Subroutine or function. */
name|assert
argument_list|(
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
comment|/* Before 0.4, this could be ENTITY/DUMMY, but see 	     ffestu_sym_end_transition -- no longer true (in particular, if 	     it could be an ENTITY, it _will_ be made one, so that 	     possibility won't come through here).  So we never make length 	     arg for CHARACTER type.  */
name|t
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|ffecom_get_identifier_
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|,
name|ffecom_tree_ptr_to_subr_type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereGLOBAL
case|:
comment|/* Subroutine or function. */
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|g
operator|=
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|FFEGLOBAL_typeSUBR
operator|)
operator|||
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|FFEGLOBAL_typeFUNC
operator|)
operator|||
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|FFEGLOBAL_typeEXT
operator|)
operator|)
operator|&&
operator|(
name|ffeglobal_hook
argument_list|(
name|g
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|&&
name|ffe_is_globals
argument_list|()
condition|)
block|{
name|t
operator|=
name|ffeglobal_hook
argument_list|(
name|g
argument_list|)
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|ffecom_get_external_identifier_
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffecom_tree_subr_type
argument_list|)
expr_stmt|;
comment|/* Assume subr. */
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|start_decl
argument_list|(
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|FFEGLOBAL_typeSUBR
operator|)
operator|||
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|FFEGLOBAL_typeFUNC
operator|)
operator|||
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|FFEGLOBAL_typeEXT
operator|)
operator|)
condition|)
name|ffeglobal_set_hook
argument_list|(
name|g
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffecom_save_tree_forever
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"NONE where unexpected"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_whereANY
case|:
break|break;
block|}
break|break;
case|case
name|FFEINFO_kindENTITY
case|:
switch|switch
condition|(
name|ffeinfo_where
argument_list|(
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
comment|/* ~~Debugging info needed? */
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
name|t
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Shouldn't ever see this in expr. */
break|break;
case|case
name|FFEINFO_whereLOCAL
case|:
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
block|{
name|ffestorag
name|st
init|=
name|ffesymbol_storage
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
operator|(
name|st
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffestorag_size
argument_list|(
name|st
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|t
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|ffecom_type_localvar_
argument_list|(
name|s
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|t
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|st
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffestorag_parent
argument_list|(
name|st
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* Child of EQUIVALENCE parent. */
name|ffestorag
name|est
decl_stmt|;
name|tree
name|et
decl_stmt|;
name|ffetargetOffset
name|offset
decl_stmt|;
name|est
operator|=
name|ffestorag_parent
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|ffecom_transform_equiv_
argument_list|(
name|est
argument_list|)
expr_stmt|;
name|et
operator|=
name|ffestorag_hook
argument_list|(
name|est
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|et
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|et
argument_list|)
condition|)
name|put_var_into_stack
argument_list|(
name|et
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ffestorag_modulo
argument_list|(
name|est
argument_list|)
operator|+
name|ffestorag_offset
argument_list|(
name|ffesymbol_storage
argument_list|(
name|s
argument_list|)
argument_list|)
operator|-
name|ffestorag_offset
argument_list|(
name|est
argument_list|)
expr_stmt|;
name|ffecom_debug_kludge_
argument_list|(
name|et
argument_list|,
literal|"EQUIVALENCE"
argument_list|,
name|s
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* (t_type *) (((char *)&et) + offset) */
name|t
operator|=
name|convert
argument_list|(
name|string_type_node
argument_list|,
comment|/* (char *) */
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|et
argument_list|)
argument_list|)
argument_list|,
name|et
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
name|staticp
argument_list|(
name|et
argument_list|)
expr_stmt|;
name|addr
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|tree
name|initexpr
decl_stmt|;
name|bool
name|init
init|=
name|ffesymbol_is_init
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_identifier_
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|||
name|ffesymbol_namelisted
argument_list|(
name|s
argument_list|)
ifdef|#
directive|ifdef
name|FFECOM_sizeMAXSTACKITEM
operator|||
operator|(
operator|(
name|st
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffestorag_size
argument_list|(
name|st
argument_list|)
operator|>
name|FFECOM_sizeMAXSTACKITEM
operator|)
operator|)
endif|#
directive|endif
operator|||
operator|(
operator|(
name|ffecom_primary_entry_kind_
operator|!=
name|FFEINFO_kindPROGRAM
operator|)
operator|&&
operator|(
name|ffecom_primary_entry_kind_
operator|!=
name|FFEINFO_kindBLOCKDATA
operator|)
operator|&&
operator|(
name|ffesymbol_is_save
argument_list|(
name|s
argument_list|)
operator|||
name|ffe_is_saveall
argument_list|()
operator|)
operator|)
condition|)
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
operator|!
name|ffesymbol_attr
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_attrADJUSTABLE
argument_list|)
expr_stmt|;
else|else
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* No need to make static. */
if|if
condition|(
name|init
operator|||
name|ffe_is_init_local_zero
argument_list|()
condition|)
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Keep -Wunused from complaining about var if it 		   is used as sfunc arg or DATA implied-DO.  */
if|if
condition|(
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
operator|&
name|FFESYMBOL_attrsSFARG
condition|)
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|start_decl
argument_list|(
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
name|ffesymbol_init
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
condition|)
name|initexpr
operator|=
name|ffecom_expr
argument_list|(
name|ffesymbol_init
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|initexpr
operator|=
name|ffecom_init_zero_
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffe_is_init_local_zero
argument_list|()
condition|)
name|initexpr
operator|=
name|ffecom_init_zero_
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|initexpr
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Not ref'd if !init. */
name|finish_decl
argument_list|(
name|t
argument_list|,
name|initexpr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|!=
name|NULL
operator|&&
name|DECL_SIZE
argument_list|(
name|t
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
operator|==
name|compare_tree_int
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffestorag_size
argument_list|(
name|st
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|FFEINFO_whereRESULT
case|:
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
block|{
comment|/* Result is already in list of dummies, use 				   it (& length). */
name|t
operator|=
name|ffecom_func_result_
expr_stmt|;
name|tlen
operator|=
name|ffecom_func_length_
expr_stmt|;
name|addr
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ffecom_num_entrypoints_
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bt
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|&&
operator|(
name|ffesymbol_is_f2c
argument_list|(
name|ffecom_primary_entry_
argument_list|)
operator|)
condition|)
block|{
comment|/* Result is already in list of dummies, use 				   it. */
name|t
operator|=
name|ffecom_func_result_
expr_stmt|;
name|addr
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffecom_func_result_
operator|!=
name|NULL_TREE
condition|)
block|{
name|t
operator|=
name|ffecom_func_result_
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ffecom_num_entrypoints_
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ffecom_master_bt_
operator|==
name|FFEINFO_basictypeNONE
operator|)
condition|)
block|{
name|assert
argument_list|(
name|ffecom_multi_retval_
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|ffecom_multi_type_node_
argument_list|,
name|ffecom_multi_retval_
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_2
argument_list|(
name|COMPONENT_REF
argument_list|,
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
argument_list|,
name|t
argument_list|,
name|ffecom_multi_fields_
index|[
name|bt
index|]
index|[
name|kt
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_identifier_
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|,
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Put result on stack. */
name|t
operator|=
name|start_decl
argument_list|(
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffecom_func_result_
operator|=
name|t
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereDUMMY
case|:
block|{
name|tree
name|type
decl_stmt|;
name|ffebld
name|dl
decl_stmt|;
name|ffebld
name|dim
decl_stmt|;
name|tree
name|low
decl_stmt|;
name|tree
name|high
decl_stmt|;
name|tree
name|old_sizes
decl_stmt|;
name|bool
name|adjustable
init|=
name|FALSE
decl_stmt|;
comment|/* Conditionally adjustable? */
name|type
operator|=
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
expr_stmt|;
if|if
condition|(
name|ffesymbol_sfdummyparent
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|current_function_decl
operator|==
name|ffecom_outer_function_decl_
condition|)
block|{
comment|/* Exec transition before sfunc 					   context; get it later. */
break|break;
block|}
name|t
operator|=
name|ffecom_get_identifier_
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffesymbol_sfdummyparent
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|=
name|ffecom_get_identifier_
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
name|old_sizes
operator|=
name|get_pending_sizes
argument_list|()
expr_stmt|;
name|put_pending_sizes
argument_list|(
name|old_sizes
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
name|tlen
operator|=
name|ffecom_char_enhance_arg_
argument_list|(
operator|&
name|type
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffecom_check_size_overflow_
argument_list|(
name|s
argument_list|,
name|type
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|ffesymbol_dims
argument_list|(
name|s
argument_list|)
init|;
name|dl
operator|!=
name|NULL
condition|;
name|dl
operator|=
name|ffebld_trail
argument_list|(
name|dl
argument_list|)
control|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
break|break;
name|dim
operator|=
name|ffebld_head
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|dim
argument_list|)
operator|==
name|FFEBLD_opBOUNDS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffebld_left
argument_list|(
name|dim
argument_list|)
operator|==
name|NULL
operator|)
operator|||
name|ffecom_doing_entry_
condition|)
name|low
operator|=
name|ffecom_integer_one_node
expr_stmt|;
else|else
name|low
operator|=
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|dim
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_right
argument_list|(
name|dim
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffebld_op
argument_list|(
name|ffebld_right
argument_list|(
name|dim
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opSTAR
operator|)
operator|||
name|ffecom_doing_entry_
condition|)
block|{
comment|/* Used to just do high=low.  But for ffecom_tree_ 		       canonize_ref_, it probably is important to correctly 		       assess the size.  E.g. given COMPLEX C(*),CFUNC and 		       C(2)=CFUNC(C), overlap can happen, while it can't 		       for, say, C(1)=CFUNC(C(2)).  */
comment|/* Even more recently used to set to INT_MAX, but that 		       broke when some overflow checking went into the back 		       end.  Now we just leave the upper bound unspecified.  */
name|high
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|high
operator|=
name|ffecom_expr
argument_list|(
name|ffebld_right
argument_list|(
name|dim
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine whether array is conditionally adjustable, 		   to decide whether back-end magic is needed.  		   Normally the front end uses the back-end function 		   variable_size to wrap SAVE_EXPR's around expressions 		   affecting the size/shape of an array so that the 		   size/shape info doesn't change during execution 		   of the compiled code even though variables and 		   functions referenced in those expressions might.  		   variable_size also makes sure those saved expressions 		   get evaluated immediately upon entry to the 		   compiled procedure -- the front end normally doesn't 		   have to worry about that.  		   However, there is a problem with this that affects 		   g77's implementation of entry points, and that is 		   that it is _not_ true that each invocation of the 		   compiled procedure is permitted to evaluate 		   array size/shape info -- because it is possible 		   that, for some invocations, that info is invalid (in 		   which case it is "promised" -- i.e. a violation of 		   the Fortran standard -- that the compiled code 		   won't reference the array or its size/shape 		   during that particular invocation).  		   To phrase this in C terms, consider this gcc function:  		     void foo (int *n, float (*a)[*n]) 		     { 		       // a is "pointer to array ...", fyi. 		     }  		   Suppose that, for some invocations, it is permitted 		   for a caller of foo to do this:  		       foo (NULL, NULL);  		   Now the _written_ code for foo can take such a call 		   into account by either testing explicitly for whether 		   (a == NULL) || (n == NULL) -- presumably it is 		   not permitted to reference *a in various fashions 		   if (n == NULL) I suppose -- or it can avoid it by 		   looking at other info (other arguments, static/global 		   data, etc.).  		   However, this won't work in gcc 2.5.8 because it'll 		   automatically emit the code to save the "*n" 		   expression, which'll yield a NULL dereference for 		   the "foo (NULL, NULL)" call, something the code 		   for foo cannot prevent.  		   g77 definitely needs to avoid executing such 		   code anytime the pointer to the adjustable array 		   is NULL, because even if its bounds expressions 		   don't have any references to possible "absent" 		   variables like "*n" -- say all variable references 		   are to COMMON variables, i.e. global (though in C, 		   local static could actually make sense) -- the 		   expressions could yield other run-time problems 		   for allowably "dead" values in those variables.  		   For example, let's consider a more complicated 		   version of foo:  		     extern int i; 		     extern int j;  		     void foo (float (*a)[i/j]) 		     { 		       ... 		     }  		   The above is (essentially) quite valid for Fortran 		   but, again, for a call like "foo (NULL);", it is 		   permitted for i and j to be undefined when the 		   call is made.  If j happened to be zero, for 		   example, emitting the code to evaluate "i/j" 		   could result in a run-time error.  		   Offhand, though I don't have my F77 or F90 		   standards handy, it might even be valid for a 		   bounds expression to contain a function reference, 		   in which case I doubt it is permitted for an 		   implementation to invoke that function in the 		   Fortran case involved here (invocation of an 		   alternate ENTRY point that doesn't have the adjustable 		   array as one of its arguments).  		   So, the code that the compiler would normally emit 		   to preevaluate the size/shape info for an 		   adjustable array _must not_ be executed at run time 		   in certain cases.  Specifically, for Fortran, 		   the case is when the pointer to the adjustable 		   array == NULL.  (For gnu-ish C, it might be nice 		   for the source code itself to specify an expression 		   that, if TRUE, inhibits execution of the code.  Or 		   reverse the sense for elegance.)  		   (Note that g77 could use a different test than NULL, 		   actually, since it happens to always pass an 		   integer to the called function that specifies which 		   entry point is being invoked.  Hmm, this might 		   solve the next problem.)  		   One way a user could, I suppose, write "foo" so 		   it works is to insert COND_EXPR's for the 		   size/shape info so the dangerous stuff isn't 		   actually done, as in:  		     void foo (int *n, float (*a)[(a == NULL) ? 0 : *n]) 		     { 		       ... 		     }  		   The next problem is that the front end needs to 		   be able to tell the back end about the array's 		   decl _before_ it tells it about the conditional 		   expression to inhibit evaluation of size/shape info, 		   as shown above.  		   To solve this, the front end needs to be able 		   to give the back end the expression to inhibit 		   generation of the preevaluation code _after_ 		   it makes the decl for the adjustable array.  		   Until then, the above example using the COND_EXPR 		   doesn't pass muster with gcc because the "(a == NULL)" 		   part has a reference to "a", which is still 		   undefined at that point.  		   g77 will therefore use a different mechanism in the 		   meantime.  */
if|if
condition|(
operator|!
name|adjustable
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|low
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|||
operator|(
name|high
operator|&&
name|TREE_CODE
argument_list|(
name|high
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|)
condition|)
name|adjustable
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Old approach -- see below. */
block|if (TREE_CODE (low) != INTEGER_CST) 		  low = ffecom_3 (COND_EXPR, integer_type_node, 				  ffecom_adjarray_passed_ (s), 				  low, 				  ffecom_integer_zero_node);  		if (high&& TREE_CODE (high) != INTEGER_CST) 		  high = ffecom_3 (COND_EXPR, integer_type_node, 				   ffecom_adjarray_passed_ (s), 				   high, 				   ffecom_integer_zero_node);
endif|#
directive|endif
comment|/* ~~~gcc/stor-layout.c (layout_type) should do this, 		   probably.  Fixes 950302-1.f.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|low
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|low
operator|=
name|variable_size
argument_list|(
name|low
argument_list|)
expr_stmt|;
comment|/* ~~~Similarly, this fixes dumb0.f.  The C front end 		   does this, which is why dumb0.c would work.  */
if|if
condition|(
name|high
operator|&&
name|TREE_CODE
argument_list|(
name|high
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|high
operator|=
name|variable_size
argument_list|(
name|high
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_array_type
argument_list|(
name|type
argument_list|,
name|build_range_type
argument_list|(
name|ffecom_integer_type_node
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffecom_check_size_overflow_
argument_list|(
name|s
argument_list|,
name|type
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|t
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ffesymbol_sfdummyparent
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
condition|)
block|{
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|addr
operator|=
name|TRUE
expr_stmt|;
block|}
name|t
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|t
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this arg is present in every entry point's list of 	       dummy args, then we're done.  */
if|if
condition|(
name|ffesymbol_numentries
argument_list|(
name|s
argument_list|)
operator|==
operator|(
name|ffecom_num_entrypoints_
operator|+
literal|1
operator|)
condition|)
break|break;
if|#
directive|if
literal|1
comment|/* If variable_size in stor-layout has been called during 	       the above, then get_pending_sizes should have the 	       yet-to-be-evaluated saved expressions pending. 	       Make the whole lot of them get emitted, conditionally 	       on whether the array decl ("t" above) is not NULL.  */
block|{
name|tree
name|sizes
init|=
name|get_pending_sizes
argument_list|()
decl_stmt|;
name|tree
name|tem
decl_stmt|;
for|for
control|(
name|tem
operator|=
name|sizes
init|;
name|tem
operator|!=
name|old_sizes
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
block|{
name|tree
name|temv
init|=
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
decl_stmt|;
if|if
condition|(
name|sizes
operator|==
name|tem
condition|)
name|sizes
operator|=
name|temv
expr_stmt|;
else|else
name|sizes
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sizes
argument_list|)
argument_list|,
name|temv
argument_list|,
name|sizes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sizes
operator|!=
name|tem
condition|)
block|{
name|sizes
operator|=
name|ffecom_3
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sizes
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|t
argument_list|,
name|null_pointer_node
argument_list|)
argument_list|,
name|sizes
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|sizes
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|sizes
operator|=
name|ffecom_save_tree
argument_list|(
name|sizes
argument_list|)
expr_stmt|;
name|sizes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizes
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sizes
condition|)
name|put_pending_sizes
argument_list|(
name|sizes
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
literal|0
block|if (adjustable&& (ffesymbol_numentries (s) 		    != ffecom_num_entrypoints_ + 1)) 	      DECL_SOMETHING (t) 		= ffecom_2 (NE_EXPR, integer_type_node, 			    t, 			    null_pointer_node);
else|#
directive|else
if|#
directive|if
literal|0
block|if (adjustable&& (ffesymbol_numentries (s) 		    != ffecom_num_entrypoints_ + 1)) 	      { 		ffebad_start (FFEBAD_MISSING_ADJARRAY_UNSUPPORTED); 		ffebad_here (0, ffesymbol_where_line (s), 			     ffesymbol_where_column (s)); 		ffebad_string (ffesymbol_text (s)); 		ffebad_finish (); 	      }
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|}
break|break;
case|case
name|FFEINFO_whereCOMMON
case|:
block|{
name|ffesymbol
name|cs
decl_stmt|;
name|ffeglobal
name|cg
decl_stmt|;
name|tree
name|ct
decl_stmt|;
name|ffestorag
name|st
init|=
name|ffesymbol_storage
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|cs
operator|=
name|ffesymbol_common
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* The COMMON area itself.  */
if|if
condition|(
name|st
operator|!=
name|NULL
condition|)
comment|/* Else not laid out. */
block|{
name|ffecom_transform_common_
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|st
operator|=
name|ffesymbol_storage
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|ffecom_type_localvar_
argument_list|(
name|s
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|)
expr_stmt|;
name|cg
operator|=
name|ffesymbol_global
argument_list|(
name|cs
argument_list|)
expr_stmt|;
comment|/* The global COMMON info.  */
if|if
condition|(
operator|(
name|cg
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeglobal_type
argument_list|(
name|cg
argument_list|)
operator|!=
name|FFEGLOBAL_typeCOMMON
operator|)
condition|)
name|ct
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|ct
operator|=
name|ffeglobal_hook
argument_list|(
name|cg
argument_list|)
expr_stmt|;
comment|/* The common area's tree.  */
if|if
condition|(
operator|(
name|ct
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|st
operator|==
name|NULL
operator|)
operator|||
operator|(
name|type
operator|==
name|error_mark_node
operator|)
condition|)
name|t
operator|=
name|error_mark_node
expr_stmt|;
else|else
block|{
name|ffetargetOffset
name|offset
decl_stmt|;
name|ffestorag
name|cst
decl_stmt|;
name|cst
operator|=
name|ffestorag_parent
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cst
operator|==
name|ffesymbol_storage
argument_list|(
name|cs
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ffestorag_modulo
argument_list|(
name|cst
argument_list|)
operator|+
name|ffestorag_offset
argument_list|(
name|st
argument_list|)
operator|-
name|ffestorag_offset
argument_list|(
name|cst
argument_list|)
expr_stmt|;
name|ffecom_debug_kludge_
argument_list|(
name|ct
argument_list|,
literal|"COMMON"
argument_list|,
name|s
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* (t_type *) (((char *)&ct) + offset) */
name|t
operator|=
name|convert
argument_list|(
name|string_type_node
argument_list|,
comment|/* (char *) */
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|ct
argument_list|)
argument_list|)
argument_list|,
name|ct
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
case|case
name|FFEINFO_whereGLOBAL
case|:
case|case
name|FFEINFO_whereFLEETING
case|:
case|case
name|FFEINFO_whereFLEETING_CADDR
case|:
case|case
name|FFEINFO_whereFLEETING_IADDR
case|:
case|case
name|FFEINFO_whereINTRINSIC
case|:
case|case
name|FFEINFO_whereCONSTANT_SUBOBJECT
case|:
default|default:
name|assert
argument_list|(
literal|"ENTITY where unheard of"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_whereANY
case|:
name|t
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_kindFUNCTION
case|:
switch|switch
condition|(
name|ffeinfo_where
argument_list|(
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereLOCAL
case|:
comment|/* Me. */
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
name|t
operator|=
name|current_function_decl
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereGLOBAL
case|:
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|g
operator|=
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|FFEGLOBAL_typeFUNC
operator|)
operator|||
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|FFEGLOBAL_typeEXT
operator|)
operator|)
operator|&&
operator|(
name|ffeglobal_hook
argument_list|(
name|g
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|&&
name|ffe_is_globals
argument_list|()
condition|)
block|{
name|t
operator|=
name|ffeglobal_hook
argument_list|(
name|g
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffesymbol_is_f2c
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
operator|)
condition|)
name|t
operator|=
name|ffecom_tree_fun_type
index|[
name|bt
index|]
index|[
name|kt
index|]
expr_stmt|;
else|else
name|t
operator|=
name|build_function_type
argument_list|(
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|ffecom_get_external_identifier_
argument_list|(
name|s
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|start_decl
argument_list|(
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|FFEGLOBAL_typeFUNC
operator|)
operator|||
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|FFEGLOBAL_typeEXT
operator|)
operator|)
condition|)
name|ffeglobal_set_hook
argument_list|(
name|g
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffecom_save_tree_forever
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereDUMMY
case|:
name|assert
argument_list|(
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_is_f2c
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
operator|)
condition|)
name|t
operator|=
name|ffecom_tree_ptr_to_fun_type
index|[
name|bt
index|]
index|[
name|kt
index|]
expr_stmt|;
else|else
name|t
operator|=
name|build_pointer_type
argument_list|(
name|build_function_type
argument_list|(
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|ffecom_get_identifier_
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereCONSTANT
case|:
comment|/* Statement function. */
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_gen_sfuncdef_
argument_list|(
name|s
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereINTRINSIC
case|:
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
break|break;
comment|/* Let actual references generate their 				   decls. */
default|default:
name|assert
argument_list|(
literal|"FUNCTION where unheard of"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_whereANY
case|:
name|t
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_kindSUBROUTINE
case|:
switch|switch
condition|(
name|ffeinfo_where
argument_list|(
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereLOCAL
case|:
comment|/* Me. */
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
name|t
operator|=
name|current_function_decl
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereGLOBAL
case|:
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|g
operator|=
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|FFEGLOBAL_typeSUBR
operator|)
operator|||
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|FFEGLOBAL_typeEXT
operator|)
operator|)
operator|&&
operator|(
name|ffeglobal_hook
argument_list|(
name|g
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|&&
name|ffe_is_globals
argument_list|()
condition|)
block|{
name|t
operator|=
name|ffeglobal_hook
argument_list|(
name|g
argument_list|)
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|ffecom_get_external_identifier_
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffecom_tree_subr_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|start_decl
argument_list|(
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|FFEGLOBAL_typeSUBR
operator|)
operator|||
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|==
name|FFEGLOBAL_typeEXT
operator|)
operator|)
condition|)
name|ffeglobal_set_hook
argument_list|(
name|g
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffecom_save_tree_forever
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereDUMMY
case|:
name|assert
argument_list|(
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|ffecom_get_identifier_
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|,
name|ffecom_tree_ptr_to_subr_type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereINTRINSIC
case|:
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
break|break;
comment|/* Let actual references generate their 				   decls. */
default|default:
name|assert
argument_list|(
literal|"SUBROUTINE where unheard of"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_whereANY
case|:
name|t
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_kindPROGRAM
case|:
switch|switch
condition|(
name|ffeinfo_where
argument_list|(
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereLOCAL
case|:
comment|/* Me. */
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
name|t
operator|=
name|current_function_decl
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereCOMMON
case|:
case|case
name|FFEINFO_whereDUMMY
case|:
case|case
name|FFEINFO_whereGLOBAL
case|:
case|case
name|FFEINFO_whereRESULT
case|:
case|case
name|FFEINFO_whereFLEETING
case|:
case|case
name|FFEINFO_whereFLEETING_CADDR
case|:
case|case
name|FFEINFO_whereFLEETING_IADDR
case|:
case|case
name|FFEINFO_whereIMMEDIATE
case|:
case|case
name|FFEINFO_whereINTRINSIC
case|:
case|case
name|FFEINFO_whereCONSTANT
case|:
case|case
name|FFEINFO_whereCONSTANT_SUBOBJECT
case|:
default|default:
name|assert
argument_list|(
literal|"PROGRAM where unheard of"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_whereANY
case|:
name|t
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_kindBLOCKDATA
case|:
switch|switch
condition|(
name|ffeinfo_where
argument_list|(
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereLOCAL
case|:
comment|/* Me. */
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
name|t
operator|=
name|current_function_decl
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereGLOBAL
case|:
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|ffecom_get_external_identifier_
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffecom_tree_blockdata_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|start_decl
argument_list|(
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffecom_save_tree_forever
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereCOMMON
case|:
case|case
name|FFEINFO_whereDUMMY
case|:
case|case
name|FFEINFO_whereRESULT
case|:
case|case
name|FFEINFO_whereFLEETING
case|:
case|case
name|FFEINFO_whereFLEETING_CADDR
case|:
case|case
name|FFEINFO_whereFLEETING_IADDR
case|:
case|case
name|FFEINFO_whereIMMEDIATE
case|:
case|case
name|FFEINFO_whereINTRINSIC
case|:
case|case
name|FFEINFO_whereCONSTANT
case|:
case|case
name|FFEINFO_whereCONSTANT_SUBOBJECT
case|:
default|default:
name|assert
argument_list|(
literal|"BLOCKDATA where unheard of"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_whereANY
case|:
name|t
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_kindCOMMON
case|:
switch|switch
condition|(
name|ffeinfo_where
argument_list|(
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereLOCAL
case|:
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
name|ffecom_transform_common_
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereNONE
case|:
case|case
name|FFEINFO_whereCOMMON
case|:
case|case
name|FFEINFO_whereDUMMY
case|:
case|case
name|FFEINFO_whereGLOBAL
case|:
case|case
name|FFEINFO_whereRESULT
case|:
case|case
name|FFEINFO_whereFLEETING
case|:
case|case
name|FFEINFO_whereFLEETING_CADDR
case|:
case|case
name|FFEINFO_whereFLEETING_IADDR
case|:
case|case
name|FFEINFO_whereIMMEDIATE
case|:
case|case
name|FFEINFO_whereINTRINSIC
case|:
case|case
name|FFEINFO_whereCONSTANT
case|:
case|case
name|FFEINFO_whereCONSTANT_SUBOBJECT
case|:
default|default:
name|assert
argument_list|(
literal|"COMMON where unheard of"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_whereANY
case|:
name|t
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_kindCONSTRUCT
case|:
switch|switch
condition|(
name|ffeinfo_where
argument_list|(
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereLOCAL
case|:
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereNONE
case|:
case|case
name|FFEINFO_whereCOMMON
case|:
case|case
name|FFEINFO_whereDUMMY
case|:
case|case
name|FFEINFO_whereGLOBAL
case|:
case|case
name|FFEINFO_whereRESULT
case|:
case|case
name|FFEINFO_whereFLEETING
case|:
case|case
name|FFEINFO_whereFLEETING_CADDR
case|:
case|case
name|FFEINFO_whereFLEETING_IADDR
case|:
case|case
name|FFEINFO_whereIMMEDIATE
case|:
case|case
name|FFEINFO_whereINTRINSIC
case|:
case|case
name|FFEINFO_whereCONSTANT
case|:
case|case
name|FFEINFO_whereCONSTANT_SUBOBJECT
case|:
default|default:
name|assert
argument_list|(
literal|"CONSTRUCT where unheard of"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_whereANY
case|:
name|t
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_kindNAMELIST
case|:
switch|switch
condition|(
name|ffeinfo_where
argument_list|(
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereLOCAL
case|:
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_transform_namelist_
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereNONE
case|:
case|case
name|FFEINFO_whereCOMMON
case|:
case|case
name|FFEINFO_whereDUMMY
case|:
case|case
name|FFEINFO_whereGLOBAL
case|:
case|case
name|FFEINFO_whereRESULT
case|:
case|case
name|FFEINFO_whereFLEETING
case|:
case|case
name|FFEINFO_whereFLEETING_CADDR
case|:
case|case
name|FFEINFO_whereFLEETING_IADDR
case|:
case|case
name|FFEINFO_whereIMMEDIATE
case|:
case|case
name|FFEINFO_whereINTRINSIC
case|:
case|case
name|FFEINFO_whereCONSTANT
case|:
case|case
name|FFEINFO_whereCONSTANT_SUBOBJECT
case|:
default|default:
name|assert
argument_list|(
literal|"NAMELIST where unheard of"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_whereANY
case|:
name|t
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"kind unheard of"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_kindANY
case|:
name|t
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
operator|=
name|t
expr_stmt|;
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|length_tree
operator|=
name|tlen
expr_stmt|;
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|lineno
operator|=
name|old_lineno
expr_stmt|;
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Transform into ASSIGNable symbol.     Symbol has already been transformed, but for whatever reason, the    resulting decl_tree has been deemed not usable for an ASSIGN target.    (E.g. it isn't wide enough to hold a pointer.)  So, here we invent    another local symbol of type void * and stuff that in the assign_tree    argument.  The F77/F90 standards allow this implementation.  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffecom_sym_transform_assign_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Transformed thingy. */
name|int
name|old_lineno
init|=
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
if|if
condition|(
name|ffesymbol_sfdummyparent
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|input_filename
operator|=
name|ffesymbol_where_filename
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|ffesymbol_where_filelinenum
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffesymbol
name|sf
init|=
name|ffesymbol_sfdummyparent
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|input_filename
operator|=
name|ffesymbol_where_filename
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|ffesymbol_where_filelinenum
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
operator|!
name|ffecom_transform_only_dummies_
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_ASSIGN_%s"
argument_list|,
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereLOCAL
case|:
comment|/* Unlike for regular vars, SAVE status is easy to determine for 	 ASSIGNed vars, since there's no initialization, there's no 	 effective storage association (so "SAVE J" does not apply to 	 K even given "EQUIVALENCE (J,K)"), there's no size issue 	 to worry about, etc.  */
if|if
condition|(
operator|(
name|ffesymbol_is_save
argument_list|(
name|s
argument_list|)
operator|||
name|ffe_is_saveall
argument_list|()
operator|)
operator|&&
operator|(
name|ffecom_primary_entry_kind_
operator|!=
name|FFEINFO_kindPROGRAM
operator|)
operator|&&
operator|(
name|ffecom_primary_entry_kind_
operator|!=
name|FFEINFO_kindBLOCKDATA
operator|)
condition|)
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* SAVEd in proc, make static. */
else|else
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* No need to make static. */
break|break;
case|case
name|FFEINFO_whereCOMMON
case|:
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Assume COMMONs always SAVEd. */
break|break;
case|case
name|FFEINFO_whereDUMMY
case|:
comment|/* Note that twinning a DUMMY means the caller won't see 	 the ASSIGNed value.  But both F77 and F90 allow implementations 	 to do this, i.e. disallow Fortran code that would try and 	 take advantage of actually putting a label into a variable 	 via a dummy argument (or any other storage association, for 	 that matter).  */
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|start_decl
argument_list|(
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|assign_tree
operator|=
name|t
expr_stmt|;
name|lineno
operator|=
name|old_lineno
expr_stmt|;
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Implement COMMON area in back end.     Because COMMON-based variables can be referenced in the dimension    expressions of dummy (adjustable) arrays, and because dummies    (in the gcc back end) need to be put in the outer binding level    of a function (which has two binding levels, the outer holding    the dummies and the inner holding the other vars), special care    must be taken to handle COMMON areas.     The current strategy is basically to always tell the back end about    the COMMON area as a top-level external reference to just a block    of storage of the master type of that area (e.g. integer, real,    character, whatever -- not a structure).  As a distinct action,    if initial values are provided, tell the back end about the area    as a top-level non-external (initialized) area and remember not to    allow further initialization or expansion of the area.  Meanwhile,    if no initialization happens at all, tell the back end about    the largest size we've seen declared so the space does get reserved.    (This function doesn't handle all that stuff, but it does some    of the important things.)     Meanwhile, for COMMON variables themselves, just keep creating    references like *((float *) (&common_area + offset)) each time    we reference the variable.  In other words, don't make a VAR_DECL    or any kind of component reference (like we used to do before 0.4),    though we might do that as well just for debugging purposes (and    stuff the rtl with the appropriate offset expression).  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_transform_common_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|ffestorag
name|st
init|=
name|ffesymbol_storage
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|ffeglobal
name|g
init|=
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|tree
name|cbt
decl_stmt|;
name|tree
name|cbtype
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|tree
name|high
decl_stmt|;
name|bool
name|is_init
init|=
name|ffestorag_is_init
argument_list|(
name|st
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|st
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeglobal_type
argument_list|(
name|g
argument_list|)
operator|!=
name|FFEGLOBAL_typeCOMMON
operator|)
condition|)
return|return;
comment|/* First update the size of the area in global terms.  */
name|ffeglobal_size_common
argument_list|(
name|s
argument_list|,
name|ffestorag_size
argument_list|(
name|st
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffeglobal_common_init
argument_list|(
name|g
argument_list|)
condition|)
name|is_init
operator|=
name|FALSE
expr_stmt|;
comment|/* No explicit init, don't let erroneous joins init. */
name|cbt
operator|=
name|ffeglobal_hook
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* If we already have declared this common block for a previous program      unit, and either we already initialized it or we don't have new      initialization for it, just return what we have without changing it.  */
if|if
condition|(
operator|(
name|cbt
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
operator|!
name|is_init
operator|||
operator|!
name|DECL_EXTERNAL
argument_list|(
name|cbt
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|st
operator|->
name|hook
operator|==
name|NULL
condition|)
name|ffestorag_set_hook
argument_list|(
name|st
argument_list|,
name|cbt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Process inits.  */
if|if
condition|(
name|is_init
condition|)
block|{
if|if
condition|(
name|ffestorag_init
argument_list|(
name|st
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ffebld
name|sexp
decl_stmt|;
comment|/* Set the padding for the expression, so ffecom_expr 	     knows to insert that many zeros.  */
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|sexp
operator|=
name|ffestorag_init
argument_list|(
name|st
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opCONTER
case|:
name|ffebld_conter_set_pad
argument_list|(
name|sexp
argument_list|,
name|ffestorag_modulo
argument_list|(
name|st
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opARRTER
case|:
name|ffebld_arrter_set_pad
argument_list|(
name|sexp
argument_list|,
name|ffestorag_modulo
argument_list|(
name|st
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opACCTER
case|:
name|ffebld_accter_set_pad
argument_list|(
name|sexp
argument_list|,
name|ffestorag_modulo
argument_list|(
name|st
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad op for cmn init (pad)"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|init
operator|=
name|ffecom_expr
argument_list|(
name|sexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Hopefully the back end complained! */
name|init
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|cbt
operator|!=
name|NULL_TREE
condition|)
return|return;
block|}
block|}
else|else
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|init
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* cbtype must be permanently allocated!  */
comment|/* Allocate the MAX of the areas so far, seen filewide.  */
name|high
operator|=
name|build_int_2
argument_list|(
operator|(
name|ffeglobal_common_size
argument_list|(
name|g
argument_list|)
operator|+
name|ffeglobal_common_pad
argument_list|(
name|g
argument_list|)
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|high
argument_list|)
operator|=
name|ffecom_integer_type_node
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|cbtype
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_range_type
argument_list|(
name|integer_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|high
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cbtype
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbt
operator|==
name|NULL_TREE
condition|)
block|{
name|cbt
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_external_identifier_
argument_list|(
name|s
argument_list|)
argument_list|,
name|cbtype
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|cbt
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|cbt
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|is_init
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|cbt
argument_list|)
operator|=
name|cbtype
expr_stmt|;
block|}
name|DECL_EXTERNAL
argument_list|(
name|cbt
argument_list|)
operator|=
name|init
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|cbt
argument_list|)
operator|=
name|init
condition|?
name|error_mark_node
else|:
name|NULL_TREE
expr_stmt|;
name|cbt
operator|=
name|start_decl
argument_list|(
name|cbt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffeglobal_hook
argument_list|(
name|g
argument_list|)
operator|!=
name|NULL
condition|)
name|assert
argument_list|(
name|cbt
operator|==
name|ffeglobal_hook
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|init
operator|||
operator|!
name|DECL_EXTERNAL
argument_list|(
name|cbt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure that any type can live in COMMON and be referenced      without getting a bus error.  We could pick the most restrictive      alignment of all entities actually placed in the COMMON, but      this seems easy enough.  */
name|DECL_ALIGN
argument_list|(
name|cbt
argument_list|)
operator|=
name|BIGGEST_ALIGNMENT
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|cbt
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_init
operator|&&
operator|(
name|ffestorag_init
argument_list|(
name|st
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|init
operator|=
name|ffecom_init_zero_
argument_list|(
name|cbt
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|cbt
argument_list|,
name|init
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_init
condition|)
name|ffestorag_set_init
argument_list|(
name|st
argument_list|,
name|ffebld_new_any
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
block|{
name|assert
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|cbt
argument_list|)
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|cbt
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
operator|==
name|compare_tree_int
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|cbt
argument_list|)
argument_list|,
operator|(
name|ffeglobal_common_size
argument_list|(
name|g
argument_list|)
operator|+
name|ffeglobal_common_pad
argument_list|(
name|g
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffeglobal_set_hook
argument_list|(
name|g
argument_list|,
name|cbt
argument_list|)
expr_stmt|;
name|ffestorag_set_hook
argument_list|(
name|st
argument_list|,
name|cbt
argument_list|)
expr_stmt|;
name|ffecom_save_tree_forever
argument_list|(
name|cbt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make master area for local EQUIVALENCE.  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_transform_equiv_
parameter_list|(
name|ffestorag
name|eqst
parameter_list|)
block|{
name|tree
name|eqt
decl_stmt|;
name|tree
name|eqtype
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|tree
name|high
decl_stmt|;
name|bool
name|is_init
init|=
name|ffestorag_is_init
argument_list|(
name|eqst
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|eqst
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|eqt
operator|=
name|ffestorag_hook
argument_list|(
name|eqst
argument_list|)
expr_stmt|;
if|if
condition|(
name|eqt
operator|!=
name|NULL_TREE
condition|)
return|return;
comment|/* Process inits.  */
if|if
condition|(
name|is_init
condition|)
block|{
if|if
condition|(
name|ffestorag_init
argument_list|(
name|eqst
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ffebld
name|sexp
decl_stmt|;
comment|/* Set the padding for the expression, so ffecom_expr 	     knows to insert that many zeros.  */
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|sexp
operator|=
name|ffestorag_init
argument_list|(
name|eqst
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opCONTER
case|:
name|ffebld_conter_set_pad
argument_list|(
name|sexp
argument_list|,
name|ffestorag_modulo
argument_list|(
name|eqst
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opARRTER
case|:
name|ffebld_arrter_set_pad
argument_list|(
name|sexp
argument_list|,
name|ffestorag_modulo
argument_list|(
name|eqst
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opACCTER
case|:
name|ffebld_accter_set_pad
argument_list|(
name|sexp
argument_list|,
name|ffestorag_modulo
argument_list|(
name|eqst
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad op for eqv init (pad)"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|init
operator|=
name|ffecom_expr
argument_list|(
name|sexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Hopefully the back end complained! */
block|}
else|else
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffe_is_init_local_zero
argument_list|()
condition|)
name|init
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|init
operator|=
name|NULL_TREE
expr_stmt|;
name|ffecom_member_namelisted_
operator|=
name|FALSE
expr_stmt|;
name|ffestorag_drive
argument_list|(
name|ffestorag_list_equivs
argument_list|(
name|eqst
argument_list|)
argument_list|,
operator|&
name|ffecom_member_phase1_
argument_list|,
name|eqst
argument_list|)
expr_stmt|;
name|high
operator|=
name|build_int_2
argument_list|(
operator|(
name|ffestorag_size
argument_list|(
name|eqst
argument_list|)
operator|+
name|ffestorag_modulo
argument_list|(
name|eqst
argument_list|)
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|high
argument_list|)
operator|=
name|ffecom_integer_type_node
expr_stmt|;
name|eqtype
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_range_type
argument_list|(
name|ffecom_integer_type_node
argument_list|,
name|ffecom_integer_zero_node
argument_list|,
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|eqt
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_equiv_%s"
argument_list|,
name|ffesymbol_text
argument_list|(
name|ffestorag_symbol
argument_list|(
name|eqst
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|eqtype
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|eqt
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_init
operator|||
name|ffecom_member_namelisted_
ifdef|#
directive|ifdef
name|FFECOM_sizeMAXSTACKITEM
operator|||
operator|(
name|ffestorag_size
argument_list|(
name|eqst
argument_list|)
operator|>
name|FFECOM_sizeMAXSTACKITEM
operator|)
endif|#
directive|endif
operator|||
operator|(
operator|(
name|ffecom_primary_entry_kind_
operator|!=
name|FFEINFO_kindPROGRAM
operator|)
operator|&&
operator|(
name|ffecom_primary_entry_kind_
operator|!=
name|FFEINFO_kindBLOCKDATA
operator|)
operator|&&
operator|(
name|ffestorag_is_save
argument_list|(
name|eqst
argument_list|)
operator|||
name|ffe_is_saveall
argument_list|()
operator|)
operator|)
condition|)
name|TREE_STATIC
argument_list|(
name|eqt
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|TREE_STATIC
argument_list|(
name|eqt
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|eqt
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|eqt
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Ensure non-register allocation */
name|DECL_CONTEXT
argument_list|(
name|eqt
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|DECL_INITIAL
argument_list|(
name|eqt
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|DECL_INITIAL
argument_list|(
name|eqt
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|eqt
operator|=
name|start_decl
argument_list|(
name|eqt
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Make sure that any type can live in EQUIVALENCE and be referenced      without getting a bus error.  We could pick the most restrictive      alignment of all entities actually placed in the EQUIVALENCE, but      this seems easy enough.  */
name|DECL_ALIGN
argument_list|(
name|eqt
argument_list|)
operator|=
name|BIGGEST_ALIGNMENT
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|eqt
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|is_init
operator|&&
name|ffe_is_init_local_zero
argument_list|()
operator|)
operator|||
operator|(
name|is_init
operator|&&
operator|(
name|ffestorag_init
argument_list|(
name|eqst
argument_list|)
operator|==
name|NULL
operator|)
operator|)
condition|)
name|init
operator|=
name|ffecom_init_zero_
argument_list|(
name|eqt
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|eqt
argument_list|,
name|init
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_init
condition|)
name|ffestorag_set_init
argument_list|(
name|eqst
argument_list|,
name|ffebld_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|eqt
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
operator|==
name|compare_tree_int
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|eqt
argument_list|)
argument_list|,
operator|(
name|ffestorag_size
argument_list|(
name|eqst
argument_list|)
operator|+
name|ffestorag_modulo
argument_list|(
name|eqst
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffestorag_set_hook
argument_list|(
name|eqst
argument_list|,
name|eqt
argument_list|)
expr_stmt|;
name|ffestorag_drive
argument_list|(
name|ffestorag_list_equivs
argument_list|(
name|eqst
argument_list|)
argument_list|,
operator|&
name|ffecom_member_phase2_
argument_list|,
name|eqst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement NAMELIST in back end.  See f2c/format.c for more info.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_transform_namelist_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|tree
name|nmlt
decl_stmt|;
name|tree
name|nmltype
init|=
name|ffecom_type_namelist_
argument_list|()
decl_stmt|;
name|tree
name|nmlinits
decl_stmt|;
name|tree
name|nameinit
decl_stmt|;
name|tree
name|varsinit
decl_stmt|;
name|tree
name|nvarsinit
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|tree
name|high
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|mynumber
init|=
literal|0
decl_stmt|;
name|nmlt
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_namelist_%d"
argument_list|,
name|mynumber
operator|++
argument_list|)
argument_list|,
name|nmltype
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|nmlt
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|nmlt
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|nmlt
operator|=
name|start_decl
argument_list|(
name|nmlt
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Process inits.  */
name|i
operator|=
name|strlen
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|high
operator|=
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|high
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
name|nameinit
operator|=
name|ffecom_build_f2c_string_
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|nameinit
argument_list|)
operator|=
name|build_type_variant
argument_list|(
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_range_type
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|ffecom_f2c_ftnlen_one_node
argument_list|,
name|high
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|nameinit
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|nameinit
argument_list|)
operator|=
literal|1
expr_stmt|;
name|nameinit
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|nameinit
argument_list|)
argument_list|)
argument_list|,
name|nameinit
argument_list|)
expr_stmt|;
name|varsinit
operator|=
name|ffecom_vardesc_array_
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|varsinit
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|varsinit
argument_list|)
argument_list|)
argument_list|,
name|varsinit
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|varsinit
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|varsinit
argument_list|)
operator|=
literal|1
expr_stmt|;
block|{
name|ffebld
name|b
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|b
operator|=
name|ffesymbol_namelist
argument_list|(
name|s
argument_list|)
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|ffebld_trail
argument_list|(
name|b
argument_list|)
control|)
operator|++
name|i
expr_stmt|;
block|}
name|nvarsinit
operator|=
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|nvarsinit
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|nvarsinit
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|nvarsinit
argument_list|)
operator|=
literal|1
expr_stmt|;
name|nmlinits
operator|=
name|build_tree_list
argument_list|(
operator|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|nmltype
argument_list|)
operator|)
argument_list|,
name|nameinit
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|nmlinits
argument_list|)
operator|=
name|build_tree_list
argument_list|(
operator|(
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|)
argument_list|,
name|varsinit
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|nmlinits
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
operator|(
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|)
argument_list|,
name|nvarsinit
argument_list|)
expr_stmt|;
name|nmlinits
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|nmltype
argument_list|,
name|NULL_TREE
argument_list|,
name|nmlinits
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|nmlinits
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|nmlinits
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|nmlt
argument_list|,
name|nmlinits
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|nmlt
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|nmltype
argument_list|)
argument_list|,
name|nmlt
argument_list|)
expr_stmt|;
return|return
name|nmlt
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of ffecom_tree_canonize_ref_.  The incoming tree is    analyzed on the assumption it is calculating a pointer to be    indirected through.  It must return the proper decl and offset,    taking into account different units of measurements for offsets.  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_tree_canonize_ptr_
parameter_list|(
name|tree
modifier|*
name|decl
parameter_list|,
name|tree
modifier|*
name|offset
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
name|ffecom_tree_canonize_ptr_
argument_list|(
name|decl
argument_list|,
name|offset
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
name|ffecom_tree_canonize_ptr_
argument_list|(
name|decl
argument_list|,
name|offset
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|decl
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
operator|*
name|decl
operator|==
name|error_mark_node
operator|)
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* An offset into COMMON.  */
operator|*
name|offset
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|offset
argument_list|)
argument_list|,
operator|*
name|offset
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert offset (presumably in bytes) into canonical units 	     (presumably bits).  */
operator|*
name|offset
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|convert
argument_list|(
name|bitsizetype
argument_list|,
operator|*
name|offset
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Not a COMMON reference, so an unrecognized pattern.  */
operator|*
name|decl
operator|=
name|error_mark_node
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
operator|*
name|decl
operator|=
name|t
expr_stmt|;
operator|*
name|offset
operator|=
name|bitsize_zero_node
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* A reference to COMMON.  */
operator|*
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|bitsize_zero_node
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
default|default:
comment|/* Not a COMMON reference, so an unrecognized pattern.  */
operator|*
name|decl
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given a tree that is possibly intended for use as an lvalue, return    information representing a canonical view of that tree as a decl, an    offset into that decl, and a size for the lvalue.     If there's no applicable decl, NULL_TREE is returned for the decl,    and the other fields are left undefined.     If the tree doesn't fit the recognizable forms, an ERROR_MARK node    is returned for the decl, and the other fields are left undefined.     Otherwise, the decl returned currently is either a VAR_DECL or a    PARM_DECL.     The offset returned is always valid, but of course not necessarily    a constant, and not necessarily converted into the appropriate    type, leaving that up to the caller (so as to avoid that overhead    if the decls being looked at are different anyway).     If the size cannot be determined (e.g. an adjustable array),    an ERROR_MARK node is returned for the size.  Otherwise, the    size returned is valid, not necessarily a constant, and not    necessarily converted into the appropriate type as with the    offset.     Note that the offset and size expressions are expressed in the    base storage units (usually bits) rather than in the units of    the type of the decl, because two decls with different types    might overlap but with apparently non-overlapping array offsets,    whereas converting the array offsets to consistant offsets will    reveal the overlap.  */
end_comment

begin_function
specifier|static
name|void
name|ffecom_tree_canonize_ref_
parameter_list|(
name|tree
modifier|*
name|decl
parameter_list|,
name|tree
modifier|*
name|offset
parameter_list|,
name|tree
modifier|*
name|size
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
comment|/* The default path is to report a nonexistant decl.  */
operator|*
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|CONST_DECL
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|FFS_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|COMPLEX_EXPR
case|:
case|case
name|CONJ_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|LABEL_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
return|return;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
operator|*
name|decl
operator|=
name|t
expr_stmt|;
operator|*
name|offset
operator|=
name|bitsize_zero_node
expr_stmt|;
operator|*
name|size
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_REF
case|:
block|{
name|tree
name|array
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|element
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|init_offset
decl_stmt|;
if|if
condition|(
operator|(
name|array
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|element
operator|==
name|NULL_TREE
operator|)
condition|)
block|{
operator|*
name|decl
operator|=
name|error_mark_node
expr_stmt|;
return|return;
block|}
name|ffecom_tree_canonize_ref_
argument_list|(
name|decl
argument_list|,
operator|&
name|init_offset
argument_list|,
name|size
argument_list|,
name|array
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|decl
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
operator|*
name|decl
operator|==
name|error_mark_node
operator|)
condition|)
return|return;
comment|/* Calculate ((element - base) * NBBY) + init_offset.  */
operator|*
name|offset
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
argument_list|,
name|element
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|convert
argument_list|(
name|bitsizetype
argument_list|,
operator|*
name|offset
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|init_offset
argument_list|,
operator|*
name|offset
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|INDIRECT_REF
case|:
comment|/* Most of this code is to handle references to COMMON.  And so 	 far that is useful only for calling library functions, since 	 external (user) functions might reference common areas.  But 	 even calling an external function, it's worthwhile to decode 	 COMMON references because if not storing into COMMON, we don't 	 want COMMON-based arguments to gratuitously force use of a 	 temporary.  */
operator|*
name|size
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_canonize_ptr_
argument_list|(
name|decl
argument_list|,
name|offset
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|COND_EXPR
case|:
comment|/* More cases than we can handle. */
case|case
name|SAVE_EXPR
case|:
case|case
name|REFERENCE_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|CALL_EXPR
case|:
default|default:
operator|*
name|decl
operator|=
name|error_mark_node
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Do divide operation appropriate to type of operands.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_tree_divide_
parameter_list|(
name|tree
name|tree_type
parameter_list|,
name|tree
name|left
parameter_list|,
name|tree
name|right
parameter_list|,
name|tree
name|dest_tree
parameter_list|,
name|ffebld
name|dest
parameter_list|,
name|bool
modifier|*
name|dest_used
parameter_list|,
name|tree
name|hook
parameter_list|)
block|{
if|if
condition|(
operator|(
name|left
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|right
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|tree_type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
return|return
name|ffecom_2
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|tree_type
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
case|case
name|COMPLEX_TYPE
case|:
if|if
condition|(
operator|!
name|optimize_size
condition|)
return|return
name|ffecom_2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|tree_type
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|{
name|ffecomGfrt
name|ix
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|tree_type
argument_list|)
operator|==
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeREAL
index|]
index|[
name|FFEINFO_kindtypeREAL1
index|]
condition|)
name|ix
operator|=
name|FFECOM_gfrtDIV_CC
expr_stmt|;
comment|/* Overlapping result okay. */
else|else
name|ix
operator|=
name|FFECOM_gfrtDIV_ZZ
expr_stmt|;
comment|/* Overlapping result okay. */
name|left
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|left
argument_list|)
argument_list|)
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|left
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|right
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|right
argument_list|)
argument_list|)
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|right
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|left
argument_list|)
operator|=
name|right
expr_stmt|;
return|return
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|ix
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|ix
argument_list|)
argument_list|,
name|ffe_is_f2c_library
argument_list|()
argument_list|,
name|tree_type
argument_list|,
name|left
argument_list|,
name|dest_tree
argument_list|,
name|dest
argument_list|,
name|dest_used
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|hook
argument_list|)
return|;
block|}
break|break;
case|case
name|RECORD_TYPE
case|:
block|{
name|ffecomGfrt
name|ix
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|tree_type
argument_list|)
argument_list|)
operator|==
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeREAL
index|]
index|[
name|FFEINFO_kindtypeREAL1
index|]
condition|)
name|ix
operator|=
name|FFECOM_gfrtDIV_CC
expr_stmt|;
comment|/* Overlapping result okay. */
else|else
name|ix
operator|=
name|FFECOM_gfrtDIV_ZZ
expr_stmt|;
comment|/* Overlapping result okay. */
name|left
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|left
argument_list|)
argument_list|)
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|left
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|right
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|right
argument_list|)
argument_list|)
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|right
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|left
argument_list|)
operator|=
name|right
expr_stmt|;
return|return
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|ix
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|ix
argument_list|)
argument_list|,
name|ffe_is_f2c_library
argument_list|()
argument_list|,
name|tree_type
argument_list|,
name|left
argument_list|,
name|dest_tree
argument_list|,
name|dest
argument_list|,
name|dest_used
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|hook
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|ffecom_2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|tree_type
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Build type info for non-dummy variable.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_type_localvar_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|ffebld
name|dl
decl_stmt|;
name|ffebld
name|dim
decl_stmt|;
name|tree
name|lowt
decl_stmt|;
name|tree
name|hight
decl_stmt|;
name|type
operator|=
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
expr_stmt|;
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
block|{
name|hight
operator|=
name|build_int_2
argument_list|(
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|hight
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
name|type
operator|=
name|build_array_type
argument_list|(
name|type
argument_list|,
name|build_range_type
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|ffecom_f2c_ftnlen_one_node
argument_list|,
name|hight
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffecom_check_size_overflow_
argument_list|(
name|s
argument_list|,
name|type
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|dl
operator|=
name|ffesymbol_dims
argument_list|(
name|s
argument_list|)
init|;
name|dl
operator|!=
name|NULL
condition|;
name|dl
operator|=
name|ffebld_trail
argument_list|(
name|dl
argument_list|)
control|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
break|break;
name|dim
operator|=
name|ffebld_head
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|dim
argument_list|)
operator|==
name|FFEBLD_opBOUNDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_left
argument_list|(
name|dim
argument_list|)
operator|==
name|NULL
condition|)
name|lowt
operator|=
name|integer_one_node
expr_stmt|;
else|else
name|lowt
operator|=
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|dim
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lowt
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|lowt
operator|=
name|variable_size
argument_list|(
name|lowt
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_right
argument_list|(
name|dim
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|hight
operator|=
name|ffecom_expr
argument_list|(
name|ffebld_right
argument_list|(
name|dim
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|hight
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|hight
operator|=
name|variable_size
argument_list|(
name|hight
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_array_type
argument_list|(
name|type
argument_list|,
name|build_range_type
argument_list|(
name|ffecom_integer_type_node
argument_list|,
name|lowt
argument_list|,
name|hight
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffecom_check_size_overflow_
argument_list|(
name|s
argument_list|,
name|type
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Build Namelist type.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_type_namelist_
parameter_list|()
block|{
specifier|static
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
block|{
specifier|static
name|tree
name|namefield
decl_stmt|,
name|varsfield
decl_stmt|,
name|nvarsfield
decl_stmt|;
name|tree
name|vardesctype
decl_stmt|;
name|vardesctype
operator|=
name|ffecom_type_vardesc_
argument_list|()
expr_stmt|;
name|type
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|vardesctype
operator|=
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|vardesctype
argument_list|)
argument_list|)
expr_stmt|;
name|namefield
operator|=
name|ffecom_decl_field
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|,
literal|"name"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|varsfield
operator|=
name|ffecom_decl_field
argument_list|(
name|type
argument_list|,
name|namefield
argument_list|,
literal|"vars"
argument_list|,
name|vardesctype
argument_list|)
expr_stmt|;
name|nvarsfield
operator|=
name|ffecom_decl_field
argument_list|(
name|type
argument_list|,
name|varsfield
argument_list|,
literal|"nvars"
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|namefield
expr_stmt|;
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Build Vardesc type.  */
end_comment

begin_function
specifier|static
name|tree
name|ffecom_type_vardesc_
parameter_list|()
block|{
specifier|static
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
specifier|static
name|tree
name|namefield
decl_stmt|,
name|addrfield
decl_stmt|,
name|dimsfield
decl_stmt|,
name|typefield
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
block|{
name|type
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|namefield
operator|=
name|ffecom_decl_field
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|,
literal|"name"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|addrfield
operator|=
name|ffecom_decl_field
argument_list|(
name|type
argument_list|,
name|namefield
argument_list|,
literal|"addr"
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|dimsfield
operator|=
name|ffecom_decl_field
argument_list|(
name|type
argument_list|,
name|addrfield
argument_list|,
literal|"dims"
argument_list|,
name|ffecom_f2c_ptr_to_ftnlen_type_node
argument_list|)
expr_stmt|;
name|typefield
operator|=
name|ffecom_decl_field
argument_list|(
name|type
argument_list|,
name|dimsfield
argument_list|,
literal|"type"
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|namefield
expr_stmt|;
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|ffecom_vardesc_
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opSYMTER
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|vardesc_tree
operator|==
name|NULL_TREE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|vardesctype
init|=
name|ffecom_type_vardesc_
argument_list|()
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|tree
name|nameinit
decl_stmt|;
name|tree
name|dimsinit
decl_stmt|;
name|tree
name|addrinit
decl_stmt|;
name|tree
name|typeinit
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|tree
name|varinits
decl_stmt|;
specifier|static
name|int
name|mynumber
init|=
literal|0
decl_stmt|;
name|var
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_vardesc_%d"
argument_list|,
name|mynumber
operator|++
argument_list|)
argument_list|,
name|vardesctype
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|var
operator|=
name|start_decl
argument_list|(
name|var
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Process inits.  */
name|nameinit
operator|=
name|ffecom_build_f2c_string_
argument_list|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
operator|)
operator|+
literal|1
argument_list|,
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|nameinit
argument_list|)
operator|=
name|build_type_variant
argument_list|(
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_range_type
argument_list|(
name|integer_type_node
argument_list|,
name|integer_one_node
argument_list|,
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|nameinit
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|nameinit
argument_list|)
operator|=
literal|1
expr_stmt|;
name|nameinit
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|nameinit
argument_list|)
argument_list|)
argument_list|,
name|nameinit
argument_list|)
expr_stmt|;
name|addrinit
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|expr
argument_list|,
operator|&
name|typeinit
argument_list|)
expr_stmt|;
name|dimsinit
operator|=
name|ffecom_vardesc_dims_
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|typeinit
operator|==
name|NULL_TREE
condition|)
block|{
name|ffeinfoBasictype
name|bt
init|=
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|ffeinfoKindtype
name|kt
init|=
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|tc
init|=
name|ffecom_f2c_typecode
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|tc
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|typeinit
operator|=
name|build_int_2
argument_list|(
name|tc
argument_list|,
operator|(
name|tc
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|typeinit
operator|=
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|typeinit
argument_list|)
argument_list|,
name|typeinit
argument_list|)
expr_stmt|;
name|varinits
operator|=
name|build_tree_list
argument_list|(
operator|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|vardesctype
argument_list|)
operator|)
argument_list|,
name|nameinit
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|varinits
argument_list|)
operator|=
name|build_tree_list
argument_list|(
operator|(
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|)
argument_list|,
name|addrinit
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|varinits
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
operator|(
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|)
argument_list|,
name|dimsinit
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|varinits
argument_list|)
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
operator|(
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|)
argument_list|,
name|typeinit
argument_list|)
expr_stmt|;
name|varinits
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|vardesctype
argument_list|,
name|NULL_TREE
argument_list|,
name|varinits
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|varinits
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|varinits
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|var
argument_list|,
name|varinits
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|var
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|vardesctype
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|vardesc_tree
operator|=
name|var
expr_stmt|;
block|}
return|return
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|vardesc_tree
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|ffecom_vardesc_array_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|ffebld
name|b
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|tree
name|item
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|mynumber
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|list
operator|=
name|NULL_TREE
operator|,
name|b
operator|=
name|ffesymbol_namelist
argument_list|(
name|s
argument_list|)
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|ffebld_trail
argument_list|(
name|b
argument_list|)
operator|,
operator|++
name|i
control|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|ffecom_vardesc_
argument_list|(
name|ffebld_head
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL_TREE
condition|)
name|list
operator|=
name|item
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|item
operator|=
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
name|item
operator|=
name|build_array_type
argument_list|(
name|build_pointer_type
argument_list|(
name|ffecom_type_vardesc_
argument_list|()
argument_list|)
argument_list|,
name|build_range_type
argument_list|(
name|integer_type_node
argument_list|,
name|integer_one_node
argument_list|,
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|item
argument_list|,
name|NULL_TREE
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|list
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|list
argument_list|)
operator|=
literal|1
expr_stmt|;
name|var
operator|=
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_vardesc_array_%d"
argument_list|,
name|mynumber
operator|++
argument_list|)
expr_stmt|;
name|var
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|var
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|var
operator|=
name|start_decl
argument_list|(
name|var
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|var
argument_list|,
name|list
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|var
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|ffecom_vardesc_dims_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
if|if
condition|(
name|ffesymbol_dims
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|convert
argument_list|(
name|ffecom_f2c_ptr_to_ftnlen_type_node
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|{
name|ffebld
name|b
decl_stmt|;
name|ffebld
name|e
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|tree
name|backlist
decl_stmt|;
name|tree
name|item
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|tree
name|numdim
decl_stmt|;
name|tree
name|numelem
decl_stmt|;
name|tree
name|baseoff
init|=
name|NULL_TREE
decl_stmt|;
specifier|static
name|int
name|mynumber
init|=
literal|0
decl_stmt|;
name|numdim
operator|=
name|build_int_2
argument_list|(
operator|(
name|int
operator|)
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|numdim
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
name|numelem
operator|=
name|ffecom_expr
argument_list|(
name|ffesymbol_arraysize
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|numelem
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
name|list
operator|=
name|NULL_TREE
expr_stmt|;
name|backlist
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|b
operator|=
name|ffesymbol_dims
argument_list|(
name|s
argument_list|)
operator|,
name|e
operator|=
name|ffesymbol_extents
argument_list|(
name|s
argument_list|)
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|ffebld_trail
argument_list|(
name|b
argument_list|)
operator|,
name|e
operator|=
name|ffebld_trail
argument_list|(
name|e
argument_list|)
control|)
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|low
decl_stmt|;
name|tree
name|back
decl_stmt|;
if|if
condition|(
name|ffebld_trail
argument_list|(
name|b
argument_list|)
operator|==
name|NULL
condition|)
name|t
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|t
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|ffecom_expr
argument_list|(
name|ffebld_head
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL_TREE
condition|)
name|list
operator|=
name|item
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|item
operator|=
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ffebld_left
argument_list|(
name|ffebld_head
argument_list|(
name|b
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
name|low
operator|=
name|ffecom_integer_one_node
expr_stmt|;
else|else
name|low
operator|=
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|ffebld_head
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|low
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|low
argument_list|)
expr_stmt|;
name|back
operator|=
name|build_tree_list
argument_list|(
name|low
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|back
argument_list|)
operator|=
name|backlist
expr_stmt|;
name|backlist
operator|=
name|back
expr_stmt|;
block|}
for|for
control|(
name|item
operator|=
name|backlist
init|;
name|item
operator|!=
name|NULL_TREE
condition|;
name|item
operator|=
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|item
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|baseoff
operator|=
name|TREE_PURPOSE
argument_list|(
name|item
argument_list|)
expr_stmt|;
else|else
name|baseoff
operator|=
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|item
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|MULT_EXPR
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|TREE_VALUE
argument_list|(
name|item
argument_list|)
argument_list|,
name|baseoff
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* backlist now dead, along with all TREE_PURPOSEs on it.  */
name|baseoff
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|baseoff
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|baseoff
argument_list|)
operator|=
name|list
expr_stmt|;
name|numelem
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|numelem
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|numelem
argument_list|)
operator|=
name|baseoff
expr_stmt|;
name|numdim
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|numdim
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|numdim
argument_list|)
operator|=
name|numelem
expr_stmt|;
name|item
operator|=
name|build_array_type
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|build_range_type
argument_list|(
name|integer_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|build_int_2
argument_list|(
operator|(
name|int
operator|)
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|item
argument_list|,
name|NULL_TREE
argument_list|,
name|numdim
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|list
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|list
argument_list|)
operator|=
literal|1
expr_stmt|;
name|var
operator|=
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_dims_%d"
argument_list|,
name|mynumber
operator|++
argument_list|)
expr_stmt|;
name|var
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|var
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|var
operator|=
name|start_decl
argument_list|(
name|var
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|var
argument_list|,
name|list
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|var
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|item
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
return|return
name|var
return|;
block|}
block|}
end_function

begin_comment
comment|/* Essentially does a "fold (build1 (code, type, node))" while checking    for certain housekeeping things.     NOTE: for building an ADDR_EXPR around a FUNCTION_DECL, use    ffecom_1_fn instead.  */
end_comment

begin_function
name|tree
name|ffecom_1
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|node
parameter_list|)
block|{
name|tree
name|item
decl_stmt|;
if|if
condition|(
operator|(
name|node
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|type
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|mark_addressable
argument_list|(
name|node
argument_list|)
condition|)
name|assert
argument_list|(
literal|"can't mark_addressable this node!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ffe_is_emulate_complex
argument_list|()
condition|?
name|code
else|:
name|NOP_EXPR
condition|)
block|{
name|tree
name|realtype
decl_stmt|;
case|case
name|REALPART_EXPR
case|:
name|item
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|type
argument_list|,
name|node
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMAGPART_EXPR
case|:
name|item
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|type
argument_list|,
name|node
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
block|{
name|item
operator|=
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
name|node
operator|=
name|ffecom_stabilize_aggregate_
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|realtype
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|realtype
argument_list|,
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node
argument_list|)
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|realtype
argument_list|,
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|item
operator|=
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|node
argument_list|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|item
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
operator|&&
name|staticp
argument_list|(
name|node
argument_list|)
condition|)
name|TREE_CONSTANT
argument_list|(
name|item
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|INDIRECT_REF
condition|)
name|TREE_READONLY
argument_list|(
name|item
argument_list|)
operator|=
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like ffecom_1 (ADDR_EXPR, TREE_TYPE (node), node), except    handles TREE_CODE (node) == FUNCTION_DECL.  In particular,    does not set TREE_ADDRESSABLE (because calling an inline    function does not mean the function needs to be separately    compiled).  */
end_comment

begin_function
name|tree
name|ffecom_1_fn
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
name|tree
name|item
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|node
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|node
argument_list|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|item
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|staticp
argument_list|(
name|node
argument_list|)
condition|)
name|TREE_CONSTANT
argument_list|(
name|item
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|fold
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Essentially does a "fold (build (code, type, node1, node2))" while    checking for certain housekeeping things.  */
end_comment

begin_function
name|tree
name|ffecom_2
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|node1
parameter_list|,
name|tree
name|node2
parameter_list|)
block|{
name|tree
name|item
decl_stmt|;
if|if
condition|(
operator|(
name|node1
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|node2
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|type
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|ffe_is_emulate_complex
argument_list|()
condition|?
name|code
else|:
name|NOP_EXPR
condition|)
block|{
name|tree
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|realtype
decl_stmt|;
case|case
name|CONJ_EXPR
case|:
name|assert
argument_list|(
literal|"no CONJ_EXPR support yet"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|COMPLEX_EXPR
case|:
name|item
operator|=
name|build_tree_list
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
name|node1
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|node2
argument_list|)
expr_stmt|;
name|item
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|item
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
block|{
name|item
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|node1
argument_list|,
name|node2
argument_list|)
expr_stmt|;
break|break;
block|}
name|node1
operator|=
name|ffecom_stabilize_aggregate_
argument_list|(
name|node1
argument_list|)
expr_stmt|;
name|node2
operator|=
name|ffecom_stabilize_aggregate_
argument_list|(
name|node2
argument_list|)
expr_stmt|;
name|realtype
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|realtype
argument_list|,
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node1
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node2
argument_list|)
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|realtype
argument_list|,
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node1
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
block|{
name|item
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|node1
argument_list|,
name|node2
argument_list|)
expr_stmt|;
break|break;
block|}
name|node1
operator|=
name|ffecom_stabilize_aggregate_
argument_list|(
name|node1
argument_list|)
expr_stmt|;
name|node2
operator|=
name|ffecom_stabilize_aggregate_
argument_list|(
name|node2
argument_list|)
expr_stmt|;
name|realtype
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|realtype
argument_list|,
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node1
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node2
argument_list|)
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|realtype
argument_list|,
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node1
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
block|{
name|item
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|node1
argument_list|,
name|node2
argument_list|)
expr_stmt|;
break|break;
block|}
name|node1
operator|=
name|ffecom_stabilize_aggregate_
argument_list|(
name|node1
argument_list|)
expr_stmt|;
name|node2
operator|=
name|ffecom_stabilize_aggregate_
argument_list|(
name|node2
argument_list|)
expr_stmt|;
name|realtype
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|save_expr
argument_list|(
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node1
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|save_expr
argument_list|(
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node1
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|save_expr
argument_list|(
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node2
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|save_expr
argument_list|(
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node2
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|ffecom_2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|realtype
argument_list|,
name|ffecom_2
argument_list|(
name|MULT_EXPR
argument_list|,
name|realtype
argument_list|,
name|a
argument_list|,
name|c
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|MULT_EXPR
argument_list|,
name|realtype
argument_list|,
name|b
argument_list|,
name|d
argument_list|)
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|realtype
argument_list|,
name|ffecom_2
argument_list|(
name|MULT_EXPR
argument_list|,
name|realtype
argument_list|,
name|a
argument_list|,
name|d
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|MULT_EXPR
argument_list|,
name|realtype
argument_list|,
name|c
argument_list|,
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|node1
argument_list|)
operator|!=
name|RECORD_TYPE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|node2
argument_list|)
operator|!=
name|RECORD_TYPE
operator|)
condition|)
block|{
name|item
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|node1
argument_list|,
name|node2
argument_list|)
expr_stmt|;
break|break;
block|}
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|node1
argument_list|)
operator|==
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|node2
argument_list|)
operator|==
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|node1
operator|=
name|ffecom_stabilize_aggregate_
argument_list|(
name|node1
argument_list|)
expr_stmt|;
name|node2
operator|=
name|ffecom_stabilize_aggregate_
argument_list|(
name|node2
argument_list|)
expr_stmt|;
name|realtype
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_2
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|ffecom_2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node1
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node2
argument_list|)
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node1
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|node1
argument_list|)
operator|!=
name|RECORD_TYPE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|node2
argument_list|)
operator|!=
name|RECORD_TYPE
operator|)
condition|)
block|{
name|item
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|node1
argument_list|,
name|node2
argument_list|)
expr_stmt|;
break|break;
block|}
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|node1
argument_list|)
operator|==
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|node2
argument_list|)
operator|==
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|node1
operator|=
name|ffecom_stabilize_aggregate_
argument_list|(
name|node1
argument_list|)
expr_stmt|;
name|node2
operator|=
name|ffecom_stabilize_aggregate_
argument_list|(
name|node2
argument_list|)
expr_stmt|;
name|realtype
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_2
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|type
argument_list|,
name|ffecom_2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node1
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node2
argument_list|)
argument_list|)
argument_list|,
name|ffecom_2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node1
argument_list|)
argument_list|,
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|realtype
argument_list|,
name|node2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|item
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|node1
argument_list|,
name|node2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|node1
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|node2
argument_list|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|item
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|fold
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffecom_2pass_advise_entrypoint -- Advise that there's this entrypoint     ffesymbol s;	 // the ENTRY point itself    if (ffecom_2pass_advise_entrypoint(s))        // the ENTRY point has been accepted     Does whatever compiler needs to do when it learns about the entrypoint,    like determine the return type of the master function, count the    number of entrypoints, etc.	Returns FALSE if the return type is    not compatible with the return type(s) of other entrypoint(s).     NOTE: for every call to this fn that returns TRUE, _do_entrypoint must    later (after _finish_progunit) be called with the same entrypoint(s)    as passed to this fn for which TRUE was returned.     03-Jan-92  JCB  2.0       Return FALSE if the return type conflicts with previous entrypoints.  */
end_comment

begin_function
name|bool
name|ffecom_2pass_advise_entrypoint
parameter_list|(
name|ffesymbol
name|entry
parameter_list|)
block|{
name|ffebld
name|list
decl_stmt|;
comment|/* opITEM. */
name|ffebld
name|mlist
decl_stmt|;
comment|/* opITEM. */
name|ffebld
name|plist
decl_stmt|;
comment|/* opITEM. */
name|ffebld
name|arg
decl_stmt|;
comment|/* ffebld_head(opITEM). */
name|ffebld
name|item
decl_stmt|;
comment|/* opITEM. */
name|ffesymbol
name|s
decl_stmt|;
comment|/* ffebld_symter(arg). */
name|ffeinfoBasictype
name|bt
init|=
name|ffesymbol_basictype
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|ffeinfoKindtype
name|kt
init|=
name|ffesymbol_kindtype
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|ffetargetCharacterSize
name|size
init|=
name|ffesymbol_size
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
if|if
condition|(
name|ffecom_num_entrypoints_
operator|==
literal|0
condition|)
block|{
comment|/* First entrypoint, make list of main 				   arglist's dummies. */
name|assert
argument_list|(
name|ffecom_primary_entry_
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffecom_master_bt_
operator|=
name|ffesymbol_basictype
argument_list|(
name|ffecom_primary_entry_
argument_list|)
expr_stmt|;
name|ffecom_master_kt_
operator|=
name|ffesymbol_kindtype
argument_list|(
name|ffecom_primary_entry_
argument_list|)
expr_stmt|;
name|ffecom_master_size_
operator|=
name|ffesymbol_size
argument_list|(
name|ffecom_primary_entry_
argument_list|)
expr_stmt|;
for|for
control|(
name|plist
operator|=
name|NULL
operator|,
name|list
operator|=
name|ffesymbol_dummyargs
argument_list|(
name|ffecom_primary_entry_
argument_list|)
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
name|arg
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|arg
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
condition|)
continue|continue;
comment|/* Alternate return or some such thing. */
name|item
operator|=
name|ffebld_new_item
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|plist
operator|==
name|NULL
condition|)
name|ffecom_master_arglist_
operator|=
name|item
expr_stmt|;
else|else
name|ffebld_set_trail
argument_list|(
name|plist
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|plist
operator|=
name|item
expr_stmt|;
block|}
block|}
comment|/* If necessary, scan entry arglist for alternate returns.  Do this scan      apparently redundantly (it's done below to UNIONize the arglists) so      that we don't complain about RETURN 1 if an offending ENTRY is the only      one with an alternate return.  */
if|if
condition|(
operator|!
name|ffecom_is_altreturning_
condition|)
block|{
for|for
control|(
name|list
operator|=
name|ffesymbol_dummyargs
argument_list|(
name|entry
argument_list|)
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
name|arg
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|arg
argument_list|)
operator|==
name|FFEBLD_opSTAR
condition|)
block|{
name|ffecom_is_altreturning_
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Now check type compatibility. */
switch|switch
condition|(
name|ffecom_master_bt_
condition|)
block|{
case|case
name|FFEINFO_basictypeNONE
case|:
name|ok
operator|=
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|ok
operator|=
operator|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
operator|&&
operator|(
name|kt
operator|==
name|ffecom_master_kt_
operator|)
operator|&&
operator|(
name|size
operator|==
name|ffecom_master_size_
operator|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|FALSE
return|;
comment|/* Just don't bother. */
default|default:
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|ok
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|bt
operator|!=
name|ffecom_master_bt_
operator|)
operator|||
operator|(
name|kt
operator|!=
name|ffecom_master_kt_
operator|)
condition|)
block|{
name|ffecom_master_bt_
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
name|ffecom_master_kt_
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_ENTRY_CONFLICTS
argument_list|)
expr_stmt|;
name|ffest_ffebad_here_current_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* Can't handle entrypoint. */
block|}
comment|/* Entrypoint type compatible with previous types. */
operator|++
name|ffecom_num_entrypoints_
expr_stmt|;
comment|/* Master-arg-list = UNION(Master-arg-list,entry-arg-list). */
for|for
control|(
name|list
operator|=
name|ffesymbol_dummyargs
argument_list|(
name|entry
argument_list|)
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
name|arg
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|arg
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
condition|)
continue|continue;
comment|/* Alternate return or some such thing. */
name|s
operator|=
name|ffebld_symter
argument_list|(
name|arg
argument_list|)
expr_stmt|;
for|for
control|(
name|plist
operator|=
name|NULL
operator|,
name|mlist
operator|=
name|ffecom_master_arglist_
init|;
name|mlist
operator|!=
name|NULL
condition|;
name|plist
operator|=
name|mlist
operator|,
name|mlist
operator|=
name|ffebld_trail
argument_list|(
name|mlist
argument_list|)
control|)
block|{
comment|/* plist points to previous item for easy 				   appending of arg. */
if|if
condition|(
name|ffebld_symter
argument_list|(
name|ffebld_head
argument_list|(
name|mlist
argument_list|)
argument_list|)
operator|==
name|s
condition|)
break|break;
comment|/* Already have this arg in the master list. */
block|}
if|if
condition|(
name|mlist
operator|!=
name|NULL
condition|)
continue|continue;
comment|/* Already have this arg in the master list. */
comment|/* Append this arg to the master list. */
name|item
operator|=
name|ffebld_new_item
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|plist
operator|==
name|NULL
condition|)
name|ffecom_master_arglist_
operator|=
name|item
expr_stmt|;
else|else
name|ffebld_set_trail
argument_list|(
name|plist
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ffecom_2pass_do_entrypoint -- Do compilation of entrypoint     ffesymbol s;	 // the ENTRY point itself    ffecom_2pass_do_entrypoint(s);     Does whatever compiler needs to do to make the entrypoint actually    happen.  Must be called for each entrypoint after    ffecom_finish_progunit is called.  */
end_comment

begin_function
name|void
name|ffecom_2pass_do_entrypoint
parameter_list|(
name|ffesymbol
name|entry
parameter_list|)
block|{
specifier|static
name|int
name|mfn_num
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|ent_num
decl_stmt|;
if|if
condition|(
name|mfn_num
operator|!=
name|ffecom_num_fns_
condition|)
block|{
comment|/* First entrypoint for this program unit. */
name|ent_num
operator|=
literal|1
expr_stmt|;
name|mfn_num
operator|=
name|ffecom_num_fns_
expr_stmt|;
name|ffecom_do_entry_
argument_list|(
name|ffecom_primary_entry_
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
operator|++
name|ent_num
expr_stmt|;
operator|--
name|ffecom_num_entrypoints_
expr_stmt|;
name|ffecom_do_entry_
argument_list|(
name|entry
argument_list|,
name|ent_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Essentially does a "fold (build (code, type, node1, node2))" while    checking for certain housekeeping things.  Always sets    TREE_SIDE_EFFECTS.  */
end_comment

begin_function
name|tree
name|ffecom_2s
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|node1
parameter_list|,
name|tree
name|node2
parameter_list|)
block|{
name|tree
name|item
decl_stmt|;
if|if
condition|(
operator|(
name|node1
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|node2
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|type
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
name|item
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|node1
argument_list|,
name|node2
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|item
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|fold
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Essentially does a "fold (build (code, type, node1, node2, node3))" while    checking for certain housekeeping things.  */
end_comment

begin_function
name|tree
name|ffecom_3
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|node1
parameter_list|,
name|tree
name|node2
parameter_list|,
name|tree
name|node3
parameter_list|)
block|{
name|tree
name|item
decl_stmt|;
if|if
condition|(
operator|(
name|node1
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|node2
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|node3
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|type
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
name|item
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|node1
argument_list|,
name|node2
argument_list|,
name|node3
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|node1
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|node2
argument_list|)
operator|||
operator|(
name|node3
operator|!=
name|NULL_TREE
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|node3
argument_list|)
operator|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|item
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|fold
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Essentially does a "fold (build (code, type, node1, node2, node3))" while    checking for certain housekeeping things.  Always sets    TREE_SIDE_EFFECTS.  */
end_comment

begin_function
name|tree
name|ffecom_3s
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|node1
parameter_list|,
name|tree
name|node2
parameter_list|,
name|tree
name|node3
parameter_list|)
block|{
name|tree
name|item
decl_stmt|;
if|if
condition|(
operator|(
name|node1
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|node2
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|node3
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|type
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
name|item
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|node1
argument_list|,
name|node2
argument_list|,
name|node3
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|item
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|fold
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffecom_arg_expr -- Transform argument expr into gcc tree     See use by ffecom_list_expr.     If expression is NULL, returns an integer zero tree.	 If it is not    a CHARACTER expression, returns whatever ffecom_expr    returns and sets the length return value to NULL_TREE.  Otherwise    generates code to evaluate the character expression, returns the proper    pointer to the result, but does NOT set the length return value to a tree    that specifies the length of the result.  (In other words, the length    variable is always set to NULL_TREE, because a length is never passed.)     21-Dec-91  JCB  1.1       Don't set returned length, since nobody needs it (yet; someday if       we allow CHARACTER*(*) dummies to statement functions, we'll need       it).  */
end_comment

begin_function
name|tree
name|ffecom_arg_expr
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|tree
modifier|*
name|length
parameter_list|)
block|{
name|tree
name|ign
decl_stmt|;
operator|*
name|length
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return
name|integer_zero_node
return|;
if|if
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_basictypeCHARACTER
condition|)
return|return
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
return|;
return|return
name|ffecom_arg_ptr_to_expr
argument_list|(
name|expr
argument_list|,
operator|&
name|ign
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Transform expression into constant argument-pointer-to-expression tree.     If the expression can be transformed into a argument-pointer-to-expression    tree that is constant, that is done, and the tree returned.  Else    NULL_TREE is returned.     That way, a caller can attempt to provide compile-time initialization    of a variable and, if that fails, *then* choose to start a new block    and resort to using temporaries, as appropriate.  */
end_comment

begin_function
name|tree
name|ffecom_arg_ptr_to_const_expr
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|tree
modifier|*
name|length
parameter_list|)
block|{
if|if
condition|(
operator|!
name|expr
condition|)
return|return
name|integer_zero_node
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
block|{
if|if
condition|(
name|length
condition|)
operator|*
name|length
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|ffebld_arity
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|||
name|ffebld_where
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEINFO_whereCOMMON
operator|||
name|ffebld_where
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEINFO_whereGLOBAL
operator|||
name|ffebld_where
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEINFO_whereINTRINSIC
operator|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|expr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|length
operator|||
name|TREE_CONSTANT
argument_list|(
operator|*
name|length
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|length
operator|&&
name|ffebld_size
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFETARGET_charactersizeNONE
condition|)
operator|*
name|length
operator|=
name|build_int_2
argument_list|(
name|ffebld_size
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|length
condition|)
operator|*
name|length
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* ffecom_arg_ptr_to_expr -- Transform argument expr into gcc tree     See use by ffecom_list_ptr_to_expr.     If expression is NULL, returns an integer zero tree.	 If it is not    a CHARACTER expression, returns whatever ffecom_ptr_to_expr    returns and sets the length return value to NULL_TREE.  Otherwise    generates code to evaluate the character expression, returns the proper    pointer to the result, AND sets the length return value to a tree that    specifies the length of the result.     If the length argument is NULL, this is a slightly special    case of building a FORMAT expression, that is, an expression that    will be used at run time without regard to length.  For the current    implementation, which uses the libf2c library, this means it is nice    to append a null byte to the end of the expression, where feasible,    to make sure any diagnostic about the FORMAT string terminates at    some useful point.     For now, treat %REF(char-expr) as the same as char-expr with a NULL    length argument.  This might even be seen as a feature, if a null    byte can always be appended.  */
end_comment

begin_function
name|tree
name|ffecom_arg_ptr_to_expr
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|tree
modifier|*
name|length
parameter_list|)
block|{
name|tree
name|item
decl_stmt|;
name|tree
name|ign_length
decl_stmt|;
name|ffecomConcatList_
name|catlist
decl_stmt|;
if|if
condition|(
name|length
operator|!=
name|NULL
condition|)
operator|*
name|length
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return
name|integer_zero_node
return|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opPERCENT_VAL
case|:
if|if
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_basictypeCHARACTER
condition|)
return|return
name|ffecom_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
block|{
name|tree
name|temp_exp
decl_stmt|;
name|tree
name|temp_length
decl_stmt|;
name|temp_exp
operator|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|,
operator|&
name|temp_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|ffecom_1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|temp_exp
argument_list|)
argument_list|)
argument_list|,
name|temp_exp
argument_list|)
return|;
block|}
case|case
name|FFEBLD_opPERCENT_REF
case|:
if|if
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_basictypeCHARACTER
condition|)
return|return
name|ffecom_ptr_to_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|length
operator|!=
name|NULL
condition|)
block|{
name|ign_length
operator|=
name|NULL_TREE
expr_stmt|;
name|length
operator|=
operator|&
name|ign_length
expr_stmt|;
block|}
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opPERCENT_DESCR
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PASS_HOLLERITH_BY_DESCRIPTOR
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
endif|#
directive|endif
case|case
name|FFEINFO_basictypeCHARACTER
case|:
break|break;
comment|/* Passed by descriptor anyway. */
default|default:
name|item
operator|=
name|ffecom_ptr_to_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|error_mark_node
condition|)
operator|*
name|length
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
ifdef|#
directive|ifdef
name|PASS_HOLLERITH_BY_DESCRIPTOR
if|if
condition|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeHOLLERITH
operator|)
operator|&&
operator|(
name|length
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* Pass Hollerith by descriptor. */
name|ffetargetHollerith
name|h
decl_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|h
operator|=
name|ffebld_cu_val_hollerith
argument_list|(
name|ffebld_constant_union
argument_list|(
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|length
operator|=
name|build_int_2
argument_list|(
name|h
operator|.
name|length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|length
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_basictypeCHARACTER
condition|)
return|return
name|ffecom_ptr_to_expr
argument_list|(
name|expr
argument_list|)
return|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeCHARACTER1
argument_list|)
expr_stmt|;
while|while
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opPAREN
condition|)
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|catlist
operator|=
name|ffecom_concat_list_new_
argument_list|(
name|expr
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffecom_concat_list_count_
argument_list|(
name|catlist
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Shouldn't happen, but in case it does... */
if|if
condition|(
name|length
operator|!=
name|NULL
condition|)
block|{
operator|*
name|length
operator|=
name|ffecom_f2c_ftnlen_zero_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|length
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
block|}
name|ffecom_concat_list_kill_
argument_list|(
name|catlist
argument_list|)
expr_stmt|;
return|return
name|null_pointer_node
return|;
case|case
literal|1
case|:
comment|/* The (fairly) easy case. */
if|if
condition|(
name|length
operator|==
name|NULL
condition|)
name|ffecom_char_args_with_null_
argument_list|(
operator|&
name|item
argument_list|,
operator|&
name|ign_length
argument_list|,
name|ffecom_concat_list_expr_
argument_list|(
name|catlist
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ffecom_char_args_
argument_list|(
operator|&
name|item
argument_list|,
name|length
argument_list|,
name|ffecom_concat_list_expr_
argument_list|(
name|catlist
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_concat_list_kill_
argument_list|(
name|catlist
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|item
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|item
return|;
default|default:
comment|/* Must actually concatenate things. */
break|break;
block|}
block|{
name|int
name|count
init|=
name|ffecom_concat_list_count_
argument_list|(
name|catlist
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|lengths
decl_stmt|;
name|tree
name|items
decl_stmt|;
name|tree
name|length_array
decl_stmt|;
name|tree
name|item_array
decl_stmt|;
name|tree
name|citem
decl_stmt|;
name|tree
name|clength
decl_stmt|;
name|tree
name|temporary
decl_stmt|;
name|tree
name|num
decl_stmt|;
name|tree
name|known_length
decl_stmt|;
name|ffetargetCharacterSize
name|sz
decl_stmt|;
name|sz
operator|=
name|ffecom_concat_list_maxlen_
argument_list|(
name|catlist
argument_list|)
expr_stmt|;
comment|/* ~~Kludge! */
name|assert
argument_list|(
name|sz
operator|!=
name|FFETARGET_charactersizeNONE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HOHO
name|length_array
operator|=
name|lengths
operator|=
name|ffecom_push_tempvar
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|count
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|item_array
operator|=
name|items
operator|=
name|ffecom_push_tempvar
argument_list|(
name|ffecom_f2c_address_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|count
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|temporary
operator|=
name|ffecom_push_tempvar
argument_list|(
name|char_type_node
argument_list|,
name|sz
argument_list|,
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|tree
name|hook
decl_stmt|;
name|hook
operator|=
name|ffebld_nonter_hook
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|hook
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|hook
argument_list|)
operator|==
name|TREE_VEC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|hook
argument_list|)
operator|==
literal|3
argument_list|)
expr_stmt|;
name|length_array
operator|=
name|lengths
operator|=
name|TREE_VEC_ELT
argument_list|(
name|hook
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|item_array
operator|=
name|items
operator|=
name|TREE_VEC_ELT
argument_list|(
name|hook
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|temporary
operator|=
name|TREE_VEC_ELT
argument_list|(
name|hook
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|known_length
operator|=
name|ffecom_f2c_ftnlen_zero_node
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|==
name|count
operator|)
operator|&&
operator|(
name|length
operator|==
name|NULL
operator|)
condition|)
name|ffecom_char_args_with_null_
argument_list|(
operator|&
name|citem
argument_list|,
operator|&
name|clength
argument_list|,
name|ffecom_concat_list_expr_
argument_list|(
name|catlist
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ffecom_char_args_
argument_list|(
operator|&
name|citem
argument_list|,
operator|&
name|clength
argument_list|,
name|ffecom_concat_list_expr_
argument_list|(
name|catlist
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|citem
operator|==
name|error_mark_node
operator|)
operator|||
operator|(
name|clength
operator|==
name|error_mark_node
operator|)
condition|)
block|{
name|ffecom_concat_list_kill_
argument_list|(
name|catlist
argument_list|)
expr_stmt|;
operator|*
name|length
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|items
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|items
argument_list|)
argument_list|,
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|ARRAY_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|item_array
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|item_array
argument_list|,
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|citem
argument_list|)
argument_list|,
name|items
argument_list|)
expr_stmt|;
name|clength
operator|=
name|ffecom_save_tree
argument_list|(
name|clength
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|NULL
condition|)
name|known_length
operator|=
name|ffecom_2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|known_length
argument_list|,
name|clength
argument_list|)
expr_stmt|;
name|lengths
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lengths
argument_list|)
argument_list|,
name|ffecom_modify
argument_list|(
name|void_type_node
argument_list|,
name|ffecom_2
argument_list|(
name|ARRAY_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|length_array
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|length_array
argument_list|,
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|clength
argument_list|)
argument_list|,
name|lengths
argument_list|)
expr_stmt|;
block|}
name|temporary
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|temporary
argument_list|)
argument_list|)
argument_list|,
name|temporary
argument_list|)
expr_stmt|;
name|item
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|temporary
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|items
argument_list|)
argument_list|)
argument_list|,
name|items
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|lengths
argument_list|)
argument_list|)
argument_list|,
name|lengths
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ffecom_f2c_ptr_to_ftnlen_type_node
argument_list|,
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|build_int_2
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|num
operator|=
name|build_int_2
argument_list|(
name|sz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|num
argument_list|)
operator|=
name|ffecom_f2c_ftnlen_type_node
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_call_gfrt
argument_list|(
name|FFECOM_gfrtCAT
argument_list|,
name|item
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|item
argument_list|)
operator|=
literal|1
expr_stmt|;
name|item
operator|=
name|ffecom_2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|temporary
argument_list|)
argument_list|,
name|item
argument_list|,
name|temporary
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|NULL
condition|)
operator|*
name|length
operator|=
name|known_length
expr_stmt|;
block|}
name|ffecom_concat_list_kill_
argument_list|(
name|catlist
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|item
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
end_function

begin_comment
comment|/* Generate call to run-time function.     The first arg is the GNU Fortran Run-Time function index, the second    arg is the list of arguments to pass to it.	Returned is the expression    (WITHOUT TREE_SIDE_EFFECTS set!) that makes the call and returns the    result (which may be void).	*/
end_comment

begin_function
name|tree
name|ffecom_call_gfrt
parameter_list|(
name|ffecomGfrt
name|ix
parameter_list|,
name|tree
name|args
parameter_list|,
name|tree
name|hook
parameter_list|)
block|{
return|return
name|ffecom_call_
argument_list|(
name|ffecom_gfrt_tree_
argument_list|(
name|ix
argument_list|)
argument_list|,
name|ffecom_gfrt_kindtype
argument_list|(
name|ix
argument_list|)
argument_list|,
name|ffe_is_f2c_library
argument_list|()
operator|&&
name|ffecom_gfrt_complex_
index|[
name|ix
index|]
argument_list|,
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|,
name|TRUE
argument_list|,
name|hook
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Transform constant-union to tree.  */
end_comment

begin_function
name|tree
name|ffecom_constantunion
parameter_list|(
name|ffebldConstantUnion
modifier|*
name|cu
parameter_list|,
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|,
name|tree
name|tree_type
parameter_list|)
block|{
name|tree
name|item
decl_stmt|;
switch|switch
condition|(
name|bt
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
block|{
name|int
name|val
decl_stmt|;
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|val
operator|=
name|ffebld_cu_val_integer1
argument_list|(
operator|*
name|cu
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|val
operator|=
name|ffebld_cu_val_integer2
argument_list|(
operator|*
name|cu
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|val
operator|=
name|ffebld_cu_val_integer3
argument_list|(
operator|*
name|cu
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|val
operator|=
name|ffebld_cu_val_integer4
argument_list|(
operator|*
name|cu
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad INTEGER constant kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_kindtypeANY
case|:
return|return
name|error_mark_node
return|;
block|}
name|item
operator|=
name|build_int_2
argument_list|(
name|val
argument_list|,
operator|(
name|val
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
operator|=
name|tree_type
expr_stmt|;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
block|{
name|int
name|val
decl_stmt|;
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|val
operator|=
name|ffebld_cu_val_logical1
argument_list|(
operator|*
name|cu
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|val
operator|=
name|ffebld_cu_val_logical2
argument_list|(
operator|*
name|cu
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|val
operator|=
name|ffebld_cu_val_logical3
argument_list|(
operator|*
name|cu
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|val
operator|=
name|ffebld_cu_val_logical4
argument_list|(
operator|*
name|cu
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad LOGICAL constant kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_kindtypeANY
case|:
return|return
name|error_mark_node
return|;
block|}
name|item
operator|=
name|build_int_2
argument_list|(
name|val
argument_list|,
operator|(
name|val
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
operator|=
name|tree_type
expr_stmt|;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
block|{
name|REAL_VALUE_TYPE
name|val
decl_stmt|;
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|val
operator|=
name|ffetarget_value_real1
argument_list|(
name|ffebld_cu_val_real1
argument_list|(
operator|*
name|cu
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|val
operator|=
name|ffetarget_value_real2
argument_list|(
name|ffebld_cu_val_real2
argument_list|(
operator|*
name|cu
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|val
operator|=
name|ffetarget_value_real3
argument_list|(
name|ffebld_cu_val_real3
argument_list|(
operator|*
name|cu
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|val
operator|=
name|ffetarget_value_real4
argument_list|(
name|ffebld_cu_val_real4
argument_list|(
operator|*
name|cu
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad REAL constant kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_kindtypeANY
case|:
return|return
name|error_mark_node
return|;
block|}
name|item
operator|=
name|build_real
argument_list|(
name|tree_type
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
block|{
name|REAL_VALUE_TYPE
name|real
decl_stmt|;
name|REAL_VALUE_TYPE
name|imag
decl_stmt|;
name|tree
name|el_type
init|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeREAL
index|]
index|[
name|kt
index|]
decl_stmt|;
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|real
operator|=
name|ffetarget_value_real1
argument_list|(
name|ffebld_cu_val_complex1
argument_list|(
operator|*
name|cu
argument_list|)
operator|.
name|real
argument_list|)
expr_stmt|;
name|imag
operator|=
name|ffetarget_value_real1
argument_list|(
name|ffebld_cu_val_complex1
argument_list|(
operator|*
name|cu
argument_list|)
operator|.
name|imaginary
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|real
operator|=
name|ffetarget_value_real2
argument_list|(
name|ffebld_cu_val_complex2
argument_list|(
operator|*
name|cu
argument_list|)
operator|.
name|real
argument_list|)
expr_stmt|;
name|imag
operator|=
name|ffetarget_value_real2
argument_list|(
name|ffebld_cu_val_complex2
argument_list|(
operator|*
name|cu
argument_list|)
operator|.
name|imaginary
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|real
operator|=
name|ffetarget_value_real3
argument_list|(
name|ffebld_cu_val_complex3
argument_list|(
operator|*
name|cu
argument_list|)
operator|.
name|real
argument_list|)
expr_stmt|;
name|imag
operator|=
name|ffetarget_value_real3
argument_list|(
name|ffebld_cu_val_complex3
argument_list|(
operator|*
name|cu
argument_list|)
operator|.
name|imaginary
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|real
operator|=
name|ffetarget_value_real4
argument_list|(
name|ffebld_cu_val_complex4
argument_list|(
operator|*
name|cu
argument_list|)
operator|.
name|real
argument_list|)
expr_stmt|;
name|imag
operator|=
name|ffetarget_value_real4
argument_list|(
name|ffebld_cu_val_complex4
argument_list|(
operator|*
name|cu
argument_list|)
operator|.
name|imaginary
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad REAL constant kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_kindtypeANY
case|:
return|return
name|error_mark_node
return|;
block|}
name|item
operator|=
name|ffecom_build_complex_constant_
argument_list|(
name|tree_type
argument_list|,
name|build_real
argument_list|(
name|el_type
argument_list|,
name|real
argument_list|)
argument_list|,
name|build_real
argument_list|(
name|el_type
argument_list|,
name|imag
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
block|{
comment|/* Happens only in DATA and similar contexts. */
name|ffetargetCharacter1
name|val
decl_stmt|;
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|val
operator|=
name|ffebld_cu_val_character1
argument_list|(
operator|*
name|cu
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad CHARACTER constant kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_kindtypeANY
case|:
return|return
name|error_mark_node
return|;
block|}
name|item
operator|=
name|build_string
argument_list|(
name|ffetarget_length_character1
argument_list|(
name|val
argument_list|)
argument_list|,
name|ffetarget_text_character1
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
operator|=
name|build_type_variant
argument_list|(
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_range_type
argument_list|(
name|integer_type_node
argument_list|,
name|integer_one_node
argument_list|,
name|build_int_2
argument_list|(
name|ffetarget_length_character1
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
block|{
name|ffetargetHollerith
name|h
decl_stmt|;
name|h
operator|=
name|ffebld_cu_val_hollerith
argument_list|(
operator|*
name|cu
argument_list|)
expr_stmt|;
comment|/* If not at least as wide as default INTEGER, widen it.  */
if|if
condition|(
name|h
operator|.
name|length
operator|>=
name|FLOAT_TYPE_SIZE
operator|/
name|CHAR_TYPE_SIZE
condition|)
name|item
operator|=
name|build_string
argument_list|(
name|h
operator|.
name|length
argument_list|,
name|h
operator|.
name|text
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|str
index|[
name|FLOAT_TYPE_SIZE
operator|/
name|CHAR_TYPE_SIZE
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|h
operator|.
name|text
argument_list|,
name|h
operator|.
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|str
index|[
name|h
operator|.
name|length
index|]
argument_list|,
literal|' '
argument_list|,
name|FLOAT_TYPE_SIZE
operator|/
name|CHAR_TYPE_SIZE
operator|-
name|h
operator|.
name|length
argument_list|)
expr_stmt|;
name|item
operator|=
name|build_string
argument_list|(
name|FLOAT_TYPE_SIZE
operator|/
name|CHAR_TYPE_SIZE
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
operator|=
name|build_type_variant
argument_list|(
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_range_type
argument_list|(
name|integer_type_node
argument_list|,
name|integer_one_node
argument_list|,
name|build_int_2
argument_list|(
name|h
operator|.
name|length
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
block|{
name|ffetargetInteger1
name|ival
decl_stmt|;
name|ffetargetTypeless
name|tless
decl_stmt|;
name|ffebad
name|error
decl_stmt|;
name|tless
operator|=
name|ffebld_cu_val_typeless
argument_list|(
operator|*
name|cu
argument_list|)
expr_stmt|;
name|error
operator|=
name|ffetarget_convert_integer1_typeless
argument_list|(
operator|&
name|ival
argument_list|,
name|tless
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
name|FFEBAD
argument_list|)
expr_stmt|;
name|item
operator|=
name|build_int_2
argument_list|(
operator|(
name|int
operator|)
name|ival
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"not yet on constant type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|error_mark_node
return|;
block|}
name|TREE_CONSTANT
argument_list|(
name|item
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|item
return|;
block|}
end_function

begin_comment
comment|/* Transform expression into constant tree.     If the expression can be transformed into a tree that is constant,    that is done, and the tree returned.  Else NULL_TREE is returned.     That way, a caller can attempt to provide compile-time initialization    of a variable and, if that fails, *then* choose to start a new block    and resort to using temporaries, as appropriate.  */
end_comment

begin_function
name|tree
name|ffecom_const_expr
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|expr
condition|)
return|return
name|integer_zero_node
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|ffebld_arity
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
if|#
directive|if
name|NEWCOMMON
comment|/* ~~Enable once common/equivalence is handled properly?  */
operator|||
name|ffebld_where
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEINFO_whereCOMMON
endif|#
directive|endif
operator|||
name|ffebld_where
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEINFO_whereGLOBAL
operator|||
name|ffebld_where
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEINFO_whereINTRINSIC
operator|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handy way to make a field in a struct/union.  */
end_comment

begin_function
name|tree
name|ffecom_decl_field
parameter_list|(
name|tree
name|context
parameter_list|,
name|tree
name|prevfield
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|field
decl_stmt|;
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
operator|=
name|context
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prevfield
operator|!=
name|NULL_TREE
condition|)
name|TREE_CHAIN
argument_list|(
name|prevfield
argument_list|)
operator|=
name|field
expr_stmt|;
return|return
name|field
return|;
block|}
end_function

begin_function
name|void
name|ffecom_close_include
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|ffecom_close_include_
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ffecom_decode_include_option
parameter_list|(
name|char
modifier|*
name|spec
parameter_list|)
block|{
return|return
name|ffecom_decode_include_option_
argument_list|(
name|spec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* End a compound statement (block).  */
end_comment

begin_function
name|tree
name|ffecom_end_compstmt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|bison_rule_compstmt_
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* ffecom_end_transition -- Perform end transition on all symbols     ffecom_end_transition();     Calls ffecom_sym_end_transition for each global and local symbol.  */
end_comment

begin_function
name|void
name|ffecom_end_transition
parameter_list|()
block|{
name|ffebld
name|item
decl_stmt|;
if|if
condition|(
name|ffe_is_ffedebug
argument_list|()
condition|)
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"; end_stmt_transition\n"
argument_list|)
expr_stmt|;
name|ffecom_list_blockdata_
operator|=
name|NULL
expr_stmt|;
name|ffecom_list_common_
operator|=
name|NULL
expr_stmt|;
name|ffesymbol_drive
argument_list|(
name|ffecom_sym_end_transition
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ffedebug
argument_list|()
condition|)
block|{
name|ffestorag_report
argument_list|()
expr_stmt|;
block|}
name|ffecom_start_progunit_
argument_list|()
expr_stmt|;
for|for
control|(
name|item
operator|=
name|ffecom_list_blockdata_
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
name|ffebld
name|callee
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|tree
name|dt
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|var
decl_stmt|;
specifier|static
name|int
name|number
init|=
literal|0
decl_stmt|;
name|callee
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffebld_symter
argument_list|(
name|callee
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
block|{
name|s
operator|=
name|ffecom_sym_transform_
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
block|}
name|dt
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|var
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_forceload_%d"
argument_list|,
name|number
operator|++
argument_list|)
argument_list|,
name|dt
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|var
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|var
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_USED
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|var
operator|=
name|start_decl
argument_list|(
name|var
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|dt
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|var
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* This handles any COMMON areas that weren't referenced but have, for      example, important initial data.  */
for|for
control|(
name|item
operator|=
name|ffecom_list_common_
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
name|ffecom_transform_common_
argument_list|(
name|ffebld_symter
argument_list|(
name|ffebld_head
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_list_common_
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffecom_exec_transition -- Perform exec transition on all symbols     ffecom_exec_transition();     Calls ffecom_sym_exec_transition for each global and local symbol.    Make sure error updating not inhibited.  */
end_comment

begin_function
name|void
name|ffecom_exec_transition
parameter_list|()
block|{
name|bool
name|inhibited
decl_stmt|;
if|if
condition|(
name|ffe_is_ffedebug
argument_list|()
condition|)
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"; exec_stmt_transition\n"
argument_list|)
expr_stmt|;
name|inhibited
operator|=
name|ffebad_inhibit
argument_list|()
expr_stmt|;
name|ffebad_set_inhibit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|ffesymbol_drive
argument_list|(
name|ffecom_sym_exec_transition
argument_list|)
expr_stmt|;
comment|/* Don't retract! */
name|ffeequiv_exec_transition
argument_list|()
expr_stmt|;
comment|/* Handle all pending EQUIVALENCEs. */
if|if
condition|(
name|ffe_is_ffedebug
argument_list|()
condition|)
block|{
name|ffestorag_report
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|inhibited
condition|)
name|ffebad_set_inhibit
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle assignment statement.     Convert dest and source using ffecom_expr, then join them    with an ASSIGN op and pass the whole thing to expand_expr_stmt.  */
end_comment

begin_function
name|void
name|ffecom_expand_let_stmt
parameter_list|(
name|ffebld
name|dest
parameter_list|,
name|ffebld
name|source
parameter_list|)
block|{
name|tree
name|dest_tree
decl_stmt|;
name|tree
name|dest_length
decl_stmt|;
name|tree
name|source_tree
decl_stmt|;
name|tree
name|expr_tree
decl_stmt|;
if|if
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_basictypeCHARACTER
condition|)
block|{
name|bool
name|dest_used
decl_stmt|;
name|tree
name|assign_temp
decl_stmt|;
comment|/* This attempts to replicate the test below, but must not be 	 true when the test below is false.  (Always err on the side 	 of creating unused temporaries, to avoid ICEs.)  */
if|if
condition|(
name|ffebld_op
argument_list|(
name|dest
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|||
operator|(
operator|(
name|dest_tree
operator|=
name|ffesymbol_hook
argument_list|(
name|ffebld_symter
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|.
name|decl_tree
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|dest_tree
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|dest_tree
argument_list|)
operator|)
operator|)
condition|)
block|{
name|ffecom_prepare_expr_
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|dest_used
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|ffecom_prepare_expr_
argument_list|(
name|source
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dest_used
operator|=
name|FALSE
expr_stmt|;
block|}
name|ffecom_prepare_expr_w
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/* For COMPLEX assignment like C1=C2, if partial overlap is possible, 	 create a temporary through which the assignment is to take place, 	 since MODIFY_EXPR doesn't handle partial overlap properly.  */
if|if
condition|(
name|ffebld_basictype
argument_list|(
name|dest
argument_list|)
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|&&
name|ffecom_possible_partial_overlap_
argument_list|(
name|dest
argument_list|,
name|source
argument_list|)
condition|)
block|{
name|assign_temp
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"complex_let"
argument_list|,
name|ffecom_tree_type
index|[
name|ffebld_basictype
argument_list|(
name|dest
argument_list|)
index|]
index|[
name|ffebld_kindtype
argument_list|(
name|dest
argument_list|)
index|]
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|assign_temp
operator|=
name|NULL_TREE
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
name|dest_tree
operator|=
name|ffecom_expr_w
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_tree
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|dest_tree
argument_list|)
operator|!=
name|VAR_DECL
operator|)
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|dest_tree
argument_list|)
condition|)
name|source_tree
operator|=
name|ffecom_expr_
argument_list|(
name|source
argument_list|,
name|dest_tree
argument_list|,
name|dest
argument_list|,
operator|&
name|dest_used
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
operator|!
name|dest_used
argument_list|)
expr_stmt|;
name|dest_used
operator|=
name|FALSE
expr_stmt|;
name|source_tree
operator|=
name|ffecom_expr
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|source_tree
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|dest_used
condition|)
name|expr_tree
operator|=
name|source_tree
expr_stmt|;
elseif|else
if|if
condition|(
name|assign_temp
condition|)
block|{
ifdef|#
directive|ifdef
name|MOVE_EXPR
comment|/* The back end understands a conceptual move (evaluate source; 	     store into dest), so use that, in case it can determine 	     that it is going to use, say, two registers as temporaries 	     anyway.  So don't use the temp (and someday avoid generating 	     it, once this code starts triggering regularly).  */
name|expr_tree
operator|=
name|ffecom_2s
argument_list|(
name|MOVE_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|dest_tree
argument_list|,
name|source_tree
argument_list|)
expr_stmt|;
else|#
directive|else
name|expr_tree
operator|=
name|ffecom_2s
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|assign_temp
argument_list|,
name|source_tree
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|expr_tree
argument_list|)
expr_stmt|;
name|expr_tree
operator|=
name|ffecom_2s
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|dest_tree
argument_list|,
name|assign_temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|expr_tree
operator|=
name|ffecom_2s
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|dest_tree
argument_list|,
name|source_tree
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|expr_tree
argument_list|)
expr_stmt|;
return|return;
block|}
name|ffecom_prepare_let_char_
argument_list|(
name|ffebld_size_known
argument_list|(
name|dest
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|ffecom_prepare_expr_w
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|ffecom_prepare_end
argument_list|()
expr_stmt|;
name|ffecom_char_args_
argument_list|(
operator|&
name|dest_tree
argument_list|,
operator|&
name|dest_length
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|ffecom_let_char_
argument_list|(
name|dest_tree
argument_list|,
name|dest_length
argument_list|,
name|ffebld_size_known
argument_list|(
name|dest
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffecom_expr -- Transform expr into gcc tree     tree t;    ffebld expr;	 // FFE expression.    tree = ffecom_expr(expr);     Recursive descent on expr while making corresponding tree nodes and    attaching type info and such.  */
end_comment

begin_function
name|tree
name|ffecom_expr
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
return|return
name|ffecom_expr_
argument_list|(
name|expr
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like ffecom_expr, but return tree usable for assigned GOTO or FORMAT.  */
end_comment

begin_function
name|tree
name|ffecom_expr_assign
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
return|return
name|ffecom_expr_
argument_list|(
name|expr
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like ffecom_expr_rw, but return tree usable for ASSIGN.  */
end_comment

begin_function
name|tree
name|ffecom_expr_assign_w
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
return|return
name|ffecom_expr_
argument_list|(
name|expr
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Transform expr for use as into read/write tree and stabilize the    reference.  Not for use on CHARACTER expressions.     Recursive descent on expr while making corresponding tree nodes and    attaching type info and such.  */
end_comment

begin_function
name|tree
name|ffecom_expr_rw
parameter_list|(
name|tree
name|type
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
name|assert
argument_list|(
name|expr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Different target types not yet supported.  */
name|assert
argument_list|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|ffecom_type_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|stabilize_reference
argument_list|(
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Transform expr for use as into write tree and stabilize the    reference.  Not for use on CHARACTER expressions.     Recursive descent on expr while making corresponding tree nodes and    attaching type info and such.  */
end_comment

begin_function
name|tree
name|ffecom_expr_w
parameter_list|(
name|tree
name|type
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
name|assert
argument_list|(
name|expr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Different target types not yet supported.  */
name|assert
argument_list|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|ffecom_type_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|stabilize_reference
argument_list|(
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do global stuff.  */
end_comment

begin_function
name|void
name|ffecom_finish_compile
parameter_list|()
block|{
name|assert
argument_list|(
name|ffecom_outer_function_decl_
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|current_function_decl
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ffeglobal_drive
argument_list|(
name|ffecom_finish_global_
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Public entry point for front end to access finish_decl.  */
end_comment

begin_function
name|void
name|ffecom_finish_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|,
name|bool
name|is_top_level
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|is_top_level
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a program unit.  */
end_comment

begin_function
name|void
name|ffecom_finish_progunit
parameter_list|()
block|{
name|ffecom_end_compstmt
argument_list|()
expr_stmt|;
name|ffecom_previous_function_decl_
operator|=
name|current_function_decl
expr_stmt|;
name|ffecom_which_entrypoint_decl_
operator|=
name|NULL_TREE
expr_stmt|;
name|finish_function
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrapper for get_identifier.  pattern is sprintf-like.  */
end_comment

begin_function
name|tree
name|ffecom_get_invented_identifier
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
modifier|...
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|nam
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|vasprintf
argument_list|(
operator|&
name|nam
argument_list|,
name|pattern
argument_list|,
name|ap
argument_list|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|decl
operator|=
name|get_identifier
argument_list|(
name|nam
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nam
argument_list|)
expr_stmt|;
name|IDENTIFIER_INVENTED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
name|ffeinfoBasictype
name|ffecom_gfrt_basictype
parameter_list|(
name|ffecomGfrt
name|gfrt
parameter_list|)
block|{
name|assert
argument_list|(
name|gfrt
operator|<
name|FFECOM_gfrt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffecom_gfrt_type_
index|[
name|gfrt
index|]
condition|)
block|{
case|case
name|FFECOM_rttypeVOID_
case|:
case|case
name|FFECOM_rttypeVOIDSTAR_
case|:
return|return
name|FFEINFO_basictypeNONE
return|;
case|case
name|FFECOM_rttypeFTNINT_
case|:
return|return
name|FFEINFO_basictypeINTEGER
return|;
case|case
name|FFECOM_rttypeINTEGER_
case|:
return|return
name|FFEINFO_basictypeINTEGER
return|;
case|case
name|FFECOM_rttypeLONGINT_
case|:
return|return
name|FFEINFO_basictypeINTEGER
return|;
case|case
name|FFECOM_rttypeLOGICAL_
case|:
return|return
name|FFEINFO_basictypeLOGICAL
return|;
case|case
name|FFECOM_rttypeREAL_F2C_
case|:
case|case
name|FFECOM_rttypeREAL_GNU_
case|:
return|return
name|FFEINFO_basictypeREAL
return|;
case|case
name|FFECOM_rttypeCOMPLEX_F2C_
case|:
case|case
name|FFECOM_rttypeCOMPLEX_GNU_
case|:
return|return
name|FFEINFO_basictypeCOMPLEX
return|;
case|case
name|FFECOM_rttypeDOUBLE_
case|:
case|case
name|FFECOM_rttypeDOUBLEREAL_
case|:
return|return
name|FFEINFO_basictypeREAL
return|;
case|case
name|FFECOM_rttypeDBLCMPLX_F2C_
case|:
case|case
name|FFECOM_rttypeDBLCMPLX_GNU_
case|:
return|return
name|FFEINFO_basictypeCOMPLEX
return|;
case|case
name|FFECOM_rttypeCHARACTER_
case|:
return|return
name|FFEINFO_basictypeCHARACTER
return|;
default|default:
return|return
name|FFEINFO_basictypeANY
return|;
block|}
block|}
end_function

begin_function
name|ffeinfoKindtype
name|ffecom_gfrt_kindtype
parameter_list|(
name|ffecomGfrt
name|gfrt
parameter_list|)
block|{
name|assert
argument_list|(
name|gfrt
operator|<
name|FFECOM_gfrt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffecom_gfrt_type_
index|[
name|gfrt
index|]
condition|)
block|{
case|case
name|FFECOM_rttypeVOID_
case|:
case|case
name|FFECOM_rttypeVOIDSTAR_
case|:
return|return
name|FFEINFO_kindtypeNONE
return|;
case|case
name|FFECOM_rttypeFTNINT_
case|:
return|return
name|FFEINFO_kindtypeINTEGER1
return|;
case|case
name|FFECOM_rttypeINTEGER_
case|:
return|return
name|FFEINFO_kindtypeINTEGER1
return|;
case|case
name|FFECOM_rttypeLONGINT_
case|:
return|return
name|FFEINFO_kindtypeINTEGER4
return|;
case|case
name|FFECOM_rttypeLOGICAL_
case|:
return|return
name|FFEINFO_kindtypeLOGICAL1
return|;
case|case
name|FFECOM_rttypeREAL_F2C_
case|:
case|case
name|FFECOM_rttypeREAL_GNU_
case|:
return|return
name|FFEINFO_kindtypeREAL1
return|;
case|case
name|FFECOM_rttypeCOMPLEX_F2C_
case|:
case|case
name|FFECOM_rttypeCOMPLEX_GNU_
case|:
return|return
name|FFEINFO_kindtypeREAL1
return|;
case|case
name|FFECOM_rttypeDOUBLE_
case|:
case|case
name|FFECOM_rttypeDOUBLEREAL_
case|:
return|return
name|FFEINFO_kindtypeREAL2
return|;
case|case
name|FFECOM_rttypeDBLCMPLX_F2C_
case|:
case|case
name|FFECOM_rttypeDBLCMPLX_GNU_
case|:
return|return
name|FFEINFO_kindtypeREAL2
return|;
case|case
name|FFECOM_rttypeCHARACTER_
case|:
return|return
name|FFEINFO_kindtypeCHARACTER1
return|;
default|default:
return|return
name|FFEINFO_kindtypeANY
return|;
block|}
block|}
end_function

begin_function
name|void
name|ffecom_init_0
parameter_list|()
block|{
name|tree
name|endlink
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|ffetype
name|type
decl_stmt|;
name|ffetype
name|base_type
decl_stmt|;
name|tree
name|double_ftype_double
decl_stmt|;
name|tree
name|float_ftype_float
decl_stmt|;
name|tree
name|ldouble_ftype_ldouble
decl_stmt|;
name|tree
name|ffecom_tree_ptr_to_fun_type_void
decl_stmt|;
comment|/* This block of code comes from the now-obsolete cktyps.c.  It checks      whether the compiler environment is buggy in known ways, some of which      would, if not explicitly checked here, result in subtle bugs in g77.  */
if|if
condition|(
name|ffe_is_do_internal_checks
argument_list|()
condition|)
block|{
specifier|static
specifier|const
name|char
name|names
index|[]
index|[
literal|12
index|]
init|=
block|{
literal|"bar"
block|,
literal|"bletch"
block|,
literal|"foo"
block|,
literal|"foobar"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|ul
decl_stmt|;
name|double
name|fl
decl_stmt|;
name|name
operator|=
name|bsearch
argument_list|(
literal|"foo"
argument_list|,
operator|&
name|names
index|[
literal|0
index|]
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|names
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|strcmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
operator|&
name|names
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
block|{
name|assert
argument_list|(
literal|"bsearch doesn't work, #define FFEPROJ_BSEARCH 0 in proj.h"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|ul
operator|=
name|strtoul
argument_list|(
literal|"123456789"
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ul
operator|!=
literal|123456789L
condition|)
block|{
name|assert
argument_list|(
literal|"strtoul doesn't have enough range, #define FFEPROJ_STRTOUL 0\  in proj.h"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|fl
operator|=
name|atof
argument_list|(
literal|"56.789"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fl
operator|<
literal|56.788
operator|)
operator|||
operator|(
name|fl
operator|>
literal|56.79
operator|)
condition|)
block|{
name|assert
argument_list|(
literal|"atof not type double, fix your #include<stdio.h>"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|ffecom_outer_function_decl_
operator|=
name|NULL_TREE
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|named_labels
operator|=
name|NULL_TREE
expr_stmt|;
name|current_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
name|free_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
comment|/* Make the binding_level structure for global names.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|global_binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|->
name|prep_state
operator|=
literal|2
expr_stmt|;
name|build_common_tree_nodes
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Define `int' and `char' first so that dbx will output them first.  */
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"int"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* CHARACTER*1 is unsigned in ICHAR contexts.  */
name|char_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"char"
argument_list|)
argument_list|,
name|char_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long int"
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unsigned int"
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long unsigned int"
argument_list|)
argument_list|,
name|long_unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long long int"
argument_list|)
argument_list|,
name|long_long_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long long unsigned int"
argument_list|)
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"short int"
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"short unsigned int"
argument_list|)
argument_list|,
name|short_unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the sizetype before we make other types.  This *should* be the      first type we create.  */
name|set_sizetype
argument_list|(
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
name|SIZE_TYPE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_typesize_pointer_
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|build_common_tree_nodes_2
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Define both `signed char' and `unsigned char'.  */
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"signed char"
argument_list|)
argument_list|,
name|signed_char_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unsigned char"
argument_list|)
argument_list|,
name|unsigned_char_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"float"
argument_list|)
argument_list|,
name|float_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"double"
argument_list|)
argument_list|,
name|double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long double"
argument_list|)
argument_list|,
name|long_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For now, override what build_common_tree_nodes has done.  */
name|complex_integer_type_node
operator|=
name|ffecom_make_complex_type_
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|complex_float_type_node
operator|=
name|ffecom_make_complex_type_
argument_list|(
name|float_type_node
argument_list|)
expr_stmt|;
name|complex_double_type_node
operator|=
name|ffecom_make_complex_type_
argument_list|(
name|double_type_node
argument_list|)
expr_stmt|;
name|complex_long_double_type_node
operator|=
name|ffecom_make_complex_type_
argument_list|(
name|long_double_type_node
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex int"
argument_list|)
argument_list|,
name|complex_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex float"
argument_list|)
argument_list|,
name|complex_float_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex double"
argument_list|)
argument_list|,
name|complex_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex long double"
argument_list|)
argument_list|,
name|complex_long_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"void"
argument_list|)
argument_list|,
name|void_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We are not going to have real types in C with less than byte alignment,      so we might as well not have any types that claim to have it.  */
name|TYPE_ALIGN
argument_list|(
name|void_type_node
argument_list|)
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|void_type_node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
name|ffecom_tree_fun_type_void
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ffecom_tree_ptr_to_fun_type_void
operator|=
name|build_pointer_type
argument_list|(
name|ffecom_tree_fun_type_void
argument_list|)
expr_stmt|;
name|endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|float_ftype_float
operator|=
name|build_function_type
argument_list|(
name|float_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|float_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|double_ftype_double
operator|=
name|build_function_type
argument_list|(
name|double_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|double_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|ldouble_ftype_ldouble
operator|=
name|build_function_type
argument_list|(
name|long_double_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_double_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffecom_tree_type
argument_list|)
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
operator|(
name|size_t
operator|)
name|j
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffecom_tree_type
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
name|ffecom_tree_type
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|NULL_TREE
expr_stmt|;
name|ffecom_tree_fun_type
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|NULL_TREE
expr_stmt|;
name|ffecom_tree_ptr_to_fun_type
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|NULL_TREE
expr_stmt|;
name|ffecom_f2c_typecode_
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Set up standard g77 types.  Note that INTEGER and LOGICAL are set      to size FLOAT_TYPE_SIZE because they have to be the same size as      REAL, which also is FLOAT_TYPE_SIZE, according to the standard.      Compiler options and other such stuff that change the ways these      types are set should not affect this particular setup.  */
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeINTEGER
index|]
index|[
name|FFEINFO_kindtypeINTEGER1
index|]
operator|=
name|t
operator|=
name|make_signed_type
argument_list|(
name|FLOAT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"integer"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffetype_new
argument_list|()
expr_stmt|;
name|base_type
operator|=
name|type
expr_stmt|;
name|ffeinfo_set_type
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGER1
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_ams
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ffetype_set_star
argument_list|(
name|base_type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|CHAR_TYPE_SIZE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_kind
argument_list|(
name|base_type
argument_list|,
literal|1
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffecom_typesize_integer1_
operator|=
name|ffetype_size
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffetype_size
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ffetargetInteger1
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeHOLLERITH
index|]
index|[
name|FFEINFO_kindtypeINTEGER1
index|]
operator|=
name|t
operator|=
name|make_unsigned_type
argument_list|(
name|FLOAT_TYPE_SIZE
argument_list|)
expr_stmt|;
comment|/* HOLLERITH means unsigned. */
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unsigned"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeINTEGER
index|]
index|[
name|FFEINFO_kindtypeINTEGER2
index|]
operator|=
name|t
operator|=
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"byte"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffetype_new
argument_list|()
expr_stmt|;
name|ffeinfo_set_type
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGER2
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_ams
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ffetype_set_star
argument_list|(
name|base_type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|CHAR_TYPE_SIZE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_kind
argument_list|(
name|base_type
argument_list|,
literal|3
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffetype_size
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ffetargetInteger2
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeHOLLERITH
index|]
index|[
name|FFEINFO_kindtypeINTEGER2
index|]
operator|=
name|t
operator|=
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unsigned byte"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeINTEGER
index|]
index|[
name|FFEINFO_kindtypeINTEGER3
index|]
operator|=
name|t
operator|=
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"word"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffetype_new
argument_list|()
expr_stmt|;
name|ffeinfo_set_type
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGER3
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_ams
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ffetype_set_star
argument_list|(
name|base_type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|CHAR_TYPE_SIZE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_kind
argument_list|(
name|base_type
argument_list|,
literal|6
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffetype_size
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ffetargetInteger3
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeHOLLERITH
index|]
index|[
name|FFEINFO_kindtypeINTEGER3
index|]
operator|=
name|t
operator|=
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unsigned word"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeINTEGER
index|]
index|[
name|FFEINFO_kindtypeINTEGER4
index|]
operator|=
name|t
operator|=
name|make_signed_type
argument_list|(
name|FLOAT_TYPE_SIZE
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"integer4"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffetype_new
argument_list|()
expr_stmt|;
name|ffeinfo_set_type
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGER4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_ams
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ffetype_set_star
argument_list|(
name|base_type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|CHAR_TYPE_SIZE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_kind
argument_list|(
name|base_type
argument_list|,
literal|2
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffetype_size
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ffetargetInteger4
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeHOLLERITH
index|]
index|[
name|FFEINFO_kindtypeINTEGER4
index|]
operator|=
name|t
operator|=
name|make_unsigned_type
argument_list|(
name|FLOAT_TYPE_SIZE
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unsigned4"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (ffe_is_do_internal_checks ()&& LONG_TYPE_SIZE != FLOAT_TYPE_SIZE&& LONG_TYPE_SIZE != CHAR_TYPE_SIZE&& LONG_TYPE_SIZE != SHORT_TYPE_SIZE&& LONG_TYPE_SIZE != LONG_LONG_TYPE_SIZE)     {       fprintf (stderr, "Sorry, no g77 support for LONG_TYPE_SIZE (%d bits) yet.\n", 	       LONG_TYPE_SIZE);     }
endif|#
directive|endif
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeLOGICAL
index|]
index|[
name|FFEINFO_kindtypeLOGICAL1
index|]
operator|=
name|t
operator|=
name|make_signed_type
argument_list|(
name|FLOAT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"logical"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffetype_new
argument_list|()
expr_stmt|;
name|base_type
operator|=
name|type
expr_stmt|;
name|ffeinfo_set_type
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICAL1
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_ams
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ffetype_set_star
argument_list|(
name|base_type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|CHAR_TYPE_SIZE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_kind
argument_list|(
name|base_type
argument_list|,
literal|1
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffetype_size
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ffetargetLogical1
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeLOGICAL
index|]
index|[
name|FFEINFO_kindtypeLOGICAL2
index|]
operator|=
name|t
operator|=
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"logical2"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffetype_new
argument_list|()
expr_stmt|;
name|ffeinfo_set_type
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICAL2
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_ams
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ffetype_set_star
argument_list|(
name|base_type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|CHAR_TYPE_SIZE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_kind
argument_list|(
name|base_type
argument_list|,
literal|3
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffetype_size
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ffetargetLogical2
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeLOGICAL
index|]
index|[
name|FFEINFO_kindtypeLOGICAL3
index|]
operator|=
name|t
operator|=
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"logical3"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffetype_new
argument_list|()
expr_stmt|;
name|ffeinfo_set_type
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICAL3
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_ams
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ffetype_set_star
argument_list|(
name|base_type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|CHAR_TYPE_SIZE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_kind
argument_list|(
name|base_type
argument_list|,
literal|6
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffetype_size
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ffetargetLogical3
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeLOGICAL
index|]
index|[
name|FFEINFO_kindtypeLOGICAL4
index|]
operator|=
name|t
operator|=
name|make_signed_type
argument_list|(
name|FLOAT_TYPE_SIZE
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"logical4"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffetype_new
argument_list|()
expr_stmt|;
name|ffeinfo_set_type
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICAL4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_ams
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ffetype_set_star
argument_list|(
name|base_type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|CHAR_TYPE_SIZE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_kind
argument_list|(
name|base_type
argument_list|,
literal|2
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffetype_size
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ffetargetLogical4
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeREAL
index|]
index|[
name|FFEINFO_kindtypeREAL1
index|]
operator|=
name|t
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"real"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffetype_new
argument_list|()
expr_stmt|;
name|base_type
operator|=
name|type
expr_stmt|;
name|ffeinfo_set_type
argument_list|(
name|FFEINFO_basictypeREAL
argument_list|,
name|FFEINFO_kindtypeREAL1
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_ams
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ffetype_set_star
argument_list|(
name|base_type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|CHAR_TYPE_SIZE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_kind
argument_list|(
name|base_type
argument_list|,
literal|1
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffecom_f2c_typecode_
index|[
name|FFEINFO_basictypeREAL
index|]
index|[
name|FFEINFO_kindtypeREAL1
index|]
operator|=
name|FFETARGET_f2cTYREAL
expr_stmt|;
name|assert
argument_list|(
name|ffetype_size
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ffetargetReal1
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeREAL
index|]
index|[
name|FFEINFO_kindtypeREALDOUBLE
index|]
operator|=
name|t
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
operator|*
literal|2
expr_stmt|;
comment|/* Always twice REAL. */
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"double precision"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffetype_new
argument_list|()
expr_stmt|;
name|ffeinfo_set_type
argument_list|(
name|FFEINFO_basictypeREAL
argument_list|,
name|FFEINFO_kindtypeREALDOUBLE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_ams
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ffetype_set_star
argument_list|(
name|base_type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|CHAR_TYPE_SIZE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_kind
argument_list|(
name|base_type
argument_list|,
literal|2
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffecom_f2c_typecode_
index|[
name|FFEINFO_basictypeREAL
index|]
index|[
name|FFEINFO_kindtypeREAL2
index|]
operator|=
name|FFETARGET_f2cTYDREAL
expr_stmt|;
name|assert
argument_list|(
name|ffetype_size
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ffetargetReal2
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeCOMPLEX
index|]
index|[
name|FFEINFO_kindtypeREAL1
index|]
operator|=
name|t
operator|=
name|ffecom_make_complex_type_
argument_list|(
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeREAL
index|]
index|[
name|FFEINFO_kindtypeREAL1
index|]
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffetype_new
argument_list|()
expr_stmt|;
name|base_type
operator|=
name|type
expr_stmt|;
name|ffeinfo_set_type
argument_list|(
name|FFEINFO_basictypeCOMPLEX
argument_list|,
name|FFEINFO_kindtypeREAL1
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_ams
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ffetype_set_star
argument_list|(
name|base_type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|CHAR_TYPE_SIZE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_kind
argument_list|(
name|base_type
argument_list|,
literal|1
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffecom_f2c_typecode_
index|[
name|FFEINFO_basictypeCOMPLEX
index|]
index|[
name|FFEINFO_kindtypeREAL1
index|]
operator|=
name|FFETARGET_f2cTYCOMPLEX
expr_stmt|;
name|assert
argument_list|(
name|ffetype_size
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ffetargetComplex1
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeCOMPLEX
index|]
index|[
name|FFEINFO_kindtypeREALDOUBLE
index|]
operator|=
name|t
operator|=
name|ffecom_make_complex_type_
argument_list|(
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeREAL
index|]
index|[
name|FFEINFO_kindtypeREAL2
index|]
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"double complex"
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffetype_new
argument_list|()
expr_stmt|;
name|ffeinfo_set_type
argument_list|(
name|FFEINFO_basictypeCOMPLEX
argument_list|,
name|FFEINFO_kindtypeREALDOUBLE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_ams
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ffetype_set_star
argument_list|(
name|base_type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|CHAR_TYPE_SIZE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_kind
argument_list|(
name|base_type
argument_list|,
literal|2
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffecom_f2c_typecode_
index|[
name|FFEINFO_basictypeCOMPLEX
index|]
index|[
name|FFEINFO_kindtypeREAL2
index|]
operator|=
name|FFETARGET_f2cTYDCOMPLEX
expr_stmt|;
name|assert
argument_list|(
name|ffetype_size
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ffetargetComplex2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make function and ptr-to-function types for non-CHARACTER types. */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffecom_tree_type
argument_list|)
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
operator|(
name|size_t
operator|)
name|j
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffecom_tree_type
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|ffecom_tree_type
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|FFEINFO_basictypeINTEGER
condition|)
block|{
comment|/* Figure out the smallest INTEGER type that can hold 		   a pointer on this machine. */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ffecom_pointer_kind_
operator|==
name|FFEINFO_kindtypeNONE
operator|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|ffecom_tree_type
index|[
name|i
index|]
index|[
name|ffecom_pointer_kind_
index|]
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
condition|)
name|ffecom_pointer_kind_
operator|=
name|j
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|FFEINFO_basictypeCOMPLEX
condition|)
name|t
operator|=
name|void_type_node
expr_stmt|;
comment|/* For f2c compatibility, REAL functions are really 	       implemented as DOUBLE PRECISION.  */
elseif|else
if|if
condition|(
operator|(
name|i
operator|==
name|FFEINFO_basictypeREAL
operator|)
operator|&&
operator|(
name|j
operator|==
name|FFEINFO_kindtypeREAL1
operator|)
condition|)
name|t
operator|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeREAL
index|]
index|[
name|FFEINFO_kindtypeREAL2
index|]
expr_stmt|;
name|t
operator|=
name|ffecom_tree_fun_type
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|build_function_type
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ffecom_tree_ptr_to_fun_type
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|build_pointer_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set up pointer types.  */
if|if
condition|(
name|ffecom_pointer_kind_
operator|==
name|FFEINFO_basictypeNONE
condition|)
name|fatal_error
argument_list|(
literal|"no INTEGER type can hold a pointer on this configuration"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|&&
name|ffe_is_do_internal_checks
argument_list|()
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Pointer type kt=%d\n"
argument_list|,
name|ffecom_pointer_kind_
argument_list|)
expr_stmt|;
name|ffetype_set_kind
argument_list|(
name|ffeinfo_type
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
argument_list|,
literal|7
argument_list|,
name|ffeinfo_type
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|ffecom_pointer_kind_
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_assign
argument_list|()
condition|)
name|ffecom_label_kind_
operator|=
name|ffecom_pointer_kind_
expr_stmt|;
comment|/* Require ASSIGN etc to this. */
else|else
name|ffecom_label_kind_
operator|=
name|FFEINFO_kindtypeINTEGERDEFAULT
expr_stmt|;
if|if
condition|(
literal|0
operator|&&
name|ffe_is_do_internal_checks
argument_list|()
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Label type kt=%d\n"
argument_list|,
name|ffecom_label_kind_
argument_list|)
expr_stmt|;
name|ffecom_integer_type_node
operator|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeINTEGER
index|]
index|[
name|FFEINFO_kindtypeINTEGER1
index|]
expr_stmt|;
name|ffecom_integer_zero_node
operator|=
name|convert
argument_list|(
name|ffecom_integer_type_node
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|ffecom_integer_one_node
operator|=
name|convert
argument_list|(
name|ffecom_integer_type_node
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
comment|/* Yes, the "FLOAT_TYPE_SIZE" references below are intentional.      Turns out that by TYLONG, runtime/libI77/lio.h really means      "whatever size an ftnint is".  For consistency and sanity,      com.h and runtime/f2c.h.in agree that flag, ftnint, and ftlen      all are INTEGER, which we also make out of whatever back-end      integer type is FLOAT_TYPE_SIZE bits wide.  This change, from      LONG_TYPE_SIZE, for TYLONG and TYLOGICAL, was necessary to      accommodate machines like the Alpha.  Note that this suggests      f2c and libf2c are missing a distinction perhaps needed on      some machines between "int" and "long int".  -- burley 0.5.5 950215 */
name|ffecom_f2c_set_lio_code_
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FLOAT_TYPE_SIZE
argument_list|,
name|FFETARGET_f2cTYLONG
argument_list|)
expr_stmt|;
name|ffecom_f2c_set_lio_code_
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|SHORT_TYPE_SIZE
argument_list|,
name|FFETARGET_f2cTYSHORT
argument_list|)
expr_stmt|;
name|ffecom_f2c_set_lio_code_
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|CHAR_TYPE_SIZE
argument_list|,
name|FFETARGET_f2cTYINT1
argument_list|)
expr_stmt|;
name|ffecom_f2c_set_lio_code_
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|LONG_LONG_TYPE_SIZE
argument_list|,
name|FFETARGET_f2cTYQUAD
argument_list|)
expr_stmt|;
name|ffecom_f2c_set_lio_code_
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FLOAT_TYPE_SIZE
argument_list|,
name|FFETARGET_f2cTYLOGICAL
argument_list|)
expr_stmt|;
name|ffecom_f2c_set_lio_code_
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|SHORT_TYPE_SIZE
argument_list|,
name|FFETARGET_f2cTYLOGICAL2
argument_list|)
expr_stmt|;
name|ffecom_f2c_set_lio_code_
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|CHAR_TYPE_SIZE
argument_list|,
name|FFETARGET_f2cTYLOGICAL1
argument_list|)
expr_stmt|;
comment|/* ~~~Not really such a type in libf2c, e.g. I/O support?  */
name|ffecom_f2c_set_lio_code_
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|LONG_LONG_TYPE_SIZE
argument_list|,
name|FFETARGET_f2cTYQUAD
argument_list|)
expr_stmt|;
comment|/* CHARACTER stuff is all special-cased, so it is not handled in the above      loop.  CHARACTER items are built as arrays of unsigned char.  */
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeCHARACTER
index|]
index|[
name|FFEINFO_kindtypeCHARACTER1
index|]
operator|=
name|t
operator|=
name|char_type_node
expr_stmt|;
name|type
operator|=
name|ffetype_new
argument_list|()
expr_stmt|;
name|base_type
operator|=
name|type
expr_stmt|;
name|ffeinfo_set_type
argument_list|(
name|FFEINFO_basictypeCHARACTER
argument_list|,
name|FFEINFO_kindtypeCHARACTER1
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ffetype_set_ams
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ffetype_set_kind
argument_list|(
name|base_type
argument_list|,
literal|1
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffetype_size
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
operator|(
operator|(
name|ffetargetCharacter1
operator|)
block|{
literal|0
block|,
name|NULL
block|}
operator|)
operator|.
name|text
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_tree_fun_type
index|[
name|FFEINFO_basictypeCHARACTER
index|]
index|[
name|FFEINFO_kindtypeCHARACTER1
index|]
operator|=
name|ffecom_tree_fun_type_void
expr_stmt|;
name|ffecom_tree_ptr_to_fun_type
index|[
name|FFEINFO_basictypeCHARACTER
index|]
index|[
name|FFEINFO_kindtypeCHARACTER1
index|]
operator|=
name|ffecom_tree_ptr_to_fun_type_void
expr_stmt|;
name|ffecom_f2c_typecode_
index|[
name|FFEINFO_basictypeCHARACTER
index|]
index|[
name|FFEINFO_kindtypeCHARACTER1
index|]
operator|=
name|FFETARGET_f2cTYCHAR
expr_stmt|;
name|ffecom_f2c_typecode_
index|[
name|FFEINFO_basictypeANY
index|]
index|[
name|FFEINFO_kindtypeANY
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Make multi-return-value type and fields. */
name|ffecom_multi_type_node_
operator|=
name|make_node
argument_list|(
name|UNION_TYPE
argument_list|)
expr_stmt|;
name|field
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffecom_tree_type
argument_list|)
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
operator|(
name|size_t
operator|)
name|j
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffecom_tree_type
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
name|char
name|name
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|ffecom_tree_type
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
name|NULL_TREE
condition|)
continue|continue;
comment|/* Not supported. */
name|sprintf
argument_list|(
operator|&
name|name
index|[
literal|0
index|]
argument_list|,
literal|"bt_%s_kt_%s"
argument_list|,
name|ffeinfo_basictype_string
argument_list|(
operator|(
name|ffeinfoBasictype
operator|)
name|i
argument_list|)
argument_list|,
name|ffeinfo_kindtype_string
argument_list|(
operator|(
name|ffeinfoKindtype
operator|)
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_multi_fields_
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffecom_tree_type
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|ffecom_multi_fields_
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
operator|=
name|ffecom_multi_type_node_
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|ffecom_multi_fields_
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|ffecom_multi_fields_
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|ffecom_multi_fields_
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
operator|=
name|field
expr_stmt|;
name|field
operator|=
name|ffecom_multi_fields_
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
name|TYPE_FIELDS
argument_list|(
name|ffecom_multi_type_node_
argument_list|)
operator|=
name|field
expr_stmt|;
name|layout_type
argument_list|(
name|ffecom_multi_type_node_
argument_list|)
expr_stmt|;
comment|/* Subroutines usually return integer because they might have alternate      returns. */
name|ffecom_tree_subr_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ffecom_tree_ptr_to_subr_type
operator|=
name|build_pointer_type
argument_list|(
name|ffecom_tree_subr_type
argument_list|)
expr_stmt|;
name|ffecom_tree_blockdata_type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_sqrtf"
argument_list|,
name|float_ftype_float
argument_list|,
name|BUILT_IN_SQRTF
argument_list|,
name|BUILT_IN_NORMAL
argument_list|,
literal|"sqrtf"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_sqrt"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_SQRT
argument_list|,
name|BUILT_IN_NORMAL
argument_list|,
literal|"sqrt"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_sqrtl"
argument_list|,
name|ldouble_ftype_ldouble
argument_list|,
name|BUILT_IN_SQRTL
argument_list|,
name|BUILT_IN_NORMAL
argument_list|,
literal|"sqrtl"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_sinf"
argument_list|,
name|float_ftype_float
argument_list|,
name|BUILT_IN_SINF
argument_list|,
name|BUILT_IN_NORMAL
argument_list|,
literal|"sinf"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_sin"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_SIN
argument_list|,
name|BUILT_IN_NORMAL
argument_list|,
literal|"sin"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_sinl"
argument_list|,
name|ldouble_ftype_ldouble
argument_list|,
name|BUILT_IN_SINL
argument_list|,
name|BUILT_IN_NORMAL
argument_list|,
literal|"sinl"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_cosf"
argument_list|,
name|float_ftype_float
argument_list|,
name|BUILT_IN_COSF
argument_list|,
name|BUILT_IN_NORMAL
argument_list|,
literal|"cosf"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_cos"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_COS
argument_list|,
name|BUILT_IN_NORMAL
argument_list|,
literal|"cos"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_cosl"
argument_list|,
name|ldouble_ftype_ldouble
argument_list|,
name|BUILT_IN_COSL
argument_list|,
name|BUILT_IN_NORMAL
argument_list|,
literal|"cosl"
argument_list|)
expr_stmt|;
name|pedantic_lvalues
operator|=
name|FALSE
expr_stmt|;
name|ffecom_f2c_make_type_
argument_list|(
operator|&
name|ffecom_f2c_integer_type_node
argument_list|,
name|FFECOM_f2cINTEGER
argument_list|,
literal|"integer"
argument_list|)
expr_stmt|;
name|ffecom_f2c_make_type_
argument_list|(
operator|&
name|ffecom_f2c_address_type_node
argument_list|,
name|FFECOM_f2cADDRESS
argument_list|,
literal|"address"
argument_list|)
expr_stmt|;
name|ffecom_f2c_make_type_
argument_list|(
operator|&
name|ffecom_f2c_real_type_node
argument_list|,
name|FFECOM_f2cREAL
argument_list|,
literal|"real"
argument_list|)
expr_stmt|;
name|ffecom_f2c_make_type_
argument_list|(
operator|&
name|ffecom_f2c_doublereal_type_node
argument_list|,
name|FFECOM_f2cDOUBLEREAL
argument_list|,
literal|"doublereal"
argument_list|)
expr_stmt|;
name|ffecom_f2c_make_type_
argument_list|(
operator|&
name|ffecom_f2c_complex_type_node
argument_list|,
name|FFECOM_f2cCOMPLEX
argument_list|,
literal|"complex"
argument_list|)
expr_stmt|;
name|ffecom_f2c_make_type_
argument_list|(
operator|&
name|ffecom_f2c_doublecomplex_type_node
argument_list|,
name|FFECOM_f2cDOUBLECOMPLEX
argument_list|,
literal|"doublecomplex"
argument_list|)
expr_stmt|;
name|ffecom_f2c_make_type_
argument_list|(
operator|&
name|ffecom_f2c_longint_type_node
argument_list|,
name|FFECOM_f2cLONGINT
argument_list|,
literal|"longint"
argument_list|)
expr_stmt|;
name|ffecom_f2c_make_type_
argument_list|(
operator|&
name|ffecom_f2c_logical_type_node
argument_list|,
name|FFECOM_f2cLOGICAL
argument_list|,
literal|"logical"
argument_list|)
expr_stmt|;
name|ffecom_f2c_make_type_
argument_list|(
operator|&
name|ffecom_f2c_flag_type_node
argument_list|,
name|FFECOM_f2cFLAG
argument_list|,
literal|"flag"
argument_list|)
expr_stmt|;
name|ffecom_f2c_make_type_
argument_list|(
operator|&
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|FFECOM_f2cFTNLEN
argument_list|,
literal|"ftnlen"
argument_list|)
expr_stmt|;
name|ffecom_f2c_make_type_
argument_list|(
operator|&
name|ffecom_f2c_ftnint_type_node
argument_list|,
name|FFECOM_f2cFTNINT
argument_list|,
literal|"ftnint"
argument_list|)
expr_stmt|;
name|ffecom_f2c_ftnlen_zero_node
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|ffecom_f2c_ftnlen_one_node
operator|=
name|convert
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|ffecom_f2c_ftnlen_two_node
operator|=
name|build_int_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|ffecom_f2c_ftnlen_two_node
argument_list|)
operator|=
name|ffecom_integer_type_node
expr_stmt|;
name|ffecom_f2c_ptr_to_ftnlen_type_node
operator|=
name|build_pointer_type
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|)
expr_stmt|;
name|ffecom_f2c_ptr_to_ftnint_type_node
operator|=
name|build_pointer_type
argument_list|(
name|ffecom_f2c_ftnint_type_node
argument_list|)
expr_stmt|;
name|ffecom_f2c_ptr_to_integer_type_node
operator|=
name|build_pointer_type
argument_list|(
name|ffecom_f2c_integer_type_node
argument_list|)
expr_stmt|;
name|ffecom_f2c_ptr_to_real_type_node
operator|=
name|build_pointer_type
argument_list|(
name|ffecom_f2c_real_type_node
argument_list|)
expr_stmt|;
name|ffecom_float_zero_
operator|=
name|build_real
argument_list|(
name|float_type_node
argument_list|,
name|dconst0
argument_list|)
expr_stmt|;
name|ffecom_double_zero_
operator|=
name|build_real
argument_list|(
name|double_type_node
argument_list|,
name|dconst0
argument_list|)
expr_stmt|;
block|{
name|REAL_VALUE_TYPE
name|point_5
decl_stmt|;
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
name|REAL_ARITHMETIC
argument_list|(
name|point_5
argument_list|,
name|RDIV_EXPR
argument_list|,
name|dconst1
argument_list|,
name|dconst2
argument_list|)
expr_stmt|;
else|#
directive|else
name|point_5
operator|=
literal|.5
expr_stmt|;
endif|#
directive|endif
name|ffecom_float_half_
operator|=
name|build_real
argument_list|(
name|float_type_node
argument_list|,
name|point_5
argument_list|)
expr_stmt|;
name|ffecom_double_half_
operator|=
name|build_real
argument_list|(
name|double_type_node
argument_list|,
name|point_5
argument_list|)
expr_stmt|;
block|}
comment|/* Do "extern int xargc;".  */
name|ffecom_tree_xargc_
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"f__xargc"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|ffecom_tree_xargc_
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|ffecom_tree_xargc_
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|ffecom_tree_xargc_
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ffecom_tree_xargc_
operator|=
name|start_decl
argument_list|(
name|ffecom_tree_xargc_
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|ffecom_tree_xargc_
argument_list|,
name|NULL_TREE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is being fixed, and seems to be working now. */
block|if ((FLOAT_TYPE_SIZE != 32)       || (TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (null_pointer_node))) != 32))     {       warning ("configuration: REAL, INTEGER, and LOGICAL are %d bits wide,", 	       (int) FLOAT_TYPE_SIZE);       warning ("and pointers are %d bits wide, but g77 doesn't yet work", 	  (int) TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (null_pointer_node))));       warning ("properly unless they all are 32 bits wide");       warning ("Please keep this in mind before you report bugs.  g77 should");       warning ("support non-32-bit machines better as of version 0.6");     }
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* Code in ste.c that would crash has been commented out. */
block|if (TYPE_PRECISION (ffecom_f2c_ftnlen_type_node)< TYPE_PRECISION (string_type_node))
comment|/* I/O will probably crash.  */
block|warning ("configuration: char * holds %d bits, but ftnlen only %d", 	     TYPE_PRECISION (string_type_node), 	     TYPE_PRECISION (ffecom_f2c_ftnlen_type_node));
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* ASSIGN-related stuff has been changed to accommodate this. */
block|if (TYPE_PRECISION (ffecom_integer_type_node)< TYPE_PRECISION (string_type_node))
comment|/* ASSIGN 10 TO I will crash.  */
block|warning ("configuration: char * holds %d bits, but INTEGER only %d --\n\  ASSIGN statement might fail", 	     TYPE_PRECISION (string_type_node), 	     TYPE_PRECISION (ffecom_integer_type_node));
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffecom_init_2 -- Initialize     ffecom_init_2();  */
end_comment

begin_function
name|void
name|ffecom_init_2
parameter_list|()
block|{
name|assert
argument_list|(
name|ffecom_outer_function_decl_
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|current_function_decl
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffecom_which_entrypoint_decl_
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ffecom_master_arglist_
operator|=
name|NULL
expr_stmt|;
operator|++
name|ffecom_num_fns_
expr_stmt|;
name|ffecom_primary_entry_
operator|=
name|NULL
expr_stmt|;
name|ffecom_is_altreturning_
operator|=
name|FALSE
expr_stmt|;
name|ffecom_func_result_
operator|=
name|NULL_TREE
expr_stmt|;
name|ffecom_multi_retval_
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffecom_list_expr -- Transform list of exprs into gcc tree     tree t;    ffebld expr;	 // FFE opITEM list.    tree = ffecom_list_expr(expr);     List of actual args is transformed into corresponding gcc backend list.  */
end_comment

begin_function
name|tree
name|ffecom_list_expr
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|tree
name|list
decl_stmt|;
name|tree
modifier|*
name|plist
init|=
operator|&
name|list
decl_stmt|;
name|tree
name|trail
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Append char length args here. */
name|tree
modifier|*
name|ptrail
init|=
operator|&
name|trail
decl_stmt|;
name|tree
name|length
decl_stmt|;
while|while
condition|(
name|expr
operator|!=
name|NULL
condition|)
block|{
name|tree
name|texpr
init|=
name|ffecom_arg_expr
argument_list|(
name|ffebld_head
argument_list|(
name|expr
argument_list|)
argument_list|,
operator|&
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|texpr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
operator|*
name|plist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|texpr
argument_list|)
expr_stmt|;
name|plist
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|plist
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_trail
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|NULL_TREE
condition|)
block|{
operator|*
name|ptrail
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ptrail
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|ptrail
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|plist
operator|=
name|trail
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* ffecom_list_ptr_to_expr -- Transform list of exprs into gcc tree     tree t;    ffebld expr;	 // FFE opITEM list.    tree = ffecom_list_ptr_to_expr(expr);     List of actual args is transformed into corresponding gcc backend list for    use in calling an external procedure (vs. a statement function).  */
end_comment

begin_function
name|tree
name|ffecom_list_ptr_to_expr
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|tree
name|list
decl_stmt|;
name|tree
modifier|*
name|plist
init|=
operator|&
name|list
decl_stmt|;
name|tree
name|trail
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Append char length args here. */
name|tree
modifier|*
name|ptrail
init|=
operator|&
name|trail
decl_stmt|;
name|tree
name|length
decl_stmt|;
while|while
condition|(
name|expr
operator|!=
name|NULL
condition|)
block|{
name|tree
name|texpr
init|=
name|ffecom_arg_ptr_to_expr
argument_list|(
name|ffebld_head
argument_list|(
name|expr
argument_list|)
argument_list|,
operator|&
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|texpr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
operator|*
name|plist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|texpr
argument_list|)
expr_stmt|;
name|plist
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|plist
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_trail
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|NULL_TREE
condition|)
block|{
operator|*
name|ptrail
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ptrail
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|ptrail
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|plist
operator|=
name|trail
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Obtain gcc's LABEL_DECL tree for label.  */
end_comment

begin_function
name|tree
name|ffecom_lookup_label
parameter_list|(
name|ffelab
name|label
parameter_list|)
block|{
name|tree
name|glabel
decl_stmt|;
if|if
condition|(
name|ffelab_hook
argument_list|(
name|label
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|char
name|labelname
index|[
literal|16
index|]
decl_stmt|;
switch|switch
condition|(
name|ffelab_type
argument_list|(
name|label
argument_list|)
condition|)
block|{
case|case
name|FFELAB_typeLOOPEND
case|:
case|case
name|FFELAB_typeNOTLOOP
case|:
case|case
name|FFELAB_typeENDIF
case|:
name|sprintf
argument_list|(
name|labelname
argument_list|,
literal|"%"
name|ffelabValue_f
literal|"u"
argument_list|,
name|ffelab_value
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|glabel
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|get_identifier
argument_list|(
name|labelname
argument_list|)
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|glabel
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_MODE
argument_list|(
name|glabel
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
break|break;
case|case
name|FFELAB_typeFORMAT
case|:
name|glabel
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_format_%d"
argument_list|,
operator|(
name|int
operator|)
name|ffelab_value
argument_list|(
name|label
argument_list|)
argument_list|)
argument_list|,
name|build_type_variant
argument_list|(
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|glabel
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|glabel
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|glabel
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|glabel
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|glabel
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expand_decl
argument_list|(
name|glabel
argument_list|)
expr_stmt|;
name|ffecom_save_tree_forever
argument_list|(
name|glabel
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeANY
case|:
name|glabel
operator|=
name|error_mark_node
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad label type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|glabel
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|ffelab_set_hook
argument_list|(
name|label
argument_list|,
name|glabel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glabel
operator|=
name|ffelab_hook
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
return|return
name|glabel
return|;
block|}
end_function

begin_comment
comment|/* Stabilizes the arguments.  Don't use this if the lhs and rhs come from    a single source specification (as in the fourth argument of MVBITS).    If the type is NULL_TREE, the type of lhs is used to make the type of    the MODIFY_EXPR.  */
end_comment

begin_function
name|tree
name|ffecom_modify
parameter_list|(
name|tree
name|newtype
parameter_list|,
name|tree
name|lhs
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
if|if
condition|(
name|lhs
operator|==
name|error_mark_node
operator|||
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|newtype
operator|==
name|NULL_TREE
condition|)
name|newtype
operator|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
condition|)
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
return|return
name|ffecom_2s
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|newtype
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Register source file name.  */
end_comment

begin_function
name|void
name|ffecom_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ffecom_file_
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffecom_notify_init_storage -- An aggregate storage is now fully init'ed     ffestorag st;    ffecom_notify_init_storage(st);     Gets called when all possible units in an aggregate storage area (a LOCAL    with equivalences or a COMMON) have been initialized.  The initialization    info either is in ffestorag_init or, if that is NULL,    ffestorag_accretion:     ffestorag_init may contain an opCONTER or opARRTER.	opCONTER may occur    even for an array if the array is one element in length!     ffestorag_accretion will contain an opACCTER.  It is much like an    opARRTER except it has an ffebit object in it instead of just a size.    The back end can use the info in the ffebit object, if it wants, to    reduce the amount of actual initialization, but in any case it should    kill the ffebit object when done.  Also, set accretion to NULL but    init to a non-NULL value.     After performing initialization, DO NOT set init to NULL, because that'll    tell the front end it is ok for more initialization to happen.  Instead,    set init to an opANY expression or some such thing that you can use to    tell that you've already initialized the object.     27-Oct-91  JCB  1.1       Support two-pass FFE.  */
end_comment

begin_function
name|void
name|ffecom_notify_init_storage
parameter_list|(
name|ffestorag
name|st
parameter_list|)
block|{
name|ffebld
name|init
decl_stmt|;
comment|/* The initialization expression. */
if|if
condition|(
name|ffestorag_init
argument_list|(
name|st
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|init
operator|=
name|ffestorag_accretion
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|init
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffestorag_set_accretion
argument_list|(
name|st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestorag_set_accretes
argument_list|(
name|st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffestorag_set_init
argument_list|(
name|st
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffecom_notify_init_symbol -- A symbol is now fully init'ed     ffesymbol s;    ffecom_notify_init_symbol(s);     Gets called when all possible units in a symbol (not placed in COMMON    or involved in EQUIVALENCE, unless it as yet has no ffestorag object)    have been initialized.  The initialization info either is in    ffesymbol_init or, if that is NULL, ffesymbol_accretion:     ffesymbol_init may contain an opCONTER or opARRTER.	opCONTER may occur    even for an array if the array is one element in length!     ffesymbol_accretion will contain an opACCTER.  It is much like an    opARRTER except it has an ffebit object in it instead of just a size.    The back end can use the info in the ffebit object, if it wants, to    reduce the amount of actual initialization, but in any case it should    kill the ffebit object when done.  Also, set accretion to NULL but    init to a non-NULL value.     After performing initialization, DO NOT set init to NULL, because that'll    tell the front end it is ok for more initialization to happen.  Instead,    set init to an opANY expression or some such thing that you can use to    tell that you've already initialized the object.     27-Oct-91  JCB  1.1       Support two-pass FFE.  */
end_comment

begin_function
name|void
name|ffecom_notify_init_symbol
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|ffebld
name|init
decl_stmt|;
comment|/* The initialization expression. */
if|if
condition|(
name|ffesymbol_storage
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
condition|)
return|return;
comment|/* Do nothing until COMMON/EQUIVALENCE 				   possibilities checked. */
if|if
condition|(
operator|(
name|ffesymbol_init
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|init
operator|=
name|ffesymbol_accretion
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ffesymbol_set_accretion
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffesymbol_set_accretes
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffesymbol_set_init
argument_list|(
name|s
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffecom_notify_primary_entry -- Learn which is the primary entry point     ffesymbol s;    ffecom_notify_primary_entry(s);     Gets called when implicit or explicit PROGRAM statement seen or when    FUNCTION, SUBROUTINE, or BLOCK DATA statement seen, with the primary    global symbol that serves as the entry point.  */
end_comment

begin_function
name|void
name|ffecom_notify_primary_entry
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|ffecom_primary_entry_
operator|=
name|s
expr_stmt|;
name|ffecom_primary_entry_kind_
operator|=
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffecom_primary_entry_kind_
operator|==
name|FFEINFO_kindFUNCTION
operator|)
operator|||
operator|(
name|ffecom_primary_entry_kind_
operator|==
name|FFEINFO_kindSUBROUTINE
operator|)
condition|)
name|ffecom_primary_entry_is_proc_
operator|=
name|TRUE
expr_stmt|;
else|else
name|ffecom_primary_entry_is_proc_
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|ffe_is_silent
argument_list|()
condition|)
block|{
if|if
condition|(
name|ffecom_primary_entry_kind_
operator|==
name|FFEINFO_kindPROGRAM
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:\n"
argument_list|,
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s:\n"
argument_list|,
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffecom_primary_entry_kind_
operator|==
name|FFEINFO_kindSUBROUTINE
condition|)
block|{
name|ffebld
name|list
decl_stmt|;
name|ffebld
name|arg
decl_stmt|;
for|for
control|(
name|list
operator|=
name|ffesymbol_dummyargs
argument_list|(
name|s
argument_list|)
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
control|)
block|{
name|arg
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|arg
argument_list|)
operator|==
name|FFEBLD_opSTAR
condition|)
block|{
name|ffecom_is_altreturning_
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
name|FILE
modifier|*
name|ffecom_open_include
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|ffewhereLine
name|l
parameter_list|,
name|ffewhereColumn
name|c
parameter_list|)
block|{
return|return
name|ffecom_open_include_
argument_list|(
name|name
argument_list|,
name|l
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffecom_ptr_to_expr -- Transform expr into gcc tree with& in front     tree t;    ffebld expr;	 // FFE expression.    tree = ffecom_ptr_to_expr(expr);     Like ffecom_expr, but sticks address-of in front of most things.  */
end_comment

begin_function
name|tree
name|ffecom_ptr_to_expr
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|tree
name|item
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|assert
argument_list|(
name|expr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opSYMTER
case|:
name|s
operator|=
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereINTRINSIC
condition|)
block|{
name|ffecomGfrt
name|ix
decl_stmt|;
name|ix
operator|=
name|ffeintrin_gfrt_indirect
argument_list|(
name|ffebld_symter_implementation
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ix
operator|!=
name|FFECOM_gfrt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|item
operator|=
name|ffecom_gfrt_
index|[
name|ix
index|]
operator|)
operator|==
name|NULL_TREE
condition|)
block|{
name|ffecom_make_gfrt_
argument_list|(
name|ix
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_gfrt_
index|[
name|ix
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|item
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL_TREE
condition|)
block|{
name|s
operator|=
name|ffecom_sym_transform_
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|decl_tree
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|item
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|error_mark_node
condition|)
return|return
name|item
return|;
if|if
condition|(
operator|!
name|ffesymbol_hook
argument_list|(
name|s
argument_list|)
operator|.
name|addr
condition|)
name|item
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|,
name|item
argument_list|)
expr_stmt|;
return|return
name|item
return|;
case|case
name|FFEBLD_opARRAYREF
case|:
return|return
name|ffecom_arrayref_
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|FFEBLD_opCONTER
case|:
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_constantunion
argument_list|(
operator|&
name|ffebld_constant_union
argument_list|(
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|,
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|item
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|,
name|item
argument_list|)
expr_stmt|;
return|return
name|item
return|;
case|case
name|FFEBLD_opANY
case|:
return|return
name|error_mark_node
return|;
default|default:
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* The back end currently optimizes a bit too zealously for us, in that 	 we fail JCB001 if the following block of code is omitted.  It checks 	 to see if the transformed expression is a symbol or array reference, 	 and encloses it in a SAVE_EXPR if that is the case.  */
name|STRIP_NOPS
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|item
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|item
argument_list|)
operator|==
name|PARM_DECL
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|item
argument_list|)
operator|==
name|RESULT_DECL
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|item
argument_list|)
operator|==
name|INDIRECT_REF
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|item
argument_list|)
operator|==
name|ARRAY_REF
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|item
argument_list|)
operator|==
name|COMPONENT_REF
operator|)
ifdef|#
directive|ifdef
name|OFFSET_REF
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|item
argument_list|)
operator|==
name|OFFSET_REF
operator|)
endif|#
directive|endif
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|item
argument_list|)
operator|==
name|BUFFER_REF
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|item
argument_list|)
operator|==
name|REALPART_EXPR
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|item
argument_list|)
operator|==
name|IMAGPART_EXPR
operator|)
condition|)
block|{
name|item
operator|=
name|ffecom_save_tree
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
name|item
operator|=
name|ffecom_1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|,
name|item
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
name|assert
argument_list|(
literal|"fall-through error"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Obtain a temp var with given data type.     size is FFETARGET_charactersizeNONE for a non-CHARACTER type    or>= 0 for a CHARACTER type.     elements is -1 for a scalar or> 0 for an array of type.  */
end_comment

begin_function
name|tree
name|ffecom_make_tempvar
parameter_list|(
specifier|const
name|char
modifier|*
name|commentary
parameter_list|,
name|tree
name|type
parameter_list|,
name|ffetargetCharacterSize
name|size
parameter_list|,
name|int
name|elements
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
specifier|static
name|int
name|mynumber
decl_stmt|;
name|assert
argument_list|(
name|current_binding_level
operator|->
name|prep_state
operator|<
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|size
operator|!=
name|FFETARGET_charactersizeNONE
condition|)
name|type
operator|=
name|build_array_type
argument_list|(
name|type
argument_list|,
name|build_range_type
argument_list|(
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|ffecom_f2c_ftnlen_one_node
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elements
operator|!=
operator|-
literal|1
condition|)
name|type
operator|=
name|build_array_type
argument_list|(
name|type
argument_list|,
name|build_range_type
argument_list|(
name|integer_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|build_int_2
argument_list|(
name|elements
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_%s_%d"
argument_list|,
name|commentary
argument_list|,
name|mynumber
operator|++
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|start_decl
argument_list|(
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Prepare argument pointer to expression.     Like ffecom_prepare_expr, except for expressions to be evaluated    via ffecom_arg_ptr_to_expr.  */
end_comment

begin_function
name|void
name|ffecom_prepare_arg_ptr_to_expr
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
comment|/* ~~For now, it seems to be the same thing.  */
name|ffecom_prepare_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* End of preparations.  */
end_comment

begin_function
name|bool
name|ffecom_prepare_end
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|prep_state
init|=
name|current_binding_level
operator|->
name|prep_state
decl_stmt|;
name|assert
argument_list|(
name|prep_state
operator|<
literal|2
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|prep_state
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|prep_state
operator|==
literal|1
operator|)
condition|?
name|TRUE
else|:
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Prepare expression.     This is called before any code is generated for the current block.    It scans the expression, declares any temporaries that might be needed    during evaluation of the expression, and stores those temporaries in    the appropriate "hook" fields of the expression.  `dest', if not NULL,    specifies the destination that ffecom_expr_ will see, in case that    helps avoid generating unused temporaries.     ~~Improve to avoid allocating unused temporaries by taking `dest'    into account vis-a-vis aliasing requirements of complex/character    functions.  */
end_comment

begin_function
name|void
name|ffecom_prepare_expr_
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffebld
name|dest
name|UNUSED
parameter_list|)
block|{
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|ffetargetCharacterSize
name|sz
decl_stmt|;
name|tree
name|tempvar
init|=
name|NULL_TREE
decl_stmt|;
name|assert
argument_list|(
name|current_binding_level
operator|->
name|prep_state
operator|<
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expr
condition|)
return|return;
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|sz
operator|=
name|ffeinfo_size
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate whatever temporaries are needed to represent the result      of the expression.  */
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
block|{
while|while
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opPAREN
condition|)
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
default|default:
comment|/* Don't make temps for SYMTER, CONTER, etc.  */
if|if
condition|(
name|ffebld_arity
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
condition|)
break|break;
switch|switch
condition|(
name|bt
condition|)
block|{
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opFUNCREF
condition|)
block|{
name|ffesymbol
name|s
decl_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
condition|)
break|break;
name|s
operator|=
name|ffebld_symter
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereCONSTANT
operator|||
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereINTRINSIC
operator|&&
operator|!
name|ffesymbol_is_f2c
argument_list|(
name|s
argument_list|)
operator|)
operator|||
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereINTRINSIC
operator|&&
operator|!
name|ffe_is_f2c_library
argument_list|()
operator|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opPOWER
condition|)
block|{
comment|/* Requires special treatment.  There's no POW_CC function 		 in libg2c, so POW_ZZ is used, which means we always 		 need a double-complex temp, not a single-complex.  */
name|kt
operator|=
name|FFEINFO_kindtypeREAL2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opDIVIDE
condition|)
comment|/* The other ops don't need temps for complex operands.  */
break|break;
comment|/* ~~~Avoid making temps for some intrinsics, such as AIMAG(C), 	     REAL(C).  See 19990325-0.f, routine `check', for cases.  */
name|tempvar
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"complex"
argument_list|,
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeCOMPLEX
index|]
index|[
name|kt
index|]
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opFUNCREF
condition|)
break|break;
if|if
condition|(
name|sz
operator|==
name|FFETARGET_charactersizeNONE
condition|)
comment|/* ~~Kludge alert!  This should someday be fixed. */
name|sz
operator|=
literal|24
expr_stmt|;
name|tempvar
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"char"
argument_list|,
name|char_type_node
argument_list|,
name|sz
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
ifdef|#
directive|ifdef
name|HAHA
case|case
name|FFEBLD_opPOWER
case|:
block|{
name|tree
name|rtype
decl_stmt|,
name|ltype
decl_stmt|;
name|tree
name|rtmp
decl_stmt|,
name|ltmp
decl_stmt|,
name|result
decl_stmt|;
name|ltype
operator|=
name|ffecom_type_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|rtype
operator|=
name|ffecom_type_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|rtmp
operator|=
name|ffecom_make_tempvar
argument_list|(
name|rtype
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ltmp
operator|=
name|ffecom_make_tempvar
argument_list|(
name|ltype
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|ffecom_make_tempvar
argument_list|(
name|ltype
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tempvar
operator|=
name|make_tree_vec
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|tempvar
argument_list|,
literal|0
argument_list|)
operator|=
name|rtmp
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|tempvar
argument_list|,
literal|1
argument_list|)
operator|=
name|ltmp
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|tempvar
argument_list|,
literal|2
argument_list|)
operator|=
name|result
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* HAHA */
case|case
name|FFEBLD_opCONCATENATE
case|:
block|{
comment|/* This gets special handling, because only one set of temps 	   is needed for a tree of these -- the tree is treated as 	   a flattened list of concatenations when generating code.  */
name|ffecomConcatList_
name|catlist
decl_stmt|;
name|tree
name|ltmp
decl_stmt|,
name|itmp
decl_stmt|,
name|result
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|catlist
operator|=
name|ffecom_concat_list_new_
argument_list|(
name|expr
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
expr_stmt|;
name|count
operator|=
name|ffecom_concat_list_count_
argument_list|(
name|catlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|2
condition|)
block|{
name|ltmp
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"concat_len"
argument_list|,
name|ffecom_f2c_ftnlen_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|itmp
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"concat_item"
argument_list|,
name|ffecom_f2c_address_type_node
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|result
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"concat_res"
argument_list|,
name|char_type_node
argument_list|,
name|ffecom_concat_list_maxlen_
argument_list|(
name|catlist
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tempvar
operator|=
name|make_tree_vec
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|tempvar
argument_list|,
literal|0
argument_list|)
operator|=
name|ltmp
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|tempvar
argument_list|,
literal|1
argument_list|)
operator|=
name|itmp
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|tempvar
argument_list|,
literal|2
argument_list|)
operator|=
name|result
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|ffecom_prepare_arg_ptr_to_expr
argument_list|(
name|ffecom_concat_list_expr_
argument_list|(
name|catlist
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_concat_list_kill_
argument_list|(
name|catlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempvar
condition|)
block|{
name|ffebld_nonter_set_hook
argument_list|(
name|expr
argument_list|,
name|tempvar
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|prep_state
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return;
case|case
name|FFEBLD_opCONVERT
case|:
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
operator|&&
operator|(
operator|(
name|ffebld_size_known
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFETARGET_charactersizeNONE
operator|)
operator|||
operator|(
name|ffebld_size_known
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|>=
name|sz
operator|)
operator|)
condition|)
name|tempvar
operator|=
name|ffecom_make_tempvar
argument_list|(
literal|"convert"
argument_list|,
name|char_type_node
argument_list|,
name|sz
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tempvar
condition|)
block|{
name|ffebld_nonter_set_hook
argument_list|(
name|expr
argument_list|,
name|tempvar
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|prep_state
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Prepare subexpressions for this expr.  */
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opPERCENT_LOC
case|:
name|ffecom_prepare_ptr_to_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opPERCENT_VAL
case|:
case|case
name|FFEBLD_opPERCENT_REF
case|:
name|ffecom_prepare_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opPERCENT_DESCR
case|:
name|ffecom_prepare_arg_ptr_to_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opITEM
case|:
block|{
name|ffebld
name|item
decl_stmt|;
for|for
control|(
name|item
operator|=
name|expr
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
if|if
condition|(
name|ffebld_head
argument_list|(
name|item
argument_list|)
operator|!=
name|NULL
condition|)
name|ffecom_prepare_expr
argument_list|(
name|ffebld_head
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Need to handle character conversion specially.  */
switch|switch
condition|(
name|ffebld_arity
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
name|ffecom_prepare_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_prepare_expr
argument_list|(
name|ffebld_right
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ffecom_prepare_expr
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Prepare expression for reading and writing.     Like ffecom_prepare_expr, except for expressions to be evaluated    via ffecom_expr_rw.  */
end_comment

begin_function
name|void
name|ffecom_prepare_expr_rw
parameter_list|(
name|tree
name|type
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
comment|/* This is all we support for now.  */
name|assert
argument_list|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|ffecom_type_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ~~For now, it seems to be the same thing.  */
name|ffecom_prepare_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Prepare expression for writing.     Like ffecom_prepare_expr, except for expressions to be evaluated    via ffecom_expr_w.  */
end_comment

begin_function
name|void
name|ffecom_prepare_expr_w
parameter_list|(
name|tree
name|type
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
comment|/* This is all we support for now.  */
name|assert
argument_list|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|ffecom_type_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ~~For now, it seems to be the same thing.  */
name|ffecom_prepare_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Prepare expression for returning.     Like ffecom_prepare_expr, except for expressions to be evaluated    via ffecom_return_expr.  */
end_comment

begin_function
name|void
name|ffecom_prepare_return_expr
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|assert
argument_list|(
name|current_binding_level
operator|->
name|prep_state
operator|<
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffecom_primary_entry_kind_
operator|==
name|FFEINFO_kindSUBROUTINE
operator|&&
name|ffecom_is_altreturning_
operator|&&
name|expr
operator|!=
name|NULL
condition|)
name|ffecom_prepare_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare pointer to expression.     Like ffecom_prepare_expr, except for expressions to be evaluated    via ffecom_ptr_to_expr.  */
end_comment

begin_function
name|void
name|ffecom_prepare_ptr_to_expr
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
comment|/* ~~For now, it seems to be the same thing.  */
name|ffecom_prepare_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Transform expression into constant pointer-to-expression tree.     If the expression can be transformed into a pointer-to-expression tree    that is constant, that is done, and the tree returned.  Else NULL_TREE    is returned.     That way, a caller can attempt to provide compile-time initialization    of a variable and, if that fails, *then* choose to start a new block    and resort to using temporaries, as appropriate.  */
end_comment

begin_function
name|tree
name|ffecom_ptr_to_const_expr
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|expr
condition|)
return|return
name|integer_zero_node
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|ffebld_arity
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|||
name|ffebld_where
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEINFO_whereCOMMON
operator|||
name|ffebld_where
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEINFO_whereGLOBAL
operator|||
name|ffebld_where
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEINFO_whereINTRINSIC
operator|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|ffecom_ptr_to_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* ffecom_return_expr -- Returns return-value expr given alt return expr     tree rtn;  // NULL_TREE means use expand_null_return()    ffebld expr;	 // NULL if no alt return expr to RETURN stmt    rtn = ffecom_return_expr(expr);     Based on the program unit type and other info (like return function    type, return master function type when alternate ENTRY points,    whether subroutine has any alternate RETURN points, etc), returns the    appropriate expression to be returned to the caller, or NULL_TREE    meaning no return value or the caller expects it to be returned somewhere    else (which is handled by other parts of this module).  */
end_comment

begin_function
name|tree
name|ffecom_return_expr
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|tree
name|rtn
decl_stmt|;
switch|switch
condition|(
name|ffecom_primary_entry_kind_
condition|)
block|{
case|case
name|FFEINFO_kindPROGRAM
case|:
case|case
name|FFEINFO_kindBLOCKDATA
case|:
name|rtn
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindSUBROUTINE
case|:
if|if
condition|(
operator|!
name|ffecom_is_altreturning_
condition|)
name|rtn
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* No alt returns, never an expr. */
elseif|else
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
name|rtn
operator|=
name|integer_zero_node
expr_stmt|;
else|else
name|rtn
operator|=
name|ffecom_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindFUNCTION
case|:
if|if
condition|(
operator|(
name|ffecom_multi_retval_
operator|!=
name|NULL_TREE
operator|)
operator|||
operator|(
name|ffesymbol_basictype
argument_list|(
name|ffecom_primary_entry_
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
operator|||
operator|(
operator|(
name|ffesymbol_basictype
argument_list|(
name|ffecom_primary_entry_
argument_list|)
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|&&
operator|(
name|ffecom_num_entrypoints_
operator|==
literal|0
operator|)
operator|&&
name|ffesymbol_is_f2c
argument_list|(
name|ffecom_primary_entry_
argument_list|)
operator|)
condition|)
block|{
comment|/* Value is returned by direct assignment 				   into (implicit) dummy. */
name|rtn
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
name|rtn
operator|=
name|ffecom_func_result_
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Spurious error if RETURN happens before first reference!  So elide 	 this code.  In particular, for debugging registry, rtn should always 	 be non-null after all, but TREE_USED won't be set until we encounter 	 a reference in the code.  Perfectly okay (but weird) code that, 	 e.g., has "GOTO 20;10 RETURN;20 RTN=0;GOTO 10", would result in 	 this diagnostic for no reason.  Have people use -O -Wuninitialized 	 and leave it to the back end to find obviously weird cases.  */
comment|/* Used to "assert(rtn != NULL_TREE);" here, but it's kind of a valid 	 situation; if the return value has never been referenced, it won't 	 have a tree under 2pass mode. */
block|if ((rtn == NULL_TREE) 	  || !TREE_USED (rtn)) 	{ 	  ffebad_start (FFEBAD_RETURN_VALUE_UNSET); 	  ffebad_here (0, ffesymbol_where_line (ffecom_primary_entry_), 		       ffesymbol_where_column (ffecom_primary_entry_)); 	  ffebad_string (ffesymbol_text (ffesymbol_funcresult 					 (ffecom_primary_entry_))); 	  ffebad_finish (); 	}
endif|#
directive|endif
break|break;
default|default:
name|assert
argument_list|(
literal|"bad unit kind"
operator|==
name|NULL
argument_list|)
expr_stmt|;
case|case
name|FFEINFO_kindANY
case|:
name|rtn
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
return|return
name|rtn
return|;
block|}
end_function

begin_comment
comment|/* Do save_expr only if tree is not error_mark_node.  */
end_comment

begin_function
name|tree
name|ffecom_save_tree
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
name|save_expr
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Start a compound statement (block).  */
end_comment

begin_function
name|void
name|ffecom_start_compstmt
parameter_list|(
name|void
parameter_list|)
block|{
name|bison_rule_pushlevel_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Public entry point for front end to access start_decl.  */
end_comment

begin_function
name|tree
name|ffecom_start_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
name|is_initialized
parameter_list|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|is_initialized
condition|?
name|error_mark_node
else|:
name|NULL_TREE
expr_stmt|;
return|return
name|start_decl
argument_list|(
name|decl
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffecom_sym_commit -- Symbol's state being committed to reality     ffesymbol s;    ffecom_sym_commit(s);     Does whatever the backend needs when a symbol is committed after having    been backtrackable for a period of time.  */
end_comment

begin_function
name|void
name|ffecom_sym_commit
parameter_list|(
name|ffesymbol
name|s
name|UNUSED
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|ffesymbol_retractable
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffecom_sym_end_transition -- Perform end transition on all symbols     ffecom_sym_end_transition();     Does backend-specific stuff and also calls ffest_sym_end_transition    to do the necessary FFE stuff.     Backtracking is never enabled when this fn is called, so don't worry    about it.  */
end_comment

begin_function
name|ffesymbol
name|ffecom_sym_end_transition
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|ffestorag
name|st
decl_stmt|;
name|assert
argument_list|(
operator|!
name|ffesymbol_retractable
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffest_sym_end_transition
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_kindBLOCKDATA
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereGLOBAL
operator|)
condition|)
block|{
name|ffecom_list_blockdata_
operator|=
name|ffebld_new_item
argument_list|(
name|ffebld_new_symter
argument_list|(
name|s
argument_list|,
name|FFEINTRIN_genNONE
argument_list|,
name|FFEINTRIN_specNONE
argument_list|,
name|FFEINTRIN_impNONE
argument_list|)
argument_list|,
name|ffecom_list_blockdata_
argument_list|)
expr_stmt|;
block|}
comment|/* This is where we finally notice that a symbol has partial initialization      and finalize it. */
if|if
condition|(
name|ffesymbol_accretion
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|ffesymbol_init
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ffecom_notify_init_symbol
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|st
operator|=
name|ffesymbol_storage
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|st
operator|=
name|ffestorag_parent
argument_list|(
name|st
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffestorag_accretion
argument_list|(
name|st
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|assert
argument_list|(
name|ffestorag_init
argument_list|(
name|st
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ffecom_notify_init_storage
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_kindCOMMON
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereLOCAL
operator|)
operator|&&
operator|(
name|ffesymbol_storage
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ffecom_list_common_
operator|=
name|ffebld_new_item
argument_list|(
name|ffebld_new_symter
argument_list|(
name|s
argument_list|,
name|FFEINTRIN_genNONE
argument_list|,
name|FFEINTRIN_specNONE
argument_list|,
name|FFEINTRIN_impNONE
argument_list|)
argument_list|,
name|ffecom_list_common_
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* ffecom_sym_exec_transition -- Perform exec transition on all symbols     ffecom_sym_exec_transition();     Does backend-specific stuff and also calls ffest_sym_exec_transition    to do the necessary FFE stuff.     See the long-winded description in ffecom_sym_learned for info    on handling the situation where backtracking is inhibited.  */
end_comment

begin_function
name|ffesymbol
name|ffecom_sym_exec_transition
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|s
operator|=
name|ffest_sym_exec_transition
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* ffecom_sym_learned -- Initial or more info gained on symbol after exec     ffesymbol s;    s = ffecom_sym_learned(s);     Called when a new symbol is seen after the exec transition or when more    info (perhaps) is gained for an UNCERTAIN symbol.  The symbol state when    it arrives here is that all its latest info is updated already, so its    state may be UNCERTAIN or UNDERSTOOD, it might already have the hook    field filled in if its gone through here or exec_transition first, and    so on.     The backend probably wants to check ffesymbol_retractable() to see if    backtracking is in effect.  If so, the FFE's changes to the symbol may    be retracted (undone) or committed (ratified), at which time the    appropriate ffecom_sym_retract or _commit function will be called    for that function.     If the backend has its own backtracking mechanism, great, use it so that    committal is a simple operation.  Though it doesn't make much difference,    I suppose: the reason for tentative symbol evolution in the FFE is to    enable error detection in weird incorrect statements early and to disable    incorrect error detection on a correct statement.  The backend is not    likely to introduce any information that'll get involved in these    considerations, so it is probably just fine that the implementation    model for this fn and for _exec_transition is to not do anything    (besides the required FFE stuff) if ffesymbol_retractable() returns TRUE    and instead wait until ffecom_sym_commit is called (which it never    will be as long as we're using ambiguity-detecting statement analysis in    the FFE, which we are initially to shake out the code, but don't depend    on this), otherwise go ahead and do whatever is needed.     In essence, then, when this fn and _exec_transition get called while    backtracking is enabled, a general mechanism would be to flag which (or    both) of these were called (and in what order? neat question as to what    might happen that I'm too lame to think through right now) and then when    _commit is called reproduce the original calling sequence, if any, for    the two fns (at which point backtracking will, of course, be disabled).  */
end_comment

begin_function
name|ffesymbol
name|ffecom_sym_learned
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|ffestorag_exec_layout
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* ffecom_sym_retract -- Symbol's state being retracted from reality     ffesymbol s;    ffecom_sym_retract(s);     Does whatever the backend needs when a symbol is retracted after having    been backtrackable for a period of time.  */
end_comment

begin_function
name|void
name|ffecom_sym_retract
parameter_list|(
name|ffesymbol
name|s
name|UNUSED
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|ffesymbol_retractable
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GCC doesn't commit any backtrackable sins, 				   so nothing needed here. */
block|switch (ffesymbol_hook (s).state)     {     case 0:
comment|/* nothing happened yet. */
block|break;      case 1:
comment|/* exec transition happened. */
block|break;      case 2:
comment|/* learned happened. */
block|break;      case 3:
comment|/* learned then exec. */
block|break;      case 4:
comment|/* exec then learned. */
block|break;      default:       assert ("bad hook state" == NULL);       break;     }
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Create temporary gcc label.  */
end_comment

begin_function
name|tree
name|ffecom_temp_label
parameter_list|()
block|{
name|tree
name|glabel
decl_stmt|;
specifier|static
name|int
name|mynumber
init|=
literal|0
decl_stmt|;
name|glabel
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|ffecom_get_invented_identifier
argument_list|(
literal|"__g77_label_%d"
argument_list|,
name|mynumber
operator|++
argument_list|)
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|glabel
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_MODE
argument_list|(
name|glabel
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
return|return
name|glabel
return|;
block|}
end_function

begin_comment
comment|/* Return an expression that is usable as an arg in a conditional context    (IF, DO WHILE, .NOT., and so on).     Use the one provided for the back end as of>2.6.0.  */
end_comment

begin_function
name|tree
name|ffecom_truth_value
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
return|return
name|truthvalue_conversion
argument_list|(
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the inversion of a truth value (the inversion of what    ffecom_truth_value builds).     Apparently invert_truthvalue, which is properly in the back end, is    enough for now, so just use it.  */
end_comment

begin_function
name|tree
name|ffecom_truth_value_invert
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
return|return
name|invert_truthvalue
argument_list|(
name|ffecom_truth_value
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the tree that is the type of the expression, as would be    returned in TREE_TYPE(ffecom_expr(expr)), without otherwise    transforming the expression, generating temporaries, etc.  */
end_comment

begin_function
name|tree
name|ffecom_type_expr
parameter_list|(
name|ffebld
name|expr
parameter_list|)
block|{
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|tree
name|tree_type
decl_stmt|;
name|assert
argument_list|(
name|expr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|tree_type
operator|=
name|ffecom_tree_type
index|[
name|bt
index|]
index|[
name|kt
index|]
expr_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opCONTER
case|:
case|case
name|FFEBLD_opSYMTER
case|:
case|case
name|FFEBLD_opARRAYREF
case|:
case|case
name|FFEBLD_opUPLUS
case|:
case|case
name|FFEBLD_opPAREN
case|:
case|case
name|FFEBLD_opUMINUS
case|:
case|case
name|FFEBLD_opADD
case|:
case|case
name|FFEBLD_opSUBTRACT
case|:
case|case
name|FFEBLD_opMULTIPLY
case|:
case|case
name|FFEBLD_opDIVIDE
case|:
case|case
name|FFEBLD_opPOWER
case|:
case|case
name|FFEBLD_opNOT
case|:
case|case
name|FFEBLD_opFUNCREF
case|:
case|case
name|FFEBLD_opSUBRREF
case|:
case|case
name|FFEBLD_opAND
case|:
case|case
name|FFEBLD_opOR
case|:
case|case
name|FFEBLD_opXOR
case|:
case|case
name|FFEBLD_opNEQV
case|:
case|case
name|FFEBLD_opEQV
case|:
case|case
name|FFEBLD_opCONVERT
case|:
case|case
name|FFEBLD_opLT
case|:
case|case
name|FFEBLD_opLE
case|:
case|case
name|FFEBLD_opEQ
case|:
case|case
name|FFEBLD_opNE
case|:
case|case
name|FFEBLD_opGT
case|:
case|case
name|FFEBLD_opGE
case|:
case|case
name|FFEBLD_opPERCENT_LOC
case|:
return|return
name|tree_type
return|;
case|case
name|FFEBLD_opACCTER
case|:
case|case
name|FFEBLD_opARRTER
case|:
case|case
name|FFEBLD_opITEM
case|:
case|case
name|FFEBLD_opSTAR
case|:
case|case
name|FFEBLD_opBOUNDS
case|:
case|case
name|FFEBLD_opREPEAT
case|:
case|case
name|FFEBLD_opLABTER
case|:
case|case
name|FFEBLD_opLABTOK
case|:
case|case
name|FFEBLD_opIMPDO
case|:
case|case
name|FFEBLD_opCONCATENATE
case|:
case|case
name|FFEBLD_opSUBSTR
case|:
default|default:
name|assert
argument_list|(
literal|"bad op for ffecom_type_expr"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEBLD_opANY
case|:
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return PARM_DECL for arg#1 of master fn containing alternate ENTRY points     If the PARM_DECL already exists, return it, else create it.	It's an    integer_type_node argument for the master function that implements a    subroutine or function with more than one entrypoint and is bound at    run time with the entrypoint number (0 for SUBROUTINE/FUNCTION, 1 for    first ENTRY statement, and so on).  */
end_comment

begin_function
name|tree
name|ffecom_which_entrypoint_decl
parameter_list|()
block|{
name|assert
argument_list|(
name|ffecom_which_entrypoint_decl_
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|ffecom_which_entrypoint_decl_
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following sections consists of private and public functions    that have the same names and perform roughly the same functions    as counterparts in the C front end.  Changes in the C front end    might affect how things should be done here.  Only functions    needed by the back end should be public here; the rest should    be private (static in the C sense).  Functions needed by other    g77 front-end modules should be accessed by them via public    ffecom_* names, which should themselves call private versions    in this section so the private versions are easy to recognize    when upgrading to a new gcc and finding interesting changes    in the front end.     Functions named after rule "foo:" in c-parse.y are named    "bison_rule_foo_" so they are easy to find.  */
end_comment

begin_function
specifier|static
name|void
name|bison_rule_pushlevel_
parameter_list|()
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|bison_rule_compstmt_
parameter_list|()
block|{
name|tree
name|t
decl_stmt|;
name|int
name|keep
init|=
name|kept_level_p
argument_list|()
decl_stmt|;
comment|/* Make the temps go away.  */
if|if
condition|(
operator|!
name|keep
condition|)
name|current_binding_level
operator|->
name|names
operator|=
name|NULL_TREE
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
name|keep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|poplevel
argument_list|(
name|keep
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a definition for a builtin function named NAME and whose data type    is TYPE.  TYPE should be a function type with argument types.    FUNCTION_CODE tells later passes how to compile calls to this function.    See tree.h for its possible values.     If LIBRARY_NAME is nonzero, use that for DECL_ASSEMBLER_NAME,    the name to be called if we can't opencode the function.  */
end_comment

begin_function
name|tree
name|builtin_function
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|function_code
parameter_list|,
name|enum
name|built_in_class
name|class
parameter_list|,
specifier|const
name|char
modifier|*
name|library_name
parameter_list|)
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|library_name
condition|)
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|get_identifier
argument_list|(
name|library_name
argument_list|)
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|=
name|class
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|=
name|function_code
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Handle when a new declaration NEWDECL    has the same name as an old one OLDDECL    in the same binding contour.    Prints an error message if appropriate.     If safely possible, alter OLDDECL to look like NEWDECL, and return 1.    Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|duplicate_decls
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|)
block|{
name|int
name|types_match
init|=
literal|1
decl_stmt|;
name|int
name|new_is_definition
init|=
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|tree
name|newtype
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|olddecl
operator|==
name|newdecl
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newtype
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|oldtype
argument_list|)
operator|==
name|ERROR_MARK
condition|)
name|types_match
operator|=
literal|0
expr_stmt|;
comment|/* New decl is completely inconsistent with the old one =>      tell caller to replace the old one.      This is always an error except in the case of shadowing a builtin.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* For real parm decl following a forward decl,      return 1 so old decl will be reused.  */
if|if
condition|(
name|types_match
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* The new declaration is the same kind of object as the old one.      The declarations may partially match.  Print warnings if they don't      match enough.  Ultimately, copy most of the information from the new      decl to the old one, and keep using the old one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* A function declaration for a built-in function.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
comment|/* Accept the return type of the new declaration if same modes.  */
name|tree
name|oldreturntype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|newreturntype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|oldreturntype
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|newreturntype
argument_list|)
condition|)
block|{
comment|/* Function types may be shared, so we can't just modify 		 the return type of olddecl's function type.  */
name|tree
name|newtype
init|=
name|build_function_type
argument_list|(
name|newreturntype
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|types_match
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|types_match
condition|)
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|newtype
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|types_match
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* A function declaration for a predeclared function 	 that isn't actually built in.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
comment|/* If the types don't match, preserve volatility indication. 	     Later on, we will discard everything else about the 	     default declaration.  */
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
operator||=
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Copy all the DECL_... slots specified in the new decl      except for any that we copy here from the old type.       Past this point, we don't change OLDTYPE and NEWTYPE      even if we change the types of NEWDECL and OLDDECL.  */
if|if
condition|(
name|types_match
condition|)
block|{
comment|/* Merge the data types specified in the two decls.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* Lay the type out, unless already done.  */
if|if
condition|(
name|oldtype
operator|!=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|CONST_DECL
condition|)
name|layout_decl
argument_list|(
name|newdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since the type is OLDDECL's, make OLDDECL's size go with.  */
name|DECL_SIZE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SIZE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
if|if
condition|(
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
operator|>
name|DECL_ALIGN
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_USER_ALIGN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Keep the old rtl since we can safely use it.  */
name|COPY_DECL_RTL
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
comment|/* Merge the type qualifiers.  */
if|if
condition|(
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|make_var_volatile
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* Keep source location of definition rather than declaration. 	 Likewise, keep decl at outer scope.  */
if|if
condition|(
operator|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|DECL_SOURCE_LINE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Merge the unused-warning information.  */
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Merge the initialization information.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Merge the section attribute. 	 We want to issue an error if the sections conflict but that must be 	 done later in decl_attributes since we are called before attributes 	 are assigned.  */
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SECTION_NAME
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If cannot merge, then use the new type and qualifiers,      and don't preserve the old rtl.  */
else|else
block|{
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the storage class information.  */
comment|/* For functions, static overrides non-static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|&=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* This is since we don't automatically 	 copy the attributes of NEWDECL into OLDDECL.  */
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* If this clears `static', clear it in the identifier too.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* An extern decl does not override previous storage class.  */
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* If either decl says `inline', this fn is inline,      unless its definition was passed already.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Get rid of any built-in function if new arg types don't match it      or if we have a function definition.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
operator|!
name|types_match
operator|||
name|new_is_definition
operator|)
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|DECL_BUILT_IN_CLASS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|NOT_BUILT_IN
expr_stmt|;
block|}
comment|/* If redeclaring a builtin function, and not a definition,      it stays built in.      Also preserve various other info from the definition.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|new_is_definition
condition|)
block|{
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|DECL_BUILT_IN_CLASS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_BUILT_IN_CLASS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SAVED_INSNS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Copy most of the decl-specific fields of NEWDECL into OLDDECL.      But preserve olddecl's DECL_UID.  */
block|{
specifier|register
name|unsigned
name|olddecl_uid
init|=
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
operator|=
name|olddecl_uid
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Finish processing of a declaration;    install its initial value.    If the length of an array type is not known before,    it must be determined now, from the initial value, or it is an error.  */
end_comment

begin_function
specifier|static
name|void
name|finish_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|,
name|bool
name|is_top_level
parameter_list|)
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|was_incomplete
init|=
operator|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|bool
name|at_top_level
init|=
operator|(
name|current_binding_level
operator|==
name|global_binding_level
operator|)
decl_stmt|;
name|bool
name|top_level
init|=
name|is_top_level
operator|||
name|at_top_level
decl_stmt|;
comment|/* Caller should pass TRUE for is_top_level only if we wouldn't be at top      level anyway.  */
name|assert
argument_list|(
operator|!
name|is_top_level
operator|||
operator|!
name|at_top_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|assert
argument_list|(
name|init
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Remember that PARM_DECL doesn't have a DECL_INITIAL field per se -- it      overlaps DECL_ARG_TYPE.  */
elseif|else
if|if
condition|(
name|init
operator|==
name|NULL_TREE
condition|)
name|assert
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|assert
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
else|else
block|{
comment|/* typedef foo = bar; store the type of bar as the type of foo.  */
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Deduce size of array from initialization, if not already known */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|assert
argument_list|(
name|top_level
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|was_incomplete
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|?
comment|/* A static variable with an incomplete type is an error if it is 	 initialized. Also if it is not file scope. Otherwise, let it 	 through, but if it is not `extern' then it may cause an error 	 message later.  */
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|||
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|)
else|:
comment|/* An automatic variable with an incomplete type is an error.  */
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
name|assert
argument_list|(
literal|"storage size not known"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
operator|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
block|{
name|assert
argument_list|(
literal|"storage size not constant"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Output the assembler code and/or RTL code for variables and functions,      unless the type is an undefined structure or union. If not, it will get      done when the type is completed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Recompute the RTL of a local array now if it used to be an 	     incomplete type.  */
if|if
condition|(
name|was_incomplete
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If we used it already as memory, it must stay in memory.  */
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If it's still incomplete now, no init will save it.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Compute and store the initial value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* At the end of a declaration, throw away any variable type sizes of types      defined inside that declaration.  There is no use computing them in the      following function definition.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|get_pending_sizes
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish up a function declaration and compile that function    all the way to assembler language output.  The free the storage    for the function definition.     This is called after parsing the body of the function definition.     NESTED is nonzero if the function being finished is nested in another.  */
end_comment

begin_function
specifier|static
name|void
name|finish_function
parameter_list|(
name|int
name|nested
parameter_list|)
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|assert
argument_list|(
name|fndecl
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|nested
condition|)
name|assert
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|assert
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/*  TREE_READONLY (fndecl) = 1;     This caused&foo to be of type ptr-to-const-function     which then got a warning when stored in a ptr-to-function variable.  */
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
name|BLOCK_SUPERCONTEXT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* Must mark the RESULT_DECL as being in this function.  */
name|DECL_CONTEXT
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* Obey `register' declarations if `setjmp' is called in this fn.  */
comment|/* Generate rtl for function exit.  */
name|expand_function_end
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is a nested function, protect the local variables in the stack 	 above us from being collected while we're compiling this function.  */
if|if
condition|(
name|nested
condition|)
name|ggc_push_context
argument_list|()
expr_stmt|;
comment|/* Run the optimizers and output the assembler code for this function.  */
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Undo the GC context switch.  */
if|if
condition|(
name|nested
condition|)
name|ggc_pop_context
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
operator|!
name|nested
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Stop pointing to the local nodes about to be freed.  */
comment|/* But DECL_INITIAL must remain nonzero so we know this was an actual 	 function definition.  */
comment|/* For a nested function, this is done in pop_f_function_context.  */
comment|/* If rest_of_compilation set this to 0, leave it 0.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|!=
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nested
condition|)
block|{
comment|/* Let the error reporting routines know that we're outside a function. 	 For a nested function, this value is used in pop_c_function_context 	 and then reset via pop_function_context.  */
name|ffecom_outer_function_decl_
operator|=
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Plug-in replacement for identifying the name of a decl and, for a    function, what we call it in diagnostics.  For now, "program unit"    should suffice, since it's a bit of a hassle to figure out which    of several kinds of things it is.  Note that it could conceivably    be a statement function, which probably isn't really a program unit    per se, but if that comes up, it should be easy to check (being a    nested function and all).  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|lang_printable_name
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|v
parameter_list|)
block|{
comment|/* Just to keep GCC quiet about the unused variable.      In theory, differing values of V should produce different      output.  */
switch|switch
condition|(
name|v
condition|)
block|{
default|default:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|"erroneous code"
return|;
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* g77's function to print out name of current function that caused    an error.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|lang_print_error_function
argument_list|(
name|diagnostic_context
operator|*
name|context
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
specifier|const
name|char
operator|*
name|file
argument_list|)
block|{
specifier|static
name|ffeglobal
name|last_g
init|=
name|NULL
decl_stmt|;
specifier|static
name|ffesymbol
name|last_s
init|=
name|NULL
decl_stmt|;
name|ffeglobal
name|g
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|kind
decl_stmt|;
if|if
condition|(
operator|(
name|ffecom_primary_entry_
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffesymbol_global
argument_list|(
name|ffecom_primary_entry_
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|g
operator|=
name|NULL
expr_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
name|kind
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|g
operator|=
name|ffesymbol_global
argument_list|(
name|ffecom_primary_entry_
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffecom_nested_entry_
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|ffecom_primary_entry_
expr_stmt|;
name|kind
operator|=
name|_
argument_list|(
name|ffeinfo_kind_message
argument_list|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|ffecom_nested_entry_
expr_stmt|;
name|kind
operator|=
name|_
argument_list|(
literal|"In statement function"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|last_g
operator|!=
name|g
operator|)
operator|||
operator|(
name|last_s
operator|!=
name|s
operator|)
condition|)
block|{
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Outside of any program unit:\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s `%s':\n"
argument_list|,
name|kind
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|last_g
operator|=
name|g
expr_stmt|;
name|last_s
operator|=
name|s
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Similar to `lookup_name' but look only at current binding level.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_name_current_level
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
specifier|register
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
return|return
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|t
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|name
condition|)
break|break;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Create a new `struct binding_level'.  */
end_comment

begin_function
specifier|static
name|struct
name|binding_level
modifier|*
name|make_binding_level
parameter_list|()
block|{
comment|/* NOSTRICT */
return|return
operator|(
expr|struct
name|binding_level
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|binding_level
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Save and restore the variables in this file and elsewhere    that keep track of the progress of compilation of the current function.    Used for nested functions.  */
end_comment

begin_struct
struct|struct
name|f_function
block|{
name|struct
name|f_function
modifier|*
name|next
decl_stmt|;
name|tree
name|named_labels
decl_stmt|;
name|tree
name|shadowed_labels
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|binding_level
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|f_function
modifier|*
name|f_function_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Restore the variables used during compilation of a C function.  */
end_comment

begin_function
specifier|static
name|void
name|pop_f_function_context
parameter_list|()
block|{
name|struct
name|f_function
modifier|*
name|p
init|=
name|f_function_chain
decl_stmt|;
name|tree
name|link
decl_stmt|;
comment|/* Bring back all the labels that were shadowed.  */
for|for
control|(
name|link
operator|=
name|shadowed_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|!=
name|error_mark_node
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|current_function_decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Stop pointing to the local nodes about to be freed.  */
comment|/* But DECL_INITIAL must remain nonzero so we know this was an actual 	 function definition.  */
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|pop_function_context
argument_list|()
expr_stmt|;
name|f_function_chain
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|named_labels
operator|=
name|p
operator|->
name|named_labels
expr_stmt|;
name|shadowed_labels
operator|=
name|p
operator|->
name|shadowed_labels
expr_stmt|;
name|current_binding_level
operator|=
name|p
operator|->
name|binding_level
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save and reinitialize the variables    used during compilation of a C function.  */
end_comment

begin_function
specifier|static
name|void
name|push_f_function_context
parameter_list|()
block|{
name|struct
name|f_function
modifier|*
name|p
init|=
operator|(
expr|struct
name|f_function
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|f_function
argument_list|)
argument_list|)
decl_stmt|;
name|push_function_context
argument_list|()
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|f_function_chain
expr_stmt|;
name|f_function_chain
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|named_labels
operator|=
name|named_labels
expr_stmt|;
name|p
operator|->
name|shadowed_labels
operator|=
name|shadowed_labels
expr_stmt|;
name|p
operator|->
name|binding_level
operator|=
name|current_binding_level
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|push_parm_decl
parameter_list|(
name|tree
name|parm
parameter_list|)
block|{
name|int
name|old_immediate_size_expand
init|=
name|immediate_size_expand
decl_stmt|;
comment|/* Don't try computing parm sizes now -- wait till fn is called.  */
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
comment|/* Fill in arg stuff.  */
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE_AS_WRITTEN
argument_list|(
name|parm
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* All implementation args are read-only. */
name|parm
operator|=
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|immediate_size_expand
operator|=
name|old_immediate_size_expand
expr_stmt|;
name|finish_decl
argument_list|(
name|parm
argument_list|,
name|NULL_TREE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL, if appropriate.  */
end_comment

begin_function
specifier|static
name|tree
name|pushdecl_top_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
specifier|register
name|tree
name|f
init|=
name|current_function_decl
decl_stmt|;
name|current_binding_level
operator|=
name|global_binding_level
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|t
operator|=
name|pushdecl
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
name|current_function_decl
operator|=
name|f
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Store the list of declarations of the current level.    This is done for the parameter declarations of a function being defined,    after they are modified in the light of any missing parameters.  */
end_comment

begin_function
specifier|static
name|tree
name|storedecls
parameter_list|(
name|decls
parameter_list|)
name|tree
name|decls
decl_stmt|;
block|{
return|return
name|current_binding_level
operator|->
name|names
operator|=
name|decls
return|;
block|}
end_function

begin_comment
comment|/* Store the parameter declarations into the current function declaration.    This is called after parsing the parameter declarations, before    digesting the body of the function.     For an old-style definition, modify the function's type    to specify at least the number of arguments.  */
end_comment

begin_function
specifier|static
name|void
name|store_parm_decls
parameter_list|(
name|int
name|is_main_program
name|UNUSED
parameter_list|)
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
if|if
condition|(
name|fndecl
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* This is a chain of PARM_DECLs from old-style parm declarations.  */
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|storedecls
argument_list|(
name|nreverse
argument_list|(
name|getdecls
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the RTL code for the function.  */
name|init_function_start
argument_list|(
name|fndecl
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* Set up parameters and prepare for return, for the function.  */
name|expand_function_start
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|start_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
name|is_top_level
parameter_list|)
block|{
specifier|register
name|tree
name|tem
decl_stmt|;
name|bool
name|at_top_level
init|=
operator|(
name|current_binding_level
operator|==
name|global_binding_level
operator|)
decl_stmt|;
name|bool
name|top_level
init|=
name|is_top_level
operator|||
name|at_top_level
decl_stmt|;
comment|/* Caller should pass TRUE for is_top_level only if we wouldn't be at top      level anyway.  */
name|assert
argument_list|(
operator|!
name|is_top_level
operator|||
operator|!
name|at_top_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|assert
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|top_level
condition|)
name|assert
argument_list|(
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|1
operator|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* For Fortran, we by default put things in .common when possible.  */
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Add this decl to the current binding level. TEM may equal DECL or it may      be a previous decl of the same name.  */
if|if
condition|(
name|is_top_level
condition|)
name|tem
operator|=
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* For a local variable, define the RTL now.  */
if|if
condition|(
operator|!
name|top_level
comment|/* But not if this is a duplicate decl and we preserved the rtl from the      previous one (which may or may not happen).  */
operator|&&
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|tem
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|expand_decl
argument_list|(
name|tem
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|DECL_INITIAL
argument_list|(
name|tem
argument_list|)
operator|!=
literal|0
condition|)
name|expand_decl
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    DECLSPECS and DECLARATOR are the parts of the declaration;    they describe the function's name and the type it returns,    but twisted together in a fashion that parallels the syntax of C.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns 1 on success.  If the DECLARATOR is not suitable for a function    (it defines a datum instead), we return 0, which tells    yyparse to report a parse error.     NESTED is nonzero for a function nested within another function.  */
end_comment

begin_function
specifier|static
name|void
name|start_function
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|nested
parameter_list|,
name|int
name|public
parameter_list|)
block|{
name|tree
name|decl1
decl_stmt|;
name|tree
name|restype
decl_stmt|;
name|int
name|old_immediate_size_expand
init|=
name|immediate_size_expand
decl_stmt|;
name|named_labels
operator|=
literal|0
expr_stmt|;
name|shadowed_labels
operator|=
literal|0
expr_stmt|;
comment|/* Don't expand any sizes in the return type of the function.  */
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nested
condition|)
block|{
name|assert
argument_list|(
operator|!
name|public
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|current_function_decl
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|current_function_decl
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
name|decl1
operator|=
name|current_function_decl
operator|=
name|error_mark_node
expr_stmt|;
else|else
block|{
name|decl1
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|=
name|public
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|nested
condition|)
name|DECL_INLINE
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|announce_function
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* Make the init_value nonzero so pushdecl knows this is not tentative. 	 error_mark_node is replaced below (in poplevel) with the BLOCK.  */
name|DECL_INITIAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Record the decl so that the function name is defined. If we already have 	 a decl for this name, and it is a FUNCTION_DECL, use the old decl.  */
name|current_function_decl
operator|=
name|pushdecl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nested
condition|)
name|ffecom_outer_function_decl_
operator|=
name|current_function_decl
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|prep_state
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
name|make_decl_rtl
argument_list|(
name|current_function_decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|restype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nested
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|ERROR_MARK
operator|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|immediate_size_expand
operator|=
name|old_immediate_size_expand
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Here are the public functions the GNU back end needs.  */
end_comment

begin_function
name|tree
name|convert
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|e
init|=
name|expr
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|e
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|assert
argument_list|(
literal|"void value not ignored as it ought to be"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
return|return
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|e
argument_list|)
return|;
if|if
condition|(
operator|(
name|code
operator|!=
name|RECORD_TYPE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
condition|)
name|e
operator|=
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_integer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_pointer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|REAL_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_real
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_complex
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
return|return
name|fold
argument_list|(
name|ffecom_convert_to_complex_
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
name|assert
argument_list|(
literal|"conversion to non-scalar type requested"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* integrate_decl_tree calls this function, but since we don't use the    DECL_LANG_SPECIFIC field, this is a no-op.  */
end_comment

begin_function
name|void
name|copy_lang_decl
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
name|UNUSED
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Return the list of declarations of the current level.    Note that this list is in reverse order unless/until    you nreverse it; and when you do nreverse it, you must    store the result back using `storedecls' or you will lose.  */
end_comment

begin_function
name|tree
name|getdecls
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|names
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if we are currently in the global binding level.  */
end_comment

begin_function
name|int
name|global_bindings_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|==
name|global_binding_level
return|;
block|}
end_function

begin_comment
comment|/* Print an error message for invalid use of an incomplete type.    VALUE is the expression that was used (or 0 if that isn't known)    and TYPE is the type that was invalid.  */
end_comment

begin_function
name|void
name|incomplete_type_error
parameter_list|(
name|value
parameter_list|,
name|type
parameter_list|)
name|tree
name|value
name|UNUSED
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
name|assert
argument_list|(
literal|"incomplete type?!?"
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark ARG for GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_binding_level
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|binding_level
modifier|*
name|level
init|=
operator|*
operator|(
expr|struct
name|binding_level
operator|*
operator|*
operator|)
name|arg
decl_stmt|;
while|while
condition|(
name|level
condition|)
block|{
name|ggc_mark_tree
argument_list|(
name|level
operator|->
name|names
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|level
operator|->
name|blocks
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|level
operator|->
name|this_block
argument_list|)
expr_stmt|;
name|level
operator|=
name|level
operator|->
name|level_chain
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ffecom_init_decl_processing
parameter_list|()
block|{
specifier|static
name|tree
modifier|*
specifier|const
name|tree_roots
index|[]
init|=
block|{
operator|&
name|current_function_decl
block|,
operator|&
name|string_type_node
block|,
operator|&
name|ffecom_tree_fun_type_void
block|,
operator|&
name|ffecom_integer_zero_node
block|,
operator|&
name|ffecom_integer_one_node
block|,
operator|&
name|ffecom_tree_subr_type
block|,
operator|&
name|ffecom_tree_ptr_to_subr_type
block|,
operator|&
name|ffecom_tree_blockdata_type
block|,
operator|&
name|ffecom_tree_xargc_
block|,
operator|&
name|ffecom_f2c_integer_type_node
block|,
operator|&
name|ffecom_f2c_ptr_to_integer_type_node
block|,
operator|&
name|ffecom_f2c_address_type_node
block|,
operator|&
name|ffecom_f2c_real_type_node
block|,
operator|&
name|ffecom_f2c_ptr_to_real_type_node
block|,
operator|&
name|ffecom_f2c_doublereal_type_node
block|,
operator|&
name|ffecom_f2c_complex_type_node
block|,
operator|&
name|ffecom_f2c_doublecomplex_type_node
block|,
operator|&
name|ffecom_f2c_longint_type_node
block|,
operator|&
name|ffecom_f2c_logical_type_node
block|,
operator|&
name|ffecom_f2c_flag_type_node
block|,
operator|&
name|ffecom_f2c_ftnlen_type_node
block|,
operator|&
name|ffecom_f2c_ftnlen_zero_node
block|,
operator|&
name|ffecom_f2c_ftnlen_one_node
block|,
operator|&
name|ffecom_f2c_ftnlen_two_node
block|,
operator|&
name|ffecom_f2c_ptr_to_ftnlen_type_node
block|,
operator|&
name|ffecom_f2c_ftnint_type_node
block|,
operator|&
name|ffecom_f2c_ptr_to_ftnint_type_node
block|,
operator|&
name|ffecom_outer_function_decl_
block|,
operator|&
name|ffecom_previous_function_decl_
block|,
operator|&
name|ffecom_which_entrypoint_decl_
block|,
operator|&
name|ffecom_float_zero_
block|,
operator|&
name|ffecom_float_half_
block|,
operator|&
name|ffecom_double_zero_
block|,
operator|&
name|ffecom_double_half_
block|,
operator|&
name|ffecom_func_result_
block|,
operator|&
name|ffecom_func_length_
block|,
operator|&
name|ffecom_multi_type_node_
block|,
operator|&
name|ffecom_multi_retval_
block|,
operator|&
name|named_labels
block|,
operator|&
name|shadowed_labels
block|}
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|malloc_init
argument_list|()
expr_stmt|;
comment|/* Record our roots.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|tree_roots
argument_list|)
condition|;
name|i
operator|++
control|)
name|ggc_add_tree_root
argument_list|(
name|tree_roots
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|ffecom_tree_type
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|FFEINFO_basictype
operator|*
name|FFEINFO_kindtype
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|ffecom_tree_fun_type
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|FFEINFO_basictype
operator|*
name|FFEINFO_kindtype
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|ffecom_tree_ptr_to_fun_type
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|FFEINFO_basictype
operator|*
name|FFEINFO_kindtype
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
name|ffecom_gfrt_
argument_list|,
name|FFECOM_gfrt
argument_list|)
expr_stmt|;
name|ggc_add_root
argument_list|(
operator|&
name|current_binding_level
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|current_binding_level
argument_list|,
name|mark_binding_level
argument_list|)
expr_stmt|;
name|ggc_add_root
argument_list|(
operator|&
name|free_binding_level
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|current_binding_level
argument_list|,
name|mark_binding_level
argument_list|)
expr_stmt|;
name|ggc_add_root
argument_list|(
operator|&
name|tracker_head
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|tracker_head
argument_list|,
name|mark_tracker_head
argument_list|)
expr_stmt|;
name|ffe_init_0
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete the node BLOCK from the current binding level.    This is used for the block inside a stmt expr ({...})    so that the block can be reinserted where appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|delete_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|blocks
operator|==
name|block
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|current_binding_level
operator|->
name|blocks
init|;
name|t
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|block
condition|)
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* Clear TREE_USED which is always set by poplevel.      The flag is set again if insert_block is called.  */
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Each front end provides its own.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ffe_init
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ffe_finish
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ffe_init_options
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ffe_print_identifier
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|LANG_HOOKS_NAME
end_undef

begin_define
define|#
directive|define
name|LANG_HOOKS_NAME
value|"GNU F77"
end_define

begin_undef
undef|#
directive|undef
name|LANG_HOOKS_INIT
end_undef

begin_define
define|#
directive|define
name|LANG_HOOKS_INIT
value|ffe_init
end_define

begin_undef
undef|#
directive|undef
name|LANG_HOOKS_FINISH
end_undef

begin_define
define|#
directive|define
name|LANG_HOOKS_FINISH
value|ffe_finish
end_define

begin_undef
undef|#
directive|undef
name|LANG_HOOKS_INIT_OPTIONS
end_undef

begin_define
define|#
directive|define
name|LANG_HOOKS_INIT_OPTIONS
value|ffe_init_options
end_define

begin_undef
undef|#
directive|undef
name|LANG_HOOKS_DECODE_OPTION
end_undef

begin_define
define|#
directive|define
name|LANG_HOOKS_DECODE_OPTION
value|ffe_decode_option
end_define

begin_undef
undef|#
directive|undef
name|LANG_HOOKS_PRINT_IDENTIFIER
end_undef

begin_define
define|#
directive|define
name|LANG_HOOKS_PRINT_IDENTIFIER
value|ffe_print_identifier
end_define

begin_comment
comment|/* We do not wish to use alias-set based aliasing at all.  Used in the    extreme (every object with its own set, with equivalences recorded) it    might be helpful, but there are problems when it comes to inlining.  We    get on ok with flag_argument_noalias, and alias-set aliasing does    currently limit how stack slots can be reused, which is a lose.  */
end_comment

begin_undef
undef|#
directive|undef
name|LANG_HOOKS_GET_ALIAS_SET
end_undef

begin_define
define|#
directive|define
name|LANG_HOOKS_GET_ALIAS_SET
value|hook_get_alias_set_0
end_define

begin_decl_stmt
specifier|const
name|struct
name|lang_hooks
name|lang_hooks
init|=
name|LANG_HOOKS_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ffe_init
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
comment|/* Open input file.  */
if|if
condition|(
name|filename
operator|==
literal|0
operator|||
operator|!
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|finput
operator|=
name|stdin
expr_stmt|;
name|filename
operator|=
literal|"stdin"
expr_stmt|;
block|}
else|else
name|finput
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|finput
operator|==
literal|0
condition|)
name|fatal_io_error
argument_list|(
literal|"can't open %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IO_BUFFER_SIZE
name|setvbuf
argument_list|(
name|finput
argument_list|,
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|IO_BUFFER_SIZE
argument_list|)
argument_list|,
name|_IOFBF
argument_list|,
name|IO_BUFFER_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ffecom_init_decl_processing
argument_list|()
expr_stmt|;
name|decl_printable_name
operator|=
name|lang_printable_name
expr_stmt|;
name|print_error_function
operator|=
name|lang_print_error_function
expr_stmt|;
comment|/* If the file is output from cpp, it should contain a first line      `# 1 "real-filename"', and the current design of gcc (toplev.c      in particular and the way it sets up information relied on by      INCLUDE) requires that we read this now, and store the      "real-filename" info in master_input_filename.  Ask the lexer      to try doing this.  */
name|ffelex_hash_kludge
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* FIXME: The ffelex_hash_kludge code needs to be cleaned up to      return the new file name.  */
if|if
condition|(
name|main_input_filename
condition|)
name|filename
operator|=
name|main_input_filename
expr_stmt|;
return|return
name|filename
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffe_finish
parameter_list|()
block|{
name|ffe_terminate_0
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffe_is_ffedebug
argument_list|()
condition|)
name|malloc_pool_display
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffe_init_options
parameter_list|()
block|{
comment|/* Set default options for Fortran.  */
name|flag_move_all_movables
operator|=
literal|1
expr_stmt|;
name|flag_reduce_all_givs
operator|=
literal|1
expr_stmt|;
name|flag_argument_noalias
operator|=
literal|2
expr_stmt|;
name|flag_merge_constants
operator|=
literal|2
expr_stmt|;
name|flag_errno_math
operator|=
literal|0
expr_stmt|;
name|flag_complex_divide_method
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mark_addressable
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|x
init|=
name|exp
decl_stmt|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|VAR_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|assert
argument_list|(
literal|"address of global register var requested"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|assert
argument_list|(
literal|"address of register variable requested"
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|assert
argument_list|(
literal|"address of global register var requested"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|assert
argument_list|(
literal|"address of register var requested"
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|put_var_into_stack
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* drops in */
case|case
name|FUNCTION_DECL
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* poplevel deals with this now.  */
block|if (DECL_CONTEXT (x) == 0) 	  TREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (x)) = 1;
endif|#
directive|endif
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* If DECL has a cleanup, build and return that cleanup here.    This is a callback called by expand_expr.  */
end_comment

begin_function
name|tree
name|maybe_build_cleanup
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
name|UNUSED
decl_stmt|;
block|{
comment|/* There are no cleanups in Fortran.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Exit a binding level.    Pop the level off, and restore the state of the identifier-decl mappings    that were in effect when this level was entered.     If KEEP is nonzero, this level had explicit declarations, so    and create a "block" (a BLOCK node) for the level    to record its declarations and subblocks for symbol table output.     If FUNCTIONBODY is nonzero, this level is the body of a function,    so create a block as if KEEP were set and also clear out all    label names.     If REVERSE is nonzero, reverse the order of decls before putting    them into the BLOCK.  */
end_comment

begin_function
name|tree
name|poplevel
parameter_list|(
name|keep
parameter_list|,
name|reverse
parameter_list|,
name|functionbody
parameter_list|)
name|int
name|keep
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|int
name|functionbody
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|;
comment|/* The chain of decls was accumulated in reverse order.      Put it into forward order, just for cleanliness.  */
name|tree
name|decls
decl_stmt|;
name|tree
name|subblocks
init|=
name|current_binding_level
operator|->
name|blocks
decl_stmt|;
name|tree
name|block
init|=
literal|0
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|block_previously_created
decl_stmt|;
comment|/* Get the decls in the order they were written.      Usually current_binding_level->names is in reverse order.      But parameter decls were previously put in forward order.  */
if|if
condition|(
name|reverse
condition|)
name|current_binding_level
operator|->
name|names
operator|=
name|decls
operator|=
name|nreverse
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|)
expr_stmt|;
else|else
name|decls
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
comment|/* Output any nested inline functions within this block      if they weren't already output.  */
for|for
control|(
name|decl
operator|=
name|decls
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If this decl was copied from a file-scope decl 	   on account of a block-scope extern decl, 	   propagate TREE_ADDRESSABLE to the file-scope decl.  	   DECL_ABSTRACT_ORIGIN can be set to itself if warn_return_type is 	   true, since then the decl goes through save_for_inline_copying.  */
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|!=
name|decl
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|push_function_context
argument_list|()
expr_stmt|;
name|output_inline_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pop_function_context
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If there were any declarations or structure tags in that level,      or if this level is a function body,      create a BLOCK to record them for the life of this function.  */
name|block
operator|=
literal|0
expr_stmt|;
name|block_previously_created
operator|=
operator|(
name|current_binding_level
operator|->
name|this_block
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|block_previously_created
condition|)
name|block
operator|=
name|current_binding_level
operator|->
name|this_block
expr_stmt|;
elseif|else
if|if
condition|(
name|keep
operator|||
name|functionbody
condition|)
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|decls
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|subblocks
expr_stmt|;
block|}
comment|/* In each subblock, record that this is its superior.  */
for|for
control|(
name|link
operator|=
name|subblocks
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|BLOCK_SUPERCONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|block
expr_stmt|;
comment|/* Clear out the meanings of the local variables of this level.  */
for|for
control|(
name|link
operator|=
name|decls
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* If the ident. was used or addressed via a local extern decl, 	     don't forget that fact.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|link
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|link
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|link
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If the level being exited is the top level of a function,      check over all the labels, and clear out the current      (function local) meanings of their names.  */
if|if
condition|(
name|functionbody
condition|)
block|{
comment|/* If this is the top level block of a function, 	 the vars are the function's parameters. 	 Don't leave them in the BLOCK because they are 	 found in the FUNCTION_DECL instead.  */
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Pop the current level, and free the structure for reuse.  */
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
name|level
operator|->
name|level_chain
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|level
expr_stmt|;
block|}
comment|/* Dispose of the block that we just made inside some higher level.  */
if|if
condition|(
name|functionbody
operator|&&
name|current_function_decl
operator|!=
name|error_mark_node
condition|)
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|block
expr_stmt|;
elseif|else
if|if
condition|(
name|block
condition|)
block|{
if|if
condition|(
operator|!
name|block_previously_created
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* If we did not make a block for the level just exited,      any blocks made for inner levels      (since they cannot be recorded as subblocks in that level)      must be carried forward so they will later become subblocks      of something else.  */
elseif|else
if|if
condition|(
name|subblocks
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|subblocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
condition|)
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffe_print_identifier
parameter_list|(
name|file
parameter_list|,
name|node
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|node
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
name|print_node
argument_list|(
name|file
argument_list|,
literal|"global"
argument_list|,
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"local"
argument_list|,
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record a decl-node X as belonging to the current lexical scope.    Check for errors (such as an incompatible declaration for the same    name already seen in the same scope).     Returns either X or an old decl for the same name.    If an old decl is returned, it may have been smashed    to agree with what X says.  */
end_comment

begin_function
name|tree
name|pushdecl
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_INVENTED
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|t
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|t
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
operator|)
argument_list|)
expr_stmt|;
comment|/* Don't push non-parms onto list for parms until we understand 	 why we're doing this and whether it works.  */
name|assert
argument_list|(
operator|(
name|b
operator|==
name|global_binding_level
operator|)
operator|||
operator|!
name|ffecom_transform_only_dummies_
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARM_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|!=
name|NULL_TREE
operator|)
operator|&&
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* If we are processing a typedef statement, generate a whole new 	 ..._TYPE node (which will be just an variant of the existing 	 ..._TYPE node with identical properties) and then install the 	 TYPE_DECL node generated to represent the typedef name as the 	 TYPE_NAME of this brand new (duplicate) ..._TYPE node.  	 The whole point here is to end up with a situation where each and every 	 ..._TYPE node the compiler creates will be uniquely associated with 	 AT MOST one node representing a typedef name. This way, even though 	 the compiler substitutes corresponding ..._TYPE nodes for TYPE_DECL 	 (i.e. "typedef name") nodes very early on, later parts of the 	 compiler can always do the reverse translation and get back the 	 corresponding typedef name.  For example, given:  	 typedef struct S MY_TYPE; MY_TYPE object;  	 Later parts of the compiler might only know that `object' was of type 	 `struct S' if it were not for code just below.  With this code 	 however, later parts of the compiler see something like:  	 struct S' == struct S typedef struct S' MY_TYPE; struct S' object;  	 And they can then deduce (from the node for type struct S') that the 	 original object declaration was:  	 MY_TYPE object;  	 Being able to do this is important for proper support of protoize, and 	 also for generating precise symbolic debugging information which 	 takes full account of the programmer's (typedef) vocabulary.  	 Obviously, we don't want to generate a duplicate ..._TYPE node if the 	 TYPE_DECL node that we are now processing really represents a 	 standard built-in type.  	 Since all standard types are effectively declared at line zero in the 	 source file, we can easily check to see if we are working on a 	 standard type by checking the current value of lineno.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|tree
name|tt
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tt
operator|=
name|build_type_copy
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|tt
argument_list|)
operator|=
name|x
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|tt
expr_stmt|;
block|}
block|}
comment|/* This name is new in its binding level. Install the new declaration 	 and return it.  */
if|if
condition|(
name|b
operator|==
name|global_binding_level
condition|)
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
else|else
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
comment|/* Put decls on list in reverse order. We will reverse them later if      necessary.  */
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|b
operator|->
name|names
expr_stmt|;
name|b
operator|->
name|names
operator|=
name|x
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if the current level needs to have a BLOCK made.  */
end_comment

begin_function
specifier|static
name|int
name|kept_level_p
parameter_list|()
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
operator|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
comment|/* Currently, there aren't supposed to be non-artificial names 	   at other than the top block for a function -- they're 	   believed to always be temps.  But it's wise to check anyway.  */
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Enter a new binding level.    If TAG_TRANSPARENT is nonzero, do so only for the name space of variables,    not for that of tags.  */
end_comment

begin_function
name|void
name|pushlevel
parameter_list|(
name|tag_transparent
parameter_list|)
name|int
name|tag_transparent
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|newlevel
init|=
name|NULL_BINDING_LEVEL
decl_stmt|;
name|assert
argument_list|(
operator|!
name|tag_transparent
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
name|named_labels
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Reuse or create a struct for this binding level.  */
if|if
condition|(
name|free_binding_level
condition|)
block|{
name|newlevel
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|free_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
else|else
block|{
name|newlevel
operator|=
name|make_binding_level
argument_list|()
expr_stmt|;
block|}
comment|/* Add this level to the front of the chain (stack) of levels that      are active.  */
operator|*
name|newlevel
operator|=
name|clear_binding_level
expr_stmt|;
name|newlevel
operator|->
name|level_chain
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|newlevel
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the BLOCK node for the innermost scope    (the one we are currently in).  */
end_comment

begin_function
name|void
name|set_block
parameter_list|(
name|block
parameter_list|)
specifier|register
name|tree
name|block
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|this_block
operator|=
name|block
expr_stmt|;
name|current_binding_level
operator|->
name|names
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|,
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|signed_or_unsigned_type
parameter_list|(
name|unsignedp
parameter_list|,
name|type
parameter_list|)
name|int
name|unsignedp
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type2
decl_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
name|type2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type2
operator|==
name|NULL_TREE
condition|)
return|return
name|type
return|;
return|return
name|type2
return|;
block|}
end_function

begin_function
name|tree
name|signed_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|tree
name|type2
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|unsigned_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|signed_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_type_node
condition|)
return|return
name|integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_unsigned_type_node
condition|)
return|return
name|short_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|long_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_unsigned_type_node
condition|)
return|return
name|long_long_integer_type_node
return|;
if|#
directive|if
literal|0
comment|/* gcc/c-* files only */
block|if (type1 == unsigned_intDI_type_node)     return intDI_type_node;   if (type1 == unsigned_intSI_type_node)     return intSI_type_node;   if (type1 == unsigned_intHI_type_node)     return intHI_type_node;   if (type1 == unsigned_intQI_type_node)     return intQI_type_node;
endif|#
directive|endif
name|type2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type2
operator|!=
name|NULL_TREE
condition|)
return|return
name|type2
return|;
for|for
control|(
name|kt
operator|=
literal|0
init|;
name|kt
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffecom_tree_type
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|kt
control|)
block|{
name|type2
operator|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeHOLLERITH
index|]
index|[
name|kt
index|]
expr_stmt|;
if|if
condition|(
name|type1
operator|==
name|type2
condition|)
return|return
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeINTEGER
index|]
index|[
name|kt
index|]
return|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Prepare expr to be an argument of a TRUTH_NOT_EXPR,    or validate its data type for an `if' or `while' statement or ?..: exp.     This preparation consists of taking the ordinary    representation of an expression expr and producing a valid tree    boolean expression describing whether expr is nonzero.  We could    simply always do build_binary_op (NE_EXPR, expr, integer_zero_node, 1),    but we optimize comparisons,&&, ||, and !.     The resulting type should always be `integer_type_node'.  */
end_comment

begin_function
name|tree
name|truthvalue_conversion
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|expr
return|;
if|#
directive|if
literal|0
comment|/* This appears to be wrong for C++.  */
comment|/* These really should return error_mark_node after 2.4 is stable.      But not all callers handle ERROR_MARK properly.  */
block|switch (TREE_CODE (TREE_TYPE (expr)))     {     case RECORD_TYPE:       error ("struct type value used where scalar is required");       return integer_zero_node;      case UNION_TYPE:       error ("union type value used where scalar is required");       return integer_zero_node;      case ARRAY_TYPE:       error ("array type value used where scalar is required");       return integer_zero_node;      default:       break;     }
endif|#
directive|endif
comment|/* 0 */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
comment|/* It is simpler and generates better code to have only TRUTH_*_EXPR 	 or comparison expressions as truth values at this level.  */
if|#
directive|if
literal|0
block|case COMPONENT_REF:
comment|/* A one-bit unsigned bit-field is already acceptable.  */
block|if (1 == TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (expr, 1)))&& TREE_UNSIGNED (TREE_OPERAND (expr, 1))) 	return expr;       break;
endif|#
directive|endif
case|case
name|EQ_EXPR
case|:
comment|/* It is simpler and generates better code to have only TRUTH_*_EXPR 	 or comparison expressions as truth values at this level.  */
if|#
directive|if
literal|0
block|if (integer_zerop (TREE_OPERAND (expr, 1))) 	return build_unary_op (TRUTH_NOT_EXPR, TREE_OPERAND (expr, 0), 0);
endif|#
directive|endif
case|case
name|NE_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
return|return
name|expr
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|expr
return|;
case|case
name|INTEGER_CST
case|:
return|return
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|?
name|integer_zero_node
else|:
name|integer_one_node
return|;
case|case
name|REAL_CST
case|:
return|return
name|real_zerop
argument_list|(
name|expr
argument_list|)
condition|?
name|integer_zero_node
else|:
name|integer_one_node
return|;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
return|;
else|else
return|return
name|integer_one_node
return|;
case|case
name|COMPLEX_EXPR
case|:
return|return
name|ffecom_2
argument_list|(
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
name|TRUTH_OR_EXPR
else|:
name|TRUTH_ORIF_EXPR
operator|)
argument_list|,
name|integer_type_node
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FFS_EXPR
case|:
comment|/* These don't change whether an object is non-zero or zero.  */
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
comment|/* These don't change whether an object is zero or non-zero, but 	 we can't ignore them if their second arg has side-effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* Distribute the conversion into the arms of a COND_EXPR.  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
comment|/* Don't cancel the effect of a CONVERT_EXPR from a REFERENCE_TYPE, 	 since that affects how `default_conversion' will behave.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
break|break;
comment|/* fall through... */
case|case
name|NOP_EXPR
case|:
comment|/* If this is widening the argument, we can ignore it.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* With IEEE arithmetic, x - x may not equal 0, so we can't optimize 	 this case.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
break|break;
comment|/* fall through... */
case|case
name|BIT_XOR_EXPR
case|:
comment|/* This and MINUS_EXPR can be changed into a comparison of the 	 two objects.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|ffecom_2
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|ffecom_2
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|BIT_AND_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|expr
return|;
break|break;
case|case
name|MODIFY_EXPR
case|:
if|#
directive|if
literal|0
comment|/* No such thing in Fortran. */
block|if (warn_parentheses&& C_EXP_ORIGINAL_CODE (expr) == MODIFY_EXPR) 	warning ("suggest parentheses around assignment used as truth value");
endif|#
directive|endif
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
operator|(
name|ffecom_2
argument_list|(
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|?
name|TRUTH_OR_EXPR
else|:
name|TRUTH_ORIF_EXPR
operator|)
argument_list|,
name|integer_type_node
argument_list|,
name|truthvalue_conversion
argument_list|(
name|ffecom_1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|ffecom_1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
return|return
name|ffecom_2
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|expr
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|type_for_mode
parameter_list|(
name|mode
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intTI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intTI_type_node
else|:
name|intTI_type_node
return|;
endif|#
directive|endif
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|float_type_node
argument_list|)
condition|)
return|return
name|float_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|double_type_node
argument_list|)
condition|)
return|return
name|double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
condition|)
return|return
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
condition|)
return|return
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffecom_tree_type
argument_list|)
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
operator|(
name|size_t
operator|)
name|j
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffecom_tree_type
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|t
operator|=
name|ffecom_tree_type
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
name|unsignedp
condition|)
return|return
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeHOLLERITH
index|]
index|[
name|j
index|]
return|;
else|else
return|return
name|t
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|tree
name|type_for_size
parameter_list|(
name|bits
parameter_list|,
name|unsignedp
parameter_list|)
name|unsigned
name|bits
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|tree
name|type_node
decl_stmt|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
for|for
control|(
name|kt
operator|=
literal|0
init|;
name|kt
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffecom_tree_type
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|kt
control|)
block|{
name|type_node
operator|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeINTEGER
index|]
index|[
name|kt
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|type_node
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|type_node
argument_list|)
operator|)
condition|)
return|return
name|unsignedp
condition|?
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeHOLLERITH
index|]
index|[
name|kt
index|]
else|:
name|type_node
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|tree
name|unsigned_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|tree
name|type2
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|signed_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|unsigned_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|integer_type_node
condition|)
return|return
name|unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_integer_type_node
condition|)
return|return
name|short_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_integer_type_node
condition|)
return|return
name|long_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_integer_type_node
condition|)
return|return
name|long_long_unsigned_type_node
return|;
if|#
directive|if
literal|0
comment|/* gcc/c-* files only */
block|if (type1 == intDI_type_node)     return unsigned_intDI_type_node;   if (type1 == intSI_type_node)     return unsigned_intSI_type_node;   if (type1 == intHI_type_node)     return unsigned_intHI_type_node;   if (type1 == intQI_type_node)     return unsigned_intQI_type_node;
endif|#
directive|endif
name|type2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type2
operator|!=
name|NULL_TREE
condition|)
return|return
name|type2
return|;
for|for
control|(
name|kt
operator|=
literal|0
init|;
name|kt
operator|<
name|ARRAY_SIZE
argument_list|(
name|ffecom_tree_type
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|kt
control|)
block|{
name|type2
operator|=
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeINTEGER
index|]
index|[
name|kt
index|]
expr_stmt|;
if|if
condition|(
name|type1
operator|==
name|type2
condition|)
return|return
name|ffecom_tree_type
index|[
name|FFEINFO_basictypeHOLLERITH
index|]
index|[
name|kt
index|]
return|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_function
name|void
name|lang_mark_tree
parameter_list|(
name|t
parameter_list|)
name|union
name|tree_node
modifier|*
name|t
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|struct
name|lang_identifier
modifier|*
name|i
init|=
operator|(
expr|struct
name|lang_identifier
operator|*
operator|)
name|t
decl_stmt|;
name|ggc_mark_tree
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
condition|)
name|ggc_mark
argument_list|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* From gcc/cccp.c, the code to handle -I.  */
end_comment

begin_comment
comment|/* Skip leading "./" from a directory name.    This may yield the empty string, which represents the current directory.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|skip_redundant_dir_prefix
parameter_list|(
specifier|const
name|char
modifier|*
name|dir
parameter_list|)
block|{
while|while
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dir
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
for|for
control|(
name|dir
operator|+=
literal|2
init|;
operator|*
name|dir
operator|==
literal|'/'
condition|;
name|dir
operator|++
control|)
continue|continue;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|!
name|dir
index|[
literal|1
index|]
condition|)
name|dir
operator|++
expr_stmt|;
return|return
name|dir
return|;
block|}
end_function

begin_comment
comment|/* The file_name_map structure holds a mapping of file names for a    particular directory.  This mapping is read from the file named    FILE_NAME_MAP_FILE in that directory.  Such a file can be used to    map filenames on a file system with severe filename restrictions,    such as DOS.  The format of the file name map file is just a series    of lines with two tokens on each line.  The first token is the name    to map, and the second token is the actual name to use.  */
end_comment

begin_struct
struct|struct
name|file_name_map
block|{
name|struct
name|file_name_map
modifier|*
name|map_next
decl_stmt|;
name|char
modifier|*
name|map_from
decl_stmt|;
name|char
modifier|*
name|map_to
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FILE_NAME_MAP_FILE
value|"header.gcc"
end_define

begin_comment
comment|/* Current maximum length of directory names in the search path    for include files.  (Altered as we get more of them.)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_include_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|file_name_list
block|{
name|struct
name|file_name_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* Mapping of file names for this directory.  */
name|struct
name|file_name_map
modifier|*
name|name_map
decl_stmt|;
comment|/* Non-zero if name_map is valid.  */
name|int
name|got_name_map
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|include
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First dir to search */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|last_include
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last in chain */
end_comment

begin_comment
comment|/* I/O buffer structure.    The `fname' field is nonzero for source files and #include files    and for the dummy text used for -D and -U.    It is zero for rescanning results of macro expansion    and for expanding macro arguments.  */
end_comment

begin_define
define|#
directive|define
name|INPUT_STACK_MAX
value|400
end_define

begin_struct
specifier|static
struct|struct
name|file_buf
block|{
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* Filename specified with #line command.  */
specifier|const
name|char
modifier|*
name|nominal_fname
decl_stmt|;
comment|/* Record where in the search path this file was found.      For #include_next.  */
name|struct
name|file_name_list
modifier|*
name|dir
decl_stmt|;
name|ffewhereLine
name|line
decl_stmt|;
name|ffewhereColumn
name|column
decl_stmt|;
block|}
name|instack
index|[
name|INPUT_STACK_MAX
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|last_error_tick
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incremented each time we print it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|input_file_stack_tick
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incremented when status changes.  */
end_comment

begin_comment
comment|/* Current nesting level of input sources.    `instack[indepth]' is the level currently being read.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|indepth
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|file_buf
name|FILE_BUF
typedef|;
end_typedef

begin_comment
comment|/* Nonzero means -I- has been seen,    so don't look for #include "foo" the source-file directory.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignore_srcdir
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|INCLUDE_LEN_FUDGE
end_ifndef

begin_define
define|#
directive|define
name|INCLUDE_LEN_FUDGE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|append_include_chain
parameter_list|(
name|struct
name|file_name_list
modifier|*
name|first
parameter_list|,
name|struct
name|file_name_list
modifier|*
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|open_include_file
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|file_name_list
modifier|*
name|searchptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_containing_files
parameter_list|(
name|ffebadSeverity
name|sev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|read_filename_string
parameter_list|(
name|int
name|ch
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|file_name_map
modifier|*
name|read_name_map
parameter_list|(
specifier|const
name|char
modifier|*
name|dirname
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Append a chain of `struct file_name_list's    to the end of the main include chain.    FIRST is the beginning of the chain to append, and LAST is the end.  */
end_comment

begin_function
specifier|static
name|void
name|append_include_chain
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|struct
name|file_name_list
modifier|*
name|first
decl_stmt|,
decl|*
name|last
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|file_name_list
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
operator|!
name|first
operator|||
operator|!
name|last
condition|)
return|return;
if|if
condition|(
name|include
operator|==
literal|0
condition|)
name|include
operator|=
name|first
expr_stmt|;
else|else
name|last_include
operator|->
name|next
operator|=
name|first
expr_stmt|;
for|for
control|(
name|dir
operator|=
name|first
init|;
condition|;
name|dir
operator|=
name|dir
operator|->
name|next
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|dir
operator|->
name|fname
argument_list|)
operator|+
name|INCLUDE_LEN_FUDGE
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|max_include_len
condition|)
name|max_include_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|last
condition|)
break|break;
block|}
name|last
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|last_include
operator|=
name|last
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Try to open include file FILENAME.  SEARCHPTR is the directory    being tried from the include file search path.  This function maps    filenames on file systems based on information read by    read_name_map.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|open_include_file
parameter_list|(
name|filename
parameter_list|,
name|searchptr
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|searchptr
decl_stmt|;
block|{
specifier|register
name|struct
name|file_name_map
modifier|*
name|map
decl_stmt|;
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
name|searchptr
operator|&&
operator|!
name|searchptr
operator|->
name|got_name_map
condition|)
block|{
name|searchptr
operator|->
name|name_map
operator|=
name|read_name_map
argument_list|(
name|searchptr
operator|->
name|fname
condition|?
name|searchptr
operator|->
name|fname
else|:
literal|"."
argument_list|)
expr_stmt|;
name|searchptr
operator|->
name|got_name_map
operator|=
literal|1
expr_stmt|;
block|}
comment|/* First check the mapping for the directory we are using.  */
if|if
condition|(
name|searchptr
operator|&&
name|searchptr
operator|->
name|name_map
condition|)
block|{
name|from
operator|=
name|filename
expr_stmt|;
if|if
condition|(
name|searchptr
operator|->
name|fname
condition|)
name|from
operator|+=
name|strlen
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|map
operator|=
name|searchptr
operator|->
name|name_map
init|;
name|map
condition|;
name|map
operator|=
name|map
operator|->
name|map_next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map
operator|->
name|map_from
argument_list|,
name|from
argument_list|)
condition|)
block|{
comment|/* Found a match.  */
return|return
name|fopen
argument_list|(
name|map
operator|->
name|map_to
argument_list|,
literal|"r"
argument_list|)
return|;
block|}
block|}
block|}
comment|/* Try to find a mapping file for the particular directory we are      looking in.  Thus #include<sys/types.h> will look up sys/types.h      in /usr/include/header.gcc and look up types.h in      /usr/include/sys/header.gcc.  */
name|p
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIR_SEPARATOR
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
name|DIR_SEPARATOR
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|tmp
init|=
name|strrchr
argument_list|(
name|filename
argument_list|,
name|DIR_SEPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
operator|&&
name|tmp
operator|>
name|p
condition|)
name|p
operator|=
name|tmp
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|filename
expr_stmt|;
if|if
condition|(
name|searchptr
operator|&&
name|searchptr
operator|->
name|fname
operator|&&
name|strlen
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|)
operator|==
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|filename
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|,
name|filename
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|filename
argument_list|)
argument_list|)
condition|)
block|{
comment|/* FILENAME is in SEARCHPTR, which we've already checked.  */
return|return
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
return|;
block|}
if|if
condition|(
name|p
operator|==
name|filename
condition|)
block|{
name|from
operator|=
name|filename
expr_stmt|;
name|map
operator|=
name|read_name_map
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|p
operator|-
name|filename
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dir
argument_list|,
name|filename
argument_list|,
name|p
operator|-
name|filename
argument_list|)
expr_stmt|;
name|dir
index|[
name|p
operator|-
name|filename
index|]
operator|=
literal|'\0'
expr_stmt|;
name|from
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|map
operator|=
name|read_name_map
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|map
condition|;
name|map
operator|=
name|map
operator|->
name|map_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map
operator|->
name|map_from
argument_list|,
name|from
argument_list|)
condition|)
return|return
name|fopen
argument_list|(
name|map
operator|->
name|map_to
argument_list|,
literal|"r"
argument_list|)
return|;
return|return
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print the file names and line numbers of the #include    commands which led to the current file.  */
end_comment

begin_function
specifier|static
name|void
name|print_containing_files
parameter_list|(
name|ffebadSeverity
name|sev
parameter_list|)
block|{
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|str1
decl_stmt|;
specifier|const
name|char
modifier|*
name|str2
decl_stmt|;
comment|/* If stack of files hasn't changed since we last printed      this info, don't repeat it.  */
if|if
condition|(
name|last_error_tick
operator|==
name|input_file_stack_tick
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
comment|/* Give up if we don't find a source file.  */
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return;
comment|/* Find the other, outer source files.  */
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|str1
operator|=
literal|"In file included"
expr_stmt|;
block|}
else|else
block|{
name|str1
operator|=
literal|"...          ..."
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|str2
operator|=
literal|":"
expr_stmt|;
else|else
name|str2
operator|=
literal|""
expr_stmt|;
name|ffebad_start_msg
argument_list|(
literal|"%A from %B at %0%C"
argument_list|,
name|sev
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ip
operator|->
name|line
argument_list|,
name|ip
operator|->
name|column
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|str1
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ip
operator|->
name|nominal_fname
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|str2
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
comment|/* Record we have printed the status as of this time.  */
name|last_error_tick
operator|=
name|input_file_stack_tick
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a space delimited string of unlimited length from a stdio    file.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_filename_string
parameter_list|(
name|ch
parameter_list|,
name|f
parameter_list|)
name|int
name|ch
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|char
modifier|*
name|alloc
decl_stmt|,
modifier|*
name|set
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
literal|20
expr_stmt|;
name|set
operator|=
name|alloc
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
name|ch
argument_list|)
condition|)
block|{
operator|*
name|set
operator|++
operator|=
name|ch
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|!
name|ISSPACE
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|set
operator|-
name|alloc
operator|==
name|len
condition|)
block|{
name|len
operator|*=
literal|2
expr_stmt|;
name|alloc
operator|=
name|xrealloc
argument_list|(
name|alloc
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|set
operator|=
name|alloc
operator|+
name|len
operator|/
literal|2
expr_stmt|;
block|}
operator|*
name|set
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
operator|*
name|set
operator|=
literal|'\0'
expr_stmt|;
name|ungetc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|alloc
return|;
block|}
end_function

begin_comment
comment|/* Read the file name map file for DIRNAME.  */
end_comment

begin_function
specifier|static
name|struct
name|file_name_map
modifier|*
name|read_name_map
parameter_list|(
name|dirname
parameter_list|)
specifier|const
name|char
modifier|*
name|dirname
decl_stmt|;
block|{
comment|/* This structure holds a linked list of file name maps, one per      directory.  */
struct|struct
name|file_name_map_list
block|{
name|struct
name|file_name_map_list
modifier|*
name|map_list_next
decl_stmt|;
name|char
modifier|*
name|map_list_name
decl_stmt|;
name|struct
name|file_name_map
modifier|*
name|map_list_map
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|file_name_map_list
modifier|*
name|map_list
decl_stmt|;
specifier|register
name|struct
name|file_name_map_list
modifier|*
name|map_list_ptr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|size_t
name|dirlen
decl_stmt|;
name|int
name|separator_needed
decl_stmt|;
name|dirname
operator|=
name|skip_redundant_dir_prefix
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
for|for
control|(
name|map_list_ptr
operator|=
name|map_list
init|;
name|map_list_ptr
condition|;
name|map_list_ptr
operator|=
name|map_list_ptr
operator|->
name|map_list_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map_list_ptr
operator|->
name|map_list_name
argument_list|,
name|dirname
argument_list|)
condition|)
return|return
name|map_list_ptr
operator|->
name|map_list_map
return|;
name|map_list_ptr
operator|=
operator|(
operator|(
expr|struct
name|file_name_map_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_map_list
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_name
operator|=
name|xstrdup
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_map
operator|=
name|NULL
expr_stmt|;
name|dirlen
operator|=
name|strlen
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|separator_needed
operator|=
name|dirlen
operator|!=
literal|0
operator|&&
name|dirname
index|[
name|dirlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dirlen
operator|+
name|strlen
argument_list|(
name|FILE_NAME_MAP_FILE
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|name
index|[
name|dirlen
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|name
operator|+
name|dirlen
operator|+
name|separator_needed
argument_list|,
name|FILE_NAME_MAP_FILE
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|map_list_ptr
operator|->
name|map_list_map
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|struct
name|file_name_map
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|ISSPACE
argument_list|(
name|ch
argument_list|)
condition|)
continue|continue;
name|from
operator|=
name|read_filename_string
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|ISSPACE
argument_list|(
name|ch
argument_list|)
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|to
operator|=
name|read_filename_string
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
operator|(
expr|struct
name|file_name_map
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_map
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ptr
operator|->
name|map_from
operator|=
name|from
expr_stmt|;
comment|/* Make the real filename absolute.  */
if|if
condition|(
operator|*
name|to
operator|==
literal|'/'
condition|)
name|ptr
operator|->
name|map_to
operator|=
name|to
expr_stmt|;
else|else
block|{
name|ptr
operator|->
name|map_to
operator|=
name|xmalloc
argument_list|(
name|dirlen
operator|+
name|strlen
argument_list|(
name|to
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ptr
operator|->
name|map_to
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|map_to
index|[
name|dirlen
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|ptr
operator|->
name|map_to
operator|+
name|dirlen
operator|+
name|separator_needed
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|->
name|map_next
operator|=
name|map_list_ptr
operator|->
name|map_list_map
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_map
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|map_list_ptr
operator|->
name|map_list_next
operator|=
name|map_list
expr_stmt|;
name|map_list
operator|=
name|map_list_ptr
expr_stmt|;
return|return
name|map_list_ptr
operator|->
name|map_list_map
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffecom_file_
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
comment|/* Do partial setup of input buffer for the sake of generating      early #line directives (when -g is in effect).  */
name|fp
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|FILE_BUF
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|""
expr_stmt|;
name|fp
operator|->
name|nominal_fname
operator|=
name|fp
operator|->
name|fname
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffecom_close_include_
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|indepth
operator|--
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
name|ffewhere_line_kill
argument_list|(
name|instack
index|[
name|indepth
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|instack
index|[
name|indepth
index|]
operator|.
name|column
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ffecom_decode_include_option_
parameter_list|(
name|char
modifier|*
name|spec
parameter_list|)
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
if|if
condition|(
operator|!
name|ignore_srcdir
operator|&&
operator|!
name|strcmp
argument_list|(
name|spec
argument_list|,
literal|"-"
argument_list|)
condition|)
name|ignore_srcdir
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
name|dirtmp
operator|->
name|fname
operator|=
name|spec
expr_stmt|;
name|dirtmp
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spec
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"directory name must immediately follow -I"
argument_list|)
expr_stmt|;
else|else
name|append_include_chain
argument_list|(
name|dirtmp
argument_list|,
name|dirtmp
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Open INCLUDEd file.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|ffecom_open_include_
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|ffewhereLine
name|l
parameter_list|,
name|ffewhereColumn
name|c
parameter_list|)
block|{
name|char
modifier|*
name|fbeg
init|=
name|name
decl_stmt|;
name|size_t
name|flen
init|=
name|strlen
argument_list|(
name|fbeg
argument_list|)
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|search_start
init|=
name|include
decl_stmt|;
comment|/* Chain of dirs to search */
name|struct
name|file_name_list
name|dsp
index|[
literal|1
index|]
decl_stmt|;
comment|/* First in chain, if #include "..." */
name|struct
name|file_name_list
modifier|*
name|searchptr
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* Dynamically allocated fname buffer */
name|FILE
modifier|*
name|f
decl_stmt|;
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|flen
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
operator|=
name|NULL
expr_stmt|;
comment|/* If -I- was specified, don't search current dir, only spec'd ones. */
if|if
condition|(
operator|!
name|ignore_srcdir
condition|)
block|{
for|for
control|(
name|fp
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
init|;
name|fp
operator|>=
name|instack
condition|;
name|fp
operator|--
control|)
block|{
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
specifier|const
name|char
modifier|*
name|nam
decl_stmt|;
if|if
condition|(
operator|(
name|nam
operator|=
name|fp
operator|->
name|nominal_fname
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Found a named file.  Figure out dir of the file, 		 and put it in front of the search list.  */
name|dsp
index|[
literal|0
index|]
operator|.
name|next
operator|=
name|search_start
expr_stmt|;
name|search_start
operator|=
name|dsp
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
name|ep
operator|=
name|strrchr
argument_list|(
name|nam
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIR_SEPARATOR
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|ep
operator|=
name|strrchr
argument_list|(
name|nam
argument_list|,
name|DIR_SEPARATOR
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|tmp
init|=
name|strrchr
argument_list|(
name|nam
argument_list|,
name|DIR_SEPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
operator|&&
name|tmp
operator|>
name|ep
condition|)
name|ep
operator|=
name|tmp
expr_stmt|;
block|}
endif|#
directive|endif
else|#
directive|else
comment|/* VMS */
name|ep
operator|=
name|strrchr
argument_list|(
name|nam
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|ep
operator|=
name|strrchr
argument_list|(
name|nam
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|ep
operator|=
name|strrchr
argument_list|(
name|nam
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
name|ep
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|ep
operator|-
name|nam
expr_stmt|;
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
argument_list|,
name|nam
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|n
operator|+
name|INCLUDE_LEN_FUDGE
operator|>
name|max_include_len
condition|)
name|max_include_len
operator|=
name|n
operator|+
name|INCLUDE_LEN_FUDGE
expr_stmt|;
block|}
else|else
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
operator|=
name|NULL
expr_stmt|;
comment|/* Current directory */
name|dsp
index|[
literal|0
index|]
operator|.
name|got_name_map
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Allocate this permanently, because it gets stored in the definitions      of macros.  */
name|fname
operator|=
name|xmalloc
argument_list|(
name|max_include_len
operator|+
name|flen
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* + 2 above for slash and terminating null.  */
comment|/* + 2 added for '.h' on VMS (to support '#include filename') (NOT USED      for g77 yet).  */
comment|/* If specified file name is absolute, just open it.  */
if|if
condition|(
operator|*
name|fbeg
operator|==
literal|'/'
ifdef|#
directive|ifdef
name|DIR_SEPARATOR
operator|||
operator|*
name|fbeg
operator|==
name|DIR_SEPARATOR
endif|#
directive|endif
condition|)
block|{
name|strncpy
argument_list|(
name|fname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fname
index|[
name|flen
index|]
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|open_include_file
argument_list|(
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|NULL
expr_stmt|;
comment|/* Search directory path, trying to open the file. 	 Copy each filename tried into FNAME.  */
for|for
control|(
name|searchptr
operator|=
name|search_start
init|;
name|searchptr
condition|;
name|searchptr
operator|=
name|searchptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|searchptr
operator|->
name|fname
condition|)
block|{
comment|/* The empty string in a search path is ignored. 		 This makes it possible to turn off entirely 		 a standard piece of the list.  */
if|if
condition|(
name|searchptr
operator|->
name|fname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
continue|continue;
name|strcpy
argument_list|(
name|fname
argument_list|,
name|skip_redundant_dir_prefix
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|&&
name|fname
index|[
name|strlen
argument_list|(
name|fname
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|fname
index|[
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
name|flen
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strncat
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* Change this 1/2 Unix 1/2 VMS file specification into a 	     full VMS file specification */
if|if
condition|(
name|searchptr
operator|->
name|fname
operator|&&
operator|(
name|searchptr
operator|->
name|fname
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Fix up the filename */
name|hack_vms_include_specification
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a normal VMS filespec, so use it unchanged.  */
name|strncpy
argument_list|(
name|fname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fname
index|[
name|flen
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Not for g77.  */
comment|/* if it's '#include filename', add the missing .h */
block|if (strchr (fname, '.') == NULL) 		strcat (fname, ".h");
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* VMS */
name|f
operator|=
name|open_include_file
argument_list|(
name|fname
argument_list|,
name|searchptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EACCES
if|if
condition|(
name|f
operator|==
name|NULL
operator|&&
name|errno
operator|==
name|EACCES
condition|)
block|{
name|print_containing_files
argument_list|(
name|FFEBAD_severityWARNING
argument_list|)
expr_stmt|;
name|ffebad_start_msg
argument_list|(
literal|"At %0, INCLUDE file %A exists, but is not readable"
argument_list|,
name|FFEBAD_severityWARNING
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|l
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* A file that was not found.  */
name|strncpy
argument_list|(
name|fname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fname
index|[
name|flen
index|]
operator|=
literal|0
expr_stmt|;
name|print_containing_files
argument_list|(
name|ffebad_severity
argument_list|(
name|FFEBAD_OPEN_INCLUDE
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_OPEN_INCLUDE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|l
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|indepth
operator|>=
operator|(
name|INPUT_STACK_MAX
operator|-
literal|1
operator|)
condition|)
block|{
name|print_containing_files
argument_list|(
name|FFEBAD_severityFATAL
argument_list|)
expr_stmt|;
name|ffebad_start_msg
argument_list|(
literal|"At %0, INCLUDE nesting too deep"
argument_list|,
name|FFEBAD_severityFATAL
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|l
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|instack
index|[
name|indepth
index|]
operator|.
name|line
operator|=
name|ffewhere_line_use
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|instack
index|[
name|indepth
index|]
operator|.
name|column
operator|=
name|ffewhere_column_use
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|&
name|instack
index|[
name|indepth
operator|+
literal|1
index|]
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|FILE_BUF
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|nominal_fname
operator|=
name|fp
operator|->
name|fname
operator|=
name|fname
expr_stmt|;
name|fp
operator|->
name|dir
operator|=
name|searchptr
expr_stmt|;
name|indepth
operator|++
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/**INDENT* (Do not reformat this comment even with -fca option.)    Data-gathering files: Given the source file listed below, compiled with    f2c I obtained the output file listed after that, and from the output    file I derived the above code.  -------- (begin input file to f2c) 	implicit none 	character*10 A1,A2 	complex C1,C2 	integer I1,I2 	real R1,R2 	double precision D1,D2 C 	call getem(A1,A2,C1,C2,I1,I2,R1,R2,D1,D2) c / 	call fooI(I1/I2) 	call fooR(R1/I1) 	call fooD(D1/I1) 	call fooC(C1/I1) 	call fooR(R1/R2) 	call fooD(R1/D1) 	call fooD(D1/D2) 	call fooD(D1/R1) 	call fooC(C1/C2) 	call fooC(C1/R1) 	call fooZ(C1/D1) c ** 	call fooI(I1**I2) 	call fooR(R1**I1) 	call fooD(D1**I1) 	call fooC(C1**I1) 	call fooR(R1**R2) 	call fooD(R1**D1) 	call fooD(D1**D2) 	call fooD(D1**R1) 	call fooC(C1**C2) 	call fooC(C1**R1) 	call fooZ(C1**D1) c FFEINTRIN_impABS 	call fooR(ABS(R1)) c FFEINTRIN_impACOS 	call fooR(ACOS(R1)) c FFEINTRIN_impAIMAG 	call fooR(AIMAG(C1)) c FFEINTRIN_impAINT 	call fooR(AINT(R1)) c FFEINTRIN_impALOG 	call fooR(ALOG(R1)) c FFEINTRIN_impALOG10 	call fooR(ALOG10(R1)) c FFEINTRIN_impAMAX0 	call fooR(AMAX0(I1,I2)) c FFEINTRIN_impAMAX1 	call fooR(AMAX1(R1,R2)) c FFEINTRIN_impAMIN0 	call fooR(AMIN0(I1,I2)) c FFEINTRIN_impAMIN1 	call fooR(AMIN1(R1,R2)) c FFEINTRIN_impAMOD 	call fooR(AMOD(R1,R2)) c FFEINTRIN_impANINT 	call fooR(ANINT(R1)) c FFEINTRIN_impASIN 	call fooR(ASIN(R1)) c FFEINTRIN_impATAN 	call fooR(ATAN(R1)) c FFEINTRIN_impATAN2 	call fooR(ATAN2(R1,R2)) c FFEINTRIN_impCABS 	call fooR(CABS(C1)) c FFEINTRIN_impCCOS 	call fooC(CCOS(C1)) c FFEINTRIN_impCEXP 	call fooC(CEXP(C1)) c FFEINTRIN_impCHAR 	call fooA(CHAR(I1)) c FFEINTRIN_impCLOG 	call fooC(CLOG(C1)) c FFEINTRIN_impCONJG 	call fooC(CONJG(C1)) c FFEINTRIN_impCOS 	call fooR(COS(R1)) c FFEINTRIN_impCOSH 	call fooR(COSH(R1)) c FFEINTRIN_impCSIN 	call fooC(CSIN(C1)) c FFEINTRIN_impCSQRT 	call fooC(CSQRT(C1)) c FFEINTRIN_impDABS 	call fooD(DABS(D1)) c FFEINTRIN_impDACOS 	call fooD(DACOS(D1)) c FFEINTRIN_impDASIN 	call fooD(DASIN(D1)) c FFEINTRIN_impDATAN 	call fooD(DATAN(D1)) c FFEINTRIN_impDATAN2 	call fooD(DATAN2(D1,D2)) c FFEINTRIN_impDCOS 	call fooD(DCOS(D1)) c FFEINTRIN_impDCOSH 	call fooD(DCOSH(D1)) c FFEINTRIN_impDDIM 	call fooD(DDIM(D1,D2)) c FFEINTRIN_impDEXP 	call fooD(DEXP(D1)) c FFEINTRIN_impDIM 	call fooR(DIM(R1,R2)) c FFEINTRIN_impDINT 	call fooD(DINT(D1)) c FFEINTRIN_impDLOG 	call fooD(DLOG(D1)) c FFEINTRIN_impDLOG10 	call fooD(DLOG10(D1)) c FFEINTRIN_impDMAX1 	call fooD(DMAX1(D1,D2)) c FFEINTRIN_impDMIN1 	call fooD(DMIN1(D1,D2)) c FFEINTRIN_impDMOD 	call fooD(DMOD(D1,D2)) c FFEINTRIN_impDNINT 	call fooD(DNINT(D1)) c FFEINTRIN_impDPROD 	call fooD(DPROD(R1,R2)) c FFEINTRIN_impDSIGN 	call fooD(DSIGN(D1,D2)) c FFEINTRIN_impDSIN 	call fooD(DSIN(D1)) c FFEINTRIN_impDSINH 	call fooD(DSINH(D1)) c FFEINTRIN_impDSQRT 	call fooD(DSQRT(D1)) c FFEINTRIN_impDTAN 	call fooD(DTAN(D1)) c FFEINTRIN_impDTANH 	call fooD(DTANH(D1)) c FFEINTRIN_impEXP 	call fooR(EXP(R1)) c FFEINTRIN_impIABS 	call fooI(IABS(I1)) c FFEINTRIN_impICHAR 	call fooI(ICHAR(A1)) c FFEINTRIN_impIDIM 	call fooI(IDIM(I1,I2)) c FFEINTRIN_impIDNINT 	call fooI(IDNINT(D1)) c FFEINTRIN_impINDEX 	call fooI(INDEX(A1,A2)) c FFEINTRIN_impISIGN 	call fooI(ISIGN(I1,I2)) c FFEINTRIN_impLEN 	call fooI(LEN(A1)) c FFEINTRIN_impLGE 	call fooL(LGE(A1,A2)) c FFEINTRIN_impLGT 	call fooL(LGT(A1,A2)) c FFEINTRIN_impLLE 	call fooL(LLE(A1,A2)) c FFEINTRIN_impLLT 	call fooL(LLT(A1,A2)) c FFEINTRIN_impMAX0 	call fooI(MAX0(I1,I2)) c FFEINTRIN_impMAX1 	call fooI(MAX1(R1,R2)) c FFEINTRIN_impMIN0 	call fooI(MIN0(I1,I2)) c FFEINTRIN_impMIN1 	call fooI(MIN1(R1,R2)) c FFEINTRIN_impMOD 	call fooI(MOD(I1,I2)) c FFEINTRIN_impNINT 	call fooI(NINT(R1)) c FFEINTRIN_impSIGN 	call fooR(SIGN(R1,R2)) c FFEINTRIN_impSIN 	call fooR(SIN(R1)) c FFEINTRIN_impSINH 	call fooR(SINH(R1)) c FFEINTRIN_impSQRT 	call fooR(SQRT(R1)) c FFEINTRIN_impTAN 	call fooR(TAN(R1)) c FFEINTRIN_impTANH 	call fooR(TANH(R1)) c FFEINTRIN_imp_CMPLX_C 	call fooC(cmplx(C1,C2)) c FFEINTRIN_imp_CMPLX_D 	call fooZ(cmplx(D1,D2)) c FFEINTRIN_imp_CMPLX_I 	call fooC(cmplx(I1,I2)) c FFEINTRIN_imp_CMPLX_R 	call fooC(cmplx(R1,R2)) c FFEINTRIN_imp_DBLE_C 	call fooD(dble(C1)) c FFEINTRIN_imp_DBLE_D 	call fooD(dble(D1)) c FFEINTRIN_imp_DBLE_I 	call fooD(dble(I1)) c FFEINTRIN_imp_DBLE_R 	call fooD(dble(R1)) c FFEINTRIN_imp_INT_C 	call fooI(int(C1)) c FFEINTRIN_imp_INT_D 	call fooI(int(D1)) c FFEINTRIN_imp_INT_I 	call fooI(int(I1)) c FFEINTRIN_imp_INT_R 	call fooI(int(R1)) c FFEINTRIN_imp_REAL_C 	call fooR(real(C1)) c FFEINTRIN_imp_REAL_D 	call fooR(real(D1)) c FFEINTRIN_imp_REAL_I 	call fooR(real(I1)) c FFEINTRIN_imp_REAL_R 	call fooR(real(R1)) c c FFEINTRIN_imp_INT_D: c c FFEINTRIN_specIDINT 	call fooI(IDINT(D1)) c c FFEINTRIN_imp_INT_R: c c FFEINTRIN_specIFIX 	call fooI(IFIX(R1)) c FFEINTRIN_specINT 	call fooI(INT(R1)) c c FFEINTRIN_imp_REAL_D: c c FFEINTRIN_specSNGL 	call fooR(SNGL(D1)) c c FFEINTRIN_imp_REAL_I: c c FFEINTRIN_specFLOAT 	call fooR(FLOAT(I1)) c FFEINTRIN_specREAL 	call fooR(REAL(I1)) c 	end -------- (end input file to f2c)  -------- (begin output from providing above input file as input to: --------  `f2c | gcc -E -C - | sed -e "s:/[*]*://:g" -e "s:[*]*[/]://:g" \ --------     -e "s:^#.*$::g"')  //  -- translated by f2c (version 19950223).    You must link the resulting object file with the libraries:         -lf2c -lm   (in that order) //   // f2c.h  --  Standard Fortran to C header file //  ///  barf  [ba:rf]  2.  "He suggested using FORTRAN, and everybody barfed."          - From The Shogakukan DICTIONARY OF NEW ENGLISH (Second edition) //     // F2C_INTEGER will normally be `int' but would be `long' on 16-bit systems // // we assume short, float are OK // typedef long int // long int // integer; typedef char *address; typedef short int shortint; typedef float real; typedef double doublereal; typedef struct { real r, i; } complex; typedef struct { doublereal r, i; } doublecomplex; typedef long int // long int // logical; typedef short int shortlogical; typedef char logical1; typedef char integer1; // typedef long long longint; // // system-dependent //     // Extern is for use with -E //     // I/O stuff //         typedef long int // int or long int // flag; typedef long int // int or long int // ftnlen; typedef long int // int or long int // ftnint;   //external read, write// typedef struct {       flag cierr;         ftnint ciunit;         flag ciend;         char *cifmt;         ftnint cirec; } cilist;  //internal read, write// typedef struct {       flag icierr;         char *iciunit;         flag iciend;         char *icifmt;         ftnint icirlen;         ftnint icirnum; } icilist;  //open// typedef struct {       flag oerr;         ftnint ounit;         char *ofnm;         ftnlen ofnmlen;         char *osta;         char *oacc;         char *ofm;         ftnint orl;         char *oblnk; } olist;  //close// typedef struct {       flag cerr;         ftnint cunit;         char *csta; } cllist;  //rewind, backspace, endfile// typedef struct {       flag aerr;         ftnint aunit; } alist;  // inquire // typedef struct {       flag inerr;         ftnint inunit;         char *infile;         ftnlen infilen;         ftnint  *inex;  //parameters in standard's order//         ftnint  *inopen;         ftnint  *innum;         ftnint  *innamed;         char    *inname;         ftnlen  innamlen;         char    *inacc;         ftnlen  inacclen;         char    *inseq;         ftnlen  inseqlen;         char    *indir;         ftnlen  indirlen;         char    *infmt;         ftnlen  infmtlen;         char    *inform;         ftnint  informlen;         char    *inunf;         ftnlen  inunflen;         ftnint  *inrecl;         ftnint  *innrec;         char    *inblank;         ftnlen  inblanklen; } inlist;    union Multitype {       // for multiple entry points //         integer1 g;         shortint h;         integer i;         // longint j; //         real r;         doublereal d;         complex c;         doublecomplex z;         };  typedef union Multitype Multitype;  typedef long Long;      // No longer used; formerly in Namelist //  struct Vardesc {        // for Namelist //         char *name;         char *addr;         ftnlen *dims;         int  type;         }; typedef struct Vardesc Vardesc;  struct Namelist {         char *name;         Vardesc **vars;         int nvars;         }; typedef struct Namelist Namelist;         // procedure parameter types for -A and -C++ //     typedef int // Unknown procedure type // (*U_fp)(); typedef shortint (*J_fp)(); typedef integer (*I_fp)(); typedef real (*R_fp)(); typedef doublereal (*D_fp)(), (*E_fp)(); typedef // Complex // void  (*C_fp)(); typedef // Double Complex // void  (*Z_fp)(); typedef logical (*L_fp)(); typedef shortlogical (*K_fp)(); typedef // Character // void  (*H_fp)(); typedef // Subroutine // int (*S_fp)();  // E_fp is for real functions when -R is not specified // typedef void  C_f;      // complex function // typedef void  H_f;      // character function // typedef void  Z_f;      // double complex function // typedef doublereal E_f; // real function with -R not specified //  // undef any lower-case symbols that your C compiler predefines, e.g.: //   // (No such symbols should be defined in a strict ANSI C compiler.    We can avoid trouble with f2c-translated code by using    gcc -ansi [-traditional].) //                        // Main program // MAIN__() {     // System generated locals //     integer i__1;     real r__1, r__2;     doublereal d__1, d__2;     complex q__1;     doublecomplex z__1, z__2, z__3;     logical L__1;     char ch__1[1];      // Builtin functions //     void c_div();     integer pow_ii();     double pow_ri(), pow_di();     void pow_ci();     double pow_dd();     void pow_zz();     double acos(), r_imag(), r_int(), log(), r_lg10(), r_mod(), r_nint(),             asin(), atan(), atan2(), c_abs();     void c_cos(), c_exp(), c_log(), r_cnjg();     double cos(), cosh();     void c_sin(), c_sqrt();     double d_dim(), exp(), r_dim(), d_int(), d_lg10(), d_mod(), d_nint(),             d_sign(), sin(), sinh(), sqrt(), tan(), tanh();     integer i_dim(), i_dnnt(), i_indx(), i_sign(), i_len();     logical l_ge(), l_gt(), l_le(), l_lt();     integer i_nint();     double r_sign();      // Local variables //     extern // Subroutine // int fooa_(), fooc_(), food_(), fooi_(), foor_(),             fool_(), fooz_(), getem_();     static char a1[10], a2[10];     static complex c1, c2;     static doublereal d1, d2;     static integer i1, i2;     static real r1, r2;       getem_(a1, a2,&c1,&c2,&i1,&i2,&r1,&r2,&d1,&d2, 10L, 10L); // / //     i__1 = i1 / i2;     fooi_(&i__1);     r__1 = r1 / i1;     foor_(&r__1);     d__1 = d1 / i1;     food_(&d__1);     d__1 = (doublereal) i1;     q__1.r = c1.r / d__1, q__1.i = c1.i / d__1;     fooc_(&q__1);     r__1 = r1 / r2;     foor_(&r__1);     d__1 = r1 / d1;     food_(&d__1);     d__1 = d1 / d2;     food_(&d__1);     d__1 = d1 / r1;     food_(&d__1);     c_div(&q__1,&c1,&c2);     fooc_(&q__1);     q__1.r = c1.r / r1, q__1.i = c1.i / r1;     fooc_(&q__1);     z__1.r = c1.r / d1, z__1.i = c1.i / d1;     fooz_(&z__1); // ** //     i__1 = pow_ii(&i1,&i2);     fooi_(&i__1);     r__1 = pow_ri(&r1,&i1);     foor_(&r__1);     d__1 = pow_di(&d1,&i1);     food_(&d__1);     pow_ci(&q__1,&c1,&i1);     fooc_(&q__1);     d__1 = (doublereal) r1;     d__2 = (doublereal) r2;     r__1 = pow_dd(&d__1,&d__2);     foor_(&r__1);     d__2 = (doublereal) r1;     d__1 = pow_dd(&d__2,&d1);     food_(&d__1);     d__1 = pow_dd(&d1,&d2);     food_(&d__1);     d__2 = (doublereal) r1;     d__1 = pow_dd(&d1,&d__2);     food_(&d__1);     z__2.r = c1.r, z__2.i = c1.i;     z__3.r = c2.r, z__3.i = c2.i;     pow_zz(&z__1,&z__2,&z__3);     q__1.r = z__1.r, q__1.i = z__1.i;     fooc_(&q__1);     z__2.r = c1.r, z__2.i = c1.i;     z__3.r = r1, z__3.i = 0.;     pow_zz(&z__1,&z__2,&z__3);     q__1.r = z__1.r, q__1.i = z__1.i;     fooc_(&q__1);     z__2.r = c1.r, z__2.i = c1.i;     z__3.r = d1, z__3.i = 0.;     pow_zz(&z__1,&z__2,&z__3);     fooz_(&z__1); // FFEINTRIN_impABS //     r__1 = (doublereal)((  r1  )>= 0 ? (  r1  ) : -(  r1  ))  ;     foor_(&r__1); // FFEINTRIN_impACOS //     r__1 = acos(r1);     foor_(&r__1); // FFEINTRIN_impAIMAG //     r__1 = r_imag(&c1);     foor_(&r__1); // FFEINTRIN_impAINT //     r__1 = r_int(&r1);     foor_(&r__1); // FFEINTRIN_impALOG //     r__1 = log(r1);     foor_(&r__1); // FFEINTRIN_impALOG10 //     r__1 = r_lg10(&r1);     foor_(&r__1); // FFEINTRIN_impAMAX0 //     r__1 = (real) (( i1 )>= ( i2 ) ? ( i1 ) : ( i2 )) ;     foor_(&r__1); // FFEINTRIN_impAMAX1 //     r__1 = (doublereal)((  r1  )>= (  r2  ) ? (  r1  ) : (  r2  ))  ;     foor_(&r__1); // FFEINTRIN_impAMIN0 //     r__1 = (real) (( i1 )<= ( i2 ) ? ( i1 ) : ( i2 )) ;     foor_(&r__1); // FFEINTRIN_impAMIN1 //     r__1 = (doublereal)((  r1  )<= (  r2  ) ? (  r1  ) : (  r2  ))  ;     foor_(&r__1); // FFEINTRIN_impAMOD //     r__1 = r_mod(&r1,&r2);     foor_(&r__1); // FFEINTRIN_impANINT //     r__1 = r_nint(&r1);     foor_(&r__1); // FFEINTRIN_impASIN //     r__1 = asin(r1);     foor_(&r__1); // FFEINTRIN_impATAN //     r__1 = atan(r1);     foor_(&r__1); // FFEINTRIN_impATAN2 //     r__1 = atan2(r1, r2);     foor_(&r__1); // FFEINTRIN_impCABS //     r__1 = c_abs(&c1);     foor_(&r__1); // FFEINTRIN_impCCOS //     c_cos(&q__1,&c1);     fooc_(&q__1); // FFEINTRIN_impCEXP //     c_exp(&q__1,&c1);     fooc_(&q__1); // FFEINTRIN_impCHAR //     *(unsigned char *)&ch__1[0] = i1;     fooa_(ch__1, 1L); // FFEINTRIN_impCLOG //     c_log(&q__1,&c1);     fooc_(&q__1); // FFEINTRIN_impCONJG //     r_cnjg(&q__1,&c1);     fooc_(&q__1); // FFEINTRIN_impCOS //     r__1 = cos(r1);     foor_(&r__1); // FFEINTRIN_impCOSH //     r__1 = cosh(r1);     foor_(&r__1); // FFEINTRIN_impCSIN //     c_sin(&q__1,&c1);     fooc_(&q__1); // FFEINTRIN_impCSQRT //     c_sqrt(&q__1,&c1);     fooc_(&q__1); // FFEINTRIN_impDABS //     d__1 = (( d1 )>= 0 ? ( d1 ) : -( d1 )) ;     food_(&d__1); // FFEINTRIN_impDACOS //     d__1 = acos(d1);     food_(&d__1); // FFEINTRIN_impDASIN //     d__1 = asin(d1);     food_(&d__1); // FFEINTRIN_impDATAN //     d__1 = atan(d1);     food_(&d__1); // FFEINTRIN_impDATAN2 //     d__1 = atan2(d1, d2);     food_(&d__1); // FFEINTRIN_impDCOS //     d__1 = cos(d1);     food_(&d__1); // FFEINTRIN_impDCOSH //     d__1 = cosh(d1);     food_(&d__1); // FFEINTRIN_impDDIM //     d__1 = d_dim(&d1,&d2);     food_(&d__1); // FFEINTRIN_impDEXP //     d__1 = exp(d1);     food_(&d__1); // FFEINTRIN_impDIM //     r__1 = r_dim(&r1,&r2);     foor_(&r__1); // FFEINTRIN_impDINT //     d__1 = d_int(&d1);     food_(&d__1); // FFEINTRIN_impDLOG //     d__1 = log(d1);     food_(&d__1); // FFEINTRIN_impDLOG10 //     d__1 = d_lg10(&d1);     food_(&d__1); // FFEINTRIN_impDMAX1 //     d__1 = (( d1 )>= ( d2 ) ? ( d1 ) : ( d2 )) ;     food_(&d__1); // FFEINTRIN_impDMIN1 //     d__1 = (( d1 )<= ( d2 ) ? ( d1 ) : ( d2 )) ;     food_(&d__1); // FFEINTRIN_impDMOD //     d__1 = d_mod(&d1,&d2);     food_(&d__1); // FFEINTRIN_impDNINT //     d__1 = d_nint(&d1);     food_(&d__1); // FFEINTRIN_impDPROD //     d__1 = (doublereal) r1 * r2;     food_(&d__1); // FFEINTRIN_impDSIGN //     d__1 = d_sign(&d1,&d2);     food_(&d__1); // FFEINTRIN_impDSIN //     d__1 = sin(d1);     food_(&d__1); // FFEINTRIN_impDSINH //     d__1 = sinh(d1);     food_(&d__1); // FFEINTRIN_impDSQRT //     d__1 = sqrt(d1);     food_(&d__1); // FFEINTRIN_impDTAN //     d__1 = tan(d1);     food_(&d__1); // FFEINTRIN_impDTANH //     d__1 = tanh(d1);     food_(&d__1); // FFEINTRIN_impEXP //     r__1 = exp(r1);     foor_(&r__1); // FFEINTRIN_impIABS //     i__1 = (( i1 )>= 0 ? ( i1 ) : -( i1 )) ;     fooi_(&i__1); // FFEINTRIN_impICHAR //     i__1 = *(unsigned char *)a1;     fooi_(&i__1); // FFEINTRIN_impIDIM //     i__1 = i_dim(&i1,&i2);     fooi_(&i__1); // FFEINTRIN_impIDNINT //     i__1 = i_dnnt(&d1);     fooi_(&i__1); // FFEINTRIN_impINDEX //     i__1 = i_indx(a1, a2, 10L, 10L);     fooi_(&i__1); // FFEINTRIN_impISIGN //     i__1 = i_sign(&i1,&i2);     fooi_(&i__1); // FFEINTRIN_impLEN //     i__1 = i_len(a1, 10L);     fooi_(&i__1); // FFEINTRIN_impLGE //     L__1 = l_ge(a1, a2, 10L, 10L);     fool_(&L__1); // FFEINTRIN_impLGT //     L__1 = l_gt(a1, a2, 10L, 10L);     fool_(&L__1); // FFEINTRIN_impLLE //     L__1 = l_le(a1, a2, 10L, 10L);     fool_(&L__1); // FFEINTRIN_impLLT //     L__1 = l_lt(a1, a2, 10L, 10L);     fool_(&L__1); // FFEINTRIN_impMAX0 //     i__1 = (( i1 )>= ( i2 ) ? ( i1 ) : ( i2 )) ;     fooi_(&i__1); // FFEINTRIN_impMAX1 //     i__1 = (integer) (doublereal)((  r1  )>= (  r2  ) ? (  r1  ) : (  r2  ))  ;     fooi_(&i__1); // FFEINTRIN_impMIN0 //     i__1 = (( i1 )<= ( i2 ) ? ( i1 ) : ( i2 )) ;     fooi_(&i__1); // FFEINTRIN_impMIN1 //     i__1 = (integer) (doublereal)((  r1  )<= (  r2  ) ? (  r1  ) : (  r2  ))  ;     fooi_(&i__1); // FFEINTRIN_impMOD //     i__1 = i1 % i2;     fooi_(&i__1); // FFEINTRIN_impNINT //     i__1 = i_nint(&r1);     fooi_(&i__1); // FFEINTRIN_impSIGN //     r__1 = r_sign(&r1,&r2);     foor_(&r__1); // FFEINTRIN_impSIN //     r__1 = sin(r1);     foor_(&r__1); // FFEINTRIN_impSINH //     r__1 = sinh(r1);     foor_(&r__1); // FFEINTRIN_impSQRT //     r__1 = sqrt(r1);     foor_(&r__1); // FFEINTRIN_impTAN //     r__1 = tan(r1);     foor_(&r__1); // FFEINTRIN_impTANH //     r__1 = tanh(r1);     foor_(&r__1); // FFEINTRIN_imp_CMPLX_C //     r__1 = c1.r;     r__2 = c2.r;     q__1.r = r__1, q__1.i = r__2;     fooc_(&q__1); // FFEINTRIN_imp_CMPLX_D //     z__1.r = d1, z__1.i = d2;     fooz_(&z__1); // FFEINTRIN_imp_CMPLX_I //     r__1 = (real) i1;     r__2 = (real) i2;     q__1.r = r__1, q__1.i = r__2;     fooc_(&q__1); // FFEINTRIN_imp_CMPLX_R //     q__1.r = r1, q__1.i = r2;     fooc_(&q__1); // FFEINTRIN_imp_DBLE_C //     d__1 = (doublereal) c1.r;     food_(&d__1); // FFEINTRIN_imp_DBLE_D //     d__1 = d1;     food_(&d__1); // FFEINTRIN_imp_DBLE_I //     d__1 = (doublereal) i1;     food_(&d__1); // FFEINTRIN_imp_DBLE_R //     d__1 = (doublereal) r1;     food_(&d__1); // FFEINTRIN_imp_INT_C //     i__1 = (integer) c1.r;     fooi_(&i__1); // FFEINTRIN_imp_INT_D //     i__1 = (integer) d1;     fooi_(&i__1); // FFEINTRIN_imp_INT_I //     i__1 = i1;     fooi_(&i__1); // FFEINTRIN_imp_INT_R //     i__1 = (integer) r1;     fooi_(&i__1); // FFEINTRIN_imp_REAL_C //     r__1 = c1.r;     foor_(&r__1); // FFEINTRIN_imp_REAL_D //     r__1 = (real) d1;     foor_(&r__1); // FFEINTRIN_imp_REAL_I //     r__1 = (real) i1;     foor_(&r__1); // FFEINTRIN_imp_REAL_R //     r__1 = r1;     foor_(&r__1);  // FFEINTRIN_imp_INT_D: //  // FFEINTRIN_specIDINT //     i__1 = (integer) d1;     fooi_(&i__1);  // FFEINTRIN_imp_INT_R: //  // FFEINTRIN_specIFIX //     i__1 = (integer) r1;     fooi_(&i__1); // FFEINTRIN_specINT //     i__1 = (integer) r1;     fooi_(&i__1);  // FFEINTRIN_imp_REAL_D: //  // FFEINTRIN_specSNGL //     r__1 = (real) d1;     foor_(&r__1);  // FFEINTRIN_imp_REAL_I: //  // FFEINTRIN_specFLOAT //     r__1 = (real) i1;     foor_(&r__1); // FFEINTRIN_specREAL //     r__1 = (real) i1;     foor_(&r__1);  } // MAIN__ //  -------- (end output file from f2c)  */
end_comment

end_unit

