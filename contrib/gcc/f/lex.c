begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implementation of Fortran lexer    Copyright (C) 1995, 1996, 1997, 1998, 2001 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"bad.h"
end_include

begin_include
include|#
directive|include
file|"com.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"src.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_function_decl
specifier|static
name|void
name|ffelex_append_to_token_
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ffelex_backslash_
parameter_list|(
name|int
name|c
parameter_list|,
name|ffewhereColumnNumber
name|col
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffelex_bad_1_
parameter_list|(
name|ffebad
name|errnum
parameter_list|,
name|ffewhereLineNumber
name|ln0
parameter_list|,
name|ffewhereColumnNumber
name|cn0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffelex_bad_2_
parameter_list|(
name|ffebad
name|errnum
parameter_list|,
name|ffewhereLineNumber
name|ln0
parameter_list|,
name|ffewhereColumnNumber
name|cn0
parameter_list|,
name|ffewhereLineNumber
name|ln1
parameter_list|,
name|ffewhereColumnNumber
name|cn1
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffelex_bad_here_
parameter_list|(
name|int
name|num
parameter_list|,
name|ffewhereLineNumber
name|ln0
parameter_list|,
name|ffewhereColumnNumber
name|cn0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffelex_finish_statement_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ffelex_get_directive_line_
parameter_list|(
name|char
modifier|*
modifier|*
name|text
parameter_list|,
name|FILE
modifier|*
name|finput
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ffelex_hash_
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffewhereColumnNumber
name|ffelex_image_char_
parameter_list|(
name|int
name|c
parameter_list|,
name|ffewhereColumnNumber
name|col
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffelex_include_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffelex_is_free_char_ctx_contin_
parameter_list|(
name|ffewhereColumnNumber
name|col
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffelex_is_free_nonc_ctx_contin_
parameter_list|(
name|ffewhereColumnNumber
name|col
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffelex_next_line_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffelex_prepare_eos_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffelex_send_token_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffelex_swallow_tokens_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexToken
name|ffelex_token_new_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Pertaining to the geometry of the input file.  */
end_comment

begin_comment
comment|/* Initial size for card image to be allocated.  */
end_comment

begin_define
define|#
directive|define
name|FFELEX_columnINITIAL_SIZE_
value|255
end_define

begin_comment
comment|/* The card image itself, which grows as source lines get longer.  It    has room for ffelex_card_size_ + 8 characters, and the length of the    current image is ffelex_card_length_.  (The + 8 characters are made    available for easy handling of tabs and such.)  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ffelex_card_image_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffewhereColumnNumber
name|ffelex_card_size_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffewhereColumnNumber
name|ffelex_card_length_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max width for free-form lines (ISO F90).  */
end_comment

begin_define
define|#
directive|define
name|FFELEX_FREE_MAX_COLUMNS_
value|132
end_define

begin_comment
comment|/* True if we saw a tab on the current line, as this (currently) means    the line is therefore treated as though final_nontab_column_ were    infinite.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffelex_saw_tab_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if current line is known to be erroneous, so don't bother    expanding room for it just to display it.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffelex_bad_line_
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last column for vanilla, i.e. non-tabbed, line.  Usually 72 or 132. */
end_comment

begin_decl_stmt
specifier|static
name|ffewhereColumnNumber
name|ffelex_final_nontab_column_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array for quickly deciding what kind of line the current card has,    based on its first character.  */
end_comment

begin_decl_stmt
specifier|static
name|ffelexType
name|ffelex_first_char_
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pertaining to file management.  */
end_comment

begin_comment
comment|/* The wf argument of the most recent active ffelex_file_(fixed,free)    function.  */
end_comment

begin_decl_stmt
specifier|static
name|ffewhereFile
name|ffelex_current_wf_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if an INCLUDE statement can be processed (ffelex_set_include    can be called).  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffelex_permit_include_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if an INCLUDE statement is pending (ffelex_set_include has been    called).  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffelex_set_include_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Information on the pending INCLUDE file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|ffelex_include_file_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ffelex_include_free_form_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffewhereFile
name|ffelex_include_wherefile_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current master line count.  */
end_comment

begin_decl_stmt
specifier|static
name|ffewhereLineNumber
name|ffelex_linecount_current_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next master line count.  */
end_comment

begin_decl_stmt
specifier|static
name|ffewhereLineNumber
name|ffelex_linecount_next_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ffewhere info on the latest (currently active) line read from the    active source file.  */
end_comment

begin_decl_stmt
specifier|static
name|ffewhereLine
name|ffelex_current_wl_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffewhereColumn
name|ffelex_current_wc_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pertaining to tokens in general.  */
end_comment

begin_comment
comment|/* Initial capacity for text in a CHARACTER/HOLLERITH/NAME/NAMES/NUMBER    token.  */
end_comment

begin_define
define|#
directive|define
name|FFELEX_columnTOKEN_SIZE_
value|63
end_define

begin_if
if|#
directive|if
name|FFELEX_columnTOKEN_SIZE_
operator|<
name|FFEWHERE_indexMAX
end_if

begin_error
error|#
directive|error
literal|"token size too small!"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Current token being lexed.  */
end_comment

begin_decl_stmt
specifier|static
name|ffelexToken
name|ffelex_token_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handler for current token.  */
end_comment

begin_decl_stmt
specifier|static
name|ffelexHandler
name|ffelex_handler_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if fixed-form lexer is to generate NAMES instead of NAME tokens.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffelex_names_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if both lexers are to generate NAMES instead of NAME tokens.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffelex_names_pure_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if 0-9 starts a NAME token instead of NUMBER, for parsing hex    numbers.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffelex_hexnum_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For ffelex_swallow_tokens().  */
end_comment

begin_decl_stmt
specifier|static
name|ffelexHandler
name|ffelex_eos_handler_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of tokens sent since last EOS or beginning of input file    (include INCLUDEd files).  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|int
name|ffelex_number_of_tokens_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of labels sent (as NUMBER tokens) since last reset of    ffelex_number_of_tokens_ to 0, should be 0 or 1 in most cases.    (Fixed-form source only.)  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|int
name|ffelex_label_tokens_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Metering for token management, to catch token-memory leaks.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|int
name|ffelex_total_tokens_
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|int
name|ffelex_old_total_tokens_
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|int
name|ffelex_token_nextid_
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pertaining to lexing CHARACTER and HOLLERITH tokens.  */
end_comment

begin_comment
comment|/*>0 if a Hollerith constant of that length might be in mid-lex, used    when the next character seen is 'H' or 'h' to enter HOLLERITH lexing    mode (see ffelex_raw_mode_).  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|int
name|ffelex_expecting_hollerith_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -3: Backslash (escape) sequence being lexed in CHARACTER.    -2: Possible closing apostrophe/quote seen in CHARACTER.    -1: Lexing CHARACTER.     0: Not lexing CHARACTER or HOLLERITH.>0: Lexing HOLLERITH, value is # chars remaining to expect.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|int
name|ffelex_raw_mode_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When lexing CHARACTER, open quote/apostrophe (either ' or ").  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ffelex_raw_char_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE when backslash processing had to use most recent character    to finish its state engine, but that character is not part of    the backslash sequence, so must be reconsidered as a "normal"    character in CHARACTER/HOLLERITH lexing.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffelex_backslash_reconsider_
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters preread before lexing happened (might include EOF).  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|ffelex_kludge_chars_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Doing the kludge processing, so not initialized yet.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffelex_kludge_flag_
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The beginning of a (possible) CHARACTER/HOLLERITH token.  */
end_comment

begin_decl_stmt
specifier|static
name|ffewhereLine
name|ffelex_raw_where_line_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffewhereColumn
name|ffelex_raw_where_col_
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Call this to append another character to the current token.	If it isn't    currently big enough for it, it will be enlarged.  The current token    must be a CHARACTER, HOLLERITH, NAME, NAMES, or NUMBER.  */
end_comment

begin_function
specifier|static
name|void
name|ffelex_append_to_token_
parameter_list|(
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_
operator|->
name|text
operator|==
name|NULL
condition|)
block|{
name|ffelex_token_
operator|->
name|text
operator|=
name|malloc_new_ksr
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFELEX token text"
argument_list|,
name|FFELEX_columnTOKEN_SIZE_
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|size
operator|=
name|FFELEX_columnTOKEN_SIZE_
expr_stmt|;
name|ffelex_token_
operator|->
name|length
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffelex_token_
operator|->
name|length
operator|>=
name|ffelex_token_
operator|->
name|size
condition|)
block|{
name|ffelex_token_
operator|->
name|text
operator|=
name|malloc_resize_ksr
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
name|ffelex_token_
operator|->
name|text
argument_list|,
operator|(
name|ffelex_token_
operator|->
name|size
operator|<<
literal|1
operator|)
operator|+
literal|1
argument_list|,
name|ffelex_token_
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|size
operator|<<=
literal|1
expr_stmt|;
name|assert
argument_list|(
name|ffelex_token_
operator|->
name|length
operator|<
name|ffelex_token_
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAP_CHARACTER
name|Sorry
operator|,
name|MAP_CHARACTER
name|is
name|not
name|going
name|to
name|work
name|as
name|expected
name|in
name|GNU
name|Fortran
operator|,
name|please
name|contact
name|fortran
expr|@
name|gnu
operator|.
name|org
if|if you wish to fund work to port g77 to non-ASCII machines.
endif|#
directive|endif
if|ffelex_token_->text[ffelex_token_->length++] = c
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Do backslash (escape) processing for a CHARACTER/HOLLERITH token    being lexed.  */
end_comment

begin_function
specifier|static
name|int
name|ffelex_backslash_
parameter_list|(
name|int
name|c
parameter_list|,
name|ffewhereColumnNumber
name|col
parameter_list|)
block|{
specifier|static
name|int
name|state
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|int
name|count
decl_stmt|;
specifier|static
name|int
name|code
decl_stmt|;
specifier|static
name|unsigned
name|int
name|firstdig
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|nonnull
decl_stmt|;
specifier|static
name|ffewhereLineNumber
name|line
decl_stmt|;
specifier|static
name|ffewhereColumnNumber
name|column
decl_stmt|;
comment|/* See gcc/c-lex.c readescape() for a straightforward version      of this state engine for handling backslashes in character/      hollerith constants.  */
define|#
directive|define
name|wide_flag
value|0
define|#
directive|define
name|warn_traditional
value|0
define|#
directive|define
name|flag_traditional
value|0
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|(
name|c
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|ffelex_raw_mode_
operator|!=
literal|0
operator|)
operator|&&
name|ffe_is_backslash
argument_list|()
condition|)
block|{
name|state
operator|=
literal|1
expr_stmt|;
name|column
operator|=
name|col
operator|+
literal|1
expr_stmt|;
name|line
operator|=
name|ffelex_linecount_current_
expr_stmt|;
return|return
name|EOF
return|;
block|}
return|return
name|c
return|;
case|case
literal|1
case|:
name|state
operator|=
literal|0
expr_stmt|;
comment|/* Assume simple case. */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'x'
case|:
if|if
condition|(
name|warn_traditional
condition|)
block|{
name|ffebad_start_msg_lex
argument_list|(
literal|"The meaning of `\\x' (at %0) varies with -traditional"
argument_list|,
name|FFEBAD_severityWARNING
argument_list|)
expr_stmt|;
name|ffelex_bad_here_
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flag_traditional
condition|)
return|return
name|c
return|;
name|code
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|nonnull
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|2
expr_stmt|;
return|return
name|EOF
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|code
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|state
operator|=
literal|3
expr_stmt|;
return|return
name|EOF
return|;
case|case
literal|'\\'
case|:
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
return|return
name|c
return|;
if|#
directive|if
literal|0
comment|/* Inappropriate for Fortran. */
block|case '\n': 	  ffelex_next_line_ (); 	  *ignore_ptr = 1; 	  return 0;
endif|#
directive|endif
case|case
literal|'n'
case|:
return|return
name|TARGET_NEWLINE
return|;
case|case
literal|'t'
case|:
return|return
name|TARGET_TAB
return|;
case|case
literal|'r'
case|:
return|return
name|TARGET_CR
return|;
case|case
literal|'f'
case|:
return|return
name|TARGET_FF
return|;
case|case
literal|'b'
case|:
return|return
name|TARGET_BS
return|;
case|case
literal|'a'
case|:
if|if
condition|(
name|warn_traditional
condition|)
block|{
name|ffebad_start_msg_lex
argument_list|(
literal|"The meaning of `\\a' (at %0) varies with -traditional"
argument_list|,
name|FFEBAD_severityWARNING
argument_list|)
expr_stmt|;
name|ffelex_bad_here_
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flag_traditional
condition|)
return|return
name|c
return|;
return|return
name|TARGET_BELL
return|;
case|case
literal|'v'
case|:
if|#
directive|if
literal|0
comment|/* Vertical tab is present in common usage compilers.  */
block|if (flag_traditional) 	    return c;
endif|#
directive|endif
return|return
name|TARGET_VT
return|;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'('
case|:
case|case
literal|'{'
case|:
case|case
literal|'['
case|:
case|case
literal|'%'
case|:
if|if
condition|(
name|pedantic
condition|)
block|{
name|char
name|m
index|[
literal|2
index|]
decl_stmt|;
name|m
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|m
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ffebad_start_msg_lex
argument_list|(
literal|"Non-ISO-C-standard escape sequence `\\%A' at %0"
argument_list|,
name|FFEBAD_severityPEDANTIC
argument_list|)
expr_stmt|;
name|ffelex_bad_here_
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'e'
operator|)
condition|?
literal|033
else|:
name|c
return|;
case|case
literal|'?'
case|:
return|return
name|c
return|;
default|default:
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
name|char
name|m
index|[
literal|2
index|]
decl_stmt|;
name|m
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|m
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ffebad_start_msg_lex
argument_list|(
literal|"Unknown escape sequence `\\%A' at %0"
argument_list|,
name|FFEBAD_severityPEDANTIC
argument_list|)
expr_stmt|;
name|ffelex_bad_here_
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|ffebad_start_msg_lex
argument_list|(
literal|"Unterminated escape sequence `\\' at %0"
argument_list|,
name|FFEBAD_severityPEDANTIC
argument_list|)
expr_stmt|;
name|ffelex_bad_here_
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|char
name|m
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
operator|&
name|m
index|[
literal|0
index|]
argument_list|,
literal|"%x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ffebad_start_msg_lex
argument_list|(
literal|"Unknown escape sequence `\\' followed by char code 0x%A at %0"
argument_list|,
name|FFEBAD_severityPEDANTIC
argument_list|)
expr_stmt|;
name|ffelex_bad_here_
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
case|case
literal|2
case|:
if|if
condition|(
name|ISXDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|code
operator|=
operator|(
name|code
operator|*
literal|16
operator|)
operator|+
name|hex_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
operator|||
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|firstdig
operator|=
name|code
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|EOF
return|;
block|}
name|state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|nonnull
condition|)
block|{
name|ffebad_start_msg_lex
argument_list|(
literal|"\\x used at %0 with no following hex digits"
argument_list|,
name|FFEBAD_severityFATAL
argument_list|)
expr_stmt|;
name|ffelex_bad_here_
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
comment|/* Digits are all 0's.  Ok.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
operator|>=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|||
operator|(
name|count
operator|>
literal|1
operator|&&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|-
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
operator|)
operator|)
operator|<=
operator|(
name|int
operator|)
name|firstdig
operator|)
operator|)
condition|)
block|{
name|ffebad_start_msg_lex
argument_list|(
literal|"Hex escape at %0 out of range"
argument_list|,
name|FFEBAD_severityPEDANTIC
argument_list|)
expr_stmt|;
name|ffelex_bad_here_
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
if|if
condition|(
operator|(
name|c
operator|<=
literal|'7'
operator|)
operator|&&
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|count
operator|++
operator|<
literal|3
operator|)
condition|)
block|{
name|code
operator|=
operator|(
name|code
operator|*
literal|8
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
name|EOF
return|;
block|}
name|state
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad backslash state"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Come here when code has a built character, and c is the next      character that might (or might not) be the next one in the constant.  */
comment|/* Don't bother doing this check for each character going into      CHARACTER or HOLLERITH constants, just the escaped-value ones.      gcc apparently checks every single character, which seems      like it'd be kinda slow and not worth doing anyway.  */
if|if
condition|(
operator|!
name|wide_flag
operator|&&
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
operator|<
name|HOST_BITS_PER_INT
operator|&&
name|code
operator|>=
operator|(
literal|1
operator|<<
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
operator|)
condition|)
block|{
name|ffebad_start_msg_lex
argument_list|(
literal|"Escape sequence at %0 out of range for character"
argument_list|,
name|FFEBAD_severityFATAL
argument_list|)
expr_stmt|;
name|ffelex_bad_here_
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
comment|/* Known end of constant, just append this character.  */
name|ffelex_append_to_token_
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_raw_mode_
operator|>
literal|0
condition|)
operator|--
name|ffelex_raw_mode_
expr_stmt|;
return|return
name|EOF
return|;
block|}
comment|/* Have two characters to handle.  Do the first, then leave it to the      caller to detect anything special about the second.  */
name|ffelex_append_to_token_
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_raw_mode_
operator|>
literal|0
condition|)
operator|--
name|ffelex_raw_mode_
expr_stmt|;
name|ffelex_backslash_reconsider_
operator|=
name|TRUE
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* ffelex_bad_1_ -- Issue diagnostic with one source point     ffelex_bad_1_(FFEBAD_SOME_ERROR,ffelex_linecount_current_,column + 1);     Creates ffewhere line and column objects for the source point, sends them    along with the error code to ffebad, then kills the line and column    objects before returning.  */
end_comment

begin_function
specifier|static
name|void
name|ffelex_bad_1_
parameter_list|(
name|ffebad
name|errnum
parameter_list|,
name|ffewhereLineNumber
name|ln0
parameter_list|,
name|ffewhereColumnNumber
name|cn0
parameter_list|)
block|{
name|ffewhereLine
name|wl0
decl_stmt|;
name|ffewhereColumn
name|wc0
decl_stmt|;
name|wl0
operator|=
name|ffewhere_line_new
argument_list|(
name|ln0
argument_list|)
expr_stmt|;
name|wc0
operator|=
name|ffewhere_column_new
argument_list|(
name|cn0
argument_list|)
expr_stmt|;
name|ffebad_start_lex
argument_list|(
name|errnum
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|wl0
argument_list|,
name|wc0
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffewhere_line_kill
argument_list|(
name|wl0
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|wc0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffelex_bad_2_ -- Issue diagnostic with two source points     ffelex_bad_2_(FFEBAD_SOME_ERROR,ffelex_linecount_current_,column + 1, 	 otherline,othercolumn);     Creates ffewhere line and column objects for the source points, sends them    along with the error code to ffebad, then kills the line and column    objects before returning.  */
end_comment

begin_function
specifier|static
name|void
name|ffelex_bad_2_
parameter_list|(
name|ffebad
name|errnum
parameter_list|,
name|ffewhereLineNumber
name|ln0
parameter_list|,
name|ffewhereColumnNumber
name|cn0
parameter_list|,
name|ffewhereLineNumber
name|ln1
parameter_list|,
name|ffewhereColumnNumber
name|cn1
parameter_list|)
block|{
name|ffewhereLine
name|wl0
decl_stmt|,
name|wl1
decl_stmt|;
name|ffewhereColumn
name|wc0
decl_stmt|,
name|wc1
decl_stmt|;
name|wl0
operator|=
name|ffewhere_line_new
argument_list|(
name|ln0
argument_list|)
expr_stmt|;
name|wc0
operator|=
name|ffewhere_column_new
argument_list|(
name|cn0
argument_list|)
expr_stmt|;
name|wl1
operator|=
name|ffewhere_line_new
argument_list|(
name|ln1
argument_list|)
expr_stmt|;
name|wc1
operator|=
name|ffewhere_column_new
argument_list|(
name|cn1
argument_list|)
expr_stmt|;
name|ffebad_start_lex
argument_list|(
name|errnum
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|wl0
argument_list|,
name|wc0
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|wl1
argument_list|,
name|wc1
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffewhere_line_kill
argument_list|(
name|wl0
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|wc0
argument_list|)
expr_stmt|;
name|ffewhere_line_kill
argument_list|(
name|wl1
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|wc1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffelex_bad_here_
parameter_list|(
name|int
name|n
parameter_list|,
name|ffewhereLineNumber
name|ln0
parameter_list|,
name|ffewhereColumnNumber
name|cn0
parameter_list|)
block|{
name|ffewhereLine
name|wl0
decl_stmt|;
name|ffewhereColumn
name|wc0
decl_stmt|;
name|wl0
operator|=
name|ffewhere_line_new
argument_list|(
name|ln0
argument_list|)
expr_stmt|;
name|wc0
operator|=
name|ffewhere_column_new
argument_list|(
name|cn0
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
name|n
argument_list|,
name|wl0
argument_list|,
name|wc0
argument_list|)
expr_stmt|;
name|ffewhere_line_kill
argument_list|(
name|wl0
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|wc0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ffelex_getc_
parameter_list|(
name|FILE
modifier|*
name|finput
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|ffelex_kludge_chars_
operator|==
name|NULL
condition|)
return|return
name|getc
argument_list|(
name|finput
argument_list|)
return|;
name|c
operator|=
operator|*
name|ffelex_kludge_chars_
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
return|return
name|c
return|;
name|ffelex_kludge_chars_
operator|=
name|NULL
expr_stmt|;
return|return
name|getc
argument_list|(
name|finput
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ffelex_cfebackslash_
parameter_list|(
name|int
modifier|*
name|use_d
parameter_list|,
name|int
modifier|*
name|d
parameter_list|,
name|FILE
modifier|*
name|finput
parameter_list|)
block|{
specifier|register
name|int
name|c
init|=
name|getc
argument_list|(
name|finput
argument_list|)
decl_stmt|;
specifier|register
name|int
name|code
decl_stmt|;
specifier|register
name|unsigned
name|count
decl_stmt|;
name|unsigned
name|firstdig
init|=
literal|0
decl_stmt|;
name|int
name|nonnull
decl_stmt|;
operator|*
name|use_d
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'x'
case|:
if|if
condition|(
name|warn_traditional
condition|)
name|warning
argument_list|(
literal|"the meaning of `\\x' varies with -traditional"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_traditional
condition|)
return|return
name|c
return|;
name|code
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|nonnull
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISXDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|use_d
operator|=
literal|1
expr_stmt|;
operator|*
name|d
operator|=
name|c
expr_stmt|;
break|break;
block|}
name|code
operator|=
operator|(
name|code
operator|*
literal|16
operator|)
operator|+
name|hex_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
operator|||
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|firstdig
operator|=
name|code
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|nonnull
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nonnull
condition|)
name|error
argument_list|(
literal|"\\x used with no following hex digits"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
comment|/* Digits are all 0's.  Ok.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
operator|>=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|||
operator|(
name|count
operator|>
literal|1
operator|&&
operator|(
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|-
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
operator|)
operator|)
operator|<=
name|firstdig
operator|)
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"hex escape out of range"
argument_list|)
expr_stmt|;
return|return
name|code
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|code
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|<=
literal|'7'
operator|)
operator|&&
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|count
operator|++
operator|<
literal|3
operator|)
condition|)
block|{
name|code
operator|=
operator|(
name|code
operator|*
literal|8
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
operator|*
name|use_d
operator|=
literal|1
expr_stmt|;
operator|*
name|d
operator|=
name|c
expr_stmt|;
return|return
name|code
return|;
case|case
literal|'\\'
case|:
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
return|return
name|c
return|;
case|case
literal|'\n'
case|:
name|ffelex_next_line_
argument_list|()
expr_stmt|;
operator|*
name|use_d
operator|=
literal|2
expr_stmt|;
return|return
literal|0
return|;
case|case
name|EOF
case|:
operator|*
name|use_d
operator|=
literal|1
expr_stmt|;
operator|*
name|d
operator|=
name|EOF
expr_stmt|;
return|return
name|EOF
return|;
case|case
literal|'n'
case|:
return|return
name|TARGET_NEWLINE
return|;
case|case
literal|'t'
case|:
return|return
name|TARGET_TAB
return|;
case|case
literal|'r'
case|:
return|return
name|TARGET_CR
return|;
case|case
literal|'f'
case|:
return|return
name|TARGET_FF
return|;
case|case
literal|'b'
case|:
return|return
name|TARGET_BS
return|;
case|case
literal|'a'
case|:
if|if
condition|(
name|warn_traditional
condition|)
name|warning
argument_list|(
literal|"the meaning of `\\a' varies with -traditional"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_traditional
condition|)
return|return
name|c
return|;
return|return
name|TARGET_BELL
return|;
case|case
literal|'v'
case|:
if|#
directive|if
literal|0
comment|/* Vertical tab is present in common usage compilers.  */
block|if (flag_traditional) 	return c;
endif|#
directive|endif
return|return
name|TARGET_VT
return|;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"non-ANSI-standard escape sequence, `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|033
return|;
case|case
literal|'?'
case|:
return|return
name|c
return|;
comment|/* `\(', etc, are used at beginning of line to avoid confusing Emacs.  */
case|case
literal|'('
case|:
case|case
literal|'{'
case|:
case|case
literal|'['
case|:
comment|/* `\%' is used to prevent SCCS from getting confused.  */
case|case
literal|'%'
case|:
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"non-ISO escape sequence `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
name|pedwarn
argument_list|(
literal|"unknown escape sequence `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"unknown escape sequence: `\\' followed by char code 0x%x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* A miniature version of the C front-end lexer.  */
end_comment

begin_function
specifier|static
name|int
name|ffelex_cfelex_
parameter_list|(
name|ffelexToken
modifier|*
name|xtoken
parameter_list|,
name|FILE
modifier|*
name|finput
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|ffelexToken
name|token
decl_stmt|;
name|char
name|buff
index|[
literal|129
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|;
specifier|register
name|unsigned
name|buffer_length
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|xtoken
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|ffelex_kludge_flag_
condition|)
name|ffelex_token_kill
argument_list|(
operator|*
name|xtoken
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|buffer_length
operator|=
name|ARRAY_SIZE
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|buff
index|[
literal|0
index|]
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
name|r
operator|=
operator|&
name|buff
index|[
name|buffer_length
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|r
condition|)
block|{
specifier|register
name|unsigned
name|bytes_used
init|=
operator|(
name|p
operator|-
name|q
operator|)
decl_stmt|;
name|buffer_length
operator|*=
literal|2
expr_stmt|;
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|q
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|q
index|[
name|bytes_used
index|]
expr_stmt|;
name|r
operator|=
operator|&
name|q
index|[
name|buffer_length
index|]
expr_stmt|;
block|}
name|c
operator|=
name|ffelex_getc_
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|token
operator|=
name|ffelex_token_new_number
argument_list|(
name|q
argument_list|,
name|ffewhere_line_unknown
argument_list|()
argument_list|,
name|ffewhere_column_unknown
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
operator|&
name|buff
index|[
literal|0
index|]
condition|)
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|buffer_length
operator|=
name|ARRAY_SIZE
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|buff
index|[
literal|0
index|]
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
name|r
operator|=
operator|&
name|buff
index|[
name|buffer_length
index|]
expr_stmt|;
name|c
operator|=
name|ffelex_getc_
argument_list|(
name|finput
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bool
name|done
init|=
name|FALSE
decl_stmt|;
name|int
name|use_d
init|=
literal|0
decl_stmt|;
name|int
name|d
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\"'
case|:
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* ~~~~~ */
name|c
operator|=
name|ffelex_cfebackslash_
argument_list|(
operator|&
name|use_d
argument_list|,
operator|&
name|d
argument_list|,
name|finput
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOF
case|:
case|case
literal|'\n'
case|:
name|error
argument_list|(
literal|"badly formed directive -- no closing quote"
argument_list|)
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|done
condition|)
break|break;
if|if
condition|(
name|use_d
operator|!=
literal|2
condition|)
comment|/* 0=>c, 1=>cd, 2=>nil. */
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|r
condition|)
block|{
specifier|register
name|unsigned
name|bytes_used
init|=
operator|(
name|p
operator|-
name|q
operator|)
decl_stmt|;
name|buffer_length
operator|=
name|bytes_used
operator|*
literal|2
expr_stmt|;
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|q
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|q
index|[
name|bytes_used
index|]
expr_stmt|;
name|r
operator|=
operator|&
name|q
index|[
name|buffer_length
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|use_d
operator|==
literal|1
condition|)
name|c
operator|=
name|d
expr_stmt|;
else|else
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|token
operator|=
name|ffelex_token_new_character
argument_list|(
name|q
argument_list|,
name|ffewhere_line_unknown
argument_list|()
argument_list|,
name|ffewhere_column_unknown
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
operator|&
name|buff
index|[
literal|0
index|]
condition|)
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
default|default:
name|token
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
operator|*
name|xtoken
operator|=
name|token
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffelex_file_pop_
parameter_list|(
specifier|const
name|char
modifier|*
name|input_filename
parameter_list|)
block|{
if|if
condition|(
name|input_file_stack
operator|->
name|next
condition|)
block|{
name|struct
name|file_stack
modifier|*
name|p
init|=
name|input_file_stack
decl_stmt|;
name|input_file_stack
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|end_source_file
call|)
argument_list|(
name|input_file_stack
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"#-lines for entering and leaving files don't match"
argument_list|)
expr_stmt|;
comment|/* Now that we've pushed or popped the input stack,      update the name in the top element.  */
if|if
condition|(
name|input_file_stack
condition|)
name|input_file_stack
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffelex_file_push_
parameter_list|(
name|int
name|old_lineno
parameter_list|,
specifier|const
name|char
modifier|*
name|input_filename
parameter_list|)
block|{
name|struct
name|file_stack
modifier|*
name|p
init|=
operator|(
expr|struct
name|file_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_stack
argument_list|)
argument_list|)
decl_stmt|;
name|input_file_stack
operator|->
name|line
operator|=
name|old_lineno
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|input_file_stack
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
name|input_file_stack
operator|=
name|p
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|start_source_file
call|)
argument_list|(
literal|0
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
comment|/* Now that we've pushed or popped the input stack,      update the name in the top element.  */
if|if
condition|(
name|input_file_stack
condition|)
name|input_file_stack
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare to finish a statement-in-progress by sending the current    token, if any, then setting up EOS as the current token with the    appropriate current pointer.  The caller can then move the current    pointer before actually sending EOS, if desired, as it is in    typical fixed-form cases.  */
end_comment

begin_function
specifier|static
name|void
name|ffelex_prepare_eos_
parameter_list|()
block|{
if|if
condition|(
name|ffelex_token_
operator|->
name|type
operator|!=
name|FFELEX_typeNONE
condition|)
block|{
name|ffelex_backslash_
argument_list|(
name|EOF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_raw_mode_
condition|)
block|{
case|case
operator|-
literal|2
case|:
break|break;
case|case
operator|-
literal|1
case|:
name|ffebad_start_lex
argument_list|(
operator|(
name|ffelex_raw_char_
operator|==
literal|'\''
operator|)
condition|?
name|FFEBAD_NO_CLOSING_APOSTROPHE
else|:
name|FFEBAD_NO_CLOSING_QUOTE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_
operator|->
name|where_line
argument_list|,
name|ffelex_token_
operator|->
name|where_col
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_current_wl_
argument_list|,
name|ffelex_current_wc_
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
default|default:
block|{
name|char
name|num
index|[
literal|20
index|]
decl_stmt|;
name|ffebad_start_lex
argument_list|(
name|FFEBAD_NOT_ENOUGH_HOLLERITH_CHARS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_
operator|->
name|where_line
argument_list|,
name|ffelex_token_
operator|->
name|where_col
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_current_wl_
argument_list|,
name|ffelex_current_wc_
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ffelex_raw_mode_
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
comment|/* Make sure the token has some text, might as well fill up with spaces.  */
do|do
block|{
name|ffelex_append_to_token_
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ffelex_raw_mode_
operator|>
literal|0
condition|)
do|;
break|break;
block|}
block|}
name|ffelex_raw_mode_
operator|=
literal|0
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeEOS
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_use
argument_list|(
name|ffelex_current_wc_
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffelex_finish_statement_
parameter_list|()
block|{
if|if
condition|(
operator|(
name|ffelex_number_of_tokens_
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ffelex_token_
operator|->
name|type
operator|==
name|FFELEX_typeNONE
operator|)
condition|)
return|return;
comment|/* Don't have a statement pending. */
if|if
condition|(
name|ffelex_token_
operator|->
name|type
operator|!=
name|FFELEX_typeEOS
condition|)
name|ffelex_prepare_eos_
argument_list|()
expr_stmt|;
name|ffelex_permit_include_
operator|=
name|TRUE
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
name|ffelex_permit_include_
operator|=
name|FALSE
expr_stmt|;
name|ffelex_number_of_tokens_
operator|=
literal|0
expr_stmt|;
name|ffelex_label_tokens_
operator|=
literal|0
expr_stmt|;
name|ffelex_names_
operator|=
name|TRUE
expr_stmt|;
name|ffelex_names_pure_
operator|=
name|FALSE
expr_stmt|;
comment|/* Probably not necessary. */
name|ffelex_hexnum_
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|ffe_is_ffedebug
argument_list|()
condition|)
return|return;
comment|/* For debugging purposes only. */
if|if
condition|(
name|ffelex_total_tokens_
operator|!=
name|ffelex_old_total_tokens_
condition|)
block|{
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"; token_track had %ld tokens, now have %ld.\n"
argument_list|,
name|ffelex_old_total_tokens_
argument_list|,
name|ffelex_total_tokens_
argument_list|)
expr_stmt|;
name|ffelex_old_total_tokens_
operator|=
name|ffelex_total_tokens_
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copied from gcc/c-common.c get_directive_line.  */
end_comment

begin_function
specifier|static
name|int
name|ffelex_get_directive_line_
parameter_list|(
name|char
modifier|*
modifier|*
name|text
parameter_list|,
name|FILE
modifier|*
name|finput
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|directive_buffer
init|=
name|NULL
decl_stmt|;
specifier|static
name|unsigned
name|buffer_length
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer_limit
decl_stmt|;
specifier|register
name|int
name|looking_for
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|char_escaped
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|buffer_length
operator|==
literal|0
condition|)
block|{
name|directive_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|buffer_length
operator|=
literal|128
expr_stmt|;
block|}
name|buffer_limit
operator|=
operator|&
name|directive_buffer
index|[
name|buffer_length
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|directive_buffer
init|;
condition|;
control|)
block|{
name|int
name|c
decl_stmt|;
comment|/* Make buffer bigger if it is full.  */
if|if
condition|(
name|p
operator|>=
name|buffer_limit
condition|)
block|{
specifier|register
name|unsigned
name|bytes_used
init|=
operator|(
name|p
operator|-
name|directive_buffer
operator|)
decl_stmt|;
name|buffer_length
operator|*=
literal|2
expr_stmt|;
name|directive_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|directive_buffer
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|directive_buffer
index|[
name|bytes_used
index|]
expr_stmt|;
name|buffer_limit
operator|=
operator|&
name|directive_buffer
index|[
name|buffer_length
index|]
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* Discard initial whitespace.  */
if|if
condition|(
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
operator|&&
name|p
operator|==
name|directive_buffer
condition|)
continue|continue;
comment|/* Detect the end of the directive.  */
if|if
condition|(
operator|(
name|c
operator|==
literal|'\n'
operator|&&
name|looking_for
operator|==
literal|0
operator|)
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|looking_for
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"bad directive -- missing close-quote"
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|text
operator|=
name|directive_buffer
expr_stmt|;
return|return
name|c
return|;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|ffelex_next_line_
argument_list|()
expr_stmt|;
comment|/* Handle string and character constant syntax.  */
if|if
condition|(
name|looking_for
condition|)
block|{
if|if
condition|(
name|looking_for
operator|==
name|c
operator|&&
operator|!
name|char_escaped
condition|)
name|looking_for
operator|=
literal|0
expr_stmt|;
comment|/* Found terminator... stop looking.  */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|looking_for
operator|=
name|c
expr_stmt|;
comment|/* Don't stop buffering until we see another 				   one of these (or an EOF).  */
comment|/* Handle backslash.  */
name|char_escaped
operator|=
operator|(
name|c
operator|==
literal|'\\'
operator|&&
operator|!
name|char_escaped
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle # directives that make it through (or are generated by) the    preprocessor.  As much as reasonably possible, emulate the behavior    of the gcc compiler phase cc1, though interactions between #include    and INCLUDE might possibly produce bizarre results in terms of    error reporting and the generation of debugging info vis-a-vis the    locations of some things.     Returns the next character unhandled, which is always newline or EOF.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|HANDLE_PRAGMA
end_if

begin_comment
comment|/* Local versions of these macros, that can be passed as function pointers.  */
end_comment

begin_function
specifier|static
name|int
name|pragma_getc
parameter_list|()
block|{
return|return
name|getc
argument_list|(
name|finput
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pragma_ungetc
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|ungetc
argument_list|(
name|arg
argument_list|,
name|finput
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_PRAGMA */
end_comment

begin_function
specifier|static
name|int
name|ffelex_hash_
parameter_list|(
name|FILE
modifier|*
name|finput
parameter_list|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|ffelexToken
name|token
init|=
name|NULL
decl_stmt|;
comment|/* Read first nonwhite char after the `#'.  */
name|c
operator|=
name|ffelex_getc_
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|ffelex_getc_
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* If a letter follows, then if the word here is `line', skip      it and ignore it; otherwise, ignore the line, with an error      if the word isn't `pragma', `ident', `define', or `undef'.  */
if|if
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'r'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'a'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'g'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'m'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'a'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
operator|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* g77 doesn't handle pragmas, so ignores them FOR NOW. */
block|static char buffer [128]; 	      char * buff = buffer;
comment|/* Read the pragma name into a buffer. 		 ISSPACE() may evaluate its argument more than once!  */
block|while (((c = getc (finput)), ISSPACE(c))) 		continue;  	      do 		{ 		  * buff ++ = c; 		  c = getc (finput); 		} 	      while (c != EOF&& ! ISSPACE (c)&& c != '\n'&& buff< buffer + 128);  	      pragma_ungetc (c);  	      * -- buff = 0;
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA
block|if (HANDLE_PRAGMA (pragma_getc, pragma_ungetc, buffer)) 		goto skipline;
endif|#
directive|endif
comment|/* HANDLE_PRAGMA */
ifdef|#
directive|ifdef
name|HANDLE_GENERIC_PRAGMAS
block|if (handle_generic_pragma (buffer)) 		goto skipline;
endif|#
directive|endif
comment|/* !HANDLE_GENERIC_PRAGMAS */
comment|/* Issue a warning message if we have been asked to do so. 		 Ignoring unknown pragmas in system header file unless 		 an explcit -Wunknown-pragmas has been given. */
block|if (warn_unknown_pragmas> 1 		  || (warn_unknown_pragmas&& ! in_system_header)) 		warning ("ignoring pragma: %s", token_buffer);
endif|#
directive|endif
comment|/* 0 */
goto|goto
name|skipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'e'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'f'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'i'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'n'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'e'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
operator|)
condition|)
block|{
name|char
modifier|*
name|text
decl_stmt|;
name|c
operator|=
name|ffelex_get_directive_line_
argument_list|(
operator|&
name|text
argument_list|,
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|define
call|)
argument_list|(
name|lineno
argument_list|,
name|text
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'u'
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'n'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'d'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'e'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'f'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
operator|)
condition|)
block|{
name|char
modifier|*
name|text
decl_stmt|;
name|c
operator|=
name|ffelex_get_directive_line_
argument_list|(
operator|&
name|text
argument_list|,
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|undef
call|)
argument_list|(
name|lineno
argument_list|,
name|text
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'i'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'n'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'e'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
goto|goto
name|linenum
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'d'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'e'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'n'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'t'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
block|{
comment|/* #ident.  The pedantic warning is now in cpp.  */
comment|/* Here we have just seen `#ident '. 		 A string constant should follow.  */
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* If no argument, ignore the line.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
return|return
name|c
return|;
name|c
operator|=
name|ffelex_cfelex_
argument_list|(
operator|&
name|token
argument_list|,
name|finput
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|token
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|token
argument_list|)
operator|!=
name|FFELEX_typeCHARACTER
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid #ident"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
if|if
condition|(
operator|!
name|flag_no_ident
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_IDENT
name|ASM_OUTPUT_IDENT
argument_list|(
name|asm_out_file
argument_list|,
name|ffelex_token_text
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Skip the rest of this line.  */
goto|goto
name|skipline
goto|;
block|}
block|}
name|error
argument_list|(
literal|"undefined or invalid # directive"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|linenum
label|:
comment|/* Here we have either `#line' or `#<nonletter>'.      In either case, it should be a line number; a digit should follow.  */
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|ffelex_getc_
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* If the # is the only nonwhite char on the line,      just ignore it.  Check the new newline.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
return|return
name|c
return|;
comment|/* Something follows the #; read a token.  */
name|c
operator|=
name|ffelex_cfelex_
argument_list|(
operator|&
name|token
argument_list|,
name|finput
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|token
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|token
argument_list|)
operator|==
name|FFELEX_typeNUMBER
operator|)
condition|)
block|{
name|int
name|old_lineno
init|=
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
name|ffewhereFile
name|wf
decl_stmt|;
comment|/* subtract one, because it is the following line that 	 gets the specified number */
name|int
name|l
init|=
name|atoi
argument_list|(
name|ffelex_token_text
argument_list|(
name|token
argument_list|)
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|/* Is this the last nonwhite stuff on the line?  */
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|ffelex_getc_
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
comment|/* No more: store the line number and check following line.  */
name|lineno
operator|=
name|l
expr_stmt|;
if|if
condition|(
operator|!
name|ffelex_kludge_flag_
condition|)
block|{
name|ffewhere_file_set
argument_list|(
name|NULL
argument_list|,
name|TRUE
argument_list|,
operator|(
name|ffewhereLineNumber
operator|)
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
comment|/* More follows: it must be a string constant (filename).  */
comment|/* Read the string constant.  */
name|c
operator|=
name|ffelex_cfelex_
argument_list|(
operator|&
name|token
argument_list|,
name|finput
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|token
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|token
argument_list|)
operator|!=
name|FFELEX_typeCHARACTER
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid #line"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|lineno
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|ffelex_kludge_flag_
condition|)
name|input_filename
operator|=
name|ggc_strdup
argument_list|(
name|ffelex_token_text
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|wf
operator|=
name|ffewhere_file_new
argument_list|(
name|ffelex_token_text
argument_list|(
name|token
argument_list|)
argument_list|,
name|ffelex_token_length
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|ffewhere_file_name
argument_list|(
name|wf
argument_list|)
expr_stmt|;
name|ffewhere_file_set
argument_list|(
name|wf
argument_list|,
name|TRUE
argument_list|,
operator|(
name|ffewhereLineNumber
operator|)
name|l
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Not sure what g77 should do with this yet. */
comment|/* Each change of file name 	 reinitializes whether we are now in a system header.  */
block|in_system_header = 0;
endif|#
directive|endif
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
name|main_input_filename
operator|=
name|input_filename
expr_stmt|;
comment|/* Is this the last nonwhite stuff on the line?  */
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
operator|!
name|ffelex_kludge_flag_
condition|)
block|{
comment|/* Update the name in the top element of input_file_stack.  */
if|if
condition|(
name|input_file_stack
condition|)
name|input_file_stack
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
name|c
operator|=
name|ffelex_cfelex_
argument_list|(
operator|&
name|token
argument_list|,
name|finput
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* `1' after file name means entering new file. 	 `2' after file name means just left a file.  */
if|if
condition|(
operator|(
name|token
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|token
argument_list|)
operator|==
name|FFELEX_typeNUMBER
operator|)
condition|)
block|{
name|int
name|num
init|=
name|atoi
argument_list|(
name|ffelex_token_text
argument_list|(
name|token
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ffelex_kludge_flag_
condition|)
block|{
name|lineno
operator|=
literal|1
expr_stmt|;
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
name|error
argument_list|(
literal|"use `#line ...' instead of `# ...' in first line"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
comment|/* Pushing to a new file.  */
name|ffelex_file_push_
argument_list|(
name|old_lineno
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num
operator|==
literal|2
condition|)
block|{
comment|/* Popping out of a file.  */
name|ffelex_file_pop_
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
block|}
comment|/* Is this the last nonwhite stuff on the line?  */
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|token
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|token
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
name|c
operator|=
name|ffelex_cfelex_
argument_list|(
operator|&
name|token
argument_list|,
name|finput
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* `3' after file name means this is a system header file.  */
if|#
directive|if
literal|0
comment|/* Not sure what g77 should do with this yet. */
block|if ((token != NULL)&& (ffelex_token_type (token) == FFELEX_typeNUMBER)&& (atoi (ffelex_token_text (token)) == 3)) 	in_system_header = 1;
endif|#
directive|endif
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|token
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
operator|)
operator|)
operator|&&
name|ffelex_kludge_flag_
condition|)
block|{
name|lineno
operator|=
literal|1
expr_stmt|;
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
name|error
argument_list|(
literal|"use `#line ...' instead of `# ...' in first line"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|token
operator|!=
name|NULL
operator|&&
operator|!
name|ffelex_kludge_flag_
condition|)
name|ffelex_token_kill
argument_list|(
name|token
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"invalid #-line"
argument_list|)
expr_stmt|;
comment|/* skip the rest of this line.  */
name|skipline
label|:
if|if
condition|(
operator|(
name|token
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|ffelex_kludge_flag_
condition|)
name|ffelex_token_kill
argument_list|(
name|token
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* "Image" a character onto the card image, return incremented column number.     Normally invoking this function as in      column = ffelex_image_char_ (c, column);    is the same as doing:      ffelex_card_image_[column++] = c;     However, tabs and carriage returns are handled specially, to preserve    the visual "image" of the input line (in most editors) in the card    image.     Carriage returns are ignored, as they are assumed to be followed    by newlines.     A tab is handled by first doing:      ffelex_card_image_[column++] = ' ';    That is, it translates to at least one space.  Then, as many spaces    are imaged as necessary to bring the column number to the next tab    position, where tab positions start in the ninth column and each    eighth column afterwards.  ALSO, a static var named ffelex_saw_tab_    is set to TRUE to notify the lexer that a tab was seen.     Columns are numbered and tab stops set as illustrated below:     012345670123456701234567...    x	   y	   z    xx	   yy	   zz    ...    xxxxxxx yyyyyyy zzzzzzz    xxxxxxxx	   yyyyyyyy...  */
end_comment

begin_function
specifier|static
name|ffewhereColumnNumber
name|ffelex_image_char_
parameter_list|(
name|int
name|c
parameter_list|,
name|ffewhereColumnNumber
name|column
parameter_list|)
block|{
name|ffewhereColumnNumber
name|old_column
init|=
name|column
decl_stmt|;
if|if
condition|(
name|column
operator|>=
name|ffelex_card_size_
condition|)
block|{
name|ffewhereColumnNumber
name|newmax
init|=
name|ffelex_card_size_
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
name|ffelex_bad_line_
condition|)
return|return
name|column
return|;
if|if
condition|(
operator|(
name|newmax
operator|>>
literal|1
operator|)
operator|!=
name|ffelex_card_size_
condition|)
block|{
comment|/* Overflowed column number. */
name|overflow
label|:
comment|/* :::::::::::::::::::: */
name|ffelex_bad_line_
operator|=
name|TRUE
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|ffelex_card_image_
index|[
name|column
operator|-
literal|3
index|]
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
name|ffelex_card_length_
operator|=
name|column
expr_stmt|;
name|ffelex_bad_1_
argument_list|(
name|FFEBAD_LINE_TOO_LONG
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|column
return|;
block|}
name|ffelex_card_image_
operator|=
name|malloc_resize_ksr
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
name|ffelex_card_image_
argument_list|,
name|newmax
operator|+
literal|9
argument_list|,
name|ffelex_card_size_
operator|+
literal|9
argument_list|)
expr_stmt|;
name|ffelex_card_size_
operator|=
name|newmax
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\r'
case|:
break|break;
case|case
literal|'\t'
case|:
name|ffelex_saw_tab_
operator|=
name|TRUE
expr_stmt|;
name|ffelex_card_image_
index|[
name|column
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|(
name|column
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
name|ffelex_card_image_
index|[
name|column
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
if|if
condition|(
operator|!
name|ffelex_bad_line_
condition|)
block|{
name|ffelex_bad_line_
operator|=
name|TRUE
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|ffelex_card_image_
index|[
name|column
index|]
argument_list|,
literal|"[\\0]"
argument_list|)
expr_stmt|;
name|ffelex_card_length_
operator|=
name|column
operator|+
literal|4
expr_stmt|;
name|ffebad_start_msg_lex
argument_list|(
literal|"Null character at %0 -- line ignored"
argument_list|,
name|FFEBAD_severityFATAL
argument_list|)
expr_stmt|;
name|ffelex_bad_here_
argument_list|(
literal|0
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|column
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
default|default:
name|ffelex_card_image_
index|[
name|column
operator|++
index|]
operator|=
name|c
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|column
operator|<
name|old_column
condition|)
block|{
name|column
operator|=
name|old_column
expr_stmt|;
goto|goto
name|overflow
goto|;
comment|/* :::::::::::::::::::: */
block|}
return|return
name|column
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffelex_include_
parameter_list|()
block|{
name|ffewhereFile
name|include_wherefile
init|=
name|ffelex_include_wherefile_
decl_stmt|;
name|FILE
modifier|*
name|include_file
init|=
name|ffelex_include_file_
decl_stmt|;
comment|/* The rest of this is to push, and after the INCLUDE file is processed,      pop, the static lexer state info that pertains to each particular      input file.  */
name|char
modifier|*
name|card_image
decl_stmt|;
name|ffewhereColumnNumber
name|card_size
init|=
name|ffelex_card_size_
decl_stmt|;
name|ffewhereColumnNumber
name|card_length
init|=
name|ffelex_card_length_
decl_stmt|;
name|ffewhereLine
name|current_wl
init|=
name|ffelex_current_wl_
decl_stmt|;
name|ffewhereColumn
name|current_wc
init|=
name|ffelex_current_wc_
decl_stmt|;
name|bool
name|saw_tab
init|=
name|ffelex_saw_tab_
decl_stmt|;
name|ffewhereColumnNumber
name|final_nontab_column
init|=
name|ffelex_final_nontab_column_
decl_stmt|;
name|ffewhereFile
name|current_wf
init|=
name|ffelex_current_wf_
decl_stmt|;
name|ffewhereLineNumber
name|linecount_current
init|=
name|ffelex_linecount_current_
decl_stmt|;
name|ffewhereLineNumber
name|linecount_offset
init|=
name|ffewhere_line_filelinenum
argument_list|(
name|current_wl
argument_list|)
decl_stmt|;
name|int
name|old_lineno
init|=
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
if|if
condition|(
name|card_length
operator|!=
literal|0
condition|)
block|{
name|card_image
operator|=
name|malloc_new_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFELEX saved card image"
argument_list|,
name|card_length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|card_image
argument_list|,
name|ffelex_card_image_
argument_list|,
name|card_length
argument_list|)
expr_stmt|;
block|}
else|else
name|card_image
operator|=
name|NULL
expr_stmt|;
name|ffelex_set_include_
operator|=
name|FALSE
expr_stmt|;
name|ffelex_next_line_
argument_list|()
expr_stmt|;
name|ffewhere_file_set
argument_list|(
name|include_wherefile
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffelex_file_push_
argument_list|(
name|old_lineno
argument_list|,
name|ffewhere_file_name
argument_list|(
name|include_wherefile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_include_free_form_
condition|)
name|ffelex_file_free
argument_list|(
name|include_wherefile
argument_list|,
name|include_file
argument_list|)
expr_stmt|;
else|else
name|ffelex_file_fixed
argument_list|(
name|include_wherefile
argument_list|,
name|include_file
argument_list|)
expr_stmt|;
name|ffelex_file_pop_
argument_list|(
name|ffewhere_file_name
argument_list|(
name|current_wf
argument_list|)
argument_list|)
expr_stmt|;
name|ffewhere_file_set
argument_list|(
name|current_wf
argument_list|,
name|TRUE
argument_list|,
name|linecount_offset
argument_list|)
expr_stmt|;
name|ffecom_close_include
argument_list|(
name|include_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|card_length
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|REDUCE_CARD_SIZE_AFTER_BIGGY
comment|/* Define if occasional large lines. */
error|#
directive|error
literal|"need to handle possible reduction of card size here!!"
endif|#
directive|endif
name|assert
argument_list|(
name|ffelex_card_size_
operator|>=
name|card_length
argument_list|)
expr_stmt|;
comment|/* It shrunk?? */
name|memcpy
argument_list|(
name|ffelex_card_image_
argument_list|,
name|card_image
argument_list|,
name|card_length
argument_list|)
expr_stmt|;
block|}
name|ffelex_card_image_
index|[
name|card_length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
name|lineno
operator|=
name|old_lineno
expr_stmt|;
name|ffelex_linecount_current_
operator|=
name|linecount_current
expr_stmt|;
name|ffelex_current_wf_
operator|=
name|current_wf
expr_stmt|;
name|ffelex_final_nontab_column_
operator|=
name|final_nontab_column
expr_stmt|;
name|ffelex_saw_tab_
operator|=
name|saw_tab
expr_stmt|;
name|ffelex_current_wc_
operator|=
name|current_wc
expr_stmt|;
name|ffelex_current_wl_
operator|=
name|current_wl
expr_stmt|;
name|ffelex_card_length_
operator|=
name|card_length
expr_stmt|;
name|ffelex_card_size_
operator|=
name|card_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffelex_is_free_char_ctx_contin_ -- Character Context Continuation?     ffewhereColumnNumber col;    int c;  // Char at col.    if ((c == '&')&& ffelex_is_free_char_ctx_contin_(col + 1))        // We have a continuation indicator.     If there are<n> spaces starting at ffelex_card_image_[col] up through    the null character, where<n> is 0 or greater, returns TRUE.	 */
end_comment

begin_function
specifier|static
name|bool
name|ffelex_is_free_char_ctx_contin_
parameter_list|(
name|ffewhereColumnNumber
name|col
parameter_list|)
block|{
while|while
condition|(
name|ffelex_card_image_
index|[
name|col
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ffelex_card_image_
index|[
name|col
operator|++
index|]
operator|!=
literal|' '
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ffelex_is_free_nonc_ctx_contin_ -- Noncharacter Context Continuation?     ffewhereColumnNumber col;    int c;  // Char at col.    if ((c == '&')&& ffelex_is_free_nonc_ctx_contin_(col + 1))        // We have a continuation indicator.     If there are<n> spaces starting at ffelex_card_image_[col] up through    the null character or '!', where<n> is 0 or greater, returns TRUE.	*/
end_comment

begin_function
specifier|static
name|bool
name|ffelex_is_free_nonc_ctx_contin_
parameter_list|(
name|ffewhereColumnNumber
name|col
parameter_list|)
block|{
while|while
condition|(
operator|(
name|ffelex_card_image_
index|[
name|col
index|]
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|ffelex_card_image_
index|[
name|col
index|]
operator|!=
literal|'!'
operator|)
condition|)
block|{
if|if
condition|(
name|ffelex_card_image_
index|[
name|col
operator|++
index|]
operator|!=
literal|' '
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffelex_next_line_
parameter_list|()
block|{
name|ffelex_linecount_current_
operator|=
name|ffelex_linecount_next_
expr_stmt|;
operator|++
name|ffelex_linecount_next_
expr_stmt|;
operator|++
name|lineno
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffelex_send_token_
parameter_list|()
block|{
operator|++
name|ffelex_number_of_tokens_
expr_stmt|;
name|ffelex_backslash_
argument_list|(
name|EOF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_
operator|->
name|text
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ffelex_token_
operator|->
name|type
operator|==
name|FFELEX_typeCHARACTER
condition|)
block|{
name|ffelex_append_to_token_
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|ffelex_token_
operator|->
name|text
index|[
name|ffelex_token_
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|assert
argument_list|(
name|ffelex_raw_mode_
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_
operator|->
name|type
operator|==
name|FFELEX_typeNAMES
condition|)
block|{
name|ffewhere_line_kill
argument_list|(
name|ffelex_token_
operator|->
name|currentnames_line
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|ffelex_token_
operator|->
name|currentnames_col
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|ffelex_handler_
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_handler_
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|ffelex_handler_
argument_list|)
argument_list|(
name|ffelex_token_
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffelex_handler_
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffelex_token_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|=
name|ffelex_token_new_
argument_list|()
expr_stmt|;
name|ffelex_token_
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|ffelex_token_
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ffelex_raw_mode_
operator|<
literal|0
condition|)
block|{
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeCHARACTER
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffelex_raw_where_line_
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffelex_raw_where_col_
expr_stmt|;
name|ffelex_raw_where_line_
operator|=
name|ffewhere_line_unknown
argument_list|()
expr_stmt|;
name|ffelex_raw_where_col_
operator|=
name|ffewhere_column_unknown
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeNONE
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_unknown
argument_list|()
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_unknown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ffelex_set_include_
condition|)
name|ffelex_include_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffelex_swallow_tokens_ -- Eat all tokens delivered to me     return ffelex_swallow_tokens_;     Return this handler when you don't want to look at any more tokens in the    statement because you've encountered an unrecoverable error in the    statement.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffelex_swallow_tokens_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|assert
argument_list|(
name|ffelex_eos_handler_
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeEOS
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeSEMICOLON
operator|)
condition|)
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|ffelex_eos_handler_
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexToken
name|ffelex_token_new_
parameter_list|()
block|{
name|ffelexToken
name|t
decl_stmt|;
operator|++
name|ffelex_total_tokens_
expr_stmt|;
name|t
operator|=
operator|(
name|ffelexToken
operator|)
name|malloc_new_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFELEX token"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|id_
operator|=
name|ffelex_token_nextid_
operator|++
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ffelex_type_string_
parameter_list|(
name|ffelexType
name|type
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|types
index|[]
init|=
block|{
literal|"FFELEX_typeNONE"
block|,
literal|"FFELEX_typeCOMMENT"
block|,
literal|"FFELEX_typeEOS"
block|,
literal|"FFELEX_typeEOF"
block|,
literal|"FFELEX_typeERROR"
block|,
literal|"FFELEX_typeRAW"
block|,
literal|"FFELEX_typeQUOTE"
block|,
literal|"FFELEX_typeDOLLAR"
block|,
literal|"FFELEX_typeHASH"
block|,
literal|"FFELEX_typePERCENT"
block|,
literal|"FFELEX_typeAMPERSAND"
block|,
literal|"FFELEX_typeAPOSTROPHE"
block|,
literal|"FFELEX_typeOPEN_PAREN"
block|,
literal|"FFELEX_typeCLOSE_PAREN"
block|,
literal|"FFELEX_typeASTERISK"
block|,
literal|"FFELEX_typePLUS"
block|,
literal|"FFELEX_typeMINUS"
block|,
literal|"FFELEX_typePERIOD"
block|,
literal|"FFELEX_typeSLASH"
block|,
literal|"FFELEX_typeNUMBER"
block|,
literal|"FFELEX_typeOPEN_ANGLE"
block|,
literal|"FFELEX_typeEQUALS"
block|,
literal|"FFELEX_typeCLOSE_ANGLE"
block|,
literal|"FFELEX_typeNAME"
block|,
literal|"FFELEX_typeCOMMA"
block|,
literal|"FFELEX_typePOWER"
block|,
literal|"FFELEX_typeCONCAT"
block|,
literal|"FFELEX_typeDEBUG"
block|,
literal|"FFELEX_typeNAMES"
block|,
literal|"FFELEX_typeHOLLERITH"
block|,
literal|"FFELEX_typeCHARACTER"
block|,
literal|"FFELEX_typeCOLON"
block|,
literal|"FFELEX_typeSEMICOLON"
block|,
literal|"FFELEX_typeUNDERSCORE"
block|,
literal|"FFELEX_typeQUESTION"
block|,
literal|"FFELEX_typeOPEN_ARRAY"
block|,
literal|"FFELEX_typeCLOSE_ARRAY"
block|,
literal|"FFELEX_typeCOLONCOLON"
block|,
literal|"FFELEX_typeREL_LE"
block|,
literal|"FFELEX_typeREL_NE"
block|,
literal|"FFELEX_typeREL_EQ"
block|,
literal|"FFELEX_typePOINTS"
block|,
literal|"FFELEX_typeREL_GE"
block|}
decl_stmt|;
if|if
condition|(
name|type
operator|>=
name|ARRAY_SIZE
argument_list|(
name|types
argument_list|)
condition|)
return|return
literal|"???"
return|;
return|return
name|types
index|[
name|type
index|]
return|;
block|}
end_function

begin_function
name|void
name|ffelex_display_token
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|t
operator|=
name|ffelex_token_
expr_stmt|;
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"; Token #%lu is %s (line %"
name|ffewhereLineNumber_f
literal|"u, col %"
name|ffewhereColumnNumber_f
literal|"u)"
argument_list|,
name|t
operator|->
name|id_
argument_list|,
name|ffelex_type_string_
argument_list|(
name|t
operator|->
name|type
argument_list|)
argument_list|,
name|ffewhere_line_number
argument_list|(
name|t
operator|->
name|where_line
argument_list|)
argument_list|,
name|ffewhere_column_number
argument_list|(
name|t
operator|->
name|where_col
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|text
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|": \"%.*s\"\n"
argument_list|,
operator|(
name|int
operator|)
name|t
operator|->
name|length
argument_list|,
name|t
operator|->
name|text
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffelex_expecting_character -- Tells if next token expected to be CHARACTER     if (ffelex_expecting_character())        // next token delivered by lexer will be CHARACTER.     If the most recent call to ffelex_set_expecting_hollerith since the last    token was delivered by the lexer passed a length of -1, then we return    TRUE, because the next token we deliver will be typeCHARACTER, else we    return FALSE.  */
end_comment

begin_function
name|bool
name|ffelex_expecting_character
parameter_list|()
block|{
return|return
operator|(
name|ffelex_raw_mode_
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ffelex_file_fixed -- Lex a given file in fixed source form     ffewhere wf;    FILE *f;    ffelex_file_fixed(wf,f);     Lexes the file according to Fortran 90 ANSI + VXT specifications.  */
end_comment

begin_function
name|ffelexHandler
name|ffelex_file_fixed
parameter_list|(
name|ffewhereFile
name|wf
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
specifier|register
name|int
name|c
init|=
literal|0
decl_stmt|;
comment|/* Character currently under consideration. */
specifier|register
name|ffewhereColumnNumber
name|column
init|=
literal|0
decl_stmt|;
comment|/* Not really; 0 means column 1... */
name|bool
name|disallow_continuation_line
decl_stmt|;
name|bool
name|ignore_disallowed_continuation
init|=
name|FALSE
decl_stmt|;
name|int
name|latest_char_in_file
init|=
literal|0
decl_stmt|;
comment|/* For getting back into comment-skipping 				   code. */
name|ffelexType
name|lextype
decl_stmt|;
name|ffewhereColumnNumber
name|first_label_char
decl_stmt|;
comment|/* First char of label -- 						   column number. */
name|char
name|label_string
index|[
literal|6
index|]
decl_stmt|;
comment|/* Text of label. */
name|int
name|labi
decl_stmt|;
comment|/* Length of label text. */
name|bool
name|finish_statement
decl_stmt|;
comment|/* Previous statement finished? */
name|bool
name|have_content
decl_stmt|;
comment|/* This line have content? */
name|bool
name|just_do_label
decl_stmt|;
comment|/* Nothing but label (and continuation?) on 				   line. */
comment|/* Lex is called for a particular file, not for a particular program unit.      Yet the two events do share common characteristics.  The first line in a      file or in a program unit cannot be a continuation line.  No token can      be in mid-formation.  No current label for the statement exists, since      there is no current statement. */
name|assert
argument_list|(
name|ffelex_handler_
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|input_filename
operator|=
name|ffewhere_file_name
argument_list|(
name|wf
argument_list|)
expr_stmt|;
name|ffelex_current_wf_
operator|=
name|wf
expr_stmt|;
name|disallow_continuation_line
operator|=
name|TRUE
expr_stmt|;
name|ignore_disallowed_continuation
operator|=
name|FALSE
expr_stmt|;
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeNONE
expr_stmt|;
name|ffelex_number_of_tokens_
operator|=
literal|0
expr_stmt|;
name|ffelex_label_tokens_
operator|=
literal|0
expr_stmt|;
name|ffelex_current_wl_
operator|=
name|ffewhere_line_unknown
argument_list|()
expr_stmt|;
name|ffelex_current_wc_
operator|=
name|ffewhere_column_unknown
argument_list|()
expr_stmt|;
name|latest_char_in_file
operator|=
literal|'\n'
expr_stmt|;
goto|goto
name|first_line
goto|;
comment|/* :::::::::::::::::::: */
comment|/* Come here to get a new line. */
name|beginning_of_line
label|:
comment|/* :::::::::::::::::::: */
name|disallow_continuation_line
operator|=
name|FALSE
expr_stmt|;
comment|/* Come here directly when last line didn't clarify the continuation issue. */
name|beginning_of_line_again
label|:
comment|/* :::::::::::::::::::: */
ifdef|#
directive|ifdef
name|REDUCE_CARD_SIZE_AFTER_BIGGY
comment|/* Define if occasional large lines. */
if|if
condition|(
name|ffelex_card_size_
operator|!=
name|FFELEX_columnINITIAL_SIZE_
condition|)
block|{
name|ffelex_card_image_
operator|=
name|malloc_resize_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
name|ffelex_card_image_
argument_list|,
name|FFELEX_columnINITIAL_SIZE_
operator|+
literal|9
argument_list|,
name|ffelex_card_size_
operator|+
literal|9
argument_list|)
expr_stmt|;
name|ffelex_card_size_
operator|=
name|FFELEX_columnINITIAL_SIZE_
expr_stmt|;
block|}
endif|#
directive|endif
name|first_line
label|:
comment|/* :::::::::::::::::::: */
name|c
operator|=
name|latest_char_in_file
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|EOF
operator|)
operator|||
operator|(
operator|(
name|c
operator|=
name|ffelex_getc_
argument_list|(
name|f
argument_list|)
operator|)
operator|==
name|EOF
operator|)
condition|)
block|{
name|end_of_file
label|:
comment|/* :::::::::::::::::::: */
comment|/* Line ending in EOF instead of \n still counts as a whole line. */
name|ffelex_finish_statement_
argument_list|()
expr_stmt|;
name|ffewhere_line_kill
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|ffelex_current_wc_
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_handler_
return|;
block|}
name|ffelex_next_line_
argument_list|()
expr_stmt|;
name|ffelex_bad_line_
operator|=
name|FALSE
expr_stmt|;
comment|/* Skip over comment (and otherwise ignored) lines as quickly as possible! */
while|while
condition|(
operator|(
operator|(
name|lextype
operator|=
name|ffelex_first_char_
index|[
name|c
index|]
operator|)
operator|==
name|FFELEX_typeCOMMENT
operator|)
operator|||
operator|(
name|lextype
operator|==
name|FFELEX_typeERROR
operator|)
operator|||
operator|(
name|lextype
operator|==
name|FFELEX_typeSLASH
operator|)
operator|||
operator|(
name|lextype
operator|==
name|FFELEX_typeHASH
operator|)
condition|)
block|{
comment|/* Test most frequent type of line first, etc.  */
if|if
condition|(
operator|(
name|lextype
operator|==
name|FFELEX_typeCOMMENT
operator|)
operator|||
operator|(
operator|(
name|lextype
operator|==
name|FFELEX_typeSLASH
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
literal|'*'
operator|)
operator|)
condition|)
comment|/* NOTE SIDE-EFFECT. */
block|{
comment|/* Typical case (straight comment), just ignore rest of line. */
name|comment_line
label|:
comment|/* :::::::::::::::::::: */
while|while
condition|(
operator|(
name|c
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|c
operator|!=
name|EOF
operator|)
condition|)
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lextype
operator|==
name|FFELEX_typeHASH
condition|)
name|c
operator|=
name|ffelex_hash_
argument_list|(
name|f
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lextype
operator|==
name|FFELEX_typeSLASH
condition|)
block|{
comment|/* SIDE-EFFECT ABOVE HAS HAPPENED. */
name|ffelex_card_image_
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|ffelex_card_image_
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|column
operator|=
literal|2
expr_stmt|;
goto|goto
name|bad_first_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
else|else
comment|/* typeERROR or unsupported typeHASH.  */
block|{
comment|/* Bad first character, get line and display 				   it with message. */
name|column
operator|=
name|ffelex_image_char_
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bad_first_character
label|:
comment|/* :::::::::::::::::::: */
name|ffelex_bad_line_
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|c
operator|!=
name|EOF
operator|)
condition|)
name|column
operator|=
name|ffelex_image_char_
argument_list|(
name|c
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|ffelex_card_image_
index|[
name|column
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ffelex_card_length_
operator|=
name|column
expr_stmt|;
name|ffelex_bad_1_
argument_list|(
name|FFEBAD_FIRST_CHAR_INVALID
argument_list|,
name|ffelex_linecount_current_
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Read past last char in line.  */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|ffelex_next_line_
argument_list|()
expr_stmt|;
goto|goto
name|end_of_file
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ffelex_next_line_
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|end_of_file
goto|;
comment|/* :::::::::::::::::::: */
name|ffelex_bad_line_
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* while [c, first char, means comment] */
name|ffelex_saw_tab_
operator|=
operator|(
name|c
operator|==
literal|'&'
operator|)
operator|||
operator|(
name|ffelex_final_nontab_column_
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|lextype
operator|==
name|FFELEX_typeDEBUG
condition|)
name|c
operator|=
literal|' '
expr_stmt|;
comment|/* A 'D' or 'd' in column 1 with the 				   debug-lines option on. */
name|column
operator|=
name|ffelex_image_char_
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read the entire line in as is (with whitespace processing).  */
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|c
operator|!=
name|EOF
operator|)
condition|)
name|column
operator|=
name|ffelex_image_char_
argument_list|(
name|c
argument_list|,
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_bad_line_
condition|)
block|{
name|ffelex_card_image_
index|[
name|column
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ffelex_card_length_
operator|=
name|column
expr_stmt|;
goto|goto
name|comment_line
goto|;
comment|/* :::::::::::::::::::: */
block|}
comment|/* If no tab, cut off line after column 72/132.  */
if|if
condition|(
operator|!
name|ffelex_saw_tab_
operator|&&
operator|(
name|column
operator|>
name|ffelex_final_nontab_column_
operator|)
condition|)
block|{
comment|/* Technically, we should now fill ffelex_card_image_ up thru column 	 72/132 with spaces, since character/hollerith constants must count 	 them in that manner. To save CPU time in several ways (avoid a loop 	 here that would be used only when we actually end a line in 	 character-constant mode; avoid writing memory unnecessarily; avoid a 	 loop later checking spaces when not scanning for character-constant 	 characters), we don't do this, and we do the appropriate thing when 	 we encounter end-of-line while actually processing a character 	 constant. */
name|column
operator|=
name|ffelex_final_nontab_column_
expr_stmt|;
block|}
name|ffelex_card_image_
index|[
name|column
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ffelex_card_length_
operator|=
name|column
expr_stmt|;
comment|/* Save next char in file so we can use register-based c while analyzing      line we just read. */
name|latest_char_in_file
operator|=
name|c
expr_stmt|;
comment|/* Should be either '\n' or EOF. */
name|have_content
operator|=
name|FALSE
expr_stmt|;
comment|/* Handle label, if any. */
name|labi
operator|=
literal|0
expr_stmt|;
name|first_label_char
operator|=
name|FFEWHERE_columnUNKNOWN
expr_stmt|;
for|for
control|(
name|column
operator|=
literal|0
init|;
name|column
operator|<
literal|5
condition|;
operator|++
name|column
control|)
block|{
switch|switch
condition|(
name|c
operator|=
name|ffelex_card_image_
index|[
name|column
index|]
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|'!'
case|:
goto|goto
name|stop_looking
goto|;
comment|/* :::::::::::::::::::: */
case|case
literal|' '
case|:
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|label_string
index|[
name|labi
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|first_label_char
operator|==
name|FFEWHERE_columnUNKNOWN
condition|)
name|first_label_char
operator|=
name|column
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
if|if
condition|(
name|column
operator|!=
literal|0
condition|)
block|{
name|ffelex_bad_1_
argument_list|(
name|FFEBAD_LABEL_FIELD_NOT_NUMERIC
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|beginning_of_line_again
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
name|ffelex_bad_1_
argument_list|(
name|FFEBAD_AMPERSAND
argument_list|,
name|ffelex_linecount_current_
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|finish_statement
operator|=
name|FALSE
expr_stmt|;
name|just_do_label
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|got_a_continuation
goto|;
comment|/* :::::::::::::::::::: */
case|case
literal|'/'
case|:
if|if
condition|(
name|ffelex_card_image_
index|[
name|column
operator|+
literal|1
index|]
operator|==
literal|'*'
condition|)
goto|goto
name|stop_looking
goto|;
comment|/* :::::::::::::::::::: */
comment|/* Fall through. */
default|default:
name|ffelex_bad_1_
argument_list|(
name|FFEBAD_LABEL_FIELD_NOT_NUMERIC
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|beginning_of_line_again
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
name|stop_looking
label|:
comment|/* :::::::::::::::::::: */
name|label_string
index|[
name|labi
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find first nonblank char starting with continuation column. */
if|if
condition|(
name|column
operator|==
literal|5
condition|)
comment|/* In which case we didn't see end of line in 				   label field. */
while|while
condition|(
operator|(
name|c
operator|=
name|ffelex_card_image_
index|[
name|column
index|]
operator|)
operator|==
literal|' '
condition|)
operator|++
name|column
expr_stmt|;
comment|/* Now we're trying to figure out whether this is a continuation line and      whether there's anything else of substance on the line.  The cases are      as follows:       1. If a line has an explicit continuation character (other than the digit      zero), then if it also has a label, the label is ignored and an error      message is printed.  Any remaining text on the line is passed to the      parser tasks, thus even an all-blank line (possibly with an ignored      label) aside from a positive continuation character might have meaning      in the midst of a character or hollerith constant.       2. If a line has no explicit continuation character (that is, it has a      space in column 6 and the first non-space character past column 6 is      not a digit 0-9), then there are two possibilities:       A. A label is present and/or a non-space (and non-comment) character      appears somewhere after column 6.	Terminate processing of the previous      statement, if any, send the new label for the next statement, if any,      and start processing a new statement with this non-blank character, if      any.       B. The line is essentially blank, except for a possible comment character.      Don't terminate processing of the previous statement and don't pass any      characters to the parser tasks, since the line is not flagged as a      continuation line.	 We treat it just like a completely blank line.       3. If a line has a continuation character of zero (0), then we terminate      processing of the previous statement, if any, send the new label for the      next statement, if any, and start processing a new statement, if any      non-blank characters are present.       If, when checking to see if we should terminate the previous statement, it      is found that there is no previous statement but that there is an      outstanding label, substitute CONTINUE as the statement for the label      and display an error message. */
name|finish_statement
operator|=
name|FALSE
expr_stmt|;
name|just_do_label
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'!'
case|:
comment|/* ANSI Fortran 90 says ! in column 6 is 				   continuation. */
comment|/* VXT Fortran says ! anywhere is comment, even column 6. */
if|if
condition|(
name|ffe_is_vxt
argument_list|()
operator|||
operator|(
name|column
operator|!=
literal|5
operator|)
condition|)
goto|goto
name|no_tokens_on_line
goto|;
comment|/* :::::::::::::::::::: */
goto|goto
name|got_a_continuation
goto|;
comment|/* :::::::::::::::::::: */
case|case
literal|'/'
case|:
if|if
condition|(
name|ffelex_card_image_
index|[
name|column
operator|+
literal|1
index|]
operator|!=
literal|'*'
condition|)
goto|goto
name|some_other_character
goto|;
comment|/* :::::::::::::::::::: */
comment|/* Fall through. */
if|if
condition|(
name|column
operator|==
literal|5
condition|)
block|{
comment|/* This seems right to do. But it is close to call, since / * starting 	     in column 6 will thus be interpreted as a continuation line 	     beginning with '*'. */
goto|goto
name|got_a_continuation
goto|;
comment|/* :::::::::::::::::::: */
block|}
comment|/* Fall through. */
case|case
literal|'\0'
case|:
comment|/* End of line.  Therefore may be continued-through line, so handle 	 pending label as possible to-be-continued and drive end-of-statement 	 for any previous statement, else treat as blank line. */
name|no_tokens_on_line
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
operator|&&
operator|(
name|c
operator|==
literal|'/'
operator|)
condition|)
name|ffelex_bad_1_
argument_list|(
name|FFEBAD_NON_ANSI_COMMENT
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_label_char
operator|!=
name|FFEWHERE_columnUNKNOWN
condition|)
block|{
comment|/* Can't be a continued-through line if it 				   has a label. */
name|finish_statement
operator|=
name|TRUE
expr_stmt|;
name|have_content
operator|=
name|TRUE
expr_stmt|;
name|just_do_label
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
goto|goto
name|beginning_of_line_again
goto|;
comment|/* :::::::::::::::::::: */
case|case
literal|'0'
case|:
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
operator|&&
operator|(
name|column
operator|!=
literal|5
operator|)
condition|)
name|ffelex_bad_1_
argument_list|(
name|FFEBAD_NON_ANSI_CONTINUATION_COLUMN
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|finish_statement
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|check_for_content
goto|;
comment|/* :::::::::::::::::::: */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* NOTE: This label can be reached directly from the code 	 that lexes the label field in columns 1-5.  */
name|got_a_continuation
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|first_label_char
operator|!=
name|FFEWHERE_columnUNKNOWN
condition|)
block|{
name|ffelex_bad_2_
argument_list|(
name|FFEBAD_LABEL_ON_CONTINUATION
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|first_label_char
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|first_label_char
operator|=
name|FFEWHERE_columnUNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|disallow_continuation_line
condition|)
block|{
if|if
condition|(
operator|!
name|ignore_disallowed_continuation
condition|)
name|ffelex_bad_1_
argument_list|(
name|FFEBAD_INVALID_CONTINUATION
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|beginning_of_line_again
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
operator|&&
operator|(
name|column
operator|!=
literal|5
operator|)
condition|)
name|ffelex_bad_1_
argument_list|(
name|FFEBAD_NON_ANSI_CONTINUATION_COLUMN
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffelex_raw_mode_
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|c
operator|=
name|ffelex_card_image_
index|[
name|column
operator|+
literal|1
index|]
operator|)
operator|!=
literal|'\0'
operator|)
operator|||
operator|!
name|ffelex_saw_tab_
operator|)
condition|)
block|{
operator|++
name|column
expr_stmt|;
name|have_content
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|check_for_content
label|:
comment|/* :::::::::::::::::::: */
while|while
condition|(
operator|(
name|c
operator|=
name|ffelex_card_image_
index|[
operator|++
name|column
index|]
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'!'
operator|)
operator|||
operator|(
operator|(
name|c
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|ffelex_card_image_
index|[
name|column
operator|+
literal|1
index|]
operator|==
literal|'*'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
operator|&&
operator|(
name|c
operator|==
literal|'/'
operator|)
condition|)
name|ffelex_bad_1_
argument_list|(
name|FFEBAD_NON_ANSI_COMMENT
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|just_do_label
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|have_content
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|some_other_character
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|column
operator|==
literal|5
condition|)
goto|goto
name|got_a_continuation
goto|;
comment|/* :::::::::::::::::::: */
comment|/* Here is the very normal case of a regular character starting in 	 column 7 or beyond with a blank in column 6. */
name|finish_statement
operator|=
name|TRUE
expr_stmt|;
name|have_content
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|have_content
operator|||
operator|(
name|first_label_char
operator|!=
name|FFEWHERE_columnUNKNOWN
operator|)
condition|)
block|{
comment|/* The line has content of some kind, install new end-statement 	 point for error messages.  Note that "content" includes cases 	 where there's little apparent content but enough to finish 	 a statement.  That's because finishing a statement can trigger 	 an impending INCLUDE, and that requires accurate line info being 	 maintained by the lexer.  */
if|if
condition|(
name|finish_statement
condition|)
name|ffelex_prepare_eos_
argument_list|()
expr_stmt|;
comment|/* Prepare EOS before we move current pointer. */
name|ffewhere_line_kill
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|ffelex_current_wc_
argument_list|)
expr_stmt|;
name|ffelex_current_wl_
operator|=
name|ffewhere_line_new
argument_list|(
name|ffelex_linecount_current_
argument_list|)
expr_stmt|;
name|ffelex_current_wc_
operator|=
name|ffewhere_column_new
argument_list|(
name|ffelex_card_length_
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We delay this for a combination of reasons.  Mainly, it can start      INCLUDE processing, and we want to delay that until the lexer's      info on the line is coherent.  And we want to delay that until we're      sure there's a reason to make that info coherent, to avoid saving      lots of useless lines.  */
if|if
condition|(
name|finish_statement
condition|)
name|ffelex_finish_statement_
argument_list|()
expr_stmt|;
comment|/* If label is present, enclose it in a NUMBER token and send it along. */
if|if
condition|(
name|first_label_char
operator|!=
name|FFEWHERE_columnUNKNOWN
condition|)
block|{
name|assert
argument_list|(
name|ffelex_token_
operator|->
name|type
operator|==
name|FFELEX_typeNONE
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeNUMBER
expr_stmt|;
name|ffelex_append_to_token_
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* Make room for label text. */
name|strcpy
argument_list|(
name|ffelex_token_
operator|->
name|text
argument_list|,
name|label_string
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|first_label_char
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|length
operator|=
name|labi
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
operator|++
name|ffelex_label_tokens_
expr_stmt|;
block|}
if|if
condition|(
name|just_do_label
condition|)
goto|goto
name|beginning_of_line
goto|;
comment|/* :::::::::::::::::::: */
comment|/* Here is the main engine for parsing.  c holds the character at column.      It is already known that c is not a blank, end of line, or shriek,      unless ffelex_raw_mode_ is not 0 (indicating we are in a      character/hollerith constant). A partially filled token may already      exist in ffelex_token_.  One special case: if, when the end of the line      is reached, continuation_line is FALSE and the only token on the line is      END, then it is indeed the last statement. We don't look for      continuation lines during this program unit in that case. This is      according to ANSI. */
if|if
condition|(
name|ffelex_raw_mode_
operator|!=
literal|0
condition|)
block|{
name|parse_raw_character
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|ffewhereColumnNumber
name|i
decl_stmt|;
if|if
condition|(
name|ffelex_saw_tab_
operator|||
operator|(
name|column
operator|>=
name|ffelex_final_nontab_column_
operator|)
condition|)
goto|goto
name|beginning_of_line
goto|;
comment|/* :::::::::::::::::::: */
comment|/* Pad out line with "virtual" spaces. */
for|for
control|(
name|i
operator|=
name|column
init|;
name|i
operator|<
name|ffelex_final_nontab_column_
condition|;
operator|++
name|i
control|)
name|ffelex_card_image_
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|ffelex_card_image_
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ffelex_card_length_
operator|=
name|i
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
switch|switch
condition|(
name|ffelex_raw_mode_
condition|)
block|{
case|case
operator|-
literal|3
case|:
name|c
operator|=
name|ffelex_backslash_
argument_list|(
name|c
argument_list|,
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
operator|!
name|ffelex_backslash_reconsider_
condition|)
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|ffelex_raw_mode_
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
if|if
condition|(
name|c
operator|==
name|ffelex_raw_char_
condition|)
block|{
name|ffelex_raw_mode_
operator|=
operator|-
literal|1
expr_stmt|;
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffelex_raw_mode_
operator|=
literal|0
expr_stmt|;
name|ffelex_backslash_reconsider_
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|c
operator|==
name|ffelex_raw_char_
condition|)
name|ffelex_raw_mode_
operator|=
operator|-
literal|2
expr_stmt|;
else|else
block|{
name|c
operator|=
name|ffelex_backslash_
argument_list|(
name|c
argument_list|,
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|ffelex_raw_mode_
operator|=
operator|-
literal|3
expr_stmt|;
break|break;
block|}
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|c
operator|=
name|ffelex_backslash_
argument_list|(
name|c
argument_list|,
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
operator|!
name|ffelex_backslash_reconsider_
condition|)
block|{
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|--
name|ffelex_raw_mode_
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|ffelex_backslash_reconsider_
condition|)
name|ffelex_backslash_reconsider_
operator|=
name|FALSE
expr_stmt|;
else|else
name|c
operator|=
name|ffelex_card_image_
index|[
operator|++
name|column
index|]
expr_stmt|;
if|if
condition|(
name|ffelex_raw_mode_
operator|==
literal|0
condition|)
block|{
name|ffelex_send_token_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|ffelex_raw_mode_
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|ffelex_card_image_
index|[
operator|++
name|column
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'!'
operator|)
operator|||
operator|(
operator|(
name|c
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|ffelex_card_image_
index|[
name|column
operator|+
literal|1
index|]
operator|==
literal|'*'
operator|)
operator|)
condition|)
goto|goto
name|beginning_of_line
goto|;
comment|/* :::::::::::::::::::: */
goto|goto
name|parse_nonraw_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
goto|goto
name|parse_raw_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|parse_nonraw_character
label|:
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_
operator|->
name|type
condition|)
block|{
case|case
name|FFELEX_typeNONE
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\"'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeQUOTE
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeDOLLAR
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typePERCENT
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeAMPERSAND
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeAPOSTROPHE
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeOPEN_PAREN
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeCLOSE_PAREN
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeASTERISK
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typePLUS
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|','
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeCOMMA
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeMINUS
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typePERIOD
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeSLASH
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|ffelex_hexnum_
condition|?
name|FFELEX_typeNAME
else|:
name|FFELEX_typeNUMBER
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeCOLON
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|';'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeSEMICOLON
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_permit_include_
operator|=
name|TRUE
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
name|ffelex_permit_include_
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeOPEN_ANGLE
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeEQUALS
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeCLOSE_ANGLE
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeQUESTION
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
if|if
condition|(
literal|1
operator|||
name|ffe_is_90
argument_list|()
condition|)
block|{
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeUNDERSCORE
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
name|c
operator|=
name|ffesrc_char_source
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesrc_char_match_init
argument_list|(
name|c
argument_list|,
literal|'H'
argument_list|,
literal|'h'
argument_list|)
operator|&&
name|ffelex_expecting_hollerith_
operator|!=
literal|0
condition|)
block|{
name|ffelex_raw_mode_
operator|=
name|ffelex_expecting_hollerith_
expr_stmt|;
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeHOLLERITH
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffelex_raw_where_line_
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffelex_raw_where_col_
expr_stmt|;
name|ffelex_raw_where_line_
operator|=
name|ffewhere_line_unknown
argument_list|()
expr_stmt|;
name|ffelex_raw_where_col_
operator|=
name|ffewhere_column_unknown
argument_list|()
expr_stmt|;
name|c
operator|=
name|ffelex_card_image_
index|[
operator|++
name|column
index|]
expr_stmt|;
goto|goto
name|parse_raw_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffelex_names_
condition|)
block|{
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_token_
operator|->
name|currentnames_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_use
argument_list|(
name|ffelex_token_
operator|->
name|currentnames_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeNAMES
expr_stmt|;
block|}
else|else
block|{
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeNAME
expr_stmt|;
block|}
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ffelex_bad_1_
argument_list|(
name|FFEBAD_UNRECOGNIZED_CHARACTER
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_finish_statement_
argument_list|()
expr_stmt|;
name|disallow_continuation_line
operator|=
name|TRUE
expr_stmt|;
name|ignore_disallowed_continuation
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|beginning_of_line_again
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
name|c
operator|=
name|ffesrc_char_source
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'_'
case|:
case|case
literal|'$'
case|:
if|if
condition|(
operator|(
name|c
operator|==
literal|'$'
operator|)
operator|&&
operator|!
name|ffe_is_dollar_ok
argument_list|()
condition|)
block|{
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeNAMES
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
name|c
operator|=
name|ffesrc_char_source
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'_'
case|:
case|case
literal|'$'
case|:
if|if
condition|(
operator|(
name|c
operator|==
literal|'$'
operator|)
operator|&&
operator|!
name|ffe_is_dollar_ok
argument_list|()
condition|)
block|{
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffelex_token_
operator|->
name|length
operator|<
name|FFEWHERE_indexMAX
condition|)
block|{
name|ffewhere_track
argument_list|(
operator|&
name|ffelex_token_
operator|->
name|currentnames_line
argument_list|,
operator|&
name|ffelex_token_
operator|->
name|currentnames_col
argument_list|,
name|ffelex_token_
operator|->
name|wheretrack
argument_list|,
name|ffelex_token_
operator|->
name|length
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeNUMBER
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeASTERISK
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'*'
case|:
comment|/* ** */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typePOWER
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|/* * not followed by another *. */
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeCOLON
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|':'
case|:
comment|/* :: */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeCOLONCOLON
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|/* : not followed by another :. */
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeSLASH
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'/'
case|:
comment|/* // */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeCONCAT
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|')'
case|:
comment|/* /) */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeCLOSE_ARRAY
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'='
case|:
comment|/* /= */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeREL_NE
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'/'
case|:
comment|/* (/ */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeOPEN_ARRAY
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeOPEN_ANGLE
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
comment|/*<= */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeREL_LE
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeEQUALS
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
comment|/* == */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeREL_EQ
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
comment|/* => */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typePOINTS
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeCLOSE_ANGLE
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
comment|/*>= */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeREL_GE
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"Serious error!!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|ffelex_card_image_
index|[
operator|++
name|column
index|]
expr_stmt|;
name|parse_next_character
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffelex_raw_mode_
operator|!=
literal|0
condition|)
goto|goto
name|parse_raw_character
goto|;
comment|/* :::::::::::::::::::: */
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|ffelex_card_image_
index|[
operator|++
name|column
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'!'
operator|)
operator|||
operator|(
operator|(
name|c
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|ffelex_card_image_
index|[
name|column
operator|+
literal|1
index|]
operator|==
literal|'*'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ffelex_number_of_tokens_
operator|==
name|ffelex_label_tokens_
operator|)
operator|&&
operator|(
name|ffelex_token_
operator|->
name|type
operator|==
name|FFELEX_typeNAMES
operator|)
operator|&&
operator|(
name|ffelex_token_
operator|->
name|length
operator|==
literal|3
operator|)
operator|&&
operator|(
name|ffesrc_strncmp_2c
argument_list|(
name|ffe_case_match
argument_list|()
argument_list|,
name|ffelex_token_
operator|->
name|text
argument_list|,
literal|"END"
argument_list|,
literal|"end"
argument_list|,
literal|"End"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ffelex_finish_statement_
argument_list|()
expr_stmt|;
name|disallow_continuation_line
operator|=
name|TRUE
expr_stmt|;
name|ignore_disallowed_continuation
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|beginning_of_line_again
goto|;
comment|/* :::::::::::::::::::: */
block|}
goto|goto
name|beginning_of_line
goto|;
comment|/* :::::::::::::::::::: */
block|}
goto|goto
name|parse_nonraw_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
end_function

begin_comment
comment|/* ffelex_file_free -- Lex a given file in free source form     ffewhere wf;    FILE *f;    ffelex_file_free(wf,f);     Lexes the file according to Fortran 90 ANSI + VXT specifications.  */
end_comment

begin_function
name|ffelexHandler
name|ffelex_file_free
parameter_list|(
name|ffewhereFile
name|wf
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
specifier|register
name|int
name|c
init|=
literal|0
decl_stmt|;
comment|/* Character currently under consideration. */
specifier|register
name|ffewhereColumnNumber
name|column
init|=
literal|0
decl_stmt|;
comment|/* Not really; 0 means column 1... */
name|bool
name|continuation_line
init|=
name|FALSE
decl_stmt|;
name|ffewhereColumnNumber
name|continuation_column
decl_stmt|;
name|int
name|latest_char_in_file
init|=
literal|0
decl_stmt|;
comment|/* For getting back into comment-skipping 				   code. */
comment|/* Lex is called for a particular file, not for a particular program unit.      Yet the two events do share common characteristics.  The first line in a      file or in a program unit cannot be a continuation line.  No token can      be in mid-formation.  No current label for the statement exists, since      there is no current statement. */
name|assert
argument_list|(
name|ffelex_handler_
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|input_filename
operator|=
name|ffewhere_file_name
argument_list|(
name|wf
argument_list|)
expr_stmt|;
name|ffelex_current_wf_
operator|=
name|wf
expr_stmt|;
name|continuation_line
operator|=
name|FALSE
expr_stmt|;
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeNONE
expr_stmt|;
name|ffelex_number_of_tokens_
operator|=
literal|0
expr_stmt|;
name|ffelex_current_wl_
operator|=
name|ffewhere_line_unknown
argument_list|()
expr_stmt|;
name|ffelex_current_wc_
operator|=
name|ffewhere_column_unknown
argument_list|()
expr_stmt|;
name|latest_char_in_file
operator|=
literal|'\n'
expr_stmt|;
comment|/* Come here to get a new line. */
name|beginning_of_line
label|:
comment|/* :::::::::::::::::::: */
name|c
operator|=
name|latest_char_in_file
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|EOF
operator|)
operator|||
operator|(
operator|(
name|c
operator|=
name|ffelex_getc_
argument_list|(
name|f
argument_list|)
operator|)
operator|==
name|EOF
operator|)
condition|)
block|{
name|end_of_file
label|:
comment|/* :::::::::::::::::::: */
comment|/* Line ending in EOF instead of \n still counts as a whole line. */
name|ffelex_finish_statement_
argument_list|()
expr_stmt|;
name|ffewhere_line_kill
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|ffelex_current_wc_
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_handler_
return|;
block|}
name|ffelex_next_line_
argument_list|()
expr_stmt|;
name|ffelex_bad_line_
operator|=
name|FALSE
expr_stmt|;
comment|/* Skip over initial-comment and empty lines as quickly as possible! */
while|while
condition|(
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'!'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'#'
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
name|c
operator|=
name|ffelex_hash_
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|comment_line
label|:
comment|/* :::::::::::::::::::: */
while|while
condition|(
operator|(
name|c
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|c
operator|!=
name|EOF
operator|)
condition|)
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|ffelex_next_line_
argument_list|()
expr_stmt|;
goto|goto
name|end_of_file
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ffelex_next_line_
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|end_of_file
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ffelex_saw_tab_
operator|=
name|FALSE
expr_stmt|;
name|column
operator|=
name|ffelex_image_char_
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read the entire line in as is (with whitespace processing).  */
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|c
operator|!=
name|EOF
operator|)
condition|)
name|column
operator|=
name|ffelex_image_char_
argument_list|(
name|c
argument_list|,
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_bad_line_
condition|)
block|{
name|ffelex_card_image_
index|[
name|column
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ffelex_card_length_
operator|=
name|column
expr_stmt|;
goto|goto
name|comment_line
goto|;
comment|/* :::::::::::::::::::: */
block|}
comment|/* If no tab, cut off line after column 132.  */
if|if
condition|(
operator|!
name|ffelex_saw_tab_
operator|&&
operator|(
name|column
operator|>
name|FFELEX_FREE_MAX_COLUMNS_
operator|)
condition|)
name|column
operator|=
name|FFELEX_FREE_MAX_COLUMNS_
expr_stmt|;
name|ffelex_card_image_
index|[
name|column
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ffelex_card_length_
operator|=
name|column
expr_stmt|;
comment|/* Save next char in file so we can use register-based c while analyzing      line we just read. */
name|latest_char_in_file
operator|=
name|c
expr_stmt|;
comment|/* Should be either '\n' or EOF. */
name|column
operator|=
literal|0
expr_stmt|;
name|continuation_column
operator|=
literal|0
expr_stmt|;
comment|/* Skip over initial spaces to see if the first nonblank character      is exclamation point, newline, or EOF (line is therefore a comment) or      ampersand (line is therefore a continuation line). */
while|while
condition|(
operator|(
name|c
operator|=
name|ffelex_card_image_
index|[
name|column
index|]
operator|)
operator|==
literal|' '
condition|)
operator|++
name|column
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'!'
case|:
case|case
literal|'\0'
case|:
goto|goto
name|beginning_of_line
goto|;
comment|/* :::::::::::::::::::: */
case|case
literal|'&'
case|:
name|continuation_column
operator|=
name|column
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* The line definitely has content of some kind, install new end-statement      point for error messages. */
name|ffewhere_line_kill
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|ffelex_current_wc_
argument_list|)
expr_stmt|;
name|ffelex_current_wl_
operator|=
name|ffewhere_line_new
argument_list|(
name|ffelex_linecount_current_
argument_list|)
expr_stmt|;
name|ffelex_current_wc_
operator|=
name|ffewhere_column_new
argument_list|(
name|ffelex_card_length_
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Figure out which column to start parsing at. */
if|if
condition|(
name|continuation_line
condition|)
block|{
if|if
condition|(
name|continuation_column
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ffelex_raw_mode_
operator|!=
literal|0
condition|)
block|{
name|ffelex_bad_1_
argument_list|(
name|FFEBAD_BAD_CHAR_CONTINUE
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffelex_token_
operator|->
name|type
operator|!=
name|FFELEX_typeNONE
condition|)
block|{
name|ffelex_bad_1_
argument_list|(
name|FFEBAD_BAD_LEXTOK_CONTINUE
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ffelex_is_free_char_ctx_contin_
argument_list|(
name|continuation_column
argument_list|)
condition|)
block|{
comment|/* Line contains only a single "&" as only 				   nonblank character. */
name|ffelex_bad_1_
argument_list|(
name|FFEBAD_BAD_FREE_CONTINUE
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|continuation_column
argument_list|)
expr_stmt|;
goto|goto
name|beginning_of_line
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|column
operator|=
name|continuation_column
expr_stmt|;
block|}
else|else
name|column
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|ffelex_card_image_
index|[
name|column
index|]
expr_stmt|;
name|continuation_line
operator|=
name|FALSE
expr_stmt|;
comment|/* Here is the main engine for parsing.  c holds the character at column.      It is already known that c is not a blank, end of line, or shriek,      unless ffelex_raw_mode_ is not 0 (indicating we are in a      character/hollerith constant).  A partially filled token may already      exist in ffelex_token_. */
if|if
condition|(
name|ffelex_raw_mode_
operator|!=
literal|0
condition|)
block|{
name|parse_raw_character
label|:
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'&'
case|:
if|if
condition|(
name|ffelex_is_free_char_ctx_contin_
argument_list|(
name|column
operator|+
literal|1
argument_list|)
condition|)
block|{
name|continuation_line
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|beginning_of_line
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
literal|'\0'
case|:
name|ffelex_finish_statement_
argument_list|()
expr_stmt|;
goto|goto
name|beginning_of_line
goto|;
comment|/* :::::::::::::::::::: */
default|default:
break|break;
block|}
switch|switch
condition|(
name|ffelex_raw_mode_
condition|)
block|{
case|case
operator|-
literal|3
case|:
name|c
operator|=
name|ffelex_backslash_
argument_list|(
name|c
argument_list|,
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
operator|!
name|ffelex_backslash_reconsider_
condition|)
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|ffelex_raw_mode_
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
if|if
condition|(
name|c
operator|==
name|ffelex_raw_char_
condition|)
block|{
name|ffelex_raw_mode_
operator|=
operator|-
literal|1
expr_stmt|;
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffelex_raw_mode_
operator|=
literal|0
expr_stmt|;
name|ffelex_backslash_reconsider_
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|c
operator|==
name|ffelex_raw_char_
condition|)
name|ffelex_raw_mode_
operator|=
operator|-
literal|2
expr_stmt|;
else|else
block|{
name|c
operator|=
name|ffelex_backslash_
argument_list|(
name|c
argument_list|,
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|ffelex_raw_mode_
operator|=
operator|-
literal|3
expr_stmt|;
break|break;
block|}
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|c
operator|=
name|ffelex_backslash_
argument_list|(
name|c
argument_list|,
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
operator|!
name|ffelex_backslash_reconsider_
condition|)
block|{
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|--
name|ffelex_raw_mode_
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|ffelex_backslash_reconsider_
condition|)
name|ffelex_backslash_reconsider_
operator|=
name|FALSE
expr_stmt|;
else|else
name|c
operator|=
name|ffelex_card_image_
index|[
operator|++
name|column
index|]
expr_stmt|;
if|if
condition|(
name|ffelex_raw_mode_
operator|==
literal|0
condition|)
block|{
name|ffelex_send_token_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|ffelex_raw_mode_
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|ffelex_card_image_
index|[
operator|++
name|column
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'!'
operator|)
condition|)
block|{
name|ffelex_finish_statement_
argument_list|()
expr_stmt|;
goto|goto
name|beginning_of_line
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
operator|(
name|c
operator|==
literal|'&'
operator|)
operator|&&
name|ffelex_is_free_nonc_ctx_contin_
argument_list|(
name|column
operator|+
literal|1
argument_list|)
condition|)
block|{
name|continuation_line
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|beginning_of_line
goto|;
comment|/* :::::::::::::::::::: */
block|}
goto|goto
name|parse_nonraw_character_noncontin
goto|;
comment|/* :::::::::::::::::::: */
block|}
goto|goto
name|parse_raw_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|parse_nonraw_character
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
operator|(
name|c
operator|==
literal|'&'
operator|)
operator|&&
name|ffelex_is_free_nonc_ctx_contin_
argument_list|(
name|column
operator|+
literal|1
argument_list|)
condition|)
block|{
name|continuation_line
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|beginning_of_line
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|parse_nonraw_character_noncontin
label|:
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffelex_token_
operator|->
name|type
condition|)
block|{
case|case
name|FFELEX_typeNONE
case|:
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
block|{
comment|/* Otherwise 				   finish-statement/continue-statement 				   already checked. */
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|ffelex_card_image_
index|[
operator|++
name|column
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'!'
operator|)
condition|)
block|{
name|ffelex_finish_statement_
argument_list|()
expr_stmt|;
goto|goto
name|beginning_of_line
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
operator|(
name|c
operator|==
literal|'&'
operator|)
operator|&&
name|ffelex_is_free_nonc_ctx_contin_
argument_list|(
name|column
operator|+
literal|1
argument_list|)
condition|)
block|{
name|continuation_line
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|beginning_of_line
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\"'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeQUOTE
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeDOLLAR
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typePERCENT
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeAMPERSAND
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeAPOSTROPHE
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeOPEN_PAREN
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeCLOSE_PAREN
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeASTERISK
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typePLUS
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|','
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeCOMMA
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeMINUS
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typePERIOD
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeSLASH
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|ffelex_hexnum_
condition|?
name|FFELEX_typeNAME
else|:
name|FFELEX_typeNUMBER
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeCOLON
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|';'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeSEMICOLON
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_permit_include_
operator|=
name|TRUE
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
name|ffelex_permit_include_
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeOPEN_ANGLE
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeEQUALS
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeCLOSE_ANGLE
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeQUESTION
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
if|if
condition|(
literal|1
operator|||
name|ffe_is_90
argument_list|()
condition|)
block|{
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeUNDERSCORE
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
name|c
operator|=
name|ffesrc_char_source
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesrc_char_match_init
argument_list|(
name|c
argument_list|,
literal|'H'
argument_list|,
literal|'h'
argument_list|)
operator|&&
name|ffelex_expecting_hollerith_
operator|!=
literal|0
condition|)
block|{
name|ffelex_raw_mode_
operator|=
name|ffelex_expecting_hollerith_
expr_stmt|;
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeHOLLERITH
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffelex_raw_where_line_
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffelex_raw_where_col_
expr_stmt|;
name|ffelex_raw_where_line_
operator|=
name|ffewhere_line_unknown
argument_list|()
expr_stmt|;
name|ffelex_raw_where_col_
operator|=
name|ffewhere_column_unknown
argument_list|()
expr_stmt|;
name|c
operator|=
name|ffelex_card_image_
index|[
operator|++
name|column
index|]
expr_stmt|;
goto|goto
name|parse_raw_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffelex_names_pure_
condition|)
block|{
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_token_
operator|->
name|currentnames_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_use
argument_list|(
name|ffelex_token_
operator|->
name|currentnames_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeNAMES
expr_stmt|;
block|}
else|else
block|{
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_current_wl_
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeNAME
expr_stmt|;
block|}
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ffelex_bad_1_
argument_list|(
name|FFEBAD_UNRECOGNIZED_CHARACTER
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ffelex_finish_statement_
argument_list|()
expr_stmt|;
goto|goto
name|beginning_of_line
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
name|c
operator|=
name|ffesrc_char_source
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'_'
case|:
case|case
literal|'$'
case|:
if|if
condition|(
operator|(
name|c
operator|==
literal|'$'
operator|)
operator|&&
operator|!
name|ffe_is_dollar_ok
argument_list|()
condition|)
block|{
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeNAMES
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
name|c
operator|=
name|ffesrc_char_source
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'_'
case|:
case|case
literal|'$'
case|:
if|if
condition|(
operator|(
name|c
operator|==
literal|'$'
operator|)
operator|&&
operator|!
name|ffe_is_dollar_ok
argument_list|()
condition|)
block|{
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffelex_token_
operator|->
name|length
operator|<
name|FFEWHERE_indexMAX
condition|)
block|{
name|ffewhere_track
argument_list|(
operator|&
name|ffelex_token_
operator|->
name|currentnames_line
argument_list|,
operator|&
name|ffelex_token_
operator|->
name|currentnames_col
argument_list|,
name|ffelex_token_
operator|->
name|wheretrack
argument_list|,
name|ffelex_token_
operator|->
name|length
argument_list|,
name|ffelex_linecount_current_
argument_list|,
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeNUMBER
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|ffelex_append_to_token_
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeASTERISK
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'*'
case|:
comment|/* ** */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typePOWER
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|/* * not followed by another *. */
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeCOLON
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|':'
case|:
comment|/* :: */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeCOLONCOLON
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|/* : not followed by another :. */
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeSLASH
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'/'
case|:
comment|/* // */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeCONCAT
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|')'
case|:
comment|/* /) */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeCLOSE_ARRAY
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'='
case|:
comment|/* /= */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeREL_NE
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'/'
case|:
comment|/* (/ */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeOPEN_ARRAY
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeOPEN_ANGLE
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
comment|/*<= */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeREL_LE
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeEQUALS
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
comment|/* == */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeREL_EQ
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
comment|/* => */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typePOINTS
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
case|case
name|FFELEX_typeCLOSE_ANGLE
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
comment|/*>= */
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeREL_GE
expr_stmt|;
name|ffelex_send_token_
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ffelex_send_token_
argument_list|()
expr_stmt|;
goto|goto
name|parse_next_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"Serious error!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|ffelex_card_image_
index|[
operator|++
name|column
index|]
expr_stmt|;
name|parse_next_character
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffelex_raw_mode_
operator|!=
literal|0
condition|)
goto|goto
name|parse_raw_character
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
operator|(
name|c
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'!'
operator|)
condition|)
block|{
name|ffelex_finish_statement_
argument_list|()
expr_stmt|;
goto|goto
name|beginning_of_line
goto|;
comment|/* :::::::::::::::::::: */
block|}
goto|goto
name|parse_nonraw_character
goto|;
comment|/* :::::::::::::::::::: */
block|}
end_function

begin_comment
comment|/* See the code in com.c that calls this to understand why.  */
end_comment

begin_function
name|void
name|ffelex_hash_kludge
parameter_list|(
name|FILE
modifier|*
name|finput
parameter_list|)
block|{
comment|/* If you change this constant string, you have to change whatever      code might thus be affected by it in terms of having to use      ffelex_getc_() instead of getc() in the lexers and _hash_.  */
specifier|static
specifier|const
name|char
name|match
index|[]
init|=
literal|"# 1 \""
decl_stmt|;
specifier|static
name|int
name|kludge
index|[
name|ARRAY_SIZE
argument_list|(
name|match
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|q
decl_stmt|;
comment|/* Read chars as long as they match the target string.      Copy them into an array that will serve as a record      of what we read (essentially a multi-char ungetc(),      for code that uses ffelex_getc_ instead of getc() elsewhere      in the lexer.  */
for|for
control|(
name|p
operator|=
operator|&
name|match
index|[
literal|0
index|]
operator|,
name|q
operator|=
operator|&
name|kludge
index|[
literal|0
index|]
operator|,
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
init|;
operator|(
name|c
operator|==
operator|*
name|p
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|!=
name|EOF
operator|)
condition|;
operator|++
name|p
operator|,
operator|++
name|q
operator|,
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
control|)
operator|*
name|q
operator|=
name|c
expr_stmt|;
operator|*
name|q
operator|=
name|c
expr_stmt|;
comment|/* Might be EOF, which requires int. */
operator|*
operator|++
name|q
operator|=
literal|0
expr_stmt|;
name|ffelex_kludge_chars_
operator|=
operator|&
name|kludge
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|ffelex_kludge_flag_
operator|=
name|TRUE
expr_stmt|;
operator|++
name|ffelex_kludge_chars_
expr_stmt|;
name|ffelex_hash_
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* Handle it NOW rather than later. */
name|ffelex_kludge_flag_
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ffelex_init_1
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|ffelex_final_nontab_column_
operator|=
name|ffe_fixed_line_length
argument_list|()
expr_stmt|;
name|ffelex_card_size_
operator|=
name|FFELEX_columnINITIAL_SIZE_
expr_stmt|;
name|ffelex_card_image_
operator|=
name|malloc_new_ksr
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFELEX card image"
argument_list|,
name|FFELEX_columnINITIAL_SIZE_
operator|+
literal|9
argument_list|)
expr_stmt|;
name|ffelex_card_image_
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|ffelex_first_char_
index|[
name|i
index|]
operator|=
name|FFELEX_typeERROR
expr_stmt|;
name|ffelex_first_char_
index|[
literal|'\t'
index|]
operator|=
name|FFELEX_typeRAW
expr_stmt|;
name|ffelex_first_char_
index|[
literal|'\n'
index|]
operator|=
name|FFELEX_typeCOMMENT
expr_stmt|;
name|ffelex_first_char_
index|[
literal|'\v'
index|]
operator|=
name|FFELEX_typeCOMMENT
expr_stmt|;
name|ffelex_first_char_
index|[
literal|'\f'
index|]
operator|=
name|FFELEX_typeCOMMENT
expr_stmt|;
name|ffelex_first_char_
index|[
literal|'\r'
index|]
operator|=
name|FFELEX_typeRAW
expr_stmt|;
name|ffelex_first_char_
index|[
literal|' '
index|]
operator|=
name|FFELEX_typeRAW
expr_stmt|;
name|ffelex_first_char_
index|[
literal|'!'
index|]
operator|=
name|FFELEX_typeCOMMENT
expr_stmt|;
name|ffelex_first_char_
index|[
literal|'*'
index|]
operator|=
name|FFELEX_typeCOMMENT
expr_stmt|;
name|ffelex_first_char_
index|[
literal|'/'
index|]
operator|=
name|FFELEX_typeSLASH
expr_stmt|;
name|ffelex_first_char_
index|[
literal|'&'
index|]
operator|=
name|FFELEX_typeRAW
expr_stmt|;
name|ffelex_first_char_
index|[
literal|'#'
index|]
operator|=
name|FFELEX_typeHASH
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|i
operator|<=
literal|'9'
condition|;
operator|++
name|i
control|)
name|ffelex_first_char_
index|[
name|i
index|]
operator|=
name|FFELEX_typeRAW
expr_stmt|;
if|if
condition|(
operator|(
name|ffe_case_match
argument_list|()
operator|==
name|FFE_caseNONE
operator|)
operator|||
operator|(
operator|(
name|ffe_case_match
argument_list|()
operator|==
name|FFE_caseUPPER
operator|)
operator|&&
operator|(
name|ffe_case_source
argument_list|()
operator|!=
name|FFE_caseLOWER
operator|)
operator|)
comment|/* Idiot!  :-) */
operator|||
operator|(
operator|(
name|ffe_case_match
argument_list|()
operator|==
name|FFE_caseLOWER
operator|)
operator|&&
operator|(
name|ffe_case_source
argument_list|()
operator|==
name|FFE_caseLOWER
operator|)
operator|)
condition|)
block|{
name|ffelex_first_char_
index|[
literal|'C'
index|]
operator|=
name|FFELEX_typeCOMMENT
expr_stmt|;
name|ffelex_first_char_
index|[
literal|'D'
index|]
operator|=
name|FFELEX_typeCOMMENT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ffe_case_match
argument_list|()
operator|==
name|FFE_caseNONE
operator|)
operator|||
operator|(
operator|(
name|ffe_case_match
argument_list|()
operator|==
name|FFE_caseLOWER
operator|)
operator|&&
operator|(
name|ffe_case_source
argument_list|()
operator|!=
name|FFE_caseUPPER
operator|)
operator|)
comment|/* Idiot!  :-) */
operator|||
operator|(
operator|(
name|ffe_case_match
argument_list|()
operator|==
name|FFE_caseUPPER
operator|)
operator|&&
operator|(
name|ffe_case_source
argument_list|()
operator|==
name|FFE_caseUPPER
operator|)
operator|)
condition|)
block|{
name|ffelex_first_char_
index|[
literal|'c'
index|]
operator|=
name|FFELEX_typeCOMMENT
expr_stmt|;
name|ffelex_first_char_
index|[
literal|'d'
index|]
operator|=
name|FFELEX_typeCOMMENT
expr_stmt|;
block|}
name|ffelex_linecount_current_
operator|=
literal|0
expr_stmt|;
name|ffelex_linecount_next_
operator|=
literal|1
expr_stmt|;
name|ffelex_raw_mode_
operator|=
literal|0
expr_stmt|;
name|ffelex_set_include_
operator|=
name|FALSE
expr_stmt|;
name|ffelex_permit_include_
operator|=
name|FALSE
expr_stmt|;
name|ffelex_names_
operator|=
name|TRUE
expr_stmt|;
comment|/* First token in program is a names. */
name|ffelex_names_pure_
operator|=
name|FALSE
expr_stmt|;
comment|/* Free-form lexer does NAMES only for 				   FORMAT. */
name|ffelex_hexnum_
operator|=
name|FALSE
expr_stmt|;
name|ffelex_expecting_hollerith_
operator|=
literal|0
expr_stmt|;
name|ffelex_raw_where_line_
operator|=
name|ffewhere_line_unknown
argument_list|()
expr_stmt|;
name|ffelex_raw_where_col_
operator|=
name|ffewhere_column_unknown
argument_list|()
expr_stmt|;
name|ffelex_token_
operator|=
name|ffelex_token_new_
argument_list|()
expr_stmt|;
name|ffelex_token_
operator|->
name|type
operator|=
name|FFELEX_typeNONE
expr_stmt|;
name|ffelex_token_
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|ffelex_token_
operator|->
name|where_line
operator|=
name|ffewhere_line_unknown
argument_list|()
expr_stmt|;
name|ffelex_token_
operator|->
name|where_col
operator|=
name|ffewhere_column_unknown
argument_list|()
expr_stmt|;
name|ffelex_token_
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
name|ffelex_handler_
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffelex_is_names_expected -- Is the current parser expecting NAMES vs. NAME?     if (ffelex_is_names_expected())        // Deliver NAMES token      else        // Deliver NAME token     Must be called while lexer is active, obviously.  */
end_comment

begin_function
name|bool
name|ffelex_is_names_expected
parameter_list|()
block|{
return|return
name|ffelex_names_
return|;
block|}
end_function

begin_comment
comment|/* Current card image, which has the master linecount number    ffelex_linecount_current_.  */
end_comment

begin_function
name|char
modifier|*
name|ffelex_line
parameter_list|()
block|{
return|return
name|ffelex_card_image_
return|;
block|}
end_function

begin_comment
comment|/* ffelex_line_length -- Return length of current lexer line     printf("Length is %lu\n",ffelex_line_length());     Must be called while lexer is active, obviously.  */
end_comment

begin_function
name|ffewhereColumnNumber
name|ffelex_line_length
parameter_list|()
block|{
return|return
name|ffelex_card_length_
return|;
block|}
end_function

begin_comment
comment|/* Master line count of current card image, or 0 if no card image    is current.  */
end_comment

begin_function
name|ffewhereLineNumber
name|ffelex_line_number
parameter_list|()
block|{
return|return
name|ffelex_linecount_current_
return|;
block|}
end_function

begin_comment
comment|/* ffelex_set_expecting_hollerith -- Set hollerith expectation status     ffelex_set_expecting_hollerith(0);     Lex initially assumes no hollerith constant is about to show up.  If    syntactic analysis expects one, it should call this function with the    number of characters expected in the constant immediately after recognizing    the decimal number preceding the "H" and the constant itself.  Then, if    the next character is indeed H, the lexer will interpret it as beginning    a hollerith constant and ship the token formed by reading the specified    number of characters (interpreting blanks and otherwise-comments too)    from the input file.	 It is up to syntactic analysis to call this routine    again with 0 to turn hollerith detection off immediately upon receiving    the token that might or might not be HOLLERITH.     Also call this after seeing an APOSTROPHE or QUOTE token that begins a    character constant.	Pass the expected termination character (apostrophe    or quote).     Pass for length either the length of the hollerith (must be> 0), -1    meaning expecting a character constant, or 0 to cancel expectation of    a hollerith only after calling it with a length of> 0 and receiving the    next token (which may or may not have been a HOLLERITH token).     Pass for which either an apostrophe or quote when passing length of -1.    Else which is a don't-care.     Pass for line and column the line/column info for the token beginning the    character or hollerith constant, for use in error messages, when passing    a length of -1 -- this function will invoke ffewhere_line/column_use to    make its own copies.	 Else line and column are don't-cares (when length    is 0) and the outstanding copies of the previous line/column info, if    still around, are killed.     21-Feb-90  JCB  3.1       When called with length of 0, also zero ffelex_raw_mode_.	 This is       so ffest_save_ can undo the effects of replaying tokens like       APOSTROPHE and QUOTE.    25-Jan-90  JCB  3.0       New line, column arguments allow error messages to point to the true       beginning of a character/hollerith constant, rather than the beginning       of the content part, which makes them more consistent and helpful.    05-Nov-89  JCB  2.0       New "which" argument allows caller to specify termination character,       which should be apostrophe or double-quote, to support Fortran 90.  */
end_comment

begin_function
name|void
name|ffelex_set_expecting_hollerith
parameter_list|(
name|long
name|length
parameter_list|,
name|char
name|which
parameter_list|,
name|ffewhereLine
name|line
parameter_list|,
name|ffewhereColumn
name|column
parameter_list|)
block|{
comment|/* First kill the pending line/col info, if any (should only be pending      when this call has length==0, the previous call had length>0, and a      non-HOLLERITH token was sent in between the calls, but play it safe). */
name|ffewhere_line_kill
argument_list|(
name|ffelex_raw_where_line_
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|ffelex_raw_where_col_
argument_list|)
expr_stmt|;
comment|/* Now handle the length function. */
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|0
case|:
name|ffelex_expecting_hollerith_
operator|=
literal|0
expr_stmt|;
name|ffelex_raw_mode_
operator|=
literal|0
expr_stmt|;
name|ffelex_raw_where_line_
operator|=
name|ffewhere_line_unknown
argument_list|()
expr_stmt|;
name|ffelex_raw_where_col_
operator|=
name|ffewhere_column_unknown
argument_list|()
expr_stmt|;
return|return;
comment|/* Don't set new line/column info from args. */
case|case
operator|-
literal|1
case|:
name|ffelex_raw_mode_
operator|=
operator|-
literal|1
expr_stmt|;
name|ffelex_raw_char_
operator|=
name|which
expr_stmt|;
break|break;
default|default:
comment|/* length> 0 */
name|ffelex_expecting_hollerith_
operator|=
name|length
expr_stmt|;
break|break;
block|}
comment|/* Now set new line/column information from passed args. */
name|ffelex_raw_where_line_
operator|=
name|ffewhere_line_use
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|ffelex_raw_where_col_
operator|=
name|ffewhere_column_use
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffelex_set_handler -- Set handler for tokens before calling _fixed or _free     ffelex_set_handler((ffelexHandler) my_first_handler);     Must be called before calling ffelex_file_fixed or ffelex_file_free or    after they return, but not while they are active.  */
end_comment

begin_function
name|void
name|ffelex_set_handler
parameter_list|(
name|ffelexHandler
name|first
parameter_list|)
block|{
name|ffelex_handler_
operator|=
name|first
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffelex_set_hexnum -- Set hexnum flag     ffelex_set_hexnum(TRUE);     Lex normally interprets a token starting with [0-9] as a NUMBER token,    so if it sees a [A-Za-z] in it, it stops parsing the NUMBER and leaves    the character as the first of the next token.  But when parsing a    hexadecimal number, by calling this function with TRUE before starting    the parse of the token itself, lex will interpret [0-9] as the start    of a NAME token.  */
end_comment

begin_function
name|void
name|ffelex_set_hexnum
parameter_list|(
name|bool
name|f
parameter_list|)
block|{
name|ffelex_hexnum_
operator|=
name|f
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffelex_set_include -- Set INCLUDE file to be processed next     ffewhereFile wf;  // The ffewhereFile object for the file.    bool free_form;  // TRUE means read free-form file, FALSE fixed-form.    FILE *fi;  // The file to INCLUDE.    ffelex_set_include(wf,free_form,fi);     Must be called only after receiving the EOS token following a valid    INCLUDE statement specifying a file that has already been successfully    opened.  */
end_comment

begin_function
name|void
name|ffelex_set_include
parameter_list|(
name|ffewhereFile
name|wf
parameter_list|,
name|bool
name|free_form
parameter_list|,
name|FILE
modifier|*
name|fi
parameter_list|)
block|{
name|assert
argument_list|(
name|ffelex_permit_include_
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|ffelex_set_include_
argument_list|)
expr_stmt|;
name|ffelex_set_include_
operator|=
name|TRUE
expr_stmt|;
name|ffelex_include_free_form_
operator|=
name|free_form
expr_stmt|;
name|ffelex_include_file_
operator|=
name|fi
expr_stmt|;
name|ffelex_include_wherefile_
operator|=
name|wf
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffelex_set_names -- Set names/name flag, names = TRUE     ffelex_set_names(FALSE);     Lex initially assumes multiple names should be formed.  If this function is    called with FALSE, then single names are formed instead.  The differences    are a difference in the token type (FFELEX_typeNAMES vs. FFELEX_typeNAME)    and in whether full source-location tracking is performed (it is for    multiple names, not for single names), which is more expensive in terms of    CPU time.  */
end_comment

begin_function
name|void
name|ffelex_set_names
parameter_list|(
name|bool
name|f
parameter_list|)
block|{
name|ffelex_names_
operator|=
name|f
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|ffelex_names_pure_
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffelex_set_names_pure -- Set names/name (pure) flag, names = TRUE     ffelex_set_names_pure(FALSE);     Like ffelex_set_names, except affects both lexers.  Normally, the    free-form lexer need not generate NAMES tokens because adjacent NAME    tokens must be separated by spaces which causes the lexer to generate    separate tokens for analysis (whereas in fixed-form the spaces are    ignored resulting in one long token).  But in FORMAT statements, for    some reason, the Fortran 90 standard specifies that spaces can occur    anywhere within a format-item-list with no effect on the format spec    (except of course within character string edit descriptors), which means    that "1PE14.2" and "1 P E 1 4 . 2" are equivalent.  For the FORMAT    statement handling, the existence of spaces makes it hard to deal with,    because each token is seen distinctly (i.e. seven tokens in the latter    example).  But when no spaces are provided, as in the former example,    then only four tokens are generated, NUMBER("1"), NAME("PE14"), PERIOD,    NUMBER ("2").  By generating a NAMES instead of NAME, three things happen:    One, ffest_kw_format_ does a substring rather than full-string match,    and thus matches "PE14" to "PE"; two, ffelex_token_xyz_from_names functions    may be used to pull NAME/NAMES and NUMBER tokens out of the NAMES token;    and three, error reporting can point to the actual character rather than    at or prior to it.  The first two things could be resolved by providing    alternate functions fairly easy, thus allowing FORMAT handling to expect    both lexers to generate NAME tokens instead of NAMES (with otherwise minor    changes to FORMAT parsing), but the third, error reporting, would suffer,    and when one makes mistakes in a FORMAT, believe me, one wants a pointer    to exactly where the compilers thinks the problem is, to even begin to get    a handle on it.  So there.  */
end_comment

begin_function
name|void
name|ffelex_set_names_pure
parameter_list|(
name|bool
name|f
parameter_list|)
block|{
name|ffelex_names_pure_
operator|=
name|f
expr_stmt|;
name|ffelex_names_
operator|=
name|f
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffelex_splice_tokens -- Splice off and send tokens from a NAMES     return (ffelexHandler) ffelex_splice_tokens(first_handler,master_token, 	 start_char_index);     Returns first_handler if start_char_index chars into master_token (which    must be a NAMES token) is '\0'. Else, creates a subtoken from that    char, either NUMBER (if it is a digit), a NAME (if a valid firstnamechar),    an UNDERSCORE (if an underscore), or DOLLAR (if a dollar sign)    and sends it to first_handler. If anything other than NAME is sent, the    character at the end of it in the master token is examined to see if it    begins a NAME, NUMBER, UNDERSCORE, or DOLLAR, and, if so,    the handler returned by first_handler is invoked with that token, and    this process is repeated until the end of the master token or a NAME    token is reached.  */
end_comment

begin_function
name|ffelexHandler
name|ffelex_splice_tokens
parameter_list|(
name|ffelexHandler
name|first
parameter_list|,
name|ffelexToken
name|master
parameter_list|,
name|ffeTokenLength
name|start
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|ffeTokenLength
name|i
decl_stmt|;
name|ffelexToken
name|t
decl_stmt|;
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|master
argument_list|)
operator|+
operator|(
name|i
operator|=
name|start
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|t
operator|=
name|ffelex_token_number_from_names
argument_list|(
name|master
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|i
operator|+=
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffesrc_is_name_init
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|t
operator|=
name|ffelex_token_name_from_names
argument_list|(
name|master
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|i
operator|+=
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|t
operator|=
name|ffelex_token_dollar_from_names
argument_list|(
name|master
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
condition|)
block|{
name|t
operator|=
name|ffelex_token_uscore_from_names
argument_list|(
name|master
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
literal|"not a valid NAMES character"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|NULL
expr_stmt|;
block|}
name|assert
argument_list|(
name|first
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|first
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|first
argument_list|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* ffelex_swallow_tokens -- Eat all tokens delivered to me     return ffelex_swallow_tokens;     Return this handler when you don't want to look at any more tokens in the    statement because you've encountered an unrecoverable error in the    statement.  */
end_comment

begin_function
name|ffelexHandler
name|ffelex_swallow_tokens
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|ffelexHandler
name|handler
parameter_list|)
block|{
name|assert
argument_list|(
name|handler
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeEOS
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeSEMICOLON
operator|)
operator|)
condition|)
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|handler
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
name|ffelex_eos_handler_
operator|=
name|handler
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffelex_swallow_tokens_
return|;
block|}
end_function

begin_comment
comment|/* ffelex_token_dollar_from_names -- Return a dollar from within a names token     ffelexToken t;    t = ffelex_token_dollar_from_names(t,6);     It's as if you made a new token of dollar type having the dollar    at, in the example above, the sixth character of the NAMES token.  */
end_comment

begin_function
name|ffelexToken
name|ffelex_token_dollar_from_names
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|ffeTokenLength
name|start
parameter_list|)
block|{
name|ffelexToken
name|nt
decl_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAMES
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|start
operator|<
name|t
operator|->
name|length
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|t
operator|->
name|text
index|[
name|start
index|]
operator|==
literal|'$'
argument_list|)
expr_stmt|;
comment|/* Now make the token. */
name|nt
operator|=
name|ffelex_token_new_
argument_list|()
expr_stmt|;
name|nt
operator|->
name|type
operator|=
name|FFELEX_typeDOLLAR
expr_stmt|;
name|nt
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|nt
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|ffewhere_set_from_track
argument_list|(
operator|&
name|nt
operator|->
name|where_line
argument_list|,
operator|&
name|nt
operator|->
name|where_col
argument_list|,
name|t
operator|->
name|where_line
argument_list|,
name|t
operator|->
name|where_col
argument_list|,
name|t
operator|->
name|wheretrack
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|nt
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
return|return
name|nt
return|;
block|}
end_function

begin_comment
comment|/* ffelex_token_kill -- Decrement use count for token, kill if no uses left     ffelexToken t;    ffelex_token_kill(t);     Complements a call to ffelex_token_use or ffelex_token_new_....  */
end_comment

begin_function
name|void
name|ffelex_token_kill
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|t
operator|->
name|uses
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|t
operator|->
name|uses
operator|!=
literal|0
condition|)
return|return;
operator|--
name|ffelex_total_tokens_
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|FFELEX_typeNAMES
condition|)
name|ffewhere_track_kill
argument_list|(
name|t
operator|->
name|where_line
argument_list|,
name|t
operator|->
name|where_col
argument_list|,
name|t
operator|->
name|wheretrack
argument_list|,
name|t
operator|->
name|length
argument_list|)
expr_stmt|;
name|ffewhere_line_kill
argument_list|(
name|t
operator|->
name|where_line
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|t
operator|->
name|where_col
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|text
operator|!=
name|NULL
condition|)
name|malloc_kill_ksr
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
name|t
operator|->
name|text
argument_list|,
name|t
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
name|t
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a new NAME token that is a substring of a NAMES token.  */
end_comment

begin_function
name|ffelexToken
name|ffelex_token_name_from_names
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|ffeTokenLength
name|start
parameter_list|,
name|ffeTokenLength
name|len
parameter_list|)
block|{
name|ffelexToken
name|nt
decl_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAMES
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|start
operator|<
name|t
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|t
operator|->
name|length
operator|-
name|start
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|len
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|start
operator|+
name|len
operator|)
operator|<=
name|t
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|ffelex_is_firstnamechar
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|t
operator|->
name|text
index|[
name|start
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nt
operator|=
name|ffelex_token_new_
argument_list|()
expr_stmt|;
name|nt
operator|->
name|type
operator|=
name|FFELEX_typeNAME
expr_stmt|;
name|nt
operator|->
name|size
operator|=
name|len
expr_stmt|;
comment|/* Assume nobody's gonna fiddle with token 				   text. */
name|nt
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|nt
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|ffewhere_set_from_track
argument_list|(
operator|&
name|nt
operator|->
name|where_line
argument_list|,
operator|&
name|nt
operator|->
name|where_col
argument_list|,
name|t
operator|->
name|where_line
argument_list|,
name|t
operator|->
name|where_col
argument_list|,
name|t
operator|->
name|wheretrack
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|nt
operator|->
name|text
operator|=
name|malloc_new_ksr
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFELEX token text"
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|nt
operator|->
name|text
argument_list|,
name|t
operator|->
name|text
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nt
operator|->
name|text
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|nt
return|;
block|}
end_function

begin_comment
comment|/* Make a new NAMES token that is a substring of another NAMES token.  */
end_comment

begin_function
name|ffelexToken
name|ffelex_token_names_from_names
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|ffeTokenLength
name|start
parameter_list|,
name|ffeTokenLength
name|len
parameter_list|)
block|{
name|ffelexToken
name|nt
decl_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAMES
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|start
operator|<
name|t
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|t
operator|->
name|length
operator|-
name|start
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|len
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|start
operator|+
name|len
operator|)
operator|<=
name|t
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|ffelex_is_firstnamechar
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|t
operator|->
name|text
index|[
name|start
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nt
operator|=
name|ffelex_token_new_
argument_list|()
expr_stmt|;
name|nt
operator|->
name|type
operator|=
name|FFELEX_typeNAMES
expr_stmt|;
name|nt
operator|->
name|size
operator|=
name|len
expr_stmt|;
comment|/* Assume nobody's gonna fiddle with token 				   text. */
name|nt
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|nt
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|ffewhere_set_from_track
argument_list|(
operator|&
name|nt
operator|->
name|where_line
argument_list|,
operator|&
name|nt
operator|->
name|where_col
argument_list|,
name|t
operator|->
name|where_line
argument_list|,
name|t
operator|->
name|where_col
argument_list|,
name|t
operator|->
name|wheretrack
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|ffewhere_track_copy
argument_list|(
name|nt
operator|->
name|wheretrack
argument_list|,
name|t
operator|->
name|wheretrack
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nt
operator|->
name|text
operator|=
name|malloc_new_ksr
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFELEX token text"
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|nt
operator|->
name|text
argument_list|,
name|t
operator|->
name|text
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nt
operator|->
name|text
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|nt
return|;
block|}
end_function

begin_comment
comment|/* Make a new CHARACTER token.  */
end_comment

begin_function
name|ffelexToken
name|ffelex_token_new_character
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|ffewhereLine
name|l
parameter_list|,
name|ffewhereColumn
name|c
parameter_list|)
block|{
name|ffelexToken
name|t
decl_stmt|;
name|t
operator|=
name|ffelex_token_new_
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|FFELEX_typeCHARACTER
expr_stmt|;
name|t
operator|->
name|length
operator|=
name|t
operator|->
name|size
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Assume it won't get bigger. */
name|t
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|text
operator|=
name|malloc_new_ksr
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFELEX token text"
argument_list|,
name|t
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t
operator|->
name|text
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|t
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|t
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a new EOF token right after end of file.  */
end_comment

begin_function
name|ffelexToken
name|ffelex_token_new_eof
parameter_list|()
block|{
name|ffelexToken
name|t
decl_stmt|;
name|t
operator|=
name|ffelex_token_new_
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|FFELEX_typeEOF
expr_stmt|;
name|t
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|where_line
operator|=
name|ffewhere_line_new
argument_list|(
name|ffelex_linecount_current_
argument_list|)
expr_stmt|;
name|t
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a new NAME token.  */
end_comment

begin_function
name|ffelexToken
name|ffelex_token_new_name
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|ffewhereLine
name|l
parameter_list|,
name|ffewhereColumn
name|c
parameter_list|)
block|{
name|ffelexToken
name|t
decl_stmt|;
name|assert
argument_list|(
name|ffelex_is_firstnamechar
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffelex_token_new_
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|FFELEX_typeNAME
expr_stmt|;
name|t
operator|->
name|length
operator|=
name|t
operator|->
name|size
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Assume it won't get bigger. */
name|t
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|text
operator|=
name|malloc_new_ksr
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFELEX token text"
argument_list|,
name|t
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t
operator|->
name|text
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|t
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|t
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a new NAMES token.  */
end_comment

begin_function
name|ffelexToken
name|ffelex_token_new_names
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|ffewhereLine
name|l
parameter_list|,
name|ffewhereColumn
name|c
parameter_list|)
block|{
name|ffelexToken
name|t
decl_stmt|;
name|assert
argument_list|(
name|ffelex_is_firstnamechar
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|ffelex_token_new_
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|FFELEX_typeNAMES
expr_stmt|;
name|t
operator|->
name|length
operator|=
name|t
operator|->
name|size
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Assume it won't get bigger. */
name|t
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|text
operator|=
name|malloc_new_ksr
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFELEX token text"
argument_list|,
name|t
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t
operator|->
name|text
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|t
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|t
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|ffewhere_track_clear
argument_list|(
name|t
operator|->
name|wheretrack
argument_list|,
name|t
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* Assume contiguous 							   names. */
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a new NUMBER token.     The first character of the string must be a digit, and only the digits    are copied into the new number.  So this may be used to easily extract    a NUMBER token from within any text string.  Then the length of the    resulting token may be used to calculate where the digits stopped    in the original string.  */
end_comment

begin_function
name|ffelexToken
name|ffelex_token_new_number
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|ffewhereLine
name|l
parameter_list|,
name|ffewhereColumn
name|c
parameter_list|)
block|{
name|ffelexToken
name|t
decl_stmt|;
name|ffeTokenLength
name|len
decl_stmt|;
comment|/* How long is the string of decimal digits at s? */
name|len
operator|=
name|strspn
argument_list|(
name|s
argument_list|,
literal|"0123456789"
argument_list|)
expr_stmt|;
comment|/* Make sure there is at least one digit. */
name|assert
argument_list|(
name|len
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Now make the token. */
name|t
operator|=
name|ffelex_token_new_
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|FFELEX_typeNUMBER
expr_stmt|;
name|t
operator|->
name|length
operator|=
name|t
operator|->
name|size
operator|=
name|len
expr_stmt|;
comment|/* Assume it won't get bigger. */
name|t
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|text
operator|=
name|malloc_new_ksr
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFELEX token text"
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|t
operator|->
name|text
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|t
operator|->
name|text
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|t
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|t
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a new token of any type that doesn't contain text.  A private    function that is used by public macros in the interface file.  */
end_comment

begin_function
name|ffelexToken
name|ffelex_token_new_simple_
parameter_list|(
name|ffelexType
name|type
parameter_list|,
name|ffewhereLine
name|l
parameter_list|,
name|ffewhereColumn
name|c
parameter_list|)
block|{
name|ffelexToken
name|t
decl_stmt|;
name|t
operator|=
name|ffelex_token_new_
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|t
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|where_line
operator|=
name|ffewhere_line_use
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|t
operator|->
name|where_col
operator|=
name|ffewhere_column_new
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a new NUMBER token from an existing NAMES token.     Like ffelex_token_new_number, this function calculates the length    of the digit string itself.  */
end_comment

begin_function
name|ffelexToken
name|ffelex_token_number_from_names
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|ffeTokenLength
name|start
parameter_list|)
block|{
name|ffelexToken
name|nt
decl_stmt|;
name|ffeTokenLength
name|len
decl_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAMES
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|start
operator|<
name|t
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* How long is the string of decimal digits at s? */
name|len
operator|=
name|strspn
argument_list|(
name|t
operator|->
name|text
operator|+
name|start
argument_list|,
literal|"0123456789"
argument_list|)
expr_stmt|;
comment|/* Make sure there is at least one digit. */
name|assert
argument_list|(
name|len
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Now make the token. */
name|nt
operator|=
name|ffelex_token_new_
argument_list|()
expr_stmt|;
name|nt
operator|->
name|type
operator|=
name|FFELEX_typeNUMBER
expr_stmt|;
name|nt
operator|->
name|size
operator|=
name|len
expr_stmt|;
comment|/* Assume nobody's gonna fiddle with token 				   text. */
name|nt
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|nt
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|ffewhere_set_from_track
argument_list|(
operator|&
name|nt
operator|->
name|where_line
argument_list|,
operator|&
name|nt
operator|->
name|where_col
argument_list|,
name|t
operator|->
name|where_line
argument_list|,
name|t
operator|->
name|where_col
argument_list|,
name|t
operator|->
name|wheretrack
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|nt
operator|->
name|text
operator|=
name|malloc_new_ksr
argument_list|(
name|malloc_pool_image
argument_list|()
argument_list|,
literal|"FFELEX token text"
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|nt
operator|->
name|text
argument_list|,
name|t
operator|->
name|text
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nt
operator|->
name|text
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|nt
return|;
block|}
end_function

begin_comment
comment|/* Make a new UNDERSCORE token from a NAMES token.  */
end_comment

begin_function
name|ffelexToken
name|ffelex_token_uscore_from_names
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|ffeTokenLength
name|start
parameter_list|)
block|{
name|ffelexToken
name|nt
decl_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAMES
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|start
operator|<
name|t
operator|->
name|length
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|t
operator|->
name|text
index|[
name|start
index|]
operator|==
literal|'_'
argument_list|)
expr_stmt|;
comment|/* Now make the token. */
name|nt
operator|=
name|ffelex_token_new_
argument_list|()
expr_stmt|;
name|nt
operator|->
name|type
operator|=
name|FFELEX_typeUNDERSCORE
expr_stmt|;
name|nt
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|ffewhere_set_from_track
argument_list|(
operator|&
name|nt
operator|->
name|where_line
argument_list|,
operator|&
name|nt
operator|->
name|where_col
argument_list|,
name|t
operator|->
name|where_line
argument_list|,
name|t
operator|->
name|where_col
argument_list|,
name|t
operator|->
name|wheretrack
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|nt
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
return|return
name|nt
return|;
block|}
end_function

begin_comment
comment|/* ffelex_token_use -- Return another instance of a token     ffelexToken t;    t = ffelex_token_use(t);     In a sense, the new token is a copy of the old, though it might be the    same with just a new use count.     We use the use count method (easy).	*/
end_comment

begin_function
name|ffelexToken
name|ffelex_token_use
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|assert
argument_list|(
literal|"_token_use: null token"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|->
name|uses
operator|++
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

end_unit

