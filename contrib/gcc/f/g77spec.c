begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Specific flags and argument handling of the Fortran front-end.    Copyright (C) 1997, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains a filter for the main `gcc' driver, which is    replicated for the `g77' driver by adding this filter.  The purpose    of this filter is to be basically identical to gcc (in that    it faithfully passes all of the original arguments to gcc) but,    unless explicitly overridden by the user in certain ways, ensure    that the needs of the language supported by this wrapper are met.     For GNU Fortran (g77), we do the following to the argument list    before passing it to `gcc':     1.  Make sure `-lg2c -lm' is at the end of the list.     2.  Make sure each time `-lg2c' or `-lm' is seen, it forms        part of the series `-lg2c -lm'.     #1 and #2 are not done if `-nostdlib' or any option that disables    the linking phase is present, or if `-xfoo' is in effect.  Note that    a lack of source files or -l options disables linking.     This program was originally made out of gcc/cp/g++spec.c, but the    way it builds the new argument list was rewritten so it is much    easier to maintain, improve the way it decides to add or not add    extra arguments, etc.  And several improvements were made in the    handling of arguments, primarily to make it more consistent with    `gcc' itself.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<f/version.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MATH_LIBRARY
end_ifndef

begin_define
define|#
directive|define
name|MATH_LIBRARY
value|"-lm"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FORTRAN_LIBRARY
end_ifndef

begin_define
define|#
directive|define
name|FORTRAN_LIBRARY
value|"-lg2c"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Options this driver needs to recognize, not just know how to    skip over.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|OPTION_b
block|,
comment|/* Aka --prefix. */
name|OPTION_B
block|,
comment|/* Aka --target. */
name|OPTION_c
block|,
comment|/* Aka --compile. */
name|OPTION_driver
block|,
comment|/* Wrapper-specific option. */
name|OPTION_E
block|,
comment|/* Aka --preprocess. */
name|OPTION_help
block|,
comment|/* --help. */
name|OPTION_i
block|,
comment|/* -imacros, -include, -include-*. */
name|OPTION_l
block|,
name|OPTION_L
block|,
comment|/* Aka --library-directory. */
name|OPTION_M
block|,
comment|/* Aka --dependencies. */
name|OPTION_MM
block|,
comment|/* Aka --user-dependencies. */
name|OPTION_nostdlib
block|,
comment|/* Aka --no-standard-libraries, or 				   -nodefaultlibs. */
name|OPTION_o
block|,
comment|/* Aka --output. */
name|OPTION_S
block|,
comment|/* Aka --assemble. */
name|OPTION_syntax_only
block|,
comment|/* -fsyntax-only. */
name|OPTION_v
block|,
comment|/* Aka --verbose. */
name|OPTION_version
block|,
comment|/* --version. */
name|OPTION_V
block|,
comment|/* Aka --use-version. */
name|OPTION_x
block|,
comment|/* Aka --language. */
name|OPTION_
comment|/* Unrecognized or unimportant. */
block|}
name|Option
typedef|;
end_typedef

begin_comment
comment|/* The original argument list and related info is copied here.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|g77_xargc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|g77_xargv
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|g77_fn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The new argument list will be built here.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|g77_newargc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|g77_newargv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --- This comes from gcc.c (2.8.1) verbatim: */
end_comment

begin_comment
comment|/* This defines which switch letters take arguments.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_SWITCH_TAKES_ARG
parameter_list|(
name|CHAR
parameter_list|)
define|\
value|((CHAR) == 'D' || (CHAR) == 'U' || (CHAR) == 'o' \    || (CHAR) == 'e' || (CHAR) == 'T' || (CHAR) == 'u' \    || (CHAR) == 'I' || (CHAR) == 'm' || (CHAR) == 'x' \    || (CHAR) == 'L' || (CHAR) == 'A')
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SWITCH_TAKES_ARG
end_ifndef

begin_define
define|#
directive|define
name|SWITCH_TAKES_ARG
parameter_list|(
name|CHAR
parameter_list|)
value|DEFAULT_SWITCH_TAKES_ARG(CHAR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This defines which multi-letter switches take arguments.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_WORD_SWITCH_TAKES_ARG
parameter_list|(
name|STR
parameter_list|)
define|\
value|(!strcmp (STR, "Tdata") || !strcmp (STR, "Ttext")	\   || !strcmp (STR, "Tbss") || !strcmp (STR, "include")	\   || !strcmp (STR, "imacros") || !strcmp (STR, "aux-info") \   || !strcmp (STR, "idirafter") || !strcmp (STR, "iprefix") \   || !strcmp (STR, "iwithprefix") || !strcmp (STR, "iwithprefixbefore") \   || !strcmp (STR, "isystem") || !strcmp (STR, "specs"))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|WORD_SWITCH_TAKES_ARG
end_ifndef

begin_define
define|#
directive|define
name|WORD_SWITCH_TAKES_ARG
parameter_list|(
name|STR
parameter_list|)
value|DEFAULT_WORD_SWITCH_TAKES_ARG (STR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* --- End of verbatim.  */
end_comment

begin_comment
comment|/* Assumes text[0] == '-'.  Returns number of argv items that belong to    (and follow) this one, an option id for options important to the    caller, and a pointer to the first char of the arg, if embedded (else    returns NULL, meaning no arg or it's the next argv).     Note that this also assumes gcc.c's pass converting long options    to short ones, where available, has already been run.  */
end_comment

begin_function
specifier|static
name|void
name|lookup_option
parameter_list|(
name|xopt
parameter_list|,
name|xskip
parameter_list|,
name|xarg
parameter_list|,
name|text
parameter_list|)
name|Option
modifier|*
name|xopt
decl_stmt|;
name|int
modifier|*
name|xskip
decl_stmt|;
name|char
modifier|*
modifier|*
name|xarg
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|Option
name|opt
init|=
name|OPTION_
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|char
modifier|*
name|arg
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|skip
operator|=
name|SWITCH_TAKES_ARG
argument_list|(
name|text
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
name|skip
operator|-=
operator|(
name|text
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|)
expr_stmt|;
comment|/* See gcc.c. */
if|if
condition|(
name|text
index|[
literal|1
index|]
operator|==
literal|'B'
condition|)
name|opt
operator|=
name|OPTION_B
operator|,
name|skip
operator|=
operator|(
name|text
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|,
name|arg
operator|=
name|text
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|text
index|[
literal|1
index|]
operator|==
literal|'b'
condition|)
name|opt
operator|=
name|OPTION_b
operator|,
name|skip
operator|=
operator|(
name|text
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|,
name|arg
operator|=
name|text
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|text
index|[
literal|1
index|]
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|text
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|opt
operator|=
name|OPTION_c
operator|,
name|skip
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|text
index|[
literal|1
index|]
operator|==
literal|'E'
operator|)
operator|&&
operator|(
name|text
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|opt
operator|=
name|OPTION_E
operator|,
name|skip
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|text
index|[
literal|1
index|]
operator|==
literal|'i'
condition|)
name|opt
operator|=
name|OPTION_i
operator|,
name|skip
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|text
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
name|opt
operator|=
name|OPTION_l
expr_stmt|;
elseif|else
if|if
condition|(
name|text
index|[
literal|1
index|]
operator|==
literal|'L'
condition|)
name|opt
operator|=
name|OPTION_L
operator|,
name|arg
operator|=
name|text
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|text
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
name|opt
operator|=
name|OPTION_o
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|text
index|[
literal|1
index|]
operator|==
literal|'S'
operator|)
operator|&&
operator|(
name|text
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|opt
operator|=
name|OPTION_S
operator|,
name|skip
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|text
index|[
literal|1
index|]
operator|==
literal|'V'
condition|)
name|opt
operator|=
name|OPTION_V
operator|,
name|skip
operator|=
operator|(
name|text
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|text
index|[
literal|1
index|]
operator|==
literal|'v'
operator|)
operator|&&
operator|(
name|text
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|opt
operator|=
name|OPTION_v
operator|,
name|skip
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|text
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
name|opt
operator|=
name|OPTION_x
operator|,
name|arg
operator|=
name|text
operator|+
literal|2
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|skip
operator|=
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|text
operator|+
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
comment|/* See gcc.c. */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|text
argument_list|,
literal|"-fdriver"
argument_list|,
literal|8
argument_list|)
condition|)
comment|/* Really --driver!! */
name|opt
operator|=
name|OPTION_driver
expr_stmt|;
comment|/* Never mind arg, this is unsupported. */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|text
argument_list|,
literal|"-fhelp"
argument_list|)
condition|)
comment|/* Really --help!! */
name|opt
operator|=
name|OPTION_help
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|text
argument_list|,
literal|"-M"
argument_list|)
condition|)
name|opt
operator|=
name|OPTION_M
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|text
argument_list|,
literal|"-MM"
argument_list|)
condition|)
name|opt
operator|=
name|OPTION_MM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|text
argument_list|,
literal|"-nostdlib"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|text
argument_list|,
literal|"-nodefaultlibs"
argument_list|)
condition|)
name|opt
operator|=
name|OPTION_nostdlib
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|text
argument_list|,
literal|"-fsyntax-only"
argument_list|)
condition|)
name|opt
operator|=
name|OPTION_syntax_only
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|text
argument_list|,
literal|"-dumpversion"
argument_list|)
condition|)
name|opt
operator|=
name|OPTION_version
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|text
argument_list|,
literal|"-Xlinker"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|text
argument_list|,
literal|"-specs"
argument_list|)
condition|)
name|skip
operator|=
literal|1
expr_stmt|;
else|else
name|skip
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xopt
operator|!=
name|NULL
condition|)
operator|*
name|xopt
operator|=
name|opt
expr_stmt|;
if|if
condition|(
name|xskip
operator|!=
name|NULL
condition|)
operator|*
name|xskip
operator|=
name|skip
expr_stmt|;
if|if
condition|(
name|xarg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|arg
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
operator|*
name|xarg
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|xarg
operator|=
name|arg
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Append another argument to the list being built.  As long as it is    identical to the corresponding arg in the original list, just increment    the new arg count.  Otherwise allocate a new list, etc.  */
end_comment

begin_function
specifier|static
name|void
name|append_arg
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|int
name|newargsize
decl_stmt|;
if|#
directive|if
literal|0
block|fprintf (stderr, "`%s'\n", arg);
endif|#
directive|endif
if|if
condition|(
name|g77_newargv
operator|==
name|g77_xargv
operator|&&
name|g77_newargc
operator|<
name|g77_xargc
operator|&&
operator|(
name|arg
operator|==
name|g77_xargv
index|[
name|g77_newargc
index|]
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
name|g77_xargv
index|[
name|g77_newargc
index|]
argument_list|)
operator|)
condition|)
block|{
operator|++
name|g77_newargc
expr_stmt|;
return|return;
comment|/* Nothing new here. */
block|}
if|if
condition|(
name|g77_newargv
operator|==
name|g77_xargv
condition|)
block|{
comment|/* Make new arglist. */
name|int
name|i
decl_stmt|;
name|newargsize
operator|=
operator|(
name|g77_xargc
operator|<<
literal|2
operator|)
operator|+
literal|20
expr_stmt|;
comment|/* This should handle all. */
name|g77_newargv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|newargsize
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy what has been done so far.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g77_newargc
condition|;
operator|++
name|i
control|)
name|g77_newargv
index|[
name|i
index|]
operator|=
name|g77_xargv
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|g77_newargc
operator|==
name|newargsize
condition|)
call|(
modifier|*
name|g77_fn
call|)
argument_list|(
literal|"overflowed output arg list for `%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|g77_newargv
index|[
name|g77_newargc
operator|++
index|]
operator|=
name|arg
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|lang_specific_driver
argument_list|(
name|fn
argument_list|,
name|in_argc
argument_list|,
name|in_argv
argument_list|,
name|in_added_libraries
argument_list|)
name|void
argument_list|(
operator|*
name|fn
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|in_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
modifier|*
name|in_argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|in_added_libraries
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|argc
init|=
operator|*
name|in_argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
init|=
operator|*
name|in_argv
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|verbose
init|=
literal|0
decl_stmt|;
name|Option
name|opt
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
comment|/* This will be NULL if we encounter a situation where we should not      link in libf2c.  */
name|char
modifier|*
name|library
init|=
name|FORTRAN_LIBRARY
decl_stmt|;
comment|/* This will become 0 if anything other than -v and kin (like -V)      is seen, meaning the user is trying to accomplish something.      If it remains nonzero, and the user wants version info, add stuff to      the command line to make gcc invoke all the appropriate phases      to get all the version info.  */
name|int
name|add_version_magic
init|=
literal|1
decl_stmt|;
comment|/* 0 => -xnone in effect.      1 => -xfoo in effect.  */
name|int
name|saw_speclang
init|=
literal|0
decl_stmt|;
comment|/* 0 => initial/reset state      1 => last arg was -l<library>      2 => last two args were -l<library> -lm.  */
name|int
name|saw_library
init|=
literal|0
decl_stmt|;
comment|/* By default, we throw on the math library if we have one.  */
name|int
name|need_math
init|=
operator|(
name|MATH_LIBRARY
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
decl_stmt|;
comment|/* The number of input and output files in the incoming arg list.  */
name|int
name|n_infiles
init|=
literal|0
decl_stmt|;
name|int
name|n_outfiles
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
block|fprintf (stderr, "Incoming:");   for (i = 0; i< argc; i++)     fprintf (stderr, " %s", argv[i]);   fprintf (stderr, "\n");
endif|#
directive|endif
name|g77_xargc
operator|=
name|argc
expr_stmt|;
name|g77_xargv
operator|=
name|argv
expr_stmt|;
name|g77_newargc
operator|=
literal|0
expr_stmt|;
name|g77_newargv
operator|=
name|argv
expr_stmt|;
name|g77_fn
operator|=
name|fn
expr_stmt|;
comment|/* First pass through arglist.       If -nostdlib or a "turn-off-linking" option is anywhere in the      command line, don't do any library-option processing (except      relating to -x).  Also, if -v is specified, but no other options      that do anything special (allowing -V version, etc.), remember      to add special stuff to make gcc command actually invoke all      the different phases of the compilation process so all the version      numbers can be seen.       Also, here is where all problems with missing arguments to options      are caught.  If this loop is exited normally, it means all options      have the appropriate number of arguments as far as the rest of this      program is concerned.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
operator|&&
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'e'
operator|)
condition|)
block|{
name|add_version_magic
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|)
operator|||
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
operator|++
name|n_infiles
expr_stmt|;
name|add_version_magic
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|lookup_option
argument_list|(
operator|&
name|opt
argument_list|,
operator|&
name|skip
argument_list|,
name|NULL
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|OPTION_nostdlib
case|:
case|case
name|OPTION_c
case|:
case|case
name|OPTION_S
case|:
case|case
name|OPTION_syntax_only
case|:
case|case
name|OPTION_E
case|:
case|case
name|OPTION_M
case|:
case|case
name|OPTION_MM
case|:
comment|/* These options disable linking entirely or linking of the 	     standard libraries.  */
name|library
operator|=
literal|0
expr_stmt|;
name|add_version_magic
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_l
case|:
operator|++
name|n_infiles
expr_stmt|;
name|add_version_magic
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_o
case|:
operator|++
name|n_outfiles
expr_stmt|;
name|add_version_magic
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_v
case|:
if|if
condition|(
operator|!
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"g77 version %s (from FSF-g77 version %s)\n"
argument_list|,
name|version_string
argument_list|,
name|ffe_version_string
argument_list|)
expr_stmt|;
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_b
case|:
case|case
name|OPTION_B
case|:
case|case
name|OPTION_L
case|:
case|case
name|OPTION_i
case|:
case|case
name|OPTION_V
case|:
comment|/* These options are useful in conjunction with -v to get 	     appropriate version info.  */
break|break;
case|case
name|OPTION_version
case|:
name|printf
argument_list|(
literal|"\ GNU Fortran %s\n\ Copyright (C) 1997 Free Software Foundation, Inc.\n\ For more version information on components of the GNU Fortran\n\ compilation system, especially useful when reporting bugs,\n\ type the command `g77 --verbose'.\n\ \n\ GNU Fortran comes with NO WARRANTY, to the extent permitted by law.\n\ You may redistribute copies of GNU Fortran\n\ under the terms of the GNU General Public License.\n\ For more information about these matters, see the file named COPYING\n\ or type the command `info -f g77 Copying'.\n\ "
argument_list|,
name|ffe_version_string
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_help
case|:
comment|/* Let gcc.c handle this, as the egcs version has a really 	     cool facility for handling --help and --verbose --help.  */
return|return;
if|#
directive|if
literal|0
block|printf ("\ Usage: g77 [OPTION]... FORTRAN-SOURCE...\n\ \n\ Compile and link Fortran source code to produce an executable program,\n\ which by default is named `a.out', and can be invoked with the UNIX\n\ command `./a.out'.\n\ \n\ Options:\n\ --debug                include debugging information in executable.\n\ --help                 display this help and exit.\n\ --optimize[=LEVEL]     take extra time and memory to make generated\n\                          executable run faster.  LEVEL is 0 for no\n\                          optimization, 1 for normal optimization, and\n\                          increases through 3 for more optimization.\n\ --output=PROGRAM       name the executable PROGRAM instead of a.out;\n\                          invoke with the command `./PROGRAM'.\n\ --version              display version information and exit.\n\ \n\ Many other options exist to tailor the compilation process, specify\n\ the dialect of the Fortran source code, specify details of the\n\ code-generation methodology, and so on.\n\ \n\ For more information on g77 and gcc, type the commands `info -f g77'\n\ and `info -f gcc' to read the Info documentation.\n\ \n\ For bug reporting instructions, please see:\n\<URL:http://www.gnu.org/software/gcc/faq.html#bugreport>.\n"); 	  exit (0); 	  break;
endif|#
directive|endif
case|case
name|OPTION_driver
case|:
call|(
modifier|*
name|fn
call|)
argument_list|(
literal|"--driver no longer supported"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|add_version_magic
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* This is the one place we check for missing arguments in the 	 program.  */
if|if
condition|(
name|i
operator|+
name|skip
operator|<
name|argc
condition|)
name|i
operator|+=
name|skip
expr_stmt|;
else|else
call|(
modifier|*
name|fn
call|)
argument_list|(
literal|"argument to `%s' missing"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n_outfiles
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|n_infiles
operator|==
literal|0
operator|)
condition|)
call|(
modifier|*
name|fn
call|)
argument_list|(
literal|"No input files; unwilling to write output files"
argument_list|)
expr_stmt|;
comment|/* Second pass through arglist, transforming arguments as appropriate.  */
name|append_arg
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Start with command name, of course. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|append_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Interesting.  Just append as is. */
continue|continue;
block|}
if|if
condition|(
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|'l'
operator|)
condition|)
block|{
comment|/* Not a filename or library. */
if|if
condition|(
name|saw_library
operator|==
literal|1
operator|&&
name|need_math
condition|)
comment|/* -l<library>. */
name|append_arg
argument_list|(
name|MATH_LIBRARY
argument_list|)
expr_stmt|;
name|saw_library
operator|=
literal|0
expr_stmt|;
name|lookup_option
argument_list|(
operator|&
name|opt
argument_list|,
operator|&
name|skip
argument_list|,
operator|&
name|arg
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|append_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* "-" == Standard input. */
continue|continue;
block|}
if|if
condition|(
name|opt
operator|==
name|OPTION_x
condition|)
block|{
comment|/* Track input language. */
name|char
modifier|*
name|lang
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|lang
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|lang
operator|=
name|arg
expr_stmt|;
name|saw_speclang
operator|=
operator|(
name|strcmp
argument_list|(
name|lang
argument_list|,
literal|"none"
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|append_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|skip
operator|!=
literal|0
condition|;
operator|--
name|skip
control|)
name|append_arg
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* A filename/library, not an option. */
if|if
condition|(
name|saw_speclang
condition|)
name|saw_library
operator|=
literal|0
expr_stmt|;
comment|/* -xfoo currently active. */
else|else
block|{
comment|/* -lfoo or filename. */
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|MATH_LIBRARY
argument_list|)
operator|==
literal|0
ifdef|#
directive|ifdef
name|ALT_LIBM
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|ALT_LIBM
argument_list|)
operator|==
literal|0
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|saw_library
operator|==
literal|1
condition|)
name|saw_library
operator|=
literal|2
expr_stmt|;
comment|/* -l<library> -lm. */
else|else
name|append_arg
argument_list|(
name|FORTRAN_LIBRARY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|FORTRAN_LIBRARY
argument_list|)
operator|==
literal|0
condition|)
name|saw_library
operator|=
literal|1
expr_stmt|;
comment|/* -l<library>. */
else|else
block|{
comment|/* Other library, or filename. */
if|if
condition|(
name|saw_library
operator|==
literal|1
operator|&&
name|need_math
condition|)
name|append_arg
argument_list|(
name|MATH_LIBRARY
argument_list|)
expr_stmt|;
name|saw_library
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|append_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Append `-lg2c -lm' as necessary.  */
if|if
condition|(
operator|!
name|add_version_magic
operator|&&
name|library
condition|)
block|{
comment|/* Doing a link and no -nostdlib. */
if|if
condition|(
name|saw_speclang
condition|)
name|append_arg
argument_list|(
literal|"-xnone"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|saw_library
condition|)
block|{
case|case
literal|0
case|:
name|append_arg
argument_list|(
name|library
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
if|if
condition|(
name|need_math
condition|)
name|append_arg
argument_list|(
name|MATH_LIBRARY
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|add_version_magic
operator|&&
name|verbose
condition|)
block|{
name|append_arg
argument_list|(
literal|"-c"
argument_list|)
expr_stmt|;
name|append_arg
argument_list|(
literal|"-xf77-version"
argument_list|)
expr_stmt|;
name|append_arg
argument_list|(
literal|"/dev/null"
argument_list|)
expr_stmt|;
name|append_arg
argument_list|(
literal|"-xnone"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|&&
name|g77_newargv
operator|!=
name|g77_xargv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Driving:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g77_newargc
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|g77_newargv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|in_argc
operator|=
name|g77_newargc
expr_stmt|;
operator|*
name|in_argv
operator|=
name|g77_newargv
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Called before linking.  Returns 0 on success and -1 on failure. */
end_comment

begin_function
name|int
name|lang_specific_pre_link
parameter_list|()
comment|/* Not used for F77. */
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Number of extra output files that lang_specific_pre_link may generate. */
end_comment

begin_decl_stmt
name|int
name|lang_specific_extra_outfiles
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Not used for F77. */
end_comment

end_unit

