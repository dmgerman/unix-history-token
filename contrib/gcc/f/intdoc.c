begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* intdoc.c    Copyright (C) 1997, 2000, 2001 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* From f/proj.h, which uses #error -- not all C compilers    support that, and we want *this* program to be compilable    by pretty much any C compiler.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_comment
comment|/* Pull in the intrinsics info, but only the doc parts.  */
end_comment

begin_define
define|#
directive|define
name|FFEINTRIN_DOC
value|1
end_define

begin_include
include|#
directive|include
file|"intrin.h"
end_include

begin_function_decl
specifier|const
name|char
modifier|*
name|family_name
parameter_list|(
name|ffeintrinFamily
name|family
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dumpif
parameter_list|(
name|ffeintrinFamily
name|fam
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dumpendif
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dumpclearif
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dumpem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dumpgen
parameter_list|(
name|int
name|menu
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|name_uc
parameter_list|,
name|ffeintrinGen
name|gen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dumpspec
parameter_list|(
name|int
name|menu
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|name_uc
parameter_list|,
name|ffeintrinSpec
name|spec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dumpimp
parameter_list|(
name|int
name|menu
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|name_uc
parameter_list|,
name|size_t
name|genno
parameter_list|,
name|ffeintrinFamily
name|family
parameter_list|,
name|ffeintrinImp
name|imp
parameter_list|,
name|ffeintrinSpec
name|spec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|argument_info_ptr
parameter_list|(
name|ffeintrinImp
name|imp
parameter_list|,
name|int
name|argno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|argument_info_string
parameter_list|(
name|ffeintrinImp
name|imp
parameter_list|,
name|int
name|argno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|argument_name_ptr
parameter_list|(
name|ffeintrinImp
name|imp
parameter_list|,
name|int
name|argno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|argument_name_string
parameter_list|(
name|ffeintrinImp
name|imp
parameter_list|,
name|int
name|argno
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char *elaborate_if_complex (ffeintrinImp imp, int argno); static const char *elaborate_if_maybe_complex (ffeintrinImp imp, int argno); static const char *elaborate_if_real (ffeintrinImp imp, int argno);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|print_type_string
parameter_list|(
specifier|const
name|char
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: intdoc> intdoc.texi\n\   Collects and dumps documentation on g77 intrinsics\n\   to the file named intdoc.texi.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|dumpem
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|_ffeintrin_name_
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name_uc
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name_lc
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name_ic
decl_stmt|;
specifier|const
name|ffeintrinGen
name|generic
decl_stmt|;
specifier|const
name|ffeintrinSpec
name|specific
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_ffeintrin_gen_
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Name as seen in program. */
specifier|const
name|ffeintrinSpec
name|specs
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_ffeintrin_spec_
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Uppercase name as seen in source code, 				   lowercase if no source name, "none" if no 				   name at all (NONE case). */
specifier|const
name|bool
name|is_actualarg
decl_stmt|;
comment|/* Ok to pass as actual arg if -pedantic. */
specifier|const
name|ffeintrinFamily
name|family
decl_stmt|;
specifier|const
name|ffeintrinImp
name|implementation
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_ffeintrin_imp_
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Name of implementation. */
specifier|const
name|char
modifier|*
specifier|const
name|control
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|_ffeintrin_name_
name|names
index|[]
init|=
block|{
define|#
directive|define
name|DEFNAME
parameter_list|(
name|UPPER
parameter_list|,
name|LOWER
parameter_list|,
name|MIXED
parameter_list|,
name|GEN
parameter_list|,
name|SPEC
parameter_list|)
define|\
value|{ UPPER, LOWER, MIXED, FFEINTRIN_ ## GEN, FFEINTRIN_ ## SPEC },
define|#
directive|define
name|DEFGEN
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|SPEC1
parameter_list|,
name|SPEC2
parameter_list|)
define|#
directive|define
name|DEFSPEC
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|CALLABLE
parameter_list|,
name|FAMILY
parameter_list|,
name|IMP
parameter_list|)
define|#
directive|define
name|DEFIMP
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|)
define|#
directive|define
name|DEFIMPY
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|,
name|Y2KBAD
parameter_list|)
include|#
directive|include
file|"intrin.def"
undef|#
directive|undef
name|DEFNAME
undef|#
directive|undef
name|DEFGEN
undef|#
directive|undef
name|DEFSPEC
undef|#
directive|undef
name|DEFIMP
undef|#
directive|undef
name|DEFIMPY
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|_ffeintrin_gen_
name|gens
index|[]
init|=
block|{
define|#
directive|define
name|DEFNAME
parameter_list|(
name|UPPER
parameter_list|,
name|LOWER
parameter_list|,
name|MIXED
parameter_list|,
name|GEN
parameter_list|,
name|SPEC
parameter_list|)
define|#
directive|define
name|DEFGEN
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|SPEC1
parameter_list|,
name|SPEC2
parameter_list|)
define|\
value|{ NAME, { SPEC1, SPEC2, }, },
define|#
directive|define
name|DEFSPEC
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|CALLABLE
parameter_list|,
name|FAMILY
parameter_list|,
name|IMP
parameter_list|)
define|#
directive|define
name|DEFIMP
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|)
define|#
directive|define
name|DEFIMPY
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|,
name|Y2KBAD
parameter_list|)
include|#
directive|include
file|"intrin.def"
undef|#
directive|undef
name|DEFNAME
undef|#
directive|undef
name|DEFGEN
undef|#
directive|undef
name|DEFSPEC
undef|#
directive|undef
name|DEFIMP
undef|#
directive|undef
name|DEFIMPY
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|_ffeintrin_imp_
name|imps
index|[]
init|=
block|{
define|#
directive|define
name|DEFNAME
parameter_list|(
name|UPPER
parameter_list|,
name|LOWER
parameter_list|,
name|MIXED
parameter_list|,
name|GEN
parameter_list|,
name|SPEC
parameter_list|)
define|#
directive|define
name|DEFGEN
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|SPEC1
parameter_list|,
name|SPEC2
parameter_list|)
define|#
directive|define
name|DEFSPEC
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|CALLABLE
parameter_list|,
name|FAMILY
parameter_list|,
name|IMP
parameter_list|)
define|#
directive|define
name|DEFIMP
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|)
define|\
value|{ NAME, CONTROL },
define|#
directive|define
name|DEFIMPY
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|,
name|Y2KBAD
parameter_list|)
define|\
value|{ NAME, CONTROL },
include|#
directive|include
file|"intrin.def"
undef|#
directive|undef
name|DEFNAME
undef|#
directive|undef
name|DEFGEN
undef|#
directive|undef
name|DEFSPEC
undef|#
directive|undef
name|DEFIMP
undef|#
directive|undef
name|DEFIMPY
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|_ffeintrin_spec_
name|specs
index|[]
init|=
block|{
define|#
directive|define
name|DEFNAME
parameter_list|(
name|UPPER
parameter_list|,
name|LOWER
parameter_list|,
name|MIXED
parameter_list|,
name|GEN
parameter_list|,
name|SPEC
parameter_list|)
define|#
directive|define
name|DEFGEN
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|SPEC1
parameter_list|,
name|SPEC2
parameter_list|)
define|#
directive|define
name|DEFSPEC
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|CALLABLE
parameter_list|,
name|FAMILY
parameter_list|,
name|IMP
parameter_list|)
define|\
value|{ NAME, CALLABLE, FAMILY, IMP, },
define|#
directive|define
name|DEFIMP
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|)
define|#
directive|define
name|DEFIMPY
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|GFRTDIRECT
parameter_list|,
name|GFRTF2C
parameter_list|,
name|GFRTGNU
parameter_list|,
name|CONTROL
parameter_list|,
name|Y2KBAD
parameter_list|)
include|#
directive|include
file|"intrin.def"
undef|#
directive|undef
name|DEFGEN
undef|#
directive|undef
name|DEFSPEC
undef|#
directive|undef
name|DEFIMP
undef|#
directive|undef
name|DEFIMPY
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|cc_pair
block|{
specifier|const
name|ffeintrinImp
name|imp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|text
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|descriptions
index|[
name|FFEINTRIN_imp
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|cc_pair
name|cc_descriptions
index|[]
init|=
block|{
define|#
directive|define
name|DEFDOC
parameter_list|(
name|IMP
parameter_list|,
name|SUMMARY
parameter_list|,
name|DESCRIPTION
parameter_list|)
value|{ FFEINTRIN_imp ## IMP, DESCRIPTION },
include|#
directive|include
file|"intdoc.h0"
undef|#
directive|undef
name|DEFDOC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|summaries
index|[
name|FFEINTRIN_imp
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|cc_pair
name|cc_summaries
index|[]
init|=
block|{
define|#
directive|define
name|DEFDOC
parameter_list|(
name|IMP
parameter_list|,
name|SUMMARY
parameter_list|,
name|DESCRIPTION
parameter_list|)
value|{ FFEINTRIN_imp ## IMP, SUMMARY },
include|#
directive|include
file|"intdoc.h0"
undef|#
directive|undef
name|DEFDOC
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|family_name
parameter_list|(
name|ffeintrinFamily
name|family
parameter_list|)
block|{
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|FFEINTRIN_familyF77
case|:
return|return
literal|"familyF77"
return|;
case|case
name|FFEINTRIN_familyASC
case|:
return|return
literal|"familyASC"
return|;
case|case
name|FFEINTRIN_familyMIL
case|:
return|return
literal|"familyMIL"
return|;
case|case
name|FFEINTRIN_familyGNU
case|:
return|return
literal|"familyGNU"
return|;
case|case
name|FFEINTRIN_familyF90
case|:
return|return
literal|"familyF90"
return|;
case|case
name|FFEINTRIN_familyVXT
case|:
return|return
literal|"familyVXT"
return|;
case|case
name|FFEINTRIN_familyFVZ
case|:
return|return
literal|"familyFVZ"
return|;
case|case
name|FFEINTRIN_familyF2C
case|:
return|return
literal|"familyF2C"
return|;
case|case
name|FFEINTRIN_familyF2U
case|:
return|return
literal|"familyF2U"
return|;
case|case
name|FFEINTRIN_familyBADU77
case|:
return|return
literal|"familyBADU77"
return|;
default|default:
name|assert
argument_list|(
literal|"bad family"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|"??"
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|in_ifset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffeintrinFamily
name|latest_family
init|=
name|FFEINTRIN_familyNONE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dumpif
parameter_list|(
name|ffeintrinFamily
name|fam
parameter_list|)
block|{
name|assert
argument_list|(
name|fam
operator|!=
name|FFEINTRIN_familyNONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|in_ifset
operator|!=
literal|2
operator|)
operator|||
operator|(
name|fam
operator|!=
name|latest_family
operator|)
condition|)
block|{
if|if
condition|(
name|in_ifset
operator|==
literal|2
condition|)
name|printf
argument_list|(
literal|"@end ifset\n"
argument_list|)
expr_stmt|;
name|latest_family
operator|=
name|fam
expr_stmt|;
name|printf
argument_list|(
literal|"@ifset %s\n"
argument_list|,
name|family_name
argument_list|(
name|fam
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|in_ifset
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dumpendif
parameter_list|()
block|{
name|in_ifset
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dumpclearif
parameter_list|()
block|{
if|if
condition|(
operator|(
name|in_ifset
operator|==
literal|2
operator|)
operator|||
operator|(
name|latest_family
operator|!=
name|FFEINTRIN_familyNONE
operator|)
condition|)
name|printf
argument_list|(
literal|"@end ifset\n"
argument_list|)
expr_stmt|;
name|latest_family
operator|=
name|FFEINTRIN_familyNONE
expr_stmt|;
name|in_ifset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dumpem
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|cc_descriptions
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|assert
argument_list|(
name|descriptions
index|[
name|cc_descriptions
index|[
name|i
index|]
operator|.
name|imp
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|descriptions
index|[
name|cc_descriptions
index|[
name|i
index|]
operator|.
name|imp
index|]
operator|=
name|cc_descriptions
index|[
name|i
index|]
operator|.
name|text
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|cc_summaries
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|assert
argument_list|(
name|summaries
index|[
name|cc_summaries
index|[
name|i
index|]
operator|.
name|imp
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|summaries
index|[
name|cc_summaries
index|[
name|i
index|]
operator|.
name|imp
index|]
operator|=
name|cc_summaries
index|[
name|i
index|]
operator|.
name|text
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"@c This file is automatically derived from intdoc.c, intdoc.in,\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"@c ansify.c, intrin.def, and intrin.h.  Edit those files instead.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"@menu\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|names
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|names
index|[
name|i
index|]
operator|.
name|generic
operator|!=
name|FFEINTRIN_genNONE
condition|)
name|dumpgen
argument_list|(
literal|1
argument_list|,
name|names
index|[
name|i
index|]
operator|.
name|name_ic
argument_list|,
name|names
index|[
name|i
index|]
operator|.
name|name_uc
argument_list|,
name|names
index|[
name|i
index|]
operator|.
name|generic
argument_list|)
expr_stmt|;
if|if
condition|(
name|names
index|[
name|i
index|]
operator|.
name|specific
operator|!=
name|FFEINTRIN_specNONE
condition|)
name|dumpspec
argument_list|(
literal|1
argument_list|,
name|names
index|[
name|i
index|]
operator|.
name|name_ic
argument_list|,
name|names
index|[
name|i
index|]
operator|.
name|name_uc
argument_list|,
name|names
index|[
name|i
index|]
operator|.
name|specific
argument_list|)
expr_stmt|;
block|}
name|dumpclearif
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"@end menu\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|size_t
operator|)
name|i
operator|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|names
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|names
index|[
name|i
index|]
operator|.
name|generic
operator|!=
name|FFEINTRIN_genNONE
condition|)
name|dumpgen
argument_list|(
literal|0
argument_list|,
name|names
index|[
name|i
index|]
operator|.
name|name_ic
argument_list|,
name|names
index|[
name|i
index|]
operator|.
name|name_uc
argument_list|,
name|names
index|[
name|i
index|]
operator|.
name|generic
argument_list|)
expr_stmt|;
if|if
condition|(
name|names
index|[
name|i
index|]
operator|.
name|specific
operator|!=
name|FFEINTRIN_specNONE
condition|)
name|dumpspec
argument_list|(
literal|0
argument_list|,
name|names
index|[
name|i
index|]
operator|.
name|name_ic
argument_list|,
name|names
index|[
name|i
index|]
operator|.
name|name_uc
argument_list|,
name|names
index|[
name|i
index|]
operator|.
name|specific
argument_list|)
expr_stmt|;
block|}
name|dumpclearif
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dumpgen
parameter_list|(
name|int
name|menu
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|name_uc
parameter_list|,
name|ffeintrinGen
name|gen
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|total
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|menu
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|gens
index|[
name|gen
index|]
operator|.
name|specs
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|gens
index|[
name|gen
index|]
operator|.
name|specs
index|[
name|i
index|]
operator|!=
name|FFEINTRIN_specNONE
condition|)
operator|++
name|total
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|gens
index|[
name|gen
index|]
operator|.
name|specs
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|ffeintrinSpec
name|spec
decl_stmt|;
name|size_t
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|spec
operator|=
name|gens
index|[
name|gen
index|]
operator|.
name|specs
index|[
name|i
index|]
operator|)
operator|==
name|FFEINTRIN_specNONE
condition|)
continue|continue;
name|dumpif
argument_list|(
name|specs
index|[
name|spec
index|]
operator|.
name|family
argument_list|)
expr_stmt|;
name|dumpimp
argument_list|(
name|menu
argument_list|,
name|name
argument_list|,
name|name_uc
argument_list|,
name|i
argument_list|,
name|specs
index|[
name|spec
index|]
operator|.
name|family
argument_list|,
name|specs
index|[
name|spec
index|]
operator|.
name|implementation
argument_list|,
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|menu
operator|&&
operator|(
name|total
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|total
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\ For information on another intrinsic with the same name:\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\ For information on other intrinsics with the same name:\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|gens
index|[
name|gen
index|]
operator|.
name|specs
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|j
operator|==
name|i
condition|)
continue|continue;
if|if
condition|(
operator|(
name|spec
operator|=
name|gens
index|[
name|gen
index|]
operator|.
name|specs
index|[
name|j
index|]
operator|)
operator|==
name|FFEINTRIN_specNONE
condition|)
continue|continue;
name|printf
argument_list|(
literal|"@xref{%s Intrinsic (%s)}.\n"
argument_list|,
name|name
argument_list|,
name|specs
index|[
name|spec
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|dumpendif
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dumpspec
parameter_list|(
name|int
name|menu
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|name_uc
parameter_list|,
name|ffeintrinSpec
name|spec
parameter_list|)
block|{
name|dumpif
argument_list|(
name|specs
index|[
name|spec
index|]
operator|.
name|family
argument_list|)
expr_stmt|;
name|dumpimp
argument_list|(
name|menu
argument_list|,
name|name
argument_list|,
name|name_uc
argument_list|,
literal|0
argument_list|,
name|specs
index|[
name|spec
index|]
operator|.
name|family
argument_list|,
name|specs
index|[
name|spec
index|]
operator|.
name|implementation
argument_list|,
name|FFEINTRIN_specNONE
argument_list|)
expr_stmt|;
name|dumpendif
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dumpimp
parameter_list|(
name|int
name|menu
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|name_uc
parameter_list|,
name|size_t
name|genno
parameter_list|,
name|ffeintrinFamily
name|family
parameter_list|,
name|ffeintrinImp
name|imp
parameter_list|,
name|ffeintrinSpec
name|spec
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
name|bool
name|subr
decl_stmt|;
specifier|const
name|char
modifier|*
name|argc
decl_stmt|;
specifier|const
name|char
modifier|*
name|argi
decl_stmt|;
name|int
name|colon
decl_stmt|;
name|int
name|argno
decl_stmt|;
name|assert
argument_list|(
operator|(
name|imp
operator|!=
name|FFEINTRIN_impNONE
operator|)
operator|||
operator|!
name|genno
argument_list|)
expr_stmt|;
if|if
condition|(
name|menu
condition|)
block|{
name|printf
argument_list|(
literal|"* %s Intrinsic"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|FFEINTRIN_specNONE
condition|)
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|specs
index|[
name|spec
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* See XYZZY1 below */
name|printf
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
define|#
directive|define
name|INDENT_SUMMARY
value|24
if|if
condition|(
operator|(
name|imp
operator|==
name|FFEINTRIN_impNONE
operator|)
operator|||
operator|(
name|summaries
index|[
name|imp
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|int
name|spaces
init|=
name|INDENT_SUMMARY
operator|-
literal|14
operator|-
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
name|FFEINTRIN_specNONE
condition|)
name|spaces
operator|-=
operator|(
literal|3
operator|+
name|strlen
argument_list|(
name|specs
index|[
name|spec
index|]
operator|.
name|name
argument_list|)
operator|)
expr_stmt|;
comment|/* See XYZZY1 above */
if|if
condition|(
name|spaces
operator|<
literal|1
condition|)
name|spaces
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|spaces
operator|--
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp
operator|==
name|FFEINTRIN_impNONE
condition|)
block|{
name|printf
argument_list|(
literal|"(Reserved for future use.)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|c
operator|=
name|summaries
index|[
name|imp
index|]
init|;
name|c
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|c
control|)
block|{
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|==
literal|'@'
operator|&&
name|ISDIGIT
argument_list|(
name|c
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|int
name|argno
init|=
name|c
index|[
literal|1
index|]
operator|-
literal|'0'
decl_stmt|;
name|c
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
name|c
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|argno
operator|=
literal|10
operator|*
name|argno
operator|+
operator|(
name|c
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|assert
argument_list|(
name|c
index|[
literal|0
index|]
operator|==
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|argno
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argno
operator|==
literal|99
condition|)
block|{
comment|/* Yeah, this is a major kludge. */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|spaces
operator|=
name|INDENT_SUMMARY
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|spaces
operator|--
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|argument_name_string
argument_list|(
name|imp
argument_list|,
name|argno
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fputc
argument_list|(
name|c
index|[
literal|0
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"@node %s Intrinsic"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|FFEINTRIN_specNONE
condition|)
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|specs
index|[
name|spec
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n@subsubsection %s Intrinsic"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|FFEINTRIN_specNONE
condition|)
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|specs
index|[
name|spec
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n@cindex %s intrinsic\n@cindex intrinsics, %s\n"
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp
operator|==
name|FFEINTRIN_impNONE
condition|)
block|{
name|printf
argument_list|(
literal|"\n\ This intrinsic is not yet implemented.\n\ The name is, however, reserved as an intrinsic.\n\ Use @samp{EXTERNAL %s} to use this name for an\n\ external procedure.\n\ \n\ "
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|=
name|imps
index|[
name|imp
index|]
operator|.
name|control
expr_stmt|;
name|subr
operator|=
operator|(
name|c
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
expr_stmt|;
name|colon
operator|=
operator|(
name|c
index|[
literal|2
index|]
operator|==
literal|':'
operator|)
condition|?
literal|2
else|:
literal|3
expr_stmt|;
name|printf
argument_list|(
literal|"\n\ @noindent\n\ @example\n\ %s%s("
argument_list|,
operator|(
name|subr
condition|?
literal|"CALL "
else|:
literal|""
operator|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|argno
operator|=
literal|0
init|;
condition|;
operator|++
name|argno
control|)
block|{
name|argc
operator|=
name|argument_name_ptr
argument_list|(
name|imp
argument_list|,
name|argno
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|argno
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"@var{%s}"
argument_list|,
name|argc
argument_list|)
expr_stmt|;
name|argi
operator|=
name|argument_info_string
argument_list|(
name|imp
argument_list|,
name|argno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argi
index|[
literal|0
index|]
operator|==
literal|'*'
operator|)
operator|||
operator|(
name|argi
index|[
literal|0
index|]
operator|==
literal|'n'
operator|)
operator|||
operator|(
name|argi
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
operator|||
operator|(
name|argi
index|[
literal|0
index|]
operator|==
literal|'p'
operator|)
condition|)
name|printf
argument_list|(
literal|"-1, @var{%s}-2, @dots{}, @var{%s}-n"
argument_list|,
name|argc
argument_list|,
name|argc
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")\n\ @end example\n\ \n\ "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subr
condition|)
block|{
name|int
name|other_arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg_string
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg_info
decl_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
index|[
name|colon
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|other_arg
operator|=
name|c
index|[
name|colon
operator|+
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|arg_string
operator|=
name|argument_name_string
argument_list|(
name|imp
argument_list|,
name|other_arg
argument_list|)
expr_stmt|;
name|arg_info
operator|=
name|argument_info_string
argument_list|(
name|imp
argument_list|,
name|other_arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|other_arg
operator|=
operator|-
literal|1
expr_stmt|;
name|arg_string
operator|=
name|NULL
expr_stmt|;
name|arg_info
operator|=
name|NULL
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\ @noindent\n\ %s: "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|print_type_string
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" function"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
index|[
literal|0
index|]
operator|==
literal|'R'
operator|)
operator|&&
operator|(
name|c
index|[
literal|1
index|]
operator|==
literal|'C'
operator|)
condition|)
block|{
name|assert
argument_list|(
name|other_arg
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'?'
operator|)
operator|||
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'!'
operator|)
operator|||
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
operator|||
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'*'
operator|)
operator|||
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'n'
operator|)
operator|||
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'p'
operator|)
condition|)
operator|++
name|arg_info
expr_stmt|;
if|if
condition|(
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'F'
operator|)
operator|||
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'N'
operator|)
condition|)
name|printf
argument_list|(
literal|".\n\ The exact type is @samp{REAL(KIND=1)} when argument @var{%s} is\n\ any type other than @code{COMPLEX}, or when it is @code{COMPLEX(KIND=1)}.\n\ When @var{%s} is any @code{COMPLEX} type other than @code{COMPLEX(KIND=1)},\n\ this intrinsic is valid only when used as the argument to\n\ @code{REAL()}, as explained below.\n\n"
argument_list|,
name|arg_string
argument_list|,
name|arg_string
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|".\n\ This intrinsic is valid when argument @var{%s} is\n\ @code{COMPLEX(KIND=1)}.\n\ When @var{%s} is any other @code{COMPLEX} type,\n\ this intrinsic is valid only when used as the argument to\n\ @code{REAL()}, as explained below.\n\n"
argument_list|,
name|arg_string
argument_list|,
name|arg_string
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
if|else if ((c[0] == 'I')&& (c[1] == '7')) 	printf (", the exact type being wide enough to hold a pointer\n\ on the target system (typically @code{INTEGER(KIND=1)} or @code{INTEGER(KIND=4)}).\n\n");
endif|#
directive|endif
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'='
operator|&&
name|ISDIGIT
argument_list|(
name|c
index|[
name|colon
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|other_arg
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'?'
operator|)
operator|||
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'!'
operator|)
operator|||
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
operator|||
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'*'
operator|)
operator|||
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'n'
operator|)
operator|||
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'p'
operator|)
condition|)
operator|++
name|arg_info
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|c
index|[
literal|0
index|]
operator|==
name|arg_info
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
operator|(
name|c
index|[
literal|0
index|]
operator|==
literal|'A'
operator|)
operator|||
operator|(
name|c
index|[
literal|0
index|]
operator|==
literal|'C'
operator|)
operator|||
operator|(
name|c
index|[
literal|0
index|]
operator|==
literal|'I'
operator|)
operator|||
operator|(
name|c
index|[
literal|0
index|]
operator|==
literal|'L'
operator|)
operator|||
operator|(
name|c
index|[
literal|0
index|]
operator|==
literal|'R'
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|c
index|[
literal|0
index|]
operator|==
literal|'R'
operator|)
operator|&&
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'C'
operator|)
operator|)
operator|||
operator|(
operator|(
name|c
index|[
literal|0
index|]
operator|==
literal|'C'
operator|)
operator|&&
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'R'
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|", the @samp{KIND=} value of the type being that of argument @var{%s}.\n\n"
argument_list|,
name|arg_string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
index|[
literal|0
index|]
operator|==
literal|'S'
operator|)
operator|&&
operator|(
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'C'
operator|)
operator|||
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'F'
operator|)
operator|||
operator|(
name|arg_info
index|[
literal|0
index|]
operator|==
literal|'N'
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|".\n\ The exact type depends on that of argument @var{%s}---if @var{%s} is\n\ @code{COMPLEX}, this function's type is @code{REAL}\n\ with the same @samp{KIND=} value as the type of @var{%s}.\n\ Otherwise, this function's type is the same as that of @var{%s}.\n\n"
argument_list|,
name|arg_string
argument_list|,
name|arg_string
argument_list|,
name|arg_string
argument_list|,
name|arg_string
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", the exact type being that of argument @var{%s}.\n\n"
argument_list|,
name|arg_string
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
index|[
literal|1
index|]
operator|==
literal|'='
operator|)
operator|&&
operator|(
name|c
index|[
name|colon
operator|+
literal|1
index|]
operator|==
literal|'*'
operator|)
condition|)
name|printf
argument_list|(
literal|", the exact type being the result of cross-promoting the\n\ types of all the arguments.\n\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
name|assert
argument_list|(
literal|"?0:?:"
operator|==
name|NULL
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|".\n\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|argno
operator|=
literal|0
operator|,
name|argc
operator|=
operator|&
name|c
index|[
name|colon
operator|+
literal|3
index|]
init|;
operator|*
name|argc
operator|!=
literal|'\0'
condition|;
operator|++
name|argno
control|)
block|{
name|char
name|optionality
init|=
literal|'\0'
decl_stmt|;
name|char
name|extra
init|=
literal|'\0'
decl_stmt|;
name|char
name|basic
decl_stmt|;
name|char
name|kind
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|elements
decl_stmt|;
name|printf
argument_list|(
literal|"\ @noindent\n\ @var{"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
operator|++
name|argc
control|)
block|{
if|if
condition|(
name|argc
index|[
literal|0
index|]
operator|==
literal|'='
condition|)
break|break;
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|argc
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"}: "
argument_list|)
expr_stmt|;
operator|++
name|argc
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argc
operator|==
literal|'?'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'!'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'*'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'n'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'p'
operator|)
condition|)
name|optionality
operator|=
operator|*
operator|(
name|argc
operator|++
operator|)
expr_stmt|;
name|basic
operator|=
operator|*
operator|(
name|argc
operator|++
operator|)
expr_stmt|;
name|kind
operator|=
operator|*
operator|(
name|argc
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|argc
operator|==
literal|'['
condition|)
block|{
name|length
operator|=
operator|*
operator|++
name|argc
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|argc
operator|!=
literal|']'
condition|)
name|length
operator|=
literal|10
operator|*
name|length
operator|+
operator|(
operator|*
operator|(
name|argc
operator|++
operator|)
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|argc
expr_stmt|;
block|}
else|else
name|length
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|argc
operator|==
literal|'('
condition|)
block|{
name|elements
operator|=
operator|*
operator|++
name|argc
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|argc
operator|!=
literal|')'
condition|)
name|elements
operator|=
literal|10
operator|*
name|elements
operator|+
operator|(
operator|*
operator|(
name|argc
operator|++
operator|)
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|argc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|argc
operator|==
literal|'&'
condition|)
block|{
name|elements
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|argc
expr_stmt|;
block|}
else|else
name|elements
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argc
operator|==
literal|'&'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'i'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'w'
operator|)
operator|||
operator|(
operator|*
name|argc
operator|==
literal|'x'
operator|)
condition|)
name|extra
operator|=
operator|*
operator|(
name|argc
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|argc
operator|==
literal|','
condition|)
operator|++
name|argc
expr_stmt|;
switch|switch
condition|(
name|basic
condition|)
block|{
case|case
literal|'-'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'*'
case|:
name|printf
argument_list|(
literal|"Any type"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"kind arg"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'A'
case|:
name|assert
argument_list|(
operator|(
name|kind
operator|==
literal|'1'
operator|)
operator|||
operator|(
name|kind
operator|==
literal|'*'
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"@code{CHARACTER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"*%d"
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'*'
case|:
name|printf
argument_list|(
literal|"@code{COMPLEX}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{COMPLEX(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|printf
argument_list|(
literal|"Same @samp{KIND=} value as for @var{%s}"
argument_list|,
name|argument_name_string
argument_list|(
name|imp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Ca"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'I'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'*'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER} with same @samp{KIND=} value as for @var{%s}"
argument_list|,
name|argument_name_string
argument_list|(
name|imp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER} not wider than the default kind"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Ia"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'L'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'*'
case|:
name|printf
argument_list|(
literal|"@code{LOGICAL}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{LOGICAL(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|printf
argument_list|(
literal|"@code{LOGICAL} with same @samp{KIND=} value as for @var{%s}"
argument_list|,
name|argument_name_string
argument_list|(
name|imp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|printf
argument_list|(
literal|"@code{LOGICAL} not wider than the default kind"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"La"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'R'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'*'
case|:
name|printf
argument_list|(
literal|"@code{REAL}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{REAL(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|printf
argument_list|(
literal|"@code{REAL} with same @samp{KIND=} value as for @var{%s}"
argument_list|,
name|argument_name_string
argument_list|(
name|imp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Ra"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'B'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'*'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER} or @code{LOGICAL}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER(KIND=%d)} or @code{LOGICAL(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|printf
argument_list|(
literal|"Same type and @samp{KIND=} value as for @var{%s}"
argument_list|,
name|argument_name_string
argument_list|(
name|imp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER} or @code{LOGICAL} not wider than the default kind"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Ba"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'F'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'*'
case|:
name|printf
argument_list|(
literal|"@code{REAL} or @code{COMPLEX}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{REAL(KIND=%d)} or @code{COMPLEX(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|printf
argument_list|(
literal|"Same type as @var{%s}"
argument_list|,
name|argument_name_string
argument_list|(
name|imp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Fa"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'N'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'*'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER}, @code{REAL}, or @code{COMPLEX}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER(KIND=%d)}, @code{REAL(KIND=%d)}, or @code{COMPLEX(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"N1"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'S'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'*'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER} or @code{REAL}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER(KIND=%d)} or @code{REAL(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER} or @code{REAL} with same @samp{KIND=} value as for @var{%s}"
argument_list|,
name|argument_name_string
argument_list|(
name|imp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Sa"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'g'
case|:
name|printf
argument_list|(
literal|"@samp{*@var{label}}, where @var{label} is the label\n\ of an executable statement"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|printf
argument_list|(
literal|"Signal handler (@code{INTEGER FUNCTION} or @code{SUBROUTINE})\n\ or dummy/global @code{INTEGER(KIND=1)} scalar"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"arg type?"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|optionality
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|'!'
case|:
name|printf
argument_list|(
literal|"; OPTIONAL (must be omitted if @var{%s} is @code{COMPLEX})"
argument_list|,
name|argument_name_string
argument_list|(
name|imp
argument_list|,
name|argno
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|printf
argument_list|(
literal|"; OPTIONAL"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|printf
argument_list|(
literal|"; OPTIONAL"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'+'
case|:
break|break;
case|case
literal|'p'
case|:
name|printf
argument_list|(
literal|"; at least two such arguments must be provided"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"optionality!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|elements
condition|)
block|{
case|case
operator|-
literal|1
case|:
break|break;
case|case
literal|0
case|:
if|if
condition|(
operator|(
name|basic
operator|!=
literal|'g'
operator|)
operator|&&
operator|(
name|basic
operator|!=
literal|'s'
operator|)
condition|)
name|printf
argument_list|(
literal|"; scalar"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|extra
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"; DIMENSION(%d)"
argument_list|,
name|elements
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|extra
condition|)
block|{
case|case
literal|'\0'
case|:
if|if
condition|(
operator|(
name|basic
operator|!=
literal|'g'
operator|)
operator|&&
operator|(
name|basic
operator|!=
literal|'s'
operator|)
condition|)
name|printf
argument_list|(
literal|"; INTENT(IN)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
break|break;
case|case
literal|'&'
case|:
name|printf
argument_list|(
literal|"; cannot be a constant or expression"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|printf
argument_list|(
literal|"; INTENT(OUT)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|printf
argument_list|(
literal|"; INTENT(INOUT)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|".\n\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\ @noindent\n\ Intrinsic groups: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|FFEINTRIN_familyF77
case|:
name|printf
argument_list|(
literal|"(standard FORTRAN 77)."
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINTRIN_familyGNU
case|:
name|printf
argument_list|(
literal|"@code{gnu}."
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINTRIN_familyASC
case|:
name|printf
argument_list|(
literal|"@code{f2c}, @code{f90}."
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINTRIN_familyMIL
case|:
name|printf
argument_list|(
literal|"@code{mil}, @code{f90}, @code{vxt}."
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINTRIN_familyF90
case|:
name|printf
argument_list|(
literal|"@code{f90}."
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINTRIN_familyVXT
case|:
name|printf
argument_list|(
literal|"@code{vxt}."
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINTRIN_familyFVZ
case|:
name|printf
argument_list|(
literal|"@code{f2c}, @code{vxt}."
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINTRIN_familyF2C
case|:
name|printf
argument_list|(
literal|"@code{f2c}."
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINTRIN_familyF2U
case|:
name|printf
argument_list|(
literal|"@code{unix}."
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINTRIN_familyBADU77
case|:
name|printf
argument_list|(
literal|"@code{badu77}."
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad family"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"@code{???}."
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|descriptions
index|[
name|imp
index|]
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|descriptions
index|[
name|imp
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"\ @noindent\n\ Description:\n\ \n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|==
literal|'@'
operator|&&
name|ISDIGIT
argument_list|(
name|c
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|int
name|argno
init|=
name|c
index|[
literal|1
index|]
operator|-
literal|'0'
decl_stmt|;
name|c
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
name|c
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|argno
operator|=
literal|10
operator|*
name|argno
operator|+
operator|(
name|c
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|assert
argument_list|(
name|c
index|[
literal|0
index|]
operator|==
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|argno
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|name_uc
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|argument_name_string
argument_list|(
name|imp
argument_list|,
name|argno
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fputc
argument_list|(
name|c
index|[
literal|0
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|argument_info_ptr
parameter_list|(
name|ffeintrinImp
name|imp
parameter_list|,
name|int
name|argno
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|imps
index|[
name|imp
index|]
operator|.
name|control
decl_stmt|;
specifier|static
name|char
name|arginfos
index|[
literal|8
index|]
index|[
literal|32
index|]
decl_stmt|;
specifier|static
name|int
name|argx
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|c
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
name|c
operator|+=
literal|5
expr_stmt|;
else|else
name|c
operator|+=
literal|6
expr_stmt|;
while|while
condition|(
name|argno
operator|--
condition|)
block|{
while|while
condition|(
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|','
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
operator|++
name|c
expr_stmt|;
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|!=
literal|','
condition|)
break|break;
operator|++
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
for|for
control|(
init|;
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'='
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|;
operator|++
name|c
control|)
empty_stmt|;
name|assert
argument_list|(
name|c
index|[
literal|0
index|]
operator|==
literal|'='
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
operator|++
name|c
init|;
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|','
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|;
operator|++
name|c
operator|,
operator|++
name|i
control|)
name|arginfos
index|[
name|argx
index|]
index|[
name|i
index|]
operator|=
name|c
index|[
literal|0
index|]
expr_stmt|;
name|arginfos
index|[
name|argx
index|]
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|=
operator|&
name|arginfos
index|[
name|argx
index|]
index|[
literal|0
index|]
expr_stmt|;
operator|++
name|argx
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|argx
operator|)
operator|>=
name|ARRAY_SIZE
argument_list|(
name|arginfos
argument_list|)
condition|)
name|argx
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|argument_info_string
parameter_list|(
name|ffeintrinImp
name|imp
parameter_list|,
name|int
name|argno
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|argument_info_ptr
argument_list|(
name|imp
argument_list|,
name|argno
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|argument_name_ptr
parameter_list|(
name|ffeintrinImp
name|imp
parameter_list|,
name|int
name|argno
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|imps
index|[
name|imp
index|]
operator|.
name|control
decl_stmt|;
specifier|static
name|char
name|argnames
index|[
literal|8
index|]
index|[
literal|32
index|]
decl_stmt|;
specifier|static
name|int
name|argx
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|c
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
name|c
operator|+=
literal|5
expr_stmt|;
else|else
name|c
operator|+=
literal|6
expr_stmt|;
while|while
condition|(
name|argno
operator|--
condition|)
block|{
while|while
condition|(
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|','
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
operator|++
name|c
expr_stmt|;
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|!=
literal|','
condition|)
break|break;
operator|++
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'='
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|;
operator|++
name|c
operator|,
operator|++
name|i
control|)
name|argnames
index|[
name|argx
index|]
index|[
name|i
index|]
operator|=
name|c
index|[
literal|0
index|]
expr_stmt|;
name|assert
argument_list|(
name|c
index|[
literal|0
index|]
operator|==
literal|'='
argument_list|)
expr_stmt|;
name|argnames
index|[
name|argx
index|]
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|=
operator|&
name|argnames
index|[
name|argx
index|]
index|[
literal|0
index|]
expr_stmt|;
operator|++
name|argx
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|argx
operator|)
operator|>=
name|ARRAY_SIZE
argument_list|(
name|argnames
argument_list|)
condition|)
name|argx
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|argument_name_string
parameter_list|(
name|ffeintrinImp
name|imp
parameter_list|,
name|int
name|argno
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|argument_name_ptr
argument_list|(
name|imp
argument_list|,
name|argno
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_type_string
parameter_list|(
specifier|const
name|char
modifier|*
name|c
parameter_list|)
block|{
name|char
name|basic
init|=
name|c
index|[
literal|0
index|]
decl_stmt|;
name|char
name|kind
init|=
name|c
index|[
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|basic
condition|)
block|{
case|case
literal|'A'
case|:
name|assert
argument_list|(
operator|(
name|kind
operator|==
literal|'1'
operator|)
operator|||
operator|(
name|kind
operator|==
literal|'='
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
name|printf
argument_list|(
literal|"@code{CHARACTER*1}"
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|c
index|[
literal|2
index|]
operator|==
literal|'*'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"@code{CHARACTER*(*)}"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'='
case|:
name|printf
argument_list|(
literal|"@code{COMPLEX}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{COMPLEX(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Ca"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'I'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'='
case|:
name|printf
argument_list|(
literal|"@code{INTEGER}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Ia"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'L'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'='
case|:
name|printf
argument_list|(
literal|"@code{LOGICAL}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{LOGICAL(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"La"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'R'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'='
case|:
name|printf
argument_list|(
literal|"@code{REAL}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{REAL(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|printf
argument_list|(
literal|"@code{REAL}"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Ra"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'B'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'='
case|:
name|printf
argument_list|(
literal|"@code{INTEGER} or @code{LOGICAL}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER(KIND=%d)} or @code{LOGICAL(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Ba"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'F'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'='
case|:
name|printf
argument_list|(
literal|"@code{REAL} or @code{COMPLEX}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{REAL(KIND=%d)} or @code{COMPLEX(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Fa"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'N'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'='
case|:
name|printf
argument_list|(
literal|"@code{INTEGER}, @code{REAL}, or @code{COMPLEX}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER(KIND=%d)}, @code{REAL(KIND=%d)}, or @code{COMPLEX(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"N1"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'S'
case|:
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'='
case|:
name|printf
argument_list|(
literal|"@code{INTEGER} or @code{REAL}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|printf
argument_list|(
literal|"@code{INTEGER(KIND=%d)} or @code{REAL(KIND=%d)}"
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|,
operator|(
name|kind
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Sa"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"type?"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

