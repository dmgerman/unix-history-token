begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* malloc.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       None     Description:       Fast pool-based memory allocation.     Modifications: */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_comment
comment|/* Externals defined here.  */
end_comment

begin_decl_stmt
name|struct
name|_malloc_root_
name|malloc_root_
init|=
block|{
block|{
operator|&
name|malloc_root_
operator|.
name|malloc_pool_image_
block|,
operator|&
name|malloc_root_
operator|.
name|malloc_pool_image_
block|,
operator|(
name|mallocPool
operator|)
operator|&
name|malloc_root_
operator|.
name|malloc_pool_image_
operator|.
name|eldest
block|,
operator|(
name|mallocPool
operator|)
operator|&
name|malloc_root_
operator|.
name|malloc_pool_image_
operator|.
name|eldest
block|,
operator|(
name|mallocArea_
operator|)
operator|&
name|malloc_root_
operator|.
name|malloc_pool_image_
operator|.
name|first
block|,
operator|(
name|mallocArea_
operator|)
operator|&
name|malloc_root_
operator|.
name|malloc_pool_image_
operator|.
name|first
block|,
literal|0
block|,
if|#
directive|if
name|MALLOC_DEBUG
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|'/'
block|}
else|#
directive|else
block|{
literal|0
block|}
endif|#
directive|endif
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|malloc_reserve_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For crashes. */
end_comment

begin_if
if|#
directive|if
name|MALLOC_DEBUG
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|malloc_types_
index|[]
init|=
block|{
literal|"KS"
block|,
literal|"KSR"
block|,
literal|"NF"
block|,
literal|"NFR"
block|,
literal|"US"
block|,
literal|"USR"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_function_decl
specifier|static
name|void
name|malloc_kill_area_
parameter_list|(
name|mallocPool
name|pool
parameter_list|,
name|mallocArea_
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|MALLOC_DEBUG
end_if

begin_function_decl
specifier|static
name|void
name|malloc_verify_area_
parameter_list|(
name|mallocPool
name|pool
parameter_list|,
name|mallocArea_
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Internal macros. */
end_comment

begin_if
if|#
directive|if
name|MALLOC_DEBUG
end_if

begin_define
define|#
directive|define
name|malloc_kill_
parameter_list|(
name|ptr
parameter_list|,
name|s
parameter_list|)
value|do {memset((ptr),127,(s));free((ptr));} while(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|malloc_kill_
parameter_list|(
name|ptr
parameter_list|,
name|s
parameter_list|)
value|free((ptr))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* malloc_kill_area_ -- Kill storage area and its object     malloc_kill_area_(mallocPool pool,mallocArea_ area);     Does the actual killing of a storage area.  */
end_comment

begin_function
specifier|static
name|void
name|malloc_kill_area_
parameter_list|(
name|mallocPool
name|pool
name|UNUSED
parameter_list|,
name|mallocArea_
name|a
parameter_list|)
block|{
if|#
directive|if
name|MALLOC_DEBUG
name|assert
argument_list|(
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|a
operator|->
name|where
operator|)
operator|)
operator|+
name|a
operator|->
name|size
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|malloc_kill_
argument_list|(
name|a
operator|->
name|where
argument_list|,
name|a
operator|->
name|size
argument_list|)
expr_stmt|;
name|a
operator|->
name|next
operator|->
name|previous
operator|=
name|a
operator|->
name|previous
expr_stmt|;
name|a
operator|->
name|previous
operator|->
name|next
operator|=
name|a
operator|->
name|next
expr_stmt|;
if|#
directive|if
name|MALLOC_DEBUG
name|pool
operator|->
name|freed
operator|+=
name|a
operator|->
name|size
expr_stmt|;
name|pool
operator|->
name|frees
operator|++
expr_stmt|;
endif|#
directive|endif
name|malloc_kill_
argument_list|(
name|a
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|_malloc_area_
argument_list|,
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|a
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* malloc_verify_area_ -- Verify storage area and its object     malloc_verify_area_(mallocPool pool,mallocArea_ area);     Does the actual verifying of a storage area.  */
end_comment

begin_if
if|#
directive|if
name|MALLOC_DEBUG
end_if

begin_function
specifier|static
name|void
name|malloc_verify_area_
parameter_list|(
name|mallocPool
name|pool
name|UNUSED
parameter_list|,
name|mallocArea_
name|a
name|UNUSED
parameter_list|)
block|{
name|mallocSize
name|s
init|=
name|a
operator|->
name|size
decl_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|a
operator|->
name|where
operator|)
operator|)
operator|+
name|s
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* malloc_init -- Initialize malloc cluster     malloc_init();     Call malloc_init before you do anything else.  */
end_comment

begin_function
name|void
name|malloc_init
parameter_list|()
block|{
if|if
condition|(
name|malloc_reserve_
operator|!=
name|NULL
condition|)
return|return;
name|malloc_reserve_
operator|=
name|xmalloc
argument_list|(
literal|20
operator|*
literal|1024
argument_list|)
expr_stmt|;
comment|/* In case of crash, free this first. */
block|}
end_function

begin_comment
comment|/* malloc_pool_display -- Display a pool     mallocPool p;    malloc_pool_display(p);     Displays information associated with the pool and its subpools.  */
end_comment

begin_function
name|void
name|malloc_pool_display
parameter_list|(
name|mallocPool
name|p
name|UNUSED
parameter_list|)
block|{
if|#
directive|if
name|MALLOC_DEBUG
name|mallocPool
name|q
decl_stmt|;
name|mallocArea_
name|a
decl_stmt|;
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"Pool \"%s\": bytes allocated=%lu, freed=%lu, old sizes=%lu, new sizes\ =%lu,\n   allocations=%lu, frees=%lu, resizes=%lu, uses=%lu\n   Subpools:\n"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|allocated
argument_list|,
name|p
operator|->
name|freed
argument_list|,
name|p
operator|->
name|old_sizes
argument_list|,
name|p
operator|->
name|new_sizes
argument_list|,
name|p
operator|->
name|allocations
argument_list|,
name|p
operator|->
name|frees
argument_list|,
name|p
operator|->
name|resizes
argument_list|,
name|p
operator|->
name|uses
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|eldest
init|;
name|q
operator|!=
operator|(
name|mallocPool
operator|)
operator|&
name|p
operator|->
name|eldest
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"      \"%s\"\n"
argument_list|,
name|q
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"   Storage areas:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|p
operator|->
name|first
init|;
name|a
operator|!=
operator|(
name|mallocArea_
operator|)
operator|&
name|p
operator|->
name|first
condition|;
name|a
operator|=
name|a
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"      "
argument_list|)
expr_stmt|;
name|malloc_display_
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* malloc_pool_kill -- Destroy a pool     mallocPool p;    malloc_pool_kill(p);     Releases all storage associated with the pool and its subpools.  */
end_comment

begin_function
name|void
name|malloc_pool_kill
parameter_list|(
name|mallocPool
name|p
parameter_list|)
block|{
name|mallocPool
name|q
decl_stmt|;
name|mallocArea_
name|a
decl_stmt|;
if|if
condition|(
operator|--
name|p
operator|->
name|uses
operator|!=
literal|0
condition|)
return|return;
if|#
directive|if
literal|0
block|malloc_pool_display (p);
endif|#
directive|endif
name|assert
argument_list|(
name|p
operator|->
name|next
operator|->
name|previous
operator|==
name|p
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|previous
operator|->
name|next
operator|==
name|p
argument_list|)
expr_stmt|;
comment|/* Kill off all the subpools. */
while|while
condition|(
operator|(
name|q
operator|=
name|p
operator|->
name|eldest
operator|)
operator|!=
operator|(
name|mallocPool
operator|)
operator|&
name|p
operator|->
name|eldest
condition|)
block|{
name|q
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
comment|/* Force the kill. */
name|malloc_pool_kill
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* Now free all the storage areas. */
while|while
condition|(
operator|(
name|a
operator|=
name|p
operator|->
name|first
operator|)
operator|!=
operator|(
name|mallocArea_
operator|)
operator|&
name|p
operator|->
name|first
condition|)
block|{
name|malloc_kill_area_
argument_list|(
name|p
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
comment|/* Now remove from list of sibling pools. */
name|p
operator|->
name|next
operator|->
name|previous
operator|=
name|p
operator|->
name|previous
expr_stmt|;
name|p
operator|->
name|previous
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
comment|/* Finally, free the pool itself. */
name|malloc_kill_
argument_list|(
name|p
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|_malloc_pool_
argument_list|,
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* malloc_pool_new -- Make a new pool     mallocPool p;    p = malloc_pool_new("My new pool",malloc_pool_image(),1024);     Makes a new pool with the given name and default new-chunk allocation.  */
end_comment

begin_function
name|mallocPool
name|malloc_pool_new
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|mallocPool
name|parent
parameter_list|,
name|unsigned
name|long
name|chunks
name|UNUSED
parameter_list|)
block|{
name|mallocPool
name|p
decl_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
name|parent
operator|=
name|malloc_pool_image
argument_list|()
expr_stmt|;
name|p
operator|=
name|malloc_new_
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|_malloc_pool_
argument_list|,
name|name
argument_list|)
operator|+
operator|(
name|MALLOC_DEBUG
condition|?
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|(
name|mallocPool
operator|)
operator|&
operator|(
name|parent
operator|->
name|eldest
operator|)
expr_stmt|;
name|p
operator|->
name|previous
operator|=
name|parent
operator|->
name|youngest
expr_stmt|;
name|parent
operator|->
name|youngest
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|parent
operator|->
name|youngest
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|eldest
operator|=
operator|(
name|mallocPool
operator|)
operator|&
operator|(
name|p
operator|->
name|eldest
operator|)
expr_stmt|;
name|p
operator|->
name|youngest
operator|=
operator|(
name|mallocPool
operator|)
operator|&
operator|(
name|p
operator|->
name|eldest
operator|)
expr_stmt|;
name|p
operator|->
name|first
operator|=
operator|(
name|mallocArea_
operator|)
operator|&
operator|(
name|p
operator|->
name|first
operator|)
expr_stmt|;
name|p
operator|->
name|last
operator|=
operator|(
name|mallocArea_
operator|)
operator|&
operator|(
name|p
operator|->
name|first
operator|)
expr_stmt|;
name|p
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|MALLOC_DEBUG
name|p
operator|->
name|allocated
operator|=
name|p
operator|->
name|freed
operator|=
name|p
operator|->
name|old_sizes
operator|=
name|p
operator|->
name|new_sizes
operator|=
name|p
operator|->
name|allocations
operator|=
name|p
operator|->
name|frees
operator|=
name|p
operator|->
name|resizes
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* malloc_pool_use -- Use an existing pool     mallocPool p;    p = malloc_pool_new(pool);     Increments use count for pool; means a matching malloc_pool_kill must    be performed before a subsequent one will actually kill the pool.  */
end_comment

begin_function
name|mallocPool
name|malloc_pool_use
parameter_list|(
name|mallocPool
name|pool
parameter_list|)
block|{
operator|++
name|pool
operator|->
name|uses
expr_stmt|;
return|return
name|pool
return|;
block|}
end_function

begin_comment
comment|/* malloc_display_ -- Display info on a mallocArea_     mallocArea_ a;    malloc_display_(a);     Simple.  */
end_comment

begin_function
name|void
name|malloc_display_
parameter_list|(
name|mallocArea_
name|a
name|UNUSED
parameter_list|)
block|{
if|#
directive|if
name|MALLOC_DEBUG
name|fprintf
argument_list|(
name|dmpout
argument_list|,
literal|"At %08lX, size=%"
name|mallocSize_f
literal|"u, type=%s, \"%s\"\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|a
operator|->
name|where
argument_list|,
name|a
operator|->
name|size
argument_list|,
name|malloc_types_
index|[
name|a
operator|->
name|type
index|]
argument_list|,
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* malloc_find_inpool_ -- Find mallocArea_ for object in pool     mallocPool pool;    void *ptr;    mallocArea_ a;    a = malloc_find_inpool_(pool,ptr);     Search for object in list of mallocArea_s, die if not found.	 */
end_comment

begin_function
name|mallocArea_
name|malloc_find_inpool_
parameter_list|(
name|mallocPool
name|pool
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|mallocArea_
name|a
decl_stmt|;
name|mallocArea_
name|b
init|=
operator|(
name|mallocArea_
operator|)
operator|&
name|pool
operator|->
name|first
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|a
operator|=
name|pool
operator|->
name|first
init|;
name|a
operator|!=
operator|(
name|mallocArea_
operator|)
operator|&
name|pool
operator|->
name|first
condition|;
name|a
operator|=
name|a
operator|->
name|next
control|)
block|{
name|assert
argument_list|(
operator|(
literal|"Infinite loop detected"
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|a
operator|!=
name|b
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|where
operator|==
name|ptr
condition|)
return|return
name|a
return|;
operator|++
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|&
literal|1
condition|)
name|b
operator|=
name|b
operator|->
name|next
expr_stmt|;
block|}
name|assert
argument_list|(
literal|"Couldn't find object in pool!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* malloc_kill_inpool_ -- Kill object     malloc_kill_inpool_(NULL,MALLOC_typeUS_,ptr,size_in_bytes);     Find the mallocArea_ for the pointer, make sure the type is proper, and    kill both of them.  */
end_comment

begin_function
name|void
name|malloc_kill_inpool_
parameter_list|(
name|mallocPool
name|pool
parameter_list|,
name|mallocType_
name|type
name|UNUSED
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|mallocSize
name|s
name|UNUSED
parameter_list|)
block|{
name|mallocArea_
name|a
decl_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
name|pool
operator|=
name|malloc_pool_image
argument_list|()
expr_stmt|;
if|#
directive|if
name|MALLOC_DEBUG
name|assert
argument_list|(
operator|(
name|pool
operator|==
name|malloc_pool_image
argument_list|()
operator|)
operator|||
name|malloc_pool_find_
argument_list|(
name|pool
argument_list|,
name|malloc_pool_image
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|a
operator|=
name|malloc_find_inpool_
argument_list|(
name|pool
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|#
directive|if
name|MALLOC_DEBUG
name|assert
argument_list|(
name|a
operator|->
name|type
operator|==
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
name|MALLOC_typeUS_
operator|)
operator|&&
operator|(
name|type
operator|!=
name|MALLOC_typeUSR_
operator|)
condition|)
name|assert
argument_list|(
name|a
operator|->
name|size
operator|==
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|malloc_kill_area_
argument_list|(
name|pool
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* malloc_new_ -- Allocate new object, die if unable     ptr = malloc_new_(size_in_bytes);     Call malloc, bomb if it returns NULL.  */
end_comment

begin_function
name|void
modifier|*
name|malloc_new_
parameter_list|(
name|mallocSize
name|s
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|ss
init|=
name|s
decl_stmt|;
if|#
directive|if
name|MALLOC_DEBUG
operator|&&
literal|0
name|assert
argument_list|(
name|s
operator|==
operator|(
name|mallocSize
operator|)
name|ss
argument_list|)
expr_stmt|;
comment|/* Else alloc is too big for this 				   library/sys. */
endif|#
directive|endif
name|ptr
operator|=
name|xmalloc
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|#
directive|if
name|MALLOC_DEBUG
name|memset
argument_list|(
name|ptr
argument_list|,
literal|126
argument_list|,
name|ss
argument_list|)
expr_stmt|;
comment|/* Catch some kinds of errors more 				   quickly/reliably. */
endif|#
directive|endif
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* malloc_new_inpool_ -- Allocate new object, die if unable     ptr = malloc_new_inpool_(NULL,MALLOC_typeUS_,"object",size_in_bytes);     Allocate the structure and allocate a mallocArea_ to describe it, then    add it to the list of mallocArea_s for the pool.  */
end_comment

begin_function
name|void
modifier|*
name|malloc_new_inpool_
parameter_list|(
name|mallocPool
name|pool
parameter_list|,
name|mallocType_
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|mallocSize
name|s
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|mallocArea_
name|a
decl_stmt|;
name|unsigned
name|short
name|i
decl_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
name|pool
operator|=
name|malloc_pool_image
argument_list|()
expr_stmt|;
if|#
directive|if
name|MALLOC_DEBUG
name|assert
argument_list|(
operator|(
name|pool
operator|==
name|malloc_pool_image
argument_list|()
operator|)
operator|||
name|malloc_pool_find_
argument_list|(
name|pool
argument_list|,
name|malloc_pool_image
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|malloc_new_
argument_list|(
name|s
operator|+
operator|(
name|i
operator|=
operator|(
name|MALLOC_DEBUG
condition|?
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|MALLOC_DEBUG
name|strcpy
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|ptr
operator|)
operator|)
operator|+
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|a
operator|=
name|malloc_new_
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|_malloc_area_
argument_list|,
name|name
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* A little optimization to speed up killing 				   of non-permanent stuff. */
case|case
name|MALLOC_typeKP_
case|:
case|case
name|MALLOC_typeKPR_
case|:
name|a
operator|->
name|next
operator|=
operator|(
name|mallocArea_
operator|)
operator|&
name|pool
operator|->
name|first
expr_stmt|;
break|break;
default|default:
name|a
operator|->
name|next
operator|=
name|pool
operator|->
name|first
expr_stmt|;
break|break;
block|}
name|a
operator|->
name|previous
operator|=
name|a
operator|->
name|next
operator|->
name|previous
expr_stmt|;
name|a
operator|->
name|next
operator|->
name|previous
operator|=
name|a
expr_stmt|;
name|a
operator|->
name|previous
operator|->
name|next
operator|=
name|a
expr_stmt|;
name|a
operator|->
name|where
operator|=
name|ptr
expr_stmt|;
if|#
directive|if
name|MALLOC_DEBUG
name|a
operator|->
name|size
operator|=
name|s
expr_stmt|;
name|a
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|strcpy
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pool
operator|->
name|allocated
operator|+=
name|s
expr_stmt|;
name|pool
operator|->
name|allocations
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* malloc_new_zinpool_ -- Allocate new zeroed object, die if unable     ptr = malloc_new_zinpool_(NULL,MALLOC_typeUS_,"object",size_in_bytes,0);     Like malloc_new_inpool_, but zeros out all the bytes in the area (assuming    you pass it a 0).  */
end_comment

begin_function
name|void
modifier|*
name|malloc_new_zinpool_
parameter_list|(
name|mallocPool
name|pool
parameter_list|,
name|mallocType_
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|mallocSize
name|s
parameter_list|,
name|int
name|z
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|malloc_new_inpool_
argument_list|(
name|pool
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
name|z
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* malloc_pool_find_ -- See if pool is a descendant of another pool     if (malloc_pool_find_(target_pool,parent_pool)) ...;     Recursive descent on each of the children of the parent pool, after    first checking the children themselves.  */
end_comment

begin_function
name|char
name|malloc_pool_find_
parameter_list|(
name|mallocPool
name|pool
parameter_list|,
name|mallocPool
name|parent
parameter_list|)
block|{
name|mallocPool
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|parent
operator|->
name|eldest
init|;
name|p
operator|!=
operator|(
name|mallocPool
operator|)
operator|&
name|parent
operator|->
name|eldest
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|==
name|pool
operator|)
operator|||
name|malloc_pool_find_
argument_list|(
name|pool
argument_list|,
name|p
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* malloc_resize_inpool_ -- Resize existing object in pool     ptr = malloc_resize_inpool_(NULL,MALLOC_typeUSR_,ptr,new_size,old_size);     Find the object's mallocArea_, check it out, then do the resizing.  */
end_comment

begin_function
name|void
modifier|*
name|malloc_resize_inpool_
parameter_list|(
name|mallocPool
name|pool
parameter_list|,
name|mallocType_
name|type
name|UNUSED
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|mallocSize
name|ns
parameter_list|,
name|mallocSize
name|os
name|UNUSED
parameter_list|)
block|{
name|mallocArea_
name|a
decl_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
name|pool
operator|=
name|malloc_pool_image
argument_list|()
expr_stmt|;
if|#
directive|if
name|MALLOC_DEBUG
name|assert
argument_list|(
operator|(
name|pool
operator|==
name|malloc_pool_image
argument_list|()
operator|)
operator|||
name|malloc_pool_find_
argument_list|(
name|pool
argument_list|,
name|malloc_pool_image
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|a
operator|=
name|malloc_find_inpool_
argument_list|(
name|pool
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|#
directive|if
name|MALLOC_DEBUG
name|assert
argument_list|(
name|a
operator|->
name|type
operator|==
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|MALLOC_typeKSR_
operator|)
operator|||
operator|(
name|type
operator|==
name|MALLOC_typeKPR_
operator|)
condition|)
name|assert
argument_list|(
name|a
operator|->
name|size
operator|==
name|os
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|ptr
operator|)
operator|)
operator|+
name|os
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|malloc_resize_
argument_list|(
name|ptr
argument_list|,
name|ns
operator|+
operator|(
name|MALLOC_DEBUG
condition|?
name|strlen
argument_list|(
name|a
operator|->
name|name
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|where
operator|=
name|ptr
expr_stmt|;
if|#
directive|if
name|MALLOC_DEBUG
name|a
operator|->
name|size
operator|=
name|ns
expr_stmt|;
name|strcpy
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|ptr
operator|)
operator|)
operator|+
name|ns
argument_list|,
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
name|pool
operator|->
name|old_sizes
operator|+=
name|os
expr_stmt|;
name|pool
operator|->
name|new_sizes
operator|+=
name|ns
expr_stmt|;
name|pool
operator|->
name|resizes
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* malloc_resize_ -- Reallocate object, die if unable     ptr = malloc_resize_(ptr,size_in_bytes);     Call realloc, bomb if it returns NULL.  */
end_comment

begin_function
name|void
modifier|*
name|malloc_resize_
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|mallocSize
name|s
parameter_list|)
block|{
name|int
name|ss
init|=
name|s
decl_stmt|;
if|#
directive|if
name|MALLOC_DEBUG
operator|&&
literal|0
name|assert
argument_list|(
name|s
operator|==
operator|(
name|mallocSize
operator|)
name|ss
argument_list|)
expr_stmt|;
comment|/* Too big if failure here. */
endif|#
directive|endif
name|ptr
operator|=
name|xrealloc
argument_list|(
name|ptr
argument_list|,
name|ss
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* malloc_verify_inpool_ -- Verify object     Find the mallocArea_ for the pointer, make sure the type is proper, and    verify both of them.  */
end_comment

begin_function
name|void
name|malloc_verify_inpool_
parameter_list|(
name|mallocPool
name|pool
name|UNUSED
parameter_list|,
name|mallocType_
name|type
name|UNUSED
parameter_list|,
name|void
modifier|*
name|ptr
name|UNUSED
parameter_list|,
name|mallocSize
name|s
name|UNUSED
parameter_list|)
block|{
if|#
directive|if
name|MALLOC_DEBUG
name|mallocArea_
name|a
decl_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
name|pool
operator|=
name|malloc_pool_image
argument_list|()
expr_stmt|;
name|assert
argument_list|(
operator|(
name|pool
operator|==
name|malloc_pool_image
argument_list|()
operator|)
operator|||
name|malloc_pool_find_
argument_list|(
name|pool
argument_list|,
name|malloc_pool_image
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|malloc_find_inpool_
argument_list|(
name|pool
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|a
operator|->
name|type
operator|==
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
name|MALLOC_typeUS_
operator|)
operator|&&
operator|(
name|type
operator|!=
name|MALLOC_typeUSR_
operator|)
condition|)
name|assert
argument_list|(
name|a
operator|->
name|size
operator|==
name|s
argument_list|)
expr_stmt|;
name|malloc_verify_area_
argument_list|(
name|pool
argument_list|,
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

