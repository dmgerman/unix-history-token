begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* expr.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995-1998 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       None.     Description:       Handles syntactic and semantic analysis of Fortran expressions.     Modifications: */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"bad.h"
end_include

begin_include
include|#
directive|include
file|"bld.h"
end_include

begin_include
include|#
directive|include
file|"com.h"
end_include

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"implic.h"
end_include

begin_include
include|#
directive|include
file|"intrin.h"
end_include

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"src.h"
end_include

begin_include
include|#
directive|include
file|"st.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_include
include|#
directive|include
file|"str.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"where.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|FFEEXPR_exprtypeUNKNOWN_
block|,
name|FFEEXPR_exprtypeOPERAND_
block|,
name|FFEEXPR_exprtypeUNARY_
block|,
name|FFEEXPR_exprtypeBINARY_
block|,
name|FFEEXPR_exprtype_
block|}
name|ffeexprExprtype_
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|FFEEXPR_operatorPOWER_
block|,
name|FFEEXPR_operatorMULTIPLY_
block|,
name|FFEEXPR_operatorDIVIDE_
block|,
name|FFEEXPR_operatorADD_
block|,
name|FFEEXPR_operatorSUBTRACT_
block|,
name|FFEEXPR_operatorCONCATENATE_
block|,
name|FFEEXPR_operatorLT_
block|,
name|FFEEXPR_operatorLE_
block|,
name|FFEEXPR_operatorEQ_
block|,
name|FFEEXPR_operatorNE_
block|,
name|FFEEXPR_operatorGT_
block|,
name|FFEEXPR_operatorGE_
block|,
name|FFEEXPR_operatorNOT_
block|,
name|FFEEXPR_operatorAND_
block|,
name|FFEEXPR_operatorOR_
block|,
name|FFEEXPR_operatorXOR_
block|,
name|FFEEXPR_operatorEQV_
block|,
name|FFEEXPR_operatorNEQV_
block|,
name|FFEEXPR_operator_
block|}
name|ffeexprOperator_
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|FFEEXPR_operatorprecedenceHIGHEST_
init|=
literal|1
block|,
name|FFEEXPR_operatorprecedencePOWER_
init|=
literal|1
block|,
name|FFEEXPR_operatorprecedenceMULTIPLY_
init|=
literal|2
block|,
name|FFEEXPR_operatorprecedenceDIVIDE_
init|=
literal|2
block|,
name|FFEEXPR_operatorprecedenceADD_
init|=
literal|3
block|,
name|FFEEXPR_operatorprecedenceSUBTRACT_
init|=
literal|3
block|,
name|FFEEXPR_operatorprecedenceLOWARITH_
init|=
literal|3
block|,
name|FFEEXPR_operatorprecedenceCONCATENATE_
init|=
literal|3
block|,
name|FFEEXPR_operatorprecedenceLT_
init|=
literal|4
block|,
name|FFEEXPR_operatorprecedenceLE_
init|=
literal|4
block|,
name|FFEEXPR_operatorprecedenceEQ_
init|=
literal|4
block|,
name|FFEEXPR_operatorprecedenceNE_
init|=
literal|4
block|,
name|FFEEXPR_operatorprecedenceGT_
init|=
literal|4
block|,
name|FFEEXPR_operatorprecedenceGE_
init|=
literal|4
block|,
name|FFEEXPR_operatorprecedenceNOT_
init|=
literal|5
block|,
name|FFEEXPR_operatorprecedenceAND_
init|=
literal|6
block|,
name|FFEEXPR_operatorprecedenceOR_
init|=
literal|7
block|,
name|FFEEXPR_operatorprecedenceXOR_
init|=
literal|8
block|,
name|FFEEXPR_operatorprecedenceEQV_
init|=
literal|8
block|,
name|FFEEXPR_operatorprecedenceNEQV_
init|=
literal|8
block|,
name|FFEEXPR_operatorprecedenceLOWEST_
init|=
literal|8
block|,
name|FFEEXPR_operatorprecedence_
block|}
name|ffeexprOperatorPrecedence_
typedef|;
end_typedef

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityL2R_
value|TRUE
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityR2L_
value|FALSE
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityPOWER_
value|FFEEXPR_operatorassociativityR2L_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityMULTIPLY_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityDIVIDE_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityADD_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativitySUBTRACT_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityCONCATENATE_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityLT_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityLE_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityEQ_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityNE_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityGT_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityGE_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityNOT_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityAND_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityOR_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityXOR_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityEQV_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_define
define|#
directive|define
name|FFEEXPR_operatorassociativityNEQV_
value|FFEEXPR_operatorassociativityL2R_
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|FFEEXPR_parentypeFUNCTION_
block|,
name|FFEEXPR_parentypeSUBROUTINE_
block|,
name|FFEEXPR_parentypeARRAY_
block|,
name|FFEEXPR_parentypeSUBSTRING_
block|,
name|FFEEXPR_parentypeFUNSUBSTR_
block|,
comment|/* Ambig: check for colon after first expr. */
name|FFEEXPR_parentypeEQUIVALENCE_
block|,
comment|/* Ambig: ARRAY_ or SUBSTRING_. */
name|FFEEXPR_parentypeANY_
block|,
comment|/* Allow basically anything. */
name|FFEEXPR_parentype_
block|}
name|ffeexprParenType_
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|FFEEXPR_percentNONE_
block|,
name|FFEEXPR_percentLOC_
block|,
name|FFEEXPR_percentVAL_
block|,
name|FFEEXPR_percentREF_
block|,
name|FFEEXPR_percentDESCR_
block|,
name|FFEEXPR_percent_
block|}
name|ffeexprPercent_
typedef|;
end_typedef

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|_ffeexpr_expr_
modifier|*
name|ffeexprExpr_
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|bool
name|ffeexprOperatorAssociativity_
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|_ffeexpr_stack_
modifier|*
name|ffeexprStack_
typedef|;
end_typedef

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_struct
struct|struct
name|_ffeexpr_expr_
block|{
name|ffeexprExpr_
name|previous
decl_stmt|;
name|ffelexToken
name|token
decl_stmt|;
name|ffeexprExprtype_
name|type
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|ffeexprOperator_
name|op
decl_stmt|;
name|ffeexprOperatorPrecedence_
name|prec
decl_stmt|;
name|ffeexprOperatorAssociativity_
name|as
decl_stmt|;
block|}
name|operator
struct|;
name|ffebld
name|operand
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_ffeexpr_stack_
block|{
name|ffeexprStack_
name|previous
decl_stmt|;
name|mallocPool
name|pool
decl_stmt|;
name|ffeexprContext
name|context
decl_stmt|;
name|ffeexprCallback
name|callback
decl_stmt|;
name|ffelexToken
name|first_token
decl_stmt|;
name|ffeexprExpr_
name|exprstack
decl_stmt|;
name|ffelexToken
name|tokens
index|[
literal|10
index|]
decl_stmt|;
comment|/* Used in certain cases, like (unary) 				   open-paren. */
name|ffebld
name|expr
decl_stmt|;
comment|/* For first of 				   complex/implied-do/substring/array-elements 				   / actual-args expression. */
name|ffebld
name|bound_list
decl_stmt|;
comment|/* For tracking dimension bounds list of 				   array. */
name|ffebldListBottom
name|bottom
decl_stmt|;
comment|/* For building lists. */
name|ffeinfoRank
name|rank
decl_stmt|;
comment|/* For elements in an array reference. */
name|bool
name|constant
decl_stmt|;
comment|/* TRUE while elements seen so far are 				   constants. */
name|bool
name|immediate
decl_stmt|;
comment|/* TRUE while elements seen so far are 				   immediate/constants. */
name|ffebld
name|next_dummy
decl_stmt|;
comment|/* Next SFUNC dummy arg in arg list. */
name|ffebldListLength
name|num_args
decl_stmt|;
comment|/* Number of dummy args expected in arg list. */
name|bool
name|is_rhs
decl_stmt|;
comment|/* TRUE if rhs context, FALSE otherwise. */
name|ffeexprPercent_
name|percent
decl_stmt|;
comment|/* Current %FOO keyword. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_ffeexpr_find_
block|{
name|ffelexToken
name|t
decl_stmt|;
name|ffelexHandler
name|after
decl_stmt|;
name|int
name|level
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_decl_stmt
specifier|static
name|ffeexprStack_
name|ffeexpr_stack_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expression stack for semantic. */
end_comment

begin_decl_stmt
specifier|static
name|ffelexToken
name|ffeexpr_tokens_
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scratchpad tokens for syntactic. */
end_comment

begin_decl_stmt
specifier|static
name|ffestrOther
name|ffeexpr_current_dotdot_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current .FOO. keyword. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|ffeexpr_hollerith_count_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ffeexpr_token_number_ and caller. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ffeexpr_level_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Level of DATA implied-DO construct. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffeexpr_is_substr_ok_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If OPEN_PAREN as binary "op" ok. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|_ffeexpr_find_
name|ffeexpr_find_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_close_paren_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_close_paren_ambig_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_close_paren_ambig_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_close_paren_c_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_c_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_close_paren_ci_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_ci_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_i_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_i_1_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_i_2_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_i_3_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_i_4_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_i_5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_end_loc_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_end_notloc_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_cb_end_notloc_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffeexpr_check_impctrl_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeexpr_check_impdo_
parameter_list|(
name|ffebld
name|list
parameter_list|,
name|ffelexToken
name|list_t
parameter_list|,
name|ffebld
name|dovar
parameter_list|,
name|ffelexToken
name|dovar_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeexpr_update_impdo_
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffebld
name|dovar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeexpr_update_impdo_sym_
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffesymbol
name|dovar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffeexprContext
name|ffeexpr_context_outer_
parameter_list|(
name|ffeexprStack_
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffeexprExpr_
name|ffeexpr_expr_new_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeexpr_fulfill_call_
parameter_list|(
name|ffebld
modifier|*
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffeexpr_isdigits_
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_lhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_lhs_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_rhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_rhs_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_rhs_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_rhs_3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_rhs_4_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_rhs_5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_rhs_6_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_namelist_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeexpr_expr_kill_
parameter_list|(
name|ffeexprExpr_
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeexpr_exprstack_push_
parameter_list|(
name|ffeexprExpr_
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeexpr_exprstack_push_binary_
parameter_list|(
name|ffeexprExpr_
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeexpr_exprstack_push_operand_
parameter_list|(
name|ffeexprExpr_
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeexpr_exprstack_push_unary_
parameter_list|(
name|ffeexprExpr_
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeexpr_reduce_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffebld
name|ffeexpr_reduced_bool1_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffebld
name|ffeexpr_reduced_bool2_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffebld
name|ffeexpr_reduced_concatenate_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffebld
name|ffeexpr_reduced_eqop2_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffebld
name|ffeexpr_reduced_math1_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffebld
name|ffeexpr_reduced_math2_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffebld
name|ffeexpr_reduced_power_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffebld
name|ffeexpr_reduced_relop2_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffebld
name|ffeexpr_reduced_ugly1_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffebld
name|ffeexpr_reduced_ugly1log_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffebld
name|ffeexpr_reduced_ugly2_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffebld
name|ffeexpr_reduced_ugly2log_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_find_close_paren_
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|ffelexHandler
name|after
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_finished_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_rhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_end_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_swallow_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_real_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_real_exponent_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_real_exp_sign_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_number_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_number_exponent_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_number_exp_sign_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_number_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_number_per_exp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_number_real_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_num_per_exp_sign_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_number_real_exp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_num_real_exp_sn_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_binary_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_binary_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_binary_end_per_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_binary_sw_per_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_quote_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_apostrophe_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_apos_char_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_name_rhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_name_apos_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_name_apos_name_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_percent_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_percent_name_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_nil_substrp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_finished_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffebld
name|ffeexpr_finished_ambig_
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|ffebld
name|expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_lhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_rhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_binary_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_end_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_swallow_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_real_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_real_exponent_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_real_exp_sign_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_number_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_number_exponent_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_number_exp_sign_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_number_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_number_per_exp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_number_real_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_num_per_exp_sign_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_number_real_exp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_num_real_exp_sn_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_binary_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_binary_end_per_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_binary_sw_per_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_quote_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_apostrophe_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_apos_char_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_name_lhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_name_arg_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_name_rhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_name_apos_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_name_apos_name_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_percent_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_percent_name_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_arguments_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_elements_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_equivalence_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_substring_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_substring_1_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_substrp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_intrincheck_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_funsubstr_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffelexHandler
name|ffeexpr_token_anything_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffeexpr_make_float_const_
parameter_list|(
name|char
name|exp_letter
parameter_list|,
name|ffelexToken
name|integer
parameter_list|,
name|ffelexToken
name|decimal
parameter_list|,
name|ffelexToken
name|fraction
parameter_list|,
name|ffelexToken
name|exponent
parameter_list|,
name|ffelexToken
name|exponent_sign
parameter_list|,
name|ffelexToken
name|exponent_digits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffeexpr_declare_unadorned_
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|bool
name|maybe_intrin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffeexpr_sym_impdoitem_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffeexpr_sym_lhs_call_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffeexpr_sym_lhs_data_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffeexpr_sym_lhs_equivalence_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffeexpr_sym_lhs_extfunc_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffeexpr_sym_lhs_impdoctrl_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffeexpr_sym_lhs_parameter_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffeexpr_sym_rhs_actualarg_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffeexpr_sym_rhs_dimlist_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffeexpr_sym_rhs_let_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffeexpr_declare_parenthesized_
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|bool
name|maybe_intrin
parameter_list|,
name|ffeexprParenType_
modifier|*
name|paren_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffesymbol
name|ffeexpr_paren_rhs_let_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Internal macros. */
end_comment

begin_define
define|#
directive|define
name|ffeexpr_paren_lhs_let_
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
value|ffeexpr_sym_rhs_let_(s,t)
end_define

begin_define
define|#
directive|define
name|ffeexpr_sym_lhs_let_
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
value|ffeexpr_sym_rhs_let_(s,t)
end_define

begin_escape
end_escape

begin_comment
comment|/* ffeexpr_collapse_convert -- Collapse convert expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_convert(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_convert
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebldConstantUnion
name|u
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|ffetargetCharacterSize
name|sz
decl_stmt|;
name|ffetargetCharacterSize
name|sz2
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
name|sz
operator|=
name|FFETARGET_charactersizeNONE
expr_stmt|;
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_integer1_integer2
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_integer1_integer3
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_integer1_integer4
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER1/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_integer1_real1
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_integer1_real2
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_integer1_real3
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_integer1_real4
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER1/REAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_integer1_complex1
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_integer1_complex2
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_integer1_complex3
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_integer1_complex4
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER1/COMPLEX bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|error
operator|=
name|ffetarget_convert_integer1_logical1
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|error
operator|=
name|ffetarget_convert_integer1_logical2
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|error
operator|=
name|ffetarget_convert_integer1_logical3
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|error
operator|=
name|ffetarget_convert_integer1_logical4
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER1/LOGICAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_integer1_character1
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_integer1_hollerith
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_integer1_typeless
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"INTEGER1 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer1_val
argument_list|(
name|ffebld_cu_val_integer1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_integer2_integer1
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_integer2_integer3
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_integer2_integer4
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER2/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_integer2_real1
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_integer2_real2
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_integer2_real3
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_integer2_real4
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER2/REAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_integer2_complex1
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_integer2_complex2
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_integer2_complex3
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_integer2_complex4
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER2/COMPLEX bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|error
operator|=
name|ffetarget_convert_integer2_logical1
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|error
operator|=
name|ffetarget_convert_integer2_logical2
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|error
operator|=
name|ffetarget_convert_integer2_logical3
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|error
operator|=
name|ffetarget_convert_integer2_logical4
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER2/LOGICAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_integer2_character1
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_integer2_hollerith
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_integer2_typeless
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"INTEGER2 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer2_val
argument_list|(
name|ffebld_cu_val_integer2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_integer3_integer1
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_integer3_integer2
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_integer3_integer4
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER3/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_integer3_real1
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_integer3_real2
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_integer3_real3
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_integer3_real4
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER3/REAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_integer3_complex1
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_integer3_complex2
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_integer3_complex3
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_integer3_complex4
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER3/COMPLEX bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|error
operator|=
name|ffetarget_convert_integer3_logical1
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|error
operator|=
name|ffetarget_convert_integer3_logical2
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|error
operator|=
name|ffetarget_convert_integer3_logical3
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|error
operator|=
name|ffetarget_convert_integer3_logical4
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER3/LOGICAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_integer3_character1
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_integer3_hollerith
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_integer3_typeless
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"INTEGER3 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer3_val
argument_list|(
name|ffebld_cu_val_integer3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_integer4_integer1
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_integer4_integer2
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_integer4_integer3
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER4/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_integer4_real1
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_integer4_real2
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_integer4_real3
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_integer4_real4
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER4/REAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_integer4_complex1
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_integer4_complex2
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_integer4_complex3
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_integer4_complex4
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER3/COMPLEX bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|error
operator|=
name|ffetarget_convert_integer4_logical1
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|error
operator|=
name|ffetarget_convert_integer4_logical2
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|error
operator|=
name|ffetarget_convert_integer4_logical3
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|error
operator|=
name|ffetarget_convert_integer4_logical4
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"INTEGER4/LOGICAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_integer4_character1
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_integer4_hollerith
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_integer4_typeless
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"INTEGER4 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer4_val
argument_list|(
name|ffebld_cu_val_integer4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|sz
operator|=
name|FFETARGET_charactersizeNONE
expr_stmt|;
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|error
operator|=
name|ffetarget_convert_logical1_logical2
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|error
operator|=
name|ffetarget_convert_logical1_logical3
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|error
operator|=
name|ffetarget_convert_logical1_logical4
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"LOGICAL1/LOGICAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_logical1_integer1
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_logical1_integer2
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_logical1_integer3
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_logical1_integer4
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"LOGICAL1/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_logical1_character1
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_logical1_hollerith
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_logical1_typeless
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"LOGICAL1 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical1_val
argument_list|(
name|ffebld_cu_val_logical1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|error
operator|=
name|ffetarget_convert_logical2_logical1
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|error
operator|=
name|ffetarget_convert_logical2_logical3
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|error
operator|=
name|ffetarget_convert_logical2_logical4
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"LOGICAL2/LOGICAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_logical2_integer1
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_logical2_integer2
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_logical2_integer3
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_logical2_integer4
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"LOGICAL2/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_logical2_character1
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_logical2_hollerith
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_logical2_typeless
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"LOGICAL2 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical2_val
argument_list|(
name|ffebld_cu_val_logical2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|error
operator|=
name|ffetarget_convert_logical3_logical1
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|error
operator|=
name|ffetarget_convert_logical3_logical2
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|error
operator|=
name|ffetarget_convert_logical3_logical4
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"LOGICAL3/LOGICAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_logical3_integer1
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_logical3_integer2
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_logical3_integer3
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_logical3_integer4
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"LOGICAL3/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_logical3_character1
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_logical3_hollerith
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_logical3_typeless
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"LOGICAL3 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical3_val
argument_list|(
name|ffebld_cu_val_logical3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|error
operator|=
name|ffetarget_convert_logical4_logical1
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|error
operator|=
name|ffetarget_convert_logical4_logical2
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|error
operator|=
name|ffetarget_convert_logical4_logical3
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"LOGICAL4/LOGICAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_logical4_integer1
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_logical4_integer2
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_logical4_integer3
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_logical4_integer4
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"LOGICAL4/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_logical4_character1
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_logical4_hollerith
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_logical4_typeless
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"LOGICAL4 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical4_val
argument_list|(
name|ffebld_cu_val_logical4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad logical kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
name|sz
operator|=
name|FFETARGET_charactersizeNONE
expr_stmt|;
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_real1_integer1
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_real1_integer2
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_real1_integer3
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_real1_integer4
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"REAL1/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_real1_real2
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_real1_real3
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_real1_real4
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"REAL1/REAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_real1_complex1
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_real1_complex2
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_real1_complex3
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_real1_complex4
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"REAL1/COMPLEX bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_real1_character1
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_real1_hollerith
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_real1_typeless
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"REAL1 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real1_val
argument_list|(
name|ffebld_cu_val_real1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_real2_integer1
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_real2_integer2
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_real2_integer3
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_real2_integer4
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"REAL2/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_real2_real1
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_real2_real3
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_real2_real4
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"REAL2/REAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_real2_complex1
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_real2_complex2
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_real2_complex3
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_real2_complex4
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"REAL2/COMPLEX bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_real2_character1
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_real2_hollerith
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_real2_typeless
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"REAL2 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real2_val
argument_list|(
name|ffebld_cu_val_real2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_real3_integer1
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_real3_integer2
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_real3_integer3
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_real3_integer4
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"REAL3/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_real3_real1
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_real3_real2
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_real3_real4
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"REAL3/REAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_real3_complex1
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_real3_complex2
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_real3_complex3
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_real3_complex4
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"REAL3/COMPLEX bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_real3_character1
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_real3_hollerith
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_real3_typeless
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"REAL3 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real3_val
argument_list|(
name|ffebld_cu_val_real3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_real4_integer1
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_real4_integer2
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_real4_integer3
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_real4_integer4
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"REAL4/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_real4_real1
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_real4_real2
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_real4_real3
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"REAL4/REAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_real4_complex1
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_real4_complex2
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_real4_complex3
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_real4_complex4
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"REAL4/COMPLEX bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_real4_character1
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_real4_hollerith
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_real4_typeless
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"REAL4 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real4_val
argument_list|(
name|ffebld_cu_val_real4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad real kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
name|sz
operator|=
name|FFETARGET_charactersizeNONE
expr_stmt|;
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_complex1_integer1
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_complex1_integer2
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_complex1_integer3
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_complex1_integer4
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"COMPLEX1/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_complex1_real1
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_complex1_real2
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_complex1_real3
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_complex1_real4
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"COMPLEX1/REAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_complex1_complex2
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_complex1_complex3
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_complex1_complex4
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"COMPLEX1/COMPLEX bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_complex1_character1
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_complex1_hollerith
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_complex1_typeless
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"COMPLEX1 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex1_val
argument_list|(
name|ffebld_cu_val_complex1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_complex2_integer1
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_complex2_integer2
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_complex2_integer3
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_complex2_integer4
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"COMPLEX2/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_complex2_real1
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_complex2_real2
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_complex2_real3
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_complex2_real4
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"COMPLEX2/REAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_complex2_complex1
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_complex2_complex3
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_complex2_complex4
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"COMPLEX2/COMPLEX bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_complex2_character1
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_complex2_hollerith
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_complex2_typeless
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"COMPLEX2 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex2_val
argument_list|(
name|ffebld_cu_val_complex2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_complex3_integer1
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_complex3_integer2
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_complex3_integer3
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_complex3_integer4
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"COMPLEX3/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_complex3_real1
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_complex3_real2
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_complex3_real3
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_complex3_real4
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"COMPLEX3/REAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_complex3_complex1
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_complex3_complex2
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_complex3_complex4
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"COMPLEX3/COMPLEX bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_complex3_character1
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_complex3_hollerith
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_complex3_typeless
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"COMPLEX3 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex3_val
argument_list|(
name|ffebld_cu_val_complex3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_complex4_integer1
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_complex4_integer2
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_complex4_integer3
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_complex4_integer4
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"COMPLEX4/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_complex4_real1
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_complex4_real2
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_complex4_real3
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_convert_complex4_real4
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"COMPLEX4/REAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_convert_complex4_complex1
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_convert_complex4_complex2
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_convert_complex4_complex3
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"COMPLEX4/COMPLEX bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|ffetarget_convert_complex4_character1
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_complex4_hollerith
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_complex4_typeless
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"COMPLEX4 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If conversion operation is not implemented, return original expr.  */
if|if
condition|(
name|error
operator|==
name|FFEBAD_NOCANDO
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex4_val
argument_list|(
name|ffebld_cu_val_complex4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad complex kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
if|if
condition|(
operator|(
name|sz
operator|=
name|ffebld_size
argument_list|(
name|expr
argument_list|)
operator|)
operator|==
name|FFETARGET_charactersizeNONE
condition|)
return|return
name|expr
return|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeCHARACTER
case|:
if|if
condition|(
operator|(
name|sz2
operator|=
name|ffebld_size
argument_list|(
name|l
argument_list|)
operator|)
operator|==
name|FFETARGET_charactersizeNONE
condition|)
return|return
name|expr
return|;
name|assert
argument_list|(
name|kt
operator|==
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sz2
operator|==
name|ffetarget_length_character1
argument_list|(
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ffetarget_convert_character1_character1
argument_list|(
name|ffebld_cu_ptr_character1
argument_list|(
name|u
argument_list|)
argument_list|,
name|sz
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_convert_character1_integer1
argument_list|(
name|ffebld_cu_ptr_character1
argument_list|(
name|u
argument_list|)
argument_list|,
name|sz
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_convert_character1_integer2
argument_list|(
name|ffebld_cu_ptr_character1
argument_list|(
name|u
argument_list|)
argument_list|,
name|sz
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_convert_character1_integer3
argument_list|(
name|ffebld_cu_ptr_character1
argument_list|(
name|u
argument_list|)
argument_list|,
name|sz
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_convert_character1_integer4
argument_list|(
name|ffebld_cu_ptr_character1
argument_list|(
name|u
argument_list|)
argument_list|,
name|sz
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"CHARACTER1/INTEGER bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|error
operator|=
name|ffetarget_convert_character1_logical1
argument_list|(
name|ffebld_cu_ptr_character1
argument_list|(
name|u
argument_list|)
argument_list|,
name|sz
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|error
operator|=
name|ffetarget_convert_character1_logical2
argument_list|(
name|ffebld_cu_ptr_character1
argument_list|(
name|u
argument_list|)
argument_list|,
name|sz
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|error
operator|=
name|ffetarget_convert_character1_logical3
argument_list|(
name|ffebld_cu_ptr_character1
argument_list|(
name|u
argument_list|)
argument_list|,
name|sz
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|error
operator|=
name|ffetarget_convert_character1_logical4
argument_list|(
name|ffebld_cu_ptr_character1
argument_list|(
name|u
argument_list|)
argument_list|,
name|sz
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"CHARACTER1/LOGICAL bad source kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|error
operator|=
name|ffetarget_convert_character1_hollerith
argument_list|(
name|ffebld_cu_ptr_character1
argument_list|(
name|u
argument_list|)
argument_list|,
name|sz
argument_list|,
name|ffebld_constant_hollerith
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|ffetarget_convert_character1_typeless
argument_list|(
name|ffebld_cu_ptr_character1
argument_list|(
name|u
argument_list|)
argument_list|,
name|sz
argument_list|,
name|ffebld_constant_typeless
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"CHARACTER1 bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_character1_val
argument_list|(
name|ffebld_cu_val_character1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad character kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|sz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_paren -- Collapse paren expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_paren(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_paren
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
name|UNUSED
parameter_list|)
block|{
name|ffebld
name|r
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|ffetargetCharacterSize
name|len
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|r
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|ffebld_size
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_copy
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_uplus -- Collapse uplus expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_uplus(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_uplus
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
name|UNUSED
parameter_list|)
block|{
name|ffebld
name|r
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|ffetargetCharacterSize
name|len
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|r
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|ffebld_size
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_copy
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_uminus -- Collapse uminus expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_uminus(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_uminus
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|ffebldConstantUnion
name|u
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|r
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_uminus_integer1
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer1_val
argument_list|(
name|ffebld_cu_val_integer1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_uminus_integer2
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer2_val
argument_list|(
name|ffebld_cu_val_integer2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_uminus_integer3
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer3_val
argument_list|(
name|ffebld_cu_val_integer3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_uminus_integer4
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer4_val
argument_list|(
name|ffebld_cu_val_integer4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_uminus_real1
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real1_val
argument_list|(
name|ffebld_cu_val_real1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_uminus_real2
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real2_val
argument_list|(
name|ffebld_cu_val_real2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_uminus_real3
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real3_val
argument_list|(
name|ffebld_cu_val_real3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_uminus_real4
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real4_val
argument_list|(
name|ffebld_cu_val_real4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad real kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_uminus_complex1
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex1_val
argument_list|(
name|ffebld_cu_val_complex1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_uminus_complex2
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex2_val
argument_list|(
name|ffebld_cu_val_complex2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_uminus_complex3
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex3_val
argument_list|(
name|ffebld_cu_val_complex3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_uminus_complex4
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex4_val
argument_list|(
name|ffebld_cu_val_complex4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad complex kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_not -- Collapse not expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_not(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_not
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|ffebldConstantUnion
name|u
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|r
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_not_integer1
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer1_val
argument_list|(
name|ffebld_cu_val_integer1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_not_integer2
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer2_val
argument_list|(
name|ffebld_cu_val_integer2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_not_integer3
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer3_val
argument_list|(
name|ffebld_cu_val_integer3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_not_integer4
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer4_val
argument_list|(
name|ffebld_cu_val_integer4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|error
operator|=
name|ffetarget_not_logical1
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical1_val
argument_list|(
name|ffebld_cu_val_logical1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|error
operator|=
name|ffetarget_not_logical2
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical2_val
argument_list|(
name|ffebld_cu_val_logical2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|error
operator|=
name|ffetarget_not_logical3
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical3_val
argument_list|(
name|ffebld_cu_val_logical3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|error
operator|=
name|ffetarget_not_logical4
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical4_val
argument_list|(
name|ffebld_cu_val_logical4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad logical kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_add -- Collapse add expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_add(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_add
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|ffebldConstantUnion
name|u
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_add_integer1
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer1_val
argument_list|(
name|ffebld_cu_val_integer1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_add_integer2
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer2_val
argument_list|(
name|ffebld_cu_val_integer2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_add_integer3
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer3_val
argument_list|(
name|ffebld_cu_val_integer3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_add_integer4
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer4_val
argument_list|(
name|ffebld_cu_val_integer4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_add_real1
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real1_val
argument_list|(
name|ffebld_cu_val_real1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_add_real2
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real2_val
argument_list|(
name|ffebld_cu_val_real2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_add_real3
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real3_val
argument_list|(
name|ffebld_cu_val_real3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_add_real4
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real4_val
argument_list|(
name|ffebld_cu_val_real4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad real kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_add_complex1
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex1_val
argument_list|(
name|ffebld_cu_val_complex1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_add_complex2
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex2_val
argument_list|(
name|ffebld_cu_val_complex2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_add_complex3
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex3_val
argument_list|(
name|ffebld_cu_val_complex3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_add_complex4
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex4_val
argument_list|(
name|ffebld_cu_val_complex4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad complex kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_subtract -- Collapse subtract expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_subtract(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_subtract
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|ffebldConstantUnion
name|u
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_subtract_integer1
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer1_val
argument_list|(
name|ffebld_cu_val_integer1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_subtract_integer2
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer2_val
argument_list|(
name|ffebld_cu_val_integer2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_subtract_integer3
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer3_val
argument_list|(
name|ffebld_cu_val_integer3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_subtract_integer4
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer4_val
argument_list|(
name|ffebld_cu_val_integer4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_subtract_real1
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real1_val
argument_list|(
name|ffebld_cu_val_real1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_subtract_real2
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real2_val
argument_list|(
name|ffebld_cu_val_real2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_subtract_real3
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real3_val
argument_list|(
name|ffebld_cu_val_real3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_subtract_real4
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real4_val
argument_list|(
name|ffebld_cu_val_real4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad real kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_subtract_complex1
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex1_val
argument_list|(
name|ffebld_cu_val_complex1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_subtract_complex2
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex2_val
argument_list|(
name|ffebld_cu_val_complex2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_subtract_complex3
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex3_val
argument_list|(
name|ffebld_cu_val_complex3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_subtract_complex4
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex4_val
argument_list|(
name|ffebld_cu_val_complex4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad complex kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_multiply -- Collapse multiply expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_multiply(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_multiply
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|ffebldConstantUnion
name|u
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_multiply_integer1
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer1_val
argument_list|(
name|ffebld_cu_val_integer1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_multiply_integer2
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer2_val
argument_list|(
name|ffebld_cu_val_integer2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_multiply_integer3
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer3_val
argument_list|(
name|ffebld_cu_val_integer3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_multiply_integer4
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer4_val
argument_list|(
name|ffebld_cu_val_integer4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_multiply_real1
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real1_val
argument_list|(
name|ffebld_cu_val_real1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_multiply_real2
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real2_val
argument_list|(
name|ffebld_cu_val_real2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_multiply_real3
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real3_val
argument_list|(
name|ffebld_cu_val_real3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_multiply_real4
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real4_val
argument_list|(
name|ffebld_cu_val_real4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad real kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_multiply_complex1
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex1_val
argument_list|(
name|ffebld_cu_val_complex1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_multiply_complex2
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex2_val
argument_list|(
name|ffebld_cu_val_complex2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_multiply_complex3
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex3_val
argument_list|(
name|ffebld_cu_val_complex3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_multiply_complex4
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex4_val
argument_list|(
name|ffebld_cu_val_complex4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad complex kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_divide -- Collapse divide expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_divide(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_divide
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|ffebldConstantUnion
name|u
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_divide_integer1
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer1_val
argument_list|(
name|ffebld_cu_val_integer1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_divide_integer2
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer2_val
argument_list|(
name|ffebld_cu_val_integer2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_divide_integer3
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer3_val
argument_list|(
name|ffebld_cu_val_integer3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_divide_integer4
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer4_val
argument_list|(
name|ffebld_cu_val_integer4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_divide_real1
argument_list|(
name|ffebld_cu_ptr_real1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real1_val
argument_list|(
name|ffebld_cu_val_real1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_divide_real2
argument_list|(
name|ffebld_cu_ptr_real2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real2_val
argument_list|(
name|ffebld_cu_val_real2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_divide_real3
argument_list|(
name|ffebld_cu_ptr_real3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real3_val
argument_list|(
name|ffebld_cu_val_real3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_divide_real4
argument_list|(
name|ffebld_cu_ptr_real4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_real4_val
argument_list|(
name|ffebld_cu_val_real4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad real kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_divide_complex1
argument_list|(
name|ffebld_cu_ptr_complex1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex1_val
argument_list|(
name|ffebld_cu_val_complex1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_divide_complex2
argument_list|(
name|ffebld_cu_ptr_complex2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex2_val
argument_list|(
name|ffebld_cu_val_complex2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_divide_complex3
argument_list|(
name|ffebld_cu_ptr_complex3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex3_val
argument_list|(
name|ffebld_cu_val_complex3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_divide_complex4
argument_list|(
name|ffebld_cu_ptr_complex4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complex4_val
argument_list|(
name|ffebld_cu_val_complex4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad complex kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_power -- Collapse power expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_power(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_power
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|ffebldConstantUnion
name|u
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|r
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|r
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_kindtypeINTEGERDEFAULT
operator|)
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_kindtypeINTEGERDEFAULT
case|:
name|error
operator|=
name|ffetarget_power_integerdefault_integerdefault
argument_list|(
name|ffebld_cu_ptr_integerdefault
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integerdefault_val
argument_list|(
name|ffebld_cu_val_integerdefault
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_kindtypeREALDEFAULT
case|:
name|error
operator|=
name|ffetarget_power_realdefault_integerdefault
argument_list|(
name|ffebld_cu_ptr_realdefault
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_realdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_realdefault_val
argument_list|(
name|ffebld_cu_val_realdefault
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindtypeREALDOUBLE
case|:
name|error
operator|=
name|ffetarget_power_realdouble_integerdefault
argument_list|(
name|ffebld_cu_ptr_realdouble
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_realdouble
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_realdouble_val
argument_list|(
name|ffebld_cu_val_realdouble
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFETARGET_okREALQUAD
case|case
name|FFEINFO_kindtypeREALQUAD
case|:
name|error
operator|=
name|ffetarget_power_realquad_integerdefault
argument_list|(
name|ffebld_cu_ptr_realquad
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_realquad
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_realquad_val
argument_list|(
name|ffebld_cu_val_realquad
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad real kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_kindtypeREALDEFAULT
case|:
name|error
operator|=
name|ffetarget_power_complexdefault_integerdefault
argument_list|(
name|ffebld_cu_ptr_complexdefault
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complexdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complexdefault_val
argument_list|(
name|ffebld_cu_val_complexdefault
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFETARGET_okCOMPLEXDOUBLE
case|case
name|FFEINFO_kindtypeREALDOUBLE
case|:
name|error
operator|=
name|ffetarget_power_complexdouble_integerdefault
argument_list|(
name|ffebld_cu_ptr_complexdouble
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complexdouble
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complexdouble_val
argument_list|(
name|ffebld_cu_val_complexdouble
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEXQUAD
case|case
name|FFEINFO_kindtypeREALQUAD
case|:
name|error
operator|=
name|ffetarget_power_complexquad_integerdefault
argument_list|(
name|ffebld_cu_ptr_complexquad
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_complexquad
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_complexquad_val
argument_list|(
name|ffebld_cu_val_complexquad
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad complex kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_concatenate -- Collapse concatenate expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_concatenate(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_concatenate
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|ffebldConstantUnion
name|u
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|ffetargetCharacterSize
name|len
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
name|error
operator|=
name|ffetarget_concatenate_character1
argument_list|(
name|ffebld_cu_ptr_character1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_character1_val
argument_list|(
name|ffebld_cu_val_character1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER2
case|case
name|FFEINFO_kindtypeCHARACTER2
case|:
name|error
operator|=
name|ffetarget_concatenate_character2
argument_list|(
name|ffebld_cu_ptr_character2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_character2_val
argument_list|(
name|ffebld_cu_val_character2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER3
case|case
name|FFEINFO_kindtypeCHARACTER3
case|:
name|error
operator|=
name|ffetarget_concatenate_character3
argument_list|(
name|ffebld_cu_ptr_character3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_character3_val
argument_list|(
name|ffebld_cu_val_character3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER4
case|case
name|FFEINFO_kindtypeCHARACTER4
case|:
name|error
operator|=
name|ffetarget_concatenate_character4
argument_list|(
name|ffebld_cu_ptr_character4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_character4_val
argument_list|(
name|ffebld_cu_val_character4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad character kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeCHARACTER
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_eq -- Collapse eq expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_eq(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_eq
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|bool
name|val
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_eq_integer1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_eq_integer2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_eq_integer3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_eq_integer4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_eq_real1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_eq_real2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_eq_real3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_eq_real4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad real kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_eq_complex1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_eq_complex2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_eq_complex3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_eq_complex4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad complex kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
name|error
operator|=
name|ffetarget_eq_character1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER2
case|case
name|FFEINFO_kindtypeCHARACTER2
case|:
name|error
operator|=
name|ffetarget_eq_character2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER3
case|case
name|FFEINFO_kindtypeCHARACTER3
case|:
name|error
operator|=
name|ffetarget_eq_character3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER4
case|case
name|FFEINFO_kindtypeCHARACTER4
case|:
name|error
operator|=
name|ffetarget_eq_character4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad character kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_ne -- Collapse ne expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_ne(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_ne
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|bool
name|val
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_ne_integer1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_ne_integer2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_ne_integer3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_ne_integer4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_ne_real1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_ne_real2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_ne_real3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_ne_real4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad real kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_ne_complex1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_ne_complex2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_ne_complex3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_ne_complex4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad complex kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
name|error
operator|=
name|ffetarget_ne_character1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER2
case|case
name|FFEINFO_kindtypeCHARACTER2
case|:
name|error
operator|=
name|ffetarget_ne_character2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER3
case|case
name|FFEINFO_kindtypeCHARACTER3
case|:
name|error
operator|=
name|ffetarget_ne_character3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER4
case|case
name|FFEINFO_kindtypeCHARACTER4
case|:
name|error
operator|=
name|ffetarget_ne_character4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad character kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_ge -- Collapse ge expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_ge(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_ge
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|bool
name|val
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_ge_integer1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_ge_integer2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_ge_integer3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_ge_integer4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_ge_real1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_ge_real2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_ge_real3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_ge_real4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad real kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
name|error
operator|=
name|ffetarget_ge_character1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER2
case|case
name|FFEINFO_kindtypeCHARACTER2
case|:
name|error
operator|=
name|ffetarget_ge_character2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER3
case|case
name|FFEINFO_kindtypeCHARACTER3
case|:
name|error
operator|=
name|ffetarget_ge_character3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER4
case|case
name|FFEINFO_kindtypeCHARACTER4
case|:
name|error
operator|=
name|ffetarget_ge_character4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad character kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_gt -- Collapse gt expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_gt(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_gt
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|bool
name|val
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_gt_integer1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_gt_integer2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_gt_integer3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_gt_integer4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_gt_real1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_gt_real2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_gt_real3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_gt_real4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad real kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
name|error
operator|=
name|ffetarget_gt_character1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER2
case|case
name|FFEINFO_kindtypeCHARACTER2
case|:
name|error
operator|=
name|ffetarget_gt_character2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER3
case|case
name|FFEINFO_kindtypeCHARACTER3
case|:
name|error
operator|=
name|ffetarget_gt_character3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER4
case|case
name|FFEINFO_kindtypeCHARACTER4
case|:
name|error
operator|=
name|ffetarget_gt_character4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad character kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_le -- Collapse le expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_le(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_le
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|bool
name|val
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_le_integer1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_le_integer2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_le_integer3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_le_integer4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_le_real1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_le_real2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_le_real3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_le_real4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad real kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
name|error
operator|=
name|ffetarget_le_character1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER2
case|case
name|FFEINFO_kindtypeCHARACTER2
case|:
name|error
operator|=
name|ffetarget_le_character2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER3
case|case
name|FFEINFO_kindtypeCHARACTER3
case|:
name|error
operator|=
name|ffetarget_le_character3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER4
case|case
name|FFEINFO_kindtypeCHARACTER4
case|:
name|error
operator|=
name|ffetarget_le_character4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad character kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_lt -- Collapse lt expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_lt(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_lt
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|bool
name|val
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_lt_integer1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_lt_integer2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_lt_integer3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_lt_integer4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okREAL1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|error
operator|=
name|ffetarget_lt_real1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|error
operator|=
name|ffetarget_lt_real2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|error
operator|=
name|ffetarget_lt_real3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okREAL4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|error
operator|=
name|ffetarget_lt_real4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_real4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad real kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
name|error
operator|=
name|ffetarget_lt_character1
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER2
case|case
name|FFEINFO_kindtypeCHARACTER2
case|:
name|error
operator|=
name|ffetarget_lt_character2
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER3
case|case
name|FFEINFO_kindtypeCHARACTER3
case|:
name|error
operator|=
name|ffetarget_lt_character3
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER4
case|case
name|FFEINFO_kindtypeCHARACTER4
case|:
name|error
operator|=
name|ffetarget_lt_character4
argument_list|(
operator|&
name|val
argument_list|,
name|ffebld_constant_character4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_character4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|val
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad character kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_and -- Collapse and expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_and(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_and
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|ffebldConstantUnion
name|u
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_and_integer1
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer1_val
argument_list|(
name|ffebld_cu_val_integer1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_and_integer2
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer2_val
argument_list|(
name|ffebld_cu_val_integer2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_and_integer3
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer3_val
argument_list|(
name|ffebld_cu_val_integer3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_and_integer4
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer4_val
argument_list|(
name|ffebld_cu_val_integer4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|error
operator|=
name|ffetarget_and_logical1
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical1_val
argument_list|(
name|ffebld_cu_val_logical1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|error
operator|=
name|ffetarget_and_logical2
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical2_val
argument_list|(
name|ffebld_cu_val_logical2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|error
operator|=
name|ffetarget_and_logical3
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical3_val
argument_list|(
name|ffebld_cu_val_logical3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|error
operator|=
name|ffetarget_and_logical4
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical4_val
argument_list|(
name|ffebld_cu_val_logical4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad logical kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_or -- Collapse or expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_or(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_or
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|ffebldConstantUnion
name|u
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_or_integer1
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer1_val
argument_list|(
name|ffebld_cu_val_integer1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_or_integer2
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer2_val
argument_list|(
name|ffebld_cu_val_integer2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_or_integer3
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer3_val
argument_list|(
name|ffebld_cu_val_integer3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_or_integer4
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer4_val
argument_list|(
name|ffebld_cu_val_integer4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|error
operator|=
name|ffetarget_or_logical1
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical1_val
argument_list|(
name|ffebld_cu_val_logical1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|error
operator|=
name|ffetarget_or_logical2
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical2_val
argument_list|(
name|ffebld_cu_val_logical2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|error
operator|=
name|ffetarget_or_logical3
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical3_val
argument_list|(
name|ffebld_cu_val_logical3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|error
operator|=
name|ffetarget_or_logical4
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical4_val
argument_list|(
name|ffebld_cu_val_logical4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad logical kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_xor -- Collapse xor expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_xor(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_xor
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|ffebldConstantUnion
name|u
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_xor_integer1
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer1_val
argument_list|(
name|ffebld_cu_val_integer1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_xor_integer2
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer2_val
argument_list|(
name|ffebld_cu_val_integer2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_xor_integer3
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer3_val
argument_list|(
name|ffebld_cu_val_integer3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_xor_integer4
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer4_val
argument_list|(
name|ffebld_cu_val_integer4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|error
operator|=
name|ffetarget_xor_logical1
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical1_val
argument_list|(
name|ffebld_cu_val_logical1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|error
operator|=
name|ffetarget_xor_logical2
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical2_val
argument_list|(
name|ffebld_cu_val_logical2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|error
operator|=
name|ffetarget_xor_logical3
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical3_val
argument_list|(
name|ffebld_cu_val_logical3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|error
operator|=
name|ffetarget_xor_logical4
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical4_val
argument_list|(
name|ffebld_cu_val_logical4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad logical kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_eqv -- Collapse eqv expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_eqv(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_eqv
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|ffebldConstantUnion
name|u
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_eqv_integer1
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer1_val
argument_list|(
name|ffebld_cu_val_integer1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_eqv_integer2
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer2_val
argument_list|(
name|ffebld_cu_val_integer2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_eqv_integer3
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer3_val
argument_list|(
name|ffebld_cu_val_integer3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_eqv_integer4
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer4_val
argument_list|(
name|ffebld_cu_val_integer4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|error
operator|=
name|ffetarget_eqv_logical1
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical1_val
argument_list|(
name|ffebld_cu_val_logical1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|error
operator|=
name|ffetarget_eqv_logical2
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical2_val
argument_list|(
name|ffebld_cu_val_logical2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|error
operator|=
name|ffetarget_eqv_logical3
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical3_val
argument_list|(
name|ffebld_cu_val_logical3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|error
operator|=
name|ffetarget_eqv_logical4
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical4_val
argument_list|(
name|ffebld_cu_val_logical4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad logical kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_neqv -- Collapse neqv expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_neqv(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_neqv
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|ffebldConstantUnion
name|u
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okINTEGER1
case|case
name|FFEINFO_kindtypeINTEGER1
case|:
name|error
operator|=
name|ffetarget_neqv_integer1
argument_list|(
name|ffebld_cu_ptr_integer1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer1_val
argument_list|(
name|ffebld_cu_val_integer1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER2
case|case
name|FFEINFO_kindtypeINTEGER2
case|:
name|error
operator|=
name|ffetarget_neqv_integer2
argument_list|(
name|ffebld_cu_ptr_integer2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer2_val
argument_list|(
name|ffebld_cu_val_integer2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER3
case|case
name|FFEINFO_kindtypeINTEGER3
case|:
name|error
operator|=
name|ffetarget_neqv_integer3
argument_list|(
name|ffebld_cu_ptr_integer3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer3_val
argument_list|(
name|ffebld_cu_val_integer3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okINTEGER4
case|case
name|FFEINFO_kindtypeINTEGER4
case|:
name|error
operator|=
name|ffetarget_neqv_integer4
argument_list|(
name|ffebld_cu_ptr_integer4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_integer4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integer4_val
argument_list|(
name|ffebld_cu_val_integer4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad integer kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okLOGICAL1
case|case
name|FFEINFO_kindtypeLOGICAL1
case|:
name|error
operator|=
name|ffetarget_neqv_logical1
argument_list|(
name|ffebld_cu_ptr_logical1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical1
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical1_val
argument_list|(
name|ffebld_cu_val_logical1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL2
case|case
name|FFEINFO_kindtypeLOGICAL2
case|:
name|error
operator|=
name|ffetarget_neqv_logical2
argument_list|(
name|ffebld_cu_ptr_logical2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical2
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical2_val
argument_list|(
name|ffebld_cu_val_logical2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL3
case|case
name|FFEINFO_kindtypeLOGICAL3
case|:
name|error
operator|=
name|ffetarget_neqv_logical3
argument_list|(
name|ffebld_cu_ptr_logical3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical3
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical3_val
argument_list|(
name|ffebld_cu_val_logical3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okLOGICAL4
case|case
name|FFEINFO_kindtypeLOGICAL4
case|:
name|error
operator|=
name|ffetarget_neqv_logical4
argument_list|(
name|ffebld_cu_ptr_logical4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|ffebld_constant_logical4
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_logical4_val
argument_list|(
name|ffebld_cu_val_logical4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad logical kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_symter -- Collapse symter expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_symter(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_symter
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
name|UNUSED
parameter_list|)
block|{
name|ffebld
name|r
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|ffetargetCharacterSize
name|len
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|ffesymbol_init
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|expr
return|;
comment|/* A PARAMETER lhs in progress. */
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|r
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opCONTER
case|:
break|break;
case|case
name|FFEBLD_opANY
case|:
return|return
name|r
return|;
default|default:
return|return
name|expr
return|;
block|}
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|ffebld_size
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_copy
argument_list|(
name|ffebld_conter
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_funcref -- Collapse funcref expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_funcref(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_funcref
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
name|UNUSED
parameter_list|)
block|{
return|return
name|expr
return|;
comment|/* ~~someday go ahead and collapse these, 				   though not required */
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_arrayref -- Collapse arrayref expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_arrayref(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_arrayref
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
name|UNUSED
parameter_list|)
block|{
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_collapse_substr -- Collapse substr expr     ffebld expr;    ffelexToken token;    expr = ffeexpr_collapse_substr(expr,token);     If the result of the expr is a constant, replaces the expr with the    computed constant.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_collapse_substr
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebad
name|error
init|=
name|FFEBAD
decl_stmt|;
name|ffebld
name|l
decl_stmt|;
name|ffebld
name|r
decl_stmt|;
name|ffebld
name|start
decl_stmt|;
name|ffebld
name|stop
decl_stmt|;
name|ffebldConstantUnion
name|u
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|ffetargetCharacterSize
name|len
decl_stmt|;
name|ffetargetIntegerDefault
name|first
decl_stmt|;
name|ffetargetIntegerDefault
name|last
decl_stmt|;
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|expr
return|;
name|l
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|r
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* opITEM. */
if|if
condition|(
name|ffebld_op
argument_list|(
name|l
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
return|return
name|expr
return|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|ffebld_size
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|start
operator|=
name|ffebld_head
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|stop
operator|=
name|ffebld_head
argument_list|(
name|ffebld_trail
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|NULL
condition|)
name|first
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|ffebld_op
argument_list|(
name|start
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|start
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|start
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_kindtypeINTEGERDEFAULT
operator|)
condition|)
return|return
name|expr
return|;
name|first
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stop
operator|==
name|NULL
condition|)
name|last
operator|=
name|len
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|ffebld_op
argument_list|(
name|stop
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|stop
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|stop
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_kindtypeINTEGERDEFAULT
operator|)
condition|)
return|return
name|expr
return|;
name|last
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|stop
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Handle problems that should have already been diagnosed, but      left in the expression tree.  */
if|if
condition|(
name|first
operator|<=
literal|0
condition|)
name|first
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|last
operator|<
name|first
condition|)
name|last
operator|=
name|first
operator|+
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|first
operator|==
literal|1
operator|)
operator|&&
operator|(
name|last
operator|==
name|len
operator|)
condition|)
block|{
comment|/* Same as original. */
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_copy
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeCHARACTER
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|expr
return|;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCHARACTER1
case|case
name|FFEINFO_kindtypeCHARACTER1
case|:
name|error
operator|=
name|ffetarget_substr_character1
argument_list|(
name|ffebld_cu_ptr_character1
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character1
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_character1_val
argument_list|(
name|ffebld_cu_val_character1
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER2
case|case
name|FFEINFO_kindtypeCHARACTER2
case|:
name|error
operator|=
name|ffetarget_substr_character2
argument_list|(
name|ffebld_cu_ptr_character2
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character2
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_character2_val
argument_list|(
name|ffebld_cu_val_character2
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER3
case|case
name|FFEINFO_kindtypeCHARACTER3
case|:
name|error
operator|=
name|ffetarget_substr_character3
argument_list|(
name|ffebld_cu_ptr_character3
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character3
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_character3_val
argument_list|(
name|ffebld_cu_val_character3
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCHARACTER4
case|case
name|FFEINFO_kindtypeCHARACTER4
case|:
name|error
operator|=
name|ffetarget_substr_character4
argument_list|(
name|ffebld_cu_ptr_character4
argument_list|(
name|u
argument_list|)
argument_list|,
name|ffebld_constant_character4
argument_list|(
name|ffebld_conter
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|ffebld_constant_pool
argument_list|()
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_character4_val
argument_list|(
name|ffebld_cu_val_character4
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"bad character kind type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeCHARACTER
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
name|FFEBAD
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_convert -- Convert source expression to given type     ffebld source;    ffelexToken source_token;    ffelexToken dest_token;  // Any appropriate token for "destination".    ffeinfoBasictype bt;    ffeinfoKindtype kt;    ffetargetCharactersize sz;    ffeexprContext context;  // Mainly LET or DATA.    source = ffeexpr_convert(source,source_token,dest_token,bt,kt,sz,context);     If the expression conforms, returns the source expression.  Otherwise    returns source wrapped in a convert node doing the conversion, or    ANY wrapped in convert if there is a conversion error (and issues an    error message).  Be sensitive to the context for certain aspects of    the conversion.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_convert
parameter_list|(
name|ffebld
name|source
parameter_list|,
name|ffelexToken
name|source_token
parameter_list|,
name|ffelexToken
name|dest_token
parameter_list|,
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffeinfoKindtype
name|kt
parameter_list|,
name|ffeinfoRank
name|rk
parameter_list|,
name|ffetargetCharacterSize
name|sz
parameter_list|,
name|ffeexprContext
name|context
parameter_list|)
block|{
name|bool
name|bad
decl_stmt|;
name|ffeinfo
name|info
decl_stmt|;
name|ffeinfoWhere
name|wh
decl_stmt|;
name|info
operator|=
name|ffebld_info
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bt
operator|!=
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
operator|)
operator|||
operator|(
name|kt
operator|!=
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
operator|)
operator|||
operator|(
name|rk
operator|!=
literal|0
operator|)
comment|/* Can't convert from or to arrays yet. */
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|sz
operator|!=
name|ffebld_size_known
argument_list|(
name|source
argument_list|)
operator|)
condition|)
if|#
directive|if
literal|0
comment|/* Nobody seems to need this spurious CONVERT node. */
then||| ((context != FFEEXPR_contextLET)&& (bt == FFEINFO_basictypeCHARACTER)&& (sz == FFETARGET_charactersizeNONE)))
endif|#
directive|endif
block|{
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
switch|switch
condition|(
name|bt
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|bad
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeINTEGER
case|:
name|bad
operator|=
operator|!
name|ffe_is_ugly_logint
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|bad
operator|=
name|ffe_is_pedantic
argument_list|()
operator|||
operator|!
operator|(
name|ffe_is_ugly_init
argument_list|()
operator|&&
operator|(
name|context
operator|==
name|FFEEXPR_contextDATA
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
name|bad
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeINTEGER
case|:
switch|switch
condition|(
name|bt
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeREAL
case|:
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
name|bad
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|bad
operator|=
operator|!
name|ffe_is_ugly_logint
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|bad
operator|=
name|ffe_is_pedantic
argument_list|()
operator|||
operator|!
operator|(
name|ffe_is_ugly_init
argument_list|()
operator|&&
operator|(
name|context
operator|==
name|FFEEXPR_contextDATA
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
name|bad
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
switch|switch
condition|(
name|bt
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeREAL
case|:
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
name|bad
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|bad
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|bad
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|bad
operator|=
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
operator|&&
operator|(
name|ffe_is_pedantic
argument_list|()
operator|||
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|!
operator|(
name|ffe_is_ugly_init
argument_list|()
operator|&&
operator|(
name|context
operator|==
name|FFEEXPR_contextDATA
operator|)
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeTYPELESS
case|:
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
name|bad
operator|=
name|ffe_is_pedantic
argument_list|()
operator|||
operator|!
operator|(
name|ffe_is_ugly_init
argument_list|()
operator|&&
operator|(
operator|(
name|context
operator|==
name|FFEEXPR_contextDATA
operator|)
operator|||
operator|(
name|context
operator|==
name|FFEEXPR_contextLET
operator|)
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
name|bad
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|bad
operator|&&
operator|(
operator|(
name|rk
operator|!=
literal|0
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
name|bad
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|bad
operator|&&
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
operator|(
name|kt
operator|!=
name|FFEINFO_kindtypeANY
operator|)
operator|&&
operator|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
operator|(
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_kindtypeANY
operator|)
operator|&&
operator|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_whereANY
operator|)
condition|)
block|{
if|if
condition|(
name|ffebad_start
argument_list|(
name|FFEBAD_BAD_TYPES
argument_list|)
condition|)
block|{
if|if
condition|(
name|dest_token
operator|==
name|NULL
condition|)
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffewhere_line_unknown
argument_list|()
argument_list|,
name|ffewhere_column_unknown
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|dest_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|dest_token
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|source_token
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|source_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|source_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|source
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|source
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
name|wh
operator|=
name|FFEINFO_whereCONSTANT
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|wh
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|wh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
name|source
operator|=
name|ffebld_new_convert
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|source
argument_list|,
name|ffeinfo_new
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|wh
argument_list|,
name|sz
argument_list|)
argument_list|)
expr_stmt|;
name|source
operator|=
name|ffeexpr_collapse_convert
argument_list|(
name|source
argument_list|,
name|source_token
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|source
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_convert_expr -- Convert source expr to conform to dest expr     ffebld source;    ffebld dest;    ffelexToken source_token;    ffelexToken dest_token;    ffeexprContext context;    source = ffeexpr_convert_expr(source,source_token,dest,dest_token,context);     If the expressions conform, returns the source expression.  Otherwise    returns source wrapped in a convert node doing the conversion, or    ANY wrapped in convert if there is a conversion error (and issues an    error message).  Be sensitive to the context, such as LET or DATA.  */
end_comment

begin_function
name|ffebld
name|ffeexpr_convert_expr
parameter_list|(
name|ffebld
name|source
parameter_list|,
name|ffelexToken
name|source_token
parameter_list|,
name|ffebld
name|dest
parameter_list|,
name|ffelexToken
name|dest_token
parameter_list|,
name|ffeexprContext
name|context
parameter_list|)
block|{
name|ffeinfo
name|info
decl_stmt|;
name|info
operator|=
name|ffebld_info
argument_list|(
name|dest
argument_list|)
expr_stmt|;
return|return
name|ffeexpr_convert
argument_list|(
name|source
argument_list|,
name|source_token
argument_list|,
name|dest_token
argument_list|,
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
argument_list|,
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
argument_list|,
name|ffebld_size_known
argument_list|(
name|dest
argument_list|)
argument_list|,
name|context
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_convert_to_sym -- Convert source expression to conform to symbol     ffebld source;    ffesymbol dest;    ffelexToken source_token;    ffelexToken dest_token;    source = ffeexpr_convert_to_sym(source,source_token,dest,dest_token);     If the expressions conform, returns the source expression.  Otherwise    returns source wrapped in a convert node doing the conversion, or    ANY wrapped in convert if there is a conversion error (and issues an    error message).  */
end_comment

begin_function
name|ffebld
name|ffeexpr_convert_to_sym
parameter_list|(
name|ffebld
name|source
parameter_list|,
name|ffelexToken
name|source_token
parameter_list|,
name|ffesymbol
name|dest
parameter_list|,
name|ffelexToken
name|dest_token
parameter_list|)
block|{
return|return
name|ffeexpr_convert
argument_list|(
name|source
argument_list|,
name|source_token
argument_list|,
name|dest_token
argument_list|,
name|ffesymbol_basictype
argument_list|(
name|dest
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|dest
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|dest
argument_list|)
argument_list|,
name|ffesymbol_size
argument_list|(
name|dest
argument_list|)
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initializes the module.  */
end_comment

begin_function
name|void
name|ffeexpr_init_2
parameter_list|()
block|{
name|ffeexpr_stack_
operator|=
name|NULL
expr_stmt|;
name|ffeexpr_level_
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffeexpr_lhs -- Begin processing left-hand-side-context expression     Prepares cluster for delivery of lexer tokens representing an expression    in a left-hand-side context (A in A=B, for example).	 ffebld is used    to build expressions in the given pool.  The appropriate lexer-token    handling routine within ffeexpr is returned.	 When the end of the    expression is detected, mycallbackroutine is called with the resulting    single ffebld object specifying the entire expression and the first    lexer token that is not considered part of the expression.  This caller-    supplied routine itself returns a lexer-token handling routine.  Thus,    if necessary, ffeexpr can return several tokens as end-of-expression    tokens if it needs to scan forward more than one in any instance.  */
end_comment

begin_function
name|ffelexHandler
name|ffeexpr_lhs
parameter_list|(
name|mallocPool
name|pool
parameter_list|,
name|ffeexprContext
name|context
parameter_list|,
name|ffeexprCallback
name|callback
parameter_list|)
block|{
name|ffeexprStack_
name|s
decl_stmt|;
name|ffebld_pool_push
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|s
operator|=
name|malloc_new_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
literal|"FFEEXPR stack"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|previous
operator|=
name|ffeexpr_stack_
expr_stmt|;
name|s
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|s
operator|->
name|context
operator|=
name|context
expr_stmt|;
name|s
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|s
operator|->
name|first_token
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|exprstack
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|is_rhs
operator|=
name|FALSE
expr_stmt|;
name|ffeexpr_stack_
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_first_lhs_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_rhs -- Begin processing right-hand-side-context expression     return ffeexpr_rhs(malloc_pool_image(),mycallbackroutine);  // to lexer.     Prepares cluster for delivery of lexer tokens representing an expression    in a right-hand-side context (B in A=B, for example).  ffebld is used    to build expressions in the given pool.  The appropriate lexer-token    handling routine within ffeexpr is returned.	 When the end of the    expression is detected, mycallbackroutine is called with the resulting    single ffebld object specifying the entire expression and the first    lexer token that is not considered part of the expression.  This caller-    supplied routine itself returns a lexer-token handling routine.  Thus,    if necessary, ffeexpr can return several tokens as end-of-expression    tokens if it needs to scan forward more than one in any instance.  */
end_comment

begin_function
name|ffelexHandler
name|ffeexpr_rhs
parameter_list|(
name|mallocPool
name|pool
parameter_list|,
name|ffeexprContext
name|context
parameter_list|,
name|ffeexprCallback
name|callback
parameter_list|)
block|{
name|ffeexprStack_
name|s
decl_stmt|;
name|ffebld_pool_push
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|s
operator|=
name|malloc_new_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
literal|"FFEEXPR stack"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|previous
operator|=
name|ffeexpr_stack_
expr_stmt|;
name|s
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|s
operator|->
name|context
operator|=
name|context
expr_stmt|;
name|s
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|s
operator|->
name|first_token
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|exprstack
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|is_rhs
operator|=
name|TRUE
expr_stmt|;
name|ffeexpr_stack_
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_first_rhs_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_close_paren_ -- OPEN_PAREN expr     Pass it to ffeexpr_rhs as the callback routine.     Makes sure the end token is close-paren and swallows it, else issues    an error message and doesn't swallow the token (passing it along instead).    In either case wraps up subexpression construction by enclosing the    ffebld expression in a paren.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_close_paren_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeCLOSE_PAREN
condition|)
block|{
comment|/* Oops, naughty user didn't specify the close paren! */
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_MISSING_CLOSE_PAREN
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_find_close_paren_
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|)
return|;
block|}
if|if
condition|(
name|expr
operator|->
name|op
operator|==
name|FFEBLD_opIMPDO
condition|)
block|{
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_IMPDO_PAREN
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|expr
operator|=
name|ffebld_new_paren
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_use
argument_list|(
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now push the (parenthesized) expression as an operand onto the      expression stack. */
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|expr
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffeexpr_collapse_paren
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ft
argument_list|)
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
expr_stmt|;
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_close_paren_ambig_ -- OPEN_PAREN expr     Pass it to ffeexpr_rhs as the callback routine.     We get here in the READ/BACKEND/ENDFILE/REWIND case "READ(expr)"    with the next token in t.  If the next token is possibly a binary    operator, continue processing the outer expression.	If the next    token is COMMA, then the expression is a unit specifier, and    parentheses should not be added to it because it surrounds the    I/O control list that starts with the unit specifier (and continues    on from here -- we haven't seen the CLOSE_PAREN that matches the    OPEN_PAREN, it is up to the callback function to expect to see it    at some point).  In this case, we notify the callback function that    the COMMA is inside, not outside, the parens by wrapping the expression    in an opITEM (with a NULL trail) -- the callback function presumably    unwraps it after seeing this kludgey indicator.     If the next token is CLOSE_PAREN, then we go to the _1_ state to    decide what to do with the token after that.     15-Feb-91  JCB  1.1       Use an extra state for the CLOSE_PAREN case to make READ&co really       work right.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_close_paren_ambig_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprCallback
name|callback
decl_stmt|;
name|ffeexprStack_
name|s
decl_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCLOSE_PAREN
condition|)
block|{
comment|/* Need to see the next token before we 				   decide anything. */
name|ffeexpr_stack_
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
name|ffeexpr_tokens_
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffeexpr_tokens_
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_close_paren_ambig_1_
return|;
block|}
name|expr
operator|=
name|ffeexpr_finished_ambig_
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* Let the callback function handle the case where t isn't COMMA. */
comment|/* Here is a kludge whereby we tell the callback function the OPEN_PAREN      that preceded the expression starts a list of expressions, and the expr      hasn't been wrapped in a corresponding (and possibly collapsed) opPAREN      node.  The callback function should extract the real expr from the head      of this opITEM node after testing it. */
name|expr
operator|=
name|ffebld_new_item
argument_list|(
name|expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffebld_pool_pop
argument_list|()
expr_stmt|;
name|callback
operator|=
name|ffeexpr_stack_
operator|->
name|callback
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffeexpr_stack_
operator|->
name|previous
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
name|ffeexpr_stack_
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ffeexpr_stack_
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|=
name|s
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|callback
argument_list|)
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_close_paren_ambig_1_ -- OPEN_PAREN expr CLOSE_PAREN     See ffeexpr_cb_close_paren_ambig_.     We get here in the READ/BACKEND/ENDFILE/REWIND case "READ(expr)"    with the next token in t.  If the next token is possibly a binary    operator, continue processing the outer expression.	If the next    token is COMMA, the expression is a parenthesized format specifier.    If the next token is not EOS or SEMICOLON, then because it is not a    binary operator (it is NAME, OPEN_PAREN,&c), the expression is    a unit specifier, and parentheses should not be added to it because    they surround the I/O control list that consists of only the unit    specifier.  If the next token is EOS or SEMICOLON, the statement    must be disambiguated by looking at the type of the expression -- a    character expression is a parenthesized format specifier, while a    non-character expression is a unit specifier.     Another issue is how to do the callback so the recipient of the    next token knows how to handle it if it is a COMMA.	In all other    cases, disambiguation is straightforward: the same approach as the    above is used.     EXTENSION: in COMMA case, if not pedantic, use same disambiguation    as for EOS/SEMICOLON case; f2c allows "READ (cilist) [[,]iolist]"    and apparently other compilers do, as well, and some code out there    uses this "feature".     19-Feb-91  JCB  1.1       Extend to allow COMMA as nondisambiguating by itself.  Remember       to not try and check info field for opSTAR, since that expr doesn't       have a valid info field.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_close_paren_ambig_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprCallback
name|callback
decl_stmt|;
name|ffeexprStack_
name|s
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|orig_ft
init|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
decl_stmt|;
comment|/* In case callback clobbers 						   these. */
name|ffelexToken
name|orig_t
init|=
name|ffeexpr_tokens_
index|[
literal|1
index|]
decl_stmt|;
name|ffebld
name|expr
init|=
name|ffeexpr_stack_
operator|->
name|expr
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
comment|/* Subexpr is parenthesized format specifier. */
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
goto|goto
name|pedantic_comma
goto|;
comment|/* :::::::::::::::::::: */
comment|/* Fall through. */
case|case
name|FFELEX_typeEOS
case|:
comment|/* Ambiguous; use type of expr to 				   disambiguate. */
case|case
name|FFELEX_typeSEMICOLON
case|:
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opSTAR
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
condition|)
break|break;
comment|/* Not a valid CHARACTER entity, can't be a 				   format spec. */
comment|/* Fall through. */
default|default:
comment|/* Binary op (we assume; error otherwise); 				   format specifier. */
name|pedantic_comma
label|:
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextFILENUMAMBIG
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextFILENUM
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextFILEUNITAMBIG
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextFILEFORMAT
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad context"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_close_paren_
argument_list|(
name|orig_ft
argument_list|,
name|expr
argument_list|,
name|orig_t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|orig_ft
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|orig_t
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
comment|/* Non-binary op; beginning of I/O list. */
case|case
name|FFELEX_typeNAME
case|:
break|break;
block|}
name|expr
operator|=
name|ffeexpr_finished_ambig_
argument_list|(
name|orig_ft
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* Here is a kludge whereby we tell the callback function the OPEN_PAREN      that preceded the expression starts a list of expressions, and the expr      hasn't been wrapped in a corresponding (and possibly collapsed) opPAREN      node.  The callback function should extract the real expr from the head      of this opITEM node after testing it. */
name|expr
operator|=
name|ffebld_new_item
argument_list|(
name|expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffebld_pool_pop
argument_list|()
expr_stmt|;
name|callback
operator|=
name|ffeexpr_stack_
operator|->
name|callback
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffeexpr_stack_
operator|->
name|previous
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
name|ffeexpr_stack_
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ffeexpr_stack_
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|=
name|s
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|callback
argument_list|)
argument_list|(
name|orig_ft
argument_list|,
name|expr
argument_list|,
name|orig_t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|orig_ft
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|orig_t
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_close_paren_c_ -- OPEN_PAREN expr (possible complex)     Pass it to ffeexpr_rhs as the callback routine.     Makes sure the end token is close-paren and swallows it, or a comma    and handles complex/implied-do possibilities, else issues    an error message and doesn't swallow the token (passing it along instead).  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_close_paren_c_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
comment|/* First check to see if this is a possible complex entity.  It is if the      token is a comma. */
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
block|{
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextPAREN_
argument_list|,
name|ffeexpr_cb_comma_c_
argument_list|)
return|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_close_paren_
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_comma_c_ -- OPEN_PAREN expr COMMA expr     Pass it to ffeexpr_rhs as the callback routine.     If this token is not a comma, we have a complex constant (or an attempt    at one), so handle it accordingly, displaying error messages if the token    is not a close-paren.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_c_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
name|ffeinfoBasictype
name|lty
init|=
operator|(
name|ffeexpr_stack_
operator|->
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|)
argument_list|)
decl_stmt|;
name|ffeinfoBasictype
name|rty
init|=
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
name|ffeinfoKindtype
name|lkt
decl_stmt|;
name|ffeinfoKindtype
name|rkt
decl_stmt|;
name|ffeinfoKindtype
name|nkt
decl_stmt|;
name|bool
name|ok
init|=
name|TRUE
decl_stmt|;
name|ffebld
name|orig
decl_stmt|;
if|if
condition|(
operator|(
name|ffeexpr_stack_
operator|->
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
operator|||
operator|(
operator|(
operator|(
name|orig
operator|=
name|ffebld_conter_orig
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ffebld_op
argument_list|(
name|orig
argument_list|)
operator|!=
name|FFEBLD_opUMINUS
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|orig
argument_list|)
operator|!=
name|FFEBLD_opUPLUS
operator|)
operator|)
operator|||
operator|(
name|ffebld_conter_orig
argument_list|(
name|ffebld_left
argument_list|(
name|orig
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|lty
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|lty
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|lty
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_INVALID_COMPLEX_PART
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"Real"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
operator|||
operator|(
operator|(
operator|(
name|orig
operator|=
name|ffebld_conter_orig
argument_list|(
name|expr
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ffebld_op
argument_list|(
name|orig
argument_list|)
operator|!=
name|FFEBLD_opUMINUS
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|orig
argument_list|)
operator|!=
name|FFEBLD_opUPLUS
operator|)
operator|)
operator|||
operator|(
name|ffebld_conter_orig
argument_list|(
name|ffebld_left
argument_list|(
name|orig
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|rty
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|rty
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rty
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_INVALID_COMPLEX_PART
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ft
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"Imaginary"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Push the (parenthesized) expression as an operand onto the expression      stack. */
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|lty
operator|==
name|FFEINFO_basictypeINTEGER
condition|)
name|lkt
operator|=
name|FFEINFO_kindtypeREALDEFAULT
expr_stmt|;
else|else
name|lkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rty
operator|==
name|FFEINFO_basictypeINTEGER
condition|)
name|rkt
operator|=
name|FFEINFO_kindtypeREALDEFAULT
expr_stmt|;
else|else
name|rkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|nkt
operator|=
name|ffeinfo_kindtype_max
argument_list|(
name|FFEINFO_basictypeCOMPLEX
argument_list|,
name|lkt
argument_list|,
name|rkt
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|,
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|,
name|FFEINFO_basictypeREAL
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|,
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|,
name|FFEINFO_basictypeREAL
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
block|}
else|else
name|nkt
operator|=
name|FFEINFO_kindtypeANY
expr_stmt|;
switch|switch
condition|(
name|nkt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_complex1
argument_list|(
name|ffebld_conter
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|)
argument_list|,
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeCOMPLEX
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_complex2
argument_list|(
name|ffebld_conter
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|)
argument_list|,
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeCOMPLEX
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_complex3
argument_list|(
name|ffebld_conter
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|)
argument_list|,
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeCOMPLEX
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_complex4
argument_list|(
name|ffebld_conter
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|)
argument_list|,
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeCOMPLEX
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
if|if
condition|(
name|ffebad_start
argument_list|(
operator|(
name|nkt
operator|==
name|FFEINFO_kindtypeREALDOUBLE
operator|)
condition|?
name|FFEBAD_BAD_DBLCMPLX
else|:
name|FFEBAD_BAD_COMPLEX
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
comment|/* Fall through. */
case|case
name|FFEINFO_kindtypeANY
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Now, if the token is a close parenthese, we're in great shape so return      the next handler. */
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCLOSE_PAREN
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
comment|/* Oops, naughty user didn't specify the close paren! */
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_MISSING_CLOSE_PAREN
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_find_close_paren_
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_close_paren_ci_ -- OPEN_PAREN expr (possible complex or 				    implied-DO construct)     Pass it to ffeexpr_rhs as the callback routine.     Makes sure the end token is close-paren and swallows it, or a comma    and handles complex/implied-do possibilities, else issues    an error message and doesn't swallow the token (passing it along instead).  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_close_paren_ci_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprContext
name|ctx
decl_stmt|;
comment|/* First check to see if this is a possible complex or implied-DO entity.      It is if the token is a comma. */
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
condition|)
block|{
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextIOLIST
case|:
case|case
name|FFEEXPR_contextIMPDOITEM_
case|:
name|ctx
operator|=
name|FFEEXPR_contextIMPDOITEM_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextIOLISTDF
case|:
case|case
name|FFEEXPR_contextIMPDOITEMDF_
case|:
name|ctx
operator|=
name|FFEEXPR_contextIMPDOITEMDF_
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad context"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|FFEEXPR_contextIMPDOITEM_
expr_stmt|;
break|break;
block|}
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|ctx
argument_list|,
name|ffeexpr_cb_comma_ci_
argument_list|)
return|;
block|}
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_close_paren_
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_comma_ci_ -- OPEN_PAREN expr COMMA expr     Pass it to ffeexpr_rhs as the callback routine.     If this token is not a comma, we have a complex constant (or an attempt    at one), so handle it accordingly, displaying error messages if the token    is not a close-paren.  If we have a comma here, it is an attempt at an    implied-DO, so start making a list accordingly.  Oh, it might be an    equal sign also, meaning an implied-DO with only one item in its list.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_ci_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebld
name|fexpr
decl_stmt|;
comment|/* First check to see if this is a possible complex constant.	 It is if the      token is not a comma or an equals sign, in which case it should be a      close-paren. */
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeCOMMA
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeEQUALS
operator|)
condition|)
block|{
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
operator|=
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_comma_c_
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
return|;
block|}
comment|/* Here we have either EQUALS or COMMA, meaning we are in an implied-DO      construct.	 Make a list and handle accordingly. */
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fexpr
operator|=
name|ffeexpr_stack_
operator|->
name|expr
expr_stmt|;
name|ffebld_init_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|ffebld_append_item
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|,
name|fexpr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_comma_i_1_
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_comma_i_ -- OPEN_PAREN expr     Pass it to ffeexpr_rhs as the callback routine.     Handle first item in an implied-DO construct.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_i_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeCOMMA
condition|)
block|{
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_BAD_IMPDO
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffebld_end_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|expr
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeCLOSE_PAREN
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_comma_i_5_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_comma_i_5_
return|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_comma_i_1_
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_comma_i_1_ -- OPEN_PAREN expr     Pass it to ffeexpr_rhs as the callback routine.     Handle first item in an implied-DO construct.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_i_1_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprContext
name|ctxi
decl_stmt|;
name|ffeexprContext
name|ctxc
decl_stmt|;
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextDATA
case|:
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
name|ctxi
operator|=
name|FFEEXPR_contextDATAIMPDOITEM_
expr_stmt|;
name|ctxc
operator|=
name|FFEEXPR_contextDATAIMPDOCTRL_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextIOLIST
case|:
case|case
name|FFEEXPR_contextIMPDOITEM_
case|:
name|ctxi
operator|=
name|FFEEXPR_contextIMPDOITEM_
expr_stmt|;
name|ctxc
operator|=
name|FFEEXPR_contextIMPDOCTRL_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextIOLISTDF
case|:
case|case
name|FFEEXPR_contextIMPDOITEMDF_
case|:
name|ctxi
operator|=
name|FFEEXPR_contextIMPDOITEMDF_
expr_stmt|;
name|ctxc
operator|=
name|FFEEXPR_contextIMPDOCTRL_
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad context"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ctxi
operator|=
name|FFEEXPR_context
expr_stmt|;
name|ctxc
operator|=
name|FFEEXPR_context
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
name|ffebld_append_item
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|ctxi
argument_list|,
name|ffeexpr_cb_comma_i_1_
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|ctxi
argument_list|,
name|ffeexpr_cb_comma_i_1_
argument_list|)
return|;
case|case
name|FFELEX_typeEQUALS
case|:
name|ffebld_end_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
comment|/* Complain if implied-DO variable in list of items to be read.  */
if|if
condition|(
operator|(
name|ctxc
operator|==
name|FFEEXPR_contextIMPDOCTRL_
operator|)
operator|&&
operator|!
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
name|ffeexpr_check_impdo_
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|,
name|expr
argument_list|,
name|ft
argument_list|)
expr_stmt|;
comment|/* Set doiter flag for all appropriate SYMTERs.  */
name|ffeexpr_update_impdo_
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|expr
operator|=
name|ffebld_new_impdo
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindNONE
argument_list|,
name|FFEINFO_whereNONE
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_init_list
argument_list|(
operator|&
operator|(
name|ffebld_right
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|)
operator|)
argument_list|,
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|ffebld_append_item
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|ctxc
argument_list|,
name|ffeexpr_cb_comma_i_2_
argument_list|)
return|;
default|default:
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_BAD_IMPDO
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffebld_end_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|expr
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeCLOSE_PAREN
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_comma_i_5_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_comma_i_5_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_comma_i_2_ -- OPEN_PAREN expr-list EQUALS expr     Pass it to ffeexpr_rhs as the callback routine.     Handle start-value in an implied-DO construct.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_i_2_
parameter_list|(
name|ffelexToken
name|ft
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprContext
name|ctx
decl_stmt|;
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextDATA
case|:
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
name|ctx
operator|=
name|FFEEXPR_contextDATAIMPDOCTRL_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextIOLIST
case|:
case|case
name|FFEEXPR_contextIOLISTDF
case|:
case|case
name|FFEEXPR_contextIMPDOITEM_
case|:
case|case
name|FFEEXPR_contextIMPDOITEMDF_
case|:
name|ctx
operator|=
name|FFEEXPR_contextIMPDOCTRL_
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad context"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|FFEEXPR_context
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
name|ffebld_append_item
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|ctx
argument_list|,
name|ffeexpr_cb_comma_i_3_
argument_list|)
return|;
break|break;
default|default:
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_BAD_IMPDO
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffebld_end_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|expr
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeCLOSE_PAREN
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_comma_i_5_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_comma_i_5_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_comma_i_3_ -- OPEN_PAREN expr-list EQUALS expr COMMA expr     Pass it to ffeexpr_rhs as the callback routine.     Handle end-value in an implied-DO construct.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_i_3_
parameter_list|(
name|ffelexToken
name|ft
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprContext
name|ctx
decl_stmt|;
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextDATA
case|:
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
name|ctx
operator|=
name|FFEEXPR_contextDATAIMPDOCTRL_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextIOLIST
case|:
case|case
name|FFEEXPR_contextIOLISTDF
case|:
case|case
name|FFEEXPR_contextIMPDOITEM_
case|:
case|case
name|FFEEXPR_contextIMPDOITEMDF_
case|:
name|ctx
operator|=
name|FFEEXPR_contextIMPDOCTRL_
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad context"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|FFEEXPR_context
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
name|ffebld_append_item
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|ctx
argument_list|,
name|ffeexpr_cb_comma_i_4_
argument_list|)
return|;
break|break;
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffebld_append_item
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_comma_i_4_
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|t
argument_list|)
return|;
break|break;
default|default:
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_BAD_IMPDO
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffebld_end_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|expr
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeCLOSE_PAREN
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_comma_i_5_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_comma_i_5_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_comma_i_4_ -- OPEN_PAREN expr-list EQUALS expr COMMA expr 			       [COMMA expr]     Pass it to ffeexpr_rhs as the callback routine.     Handle incr-value in an implied-DO construct.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_i_4_
parameter_list|(
name|ffelexToken
name|ft
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
name|ffebld_append_item
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|ffebld_end_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
block|{
name|ffebld
name|item
decl_stmt|;
for|for
control|(
name|item
operator|=
name|ffebld_left
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
if|if
condition|(
name|ffebld_op
argument_list|(
name|ffebld_head
argument_list|(
name|item
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
goto|goto
name|replace_with_any
goto|;
comment|/* :::::::::::::::::::: */
for|for
control|(
name|item
operator|=
name|ffebld_right
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
if|if
condition|(
operator|(
name|ffebld_head
argument_list|(
name|item
argument_list|)
operator|!=
name|NULL
operator|)
comment|/* Increment may be NULL. */
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|ffebld_head
argument_list|(
name|item
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
condition|)
goto|goto
name|replace_with_any
goto|;
comment|/* :::::::::::::::::::: */
block|}
break|break;
default|default:
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_BAD_IMPDO
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffebld_end_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|replace_with_any
label|:
comment|/* :::::::::::::::::::: */
name|ffeexpr_stack_
operator|->
name|expr
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCLOSE_PAREN
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_comma_i_5_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_comma_i_5_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_comma_i_5_ -- OPEN_PAREN expr-list EQUALS expr COMMA expr 			       [COMMA expr] CLOSE_PAREN     Pass it to ffeexpr_rhs as the callback routine.     Collects token following implied-DO construct for callback function.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_comma_i_5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprCallback
name|callback
decl_stmt|;
name|ffeexprStack_
name|s
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|ft
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
name|bool
name|terminate
decl_stmt|;
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextDATA
case|:
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
name|terminate
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextIOLIST
case|:
case|case
name|FFEEXPR_contextIOLISTDF
case|:
case|case
name|FFEEXPR_contextIMPDOITEM_
case|:
case|case
name|FFEEXPR_contextIMPDOITEMDF_
case|:
name|terminate
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad context"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|terminate
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|ffebld_pool_pop
argument_list|()
expr_stmt|;
name|callback
operator|=
name|ffeexpr_stack_
operator|->
name|callback
expr_stmt|;
name|ft
operator|=
name|ffeexpr_stack_
operator|->
name|first_token
expr_stmt|;
name|expr
operator|=
name|ffeexpr_stack_
operator|->
name|expr
expr_stmt|;
name|s
operator|=
name|ffeexpr_stack_
operator|->
name|previous
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
name|ffeexpr_stack_
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ffeexpr_stack_
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|=
name|s
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|callback
argument_list|)
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ft
argument_list|)
expr_stmt|;
if|if
condition|(
name|terminate
condition|)
block|{
name|ffesymbol_drive_sfnames
argument_list|(
name|ffeexpr_check_impctrl_
argument_list|)
expr_stmt|;
operator|--
name|ffeexpr_level_
expr_stmt|;
if|if
condition|(
name|ffeexpr_level_
operator|==
literal|0
condition|)
name|ffe_terminate_4
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|next
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_end_loc_ -- Handle end of %LOC subexpression     Makes sure the end token is close-paren and swallows it, else issues    an error message and doesn't swallow the token (passing it along instead).    In either case wraps up subexpression construction by enclosing the    ffebld expression in a %LOC.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_end_loc_
parameter_list|(
name|ffelexToken
name|ft
name|UNUSED
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
comment|/* First push the (%LOC) expression as an operand onto the expression      stack. */
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_percent_loc
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|ffecom_pointer_kind
argument_list|()
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereFLEETING
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* ~~ */
block|e->u.operand = ffeexpr_collapse_percent_loc (e->u.operand, ft);
endif|#
directive|endif
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Now, if the token is a close parenthese, we're in great shape so return      the next handler. */
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCLOSE_PAREN
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
block|}
comment|/* Oops, naughty user didn't specify the close paren! */
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_MISSING_CLOSE_PAREN
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_find_close_paren_
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_end_notloc_ -- PERCENT NAME(VAL,REF,DESCR) OPEN_PAREN expr     Should be CLOSE_PAREN, and make sure expr isn't a %(VAL,REF,DESCR).  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_end_notloc_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
name|ffebldOp
name|op
decl_stmt|;
comment|/* If expression is itself a %(VAL,REF,DESCR), complain and strip off all      such things until the lowest-level expression is reached.  */
name|op
operator|=
name|ffebld_op
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|==
name|FFEBLD_opPERCENT_VAL
operator|)
operator|||
operator|(
name|op
operator|==
name|FFEBLD_opPERCENT_REF
operator|)
operator|||
operator|(
name|op
operator|==
name|FFEBLD_opPERCENT_DESCR
operator|)
condition|)
block|{
if|if
condition|(
name|ffebad_start
argument_list|(
name|FFEBAD_NESTED_PERCENT
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ft
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
do|do
block|{
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|op
operator|=
name|ffebld_op
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|op
operator|==
name|FFEBLD_opPERCENT_VAL
operator|)
operator|||
operator|(
name|op
operator|==
name|FFEBLD_opPERCENT_REF
operator|)
operator|||
operator|(
name|op
operator|==
name|FFEBLD_opPERCENT_DESCR
operator|)
condition|)
do|;
block|}
comment|/* Push the expression as an operand onto the expression stack. */
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|percent
condition|)
block|{
case|case
name|FFEEXPR_percentVAL_
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_percent_val
argument_list|(
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_percentREF_
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_percent_ref
argument_list|(
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_percentDESCR_
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_percent_descr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"%lossage"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|expr
expr_stmt|;
break|break;
block|}
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* ~~ */
block|e->u.operand = ffeexpr_collapse_percent_ ? ? ? (e->u.operand, ft);
endif|#
directive|endif
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Now, if the token is a close parenthese, we're in great shape so return      the next handler. */
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCLOSE_PAREN
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_end_notloc_1_
return|;
comment|/* Oops, naughty user didn't specify the close paren! */
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_MISSING_CLOSE_PAREN
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffebld_set_op
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|FFEBLD_opPERCENT_LOC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad context?!?!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_find_close_paren_
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_cb_end_notloc_1_
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_cb_end_notloc_1_ -- PERCENT NAME(VAL,REF,DESCR) OPEN_PAREN expr    CLOSE_PAREN     Should be COMMA or CLOSE_PAREN, else change back to %LOC.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_cb_end_notloc_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextACTUALARG_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
break|break;
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextACTUALARG_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFACTUALARG_
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad context?!?!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
if|if
condition|(
name|ffebad_start
argument_list|(
name|FFEBAD_INVALID_PERCENT
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffebld_set_op
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|u
operator|.
name|operand
argument_list|,
name|FFEBLD_opPERCENT_LOC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad context?!?!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process DATA implied-DO iterator variables as this implied-DO level    terminates.  At this point, ffeexpr_level_ == 1 when we see the    last right-paren in "DATA (A(I),I=1,10)/.../".  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffeexpr_check_impctrl_
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|assert
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffesymbol_sfdummyparent
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|FFESYMBOL_stateNONE
case|:
comment|/* Used as iterator already. Now let symbol 				   be used as iterator at any level at or 				   innermore than the outermost of the 				   current level and the symbol's current 				   level. */
if|if
condition|(
name|ffeexpr_level_
operator|<
name|ffesymbol_maxentrynum
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_set_maxentrynum
argument_list|(
name|s
argument_list|,
name|ffeexpr_level_
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FFESYMBOL_stateSEEN
case|:
comment|/* Seen already in this or other implied-DO. 				   Error if at outermost level, else it can 				   still become an iterator. */
if|if
condition|(
operator|(
name|ffeexpr_level_
operator|==
literal|1
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_BAD_IMPDCL
argument_list|)
condition|)
block|{
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffesymbol_where_line
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where_column
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|FFESYMBOL_stateUNCERTAIN
case|:
comment|/* Iterator. */
name|assert
argument_list|(
name|ffeexpr_level_
operator|<=
name|ffesymbol_maxentrynum
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateNONE
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESYMBOL_stateUNDERSTOOD
case|:
break|break;
comment|/* ANY. */
default|default:
name|assert
argument_list|(
literal|"Sasha Foo!!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Issue diagnostic if implied-DO variable appears in list of lhs    expressions (as in "READ *, (I,I=1,10)").  */
end_comment

begin_function
specifier|static
name|void
name|ffeexpr_check_impdo_
parameter_list|(
name|ffebld
name|list
parameter_list|,
name|ffelexToken
name|list_t
parameter_list|,
name|ffebld
name|dovar
parameter_list|,
name|ffelexToken
name|dovar_t
parameter_list|)
block|{
name|ffebld
name|item
decl_stmt|;
name|ffesymbol
name|dovar_sym
decl_stmt|;
name|int
name|itemnum
decl_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|dovar
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
condition|)
return|return;
comment|/* Presumably opANY. */
name|dovar_sym
operator|=
name|ffebld_symter
argument_list|(
name|dovar
argument_list|)
expr_stmt|;
for|for
control|(
name|itemnum
operator|=
literal|1
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
operator|,
operator|++
name|itemnum
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|item
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|item
argument_list|)
operator|==
name|FFEBLD_opSYMTER
operator|)
operator|&&
operator|(
name|ffebld_symter
argument_list|(
name|item
argument_list|)
operator|==
name|dovar_sym
operator|)
condition|)
block|{
name|char
name|itemno
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
operator|&
name|itemno
index|[
literal|0
index|]
argument_list|,
literal|"%d"
argument_list|,
name|itemnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebad_start
argument_list|(
name|FFEBAD_DOITER_IMPDO
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|list_t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|list_t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|dovar_t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|dovar_t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|dovar_sym
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|itemno
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Decorate any SYMTERs referencing the DO variable with the "doiter"    flag.  */
end_comment

begin_function
specifier|static
name|void
name|ffeexpr_update_impdo_
parameter_list|(
name|ffebld
name|list
parameter_list|,
name|ffebld
name|dovar
parameter_list|)
block|{
name|ffesymbol
name|dovar_sym
decl_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|dovar
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
condition|)
return|return;
comment|/* Presumably opANY. */
name|dovar_sym
operator|=
name|ffebld_symter
argument_list|(
name|dovar
argument_list|)
expr_stmt|;
name|ffeexpr_update_impdo_sym_
argument_list|(
name|list
argument_list|,
name|dovar_sym
argument_list|)
expr_stmt|;
comment|/* Recurse! */
block|}
end_function

begin_comment
comment|/* Recursive function to update any expr so SYMTERs have "doiter" flag    if they refer to the given variable.	 */
end_comment

begin_function
specifier|static
name|void
name|ffeexpr_update_impdo_sym_
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffesymbol
name|dovar
parameter_list|)
block|{
name|tail_recurse
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opSYMTER
case|:
if|if
condition|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
operator|==
name|dovar
condition|)
name|ffebld_symter_set_is_doiter
argument_list|(
name|expr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opITEM
case|:
name|ffeexpr_update_impdo_sym_
argument_list|(
name|ffebld_head
argument_list|(
name|expr
argument_list|)
argument_list|,
name|dovar
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_trail
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|tail_recurse
goto|;
comment|/* :::::::::::::::::::: */
default|default:
break|break;
block|}
switch|switch
condition|(
name|ffebld_arity
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
name|ffeexpr_update_impdo_sym_
argument_list|(
name|ffebld_left
argument_list|(
name|expr
argument_list|)
argument_list|,
name|dovar
argument_list|)
expr_stmt|;
name|expr
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|tail_recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
literal|1
case|:
name|expr
operator|=
name|ffebld_left
argument_list|(
name|expr
argument_list|)
expr_stmt|;
goto|goto
name|tail_recurse
goto|;
comment|/* :::::::::::::::::::: */
default|default:
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ffeexpr_context_outer_ -- Determine context of stack entry, skipping PARENs     if (ffeexpr_context_outer_(ffeexpr_stack_) == FFEEXPR_contextIF)        // After zero or more PAREN_ contexts, an IF context exists  */
end_comment

begin_function
specifier|static
name|ffeexprContext
name|ffeexpr_context_outer_
parameter_list|(
name|ffeexprStack_
name|s
parameter_list|)
block|{
name|assert
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextPAREN_
case|:
case|case
name|FFEEXPR_contextPARENFILENUM_
case|:
case|case
name|FFEEXPR_contextPARENFILEUNIT_
case|:
break|break;
default|default:
return|return
name|s
operator|->
name|context
return|;
block|}
name|s
operator|=
name|s
operator|->
name|previous
expr_stmt|;
name|assert
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffeexpr_percent_ -- Look up name in list of %FOO possibilities     ffeexprPercent_ p;    ffelexToken t;    p = ffeexpr_percent_(t);     Returns the identifier for the name, or the NONE identifier.	 */
end_comment

begin_function
specifier|static
name|ffeexprPercent_
name|ffeexpr_percent_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
literal|3
case|:
switch|switch
condition|(
operator|*
operator|(
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'L'
argument_list|,
literal|'l'
argument_list|,
name|match_3l
argument_list|,
name|no_match_3
argument_list|)
case|:
if|if
condition|(
operator|(
name|ffesrc_char_match_noninit
argument_list|(
operator|*
operator|++
name|p
argument_list|,
literal|'O'
argument_list|,
literal|'o'
argument_list|)
operator|)
operator|&&
operator|(
name|ffesrc_char_match_noninit
argument_list|(
operator|*
operator|++
name|p
argument_list|,
literal|'C'
argument_list|,
literal|'c'
argument_list|)
operator|)
condition|)
return|return
name|FFEEXPR_percentLOC_
return|;
return|return
name|FFEEXPR_percentNONE_
return|;
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'R'
argument_list|,
literal|'r'
argument_list|,
name|match_3r
argument_list|,
name|no_match_3
argument_list|)
case|:
if|if
condition|(
operator|(
name|ffesrc_char_match_noninit
argument_list|(
operator|*
operator|++
name|p
argument_list|,
literal|'E'
argument_list|,
literal|'e'
argument_list|)
operator|)
operator|&&
operator|(
name|ffesrc_char_match_noninit
argument_list|(
operator|*
operator|++
name|p
argument_list|,
literal|'F'
argument_list|,
literal|'f'
argument_list|)
operator|)
condition|)
return|return
name|FFEEXPR_percentREF_
return|;
return|return
name|FFEEXPR_percentNONE_
return|;
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'V'
argument_list|,
literal|'v'
argument_list|,
name|match_3v
argument_list|,
name|no_match_3
argument_list|)
case|:
if|if
condition|(
operator|(
name|ffesrc_char_match_noninit
argument_list|(
operator|*
operator|++
name|p
argument_list|,
literal|'A'
argument_list|,
literal|'a'
argument_list|)
operator|)
operator|&&
operator|(
name|ffesrc_char_match_noninit
argument_list|(
operator|*
operator|++
name|p
argument_list|,
literal|'L'
argument_list|,
literal|'l'
argument_list|)
operator|)
condition|)
return|return
name|FFEEXPR_percentVAL_
return|;
return|return
name|FFEEXPR_percentNONE_
return|;
default|default:
name|no_match_3
label|:
comment|/* :::::::::::::::::::: */
return|return
name|FFEEXPR_percentNONE_
return|;
block|}
case|case
literal|5
case|:
if|if
condition|(
name|ffesrc_strcmp_2c
argument_list|(
name|ffe_case_match
argument_list|()
argument_list|,
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"DESCR"
argument_list|,
literal|"descr"
argument_list|,
literal|"Descr"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FFEEXPR_percentDESCR_
return|;
return|return
name|FFEEXPR_percentNONE_
return|;
default|default:
return|return
name|FFEEXPR_percentNONE_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeexpr_type_combine -- Binop combine types, check for mythical new COMPLEX     See prototype.     If combining the two basictype/kindtype pairs produces a COMPLEX with an    unsupported kind type, complain and use the default kind type for    COMPLEX.  */
end_comment

begin_function
name|void
name|ffeexpr_type_combine
parameter_list|(
name|ffeinfoBasictype
modifier|*
name|xnbt
parameter_list|,
name|ffeinfoKindtype
modifier|*
name|xnkt
parameter_list|,
name|ffeinfoBasictype
name|lbt
parameter_list|,
name|ffeinfoKindtype
name|lkt
parameter_list|,
name|ffeinfoBasictype
name|rbt
parameter_list|,
name|ffeinfoKindtype
name|rkt
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeinfoBasictype
name|nbt
decl_stmt|;
name|ffeinfoKindtype
name|nkt
decl_stmt|;
name|nbt
operator|=
name|ffeinfo_basictype_combine
argument_list|(
name|lbt
argument_list|,
name|rbt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|&&
operator|(
operator|(
name|lbt
operator|==
name|nbt
operator|)
operator|||
operator|(
name|lbt
operator|==
name|FFEINFO_basictypeREAL
operator|)
operator|)
operator|&&
operator|(
operator|(
name|rbt
operator|==
name|nbt
operator|)
operator|||
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeREAL
operator|)
operator|)
condition|)
block|{
name|nkt
operator|=
name|ffeinfo_kindtype_max
argument_list|(
name|nbt
argument_list|,
name|lkt
argument_list|,
name|rkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_pedantic_not_90
argument_list|()
operator|&&
operator|(
name|nkt
operator|==
name|FFEINFO_kindtypeREALDOUBLE
operator|)
condition|)
name|nkt
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
comment|/* Force error. */
switch|switch
condition|(
name|nkt
condition|)
block|{
if|#
directive|if
name|FFETARGET_okCOMPLEX1
case|case
name|FFEINFO_kindtypeREAL1
case|:
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX2
case|case
name|FFEINFO_kindtypeREAL2
case|:
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX3
case|case
name|FFEINFO_kindtypeREAL3
case|:
endif|#
directive|endif
if|#
directive|if
name|FFETARGET_okCOMPLEX4
case|case
name|FFEINFO_kindtypeREAL4
case|:
endif|#
directive|endif
break|break;
comment|/* Fine and dandy. */
default|default:
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
operator|(
name|nkt
operator|==
name|FFEINFO_kindtypeREALDOUBLE
operator|)
condition|?
name|FFEBAD_BAD_DBLCMPLX
else|:
name|FFEBAD_BAD_COMPLEX
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|nbt
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
name|nkt
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindtypeANY
case|:
name|nkt
operator|=
name|FFEINFO_kindtypeREALDEFAULT
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* The normal stuff. */
if|if
condition|(
name|nbt
operator|==
name|lbt
condition|)
block|{
if|if
condition|(
name|nbt
operator|==
name|rbt
condition|)
name|nkt
operator|=
name|ffeinfo_kindtype_max
argument_list|(
name|nbt
argument_list|,
name|lkt
argument_list|,
name|rkt
argument_list|)
expr_stmt|;
else|else
name|nkt
operator|=
name|lkt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nbt
operator|==
name|rbt
condition|)
name|nkt
operator|=
name|rkt
expr_stmt|;
else|else
block|{
comment|/* Let the caller do the complaining. */
name|nbt
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
name|nkt
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
block|}
block|}
comment|/* Always a good idea to avoid aliasing problems.  */
operator|*
name|xnbt
operator|=
name|nbt
expr_stmt|;
operator|*
name|xnkt
operator|=
name|nkt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_first_lhs_ -- First state for lhs expression     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Record line and column of first token in expression, then invoke the    initial-state lhs handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_lhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexpr_stack_
operator|->
name|first_token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* When changing the list of valid initial lhs tokens, check whether to      update a corresponding list in ffeexpr_cb_close_paren_ambig_1_ for the      READ (expr)<token> case -- it assumes it knows which tokens<token> can      be to indicate an lhs (or implied DO), which right now is the set      {NAME,OPEN_PAREN}.       This comment also appears in ffeexpr_token_lhs_. */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextDATA
case|:
name|ffe_init_4
argument_list|()
expr_stmt|;
name|ffeexpr_level_
operator|=
literal|1
expr_stmt|;
comment|/* Level of DATA implied-DO construct. */
name|ffebld_init_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextDATAIMPDOITEM_
argument_list|,
name|ffeexpr_cb_comma_i_
argument_list|)
return|;
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
operator|++
name|ffeexpr_level_
expr_stmt|;
comment|/* Level of DATA implied-DO construct. */
name|ffebld_init_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextDATAIMPDOITEM_
argument_list|,
name|ffeexpr_cb_comma_i_
argument_list|)
return|;
case|case
name|FFEEXPR_contextIOLIST
case|:
case|case
name|FFEEXPR_contextIMPDOITEM_
case|:
name|ffebld_init_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextIMPDOITEM_
argument_list|,
name|ffeexpr_cb_comma_i_
argument_list|)
return|;
case|case
name|FFEEXPR_contextIOLISTDF
case|:
case|case
name|FFEEXPR_contextIMPDOITEMDF_
case|:
name|ffebld_init_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_lhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextIMPDOITEMDF_
argument_list|,
name|ffeexpr_cb_comma_i_
argument_list|)
return|;
case|case
name|FFEEXPR_contextFILEEXTFUNC
case|:
name|assert
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_first_lhs_1_
return|;
default|default:
break|break;
block|}
break|break;
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextFILENAMELIST
case|:
name|assert
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_namelist_
return|;
case|case
name|FFEEXPR_contextFILEEXTFUNC
case|:
name|assert
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_first_lhs_1_
return|;
default|default:
break|break;
block|}
break|break;
default|default:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextFILEEXTFUNC
case|:
name|assert
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_first_lhs_1_
return|;
default|default:
break|break;
block|}
break|break;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_lhs_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_first_lhs_1_ -- NAME     return ffeexpr_token_first_lhs_1_;  // to lexer     Handle NAME as an external function (USEROPEN= VXT extension to OPEN    statement).	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_lhs_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprCallback
name|callback
decl_stmt|;
name|ffeexprStack_
name|s
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|ft
decl_stmt|;
name|ffesymbol
name|sy
init|=
name|NULL
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
name|ffebld_pool_pop
argument_list|()
expr_stmt|;
name|callback
operator|=
name|ffeexpr_stack_
operator|->
name|callback
expr_stmt|;
name|ft
operator|=
name|ffeexpr_stack_
operator|->
name|first_token
expr_stmt|;
name|s
operator|=
name|ffeexpr_stack_
operator|->
name|previous
expr_stmt|;
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|ft
argument_list|)
operator|!=
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffesymbol_attrs
argument_list|(
name|sy
operator|=
name|ffeexpr_declare_unadorned_
argument_list|(
name|ft
argument_list|,
name|FALSE
argument_list|)
argument_list|)
operator|&
name|FFESYMBOL_attrANY
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|ft
argument_list|)
operator|!=
name|FFELEX_typeNAME
operator|)
operator|||
operator|!
operator|(
name|ffesymbol_attrs
argument_list|(
name|sy
argument_list|)
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_EXPR_WRONG
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ft
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|expr
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expr
operator|=
name|ffebld_new_symter
argument_list|(
name|sy
argument_list|,
name|FFEINTRIN_genNONE
argument_list|,
name|FFEINTRIN_specNONE
argument_list|,
name|FFEINTRIN_impNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffesymbol_info
argument_list|(
name|sy
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|malloc_kill_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
name|ffeexpr_stack_
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ffeexpr_stack_
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|=
name|s
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|callback
argument_list|)
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|next
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_first_rhs_ -- First state for rhs expression     Record line and column of first token in expression, then invoke the    initial-state rhs handler.     19-Feb-91  JCB  1.1       Allow ASTERISK in PARENFILEUNIT_ case, but only on second level only       (i.e. only as in READ(*), not READ((*))).	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_rhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffeexpr_stack_
operator|->
name|first_token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeASTERISK
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextFILEFORMATNML
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextFILEFORMAT
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FFEEXPR_contextFILEUNIT
case|:
case|case
name|FFEEXPR_contextDIMLIST
case|:
case|case
name|FFEEXPR_contextFILEFORMAT
case|:
case|case
name|FFEEXPR_contextCHARACTERSIZE
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|previous
operator|!=
name|NULL
condition|)
break|break;
comment|/* Valid only on first level. */
name|assert
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_first_rhs_1_
return|;
case|case
name|FFEEXPR_contextPARENFILEUNIT_
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|previous
operator|->
name|previous
operator|!=
name|NULL
condition|)
break|break;
comment|/* Valid only on second level. */
name|assert
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_first_rhs_1_
return|;
case|case
name|FFEEXPR_contextACTUALARG_
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|previous
operator|->
name|context
operator|!=
name|FFEEXPR_contextSUBROUTINEREF
condition|)
block|{
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextACTUALARGEXPR_
expr_stmt|;
break|break;
block|}
name|assert
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_first_rhs_3_
return|;
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextFILENUMAMBIG
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextPARENFILENUM_
argument_list|,
name|ffeexpr_cb_close_paren_ambig_
argument_list|)
return|;
case|case
name|FFEEXPR_contextFILEUNITAMBIG
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextPARENFILEUNIT_
argument_list|,
name|ffeexpr_cb_close_paren_ambig_
argument_list|)
return|;
case|case
name|FFEEXPR_contextIOLIST
case|:
case|case
name|FFEEXPR_contextIMPDOITEM_
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextIMPDOITEM_
argument_list|,
name|ffeexpr_cb_close_paren_ci_
argument_list|)
return|;
case|case
name|FFEEXPR_contextIOLISTDF
case|:
case|case
name|FFEEXPR_contextIMPDOITEMDF_
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextIMPDOITEMDF_
argument_list|,
name|ffeexpr_cb_close_paren_ci_
argument_list|)
return|;
case|case
name|FFEEXPR_contextFILEFORMATNML
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextFILEFORMAT
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FFELEX_typeNUMBER
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextFILEFORMATNML
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextFILEFORMAT
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FFEEXPR_contextFILEFORMAT
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|previous
operator|!=
name|NULL
condition|)
break|break;
comment|/* Valid only on first level. */
name|assert
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_first_rhs_2_
return|;
case|case
name|FFEEXPR_contextACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FFELEX_typeNAME
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextFILEFORMATNML
case|:
name|assert
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_lookup_local
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_kindNAMELIST
operator|)
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_namelist_
return|;
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextFILEFORMAT
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FFELEX_typePERCENT
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextACTUALARG_
case|:
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_first_rhs_5_
return|;
case|case
name|FFEEXPR_contextFILEFORMATNML
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextFILEFORMAT
expr_stmt|;
break|break;
default|default:
break|break;
block|}
default|default:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextFILEFORMATNML
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextFILEFORMAT
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_first_rhs_1_ -- ASTERISK     return ffeexpr_token_first_rhs_1_;  // to lexer     Return STAR as expression.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_rhs_1_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebld
name|expr
decl_stmt|;
name|ffeexprCallback
name|callback
decl_stmt|;
name|ffeexprStack_
name|s
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|ft
decl_stmt|;
name|expr
operator|=
name|ffebld_new_star
argument_list|()
expr_stmt|;
name|ffebld_pool_pop
argument_list|()
expr_stmt|;
name|callback
operator|=
name|ffeexpr_stack_
operator|->
name|callback
expr_stmt|;
name|ft
operator|=
name|ffeexpr_stack_
operator|->
name|first_token
expr_stmt|;
name|s
operator|=
name|ffeexpr_stack_
operator|->
name|previous
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
name|ffeexpr_stack_
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ffeexpr_stack_
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|=
name|s
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|callback
argument_list|)
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|next
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_first_rhs_2_ -- NUMBER     return ffeexpr_token_first_rhs_2_;  // to lexer     Return NULL as expression; NUMBER as first (and only) token, unless the    current token is not a terminating token, in which case run normal    expression handling.	 */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_rhs_2_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprCallback
name|callback
decl_stmt|;
name|ffeexprStack_
name|s
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|ft
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeEOS
case|:
case|case
name|FFELEX_typeSEMICOLON
case|:
break|break;
default|default:
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffebld_pool_pop
argument_list|()
expr_stmt|;
name|callback
operator|=
name|ffeexpr_stack_
operator|->
name|callback
expr_stmt|;
name|ft
operator|=
name|ffeexpr_stack_
operator|->
name|first_token
expr_stmt|;
name|s
operator|=
name|ffeexpr_stack_
operator|->
name|previous
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
name|ffeexpr_stack_
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ffeexpr_stack_
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|=
name|s
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|callback
argument_list|)
argument_list|(
name|ft
argument_list|,
name|NULL
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|next
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_first_rhs_3_ -- ASTERISK     return ffeexpr_token_first_rhs_3_;  // to lexer     Expect NUMBER, make LABTOK (with copy of token if not inhibited after    confirming, else NULL).  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_rhs_3_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNUMBER
condition|)
block|{
comment|/* An error, but let normal processing handle 				   it. */
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
comment|/* Special case: when we see "*10" as an argument to a subroutine      reference, we confirm the current statement and, if not inhibited at      this point, put a copy of the token into a LABTOK node.  We do this      instead of just resolving the label directly via ffelab and putting it      into a LABTER simply to improve error reporting and consistency in      ffestc.  We put NULL in the LABTOK if we're still inhibited, so ffestb      doesn't have to worry about killing off any tokens when retracting. */
name|ffest_confirmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffest_is_inhibited
argument_list|()
condition|)
name|ffeexpr_stack_
operator|->
name|expr
operator|=
name|ffebld_new_labtok
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ffeexpr_stack_
operator|->
name|expr
operator|=
name|ffebld_new_labtok
argument_list|(
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindNONE
argument_list|,
name|FFEINFO_whereNONE
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_first_rhs_4_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_first_rhs_4_ -- ASTERISK NUMBER     return ffeexpr_token_first_rhs_4_;  // to lexer     Collect/flush appropriate stuff, send token to callback function.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_rhs_4_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffebld
name|expr
decl_stmt|;
name|ffeexprCallback
name|callback
decl_stmt|;
name|ffeexprStack_
name|s
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|ft
decl_stmt|;
name|expr
operator|=
name|ffeexpr_stack_
operator|->
name|expr
expr_stmt|;
name|ffebld_pool_pop
argument_list|()
expr_stmt|;
name|callback
operator|=
name|ffeexpr_stack_
operator|->
name|callback
expr_stmt|;
name|ft
operator|=
name|ffeexpr_stack_
operator|->
name|first_token
expr_stmt|;
name|s
operator|=
name|ffeexpr_stack_
operator|->
name|previous
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
name|ffeexpr_stack_
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ffeexpr_stack_
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|=
name|s
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|callback
argument_list|)
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|next
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_first_rhs_5_ -- PERCENT     Should be NAME, or pass through original mechanism.  If NAME is LOC,    pass through original mechanism, otherwise must be VAL, REF, or DESCR,    in which case handle the argument (in parentheses), etc.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_rhs_5_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
condition|)
block|{
name|ffeexprPercent_
name|p
init|=
name|ffeexpr_percent_
argument_list|(
name|t
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|FFEEXPR_percentNONE_
case|:
case|case
name|FFEEXPR_percentLOC_
case|:
break|break;
comment|/* Treat %LOC as any other expression. */
case|case
name|FFEEXPR_percentVAL_
case|:
case|case
name|FFEEXPR_percentREF_
case|:
case|case
name|FFEEXPR_percentDESCR_
case|:
name|ffeexpr_stack_
operator|->
name|percent
operator|=
name|p
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_first_rhs_6_
return|;
default|default:
name|assert
argument_list|(
literal|"bad percent?!?"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad context?!?!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_first_rhs_6_ -- PERCENT NAME(VAL,REF,DESCR)     Should be OPEN_PAREN, or pass through original mechanism.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_first_rhs_6_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|ft
decl_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeOPEN_PAREN
condition|)
block|{
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|ffeexpr_stack_
operator|->
name|context
argument_list|,
name|ffeexpr_cb_end_notloc_
argument_list|)
return|;
block|}
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad context?!?!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|ft
operator|=
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
expr_stmt|;
name|next
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ft
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|next
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_namelist_ -- NAME     return ffeexpr_token_namelist_;  // to lexer     Make sure NAME was a valid namelist object, wrap it in a SYMTER and    return.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_namelist_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprCallback
name|callback
decl_stmt|;
name|ffeexprStack_
name|s
decl_stmt|;
name|ffelexHandler
name|next
decl_stmt|;
name|ffelexToken
name|ft
decl_stmt|;
name|ffesymbol
name|sy
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
name|ffebld_pool_pop
argument_list|()
expr_stmt|;
name|callback
operator|=
name|ffeexpr_stack_
operator|->
name|callback
expr_stmt|;
name|ft
operator|=
name|ffeexpr_stack_
operator|->
name|first_token
expr_stmt|;
name|s
operator|=
name|ffeexpr_stack_
operator|->
name|previous
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
name|ffeexpr_stack_
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ffeexpr_stack_
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|=
name|s
expr_stmt|;
name|sy
operator|=
name|ffesymbol_lookup_local
argument_list|(
name|ft
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sy
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffesymbol_kind
argument_list|(
name|sy
argument_list|)
operator|!=
name|FFEINFO_kindNAMELIST
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_EXPR_WRONG
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ft
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|expr
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expr
operator|=
name|ffebld_new_symter
argument_list|(
name|sy
argument_list|,
name|FFEINTRIN_genNONE
argument_list|,
name|FFEINTRIN_specNONE
argument_list|,
name|FFEINTRIN_impNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffesymbol_info
argument_list|(
name|sy
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|callback
argument_list|)
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|next
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_expr_kill_ -- Kill an existing internal expression object     ffeexprExpr_ e;    ffeexpr_expr_kill_(e);     Kills the ffewhere info, if necessary, then kills the object.  */
end_comment

begin_function
specifier|static
name|void
name|ffeexpr_expr_kill_
parameter_list|(
name|ffeexprExpr_
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|token
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|e
operator|->
name|token
argument_list|)
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
name|e
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffeexpr_expr_new_ -- Make a new internal expression object     ffeexprExpr_ e;    e = ffeexpr_expr_new_();     Allocates and initializes a new expression object, returns it.  */
end_comment

begin_function
specifier|static
name|ffeexprExpr_
name|ffeexpr_expr_new_
parameter_list|()
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
name|e
operator|=
operator|(
name|ffeexprExpr_
operator|)
name|malloc_new_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
literal|"FFEEXPR expr"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|previous
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeUNKNOWN_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|NULL
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Verify that call to global is valid, and register whatever    new information about a global might be discoverable by looking    at the call.  */
end_comment

begin_function
specifier|static
name|void
name|ffeexpr_fulfill_call_
parameter_list|(
name|ffebld
modifier|*
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|int
name|n_args
decl_stmt|;
name|ffebld
name|list
decl_stmt|;
name|ffebld
name|item
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|assert
argument_list|(
operator|(
name|ffebld_op
argument_list|(
operator|*
name|expr
argument_list|)
operator|==
name|FFEBLD_opSUBRREF
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
operator|*
name|expr
argument_list|)
operator|==
name|FFEBLD_opFUNCREF
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|ffebld_left
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
condition|)
return|return;
if|if
condition|(
name|ffesymbol_retractable
argument_list|()
condition|)
return|return;
name|s
operator|=
name|ffebld_symter
argument_list|(
name|ffebld_left
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_global
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|n_args
operator|=
literal|0
operator|,
name|list
operator|=
name|ffebld_right
argument_list|(
operator|*
name|expr
argument_list|)
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
operator|,
operator|++
name|n_args
control|)
empty_stmt|;
if|if
condition|(
name|ffeglobal_proc_ref_nargs
argument_list|(
name|s
argument_list|,
name|n_args
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|ffeglobalArgSummary
name|as
decl_stmt|;
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|bool
name|array
decl_stmt|;
name|bool
name|fail
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|n_args
operator|=
literal|0
operator|,
name|list
operator|=
name|ffebld_right
argument_list|(
operator|*
name|expr
argument_list|)
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|ffebld_trail
argument_list|(
name|list
argument_list|)
operator|,
operator|++
name|n_args
control|)
block|{
name|item
operator|=
name|ffebld_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
block|{
name|bt
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|array
operator|=
operator|(
name|ffeinfo_rank
argument_list|(
name|ffebld_info
argument_list|(
name|item
argument_list|)
argument_list|)
operator|>
literal|0
operator|)
expr_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|item
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opLABTOK
case|:
case|case
name|FFEBLD_opLABTER
case|:
name|as
operator|=
name|FFEGLOBAL_argsummaryALTRTN
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* No, %LOC(foo) is just like any INTEGER(KIND=7) 		     expression, so don't treat it specially.  */
block|case FFEBLD_opPERCENT_LOC: 		  as = FFEGLOBAL_argsummaryPTR; 		  break;
endif|#
directive|endif
case|case
name|FFEBLD_opPERCENT_VAL
case|:
name|as
operator|=
name|FFEGLOBAL_argsummaryVAL
expr_stmt|;
break|break;
case|case
name|FFEBLD_opPERCENT_REF
case|:
name|as
operator|=
name|FFEGLOBAL_argsummaryREF
expr_stmt|;
break|break;
case|case
name|FFEBLD_opPERCENT_DESCR
case|:
name|as
operator|=
name|FFEGLOBAL_argsummaryDESCR
expr_stmt|;
break|break;
case|case
name|FFEBLD_opFUNCREF
case|:
if|#
directive|if
literal|0
comment|/* No, LOC(foo) is just like any INTEGER(KIND=7) 		     expression, so don't treat it specially.  */
block|if ((ffebld_op (ffebld_left (item)) == FFEBLD_opSYMTER)&& (ffesymbol_specific (ffebld_symter (ffebld_left (item))) 			  == FFEINTRIN_specLOC)) 		    { 		      as = FFEGLOBAL_argsummaryPTR; 		      break; 		    }
endif|#
directive|endif
comment|/* Fall through.  */
default|default:
if|if
condition|(
name|ffebld_op
argument_list|(
name|item
argument_list|)
operator|==
name|FFEBLD_opSYMTER
condition|)
block|{
name|as
operator|=
name|FFEGLOBAL_argsummaryNONE
expr_stmt|;
switch|switch
condition|(
name|ffeinfo_kind
argument_list|(
name|ffebld_info
argument_list|(
name|item
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_kindFUNCTION
case|:
name|as
operator|=
name|FFEGLOBAL_argsummaryFUNC
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindSUBROUTINE
case|:
name|as
operator|=
name|FFEGLOBAL_argsummarySUBR
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindNONE
case|:
name|as
operator|=
name|FFEGLOBAL_argsummaryPROC
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|as
operator|!=
name|FFEGLOBAL_argsummaryNONE
condition|)
break|break;
block|}
if|if
condition|(
name|bt
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
name|as
operator|=
name|FFEGLOBAL_argsummaryDESCR
expr_stmt|;
else|else
name|as
operator|=
name|FFEGLOBAL_argsummaryREF
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|array
operator|=
name|FALSE
expr_stmt|;
name|as
operator|=
name|FFEGLOBAL_argsummaryNONE
expr_stmt|;
name|bt
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
name|kt
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ffeglobal_proc_ref_arg
argument_list|(
name|s
argument_list|,
name|n_args
argument_list|,
name|as
argument_list|,
name|bt
argument_list|,
name|kt
argument_list|,
name|array
argument_list|,
name|t
argument_list|)
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fail
condition|)
return|return;
block|}
operator|*
name|expr
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
operator|*
name|expr
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check whether rest of string is all decimal digits.  */
end_comment

begin_function
specifier|static
name|bool
name|ffeexpr_isdigits_
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_exprstack_push_ -- Push an arbitrary expression object onto the stack     ffeexprExpr_ e;    ffeexpr_exprstack_push_(e);     Pushes the expression onto the stack without any analysis of the existing    contents of the stack.  */
end_comment

begin_function
specifier|static
name|void
name|ffeexpr_exprstack_push_
parameter_list|(
name|ffeexprExpr_
name|e
parameter_list|)
block|{
name|e
operator|->
name|previous
operator|=
name|ffeexpr_stack_
operator|->
name|exprstack
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|exprstack
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffeexpr_exprstack_push_operand_ -- Push an operand onto the stack, reduce?     ffeexprExpr_ e;    ffeexpr_exprstack_push_operand_(e);     Pushes the expression already containing an operand (a constant, variable,    or more complicated expression that has already been fully resolved) after    analyzing the stack and checking for possible reduction (which will never    happen here since the highest precedence operator is ** and it has right-    to-left associativity).  */
end_comment

begin_function
specifier|static
name|void
name|ffeexpr_exprstack_push_operand_
parameter_list|(
name|ffeexprExpr_
name|e
parameter_list|)
block|{
name|ffeexpr_exprstack_push_
argument_list|(
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WEIRD_NONFORTRAN_RULES
if|if
condition|(
operator|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|expr
operator|->
name|type
operator|==
name|FFEEXPR_exprtypeBINARY_
operator|)
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|expr
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|==
name|FFEEXPR_operatorprecedenceHIGHEST_
operator|)
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|expr
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|==
name|FFEEXPR_operatorassociativityL2R_
operator|)
condition|)
name|ffeexpr_reduce_
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffeexpr_exprstack_push_unary_ -- Push a unary operator onto the stack     ffeexprExpr_ e;    ffeexpr_exprstack_push_unary_(e);     Pushes the expression already containing a unary operator.  Reduction can    never happen since unary operators are themselves always R-L; that is, the    top of the expression stack is not an operand, in that it is either empty,    has a binary operator at the top, or a unary operator at the top.  In any    of these cases, reduction is impossible.  */
end_comment

begin_function
specifier|static
name|void
name|ffeexpr_exprstack_push_unary_
parameter_list|(
name|ffeexprExpr_
name|e
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ffe_is_pedantic
argument_list|()
operator|||
name|ffe_is_warn_surprising
argument_list|()
operator|)
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|type
operator|!=
name|FFEEXPR_exprtypeOPERAND_
operator|)
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|<=
name|FFEEXPR_operatorprecedenceLOWARITH_
operator|)
operator|&&
operator|(
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|<=
name|FFEEXPR_operatorprecedenceLOWARITH_
operator|)
condition|)
block|{
name|ffebad_start_msg
argument_list|(
literal|"Two arithmetic operators in a row at %0 and %1 -- use parentheses"
argument_list|,
name|ffe_is_pedantic
argument_list|()
condition|?
name|FFEBAD_severityPEDANTIC
else|:
name|FFEBAD_severityWARNING
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|e
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|e
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffeexpr_exprstack_push_
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffeexpr_exprstack_push_binary_ -- Push a binary operator onto the stack, reduce?     ffeexprExpr_ e;    ffeexpr_exprstack_push_binary_(e);     Pushes the expression already containing a binary operator after checking    whether reduction is possible.  If the stack is not empty, the top of the    stack must be an operand or syntactic analysis has failed somehow.  If    the operand is preceded by a unary operator of higher (or equal and L-R    associativity) precedence than the new binary operator, then reduce that    preceding operator and its operand(s) before pushing the new binary    operator.  */
end_comment

begin_function
specifier|static
name|void
name|ffeexpr_exprstack_push_binary_
parameter_list|(
name|ffeexprExpr_
name|e
parameter_list|)
block|{
name|ffeexprExpr_
name|ce
decl_stmt|;
if|if
condition|(
name|ffe_is_warn_surprising
argument_list|()
comment|/* These next two are always true (see assertions below).  */
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|type
operator|==
name|FFEEXPR_exprtypeOPERAND_
operator|)
comment|/* If the previous operator is a unary minus, and the binary op 	 is of higher precedence, might not do what user expects, 	 e.g. "-2**2" is "-(2**2)", i.e. "-4", not "(-2)**2", which would 	 yield "4".  */
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|previous
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|previous
operator|->
name|type
operator|==
name|FFEEXPR_exprtypeUNARY_
operator|)
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|previous
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|==
name|FFEEXPR_operatorSUBTRACT_
operator|)
operator|&&
operator|(
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|<
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|previous
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|)
condition|)
block|{
name|ffebad_start_msg
argument_list|(
literal|"Operator at %0 has lower precedence than that at %1 -- use parentheses"
argument_list|,
name|FFEBAD_severityWARNING
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|previous
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|previous
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|e
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|e
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|again
label|:
name|assert
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|type
operator|==
name|FFEEXPR_exprtypeOPERAND_
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ce
operator|=
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|previous
operator|)
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|ce
operator|->
name|type
operator|!=
name|FFEEXPR_exprtypeOPERAND_
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ce
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|<
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|)
operator|||
operator|(
operator|(
name|ce
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|==
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|)
operator|&&
operator|(
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|==
name|FFEEXPR_operatorassociativityL2R_
operator|)
operator|)
condition|)
block|{
name|ffeexpr_reduce_
argument_list|()
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
name|ffeexpr_exprstack_push_
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffeexpr_reduce_ -- Reduce highest operator w/operands on stack     ffeexpr_reduce_();     Converts operand binop operand or unop operand at top of stack to a    single operand having the appropriate ffebld expression, and makes    sure that the expression is proper (like not trying to add two character    variables, not trying to concatenate two numbers).  Also does the    requisite type-assignment.  */
end_comment

begin_function
specifier|static
name|void
name|ffeexpr_reduce_
parameter_list|()
block|{
name|ffeexprExpr_
name|operand
decl_stmt|;
comment|/* This is B in -B or A+B. */
name|ffeexprExpr_
name|left_operand
decl_stmt|;
comment|/* When operator is binary, this is A in A+B. */
name|ffeexprExpr_
name|operator
decl_stmt|;
comment|/* This is + in A+B. */
name|ffebld
name|reduced
decl_stmt|;
comment|/* This is +(A,B) in A+B or u-(B) in -B. */
name|ffebldConstant
name|constnode
decl_stmt|;
comment|/* For checking magical numbers (where mag == 				   -mag). */
name|ffebld
name|expr
decl_stmt|;
name|ffebld
name|left_expr
decl_stmt|;
name|bool
name|submag
init|=
name|FALSE
decl_stmt|;
name|operand
operator|=
name|ffeexpr_stack_
operator|->
name|exprstack
expr_stmt|;
name|assert
argument_list|(
name|operand
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|operand
operator|->
name|type
operator|==
name|FFEEXPR_exprtypeOPERAND_
argument_list|)
expr_stmt|;
name|operator
operator|=
name|operand
operator|->
name|previous
expr_stmt|;
name|assert
argument_list|(
name|operator
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|operator
operator|->
name|type
operator|!=
name|FFEEXPR_exprtypeOPERAND_
argument_list|)
expr_stmt|;
if|if
condition|(
name|operator
operator|->
name|type
operator|==
name|FFEEXPR_exprtypeUNARY_
condition|)
block|{
name|expr
operator|=
name|operand
operator|->
name|u
operator|.
name|operand
expr_stmt|;
switch|switch
condition|(
name|operator
operator|->
name|u
operator|.
name|operator
operator|.
name|op
condition|)
block|{
case|case
name|FFEEXPR_operatorADD_
case|:
name|reduced
operator|=
name|ffebld_new_uplus
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly1_
argument_list|(
name|reduced
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_math1_
argument_list|(
name|reduced
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_uplus
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorSUBTRACT_
case|:
name|submag
operator|=
name|TRUE
expr_stmt|;
comment|/* Ok to negate a magic number. */
name|reduced
operator|=
name|ffebld_new_uminus
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly1_
argument_list|(
name|reduced
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_math1_
argument_list|(
name|reduced
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_uminus
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorNOT_
case|:
name|reduced
operator|=
name|ffebld_new_not
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly1log_
argument_list|(
name|reduced
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_bool1_
argument_list|(
name|reduced
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_not
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"unexpected unary op"
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|submag
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|&&
operator|(
name|ffebld_conter_orig
argument_list|(
name|expr
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
name|ffebld_constant_is_magical
argument_list|(
name|constnode
operator|=
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
name|ffetarget_integer_bad_magical
argument_list|(
name|operand
operator|->
name|token
argument_list|)
expr_stmt|;
block|}
name|ffeexpr_stack_
operator|->
name|exprstack
operator|=
name|operator
operator|->
name|previous
expr_stmt|;
comment|/* Pops unary-op operand 							   off stack. */
name|ffeexpr_expr_kill_
argument_list|(
name|operand
argument_list|)
expr_stmt|;
name|operator
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
comment|/* Convert operator, but 							   save */
name|operator
operator|->
name|u
operator|.
name|operand
operator|=
name|reduced
expr_stmt|;
comment|/* the line/column ffewhere info. */
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|operator
argument_list|)
expr_stmt|;
comment|/* Push it back on 							   stack. */
block|}
else|else
block|{
name|assert
argument_list|(
name|operator
operator|->
name|type
operator|==
name|FFEEXPR_exprtypeBINARY_
argument_list|)
expr_stmt|;
name|left_operand
operator|=
name|operator
operator|->
name|previous
expr_stmt|;
name|assert
argument_list|(
name|left_operand
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|left_operand
operator|->
name|type
operator|==
name|FFEEXPR_exprtypeOPERAND_
argument_list|)
expr_stmt|;
name|expr
operator|=
name|operand
operator|->
name|u
operator|.
name|operand
expr_stmt|;
name|left_expr
operator|=
name|left_operand
operator|->
name|u
operator|.
name|operand
expr_stmt|;
switch|switch
condition|(
name|operator
operator|->
name|u
operator|.
name|operator
operator|.
name|op
condition|)
block|{
case|case
name|FFEEXPR_operatorADD_
case|:
name|reduced
operator|=
name|ffebld_new_add
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_math2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_add
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorSUBTRACT_
case|:
name|submag
operator|=
name|TRUE
expr_stmt|;
comment|/* Just to pick the right error if magic 				   number. */
name|reduced
operator|=
name|ffebld_new_subtract
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_math2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_subtract
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorMULTIPLY_
case|:
name|reduced
operator|=
name|ffebld_new_multiply
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_math2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_multiply
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorDIVIDE_
case|:
name|reduced
operator|=
name|ffebld_new_divide
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_math2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_divide
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorPOWER_
case|:
name|reduced
operator|=
name|ffebld_new_power
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_power_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_power
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorCONCATENATE_
case|:
name|reduced
operator|=
name|ffebld_new_concatenate
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_concatenate_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_concatenate
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorLT_
case|:
name|reduced
operator|=
name|ffebld_new_lt
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_relop2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_lt
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorLE_
case|:
name|reduced
operator|=
name|ffebld_new_le
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_relop2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_le
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorEQ_
case|:
name|reduced
operator|=
name|ffebld_new_eq
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_eqop2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_eq
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorNE_
case|:
name|reduced
operator|=
name|ffebld_new_ne
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_eqop2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_ne
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorGT_
case|:
name|reduced
operator|=
name|ffebld_new_gt
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_relop2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_gt
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorGE_
case|:
name|reduced
operator|=
name|ffebld_new_ge
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_relop2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_ge
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorAND_
case|:
name|reduced
operator|=
name|ffebld_new_and
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2log_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_bool2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_and
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorOR_
case|:
name|reduced
operator|=
name|ffebld_new_or
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2log_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_bool2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_or
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorXOR_
case|:
name|reduced
operator|=
name|ffebld_new_xor
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2log_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_bool2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_xor
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorEQV_
case|:
name|reduced
operator|=
name|ffebld_new_eqv
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2log_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_bool2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_eqv
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_operatorNEQV_
case|:
name|reduced
operator|=
name|ffebld_new_neqv
argument_list|(
name|left_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|reduced
operator|=
name|ffeexpr_reduced_ugly2log_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_reduced_bool2_
argument_list|(
name|reduced
argument_list|,
name|left_operand
argument_list|,
name|operator
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_neqv
argument_list|(
name|reduced
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad bin op"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|expr
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ffebld_op
argument_list|(
name|left_expr
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|&&
operator|(
name|ffebld_conter_orig
argument_list|(
name|expr
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
name|ffebld_constant_is_magical
argument_list|(
name|constnode
operator|=
name|ffebld_conter
argument_list|(
name|left_expr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|left_operand
operator|->
name|previous
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|left_operand
operator|->
name|previous
operator|->
name|type
operator|!=
name|FFEEXPR_exprtypeOPERAND_
operator|)
operator|&&
operator|(
name|left_operand
operator|->
name|previous
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|==
name|FFEEXPR_operatorSUBTRACT_
operator|)
condition|)
block|{
if|if
condition|(
name|left_operand
operator|->
name|previous
operator|->
name|type
operator|==
name|FFEEXPR_exprtypeUNARY_
condition|)
name|ffetarget_integer_bad_magical_precedence
argument_list|(
name|left_operand
operator|->
name|token
argument_list|,
name|left_operand
operator|->
name|previous
operator|->
name|token
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
else|else
name|ffetarget_integer_bad_magical_precedence_binary
argument_list|(
name|left_operand
operator|->
name|token
argument_list|,
name|left_operand
operator|->
name|previous
operator|->
name|token
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
block|}
else|else
name|ffetarget_integer_bad_magical
argument_list|(
name|left_operand
operator|->
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|&&
operator|(
name|ffebld_conter_orig
argument_list|(
name|expr
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
name|ffebld_constant_is_magical
argument_list|(
name|constnode
operator|=
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|submag
condition|)
name|ffetarget_integer_bad_magical_binary
argument_list|(
name|operand
operator|->
name|token
argument_list|,
name|operator
operator|->
name|token
argument_list|)
expr_stmt|;
else|else
name|ffetarget_integer_bad_magical
argument_list|(
name|operand
operator|->
name|token
argument_list|)
expr_stmt|;
block|}
name|ffeexpr_stack_
operator|->
name|exprstack
operator|=
name|left_operand
operator|->
name|previous
expr_stmt|;
comment|/* Pops binary-op 								   operands off stack. */
name|ffeexpr_expr_kill_
argument_list|(
name|left_operand
argument_list|)
expr_stmt|;
name|ffeexpr_expr_kill_
argument_list|(
name|operand
argument_list|)
expr_stmt|;
name|operator
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
comment|/* Convert operator, but 							   save */
name|operator
operator|->
name|u
operator|.
name|operand
operator|=
name|reduced
expr_stmt|;
comment|/* the line/column ffewhere info. */
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|operator
argument_list|)
expr_stmt|;
comment|/* Push it back on 							   stack. */
block|}
block|}
end_function

begin_comment
comment|/* ffeexpr_reduced_bool1_ -- Wrap up reduction of NOT operator     reduced = ffeexpr_reduced_bool1_(reduced,op,r);     Makes sure the argument for reduced has basictype of    LOGICAL or (ugly) INTEGER.  If    argument has where of CONSTANT, assign where CONSTANT to    reduced, else assign where FLEETING.     If these requirements cannot be met, generate error message.	 */
end_comment

begin_function
specifier|static
name|ffebld
name|ffeexpr_reduced_bool1_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
block|{
name|ffeinfo
name|rinfo
decl_stmt|,
name|ninfo
decl_stmt|;
name|ffeinfoBasictype
name|rbt
decl_stmt|;
name|ffeinfoKindtype
name|rkt
decl_stmt|;
name|ffeinfoRank
name|rrk
decl_stmt|;
name|ffeinfoKind
name|rkd
decl_stmt|;
name|ffeinfoWhere
name|rwh
decl_stmt|,
name|nwh
decl_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rrk
operator|=
name|ffeinfo_rank
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkd
operator|=
name|ffeinfo_kind
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeLOGICAL
operator|)
operator|||
operator|(
name|ffe_is_ugly_logint
argument_list|()
operator|&&
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|)
operator|)
operator|&&
operator|(
name|rrk
operator|==
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
name|nwh
operator|=
name|FFEINFO_whereCONSTANT
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|nwh
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
name|ninfo
operator|=
name|ffeinfo_new
argument_list|(
name|rbt
argument_list|,
name|rkt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|nwh
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ninfo
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeLOGICAL
operator|)
operator|&&
operator|(
operator|!
name|ffe_is_ugly_logint
argument_list|()
operator|||
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_NOT_ARG_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rkd
operator|!=
name|FFEINFO_kindANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_NOT_ARG_KIND
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"an array"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|reduced
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_reduced_bool2_ -- Wrap up reduction of boolean operators     reduced = ffeexpr_reduced_bool2_(reduced,l,op,r);     Makes sure the left and right arguments for reduced have basictype of    LOGICAL or (ugly) INTEGER.  Determine common basictype and    size for reduction (flag expression for combined hollerith/typeless    situations for later determination of effective basictype).	If both left    and right arguments have where of CONSTANT, assign where CONSTANT to    reduced, else assign where FLEETING.	 Create CONVERT ops for args where    needed.  Convert typeless    constants to the desired type/size explicitly.     If these requirements cannot be met, generate error message.	 */
end_comment

begin_function
specifier|static
name|ffebld
name|ffeexpr_reduced_bool2_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
block|{
name|ffeinfo
name|linfo
decl_stmt|,
name|rinfo
decl_stmt|,
name|ninfo
decl_stmt|;
name|ffeinfoBasictype
name|lbt
decl_stmt|,
name|rbt
decl_stmt|,
name|nbt
decl_stmt|;
name|ffeinfoKindtype
name|lkt
decl_stmt|,
name|rkt
decl_stmt|,
name|nkt
decl_stmt|;
name|ffeinfoRank
name|lrk
decl_stmt|,
name|rrk
decl_stmt|;
name|ffeinfoKind
name|lkd
decl_stmt|,
name|rkd
decl_stmt|;
name|ffeinfoWhere
name|lwh
decl_stmt|,
name|rwh
decl_stmt|,
name|nwh
decl_stmt|;
name|linfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|lbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lrk
operator|=
name|ffeinfo_rank
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkd
operator|=
name|ffeinfo_kind
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lwh
operator|=
name|ffeinfo_where
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rrk
operator|=
name|ffeinfo_rank
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkd
operator|=
name|ffeinfo_kind
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|ffeexpr_type_combine
argument_list|(
operator|&
name|nbt
argument_list|,
operator|&
name|nkt
argument_list|,
name|lbt
argument_list|,
name|lkt
argument_list|,
name|rbt
argument_list|,
name|rkt
argument_list|,
name|op
operator|->
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeLOGICAL
operator|)
operator|||
operator|(
name|ffe_is_ugly_logint
argument_list|()
operator|&&
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|)
operator|)
operator|&&
operator|(
name|lrk
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rrk
operator|==
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|lwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
name|nwh
operator|=
name|FFEINFO_whereCONSTANT
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|nwh
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|nwh
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
name|ninfo
operator|=
name|ffeinfo_new
argument_list|(
name|nbt
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|nwh
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ninfo
argument_list|)
expr_stmt|;
name|ffebld_set_left
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|l
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|nbt
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_right
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|nbt
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeLOGICAL
operator|)
operator|&&
operator|(
operator|!
name|ffe_is_ugly_logint
argument_list|()
operator|||
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeLOGICAL
operator|)
operator|&&
operator|(
operator|!
name|ffe_is_ugly_logint
argument_list|()
operator|||
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_BOOL_ARGS_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_BOOL_ARG_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeLOGICAL
operator|)
operator|&&
operator|(
operator|!
name|ffe_is_ugly_logint
argument_list|()
operator|||
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_BOOL_ARG_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lrk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lkd
operator|!=
name|FFEINFO_kindANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_BOOL_ARG_KIND
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"an array"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rkd
operator|!=
name|FFEINFO_kindANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_BOOL_ARG_KIND
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"an array"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|reduced
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_reduced_concatenate_ -- Wrap up reduction of concatenate operator     reduced = ffeexpr_reduced_concatenate_(reduced,l,op,r);     Makes sure the left and right arguments for reduced have basictype of    CHARACTER and kind of SCALAR, FUNCTION, or STATEMENT FUNCTION.  Assign    basictype of CHARACTER and kind of SCALAR to reduced.  Calculate effective    size of concatenation and assign that size to reduced.  If both left and    right arguments have where of CONSTANT, assign where CONSTANT to reduced,    else assign where FLEETING.     If these requirements cannot be met, generate error message using the    info in l, op, and r arguments and assign basictype, size, kind, and where    of ANY.  */
end_comment

begin_function
specifier|static
name|ffebld
name|ffeexpr_reduced_concatenate_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
block|{
name|ffeinfo
name|linfo
decl_stmt|,
name|rinfo
decl_stmt|,
name|ninfo
decl_stmt|;
name|ffeinfoBasictype
name|lbt
decl_stmt|,
name|rbt
decl_stmt|,
name|nbt
decl_stmt|;
name|ffeinfoKindtype
name|lkt
decl_stmt|,
name|rkt
decl_stmt|,
name|nkt
decl_stmt|;
name|ffeinfoRank
name|lrk
decl_stmt|,
name|rrk
decl_stmt|;
name|ffeinfoKind
name|lkd
decl_stmt|,
name|rkd
decl_stmt|,
name|nkd
decl_stmt|;
name|ffeinfoWhere
name|lwh
decl_stmt|,
name|rwh
decl_stmt|,
name|nwh
decl_stmt|;
name|ffetargetCharacterSize
name|lszm
decl_stmt|,
name|lszk
decl_stmt|,
name|rszm
decl_stmt|,
name|rszk
decl_stmt|,
name|nszk
decl_stmt|;
name|linfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|lbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lrk
operator|=
name|ffeinfo_rank
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkd
operator|=
name|ffeinfo_kind
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lwh
operator|=
name|ffeinfo_where
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lszk
operator|=
name|ffeinfo_size
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
comment|/* Known size. */
name|lszm
operator|=
name|ffebld_size_max
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rrk
operator|=
name|ffeinfo_rank
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkd
operator|=
name|ffeinfo_kind
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rszk
operator|=
name|ffeinfo_size
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
comment|/* Known size. */
name|rszm
operator|=
name|ffebld_size_max
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lbt
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
operator|&&
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
operator|&&
operator|(
name|lkt
operator|==
name|rkt
operator|)
operator|&&
operator|(
name|lrk
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rrk
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|lszm
operator|!=
name|FFETARGET_charactersizeNONE
operator|)
operator|&&
operator|(
name|rszm
operator|!=
name|FFETARGET_charactersizeNONE
operator|)
operator|)
operator|||
operator|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
operator|==
name|FFEEXPR_contextLET
operator|)
operator|||
operator|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
operator|==
name|FFEEXPR_contextSFUNCDEF
operator|)
operator|)
condition|)
block|{
name|nbt
operator|=
name|FFEINFO_basictypeCHARACTER
expr_stmt|;
name|nkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
if|if
condition|(
operator|(
name|lszk
operator|==
name|FFETARGET_charactersizeNONE
operator|)
operator|||
operator|(
name|rszk
operator|==
name|FFETARGET_charactersizeNONE
operator|)
condition|)
name|nszk
operator|=
name|FFETARGET_charactersizeNONE
expr_stmt|;
comment|/* Ok only in rhs of LET 						   stmt. */
else|else
name|nszk
operator|=
name|lszk
operator|+
name|rszk
expr_stmt|;
switch|switch
condition|(
name|lwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
name|nwh
operator|=
name|FFEINFO_whereCONSTANT
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|nwh
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|nwh
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
name|nkt
operator|=
name|lkt
expr_stmt|;
name|ninfo
operator|=
name|ffeinfo_new
argument_list|(
name|nbt
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|nkd
argument_list|,
name|nwh
argument_list|,
name|nszk
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ninfo
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_CONCAT_ARGS_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lbt
operator|!=
name|FFEINFO_basictypeCHARACTER
condition|)
block|{
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_CONCAT_ARG_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rbt
operator|!=
name|FFEINFO_basictypeCHARACTER
condition|)
block|{
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_CONCAT_ARG_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|lrk
operator|!=
literal|0
operator|)
operator|||
operator|(
name|lszm
operator|==
name|FFETARGET_charactersizeNONE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|lkd
operator|!=
name|FFEINFO_kindANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_CONCAT_ARG_KIND
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|what
decl_stmt|;
if|if
condition|(
name|lrk
operator|!=
literal|0
condition|)
name|what
operator|=
literal|"an array"
expr_stmt|;
else|else
name|what
operator|=
literal|"of indeterminate length"
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|what
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ffebad_start
argument_list|(
name|FFEBAD_CONCAT_ARG_KIND
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|what
decl_stmt|;
if|if
condition|(
name|rrk
operator|!=
literal|0
condition|)
name|what
operator|=
literal|"an array"
expr_stmt|;
else|else
name|what
operator|=
literal|"of indeterminate length"
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|what
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|reduced
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_reduced_eqop2_ -- Wrap up reduction of EQ and NE operators     reduced = ffeexpr_reduced_eqop2_(reduced,l,op,r);     Makes sure the left and right arguments for reduced have basictype of    INTEGER, REAL, COMPLEX, or CHARACTER.  Determine common basictype and    size for reduction.	If both left    and right arguments have where of CONSTANT, assign where CONSTANT to    reduced, else assign where FLEETING.	 Create CONVERT ops for args where    needed.  Convert typeless    constants to the desired type/size explicitly.     If these requirements cannot be met, generate error message.	 */
end_comment

begin_function
specifier|static
name|ffebld
name|ffeexpr_reduced_eqop2_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
block|{
name|ffeinfo
name|linfo
decl_stmt|,
name|rinfo
decl_stmt|,
name|ninfo
decl_stmt|;
name|ffeinfoBasictype
name|lbt
decl_stmt|,
name|rbt
decl_stmt|,
name|nbt
decl_stmt|;
name|ffeinfoKindtype
name|lkt
decl_stmt|,
name|rkt
decl_stmt|,
name|nkt
decl_stmt|;
name|ffeinfoRank
name|lrk
decl_stmt|,
name|rrk
decl_stmt|;
name|ffeinfoKind
name|lkd
decl_stmt|,
name|rkd
decl_stmt|;
name|ffeinfoWhere
name|lwh
decl_stmt|,
name|rwh
decl_stmt|,
name|nwh
decl_stmt|;
name|ffetargetCharacterSize
name|lsz
decl_stmt|,
name|rsz
decl_stmt|;
name|linfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|lbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lrk
operator|=
name|ffeinfo_rank
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkd
operator|=
name|ffeinfo_kind
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lwh
operator|=
name|ffeinfo_where
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lsz
operator|=
name|ffebld_size_known
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rrk
operator|=
name|ffeinfo_rank
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkd
operator|=
name|ffeinfo_kind
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rsz
operator|=
name|ffebld_size_known
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_type_combine
argument_list|(
operator|&
name|nbt
argument_list|,
operator|&
name|nkt
argument_list|,
name|lbt
argument_list|,
name|lkt
argument_list|,
name|rbt
argument_list|,
name|rkt
argument_list|,
name|op
operator|->
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeREAL
operator|)
operator|||
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|||
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
operator|)
operator|&&
operator|(
name|lrk
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rrk
operator|==
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|lwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
name|nwh
operator|=
name|FFEINFO_whereCONSTANT
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|nwh
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|nwh
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|lsz
operator|!=
name|FFETARGET_charactersizeNONE
operator|)
operator|&&
operator|(
name|rsz
operator|!=
name|FFETARGET_charactersizeNONE
operator|)
condition|)
name|lsz
operator|=
name|rsz
operator|=
operator|(
name|lsz
operator|>
name|rsz
operator|)
condition|?
name|lsz
else|:
name|rsz
expr_stmt|;
name|ninfo
operator|=
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|nwh
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ninfo
argument_list|)
expr_stmt|;
name|ffebld_set_left
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|l
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|nbt
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|lsz
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_right
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|nbt
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|rsz
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
if|if
condition|(
operator|(
name|lbt
operator|==
name|FFEINFO_basictypeLOGICAL
operator|)
operator|&&
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeLOGICAL
operator|)
condition|)
block|{
if|if
condition|(
name|ffebad_start_msg
argument_list|(
literal|"Use .EQV./.NEQV. instead of .EQ./.NE. at %0 for LOGICAL operands at %1 and %2"
argument_list|,
name|FFEBAD_severityFATAL
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|&&
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|&&
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_EQOP_ARGS_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_EQOP_ARG_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_EQOP_ARG_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lrk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lkd
operator|!=
name|FFEINFO_kindANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_EQOP_ARG_KIND
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"an array"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rkd
operator|!=
name|FFEINFO_kindANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_EQOP_ARG_KIND
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"an array"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|reduced
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_reduced_math1_ -- Wrap up reduction of + - unary operators     reduced = ffeexpr_reduced_math1_(reduced,op,r);     Makes sure the argument for reduced has basictype of    INTEGER, REAL, or COMPLEX.  If the argument has where of CONSTANT,    assign where CONSTANT to    reduced, else assign where FLEETING.     If these requirements cannot be met, generate error message.	 */
end_comment

begin_function
specifier|static
name|ffebld
name|ffeexpr_reduced_math1_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
block|{
name|ffeinfo
name|rinfo
decl_stmt|,
name|ninfo
decl_stmt|;
name|ffeinfoBasictype
name|rbt
decl_stmt|;
name|ffeinfoKindtype
name|rkt
decl_stmt|;
name|ffeinfoRank
name|rrk
decl_stmt|;
name|ffeinfoKind
name|rkd
decl_stmt|;
name|ffeinfoWhere
name|rwh
decl_stmt|,
name|nwh
decl_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rrk
operator|=
name|ffeinfo_rank
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkd
operator|=
name|ffeinfo_kind
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeREAL
operator|)
operator|||
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|)
operator|&&
operator|(
name|rrk
operator|==
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
name|nwh
operator|=
name|FFEINFO_whereCONSTANT
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|nwh
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
name|ninfo
operator|=
name|ffeinfo_new
argument_list|(
name|rbt
argument_list|,
name|rkt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|nwh
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ninfo
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_MATH_ARG_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rkd
operator|!=
name|FFEINFO_kindANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_MATH_ARG_KIND
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"an array"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|reduced
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_reduced_math2_ -- Wrap up reduction of + - * / operators     reduced = ffeexpr_reduced_math2_(reduced,l,op,r);     Makes sure the left and right arguments for reduced have basictype of    INTEGER, REAL, or COMPLEX.  Determine common basictype and    size for reduction (flag expression for combined hollerith/typeless    situations for later determination of effective basictype).	If both left    and right arguments have where of CONSTANT, assign where CONSTANT to    reduced, else assign where FLEETING.	 Create CONVERT ops for args where    needed.  Convert typeless    constants to the desired type/size explicitly.     If these requirements cannot be met, generate error message.	 */
end_comment

begin_function
specifier|static
name|ffebld
name|ffeexpr_reduced_math2_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
block|{
name|ffeinfo
name|linfo
decl_stmt|,
name|rinfo
decl_stmt|,
name|ninfo
decl_stmt|;
name|ffeinfoBasictype
name|lbt
decl_stmt|,
name|rbt
decl_stmt|,
name|nbt
decl_stmt|;
name|ffeinfoKindtype
name|lkt
decl_stmt|,
name|rkt
decl_stmt|,
name|nkt
decl_stmt|;
name|ffeinfoRank
name|lrk
decl_stmt|,
name|rrk
decl_stmt|;
name|ffeinfoKind
name|lkd
decl_stmt|,
name|rkd
decl_stmt|;
name|ffeinfoWhere
name|lwh
decl_stmt|,
name|rwh
decl_stmt|,
name|nwh
decl_stmt|;
name|linfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|lbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lrk
operator|=
name|ffeinfo_rank
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkd
operator|=
name|ffeinfo_kind
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lwh
operator|=
name|ffeinfo_where
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rrk
operator|=
name|ffeinfo_rank
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkd
operator|=
name|ffeinfo_kind
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|ffeexpr_type_combine
argument_list|(
operator|&
name|nbt
argument_list|,
operator|&
name|nkt
argument_list|,
name|lbt
argument_list|,
name|lkt
argument_list|,
name|rbt
argument_list|,
name|rkt
argument_list|,
name|op
operator|->
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeREAL
operator|)
operator|||
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|)
operator|&&
operator|(
name|lrk
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rrk
operator|==
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|lwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
name|nwh
operator|=
name|FFEINFO_whereCONSTANT
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|nwh
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|nwh
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
name|ninfo
operator|=
name|ffeinfo_new
argument_list|(
name|nbt
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|nwh
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ninfo
argument_list|)
expr_stmt|;
name|ffebld_set_left
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|l
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|nbt
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_right
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|nbt
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|&&
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_MATH_ARGS_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_MATH_ARG_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_MATH_ARG_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lrk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lkd
operator|!=
name|FFEINFO_kindANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_MATH_ARG_KIND
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"an array"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rkd
operator|!=
name|FFEINFO_kindANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_MATH_ARG_KIND
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"an array"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|reduced
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_reduced_power_ -- Wrap up reduction of ** operator     reduced = ffeexpr_reduced_power_(reduced,l,op,r);     Makes sure the left and right arguments for reduced have basictype of    INTEGER, REAL, or COMPLEX.  Determine common basictype and    size for reduction (flag expression for combined hollerith/typeless    situations for later determination of effective basictype).	If both left    and right arguments have where of CONSTANT, assign where CONSTANT to    reduced, else assign where FLEETING.	 Create CONVERT ops for args where    needed.  Note that real**int or complex**int    comes out as int = real**int etc with no conversions.     If these requirements cannot be met, generate error message using the    info in l, op, and r arguments and assign basictype, size, kind, and where    of ANY.  */
end_comment

begin_function
specifier|static
name|ffebld
name|ffeexpr_reduced_power_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
block|{
name|ffeinfo
name|linfo
decl_stmt|,
name|rinfo
decl_stmt|,
name|ninfo
decl_stmt|;
name|ffeinfoBasictype
name|lbt
decl_stmt|,
name|rbt
decl_stmt|,
name|nbt
decl_stmt|;
name|ffeinfoKindtype
name|lkt
decl_stmt|,
name|rkt
decl_stmt|,
name|nkt
decl_stmt|;
name|ffeinfoRank
name|lrk
decl_stmt|,
name|rrk
decl_stmt|;
name|ffeinfoKind
name|lkd
decl_stmt|,
name|rkd
decl_stmt|;
name|ffeinfoWhere
name|lwh
decl_stmt|,
name|rwh
decl_stmt|,
name|nwh
decl_stmt|;
name|linfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|lbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lrk
operator|=
name|ffeinfo_rank
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkd
operator|=
name|ffeinfo_kind
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lwh
operator|=
name|ffeinfo_where
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rrk
operator|=
name|ffeinfo_rank
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkd
operator|=
name|ffeinfo_kind
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
operator|(
name|lbt
operator|==
name|FFEINFO_basictypeREAL
operator|)
operator|||
operator|(
name|lbt
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|)
condition|)
block|{
name|nbt
operator|=
name|lbt
expr_stmt|;
name|nkt
operator|=
name|ffeinfo_kindtype_max
argument_list|(
name|nbt
argument_list|,
name|lkt
argument_list|,
name|FFEINFO_kindtypeREALDEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkt
operator|!=
name|FFEINFO_kindtypeREALDEFAULT
condition|)
block|{
name|nkt
operator|=
name|ffeinfo_kindtype_max
argument_list|(
name|nbt
argument_list|,
name|lkt
argument_list|,
name|FFEINFO_kindtypeREALDOUBLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkt
operator|!=
name|FFEINFO_kindtypeREALDOUBLE
condition|)
name|nkt
operator|=
name|FFEINFO_kindtypeREALDOUBLE
expr_stmt|;
comment|/* Highest kt we can power! */
block|}
if|if
condition|(
name|rkt
operator|==
name|FFEINFO_kindtypeINTEGER4
condition|)
block|{
name|ffebad_start_msg
argument_list|(
literal|"Unsupported operand for ** at %1 -- converting to default INTEGER"
argument_list|,
name|FFEBAD_severityWARNING
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rkt
operator|!=
name|FFEINFO_kindtypeINTEGERDEFAULT
condition|)
block|{
name|ffebld_set_right
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|rkt
operator|=
name|FFEINFO_kindtypeINTEGERDEFAULT
expr_stmt|;
block|}
block|}
else|else
block|{
name|ffeexpr_type_combine
argument_list|(
operator|&
name|nbt
argument_list|,
operator|&
name|nkt
argument_list|,
name|lbt
argument_list|,
name|lkt
argument_list|,
name|rbt
argument_list|,
name|rkt
argument_list|,
name|op
operator|->
name|token
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* INTEGER4**INTEGER4 works now. */
block|if ((nbt == FFEINFO_basictypeINTEGER)&& (nkt != FFEINFO_kindtypeINTEGERDEFAULT)) 	nkt = FFEINFO_kindtypeINTEGERDEFAULT;
comment|/* Highest kt we can power! */
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeREAL
operator|)
operator|||
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|)
operator|&&
operator|(
name|nkt
operator|!=
name|FFEINFO_kindtypeREALDEFAULT
operator|)
condition|)
block|{
name|nkt
operator|=
name|ffeinfo_kindtype_max
argument_list|(
name|nbt
argument_list|,
name|nkt
argument_list|,
name|FFEINFO_kindtypeREALDOUBLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkt
operator|!=
name|FFEINFO_kindtypeREALDOUBLE
condition|)
name|nkt
operator|=
name|FFEINFO_kindtypeREALDOUBLE
expr_stmt|;
comment|/* Highest kt we can power! */
block|}
comment|/* else Gonna turn into an error below. */
block|}
if|if
condition|(
operator|(
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeREAL
operator|)
operator|||
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeCOMPLEX
operator|)
operator|)
operator|&&
operator|(
name|lrk
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rrk
operator|==
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|lwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
name|nwh
operator|=
name|FFEINFO_whereCONSTANT
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|nwh
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|nwh
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
name|ninfo
operator|=
name|ffeinfo_new
argument_list|(
name|nbt
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|nwh
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ninfo
argument_list|)
expr_stmt|;
name|ffebld_set_left
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|l
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|nbt
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbt
operator|!=
name|FFEINFO_basictypeINTEGER
condition|)
name|ffebld_set_right
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|nbt
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|&&
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_MATH_ARGS_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_MATH_ARG_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeCOMPLEX
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_MATH_ARG_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lrk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lkd
operator|!=
name|FFEINFO_kindANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_MATH_ARG_KIND
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"an array"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rkd
operator|!=
name|FFEINFO_kindANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_MATH_ARG_KIND
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"an array"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|reduced
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_reduced_relop2_ -- Wrap up reduction of LT, LE, GE, and GT operators     reduced = ffeexpr_reduced_relop2_(reduced,l,op,r);     Makes sure the left and right arguments for reduced have basictype of    INTEGER, REAL, or CHARACTER.	 Determine common basictype and    size for reduction.	If both left    and right arguments have where of CONSTANT, assign where CONSTANT to    reduced, else assign where FLEETING.	 Create CONVERT ops for args where    needed.  Convert typeless    constants to the desired type/size explicitly.     If these requirements cannot be met, generate error message.	 */
end_comment

begin_function
specifier|static
name|ffebld
name|ffeexpr_reduced_relop2_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
block|{
name|ffeinfo
name|linfo
decl_stmt|,
name|rinfo
decl_stmt|,
name|ninfo
decl_stmt|;
name|ffeinfoBasictype
name|lbt
decl_stmt|,
name|rbt
decl_stmt|,
name|nbt
decl_stmt|;
name|ffeinfoKindtype
name|lkt
decl_stmt|,
name|rkt
decl_stmt|,
name|nkt
decl_stmt|;
name|ffeinfoRank
name|lrk
decl_stmt|,
name|rrk
decl_stmt|;
name|ffeinfoKind
name|lkd
decl_stmt|,
name|rkd
decl_stmt|;
name|ffeinfoWhere
name|lwh
decl_stmt|,
name|rwh
decl_stmt|,
name|nwh
decl_stmt|;
name|ffetargetCharacterSize
name|lsz
decl_stmt|,
name|rsz
decl_stmt|;
name|linfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|lbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lrk
operator|=
name|ffeinfo_rank
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkd
operator|=
name|ffeinfo_kind
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lwh
operator|=
name|ffeinfo_where
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lsz
operator|=
name|ffebld_size_known
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rrk
operator|=
name|ffeinfo_rank
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkd
operator|=
name|ffeinfo_kind
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rsz
operator|=
name|ffebld_size_known
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_type_combine
argument_list|(
operator|&
name|nbt
argument_list|,
operator|&
name|nkt
argument_list|,
name|lbt
argument_list|,
name|lkt
argument_list|,
name|rbt
argument_list|,
name|rkt
argument_list|,
name|op
operator|->
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeREAL
operator|)
operator|||
operator|(
name|nbt
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
operator|)
operator|&&
operator|(
name|lrk
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rrk
operator|==
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|lwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
name|nwh
operator|=
name|FFEINFO_whereCONSTANT
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|nwh
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|nwh
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|nwh
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|lsz
operator|!=
name|FFETARGET_charactersizeNONE
operator|)
operator|&&
operator|(
name|rsz
operator|!=
name|FFETARGET_charactersizeNONE
operator|)
condition|)
name|lsz
operator|=
name|rsz
operator|=
operator|(
name|lsz
operator|>
name|rsz
operator|)
condition|?
name|lsz
else|:
name|rsz
expr_stmt|;
name|ninfo
operator|=
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|nwh
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ninfo
argument_list|)
expr_stmt|;
name|ffebld_set_left
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|l
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|nbt
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|lsz
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_right
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|nbt
argument_list|,
name|nkt
argument_list|,
literal|0
argument_list|,
name|rsz
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|&&
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_RELOP_ARGS_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|lbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_RELOP_ARG_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeREAL
operator|)
operator|&&
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rbt
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_RELOP_ARG_TYPE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lrk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lkd
operator|!=
name|FFEINFO_kindANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_RELOP_ARG_KIND
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|l
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"an array"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rkd
operator|!=
name|FFEINFO_kindANY
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_RELOP_ARG_KIND
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|r
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"an array"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|reduced
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|reduced
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_reduced_ugly1_ -- Deal with TYPELESS, HOLLERITH, and LOGICAL     reduced = ffeexpr_reduced_ugly1_(reduced,op,r);     Sigh.  */
end_comment

begin_function
specifier|static
name|ffebld
name|ffeexpr_reduced_ugly1_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
block|{
name|ffeinfo
name|rinfo
decl_stmt|;
name|ffeinfoBasictype
name|rbt
decl_stmt|;
name|ffeinfoKindtype
name|rkt
decl_stmt|;
name|ffeinfoRank
name|rrk
decl_stmt|;
name|ffeinfoKind
name|rkd
decl_stmt|;
name|ffeinfoWhere
name|rwh
decl_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rrk
operator|=
name|ffeinfo_rank
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkd
operator|=
name|ffeinfo_kind
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeTYPELESS
operator|)
operator|||
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeHOLLERITH
operator|)
condition|)
block|{
name|ffebld_set_left
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|FFEINFO_basictypeINTEGER
expr_stmt|;
name|rkt
operator|=
name|FFEINFO_kindtypeINTEGERDEFAULT
expr_stmt|;
name|rrk
operator|=
literal|0
expr_stmt|;
name|rkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rbt
operator|==
name|FFEINFO_basictypeLOGICAL
condition|)
block|{
name|ffebld_set_left
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|reduced
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_reduced_ugly1log_ -- Deal with TYPELESS and HOLLERITH     reduced = ffeexpr_reduced_ugly1log_(reduced,op,r);     Sigh.  */
end_comment

begin_function
specifier|static
name|ffebld
name|ffeexpr_reduced_ugly1log_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
block|{
name|ffeinfo
name|rinfo
decl_stmt|;
name|ffeinfoBasictype
name|rbt
decl_stmt|;
name|ffeinfoKindtype
name|rkt
decl_stmt|;
name|ffeinfoRank
name|rrk
decl_stmt|;
name|ffeinfoKind
name|rkd
decl_stmt|;
name|ffeinfoWhere
name|rwh
decl_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rrk
operator|=
name|ffeinfo_rank
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkd
operator|=
name|ffeinfo_kind
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeTYPELESS
operator|)
operator|||
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeHOLLERITH
operator|)
condition|)
block|{
name|ffebld_set_left
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|FFEINFO_basictypeLOGICAL
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|FFEINFO_basictypeLOGICAL
expr_stmt|;
name|rkt
operator|=
name|FFEINFO_kindtypeLOGICALDEFAULT
expr_stmt|;
name|rrk
operator|=
literal|0
expr_stmt|;
name|rkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
block|}
return|return
name|reduced
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_reduced_ugly2_ -- Deal with TYPELESS, HOLLERITH, and LOGICAL     reduced = ffeexpr_reduced_ugly2_(reduced,l,op,r);     Sigh.  */
end_comment

begin_function
specifier|static
name|ffebld
name|ffeexpr_reduced_ugly2_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
block|{
name|ffeinfo
name|linfo
decl_stmt|,
name|rinfo
decl_stmt|;
name|ffeinfoBasictype
name|lbt
decl_stmt|,
name|rbt
decl_stmt|;
name|ffeinfoKindtype
name|lkt
decl_stmt|,
name|rkt
decl_stmt|;
name|ffeinfoRank
name|lrk
decl_stmt|,
name|rrk
decl_stmt|;
name|ffeinfoKind
name|lkd
decl_stmt|,
name|rkd
decl_stmt|;
name|ffeinfoWhere
name|lwh
decl_stmt|,
name|rwh
decl_stmt|;
name|linfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|lbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lrk
operator|=
name|ffeinfo_rank
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkd
operator|=
name|ffeinfo_kind
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lwh
operator|=
name|ffeinfo_where
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rrk
operator|=
name|ffeinfo_rank
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkd
operator|=
name|ffeinfo_kind
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lbt
operator|==
name|FFEINFO_basictypeTYPELESS
operator|)
operator|||
operator|(
name|lbt
operator|==
name|FFEINFO_basictypeHOLLERITH
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeTYPELESS
operator|)
operator|||
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeHOLLERITH
operator|)
condition|)
block|{
name|ffebld_set_left
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|l
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_right
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|linfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|lbt
operator|=
name|rbt
operator|=
name|FFEINFO_basictypeINTEGER
expr_stmt|;
name|lkt
operator|=
name|rkt
operator|=
name|FFEINFO_kindtypeINTEGERDEFAULT
expr_stmt|;
name|lrk
operator|=
name|rrk
operator|=
literal|0
expr_stmt|;
name|lkd
operator|=
name|rkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|lwh
operator|=
name|ffeinfo_where
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffebld_set_left
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert_expr
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|l
operator|->
name|token
argument_list|,
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|linfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|lbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lrk
operator|=
name|ffeinfo_rank
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkd
operator|=
name|ffeinfo_kind
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lwh
operator|=
name|ffeinfo_where
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeTYPELESS
operator|)
operator|||
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeHOLLERITH
operator|)
condition|)
block|{
name|ffebld_set_right
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert_expr
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|l
operator|->
name|token
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rrk
operator|=
name|ffeinfo_rank
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkd
operator|=
name|ffeinfo_kind
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
block|}
comment|/* else Leave it alone. */
block|}
if|if
condition|(
name|lbt
operator|==
name|FFEINFO_basictypeLOGICAL
condition|)
block|{
name|ffebld_set_left
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|l
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rbt
operator|==
name|FFEINFO_basictypeLOGICAL
condition|)
block|{
name|ffebld_set_right
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|reduced
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_reduced_ugly2log_ -- Deal with TYPELESS and HOLLERITH     reduced = ffeexpr_reduced_ugly2log_(reduced,l,op,r);     Sigh.  */
end_comment

begin_function
specifier|static
name|ffebld
name|ffeexpr_reduced_ugly2log_
parameter_list|(
name|ffebld
name|reduced
parameter_list|,
name|ffeexprExpr_
name|l
parameter_list|,
name|ffeexprExpr_
name|op
parameter_list|,
name|ffeexprExpr_
name|r
parameter_list|)
block|{
name|ffeinfo
name|linfo
decl_stmt|,
name|rinfo
decl_stmt|;
name|ffeinfoBasictype
name|lbt
decl_stmt|,
name|rbt
decl_stmt|;
name|ffeinfoKindtype
name|lkt
decl_stmt|,
name|rkt
decl_stmt|;
name|ffeinfoRank
name|lrk
decl_stmt|,
name|rrk
decl_stmt|;
name|ffeinfoKind
name|lkd
decl_stmt|,
name|rkd
decl_stmt|;
name|ffeinfoWhere
name|lwh
decl_stmt|,
name|rwh
decl_stmt|;
name|linfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|lbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lrk
operator|=
name|ffeinfo_rank
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkd
operator|=
name|ffeinfo_kind
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lwh
operator|=
name|ffeinfo_where
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rrk
operator|=
name|ffeinfo_rank
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkd
operator|=
name|ffeinfo_kind
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lbt
operator|==
name|FFEINFO_basictypeTYPELESS
operator|)
operator|||
operator|(
name|lbt
operator|==
name|FFEINFO_basictypeHOLLERITH
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeTYPELESS
operator|)
operator|||
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeHOLLERITH
operator|)
condition|)
block|{
name|ffebld_set_left
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|l
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_right
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|op
operator|->
name|token
argument_list|,
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|linfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|lbt
operator|=
name|rbt
operator|=
name|FFEINFO_basictypeLOGICAL
expr_stmt|;
name|lkt
operator|=
name|rkt
operator|=
name|FFEINFO_kindtypeLOGICALDEFAULT
expr_stmt|;
name|lrk
operator|=
name|rrk
operator|=
literal|0
expr_stmt|;
name|lkd
operator|=
name|rkd
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|lwh
operator|=
name|ffeinfo_where
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffebld_set_left
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert_expr
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|l
operator|->
name|token
argument_list|,
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|linfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|lbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lrk
operator|=
name|ffeinfo_rank
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lkd
operator|=
name|ffeinfo_kind
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
name|lwh
operator|=
name|ffeinfo_where
argument_list|(
name|linfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeTYPELESS
operator|)
operator|||
operator|(
name|rbt
operator|==
name|FFEINFO_basictypeHOLLERITH
operator|)
condition|)
block|{
name|ffebld_set_right
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_convert_expr
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|r
operator|->
name|token
argument_list|,
name|ffebld_left
argument_list|(
name|reduced
argument_list|)
argument_list|,
name|l
operator|->
name|token
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|ffebld_info
argument_list|(
name|ffebld_right
argument_list|(
name|reduced
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|ffeinfo_basictype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rrk
operator|=
name|ffeinfo_rank
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rkd
operator|=
name|ffeinfo_kind
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
block|}
comment|/* else Leave it alone. */
block|}
return|return
name|reduced
return|;
block|}
end_function

begin_comment
comment|/* Fumble through tokens until a nonmatching CLOSE_PAREN, EOS, or SEMICOLON    is found.     The idea is to process the tokens as they would be done by normal    expression processing, with the key things being telling the lexer    when hollerith/character constants are about to happen, until the    true closing token is found.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_find_close_paren_
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|ffelexHandler
name|after
parameter_list|)
block|{
name|ffeexpr_find_
operator|.
name|after
operator|=
name|after
expr_stmt|;
name|ffeexpr_find_
operator|.
name|level
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_finished_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
if|if
condition|(
operator|--
name|ffeexpr_find_
operator|.
name|level
operator|==
literal|0
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_find_
operator|.
name|after
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
return|;
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLON
case|:
case|case
name|FFELEX_typeEQUALS
case|:
case|case
name|FFELEX_typePOINTS
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
return|;
default|default:
if|if
condition|(
operator|--
name|ffeexpr_find_
operator|.
name|level
operator|==
literal|0
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_find_
operator|.
name|after
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_rhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeQUOTE
case|:
if|if
condition|(
name|ffe_is_vxt
argument_list|()
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_quote_
return|;
name|ffelex_set_expecting_hollerith
argument_list|(
operator|-
literal|1
argument_list|,
literal|'\"'
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_apostrophe_
return|;
case|case
name|FFELEX_typeAPOSTROPHE
case|:
name|ffelex_set_expecting_hollerith
argument_list|(
operator|-
literal|1
argument_list|,
literal|'\''
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_apostrophe_
return|;
case|case
name|FFELEX_typePERCENT
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_percent_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
operator|++
name|ffeexpr_find_
operator|.
name|level
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
return|;
case|case
name|FFELEX_typePLUS
case|:
case|case
name|FFELEX_typeMINUS
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
return|;
case|case
name|FFELEX_typePERIOD
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_period_
return|;
case|case
name|FFELEX_typeNUMBER
case|:
name|ffeexpr_hollerith_count_
operator|=
name|atol
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffeexpr_hollerith_count_
operator|>
literal|0
condition|)
name|ffelex_set_expecting_hollerith
argument_list|(
name|ffeexpr_hollerith_count_
argument_list|,
literal|'\0'
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_number_
return|;
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_name_rhs_
return|;
case|case
name|FFELEX_typeASTERISK
case|:
case|case
name|FFELEX_typeSLASH
case|:
case|case
name|FFELEX_typePOWER
case|:
case|case
name|FFELEX_typeCONCAT
case|:
case|case
name|FFELEX_typeREL_EQ
case|:
case|case
name|FFELEX_typeREL_NE
case|:
case|case
name|FFELEX_typeREL_LE
case|:
case|case
name|FFELEX_typeREL_GE
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_finished_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
name|ffeexpr_current_dotdot_
operator|=
name|ffestr_other
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_current_dotdot_
condition|)
block|{
case|case
name|FFESTR_otherNone
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFESTR_otherTRUE
case|:
case|case
name|FFESTR_otherFALSE
case|:
case|case
name|FFESTR_otherNOT
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_end_period_
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_swallow_period_
return|;
block|}
break|break;
comment|/* Nothing really reaches here. */
case|case
name|FFELEX_typeNUMBER
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_real_
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_end_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffeexpr_current_dotdot_
condition|)
block|{
case|case
name|FFESTR_otherNOT
case|:
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePERIOD
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
return|;
case|case
name|FFESTR_otherTRUE
case|:
case|case
name|FFESTR_otherFALSE
case|:
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePERIOD
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
return|;
default|default:
name|assert
argument_list|(
literal|"Bad [nil] unary dotdot in ffeexpr_current_dotdot_"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_swallow_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePERIOD
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_real_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|char
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNAME
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNAMES
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|(
name|ffesrc_char_match_init
argument_list|(
operator|(
name|d
operator|=
operator|*
operator|(
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
operator|)
operator|)
argument_list|,
literal|'D'
argument_list|,
literal|'d'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'E'
argument_list|,
literal|'e'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'Q'
argument_list|,
literal|'q'
argument_list|)
operator|)
operator|)
operator|&&
name|ffeexpr_isdigits_
argument_list|(
operator|++
name|p
argument_list|)
operator|)
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_real_exponent_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_real_exponent_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePLUS
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeMINUS
operator|)
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_real_exp_sign_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_real_exp_sign_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNUMBER
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_number_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|char
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ffeexpr_hollerith_count_
operator|>
literal|0
condition|)
name|ffelex_set_expecting_hollerith
argument_list|(
literal|0
argument_list|,
literal|'\0'
argument_list|,
name|ffewhere_line_unknown
argument_list|()
argument_list|,
name|ffewhere_column_unknown
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
operator|(
name|ffesrc_char_match_init
argument_list|(
operator|(
name|d
operator|=
operator|*
operator|(
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
operator|)
operator|)
argument_list|,
literal|'D'
argument_list|,
literal|'d'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'E'
argument_list|,
literal|'e'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'Q'
argument_list|,
literal|'q'
argument_list|)
operator|)
operator|&&
name|ffeexpr_isdigits_
argument_list|(
operator|++
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|ffeexpr_find_
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_number_exponent_
return|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
return|;
block|}
break|break;
case|case
name|FFELEX_typePERIOD
case|:
name|ffeexpr_find_
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_number_period_
return|;
case|case
name|FFELEX_typeHOLLERITH
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
return|;
default|default:
break|break;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expects ffeexpr_find_.t.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_number_exponent_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|nexthandler
decl_stmt|;
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePLUS
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeMINUS
operator|)
condition|)
block|{
name|nexthandler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|ffeexpr_find_
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_find_
operator|.
name|t
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|nexthandler
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_find_
operator|.
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_number_exp_sign_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_number_exp_sign_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNUMBER
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
return|;
block|}
end_function

begin_comment
comment|/* Expects ffeexpr_find_.t.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_number_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|nexthandler
decl_stmt|;
name|char
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
operator|(
name|ffesrc_char_match_init
argument_list|(
operator|(
name|d
operator|=
operator|*
operator|(
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
operator|)
operator|)
argument_list|,
literal|'D'
argument_list|,
literal|'d'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'E'
argument_list|,
literal|'e'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'Q'
argument_list|,
literal|'q'
argument_list|)
operator|)
operator|&&
name|ffeexpr_isdigits_
argument_list|(
operator|++
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_number_per_exp_
return|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_find_
operator|.
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
return|;
block|}
name|nexthandler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|ffeexpr_find_
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_find_
operator|.
name|t
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|nexthandler
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNUMBER
case|:
name|ffelex_token_kill
argument_list|(
name|ffeexpr_find_
operator|.
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_number_real_
return|;
default|default:
break|break;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_find_
operator|.
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expects ffeexpr_find_.t.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_number_per_exp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePLUS
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeMINUS
operator|)
condition|)
block|{
name|ffelexHandler
name|nexthandler
decl_stmt|;
name|nexthandler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|ffeexpr_find_
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_find_
operator|.
name|t
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|nexthandler
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_find_
operator|.
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_num_per_exp_sign_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_number_real_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|char
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNAME
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNAMES
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|(
name|ffesrc_char_match_init
argument_list|(
operator|(
name|d
operator|=
operator|*
operator|(
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
operator|)
operator|)
argument_list|,
literal|'D'
argument_list|,
literal|'d'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'E'
argument_list|,
literal|'e'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'Q'
argument_list|,
literal|'q'
argument_list|)
operator|)
operator|)
operator|&&
name|ffeexpr_isdigits_
argument_list|(
operator|++
name|p
argument_list|)
operator|)
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_number_real_exp_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_num_per_exp_sign_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNUMBER
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_number_real_exp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePLUS
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeMINUS
operator|)
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_num_real_exp_sn_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_num_real_exp_sn_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNUMBER
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_binary_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typePLUS
case|:
case|case
name|FFELEX_typeMINUS
case|:
case|case
name|FFELEX_typeASTERISK
case|:
case|case
name|FFELEX_typeSLASH
case|:
case|case
name|FFELEX_typePOWER
case|:
case|case
name|FFELEX_typeCONCAT
case|:
case|case
name|FFELEX_typeOPEN_ANGLE
case|:
case|case
name|FFELEX_typeCLOSE_ANGLE
case|:
case|case
name|FFELEX_typeREL_EQ
case|:
case|case
name|FFELEX_typeREL_NE
case|:
case|case
name|FFELEX_typeREL_GE
case|:
case|case
name|FFELEX_typeREL_LE
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
return|;
case|case
name|FFELEX_typePERIOD
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_period_
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_finished_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_binary_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
name|ffeexpr_current_dotdot_
operator|=
name|ffestr_other
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_current_dotdot_
condition|)
block|{
case|case
name|FFESTR_otherTRUE
case|:
case|case
name|FFESTR_otherFALSE
case|:
case|case
name|FFESTR_otherNOT
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_sw_per_
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_end_per_
return|;
block|}
break|break;
comment|/* Nothing really reaches here. */
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_binary_end_per_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePERIOD
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_binary_sw_per_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePERIOD
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_quote_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNUMBER
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_apostrophe_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCHARACTER
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_apos_char_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_apos_char_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAMES
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|==
literal|1
operator|)
operator|&&
operator|(
name|ffesrc_char_match_init
argument_list|(
operator|(
name|c
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
index|[
literal|0
index|]
operator|)
argument_list|,
literal|'B'
argument_list|,
literal|'b'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|c
argument_list|,
literal|'O'
argument_list|,
literal|'o'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|c
argument_list|,
literal|'X'
argument_list|,
literal|'x'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|c
argument_list|,
literal|'Z'
argument_list|,
literal|'z'
argument_list|)
operator|)
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
return|;
block|}
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAMES
operator|)
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_substrp_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_name_rhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeQUOTE
case|:
case|case
name|FFELEX_typeAPOSTROPHE
case|:
name|ffelex_set_hexnum
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_name_apos_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
operator|++
name|ffeexpr_find_
operator|.
name|level
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_name_apos_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_name_apos_name_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_name_apos_name_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeAPOSTROPHE
case|:
case|case
name|FFELEX_typeQUOTE
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_finished_
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_finished_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_percent_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
name|ffeexpr_stack_
operator|->
name|percent
operator|=
name|ffeexpr_percent_
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffeexpr_find_
operator|.
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_percent_name_
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expects ffeexpr_find_.t.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_percent_name_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|nexthandler
decl_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeOPEN_PAREN
condition|)
block|{
name|nexthandler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
argument_list|(
name|ffeexpr_find_
operator|.
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_find_
operator|.
name|t
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|nexthandler
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_find_
operator|.
name|t
argument_list|)
expr_stmt|;
operator|++
name|ffeexpr_find_
operator|.
name|level
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_nil_substrp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeOPEN_PAREN
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_binary_
argument_list|(
name|t
argument_list|)
return|;
operator|++
name|ffeexpr_find_
operator|.
name|level
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_nil_rhs_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_finished_ -- Reduce expression stack to one expr, finish     ffelexToken t;    return ffeexpr_finished_(t);     Reduces expression stack to one (or zero) elements by repeatedly reducing    the top operator on the stack (or, if the top element on the stack is    itself an operator, issuing an error message and discarding it).  Calls    finishing routine with the expression, returning the ffelexHandler it    returns to the caller.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_finished_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|operand
decl_stmt|;
comment|/* This is B in -B or A+B. */
name|ffebld
name|expr
decl_stmt|;
name|ffeexprCallback
name|callback
decl_stmt|;
name|ffeexprStack_
name|s
decl_stmt|;
name|ffebldConstant
name|constnode
decl_stmt|;
comment|/* For detecting magical number. */
name|ffelexToken
name|ft
decl_stmt|;
comment|/* Temporary copy of first token in 				   expression. */
name|ffelexHandler
name|next
decl_stmt|;
name|ffeinfo
name|info
decl_stmt|;
name|bool
name|error
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|operand
operator|=
name|ffeexpr_stack_
operator|->
name|exprstack
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|operand
operator|->
name|previous
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|operand
operator|->
name|type
operator|!=
name|FFEEXPR_exprtypeOPERAND_
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|type
operator|==
name|FFEEXPR_exprtypeOPERAND_
condition|)
name|ffeexpr_reduce_
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_MISSING_OPERAND_FOR_OPERATOR
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffeexpr_stack_
operator|->
name|exprstack
operator|=
name|operand
operator|->
name|previous
expr_stmt|;
comment|/* Pop the useless 								   operator. */
name|ffeexpr_expr_kill_
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
operator|(
name|operand
operator|==
name|NULL
operator|)
operator|||
operator|(
name|operand
operator|->
name|previous
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|ffebld_pool_pop
argument_list|()
expr_stmt|;
if|if
condition|(
name|operand
operator|==
name|NULL
condition|)
name|expr
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|operand
operator|->
name|u
operator|.
name|operand
expr_stmt|;
name|info
operator|=
name|ffebld_info
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|&&
operator|(
name|ffebld_conter_orig
argument_list|(
name|expr
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
name|ffebld_constant_is_magical
argument_list|(
name|constnode
operator|=
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
name|ffetarget_integer_bad_magical
argument_list|(
name|operand
operator|->
name|token
argument_list|)
expr_stmt|;
block|}
name|ffeexpr_expr_kill_
argument_list|(
name|operand
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|exprstack
operator|=
name|NULL
expr_stmt|;
block|}
name|ft
operator|=
name|ffeexpr_stack_
operator|->
name|first_token
expr_stmt|;
name|again
label|:
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextLET
case|:
case|case
name|FFEEXPR_contextSFUNCDEF
case|:
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextPAREN_
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FFEEXPR_contextPARENFILENUM_
case|:
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeCOMMA
condition|)
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextPAREN_
expr_stmt|;
else|else
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextFILENUM
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEEXPR_contextPARENFILEUNIT_
case|:
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeCOMMA
condition|)
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextPAREN_
expr_stmt|;
else|else
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextFILEUNIT
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEEXPR_contextACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
case|:
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
if|if
condition|(
operator|!
name|ffe_is_ugly_args
argument_list|()
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_ACTUALARG
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ft
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|error
operator|=
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextACTUALARG_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
if|#
directive|if
literal|0
comment|/* Should never get here. */
block|expr = ffeexpr_convert (expr, ft, ft, 				  FFEINFO_basictypeINTEGER, 				  FFEINFO_kindtypeINTEGERDEFAULT, 				  0, 				  FFETARGET_charactersizeNONE, 				  FFEEXPR_contextLET);
else|#
directive|else
name|assert
argument_list|(
literal|"why hollerith/typeless in actualarg_?"
operator|==
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEBLD_opANY
else|:
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opSYMTER
case|:
case|case
name|FFEBLD_opPERCENT_LOC
case|:
case|case
name|FFEBLD_opPERCENT_VAL
case|:
case|case
name|FFEBLD_opPERCENT_REF
case|:
case|case
name|FFEBLD_opPERCENT_DESCR
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|error
operator|=
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
block|}
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffeinfoWhere
name|where
decl_stmt|;
name|ffeinfoKind
name|kind
decl_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opSYMTER
operator|)
operator|&&
operator|(
operator|(
name|s
operator|=
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
operator|)
operator|,
operator|(
name|where
operator|=
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|)
operator|,
operator|(
name|where
operator|==
name|FFEINFO_whereINTRINSIC
operator|)
operator|||
operator|(
name|where
operator|==
name|FFEINFO_whereGLOBAL
operator|)
operator|||
operator|(
operator|(
name|where
operator|==
name|FFEINFO_whereDUMMY
operator|)
operator|&&
operator|(
operator|(
name|kind
operator|=
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|)
operator|,
operator|(
name|kind
operator|==
name|FFEINFO_kindFUNCTION
operator|)
operator|||
operator|(
name|kind
operator|==
name|FFEINFO_kindSUBROUTINE
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|!
name|ffesymbol_explicitwhere
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|where
operator|==
name|FFEINFO_whereINTRINSIC
condition|?
name|FFEBAD_NEED_INTRINSIC
else|:
name|FFEBAD_NEED_EXTERNAL
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ft
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_set_explicitwhere
argument_list|(
name|s
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|FFEEXPR_contextINDEX_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEX_
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeNONE
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeREAL
case|:
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeINTEGER
case|:
comment|/* Specifically, allow INTEGER(KIND=2), aka INTEGER*8, through 	     unmolested.  Leave it to downstream to handle kinds.  */
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
comment|/* expr==NULL ok for substring; element case 				   caught by callback. */
case|case
name|FFEEXPR_contextRETURN
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeNONE
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeREAL
case|:
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEEXPR_contextDO
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|error
operator|=
operator|!
name|ffe_is_ugly_logint
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
break|break;
comment|/* Don't convert lhs variable. */
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
if|if
condition|(
operator|!
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
comment|/* Don't convert lhs variable. */
block|}
break|break;
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeREAL
case|:
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffeexpr_stack_
operator|->
name|is_rhs
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextDOWHILE
case|:
case|case
name|FFEEXPR_contextIF
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeLOGICAL
case|:
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEEXPR_contextASSIGN
case|:
case|case
name|FFEEXPR_contextAGOTO
case|:
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
name|error
operator|=
operator|(
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
operator|!=
name|ffecom_label_kind
argument_list|()
operator|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|error
operator|=
operator|!
name|ffe_is_ugly_logint
argument_list|()
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
operator|!=
name|ffecom_label_kind
argument_list|()
operator|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextCGOTO
case|:
case|case
name|FFEEXPR_contextFORMAT
case|:
case|case
name|FFEEXPR_contextDIMLIST
case|:
case|case
name|FFEEXPR_contextFILENUM
case|:
comment|/* See equiv code in _ambig_. */
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeREAL
case|:
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEEXPR_contextARITHIF
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeREAL
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEEXPR_contextSTOP
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
name|error
operator|=
operator|(
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_kindtypeINTEGERDEFAULT
operator|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
operator|(
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_kindtypeCHARACTERDEFAULT
operator|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeNONE
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
operator|||
operator|(
name|ffebld_conter_orig
argument_list|(
name|expr
argument_list|)
operator|!=
name|NULL
operator|)
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextINCLUDE
case|:
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
operator|||
operator|(
name|ffebld_conter_orig
argument_list|(
name|expr
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSELECTCASE
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeCHARACTER
case|:
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEEXPR_contextCASE
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeINTEGER
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeCHARACTER
case|:
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextCHARACTERSIZE
case|:
case|case
name|FFEEXPR_contextKINDTYPE
case|:
case|case
name|FFEEXPR_contextDIMLISTCOMMON
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeREAL
case|:
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextEQVINDEX_
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeNONE
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeREAL
case|:
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextPARAMETER
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
expr_stmt|;
else|else
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOLON
condition|)
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextINDEX_
expr_stmt|;
else|else
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextACTUALARG_
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
case|:
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOLON
condition|)
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextINDEX_
expr_stmt|;
else|else
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextACTUALARGEXPR_
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOLON
condition|)
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFINDEX_
expr_stmt|;
else|else
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFACTUALARG_
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
case|:
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOLON
condition|)
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFINDEX_
expr_stmt|;
else|else
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEEXPR_contextIMPDOCTRL_
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|ffeexpr_stack_
operator|->
name|is_rhs
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
if|if
condition|(
operator|!
name|ffe_is_ugly_logint
argument_list|()
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
break|break;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
if|if
condition|(
operator|!
name|ffeexpr_stack_
operator|->
name|is_rhs
operator|&&
name|ffe_is_warn_surprising
argument_list|()
operator|&&
operator|!
name|error
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DO_REAL
argument_list|)
expr_stmt|;
comment|/* See error message!!! */
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ft
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEEXPR_contextDATAIMPDOCTRL_
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
block|{
if|if
condition|(
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
operator|&&
operator|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_whereIMMEDIATE
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
operator|||
operator|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_whereIMMEDIATE
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
if|if
condition|(
operator|!
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
break|break;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FFEINFO_basictypeINTEGER
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
operator|&&
operator|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEINFO_kindtypeINTEGERDEFAULT
operator|)
condition|)
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeREAL
case|:
if|if
condition|(
operator|!
name|ffeexpr_stack_
operator|->
name|is_rhs
operator|&&
name|ffe_is_warn_surprising
argument_list|()
operator|&&
operator|!
name|error
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DO_REAL
argument_list|)
expr_stmt|;
comment|/* See error message!!! */
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ft
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEEXPR_contextIMPDOITEM_
case|:
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeEQUALS
condition|)
block|{
name|ffeexpr_stack_
operator|->
name|is_rhs
operator|=
name|FALSE
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextIMPDOCTRL_
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
block|}
comment|/* Fall through. */
case|case
name|FFEEXPR_contextIOLIST
case|:
case|case
name|FFEEXPR_contextFILEVXTCODE
case|:
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
operator|||
operator|(
name|ffesymbol_arraysize
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|ffesymbol_arraysize
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opSTAR
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Bad if null expr, or if 						   array that is not a SYMTER 						   (can't happen yet, I 						   think) or has a NULL or 						   STAR (assumed) array 						   size. */
break|break;
case|case
name|FFEEXPR_contextIMPDOITEMDF_
case|:
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeEQUALS
condition|)
block|{
name|ffeexpr_stack_
operator|->
name|is_rhs
operator|=
name|FALSE
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextIMPDOCTRL_
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* :::::::::::::::::::: */
block|}
comment|/* Fall through. */
case|case
name|FFEEXPR_contextIOLISTDF
case|:
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
operator|&&
operator|(
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_kindtypeCHARACTERDEFAULT
operator|)
operator|)
operator|||
operator|(
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
operator|||
operator|(
name|ffesymbol_arraysize
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|ffesymbol_arraysize
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opSTAR
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Bad if null expr, 						   non-default-kindtype 						   character expr, or if 						   array that is not a SYMTER 						   (can't happen yet, I 						   think) or has a NULL or 						   STAR (assumed) array 						   size. */
break|break;
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opARRAYREF
operator|)
operator|||
operator|(
operator|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_whereFLEETING_CADDR
operator|)
operator|&&
operator|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_whereFLEETING_IADDR
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextDATAIMPDOINDEX_
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeREAL
case|:
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
operator|)
operator|&&
operator|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_whereIMMEDIATE
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextDATA
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
name|error
operator|=
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opSYMTER
condition|)
name|error
operator|=
name|FALSE
expr_stmt|;
else|else
name|error
operator|=
operator|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_whereFLEETING_CADDR
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextINITVAL
case|:
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextEQUIVALENCE
case|:
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opSYMTER
condition|)
name|error
operator|=
name|FALSE
expr_stmt|;
else|else
name|error
operator|=
operator|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_whereFLEETING_CADDR
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextFILEASSOC
case|:
case|case
name|FFEEXPR_contextFILEINT
case|:
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
comment|/* Maybe this should be supported someday, but, right now, 	     g77 can't generate a call to libf2c to write to an 	     integer other than the default size.  */
name|error
operator|=
operator|(
operator|(
operator|!
name|ffeexpr_stack_
operator|->
name|is_rhs
operator|)
operator|&&
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_kindtypeINTEGERDEFAULT
operator|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextFILEDFINT
case|:
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
name|error
operator|=
operator|(
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_kindtypeINTEGERDEFAULT
operator|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextFILELOG
case|:
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextFILECHAR
case|:
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextFILENUMCHAR
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeREAL
case|:
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEEXPR_contextFILEDFCHAR
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|error
operator|=
operator|(
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_kindtypeCHARACTERDEFAULT
operator|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffeexpr_stack_
operator|->
name|is_rhs
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opSUBSTR
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextFILEUNIT
case|:
comment|/* See equiv code in _ambig_. */
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeREAL
case|:
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
break|break;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
comment|/* As if _lhs had been called instead of 				   _rhs. */
case|case
name|FFEBLD_opSYMTER
case|:
name|error
operator|=
operator|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_whereCONSTANT
operator|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opSUBSTR
case|:
name|error
operator|=
operator|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_whereCONSTANT_SUBOBJECT
operator|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opARRAYREF
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
operator|(
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_kindtypeCHARACTERDEFAULT
operator|)
operator|||
operator|(
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
operator|||
operator|(
name|ffesymbol_arraysize
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|ffesymbol_arraysize
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opSTAR
operator|)
operator|)
operator|)
operator|)
condition|)
comment|/* Bad if 						   non-default-kindtype 						   character expr, or if 						   array that is not a SYMTER 						   (can't happen yet, I 						   think), or has a NULL or 						   STAR (assumed) array 						   size. */
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEEXPR_contextFILEFORMAT
case|:
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
name|error
operator|=
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
condition|?
name|ffe_is_pedantic
argument_list|()
comment|/* F77 C5. */
else|:
operator|(
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
operator|!=
name|ffecom_label_kind
argument_list|()
operator|)
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeLOGICAL
case|:
case|case
name|FFEINFO_basictypeREAL
case|:
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
comment|/* F77 C5 -- must be an array of hollerith.  */
name|error
operator|=
name|ffe_is_pedantic
argument_list|()
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
if|if
condition|(
operator|(
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_kindtypeCHARACTERDEFAULT
operator|)
operator|||
operator|(
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
operator|||
operator|(
name|ffesymbol_arraysize
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|ffesymbol_arraysize
argument_list|(
name|ffebld_symter
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opSTAR
operator|)
operator|)
operator|)
condition|)
comment|/* Bad if 						   non-default-kindtype 						   character expr, or if 						   array that is not a SYMTER 						   (can't happen yet, I 						   think), or has a NULL or 						   STAR (assumed) array 						   size. */
name|error
operator|=
name|TRUE
expr_stmt|;
else|else
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEEXPR_contextLOC_
case|:
comment|/* See also ffeintrin_check_loc_.  */
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_kind
argument_list|(
name|info
argument_list|)
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSYMTER
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSUBSTR
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opARRAYREF
operator|)
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|&&
operator|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opANY
operator|)
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_EXPR_WRONG
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ft
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|expr
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|callback
operator|=
name|ffeexpr_stack_
operator|->
name|callback
expr_stmt|;
name|s
operator|=
name|ffeexpr_stack_
operator|->
name|previous
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|ffe_pool_program_unit
argument_list|()
argument_list|,
name|ffeexpr_stack_
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ffeexpr_stack_
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|=
name|s
expr_stmt|;
name|next
operator|=
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|callback
argument_list|)
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|next
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_finished_ambig_ -- Check validity of ambiguous unit/form spec     ffebld expr;    expr = ffeexpr_finished_ambig_(expr);     Replicates a bit of ffeexpr_finished_'s task when in a context    of UNIT or FORMAT.  */
end_comment

begin_function
specifier|static
name|ffebld
name|ffeexpr_finished_ambig_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|)
block|{
name|ffeinfo
name|info
init|=
name|ffebld_info
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|bool
name|error
decl_stmt|;
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextFILENUMAMBIG
case|:
comment|/* Same as FILENUM in _finished_. */
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeREAL
case|:
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextFILEUNITAMBIG
case|:
comment|/* Same as FILEUNIT in _finished_. */
if|if
condition|(
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opSTAR
operator|)
condition|)
block|{
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
condition|?
name|FFEINFO_basictypeNONE
else|:
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeLOGICAL
case|:
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeREAL
case|:
case|case
name|FFEINFO_basictypeCOMPLEX
case|:
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
name|FFEINFO_basictypeINTEGER
case|:
case|case
name|FFEINFO_basictypeHOLLERITH
case|:
case|case
name|FFEINFO_basictypeTYPELESS
case|:
name|error
operator|=
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|expr
operator|=
name|ffeexpr_convert
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ft
argument_list|,
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
comment|/* As if _lhs had been called instead of 				   _rhs. */
case|case
name|FFEBLD_opSYMTER
case|:
name|error
operator|=
operator|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_whereCONSTANT
operator|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opSUBSTR
case|:
name|error
operator|=
operator|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_whereCONSTANT_SUBOBJECT
operator|)
expr_stmt|;
break|break;
case|case
name|FFEBLD_opARRAYREF
case|:
name|error
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad context"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|&&
operator|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opANY
operator|)
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_EXPR_WRONG
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ft
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|expr
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_lhs_ -- Initial state for lhs expression     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Basically a smaller version of _rhs_; keep them both in sync, of course.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_lhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
comment|/* When changing the list of valid initial lhs tokens, check whether to      update a corresponding list in ffeexpr_cb_close_paren_ambig_1_ for the      READ (expr)<token> case -- it assumes it knows which tokens<token> can      be to indicate an lhs (or implied DO), which right now is the set      {NAME,OPEN_PAREN}.       This comment also appears in ffeexpr_token_first_lhs_. */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
name|ffeexpr_tokens_
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_name_lhs_
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_finished_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeexpr_token_rhs_ -- Initial state for rhs expression     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     The initial state and the post-binary-operator state are the same and    both handled here, with the expression stack used to distinguish    between them.  Binary operators are invalid here; unary operators,    constants, subexpressions, and name references are valid.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_rhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeQUOTE
case|:
if|if
condition|(
name|ffe_is_vxt
argument_list|()
condition|)
block|{
name|ffeexpr_tokens_
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_quote_
return|;
block|}
name|ffeexpr_tokens_
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffelex_set_expecting_hollerith
argument_list|(
operator|-
literal|1
argument_list|,
literal|'\"'
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't have to unset this one. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_apostrophe_
return|;
case|case
name|FFELEX_typeAPOSTROPHE
case|:
name|ffeexpr_tokens_
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffelex_set_expecting_hollerith
argument_list|(
operator|-
literal|1
argument_list|,
literal|'\''
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't have to unset this one. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_apostrophe_
return|;
case|case
name|FFELEX_typePERCENT
case|:
name|ffeexpr_tokens_
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_percent_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextPAREN_
argument_list|,
name|ffeexpr_cb_close_paren_c_
argument_list|)
return|;
case|case
name|FFELEX_typePLUS
case|:
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeUNARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorADD_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceADD_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityADD_
expr_stmt|;
name|ffeexpr_exprstack_push_unary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
case|case
name|FFELEX_typeMINUS
case|:
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeUNARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorSUBTRACT_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceSUBTRACT_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativitySUBTRACT_
expr_stmt|;
name|ffeexpr_exprstack_push_unary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
case|case
name|FFELEX_typePERIOD
case|:
name|ffeexpr_tokens_
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_period_
return|;
case|case
name|FFELEX_typeNUMBER
case|:
name|ffeexpr_tokens_
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffeexpr_hollerith_count_
operator|=
name|atol
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffeexpr_hollerith_count_
operator|>
literal|0
condition|)
name|ffelex_set_expecting_hollerith
argument_list|(
name|ffeexpr_hollerith_count_
argument_list|,
literal|'\0'
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_number_
return|;
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
name|ffeexpr_tokens_
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextACTUALARG_
case|:
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_name_arg_
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_name_rhs_
return|;
block|}
case|case
name|FFELEX_typeASTERISK
case|:
case|case
name|FFELEX_typeSLASH
case|:
case|case
name|FFELEX_typePOWER
case|:
case|case
name|FFELEX_typeCONCAT
case|:
case|case
name|FFELEX_typeREL_EQ
case|:
case|case
name|FFELEX_typeREL_NE
case|:
case|case
name|FFELEX_typeREL_LE
case|:
case|case
name|FFELEX_typeREL_GE
case|:
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_MISSING_FIRST_BINARY_OPERAND
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
if|#
directive|if
literal|0
block|case FFELEX_typeEQUALS:     case FFELEX_typePOINTS:     case FFELEX_typeCLOSE_ANGLE:     case FFELEX_typeCLOSE_PAREN:     case FFELEX_typeCOMMA:     case FFELEX_typeCOLON:     case FFELEX_typeEOS:     case FFELEX_typeSEMICOLON:
endif|#
directive|endif
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_finished_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeexpr_token_period_ -- Rhs PERIOD     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Handle a period detected at rhs (expecting unary op or operand) state.    Must begin a floating-point value (as in .12) or a dot-dot name, of    which only .NOT., .TRUE., and .FALSE. are truly valid.  Other sort-of-    valid names represent binary operators, which are invalid here because    there isn't an operand at the top of the stack.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
name|ffeexpr_current_dotdot_
operator|=
name|ffestr_other
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_current_dotdot_
condition|)
block|{
case|case
name|FFESTR_otherNone
case|:
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_IGNORING_PERIOD
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFESTR_otherTRUE
case|:
case|case
name|FFESTR_otherFALSE
case|:
case|case
name|FFESTR_otherNOT
case|:
name|ffeexpr_tokens_
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_end_period_
return|;
default|default:
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_MISSING_FIRST_BINARY_OPERAND
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_swallow_period_
return|;
block|}
break|break;
comment|/* Nothing really reaches here. */
case|case
name|FFELEX_typeNUMBER
case|:
name|ffeexpr_tokens_
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_real_
return|;
default|default:
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_IGNORING_PERIOD
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeexpr_token_end_period_ -- Rhs PERIOD NAME(NOT, TRUE, or FALSE)     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Expecting a period to close a .NOT, .TRUE, or .FALSE at rhs (unary op    or operator) state.	If period isn't found, issue a diagnostic but    pretend we saw one.	ffeexpr_current_dotdot_ must already contained the    dotdot representation of the name in between the two PERIOD tokens.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_end_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePERIOD
condition|)
block|{
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_INSERTING_PERIOD
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Kill "NOT"/"TRUE"/"FALSE" 						   token. */
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_current_dotdot_
condition|)
block|{
case|case
name|FFESTR_otherNOT
case|:
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeUNARY_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorNOT_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceNOT_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityNOT_
expr_stmt|;
name|ffeexpr_exprstack_push_unary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePERIOD
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
case|case
name|FFESTR_otherTRUE
case|:
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePERIOD
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
case|case
name|FFESTR_otherFALSE
case|:
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_logicaldefault
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeLOGICAL
argument_list|,
name|FFEINFO_kindtypeLOGICALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePERIOD
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
default|default:
name|assert
argument_list|(
literal|"Bad unary dotdot in ffeexpr_current_dotdot_"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeexpr_token_swallow_period_ -- Rhs PERIOD NAME(not NOT, TRUE, or FALSE)     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     A diagnostic has already been issued; just swallow a period if there is    one, then continue with ffeexpr_token_rhs_.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_swallow_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePERIOD
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_real_ -- Rhs PERIOD NUMBER     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     After a period and a string of digits, check next token for possible    exponent designation (D, E, or Q as first/only character) and continue    real-number handling accordingly.  Else form basic real constant, push    onto expression stack, and enter binary state using current token (which,    if it is a name not beginning with D, E, or Q, will certainly result    in an error, but that's not for this routine to deal with).	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_real_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|char
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNAME
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNAMES
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|(
name|ffesrc_char_match_init
argument_list|(
operator|(
name|d
operator|=
operator|*
operator|(
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
operator|)
operator|)
argument_list|,
literal|'D'
argument_list|,
literal|'d'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'E'
argument_list|,
literal|'e'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'Q'
argument_list|,
literal|'q'
argument_list|)
operator|)
operator|)
operator|&&
name|ffeexpr_isdigits_
argument_list|(
operator|++
name|p
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This code has been removed because it seems inconsistent to 	 produce a diagnostic in this case, but not all of the other 	 ones that look for an exponent and cannot recognize one.  */
block|if (((ffelex_token_type (t) == FFELEX_typeNAME) 	   || (ffelex_token_type (t) == FFELEX_typeNAMES))&& ffest_ffebad_start (FFEBAD_INVALID_EXPONENT)) 	{ 	  char bad[2];  	  ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t)); 	  ffebad_here (1, ffelex_token_where_line (ffeexpr_tokens_[0]), 		       ffelex_token_where_column (ffeexpr_tokens_[0])); 	  bad[0] = *(p - 1); 	  bad[1] = '\0'; 	  ffebad_string (bad); 	  ffebad_finish (); 	}
endif|#
directive|endif
name|ffeexpr_make_float_const_
argument_list|(
name|ffesrc_char_internal_init
argument_list|(
literal|'E'
argument_list|,
literal|'e'
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
comment|/* Just exponent character by itself?	 In which case, PLUS or MINUS must      surely be next, followed by a NUMBER token. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|ffeexpr_tokens_
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_real_exponent_
return|;
block|}
name|ffeexpr_make_float_const_
argument_list|(
name|d
argument_list|,
name|NULL
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_real_exponent_ -- Rhs PERIOD NUMBER NAME(D, E, or Q)     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Ensures this token is PLUS or MINUS, preserves it, goes to final state    for real number (exponent digits).  Else issues diagnostic, assumes a    zero exponent field for number, passes token on to binary state as if    previous token had been "E0" instead of "E", for example.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_real_exponent_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePLUS
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeMINUS
operator|)
condition|)
block|{
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_MISSING_EXPONENT_VALUE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffeexpr_make_float_const_
argument_list|(
name|ffesrc_char_internal_init
argument_list|(
literal|'E'
argument_list|,
literal|'e'
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffeexpr_tokens_
index|[
literal|3
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_real_exp_sign_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_real_exp_sign_ -- Rhs PERIOD NUMBER NAME(D,E,Q) PLUS/MINUS     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Make sure token is a NUMBER, make a real constant out of all we have and    push it onto the expression stack.  Else issue diagnostic and pretend    exponent field was a zero.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_real_exp_sign_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNUMBER
condition|)
block|{
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_MISSING_EXPONENT_VALUE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffeexpr_make_float_const_
argument_list|(
name|ffesrc_char_internal_init
argument_list|(
literal|'E'
argument_list|,
literal|'e'
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffeexpr_make_float_const_
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|3
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_number_ -- Rhs NUMBER     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     If the token is a period, we may have a floating-point number, or an    integer followed by a dotdot binary operator.  If the token is a name    beginning with D, E, or Q, we definitely have a floating-point number.    If the token is a hollerith constant, that's what we've got, so push    it onto the expression stack and continue with the binary state.     Otherwise, we have an integer followed by something the binary state    should be able to swallow.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_number_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
name|ffeinfo
name|ni
decl_stmt|;
name|char
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ffeexpr_hollerith_count_
operator|>
literal|0
condition|)
name|ffelex_set_expecting_hollerith
argument_list|(
literal|0
argument_list|,
literal|'\0'
argument_list|,
name|ffewhere_line_unknown
argument_list|()
argument_list|,
name|ffewhere_column_unknown
argument_list|()
argument_list|)
expr_stmt|;
comment|/* See if we've got a floating-point number here. */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
operator|(
name|ffesrc_char_match_init
argument_list|(
operator|(
name|d
operator|=
operator|*
operator|(
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
operator|)
operator|)
argument_list|,
literal|'D'
argument_list|,
literal|'d'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'E'
argument_list|,
literal|'e'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'Q'
argument_list|,
literal|'q'
argument_list|)
operator|)
operator|&&
name|ffeexpr_isdigits_
argument_list|(
operator|++
name|p
argument_list|)
condition|)
block|{
comment|/* Just exponent character by itself?	 In which case, PLUS or MINUS 	     must surely be next, followed by a NUMBER token. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|ffeexpr_tokens_
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_number_exponent_
return|;
block|}
name|ffeexpr_make_float_const_
argument_list|(
name|d
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
block|}
break|break;
case|case
name|FFELEX_typePERIOD
case|:
name|ffeexpr_tokens_
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_number_period_
return|;
case|case
name|FFELEX_typeHOLLERITH
case|:
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_hollerith
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeHOLLERITH
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
default|default:
break|break;
block|}
comment|/* Nothing specific we were looking for, so make an integer and pass the      current token to the binary state. */
name|ffeexpr_make_float_const_
argument_list|(
literal|'I'
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_number_exponent_ -- Rhs NUMBER NAME(D, E, or Q)     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Ensures this token is PLUS or MINUS, preserves it, goes to final state    for real number (exponent digits).  Else treats number as integer, passes    name to binary, passes current token to subsequent handler.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_number_exponent_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePLUS
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeMINUS
operator|)
condition|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
name|ffelexHandler
name|nexthandler
decl_stmt|;
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_integerdefault
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|nexthandler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|nexthandler
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffeexpr_tokens_
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_number_exp_sign_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_number_exp_sign_ -- Rhs NUMBER NAME(D,E,Q) PLUS/MINUS     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Make sure token is a NUMBER, make a real constant out of all we have and    push it onto the expression stack.  Else issue diagnostic and pretend    exponent field was a zero.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_number_exp_sign_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNUMBER
condition|)
block|{
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_MISSING_EXPONENT_VALUE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffeexpr_make_float_const_
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffeexpr_make_float_const_
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_number_period_ -- Rhs NUMBER PERIOD     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Handle a period detected following a number at rhs state.  Must begin a    floating-point value (as in 1., 1.2, 1.E3, or 1.E+3) or a dot-dot name.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_number_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
name|ffelexHandler
name|nexthandler
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|d
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
if|if
condition|(
operator|(
name|ffesrc_char_match_init
argument_list|(
operator|(
name|d
operator|=
operator|*
operator|(
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
operator|)
operator|)
argument_list|,
literal|'D'
argument_list|,
literal|'d'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'E'
argument_list|,
literal|'e'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'Q'
argument_list|,
literal|'q'
argument_list|)
operator|)
operator|&&
name|ffeexpr_isdigits_
argument_list|(
operator|++
name|p
argument_list|)
condition|)
block|{
comment|/* Just exponent character by itself?	 In which case, PLUS or MINUS 	     must surely be next, followed by a NUMBER token. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|ffeexpr_tokens_
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_number_per_exp_
return|;
block|}
name|ffeexpr_make_float_const_
argument_list|(
name|d
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
block|}
comment|/* A name not representing an exponent, so assume it will be something 	 like EQ, make an integer from the number, pass the period to binary 	 state and the current token to the resulting state. */
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_integerdefault
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|nexthandler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|nexthandler
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
case|case
name|FFELEX_typeNUMBER
case|:
name|ffeexpr_tokens_
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_number_real_
return|;
default|default:
break|break;
block|}
comment|/* Nothing specific we were looking for, so make a real number and pass the      period and then the current token to the binary state. */
name|ffeexpr_make_float_const_
argument_list|(
name|ffesrc_char_internal_init
argument_list|(
literal|'E'
argument_list|,
literal|'e'
argument_list|)
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_number_per_exp_ -- Rhs NUMBER PERIOD NAME(D, E, or Q)     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Ensures this token is PLUS or MINUS, preserves it, goes to final state    for real number (exponent digits).  Else treats number as real, passes    name to binary, passes current token to subsequent handler.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_number_per_exp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePLUS
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeMINUS
operator|)
condition|)
block|{
name|ffelexHandler
name|nexthandler
decl_stmt|;
name|ffeexpr_make_float_const_
argument_list|(
name|ffesrc_char_internal_init
argument_list|(
literal|'E'
argument_list|,
literal|'e'
argument_list|)
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|nexthandler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|nexthandler
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffeexpr_tokens_
index|[
literal|3
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_num_per_exp_sign_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_number_real_ -- Rhs NUMBER PERIOD NUMBER     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     After a number, period, and number, check next token for possible    exponent designation (D, E, or Q as first/only character) and continue    real-number handling accordingly.  Else form basic real constant, push    onto expression stack, and enter binary state using current token (which,    if it is a name not beginning with D, E, or Q, will certainly result    in an error, but that's not for this routine to deal with).	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_number_real_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|char
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNAME
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNAMES
operator|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|(
name|ffesrc_char_match_init
argument_list|(
operator|(
name|d
operator|=
operator|*
operator|(
name|p
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
operator|)
operator|)
argument_list|,
literal|'D'
argument_list|,
literal|'d'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'E'
argument_list|,
literal|'e'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|d
argument_list|,
literal|'Q'
argument_list|,
literal|'q'
argument_list|)
operator|)
operator|)
operator|&&
name|ffeexpr_isdigits_
argument_list|(
operator|++
name|p
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This code has been removed because it seems inconsistent to 	 produce a diagnostic in this case, but not all of the other 	 ones that look for an exponent and cannot recognize one.  */
block|if (((ffelex_token_type (t) == FFELEX_typeNAME) 	   || (ffelex_token_type (t) == FFELEX_typeNAMES))&& ffest_ffebad_start (FFEBAD_INVALID_EXPONENT)) 	{ 	  char bad[2];  	  ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t)); 	  ffebad_here (1, ffelex_token_where_line (ffeexpr_tokens_[0]), 		       ffelex_token_where_column (ffeexpr_tokens_[0])); 	  bad[0] = *(p - 1); 	  bad[1] = '\0'; 	  ffebad_string (bad); 	  ffebad_finish (); 	}
endif|#
directive|endif
name|ffeexpr_make_float_const_
argument_list|(
name|ffesrc_char_internal_init
argument_list|(
literal|'E'
argument_list|,
literal|'e'
argument_list|)
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
comment|/* Just exponent character by itself?	 In which case, PLUS or MINUS must      surely be next, followed by a NUMBER token. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|ffeexpr_tokens_
index|[
literal|3
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_number_real_exp_
return|;
block|}
name|ffeexpr_make_float_const_
argument_list|(
name|d
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_num_per_exp_sign_ -- Rhs NUMBER PERIOD NAME(D,E,Q) PLUS/MINUS     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Make sure token is a NUMBER, make a real constant out of all we have and    push it onto the expression stack.  Else issue diagnostic and pretend    exponent field was a zero.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_num_per_exp_sign_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNUMBER
condition|)
block|{
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_MISSING_EXPONENT_VALUE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffeexpr_make_float_const_
argument_list|(
name|ffesrc_char_internal_init
argument_list|(
literal|'E'
argument_list|,
literal|'e'
argument_list|)
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffeexpr_make_float_const_
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|3
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_number_real_exp_ -- Rhs NUMBER PERIOD NUMBER NAME(D, E, or Q)     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Ensures this token is PLUS or MINUS, preserves it, goes to final state    for real number (exponent digits).  Else issues diagnostic, assumes a    zero exponent field for number, passes token on to binary state as if    previous token had been "E0" instead of "E", for example.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_number_real_exp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePLUS
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeMINUS
operator|)
condition|)
block|{
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_MISSING_EXPONENT_VALUE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffeexpr_make_float_const_
argument_list|(
name|ffesrc_char_internal_init
argument_list|(
literal|'E'
argument_list|,
literal|'e'
argument_list|)
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffeexpr_tokens_
index|[
literal|4
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_num_real_exp_sn_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_num_real_exp_sn_ -- Rhs NUMBER PERIOD NUMBER NAME(D,E,Q) 				  PLUS/MINUS     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Make sure token is a NUMBER, make a real constant out of all we have and    push it onto the expression stack.  Else issue diagnostic and pretend    exponent field was a zero.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_num_real_exp_sn_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNUMBER
condition|)
block|{
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_MISSING_EXPONENT_VALUE
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffeexpr_make_float_const_
argument_list|(
name|ffesrc_char_internal_init
argument_list|(
literal|'E'
argument_list|,
literal|'e'
argument_list|)
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffeexpr_make_float_const_
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffeexpr_tokens_
index|[
literal|3
index|]
argument_list|)
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|3
index|]
argument_list|,
name|ffeexpr_tokens_
index|[
literal|4
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_binary_ -- Handle binary operator possibility     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     The possibility of a binary operator is handled here, meaning the previous    token was an operand.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_binary_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_finished_
argument_list|(
name|t
argument_list|)
return|;
comment|/* For now. */
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typePLUS
case|:
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeBINARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorADD_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceADD_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityADD_
expr_stmt|;
name|ffeexpr_exprstack_push_binary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
case|case
name|FFELEX_typeMINUS
case|:
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeBINARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorSUBTRACT_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceSUBTRACT_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativitySUBTRACT_
expr_stmt|;
name|ffeexpr_exprstack_push_binary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
case|case
name|FFELEX_typeASTERISK
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextDATA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_finished_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeBINARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorMULTIPLY_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceMULTIPLY_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityMULTIPLY_
expr_stmt|;
name|ffeexpr_exprstack_push_binary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
case|case
name|FFELEX_typeSLASH
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextDATA
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_finished_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeBINARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorDIVIDE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceDIVIDE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityDIVIDE_
expr_stmt|;
name|ffeexpr_exprstack_push_binary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
case|case
name|FFELEX_typePOWER
case|:
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeBINARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorPOWER_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedencePOWER_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityPOWER_
expr_stmt|;
name|ffeexpr_exprstack_push_binary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
case|case
name|FFELEX_typeCONCAT
case|:
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeBINARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorCONCATENATE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceCONCATENATE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityCONCATENATE_
expr_stmt|;
name|ffeexpr_exprstack_push_binary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
case|case
name|FFELEX_typeOPEN_ANGLE
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextFORMAT
case|:
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_EXPR_TOKEN
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeBINARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorLT_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceLT_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityLT_
expr_stmt|;
name|ffeexpr_exprstack_push_binary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
case|case
name|FFELEX_typeCLOSE_ANGLE
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextFORMAT
case|:
return|return
name|ffeexpr_finished_
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeBINARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorGT_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceGT_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityGT_
expr_stmt|;
name|ffeexpr_exprstack_push_binary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
case|case
name|FFELEX_typeREL_EQ
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextFORMAT
case|:
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_EXPR_TOKEN
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeBINARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorEQ_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceEQ_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityEQ_
expr_stmt|;
name|ffeexpr_exprstack_push_binary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
case|case
name|FFELEX_typeREL_NE
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextFORMAT
case|:
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_EXPR_TOKEN
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeBINARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorNE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceNE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityNE_
expr_stmt|;
name|ffeexpr_exprstack_push_binary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
case|case
name|FFELEX_typeREL_LE
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextFORMAT
case|:
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_EXPR_TOKEN
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeBINARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorLE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceLE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityLE_
expr_stmt|;
name|ffeexpr_exprstack_push_binary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
case|case
name|FFELEX_typeREL_GE
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextFORMAT
case|:
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_EXPR_TOKEN
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeBINARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorGE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceGE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityGE_
expr_stmt|;
name|ffeexpr_exprstack_push_binary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
case|case
name|FFELEX_typePERIOD
case|:
name|ffeexpr_tokens_
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_period_
return|;
if|#
directive|if
literal|0
block|case FFELEX_typeOPEN_PAREN:     case FFELEX_typeCLOSE_PAREN:     case FFELEX_typeEQUALS:     case FFELEX_typePOINTS:     case FFELEX_typeCOMMA:     case FFELEX_typeCOLON:     case FFELEX_typeEOS:     case FFELEX_typeSEMICOLON:     case FFELEX_typeNAME:     case FFELEX_typeNAMES:
endif|#
directive|endif
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_finished_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeexpr_token_binary_period_ -- Binary PERIOD     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Handle a period detected at binary (expecting binary op or end) state.    Must begin a dot-dot name, of which .NOT., .TRUE., and .FALSE. are not    valid.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_binary_period_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|operand
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
name|ffeexpr_current_dotdot_
operator|=
name|ffestr_other
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_current_dotdot_
condition|)
block|{
case|case
name|FFESTR_otherTRUE
case|:
case|case
name|FFESTR_otherFALSE
case|:
case|case
name|FFESTR_otherNOT
case|:
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_MISSING_BINARY_OPERATOR
argument_list|)
condition|)
block|{
name|operand
operator|=
name|ffeexpr_stack_
operator|->
name|exprstack
expr_stmt|;
name|assert
argument_list|(
name|operand
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|operand
operator|->
name|type
operator|==
name|FFEEXPR_exprtypeOPERAND_
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|operand
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|operand
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_sw_per_
return|;
default|default:
name|ffeexpr_tokens_
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_end_per_
return|;
block|}
break|break;
comment|/* Nothing really reaches here. */
default|default:
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_IGNORING_PERIOD
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeexpr_token_binary_end_per_ -- Binary PERIOD NAME(not NOT, TRUE, or FALSE)     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Expecting a period to close a dot-dot at binary (binary op    or operator) state.	If period isn't found, issue a diagnostic but    pretend we saw one.	ffeexpr_current_dotdot_ must already contained the    dotdot representation of the name in between the two PERIOD tokens.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_binary_end_per_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeBINARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_current_dotdot_
condition|)
block|{
case|case
name|FFESTR_otherAND
case|:
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorAND_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceAND_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityAND_
expr_stmt|;
break|break;
case|case
name|FFESTR_otherOR
case|:
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorOR_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceOR_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityOR_
expr_stmt|;
break|break;
case|case
name|FFESTR_otherXOR
case|:
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorXOR_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceXOR_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityXOR_
expr_stmt|;
break|break;
case|case
name|FFESTR_otherEQV
case|:
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorEQV_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceEQV_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityEQV_
expr_stmt|;
break|break;
case|case
name|FFESTR_otherNEQV
case|:
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorNEQV_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceNEQV_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityNEQV_
expr_stmt|;
break|break;
case|case
name|FFESTR_otherLT
case|:
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorLT_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceLT_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityLT_
expr_stmt|;
break|break;
case|case
name|FFESTR_otherLE
case|:
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorLE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceLE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityLE_
expr_stmt|;
break|break;
case|case
name|FFESTR_otherEQ
case|:
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorEQ_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceEQ_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityEQ_
expr_stmt|;
break|break;
case|case
name|FFESTR_otherNE
case|:
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorNE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceNE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityNE_
expr_stmt|;
break|break;
case|case
name|FFESTR_otherGT
case|:
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorGT_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceGT_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityGT_
expr_stmt|;
break|break;
case|case
name|FFESTR_otherGE
case|:
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorGE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceGE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityGE_
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_INVALID_DOTDOT
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorEQ_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceEQ_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityEQ_
expr_stmt|;
break|break;
block|}
name|ffeexpr_exprstack_push_binary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePERIOD
condition|)
block|{
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_INSERTING_PERIOD
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Kill dot-dot token. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Kill dot-dot token. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_binary_sw_per_ -- Rhs PERIOD NAME(NOT, TRUE, or FALSE)     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     A diagnostic has already been issued; just swallow a period if there is    one, then continue with ffeexpr_token_binary_.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_binary_sw_per_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typePERIOD
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_quote_ -- Rhs QUOTE     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Expecting a NUMBER that we'll treat as an octal integer.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_quote_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
name|ffebld
name|anyexpr
decl_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeNUMBER
condition|)
block|{
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_QUOTE_MISSES_DIGITS
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
argument_list|(
name|t
argument_list|)
return|;
block|}
comment|/* This is kind of a kludge to prevent any whining about magical numbers      that start out as these octal integers, so "20000000000 (on a 32-bit      2's-complement machine) by itself won't produce an error. */
name|anyexpr
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|anyexpr
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter_with_orig
argument_list|(
name|ffebld_constant_new_integeroctal
argument_list|(
name|t
argument_list|)
argument_list|,
name|anyexpr
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_apostrophe_ -- Rhs APOSTROPHE     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Handle an open-apostrophe, which begins either a character ('char-const'),    typeless octal ('octal-const'O), or typeless hexadecimal ('hex-const'Z or    'hex-const'X) constant.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_apostrophe_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCHARACTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_pedantic_not_90
argument_list|()
operator|&&
operator|(
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_NULL_CHAR_CONST
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffeexpr_tokens_
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_apos_char_
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_apos_char_ -- Rhs APOSTROPHE CHARACTER     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Close-apostrophe is implicit; if this token is NAME, it is a possible    typeless-constant radix specifier.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_apos_char_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
name|ffeinfo
name|ni
decl_stmt|;
name|char
name|c
decl_stmt|;
name|ffetargetCharacterSize
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAMES
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ffelex_token_length
argument_list|(
name|t
argument_list|)
operator|==
literal|1
operator|)
operator|&&
operator|(
name|ffesrc_char_match_init
argument_list|(
operator|(
name|c
operator|=
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
index|[
literal|0
index|]
operator|)
argument_list|,
literal|'B'
argument_list|,
literal|'b'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|c
argument_list|,
literal|'O'
argument_list|,
literal|'o'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|c
argument_list|,
literal|'X'
argument_list|,
literal|'x'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|c
argument_list|,
literal|'Z'
argument_list|,
literal|'z'
argument_list|)
operator|)
condition|)
block|{
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'B'
argument_list|,
literal|'b'
argument_list|,
name|match_b
argument_list|,
name|no_match
argument_list|)
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_typeless_bv
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|ffetarget_size_typeless_binary
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'O'
argument_list|,
literal|'o'
argument_list|,
name|match_o
argument_list|,
name|no_match
argument_list|)
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_typeless_ov
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|ffetarget_size_typeless_octal
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'X'
argument_list|,
literal|'x'
argument_list|,
name|match_x
argument_list|,
name|no_match
argument_list|)
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_typeless_hxv
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|ffetarget_size_typeless_hex
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'Z'
argument_list|,
literal|'z'
argument_list|,
name|match_z
argument_list|,
name|no_match
argument_list|)
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_typeless_hzv
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|ffetarget_size_typeless_hex
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|no_match
label|:
comment|/* :::::::::::::::::::: */
name|assert
argument_list|(
literal|"not BOXZ!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeTYPELESS
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
block|}
block|}
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_characterdefault
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeCHARACTER
argument_list|,
name|FFEINFO_kindtypeCHARACTERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|ffelex_token_length
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeNAMES
operator|)
condition|)
block|{
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_INVALID_RADIX_SPECIFIER
argument_list|)
condition|)
block|{
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeBINARY_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|op
operator|=
name|FFEEXPR_operatorCONCATENATE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|prec
operator|=
name|FFEEXPR_operatorprecedenceCONCATENATE_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operator
operator|.
name|as
operator|=
name|FFEEXPR_operatorassociativityCONCATENATE_
expr_stmt|;
name|ffeexpr_exprstack_push_binary_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
argument_list|(
name|t
argument_list|)
return|;
block|}
name|ffeexpr_is_substr_ok_
operator|=
operator|!
name|ffe_is_pedantic_not_90
argument_list|()
expr_stmt|;
comment|/* Allow "'hello'(3:5)". */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_substrp_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_name_lhs_ -- Lhs NAME     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Handle a name followed by open-paren, period (RECORD.MEMBER), percent    (RECORD%MEMBER), or nothing at all.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_name_lhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
name|ffeexprParenType_
name|paren_type
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|ffebld
name|expr
decl_stmt|;
name|ffeinfo
name|info
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeOPEN_PAREN
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextASSIGN
case|:
case|case
name|FFEEXPR_contextAGOTO
case|:
case|case
name|FFEEXPR_contextFILEUNIT_DF
case|:
goto|goto
name|just_name
goto|;
comment|/* :::::::::::::::::::: */
default|default:
break|break;
block|}
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffeexpr_declare_parenthesized_
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|FALSE
argument_list|,
operator|&
name|paren_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereLOCAL
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|context
operator|==
name|FFEEXPR_contextSUBROUTINEREF
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Recursion. */
break|break;
case|case
name|FFEINFO_whereINTRINSIC
case|:
case|case
name|FFEINFO_whereGLOBAL
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|context
operator|!=
name|FFEEXPR_contextSUBROUTINEREF
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Can call intrin. */
break|break;
case|case
name|FFEINFO_whereCOMMON
case|:
case|case
name|FFEINFO_whereDUMMY
case|:
case|case
name|FFEINFO_whereRESULT
case|:
break|break;
case|case
name|FFEINFO_whereNONE
case|:
case|case
name|FFEINFO_whereANY
case|:
break|break;
default|default:
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
operator|&
name|FFESYMBOL_attrsANY
condition|)
block|{
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_symter
argument_list|(
name|s
argument_list|,
name|ffesymbol_generic
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_specific
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_implementation
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffeexpr_exprstack_push_
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Not a complete operand yet. */
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|paren_type
condition|)
block|{
case|case
name|FFEEXPR_parentypeSUBROUTINE_
case|:
name|ffebld_init_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextACTUALARG_
argument_list|,
name|ffeexpr_token_arguments_
argument_list|)
return|;
case|case
name|FFEEXPR_parentypeARRAY_
case|:
name|ffebld_init_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|bound_list
operator|=
name|ffesymbol_dims
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|rank
operator|=
literal|0
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|constant
operator|=
name|TRUE
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|immediate
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextDATAIMPDOINDEX_
argument_list|,
name|ffeexpr_token_elements_
argument_list|)
return|;
case|case
name|FFEEXPR_contextEQUIVALENCE
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextEQVINDEX_
argument_list|,
name|ffeexpr_token_elements_
argument_list|)
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextINDEX_
argument_list|,
name|ffeexpr_token_elements_
argument_list|)
return|;
block|}
case|case
name|FFEEXPR_parentypeSUBSTRING_
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffeexpr_collapse_symter
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextINDEX_
argument_list|,
name|ffeexpr_token_substring_
argument_list|)
return|;
case|case
name|FFEEXPR_parentypeEQUIVALENCE_
case|:
name|ffebld_init_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|bound_list
operator|=
name|ffesymbol_dims
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|rank
operator|=
literal|0
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|constant
operator|=
name|TRUE
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|immediate
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextEQVINDEX_
argument_list|,
name|ffeexpr_token_equivalence_
argument_list|)
return|;
case|case
name|FFEEXPR_parentypeFUNCTION_
case|:
comment|/* Invalid case. */
case|case
name|FFEEXPR_parentypeFUNSUBSTR_
case|:
comment|/* Invalid case. */
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEEXPR_parentypeANY_
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextACTUALARG_
argument_list|,
name|ffeexpr_token_anything_
argument_list|)
return|;
default|default:
name|assert
argument_list|(
literal|"bad paren type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|FFELEX_typeEQUALS
case|:
comment|/* As in "VAR=". */
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextIMPDOITEM_
case|:
comment|/* within 						   "(,VAR=start,end[,incr])". */
case|case
name|FFEEXPR_contextIMPDOITEMDF_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextIMPDOCTRL_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextDATAIMPDOCTRL_
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
if|#
directive|if
literal|0
block|case FFELEX_typePERIOD:     case FFELEX_typePERCENT:       assert ("FOO%, FOO. not yet supported!~~" == NULL);       break;
endif|#
directive|endif
default|default:
break|break;
block|}
name|just_name
label|:
comment|/* :::::::::::::::::::: */
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|=
name|ffeexpr_declare_unadorned_
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
operator|(
name|ffeexpr_stack_
operator|->
name|context
operator|==
name|FFEEXPR_contextSUBROUTINEREF
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
if|if
condition|(
operator|(
name|ffeexpr_stack_
operator|->
name|context
operator|!=
name|FFEEXPR_contextPARAMETER
operator|)
operator|||
operator|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_kindENTITY
operator|)
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
if|if
condition|(
operator|(
name|ffeexpr_stack_
operator|->
name|context
operator|!=
name|FFEEXPR_contextDATAIMPDOCTRL_
operator|)
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|context
operator|!=
name|FFEEXPR_contextDATAIMPDOINDEX_
operator|)
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereLOCAL
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|context
operator|==
name|FFEEXPR_contextSUBROUTINEREF
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Recurse!. */
break|break;
case|case
name|FFEINFO_whereINTRINSIC
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|context
operator|!=
name|FFEEXPR_contextSUBROUTINEREF
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Can call intrin. */
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
operator|&
name|FFESYMBOL_attrsANY
condition|)
block|{
name|expr
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|info
operator|=
name|ffeinfo_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expr
operator|=
name|ffebld_new_symter
argument_list|(
name|s
argument_list|,
name|ffesymbol_generic
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_specific
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_implementation
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|=
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_is_doiter
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DOITER
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffest_ffebad_here_doiter
argument_list|(
literal|1
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|expr
operator|=
name|ffeexpr_collapse_symter
argument_list|(
name|expr
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|context
operator|==
name|FFEEXPR_contextSUBROUTINEREF
condition|)
block|{
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
block|{
name|expr
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expr
operator|=
name|ffebld_new_subrref
argument_list|(
name|expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* No argument list. */
if|if
condition|(
name|ffesymbol_generic
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINTRIN_genNONE
condition|)
name|ffeintrin_fulfill_generic
argument_list|(
operator|&
name|expr
argument_list|,
operator|&
name|info
argument_list|,
name|e
operator|->
name|token
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ffesymbol_specific
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINTRIN_specNONE
condition|)
name|ffeintrin_fulfill_specific
argument_list|(
operator|&
name|expr
argument_list|,
operator|&
name|info
argument_list|,
name|NULL
argument_list|,
name|e
operator|->
name|token
argument_list|)
expr_stmt|;
else|else
name|ffeexpr_fulfill_call_
argument_list|(
operator|&
name|expr
argument_list|,
name|e
operator|->
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opANY
condition|)
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereFLEETING
argument_list|,
name|ffeinfo_size
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|expr
expr_stmt|;
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_finished_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_name_arg_ -- Rhs NAME     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Handle first token in an actual-arg (or possible actual-arg) context    being a NAME, and use second token to refine the context.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_name_arg_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCLOSE_PAREN
case|:
case|case
name|FFELEX_typeCOMMA
case|:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextACTUALARG_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFACTUALARG_
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad context in _name_arg_"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_name_rhs_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_name_rhs_ -- Rhs NAME     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Handle a name followed by open-paren, apostrophe (O'octal-const',    Z'hex-const', or X'hex-const'), period (RECORD.MEMBER).     26-Nov-91  JCB  1.2       When followed by apostrophe or quote, set lex hexnum flag on so       [0-9] as first char of next token seen as starting a potentially       hex number (NAME).    04-Oct-91  JCB  1.1       In case of intrinsic, decorate its SYMTER with the type info for       the specific intrinsic.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_name_rhs_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
name|ffeexprParenType_
name|paren_type
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|bool
name|sfdef
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeQUOTE
case|:
case|case
name|FFELEX_typeAPOSTROPHE
case|:
name|ffeexpr_tokens_
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffelex_set_hexnum
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_name_apos_
return|;
case|case
name|FFELEX_typeOPEN_PAREN
case|:
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffeexpr_declare_parenthesized_
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|TRUE
argument_list|,
operator|&
name|paren_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
else|else
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_symter
argument_list|(
name|s
argument_list|,
name|ffesymbol_generic
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_specific
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_implementation
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_exprstack_push_
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Not a complete operand yet. */
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
condition|)
block|{
case|case
name|FFEEXPR_contextSFUNCDEF
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEX_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
case|:
name|sfdef
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|assert
argument_list|(
literal|"weird context!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|sfdef
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|sfdef
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|paren_type
condition|)
block|{
case|case
name|FFEEXPR_parentypeFUNCTION_
case|:
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_init_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereCONSTANT
condition|)
block|{
comment|/* A statement function. */
name|ffeexpr_stack_
operator|->
name|num_args
operator|=
name|ffebld_list_length
argument_list|(
name|ffeexpr_stack_
operator|->
name|next_dummy
operator|=
name|ffesymbol_dummyargs
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* !=NULL when> num_args. */
block|}
elseif|else
if|if
condition|(
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereINTRINSIC
operator|)
operator|&&
operator|!
name|ffe_is_pedantic_not_90
argument_list|()
operator|&&
operator|(
operator|(
name|ffesymbol_implementation
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINTRIN_impICHAR
operator|)
operator|||
operator|(
name|ffesymbol_implementation
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINTRIN_impIACHAR
operator|)
operator|||
operator|(
name|ffesymbol_implementation
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINTRIN_impLEN
operator|)
operator|)
condition|)
block|{
comment|/* Allow arbitrary concatenations. */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|sfdef
condition|?
name|FFEEXPR_contextSFUNCDEF
else|:
name|FFEEXPR_contextLET
argument_list|,
name|ffeexpr_token_arguments_
argument_list|)
return|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|sfdef
condition|?
name|FFEEXPR_contextSFUNCDEFACTUALARG_
else|:
name|FFEEXPR_contextACTUALARG_
argument_list|,
name|ffeexpr_token_arguments_
argument_list|)
return|;
case|case
name|FFEEXPR_parentypeARRAY_
case|:
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffesymbol_info
argument_list|(
name|ffebld_symter
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_init_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|bound_list
operator|=
name|ffesymbol_dims
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|rank
operator|=
literal|0
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|constant
operator|=
name|TRUE
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|immediate
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|sfdef
condition|?
name|FFEEXPR_contextSFUNCDEFINDEX_
else|:
name|FFEEXPR_contextINDEX_
argument_list|,
name|ffeexpr_token_elements_
argument_list|)
return|;
case|case
name|FFEEXPR_parentypeSUBSTRING_
case|:
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffesymbol_info
argument_list|(
name|ffebld_symter
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffeexpr_collapse_symter
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|sfdef
condition|?
name|FFEEXPR_contextSFUNCDEFINDEX_
else|:
name|FFEEXPR_contextINDEX_
argument_list|,
name|ffeexpr_token_substring_
argument_list|)
return|;
case|case
name|FFEEXPR_parentypeFUNSUBSTR_
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|sfdef
condition|?
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
else|:
name|FFEEXPR_contextINDEXORACTUALARG_
argument_list|,
name|ffeexpr_token_funsubstr_
argument_list|)
return|;
case|case
name|FFEEXPR_parentypeANY_
case|:
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|sfdef
condition|?
name|FFEEXPR_contextSFUNCDEFACTUALARG_
else|:
name|FFEEXPR_contextACTUALARG_
argument_list|,
name|ffeexpr_token_anything_
argument_list|)
return|;
default|default:
name|assert
argument_list|(
literal|"bad paren type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|FFELEX_typeEQUALS
case|:
comment|/* As in "VAR=". */
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextIMPDOITEM_
case|:
comment|/* "(,VAR=start,end[,incr])". */
case|case
name|FFEEXPR_contextIMPDOITEMDF_
case|:
name|ffeexpr_stack_
operator|->
name|is_rhs
operator|=
name|FALSE
expr_stmt|;
comment|/* Really an lhs construct. */
name|ffeexpr_stack_
operator|->
name|context
operator|=
name|FFEEXPR_contextIMPDOCTRL_
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
if|#
directive|if
literal|0
block|case FFELEX_typePERIOD:     case FFELEX_typePERCENT:       ~~Support these two someday, though not required 	assert ("FOO%, FOO. not yet supported!~~" == NULL);       break;
endif|#
directive|endif
default|default:
break|break;
block|}
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|assert
argument_list|(
literal|"strange context"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|=
name|ffeexpr_declare_unadorned_
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
operator|&
name|FFESYMBOL_attrsANY
condition|)
block|{
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_symter
argument_list|(
name|s
argument_list|,
name|FFEINTRIN_genNONE
argument_list|,
name|ffesymbol_specific
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_implementation
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_specific
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINTRIN_specNONE
condition|)
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_use
argument_list|(
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Decorate the SYMTER with the actual type 				   of the intrinsic. */
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffeintrin_basictype
argument_list|(
name|ffesymbol_specific
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|,
name|ffeintrin_kindtype
argument_list|(
name|ffesymbol_specific
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffesymbol_is_doiter
argument_list|(
name|s
argument_list|)
condition|)
name|ffebld_symter_set_is_doiter
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffeexpr_collapse_symter
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_name_apos_ -- Rhs NAME APOSTROPHE     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Expecting a NAME token, analyze the previous NAME token to see what kind,    if any, typeless constant we've got.     01-Sep-90  JCB  1.1       Expect a NAME instead of CHARACTER in this situation.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_name_apos_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
name|ffelex_set_hexnum
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
name|ffeexpr_tokens_
index|[
literal|2
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_name_apos_name_
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_INVALID_RADIX_SPECIFIER
argument_list|)
condition|)
block|{
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_name_apos_name_ -- Rhs NAME APOSTROPHE NAME     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Expecting an APOSTROPHE token, analyze the previous NAME token to see    what kind, if any, typeless constant we've got.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_name_apos_name_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
name|char
name|c
decl_stmt|;
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|ffelex_token_type
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|ffelex_token_length
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
operator|==
literal|1
operator|)
operator|&&
operator|(
name|ffesrc_char_match_init
argument_list|(
operator|(
name|c
operator|=
name|ffelex_token_text
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
index|[
literal|0
index|]
operator|)
argument_list|,
literal|'B'
argument_list|,
literal|'b'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|c
argument_list|,
literal|'O'
argument_list|,
literal|'o'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|c
argument_list|,
literal|'X'
argument_list|,
literal|'x'
argument_list|)
operator|||
name|ffesrc_char_match_init
argument_list|(
name|c
argument_list|,
literal|'Z'
argument_list|,
literal|'z'
argument_list|)
operator|)
condition|)
block|{
name|ffetargetCharacterSize
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|ffe_is_typeless_boz
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'B'
argument_list|,
literal|'b'
argument_list|,
name|imatch_b
argument_list|,
name|no_imatch
argument_list|)
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_integerbinary
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'O'
argument_list|,
literal|'o'
argument_list|,
name|imatch_o
argument_list|,
name|no_imatch
argument_list|)
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_integeroctal
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'X'
argument_list|,
literal|'x'
argument_list|,
name|imatch_x
argument_list|,
name|no_imatch
argument_list|)
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_integerhex
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'Z'
argument_list|,
literal|'z'
argument_list|,
name|imatch_z
argument_list|,
name|no_imatch
argument_list|)
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_integerhex
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|no_imatch
label|:
comment|/* :::::::::::::::::::: */
name|assert
argument_list|(
literal|"not BOXZ!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'B'
argument_list|,
literal|'b'
argument_list|,
name|match_b
argument_list|,
name|no_match
argument_list|)
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_typeless_bm
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|ffetarget_size_typeless_binary
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'O'
argument_list|,
literal|'o'
argument_list|,
name|match_o
argument_list|,
name|no_match
argument_list|)
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_typeless_om
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|ffetarget_size_typeless_octal
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'X'
argument_list|,
literal|'x'
argument_list|,
name|match_x
argument_list|,
name|no_match
argument_list|)
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_typeless_hxm
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|ffetarget_size_typeless_hex
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'Z'
argument_list|,
literal|'z'
argument_list|,
name|match_z
argument_list|,
name|no_match
argument_list|)
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_typeless_hzm
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|ffetarget_size_typeless_hex
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|no_match
label|:
comment|/* :::::::::::::::::::: */
name|assert
argument_list|(
literal|"not BOXZ!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_typeless_hzm
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|ffetarget_size_typeless_hex
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeTYPELESS
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
block|}
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_INVALID_RADIX_SPECIFIER
argument_list|)
condition|)
block|{
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeAPOSTROPHE
case|:
case|case
name|FFELEX_typeQUOTE
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
return|;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeexpr_token_percent_ -- Rhs PERCENT     Handle a percent sign possibly followed by "LOC".  If followed instead    by "VAL", "REF", or "DESCR", issue an error message and substitute    "LOC".  If followed by something else, treat the percent sign as a    spurious incorrect token and reprocess the token via _rhs_.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_percent_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeNAME
case|:
case|case
name|FFELEX_typeNAMES
case|:
name|ffeexpr_stack_
operator|->
name|percent
operator|=
name|ffeexpr_percent_
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ffeexpr_tokens_
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_percent_name_
return|;
default|default:
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_INVALID_TOKEN_IN_EXPRESSION
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeexpr_token_percent_name_ -- Rhs PERCENT NAME     Make sure the token is OPEN_PAREN and prepare for the one-item list of    LHS expressions.  Else display an error message.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_percent_name_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffelexHandler
name|nexthandler
decl_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeOPEN_PAREN
condition|)
block|{
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_INVALID_TOKEN_IN_EXPRESSION
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|first_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|nexthandler
operator|=
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_rhs_
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
call|(
name|ffelexHandler
call|)
argument_list|(
operator|*
name|nexthandler
argument_list|)
argument_list|(
name|t
argument_list|)
return|;
block|}
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|percent
condition|)
block|{
default|default:
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_INVALID_PERCENT
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffeexpr_stack_
operator|->
name|percent
operator|=
name|FFEEXPR_percentLOC_
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFEEXPR_percentLOC_
case|:
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
operator|=
name|ffeexpr_tokens_
index|[
literal|0
index|]
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_tokens_
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextLOC_
argument_list|,
name|ffeexpr_cb_end_loc_
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeexpr_make_float_const_ -- Make a floating-point constant     See prototype.     Pass 'E', 'D', or 'Q' for exponent letter.  */
end_comment

begin_function
specifier|static
name|void
name|ffeexpr_make_float_const_
parameter_list|(
name|char
name|exp_letter
parameter_list|,
name|ffelexToken
name|integer
parameter_list|,
name|ffelexToken
name|decimal
parameter_list|,
name|ffelexToken
name|fraction
parameter_list|,
name|ffelexToken
name|exponent
parameter_list|,
name|ffelexToken
name|exponent_sign
parameter_list|,
name|ffelexToken
name|exponent_digits
parameter_list|)
block|{
name|ffeexprExpr_
name|e
decl_stmt|;
name|e
operator|=
name|ffeexpr_expr_new_
argument_list|()
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|FFEEXPR_exprtypeOPERAND_
expr_stmt|;
if|if
condition|(
name|integer
operator|!=
name|NULL
condition|)
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|integer
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|decimal
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|->
name|token
operator|=
name|ffelex_token_use
argument_list|(
name|decimal
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|exp_letter
condition|)
block|{
if|#
directive|if
operator|!
name|FFETARGET_okREALQUAD
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'Q'
argument_list|,
literal|'q'
argument_list|,
name|match_q
argument_list|,
name|no_match
argument_list|)
case|:
if|if
condition|(
name|ffebad_start
argument_list|(
name|FFEBAD_QUAD_UNSUPPORTED
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|e
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|e
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
goto|goto
name|match_d
goto|;
comment|/* The FFESRC_CASE_* macros don't 				   allow fall-through! */
endif|#
directive|endif
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'D'
argument_list|,
literal|'d'
argument_list|,
name|match_d
argument_list|,
name|no_match
argument_list|)
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_realdouble
argument_list|(
name|integer
argument_list|,
name|decimal
argument_list|,
name|fraction
argument_list|,
name|exponent
argument_list|,
name|exponent_sign
argument_list|,
name|exponent_digits
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeREAL
argument_list|,
name|FFEINFO_kindtypeREALDOUBLE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'E'
argument_list|,
literal|'e'
argument_list|,
name|match_e
argument_list|,
name|no_match
argument_list|)
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_realdefault
argument_list|(
name|integer
argument_list|,
name|decimal
argument_list|,
name|fraction
argument_list|,
name|exponent
argument_list|,
name|exponent_sign
argument_list|,
name|exponent_digits
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeREAL
argument_list|,
name|FFEINFO_kindtypeREALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FFETARGET_okREALQUAD
case|case
name|FFESRC_CASE_MATCH_INIT
argument_list|(
literal|'Q'
argument_list|,
literal|'q'
argument_list|,
name|match_q
argument_list|,
name|no_match
argument_list|)
case|:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_realquad
argument_list|(
name|integer
argument_list|,
name|decimal
argument_list|,
name|fraction
argument_list|,
name|exponent
argument_list|,
name|exponent_sign
argument_list|,
name|exponent_digits
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeREAL
argument_list|,
name|FFEINFO_kindtypeREALQUAD
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'I'
case|:
comment|/* Make an integer. */
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_integerdefault
argument_list|(
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|no_match
label|:
comment|/* :::::::::::::::::::: */
name|assert
argument_list|(
literal|"Lost the exponent letter!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just like ffesymbol_declare_local, except performs any implicit info    assignment necessary.  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffeexpr_declare_unadorned_
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|bool
name|maybe_intrin
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffeinfoKind
name|k
decl_stmt|;
name|bool
name|bad
decl_stmt|;
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|t
argument_list|,
name|maybe_intrin
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
condition|)
comment|/* Special-case these since they can involve a different concept        of "state" (in the stmtfunc name space).  */
block|{
case|case
name|FFEEXPR_contextDATAIMPDOINDEX_
case|:
case|case
name|FFEEXPR_contextDATAIMPDOCTRL_
case|:
if|if
condition|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
operator|==
name|FFEEXPR_contextDATAIMPDOINDEX_
condition|)
name|s
operator|=
name|ffeexpr_sym_impdoitem_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
name|s
operator|=
name|ffeexpr_sym_impdoitem_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|ffeexpr_sym_lhs_impdoctrl_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|bad
operator|=
operator|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereIMMEDIATE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|bad
operator|&&
operator|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_kindANY
operator|)
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
operator|(
name|ffesymbol_sfdummyparent
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
operator|)
condition|?
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
else|:
name|FFESYMBOL_stateUNDERSTOOD
condition|)
block|{
case|case
name|FFESYMBOL_stateNONE
case|:
comment|/* Before first exec, not seen in expr 				   context. */
if|if
condition|(
operator|!
name|ffest_seen_first_exec
argument_list|()
condition|)
goto|goto
name|seen
goto|;
comment|/* :::::::::::::::::::: */
comment|/* Fall through. */
case|case
name|FFESYMBOL_stateUNCERTAIN
case|:
comment|/* Unseen since first exec. */
switch|switch
condition|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
condition|)
block|{
case|case
name|FFEEXPR_contextSUBROUTINEREF
case|:
name|s
operator|=
name|ffeexpr_sym_lhs_call_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextFILEEXTFUNC
case|:
name|s
operator|=
name|ffeexpr_sym_lhs_extfunc_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
name|s
operator|=
name|ffecom_sym_exec_transition
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNDERSTOOD
condition|)
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
comment|/* Fall through. */
case|case
name|FFEEXPR_contextACTUALARG_
case|:
name|s
operator|=
name|ffeexpr_sym_rhs_actualarg_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextDATA
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
name|s
operator|=
name|ffeexpr_sym_rhs_let_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|ffeexpr_sym_lhs_data_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
name|s
operator|=
name|ffeexpr_sym_lhs_data_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEF
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEX_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
case|:
name|s
operator|=
name|ffecom_sym_exec_transition
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNDERSTOOD
condition|)
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
comment|/* Fall through. */
case|case
name|FFEEXPR_contextLET
case|:
case|case
name|FFEEXPR_contextPAREN_
case|:
case|case
name|FFEEXPR_contextACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextASSIGN
case|:
case|case
name|FFEEXPR_contextIOLIST
case|:
case|case
name|FFEEXPR_contextIOLISTDF
case|:
case|case
name|FFEEXPR_contextDO
case|:
case|case
name|FFEEXPR_contextDOWHILE
case|:
case|case
name|FFEEXPR_contextAGOTO
case|:
case|case
name|FFEEXPR_contextCGOTO
case|:
case|case
name|FFEEXPR_contextIF
case|:
case|case
name|FFEEXPR_contextARITHIF
case|:
case|case
name|FFEEXPR_contextFORMAT
case|:
case|case
name|FFEEXPR_contextSTOP
case|:
case|case
name|FFEEXPR_contextRETURN
case|:
case|case
name|FFEEXPR_contextSELECTCASE
case|:
case|case
name|FFEEXPR_contextCASE
case|:
case|case
name|FFEEXPR_contextFILEASSOC
case|:
case|case
name|FFEEXPR_contextFILEINT
case|:
case|case
name|FFEEXPR_contextFILEDFINT
case|:
case|case
name|FFEEXPR_contextFILELOG
case|:
case|case
name|FFEEXPR_contextFILENUM
case|:
case|case
name|FFEEXPR_contextFILENUMAMBIG
case|:
case|case
name|FFEEXPR_contextFILECHAR
case|:
case|case
name|FFEEXPR_contextFILENUMCHAR
case|:
case|case
name|FFEEXPR_contextFILEDFCHAR
case|:
case|case
name|FFEEXPR_contextFILEKEY
case|:
case|case
name|FFEEXPR_contextFILEUNIT
case|:
case|case
name|FFEEXPR_contextFILEUNIT_DF
case|:
case|case
name|FFEEXPR_contextFILEUNITAMBIG
case|:
case|case
name|FFEEXPR_contextFILEFORMAT
case|:
case|case
name|FFEEXPR_contextFILENAMELIST
case|:
case|case
name|FFEEXPR_contextFILEVXTCODE
case|:
case|case
name|FFEEXPR_contextINDEX_
case|:
case|case
name|FFEEXPR_contextIMPDOITEM_
case|:
case|case
name|FFEEXPR_contextIMPDOITEMDF_
case|:
case|case
name|FFEEXPR_contextIMPDOCTRL_
case|:
case|case
name|FFEEXPR_contextLOC_
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
name|s
operator|=
name|ffeexpr_sym_rhs_let_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|ffeexpr_sym_lhs_let_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextCHARACTERSIZE
case|:
case|case
name|FFEEXPR_contextEQUIVALENCE
case|:
case|case
name|FFEEXPR_contextINCLUDE
case|:
case|case
name|FFEEXPR_contextPARAMETER
case|:
case|case
name|FFEEXPR_contextDIMLIST
case|:
case|case
name|FFEEXPR_contextDIMLISTCOMMON
case|:
case|case
name|FFEEXPR_contextKINDTYPE
case|:
case|case
name|FFEEXPR_contextINITVAL
case|:
case|case
name|FFEEXPR_contextEQVINDEX_
case|:
break|break;
comment|/* Will turn into errors below. */
default|default:
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
name|FFESYMBOL_stateUNDERSTOOD
case|:
comment|/* Nothing much more to learn. */
name|understood
label|:
comment|/* :::::::::::::::::::: */
name|k
operator|=
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
condition|)
block|{
case|case
name|FFEEXPR_contextSUBROUTINEREF
case|:
name|bad
operator|=
operator|(
operator|(
name|k
operator|!=
name|FFEINFO_kindSUBROUTINE
operator|)
operator|&&
operator|(
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereINTRINSIC
operator|)
operator|||
operator|(
name|k
operator|!=
name|FFEINFO_kindNONE
operator|)
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextFILEEXTFUNC
case|:
name|bad
operator|=
operator|(
name|k
operator|!=
name|FFEINFO_kindFUNCTION
operator|)
operator|||
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereGLOBAL
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
case|case
name|FFEEXPR_contextACTUALARG_
case|:
switch|switch
condition|(
name|k
condition|)
block|{
case|case
name|FFEINFO_kindENTITY
case|:
name|bad
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindFUNCTION
case|:
case|case
name|FFEINFO_kindSUBROUTINE
case|:
name|bad
operator|=
operator|(
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereGLOBAL
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereDUMMY
operator|)
operator|&&
operator|(
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereINTRINSIC
operator|)
operator|||
operator|!
name|ffeintrin_is_actualarg
argument_list|(
name|ffesymbol_specific
argument_list|(
name|s
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindNONE
case|:
if|if
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereINTRINSIC
condition|)
block|{
name|bad
operator|=
operator|!
operator|(
name|ffeintrin_is_actualarg
argument_list|(
name|ffesymbol_specific
argument_list|(
name|s
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
block|}
comment|/* If state is UNDERSTOOD here, it's CHAR*(*) or attrsANY, 		 and in the former case, attrsTYPE is set, so we 		 see this as an error as we should, since CHAR*(*) 		 cannot be actually referenced in a main/block data 		 program unit.  */
if|if
condition|(
operator|(
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
operator|&
operator|(
name|FFESYMBOL_attrsANY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
operator|==
name|FFESYMBOL_attrsEXTERNAL
condition|)
name|bad
operator|=
name|FALSE
expr_stmt|;
else|else
name|bad
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|bad
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEEXPR_contextDATA
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
name|bad
operator|=
operator|(
name|k
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
operator|)
expr_stmt|;
else|else
name|bad
operator|=
operator|(
name|k
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereNONE
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereLOCAL
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereCOMMON
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
name|bad
operator|=
name|TRUE
expr_stmt|;
comment|/* Unadorned item never valid. */
break|break;
case|case
name|FFEEXPR_contextSFUNCDEF
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEX_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextLET
case|:
case|case
name|FFEEXPR_contextPAREN_
case|:
case|case
name|FFEEXPR_contextACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextASSIGN
case|:
case|case
name|FFEEXPR_contextIOLIST
case|:
case|case
name|FFEEXPR_contextIOLISTDF
case|:
case|case
name|FFEEXPR_contextDO
case|:
case|case
name|FFEEXPR_contextDOWHILE
case|:
case|case
name|FFEEXPR_contextAGOTO
case|:
case|case
name|FFEEXPR_contextCGOTO
case|:
case|case
name|FFEEXPR_contextIF
case|:
case|case
name|FFEEXPR_contextARITHIF
case|:
case|case
name|FFEEXPR_contextFORMAT
case|:
case|case
name|FFEEXPR_contextSTOP
case|:
case|case
name|FFEEXPR_contextRETURN
case|:
case|case
name|FFEEXPR_contextSELECTCASE
case|:
case|case
name|FFEEXPR_contextCASE
case|:
case|case
name|FFEEXPR_contextFILEASSOC
case|:
case|case
name|FFEEXPR_contextFILEINT
case|:
case|case
name|FFEEXPR_contextFILEDFINT
case|:
case|case
name|FFEEXPR_contextFILELOG
case|:
case|case
name|FFEEXPR_contextFILENUM
case|:
case|case
name|FFEEXPR_contextFILENUMAMBIG
case|:
case|case
name|FFEEXPR_contextFILECHAR
case|:
case|case
name|FFEEXPR_contextFILENUMCHAR
case|:
case|case
name|FFEEXPR_contextFILEDFCHAR
case|:
case|case
name|FFEEXPR_contextFILEKEY
case|:
case|case
name|FFEEXPR_contextFILEUNIT
case|:
case|case
name|FFEEXPR_contextFILEUNIT_DF
case|:
case|case
name|FFEEXPR_contextFILEUNITAMBIG
case|:
case|case
name|FFEEXPR_contextFILEFORMAT
case|:
case|case
name|FFEEXPR_contextFILENAMELIST
case|:
case|case
name|FFEEXPR_contextFILEVXTCODE
case|:
case|case
name|FFEEXPR_contextINDEX_
case|:
case|case
name|FFEEXPR_contextIMPDOITEM_
case|:
case|case
name|FFEEXPR_contextIMPDOITEMDF_
case|:
case|case
name|FFEEXPR_contextIMPDOCTRL_
case|:
case|case
name|FFEEXPR_contextLOC_
case|:
name|bad
operator|=
operator|(
name|k
operator|!=
name|FFEINFO_kindENTITY
operator|)
expr_stmt|;
comment|/* This catches "SUBROUTINE 						   X(A);EXTERNAL A;CALL 						   Y(A);B=A", for example. */
break|break;
case|case
name|FFEEXPR_contextCHARACTERSIZE
case|:
case|case
name|FFEEXPR_contextEQUIVALENCE
case|:
case|case
name|FFEEXPR_contextPARAMETER
case|:
case|case
name|FFEEXPR_contextDIMLIST
case|:
case|case
name|FFEEXPR_contextDIMLISTCOMMON
case|:
case|case
name|FFEEXPR_contextKINDTYPE
case|:
case|case
name|FFEEXPR_contextINITVAL
case|:
case|case
name|FFEEXPR_contextEQVINDEX_
case|:
name|bad
operator|=
operator|(
name|k
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextINCLUDE
case|:
name|bad
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|bad
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bad
operator|&&
operator|(
name|k
operator|!=
name|FFEINFO_kindANY
operator|)
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
case|case
name|FFESYMBOL_stateSEEN
case|:
comment|/* Seen but not yet in exec portion. */
name|seen
label|:
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
condition|)
block|{
case|case
name|FFEEXPR_contextPARAMETER
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|ffeexpr_sym_lhs_parameter_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextDATA
case|:
name|s
operator|=
name|ffecom_sym_exec_transition
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNDERSTOOD
condition|)
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|ffeexpr_sym_lhs_data_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
name|s
operator|=
name|ffecom_sym_exec_transition
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNDERSTOOD
condition|)
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
name|s
operator|=
name|ffeexpr_sym_lhs_data_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEEXPR_contextEQUIVALENCE
case|:
name|s
operator|=
name|ffeexpr_sym_lhs_equivalence_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextDIMLIST
case|:
name|s
operator|=
name|ffeexpr_sym_rhs_dimlist_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextCHARACTERSIZE
case|:
case|case
name|FFEEXPR_contextKINDTYPE
case|:
case|case
name|FFEEXPR_contextDIMLISTCOMMON
case|:
case|case
name|FFEEXPR_contextINITVAL
case|:
case|case
name|FFEEXPR_contextEQVINDEX_
case|:
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextINCLUDE
case|:
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextACTUALARG_
case|:
comment|/* E.g. I in REAL A(Y(I)). */
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
name|s
operator|=
name|ffecom_sym_exec_transition
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNDERSTOOD
condition|)
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
name|s
operator|=
name|ffeexpr_sym_rhs_actualarg_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEEXPR_contextINDEX_
case|:
case|case
name|FFEEXPR_contextACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextSFUNCDEF
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEX_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
case|:
name|assert
argument_list|(
name|ffeexpr_stack_
operator|->
name|is_rhs
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_exec_transition
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNDERSTOOD
condition|)
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
name|s
operator|=
name|ffeexpr_sym_rhs_let_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
default|default:
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|s
return|;
default|default:
name|assert
argument_list|(
literal|"bad symbol state"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Have FOO in DATA (XYZ(FOO),...)/.../ or DATA (...,XYZ=FOO,BAR,BLETCH).    Could be found via the "statement-function" name space (in which case    it should become an iterator) or the local name space (in which case    it should be either a named constant, or a variable that will have an    sfunc name space sibling that should become an iterator).  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffeexpr_sym_impdoitem_
parameter_list|(
name|ffesymbol
name|sp
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffesymbolState
name|ss
decl_stmt|;
name|ffesymbolState
name|ns
decl_stmt|;
name|ffeinfoKind
name|kind
decl_stmt|;
name|ffeinfoWhere
name|where
decl_stmt|;
name|ss
operator|=
name|ffesymbol_state
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_sfdummyparent
argument_list|(
name|sp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Have symbol in sfunc name space. */
switch|switch
condition|(
name|ss
condition|)
block|{
case|case
name|FFESYMBOL_stateNONE
case|:
comment|/* Used as iterator already. */
if|if
condition|(
name|ffeexpr_level_
operator|<
name|ffesymbol_maxentrynum
argument_list|(
name|sp
argument_list|)
condition|)
name|ffesymbol_error
argument_list|(
name|sp
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Can't use dead iterator. */
else|else
block|{
comment|/* Can use dead iterator because we're at at 				   least an innermore (higher-numbered) level 				   than the iterator's outermost 				   (lowest-numbered) level. */
name|ffesymbol_signal_change
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|sp
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
name|ffesymbol_set_maxentrynum
argument_list|(
name|sp
argument_list|,
name|ffeexpr_level_
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FFESYMBOL_stateSEEN
case|:
comment|/* Seen already in this or other 					   implied-DO.  Set symbol level 					   number to outermost value, as that 					   tells us we can see it as iterator 					   at that level at the innermost. */
if|if
condition|(
name|ffeexpr_level_
operator|<
name|ffesymbol_maxentrynum
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ffesymbol_set_maxentrynum
argument_list|(
name|sp
argument_list|,
name|ffeexpr_level_
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FFESYMBOL_stateUNCERTAIN
case|:
comment|/* Iterator. */
name|assert
argument_list|(
name|ffeexpr_level_
operator|==
name|ffesymbol_maxentrynum
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_error
argument_list|(
name|sp
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* (,,,I=I,10). */
break|break;
case|case
name|FFESYMBOL_stateUNDERSTOOD
case|:
break|break;
comment|/* ANY. */
default|default:
name|assert
argument_list|(
literal|"Foo Bar!!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|sp
return|;
block|}
comment|/* Got symbol in local name space, so we haven't seen it in impdo yet.      First, if it is brand-new and we're in executable statements, set the      attributes and exec-transition it to set state UNCERTAIN or UNDERSTOOD.      Second, if it is now a constant (PARAMETER), then just return it, it      can't be an implied-do iterator.  If it is understood, complain if it is      not a valid variable, but make the inner name space iterator anyway and      return that.  If it is not understood, improve understanding of the      symbol accordingly, complain accordingly, in either case make the inner      name space iterator and return that.  */
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state_is_specable
argument_list|(
name|ss
argument_list|)
operator|&&
name|ffest_seen_first_exec
argument_list|()
condition|)
block|{
name|assert
argument_list|(
name|sa
operator|==
name|FFESYMBOL_attrsetNONE
argument_list|)
expr_stmt|;
name|ffesymbol_signal_change
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|sp
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffeimplic_establish_symbol
argument_list|(
name|sp
argument_list|)
condition|)
name|ffesymbol_set_attr
argument_list|(
name|sp
argument_list|,
name|FFESYMBOL_attrSFARG
argument_list|)
expr_stmt|;
else|else
name|ffesymbol_error
argument_list|(
name|sp
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* After the exec transition, the state will either be UNCERTAIN (could 	 be a dummy or local var) or UNDERSTOOD (local var, because this is a 	 PROGRAM/BLOCKDATA program unit).  */
name|sp
operator|=
name|ffecom_sym_exec_transition
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ss
operator|=
name|ffesymbol_state
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
name|ns
operator|=
name|ss
expr_stmt|;
name|kind
operator|=
name|ffesymbol_kind
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|where
operator|=
name|ffesymbol_where
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|FFESYMBOL_stateUNDERSTOOD
condition|)
block|{
if|if
condition|(
name|kind
operator|!=
name|FFEINFO_kindENTITY
condition|)
name|ffesymbol_error
argument_list|(
name|sp
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
operator|==
name|FFEINFO_whereCONSTANT
condition|)
return|return
name|sp
return|;
block|}
else|else
block|{
comment|/* Enhance understanding of local symbol.  This used to imply exec 	 transition, but that doesn't seem necessary, since the local symbol 	 doesn't actually get put into an ffebld tree here -- we just learn 	 more about it, just like when we see a local symbol's name in the 	 dummy-arg list of a statement function.  */
if|if
condition|(
name|ss
operator|!=
name|FFESYMBOL_stateUNCERTAIN
condition|)
block|{
comment|/* Figure out what kind of object we've got based on previous 	     declarations of or references to the object. */
name|ns
operator|=
name|FFESYMBOL_stateSEEN
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|na
operator|=
name|sa
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsANY
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsRESULT
operator||
name|FFESYMBOL_attrsSAVE
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
condition|)
name|na
operator|=
name|sa
operator||
name|FFESYMBOL_attrsSFARG
expr_stmt|;
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
block|}
else|else
block|{
comment|/* stateUNCERTAIN. */
name|na
operator|=
name|sa
operator||
name|FFESYMBOL_attrsSFARG
expr_stmt|;
name|ns
operator|=
name|FFESYMBOL_stateUNDERSTOOD
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsARRAY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsSFARG
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsTYPE
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
if|if
condition|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
elseif|else
if|if
condition|(
name|ffest_is_entry_valid
argument_list|()
condition|)
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
comment|/* Could be DUMMY or LOCAL. */
else|else
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Error. */
block|}
comment|/* Now see what we've got for a new object: NONE means a new error 	 cropped up; ANY means an old error to be ignored; otherwise, 	 everything's ok, update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
name|ffesymbol_error
argument_list|(
name|sp
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* May need to back up to previous 					   version. */
if|if
condition|(
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|sp
argument_list|)
condition|)
name|ffesymbol_error
argument_list|(
name|sp
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|ffesymbol_set_info
argument_list|(
name|sp
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|sp
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|sp
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|sp
argument_list|)
argument_list|,
name|kind
argument_list|,
name|where
argument_list|,
name|ffesymbol_size
argument_list|(
name|sp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_attrs
argument_list|(
name|sp
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|sp
argument_list|,
name|ns
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffesymbol_state_is_specable
argument_list|(
name|ns
argument_list|)
condition|)
name|sp
operator|=
name|ffecom_sym_learned
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
block|}
block|}
block|}
comment|/* Here we create the sfunc-name-space symbol representing what should      become an iterator in this name space at this or an outermore (lower-      numbered) expression level, else the implied-DO construct is in error.  */
name|s
operator|=
name|ffesymbol_declare_sfdummy
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Sets maxentrynum to 0 for new obj; 					   also sets sfa_dummy_parent to 					   parent symbol. */
name|assert
argument_list|(
name|sp
operator|==
name|ffesymbol_sfdummyparent
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
name|ffesymbol_set_maxentrynum
argument_list|(
name|s
argument_list|,
name|ffeexpr_level_
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereIMMEDIATE
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ffesymbol_basictype
argument_list|(
name|sp
argument_list|)
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|&&
operator|(
name|ffesymbol_basictype
argument_list|(
name|sp
argument_list|)
operator|!=
name|FFEINFO_basictypeANY
operator|)
operator|)
operator|||
operator|(
operator|(
name|ffesymbol_kindtype
argument_list|(
name|sp
argument_list|)
operator|!=
name|FFEINFO_kindtypeINTEGERDEFAULT
operator|)
operator|&&
operator|(
name|ffesymbol_kindtype
argument_list|(
name|sp
argument_list|)
operator|!=
name|FFEINFO_kindtypeANY
operator|)
operator|)
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Have FOO in CALL FOO.  Local name space, executable context only.  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffeexpr_sym_lhs_call_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffeinfoKind
name|kind
decl_stmt|;
name|ffeinfoWhere
name|where
decl_stmt|;
name|ffeintrinGen
name|gen
decl_stmt|;
name|ffeintrinSpec
name|spec
decl_stmt|;
name|ffeintrinImp
name|imp
decl_stmt|;
name|bool
name|error
init|=
name|FALSE
decl_stmt|;
name|assert
argument_list|(
operator|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
operator|)
operator|||
operator|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNCERTAIN
operator|)
argument_list|)
expr_stmt|;
name|na
operator|=
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|where
operator|=
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
else|else
comment|/* Not TYPE. */
block|{
name|kind
operator|=
name|FFEINFO_kindSUBROUTINE
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
empty_stmt|;
comment|/* Not TYPE. */
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsACTUALARG
condition|)
empty_stmt|;
comment|/* Not DUMMY or TYPE. */
else|else
comment|/* Not ACTUALARG, DUMMY, or TYPE. */
name|where
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
else|else
name|kind
operator|=
name|FFEINFO_kindSUBROUTINE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsARRAY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsSFARG
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsTYPE
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
block|{
name|assert
argument_list|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffeintrin_is_intrinsic
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|,
operator|&
name|gen
argument_list|,
operator|&
name|spec
argument_list|,
operator|&
name|imp
argument_list|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* May need to back up to previous 					   version. */
name|ffesymbol_set_generic
argument_list|(
name|s
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|ffesymbol_set_specific
argument_list|(
name|s
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|ffesymbol_set_implementation
argument_list|(
name|s
argument_list|,
name|imp
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindSUBROUTINE
argument_list|,
name|FFEINFO_whereINTRINSIC
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
return|return
name|s
return|;
block|}
name|kind
operator|=
name|FFEINFO_kindSUBROUTINE
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
block|}
else|else
name|error
operator|=
name|TRUE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|error
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* May need to back up to previous 					   version. */
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
name|kind
argument_list|,
comment|/* SUBROUTINE. */
name|where
argument_list|,
comment|/* GLOBAL or DUMMY. */
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Have FOO in DATA FOO/.../.  Local name space and executable context    only.  (This will change in the future when DATA FOO may be followed    by COMMON FOO or even INTEGER FOO(10), etc.)  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffeexpr_sym_lhs_data_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffeinfoKind
name|kind
decl_stmt|;
name|ffeinfoWhere
name|where
decl_stmt|;
name|bool
name|error
init|=
name|FALSE
decl_stmt|;
name|assert
argument_list|(
operator|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
operator|)
operator|||
operator|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNCERTAIN
operator|)
argument_list|)
expr_stmt|;
name|na
operator|=
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|where
operator|=
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsARRAY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsADJUSTABLE
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsSFARG
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsTYPE
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|kind
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
block|{
name|assert
argument_list|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
argument_list|)
expr_stmt|;
name|kind
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
else|else
name|error
operator|=
name|TRUE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|error
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* May need to back up to previous 					   version. */
if|if
condition|(
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
name|kind
argument_list|,
comment|/* ENTITY. */
name|where
argument_list|,
comment|/* LOCAL. */
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Have FOO in EQUIVALENCE (...,FOO,...).  Does not include    EQUIVALENCE (...,BAR(FOO),...).  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffeexpr_sym_lhs_equivalence_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffeinfoKind
name|kind
decl_stmt|;
name|ffeinfoWhere
name|where
decl_stmt|;
name|na
operator|=
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|kind
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|where
operator|=
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsSAVE
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
condition|)
name|na
operator|=
name|sa
operator||
name|FFESYMBOL_attrsEQUIV
expr_stmt|;
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Don't know why we're bothering to set kind and where in this code, but      added the following to make it complete, in case it's really important.      Generally this is left up to symbol exec transition.  */
if|if
condition|(
name|where
operator|==
name|FFEINFO_whereNONE
condition|)
block|{
if|if
condition|(
name|na
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsCOMMON
operator|)
condition|)
name|where
operator|=
name|FFEINFO_whereCOMMON
expr_stmt|;
elseif|else
if|if
condition|(
name|na
operator|&
name|FFESYMBOL_attrsSAVE
condition|)
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* May need to back up to previous 					   version. */
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
name|kind
argument_list|,
comment|/* Always ENTITY. */
name|where
argument_list|,
comment|/* NONE, COMMON, or LOCAL. */
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Have FOO in OPEN(...,USEROPEN=FOO,...).  Executable context only.     Note that I think this should be considered semantically similar to    doing CALL XYZ(FOO), in that it should be considered like an    ACTUALARG context.  In particular, without EXTERNAL being specified,    it should not be allowed.  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffeexpr_sym_lhs_extfunc_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffeinfoKind
name|kind
decl_stmt|;
name|ffeinfoWhere
name|where
decl_stmt|;
name|bool
name|needs_type
init|=
name|FALSE
decl_stmt|;
name|bool
name|error
init|=
name|FALSE
decl_stmt|;
name|assert
argument_list|(
operator|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
operator|)
operator|||
operator|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNCERTAIN
operator|)
argument_list|)
expr_stmt|;
name|na
operator|=
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|where
operator|=
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
name|where
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
else|else
comment|/* Not TYPE. */
block|{
name|kind
operator|=
name|FFEINFO_kindFUNCTION
expr_stmt|;
name|needs_type
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
empty_stmt|;
comment|/* Not TYPE. */
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsACTUALARG
condition|)
empty_stmt|;
comment|/* Not DUMMY or TYPE. */
else|else
comment|/* Not ACTUALARG, DUMMY, or TYPE. */
name|where
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|FFEINFO_kindFUNCTION
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
operator|)
condition|)
name|needs_type
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsARRAY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsSFARG
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsTYPE
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|kind
operator|=
name|FFEINFO_kindFUNCTION
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
block|{
name|assert
argument_list|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
argument_list|)
expr_stmt|;
name|kind
operator|=
name|FFEINFO_kindFUNCTION
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
name|needs_type
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|error
operator|=
name|TRUE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|error
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* May need to back up to previous 					   version. */
if|if
condition|(
name|needs_type
operator|&&
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
operator|!
name|ffesymbol_explicitwhere
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_NEED_EXTERNAL
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffesymbol_set_explicitwhere
argument_list|(
name|s
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
name|kind
argument_list|,
comment|/* FUNCTION. */
name|where
argument_list|,
comment|/* GLOBAL or DUMMY. */
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Have FOO in DATA (stuff,FOO=1,10)/.../.  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffeexpr_sym_lhs_impdoctrl_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbolState
name|ss
decl_stmt|;
comment|/* If the symbol isn't in the sfunc name space, pretend as though we saw a      reference to it already within the imp-DO construct at this level, so as      to get a symbol that is in the sfunc name space. But this is an      erroneous construct, and should be caught elsewhere.  */
if|if
condition|(
name|ffesymbol_sfdummyparent
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|ffeexpr_sym_impdoitem_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_sfdummyparent
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* PARAMETER FOO...DATA (A(I),FOO=...). */
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
name|ss
operator|=
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ss
condition|)
block|{
case|case
name|FFESYMBOL_stateNONE
case|:
comment|/* Used as iterator already. */
if|if
condition|(
name|ffeexpr_level_
operator|<
name|ffesymbol_maxentrynum
argument_list|(
name|s
argument_list|)
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Can't reuse dead iterator.  F90 disallows 				   this; F77 allows it but it is a stupid 				   feature. */
else|else
block|{
comment|/* Can use dead iterator because we're at at 				   least a innermore (higher-numbered) level 				   than the iterator's outermost 				   (lowest-numbered) level.  This should be 				   diagnosed later, because it means an item 				   in this list didn't reference this 				   iterator. */
if|#
directive|if
literal|1
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* For now, complain. */
else|#
directive|else
comment|/* Someday will detect all cases where initializer doesn't reference 	 all applicable iterators, in which case reenable this code. */
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNCERTAIN
argument_list|)
expr_stmt|;
name|ffesymbol_set_maxentrynum
argument_list|(
name|s
argument_list|,
name|ffeexpr_level_
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
name|FFESYMBOL_stateSEEN
case|:
comment|/* Seen already in this or other implied-DO. 				   If seen in outermore level, can't be an 				   iterator here, so complain.  If not seen 				   at current level, complain for now, 				   because that indicates something F90 				   rejects (though we currently don't detect 				   all such cases for now). */
if|if
condition|(
name|ffeexpr_level_
operator|<=
name|ffesymbol_maxentrynum
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNCERTAIN
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESYMBOL_stateUNCERTAIN
case|:
comment|/* Already iterator! */
name|assert
argument_list|(
literal|"DATA implied-DO control var seen twice!!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESYMBOL_stateUNDERSTOOD
case|:
break|break;
comment|/* ANY. */
default|default:
name|assert
argument_list|(
literal|"Foo Bletch!!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Have FOO in PARAMETER (FOO=...).  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffeexpr_sym_lhs_parameter_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsTYPE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* May need to back up to previous 					   version. */
if|if
condition|(
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Have FOO in CALL XYZ(...,FOO,...).  Does not include any other    embedding of FOO, such as CALL XYZ((FOO)) or CALL XYZ(FOO+1).  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffeexpr_sym_rhs_actualarg_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffeinfoKind
name|kind
decl_stmt|;
name|ffeinfoWhere
name|where
decl_stmt|;
name|ffesymbolState
name|ns
decl_stmt|;
name|bool
name|needs_type
init|=
name|FALSE
decl_stmt|;
name|assert
argument_list|(
operator|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
operator|)
operator|||
operator|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNCERTAIN
operator|)
argument_list|)
expr_stmt|;
name|na
operator|=
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|where
operator|=
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
name|ns
operator|=
name|FFESYMBOL_stateUNDERSTOOD
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
name|where
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
else|else
comment|/* Not TYPE. */
block|{
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
name|assert
argument_list|(
name|kind
operator|==
name|FFEINFO_kindNONE
argument_list|)
expr_stmt|;
comment|/* FUNCTION, SUBROUTINE. */
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsACTUALARG
condition|)
empty_stmt|;
comment|/* Not DUMMY or TYPE. */
else|else
comment|/* Not ACTUALARG, DUMMY, or TYPE. */
block|{
name|assert
argument_list|(
name|kind
operator|==
name|FFEINFO_kindNONE
argument_list|)
expr_stmt|;
comment|/* FUNCTION, SUBROUTINE. */
name|na
operator||=
name|FFESYMBOL_attrsACTUALARG
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
operator|)
condition|)
name|needs_type
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsARRAY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsSFARG
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsTYPE
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANYLEN
condition|)
name|ns
operator|=
name|FFESYMBOL_stateNONE
expr_stmt|;
else|else
block|{
name|kind
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
block|{
comment|/* New state is left empty because there isn't any state flag to 	 set for this case, and it's UNDERSTOOD after all.  */
name|assert
argument_list|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
argument_list|)
expr_stmt|;
name|kind
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
name|needs_type
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|ns
operator|=
name|FFESYMBOL_stateNONE
expr_stmt|;
comment|/* Error. */
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|ns
operator|==
name|FFESYMBOL_stateNONE
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* May need to back up to previous 					   version. */
if|if
condition|(
name|needs_type
operator|&&
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
name|kind
argument_list|,
name|where
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|ns
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Have FOO in DIMENSION XYZ(FOO) or any array declarator containing    a reference to FOO.  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffeexpr_sym_rhs_dimlist_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffeinfoKind
name|kind
decl_stmt|;
name|ffeinfoWhere
name|where
decl_stmt|;
name|na
operator|=
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|kind
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|where
operator|=
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
condition|)
name|na
operator|=
name|sa
operator||
name|FFESYMBOL_attrsADJUSTS
expr_stmt|;
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Since this symbol definitely is going into an expression (the      dimension-list for some dummy array, presumably), figure out WHERE if      possible.  */
if|if
condition|(
name|where
operator|==
name|FFEINFO_whereNONE
condition|)
block|{
if|if
condition|(
name|na
operator|&
operator|(
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator|)
condition|)
name|where
operator|=
name|FFEINFO_whereCOMMON
expr_stmt|;
elseif|else
if|if
condition|(
name|na
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
name|where
operator|=
name|FFEINFO_whereDUMMY
expr_stmt|;
block|}
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* May need to back up to previous 					   version. */
if|if
condition|(
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
name|kind
argument_list|,
comment|/* Always ENTITY. */
name|where
argument_list|,
comment|/* NONE, COMMON, or DUMMY. */
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Have FOO in XYZ = ...FOO....  Does not include cases like FOO in    XYZ = BAR(FOO), as such cases are handled elsewhere.  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffeexpr_sym_rhs_let_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffeinfoKind
name|kind
decl_stmt|;
name|ffeinfoWhere
name|where
decl_stmt|;
name|bool
name|error
init|=
name|FALSE
decl_stmt|;
name|assert
argument_list|(
operator|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
operator|)
operator|||
operator|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNCERTAIN
operator|)
argument_list|)
expr_stmt|;
name|na
operator|=
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|where
operator|=
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsARRAY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsSFARG
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsTYPE
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANYLEN
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|kind
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
block|{
name|assert
argument_list|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
argument_list|)
expr_stmt|;
name|kind
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
else|else
name|error
operator|=
name|TRUE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|error
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* May need to back up to previous 					   version. */
if|if
condition|(
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
name|kind
argument_list|,
comment|/* ENTITY. */
name|where
argument_list|,
comment|/* LOCAL. */
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_declare_parenthesized_ -- ffesymbol wrapper for NAME(...) operand     ffelexToken t;    bool maybe_intrin;    ffeexprParenType_ paren_type;    ffesymbol s;    s = ffeexpr_declare_parenthesized_ (t, maybe_intrin,&paren_type);     Just like ffesymbol_declare_local, except performs any implicit info    assignment necessary, and it returns the type of the parenthesized list    (list of function args, list of array args, or substring spec).  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffeexpr_declare_parenthesized_
parameter_list|(
name|ffelexToken
name|t
parameter_list|,
name|bool
name|maybe_intrin
parameter_list|,
name|ffeexprParenType_
modifier|*
name|paren_type
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbolState
name|st
decl_stmt|;
comment|/* Effective state. */
name|ffeinfoKind
name|k
decl_stmt|;
name|bool
name|bad
decl_stmt|;
if|if
condition|(
name|maybe_intrin
operator|&&
name|ffesrc_check_symbol
argument_list|()
condition|)
block|{
comment|/* Knock off some easy cases. */
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextSUBROUTINEREF
case|:
case|case
name|FFEEXPR_contextDATA
case|:
case|case
name|FFEEXPR_contextDATAIMPDOINDEX_
case|:
case|case
name|FFEEXPR_contextSFUNCDEF
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEX_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextLET
case|:
case|case
name|FFEEXPR_contextPAREN_
case|:
case|case
name|FFEEXPR_contextACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextIOLIST
case|:
case|case
name|FFEEXPR_contextIOLISTDF
case|:
case|case
name|FFEEXPR_contextDO
case|:
case|case
name|FFEEXPR_contextDOWHILE
case|:
case|case
name|FFEEXPR_contextACTUALARG_
case|:
case|case
name|FFEEXPR_contextCGOTO
case|:
case|case
name|FFEEXPR_contextIF
case|:
case|case
name|FFEEXPR_contextARITHIF
case|:
case|case
name|FFEEXPR_contextFORMAT
case|:
case|case
name|FFEEXPR_contextSTOP
case|:
case|case
name|FFEEXPR_contextRETURN
case|:
case|case
name|FFEEXPR_contextSELECTCASE
case|:
case|case
name|FFEEXPR_contextCASE
case|:
case|case
name|FFEEXPR_contextFILEASSOC
case|:
case|case
name|FFEEXPR_contextFILEINT
case|:
case|case
name|FFEEXPR_contextFILEDFINT
case|:
case|case
name|FFEEXPR_contextFILELOG
case|:
case|case
name|FFEEXPR_contextFILENUM
case|:
case|case
name|FFEEXPR_contextFILENUMAMBIG
case|:
case|case
name|FFEEXPR_contextFILECHAR
case|:
case|case
name|FFEEXPR_contextFILENUMCHAR
case|:
case|case
name|FFEEXPR_contextFILEDFCHAR
case|:
case|case
name|FFEEXPR_contextFILEKEY
case|:
case|case
name|FFEEXPR_contextFILEUNIT
case|:
case|case
name|FFEEXPR_contextFILEUNIT_DF
case|:
case|case
name|FFEEXPR_contextFILEUNITAMBIG
case|:
case|case
name|FFEEXPR_contextFILEFORMAT
case|:
case|case
name|FFEEXPR_contextFILENAMELIST
case|:
case|case
name|FFEEXPR_contextFILEVXTCODE
case|:
case|case
name|FFEEXPR_contextINDEX_
case|:
case|case
name|FFEEXPR_contextIMPDOITEM_
case|:
case|case
name|FFEEXPR_contextIMPDOITEMDF_
case|:
case|case
name|FFEEXPR_contextIMPDOCTRL_
case|:
case|case
name|FFEEXPR_contextDATAIMPDOCTRL_
case|:
case|case
name|FFEEXPR_contextCHARACTERSIZE
case|:
case|case
name|FFEEXPR_contextPARAMETER
case|:
case|case
name|FFEEXPR_contextDIMLIST
case|:
case|case
name|FFEEXPR_contextDIMLISTCOMMON
case|:
case|case
name|FFEEXPR_contextKINDTYPE
case|:
case|case
name|FFEEXPR_contextINITVAL
case|:
case|case
name|FFEEXPR_contextEQVINDEX_
case|:
break|break;
comment|/* These could be intrinsic invocations. */
case|case
name|FFEEXPR_contextAGOTO
case|:
case|case
name|FFEEXPR_contextFILEFORMATNML
case|:
case|case
name|FFEEXPR_contextALLOCATE
case|:
case|case
name|FFEEXPR_contextDEALLOCATE
case|:
case|case
name|FFEEXPR_contextHEAPSTAT
case|:
case|case
name|FFEEXPR_contextNULLIFY
case|:
case|case
name|FFEEXPR_contextINCLUDE
case|:
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
case|case
name|FFEEXPR_contextLOC_
case|:
case|case
name|FFEEXPR_contextINDEXORACTUALARG_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
case|case
name|FFEEXPR_contextPARENFILENUM_
case|:
case|case
name|FFEEXPR_contextPARENFILEUNIT_
case|:
name|maybe_intrin
operator|=
name|FALSE
expr_stmt|;
break|break;
comment|/* Can't be intrinsic invocation. */
default|default:
name|assert
argument_list|(
literal|"blah! blah! waaauuggh!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|t
argument_list|,
name|maybe_intrin
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
condition|)
comment|/* Special-case these since they can involve a different concept        of "state" (in the stmtfunc name space).  */
block|{
case|case
name|FFEEXPR_contextDATAIMPDOINDEX_
case|:
case|case
name|FFEEXPR_contextDATAIMPDOCTRL_
case|:
if|if
condition|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
operator|==
name|FFEEXPR_contextDATAIMPDOINDEX_
condition|)
name|s
operator|=
name|ffeexpr_sym_impdoitem_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
name|s
operator|=
name|ffeexpr_sym_impdoitem_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|ffeexpr_sym_lhs_impdoctrl_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_kindANY
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
operator|(
name|ffesymbol_sfdummyparent
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
operator|)
condition|?
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
else|:
name|FFESYMBOL_stateUNDERSTOOD
condition|)
block|{
case|case
name|FFESYMBOL_stateNONE
case|:
comment|/* Before first exec, not seen in expr 				   context. */
if|if
condition|(
operator|!
name|ffest_seen_first_exec
argument_list|()
condition|)
goto|goto
name|seen
goto|;
comment|/* :::::::::::::::::::: */
comment|/* Fall through. */
case|case
name|FFESYMBOL_stateUNCERTAIN
case|:
comment|/* Unseen since first exec. */
switch|switch
condition|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
condition|)
block|{
case|case
name|FFEEXPR_contextSUBROUTINEREF
case|:
name|s
operator|=
name|ffeexpr_sym_lhs_call_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* "CALL FOO"=="CALL 						   FOO(...)". */
break|break;
case|case
name|FFEEXPR_contextDATA
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
name|s
operator|=
name|ffeexpr_sym_rhs_let_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|ffeexpr_sym_lhs_data_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
name|s
operator|=
name|ffeexpr_sym_lhs_data_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEF
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEX_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
case|:
name|s
operator|=
name|ffecom_sym_exec_transition
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNDERSTOOD
condition|)
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
comment|/* Fall through. */
case|case
name|FFEEXPR_contextLET
case|:
case|case
name|FFEEXPR_contextPAREN_
case|:
case|case
name|FFEEXPR_contextACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextIOLIST
case|:
case|case
name|FFEEXPR_contextIOLISTDF
case|:
case|case
name|FFEEXPR_contextDO
case|:
case|case
name|FFEEXPR_contextDOWHILE
case|:
case|case
name|FFEEXPR_contextACTUALARG_
case|:
case|case
name|FFEEXPR_contextCGOTO
case|:
case|case
name|FFEEXPR_contextIF
case|:
case|case
name|FFEEXPR_contextARITHIF
case|:
case|case
name|FFEEXPR_contextFORMAT
case|:
case|case
name|FFEEXPR_contextSTOP
case|:
case|case
name|FFEEXPR_contextRETURN
case|:
case|case
name|FFEEXPR_contextSELECTCASE
case|:
case|case
name|FFEEXPR_contextCASE
case|:
case|case
name|FFEEXPR_contextFILEASSOC
case|:
case|case
name|FFEEXPR_contextFILEINT
case|:
case|case
name|FFEEXPR_contextFILEDFINT
case|:
case|case
name|FFEEXPR_contextFILELOG
case|:
case|case
name|FFEEXPR_contextFILENUM
case|:
case|case
name|FFEEXPR_contextFILENUMAMBIG
case|:
case|case
name|FFEEXPR_contextFILECHAR
case|:
case|case
name|FFEEXPR_contextFILENUMCHAR
case|:
case|case
name|FFEEXPR_contextFILEDFCHAR
case|:
case|case
name|FFEEXPR_contextFILEKEY
case|:
case|case
name|FFEEXPR_contextFILEUNIT
case|:
case|case
name|FFEEXPR_contextFILEUNIT_DF
case|:
case|case
name|FFEEXPR_contextFILEUNITAMBIG
case|:
case|case
name|FFEEXPR_contextFILEFORMAT
case|:
case|case
name|FFEEXPR_contextFILENAMELIST
case|:
case|case
name|FFEEXPR_contextFILEVXTCODE
case|:
case|case
name|FFEEXPR_contextINDEX_
case|:
case|case
name|FFEEXPR_contextIMPDOITEM_
case|:
case|case
name|FFEEXPR_contextIMPDOITEMDF_
case|:
case|case
name|FFEEXPR_contextIMPDOCTRL_
case|:
case|case
name|FFEEXPR_contextLOC_
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
name|s
operator|=
name|ffeexpr_paren_rhs_let_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|ffeexpr_paren_lhs_let_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextASSIGN
case|:
case|case
name|FFEEXPR_contextAGOTO
case|:
case|case
name|FFEEXPR_contextCHARACTERSIZE
case|:
case|case
name|FFEEXPR_contextEQUIVALENCE
case|:
case|case
name|FFEEXPR_contextINCLUDE
case|:
case|case
name|FFEEXPR_contextPARAMETER
case|:
case|case
name|FFEEXPR_contextDIMLIST
case|:
case|case
name|FFEEXPR_contextDIMLISTCOMMON
case|:
case|case
name|FFEEXPR_contextKINDTYPE
case|:
case|case
name|FFEEXPR_contextINITVAL
case|:
case|case
name|FFEEXPR_contextEQVINDEX_
case|:
break|break;
comment|/* Will turn into errors below. */
default|default:
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
name|FFESYMBOL_stateUNDERSTOOD
case|:
comment|/* Nothing much more to learn. */
name|understood
label|:
comment|/* :::::::::::::::::::: */
comment|/* State might have changed, update it.  */
name|st
operator|=
operator|(
operator|(
name|ffesymbol_sfdummyparent
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
operator|)
condition|?
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
else|:
name|FFESYMBOL_stateUNDERSTOOD
operator|)
expr_stmt|;
name|k
operator|=
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
condition|)
block|{
case|case
name|FFEEXPR_contextSUBROUTINEREF
case|:
name|bad
operator|=
operator|(
operator|(
name|k
operator|!=
name|FFEINFO_kindSUBROUTINE
operator|)
operator|&&
operator|(
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereINTRINSIC
operator|)
operator|||
operator|(
name|k
operator|!=
name|FFEINFO_kindNONE
operator|)
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextDATA
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
name|bad
operator|=
operator|(
name|k
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
operator|)
expr_stmt|;
else|else
name|bad
operator|=
operator|(
name|k
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereNONE
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereLOCAL
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereCOMMON
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
name|bad
operator|=
operator|(
name|k
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereNONE
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereLOCAL
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereCOMMON
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEF
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEX_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextLET
case|:
case|case
name|FFEEXPR_contextPAREN_
case|:
case|case
name|FFEEXPR_contextACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextIOLIST
case|:
case|case
name|FFEEXPR_contextIOLISTDF
case|:
case|case
name|FFEEXPR_contextDO
case|:
case|case
name|FFEEXPR_contextDOWHILE
case|:
case|case
name|FFEEXPR_contextACTUALARG_
case|:
case|case
name|FFEEXPR_contextCGOTO
case|:
case|case
name|FFEEXPR_contextIF
case|:
case|case
name|FFEEXPR_contextARITHIF
case|:
case|case
name|FFEEXPR_contextFORMAT
case|:
case|case
name|FFEEXPR_contextSTOP
case|:
case|case
name|FFEEXPR_contextRETURN
case|:
case|case
name|FFEEXPR_contextSELECTCASE
case|:
case|case
name|FFEEXPR_contextCASE
case|:
case|case
name|FFEEXPR_contextFILEASSOC
case|:
case|case
name|FFEEXPR_contextFILEINT
case|:
case|case
name|FFEEXPR_contextFILEDFINT
case|:
case|case
name|FFEEXPR_contextFILELOG
case|:
case|case
name|FFEEXPR_contextFILENUM
case|:
case|case
name|FFEEXPR_contextFILENUMAMBIG
case|:
case|case
name|FFEEXPR_contextFILECHAR
case|:
case|case
name|FFEEXPR_contextFILENUMCHAR
case|:
case|case
name|FFEEXPR_contextFILEDFCHAR
case|:
case|case
name|FFEEXPR_contextFILEKEY
case|:
case|case
name|FFEEXPR_contextFILEUNIT
case|:
case|case
name|FFEEXPR_contextFILEUNIT_DF
case|:
case|case
name|FFEEXPR_contextFILEUNITAMBIG
case|:
case|case
name|FFEEXPR_contextFILEFORMAT
case|:
case|case
name|FFEEXPR_contextFILENAMELIST
case|:
case|case
name|FFEEXPR_contextFILEVXTCODE
case|:
case|case
name|FFEEXPR_contextINDEX_
case|:
case|case
name|FFEEXPR_contextIMPDOITEM_
case|:
case|case
name|FFEEXPR_contextIMPDOITEMDF_
case|:
case|case
name|FFEEXPR_contextIMPDOCTRL_
case|:
case|case
name|FFEEXPR_contextLOC_
case|:
name|bad
operator|=
name|FALSE
expr_stmt|;
comment|/* Let paren-switch handle the cases. */
break|break;
case|case
name|FFEEXPR_contextASSIGN
case|:
case|case
name|FFEEXPR_contextAGOTO
case|:
case|case
name|FFEEXPR_contextCHARACTERSIZE
case|:
case|case
name|FFEEXPR_contextEQUIVALENCE
case|:
case|case
name|FFEEXPR_contextPARAMETER
case|:
case|case
name|FFEEXPR_contextDIMLIST
case|:
case|case
name|FFEEXPR_contextDIMLISTCOMMON
case|:
case|case
name|FFEEXPR_contextKINDTYPE
case|:
case|case
name|FFEEXPR_contextINITVAL
case|:
case|case
name|FFEEXPR_contextEQVINDEX_
case|:
name|bad
operator|=
operator|(
name|k
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
operator|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextINCLUDE
case|:
name|bad
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|bad
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|bad
condition|?
name|FFEINFO_kindANY
else|:
name|k
condition|)
block|{
case|case
name|FFEINFO_kindNONE
case|:
comment|/* Case "CHARACTER X,Y; Y=X(?". */
if|if
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereINTRINSIC
condition|)
block|{
if|if
condition|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
operator|==
name|FFEEXPR_contextSUBROUTINEREF
condition|)
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeSUBROUTINE_
expr_stmt|;
else|else
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeFUNCTION_
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|st
operator|==
name|FFESYMBOL_stateUNDERSTOOD
condition|)
block|{
name|bad
operator|=
name|TRUE
expr_stmt|;
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeANY_
expr_stmt|;
block|}
else|else
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeFUNSUBSTR_
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindFUNCTION
case|:
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeFUNCTION_
expr_stmt|;
switch|switch
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereLOCAL
case|:
name|bad
operator|=
name|TRUE
expr_stmt|;
comment|/* Attempt to recurse! */
break|break;
case|case
name|FFEINFO_whereCONSTANT
case|:
name|bad
operator|=
operator|(
operator|(
name|ffesymbol_sfexpr
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|ffesymbol_sfexpr
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
operator|)
expr_stmt|;
comment|/* Attempt to recurse! */
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FFEINFO_kindSUBROUTINE
case|:
if|if
condition|(
operator|(
name|ffeexpr_stack_
operator|->
name|context
operator|!=
name|FFEEXPR_contextSUBROUTINEREF
operator|)
operator|||
operator|(
name|ffeexpr_stack_
operator|->
name|previous
operator|!=
name|NULL
operator|)
condition|)
block|{
name|bad
operator|=
name|TRUE
expr_stmt|;
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeANY_
expr_stmt|;
break|break;
block|}
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeSUBROUTINE_
expr_stmt|;
switch|switch
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereLOCAL
case|:
case|case
name|FFEINFO_whereCONSTANT
case|:
name|bad
operator|=
name|TRUE
expr_stmt|;
comment|/* Attempt to recurse! */
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FFEINFO_kindENTITY
case|:
if|if
condition|(
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeSUBSTRING_
expr_stmt|;
else|else
block|{
name|bad
operator|=
name|TRUE
expr_stmt|;
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeANY_
expr_stmt|;
block|}
block|}
else|else
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeARRAY_
expr_stmt|;
break|break;
default|default:
case|case
name|FFEINFO_kindANY
case|:
name|bad
operator|=
name|TRUE
expr_stmt|;
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeANY_
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bad
condition|)
block|{
if|if
condition|(
name|k
operator|==
name|FFEINFO_kindANY
condition|)
name|ffest_shutdown
argument_list|()
expr_stmt|;
else|else
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
case|case
name|FFESYMBOL_stateSEEN
case|:
comment|/* Seen but not yet in exec portion. */
name|seen
label|:
comment|/* :::::::::::::::::::: */
name|bad
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
condition|)
block|{
case|case
name|FFEEXPR_contextPARAMETER
case|:
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|ffeexpr_sym_lhs_parameter_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextDATA
case|:
name|s
operator|=
name|ffecom_sym_exec_transition
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNDERSTOOD
condition|)
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|is_rhs
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|ffeexpr_sym_lhs_data_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
name|s
operator|=
name|ffecom_sym_exec_transition
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNDERSTOOD
condition|)
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
name|s
operator|=
name|ffeexpr_sym_lhs_data_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFEEXPR_contextEQUIVALENCE
case|:
name|s
operator|=
name|ffeexpr_sym_lhs_equivalence_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|bad
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextDIMLIST
case|:
name|s
operator|=
name|ffeexpr_sym_rhs_dimlist_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextCHARACTERSIZE
case|:
case|case
name|FFEEXPR_contextKINDTYPE
case|:
case|case
name|FFEEXPR_contextDIMLISTCOMMON
case|:
case|case
name|FFEEXPR_contextINITVAL
case|:
case|case
name|FFEEXPR_contextEQVINDEX_
case|:
break|break;
case|case
name|FFEEXPR_contextINCLUDE
case|:
break|break;
case|case
name|FFEEXPR_contextINDEX_
case|:
case|case
name|FFEEXPR_contextACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextINDEXORACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextSFUNCDEF
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEX_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
case|:
name|assert
argument_list|(
name|ffeexpr_stack_
operator|->
name|is_rhs
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_exec_transition
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNDERSTOOD
condition|)
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
name|s
operator|=
name|ffeexpr_paren_rhs_let_
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
goto|goto
name|understood
goto|;
comment|/* :::::::::::::::::::: */
default|default:
break|break;
block|}
name|k
operator|=
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bad
condition|?
name|FFEINFO_kindANY
else|:
name|k
condition|)
block|{
case|case
name|FFEINFO_kindNONE
case|:
comment|/* Case "CHARACTER X,Y; Y=X(?". */
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeFUNSUBSTR_
expr_stmt|;
break|break;
case|case
name|FFEINFO_kindFUNCTION
case|:
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeFUNCTION_
expr_stmt|;
switch|switch
condition|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereLOCAL
case|:
name|bad
operator|=
name|TRUE
expr_stmt|;
comment|/* Attempt to recurse! */
break|break;
case|case
name|FFEINFO_whereCONSTANT
case|:
name|bad
operator|=
operator|(
operator|(
name|ffesymbol_sfexpr
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|ffesymbol_sfexpr
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
operator|)
expr_stmt|;
comment|/* Attempt to recurse! */
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|FFEINFO_kindSUBROUTINE
case|:
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeANY_
expr_stmt|;
name|bad
operator|=
name|TRUE
expr_stmt|;
comment|/* Cannot possibly be in 				   contextSUBROUTINEREF. */
break|break;
case|case
name|FFEINFO_kindENTITY
case|:
if|if
condition|(
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|context
operator|==
name|FFEEXPR_contextEQUIVALENCE
condition|)
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeEQUIVALENCE_
expr_stmt|;
elseif|else
if|if
condition|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeSUBSTRING_
expr_stmt|;
else|else
block|{
name|bad
operator|=
name|TRUE
expr_stmt|;
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeANY_
expr_stmt|;
block|}
block|}
else|else
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeARRAY_
expr_stmt|;
break|break;
default|default:
case|case
name|FFEINFO_kindANY
case|:
name|bad
operator|=
name|TRUE
expr_stmt|;
operator|*
name|paren_type
operator|=
name|FFEEXPR_parentypeANY_
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bad
condition|)
block|{
if|if
condition|(
name|k
operator|==
name|FFEINFO_kindANY
condition|)
name|ffest_shutdown
argument_list|()
expr_stmt|;
else|else
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
default|default:
name|assert
argument_list|(
literal|"bad symbol state"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Have FOO in XYZ = ...FOO(...)....  Executable context only.  */
end_comment

begin_function
specifier|static
name|ffesymbol
name|ffeexpr_paren_rhs_let_
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffeinfoKind
name|kind
decl_stmt|;
name|ffeinfoWhere
name|where
decl_stmt|;
name|ffeintrinGen
name|gen
decl_stmt|;
name|ffeintrinSpec
name|spec
decl_stmt|;
name|ffeintrinImp
name|imp
decl_stmt|;
name|bool
name|maybe_ambig
init|=
name|FALSE
decl_stmt|;
name|bool
name|error
init|=
name|FALSE
decl_stmt|;
name|assert
argument_list|(
operator|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
operator|)
operator|||
operator|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNCERTAIN
operator|)
argument_list|)
expr_stmt|;
name|na
operator|=
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|where
operator|=
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsACTUALARG
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
name|where
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
else|else
comment|/* Not TYPE. */
block|{
name|kind
operator|=
name|FFEINFO_kindFUNCTION
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
empty_stmt|;
comment|/* Not TYPE. */
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsACTUALARG
condition|)
empty_stmt|;
comment|/* Not DUMMY or TYPE. */
else|else
comment|/* Not ACTUALARG, DUMMY, or TYPE. */
name|where
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsEXTERNAL
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|FFEINFO_kindFUNCTION
expr_stmt|;
name|maybe_ambig
operator|=
name|TRUE
expr_stmt|;
comment|/* If basictypeCHARACTER, can't be sure; kind 				   could be ENTITY w/substring ref. */
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsARRAY
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsSFARG
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
comment|/* Actually an error, but at least we 					   know it's a local var. */
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Handled above. */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsTYPE
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffeintrin_is_intrinsic
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|,
operator|&
name|gen
argument_list|,
operator|&
name|spec
argument_list|,
operator|&
name|imp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsANYLEN
operator|)
operator|&&
operator|(
name|ffeimplic_peek_symbol_type
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
condition|)
return|return
name|s
return|;
comment|/* Haven't learned anything yet. */
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* May need to back up to previous 					   version. */
name|ffesymbol_set_generic
argument_list|(
name|s
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|ffesymbol_set_specific
argument_list|(
name|s
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|ffesymbol_set_implementation
argument_list|(
name|s
argument_list|,
name|imp
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindFUNCTION
argument_list|,
name|FFEINFO_whereINTRINSIC
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
return|return
name|s
return|;
block|}
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANYLEN
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
comment|/* Error, since the only way we can, 				   given CHARACTER*(*) FOO, accept 				   FOO(...) is for FOO to be a dummy 				   arg or constant, but it can't 				   become either now. */
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsADJUSTABLE
condition|)
block|{
name|kind
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereLOCAL
expr_stmt|;
block|}
else|else
block|{
name|kind
operator|=
name|FFEINFO_kindFUNCTION
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
name|maybe_ambig
operator|=
name|TRUE
expr_stmt|;
comment|/* If basictypeCHARACTER, can't be sure; 				   could be ENTITY/LOCAL w/substring ref. */
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
block|{
name|assert
argument_list|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffeintrin_is_intrinsic
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|,
operator|&
name|gen
argument_list|,
operator|&
name|spec
argument_list|,
operator|&
name|imp
argument_list|)
condition|)
block|{
if|if
condition|(
name|ffeimplic_peek_symbol_type
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
condition|)
return|return
name|s
return|;
comment|/* Haven't learned anything yet. */
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* May need to back up to previous 					   version. */
name|ffesymbol_set_generic
argument_list|(
name|s
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|ffesymbol_set_specific
argument_list|(
name|s
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|ffesymbol_set_implementation
argument_list|(
name|s
argument_list|,
name|imp
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindFUNCTION
argument_list|,
name|FFEINFO_whereINTRINSIC
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
return|return
name|s
return|;
block|}
name|kind
operator|=
name|FFEINFO_kindFUNCTION
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereGLOBAL
expr_stmt|;
name|maybe_ambig
operator|=
name|TRUE
expr_stmt|;
comment|/* If basictypeCHARACTER, can't be sure; 				   could be ENTITY/LOCAL w/substring ref. */
block|}
else|else
name|error
operator|=
name|TRUE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|error
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* May need to back up to previous 					   version. */
if|if
condition|(
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
name|maybe_ambig
operator|&&
operator|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
condition|)
return|return
name|s
return|;
comment|/* Still not sure, let caller deal with it 				   based on (...). */
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
name|kind
argument_list|,
name|where
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_arguments_ -- OPEN_PAREN [expr COMMA]...expr     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Handle expression (which might be null) and COMMA or CLOSE_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_arguments_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|procedure
decl_stmt|;
name|ffebld
name|reduced
decl_stmt|;
name|ffeinfo
name|info
decl_stmt|;
name|ffeexprContext
name|ctx
decl_stmt|;
name|bool
name|check_intrin
init|=
name|FALSE
decl_stmt|;
comment|/* Set TRUE if intrinsic is REAL(Z) or AIMAG(Z). */
name|procedure
operator|=
name|ffeexpr_stack_
operator|->
name|exprstack
expr_stmt|;
name|info
operator|=
name|ffebld_info
argument_list|(
name|procedure
operator|->
name|u
operator|.
name|operand
argument_list|)
expr_stmt|;
comment|/* Is there an expression to add?  If the expression is nil,      it might still be an argument.  It is if:         -  The current token is comma, or         -  The -fugly-comma flag was specified *and* the procedure           being invoked is external.       Otherwise, if neither of the above is the case, just      ignore this (nil) expression.  */
if|if
condition|(
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOMMA
operator|)
operator|||
operator|(
name|ffe_is_ugly_comma
argument_list|()
operator|&&
operator|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
operator|==
name|FFEINFO_whereGLOBAL
operator|)
operator|)
condition|)
block|{
comment|/* This expression, even if nil, is apparently intended as an argument.  */
comment|/* Internal procedure (CONTAINS, or statement function)?  */
if|if
condition|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
operator|==
name|FFEINFO_whereCONSTANT
condition|)
block|{
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_NULL_ARGUMENT
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|next_dummy
operator|==
name|NULL
condition|)
block|{
comment|/* Report later which was the first extra argument. */
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|num_args
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|ffeexpr_stack_
operator|->
name|num_args
expr_stmt|;
comment|/* Count # of extra arguments. */
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ffeinfo_rank
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_ARRAY_AS_SFARG
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ft
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffesymbol_sfdummyparent
argument_list|(
name|ffebld_symter
argument_list|(
name|ffebld_head
argument_list|(
name|ffeexpr_stack_
operator|->
name|next_dummy
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|expr
operator|=
name|ffeexpr_convert_expr
argument_list|(
name|expr
argument_list|,
name|ft
argument_list|,
name|ffebld_head
argument_list|(
name|ffeexpr_stack_
operator|->
name|next_dummy
argument_list|)
argument_list|,
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|ffebld_append_item
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
operator|--
name|ffeexpr_stack_
operator|->
name|num_args
expr_stmt|;
comment|/* Count down # of args. */
name|ffeexpr_stack_
operator|->
name|next_dummy
operator|=
name|ffebld_trail
argument_list|(
name|ffeexpr_stack_
operator|->
name|next_dummy
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
operator|&&
name|ffe_is_pedantic
argument_list|()
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_NULL_ARGUMENT_W
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffebld_append_item
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
switch|switch
condition|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
condition|)
block|{
case|case
name|FFEEXPR_contextSFUNCDEF
case|:
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARGEXPR_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEX_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_
case|:
name|ctx
operator|=
name|FFEEXPR_contextSFUNCDEFACTUALARG_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|assert
argument_list|(
literal|"bad context"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|FFEEXPR_context
expr_stmt|;
break|break;
default|default:
name|ctx
operator|=
name|FFEEXPR_contextACTUALARG_
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|ctx
argument_list|,
name|ffeexpr_token_arguments_
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
operator|==
name|FFEINFO_whereCONSTANT
operator|)
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|next_dummy
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* Too few arguments. */
if|if
condition|(
name|ffebad_start
argument_list|(
name|FFEBAD_TOO_FEW_ARGUMENTS
argument_list|)
condition|)
block|{
name|char
name|num
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%"
name|ffebldListLength_f
literal|"u"
argument_list|,
name|ffeexpr_stack_
operator|->
name|num_args
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffesymbol_sfdummyparent
argument_list|(
name|ffebld_symter
argument_list|(
name|ffebld_head
argument_list|(
name|ffeexpr_stack_
operator|->
name|next_dummy
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
name|ffeexpr_stack_
operator|->
name|next_dummy
operator|!=
name|NULL
condition|;
name|ffeexpr_stack_
operator|->
name|next_dummy
operator|=
name|ffebld_trail
argument_list|(
name|ffeexpr_stack_
operator|->
name|next_dummy
argument_list|)
control|)
block|{
name|expr
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_integerdefault_val
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
name|ffebld_append_item
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
operator|==
name|FFEINFO_whereCONSTANT
operator|)
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* Too many arguments to statement function. */
if|if
condition|(
name|ffebad_start
argument_list|(
name|FFEBAD_TOO_MANY_ARGUMENTS
argument_list|)
condition|)
block|{
name|char
name|num
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%"
name|ffebldListLength_f
literal|"u"
argument_list|,
name|ffeexpr_stack_
operator|->
name|num_args
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|ffebld_end_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|procedure
operator|->
name|u
operator|.
name|operand
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
block|{
name|reduced
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|context
operator|!=
name|FFEEXPR_contextSUBROUTINEREF
condition|)
name|reduced
operator|=
name|ffebld_new_funcref
argument_list|(
name|procedure
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeexpr_stack_
operator|->
name|expr
argument_list|)
expr_stmt|;
else|else
name|reduced
operator|=
name|ffebld_new_subrref
argument_list|(
name|procedure
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeexpr_stack_
operator|->
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_symter_generic
argument_list|(
name|procedure
operator|->
name|u
operator|.
name|operand
argument_list|)
operator|!=
name|FFEINTRIN_genNONE
condition|)
name|ffeintrin_fulfill_generic
argument_list|(
operator|&
name|reduced
argument_list|,
operator|&
name|info
argument_list|,
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ffebld_symter_specific
argument_list|(
name|procedure
operator|->
name|u
operator|.
name|operand
argument_list|)
operator|!=
name|FFEINTRIN_specNONE
condition|)
name|ffeintrin_fulfill_specific
argument_list|(
operator|&
name|reduced
argument_list|,
operator|&
name|info
argument_list|,
operator|&
name|check_intrin
argument_list|,
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|ffeexpr_fulfill_call_
argument_list|(
operator|&
name|reduced
argument_list|,
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|reduced
argument_list|)
operator|!=
name|FFEBLD_opANY
condition|)
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereFLEETING
argument_list|,
name|ffeinfo_size
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffebld_op
argument_list|(
name|reduced
argument_list|)
operator|==
name|FFEBLD_opFUNCREF
condition|)
name|reduced
operator|=
name|ffeexpr_collapse_funcref
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|exprstack
operator|=
name|procedure
operator|->
name|previous
expr_stmt|;
comment|/* Pops 							   not-quite-operand off 							   stack. */
name|procedure
operator|->
name|u
operator|.
name|operand
operator|=
name|reduced
expr_stmt|;
comment|/* Save the line/column ffewhere 					   info. */
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
comment|/* Push it back on stack. */
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCLOSE_PAREN
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffeexpr_is_substr_ok_
operator|=
name|FALSE
expr_stmt|;
comment|/* Nobody likes "FUNC(3)(1:1)".... */
comment|/* If the intrinsic needs checking (is REAL(Z) or AIMAG(Z), where 	 Z is DOUBLE COMPLEX), and a command-line option doesn't already 	 establish interpretation, probably complain.  */
if|if
condition|(
name|check_intrin
operator|&&
operator|!
name|ffe_is_90
argument_list|()
operator|&&
operator|!
name|ffe_is_ugly_complex
argument_list|()
condition|)
block|{
comment|/* If the outer expression is REAL(me...), issue diagnostic 	     only if next token isn't the close-paren for REAL(me).  */
if|if
condition|(
operator|(
name|ffeexpr_stack_
operator|->
name|previous
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|previous
operator|->
name|exprstack
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeexpr_stack_
operator|->
name|previous
operator|->
name|exprstack
operator|->
name|type
operator|==
name|FFEEXPR_exprtypeOPERAND_
operator|)
operator|&&
operator|(
operator|(
name|reduced
operator|=
name|ffeexpr_stack_
operator|->
name|previous
operator|->
name|exprstack
operator|->
name|u
operator|.
name|operand
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|reduced
argument_list|)
operator|==
name|FFEBLD_opSYMTER
operator|)
operator|&&
operator|(
name|ffebld_symter_implementation
argument_list|(
name|reduced
argument_list|)
operator|==
name|FFEINTRIN_impREAL
operator|)
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_intrincheck_
return|;
comment|/* Diagnose the ambiguity now.  */
if|if
condition|(
name|ffebad_start
argument_list|(
name|FFEBAD_INTRINSIC_CMPAMBIG
argument_list|)
condition|)
block|{
name|ffebad_string
argument_list|(
name|ffeintrin_name_implementation
argument_list|(
name|ffebld_symter_implementation
argument_list|(
name|ffebld_left
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|u
operator|.
name|operand
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_substrp_
return|;
block|}
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_INVALID_TOKEN_IN_EXPRESSION
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffeexpr_is_substr_ok_
operator|=
name|FALSE
expr_stmt|;
comment|/* Nobody likes "FUNC(3)(1:1)".... */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_find_close_paren_
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_substrp_
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_elements_ -- OPEN_PAREN [expr COMMA]...expr     Return a pointer to this array to the lexer (ffelex), which will    invoke it for the next token.     Handle expression and COMMA or CLOSE_PAREN.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_elements_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|array
decl_stmt|;
name|ffebld
name|reduced
decl_stmt|;
name|ffeinfo
name|info
decl_stmt|;
name|ffeinfoWhere
name|where
decl_stmt|;
name|ffetargetIntegerDefault
name|val
decl_stmt|;
name|ffetargetIntegerDefault
name|lval
init|=
literal|0
decl_stmt|;
name|ffetargetIntegerDefault
name|uval
init|=
literal|0
decl_stmt|;
name|ffebld
name|lbound
decl_stmt|;
name|ffebld
name|ubound
decl_stmt|;
name|bool
name|lcheck
decl_stmt|;
name|bool
name|ucheck
decl_stmt|;
name|array
operator|=
name|ffeexpr_stack_
operator|->
name|exprstack
expr_stmt|;
name|info
operator|=
name|ffebld_info
argument_list|(
name|array
operator|->
name|u
operator|.
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|expr
operator|==
name|NULL
operator|)
comment|/*&& ((ffeexpr_stack_->rank != 0) || 				   (ffelex_token_type(t) == 	 FFELEX_typeCOMMA)) */
condition|)
block|{
if|if
condition|(
name|ffebad_start
argument_list|(
name|FFEBAD_NULL_ELEMENT
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|rank
operator|<
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
condition|)
block|{
comment|/* Don't bother if we're going to complain 				   later! */
name|expr
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_integerdefault_val
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* In EQUIVALENCE context, ffeinfo_rank(info) 				   may == 0. */
operator|++
name|ffeexpr_stack_
operator|->
name|rank
expr_stmt|;
comment|/* Track anyway, may need for new VXT 				   feature. */
name|ffebld_append_item
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|ffeexpr_stack_
operator|->
name|rank
expr_stmt|;
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|rank
operator|>
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
condition|)
block|{
comment|/* Report later which was the first extra 				   element. */
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|rank
operator|==
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|+
literal|1
condition|)
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|ft
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|ffeexpr_stack_
operator|->
name|constant
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|ffeexpr_stack_
operator|->
name|constant
operator|=
name|FALSE
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|immediate
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|&&
name|ffebld_kindtype
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
condition|)
block|{
name|val
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|lbound
operator|=
name|ffebld_left
argument_list|(
name|ffebld_head
argument_list|(
name|ffeexpr_stack_
operator|->
name|bound_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbound
operator|==
name|NULL
condition|)
block|{
name|lcheck
operator|=
name|TRUE
expr_stmt|;
name|lval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|lbound
argument_list|)
operator|==
name|FFEBLD_opCONTER
condition|)
block|{
name|lcheck
operator|=
name|TRUE
expr_stmt|;
name|lval
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|lbound
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|lcheck
operator|=
name|FALSE
expr_stmt|;
name|ubound
operator|=
name|ffebld_right
argument_list|(
name|ffebld_head
argument_list|(
name|ffeexpr_stack_
operator|->
name|bound_list
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ubound
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|ubound
argument_list|)
operator|==
name|FFEBLD_opCONTER
condition|)
block|{
name|ucheck
operator|=
name|TRUE
expr_stmt|;
name|uval
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|ubound
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ucheck
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|lcheck
operator|&&
operator|(
name|val
operator|<
name|lval
operator|)
operator|)
operator|||
operator|(
name|ucheck
operator|&&
operator|(
name|val
operator|>
name|uval
operator|)
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_RANGE_ARRAY
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ft
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|ffebld_append_item
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|ffeexpr_stack_
operator|->
name|bound_list
operator|=
name|ffebld_trail
argument_list|(
name|ffeexpr_stack_
operator|->
name|bound_list
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
switch|switch
condition|(
name|ffeexpr_context_outer_
argument_list|(
name|ffeexpr_stack_
argument_list|)
condition|)
block|{
case|case
name|FFEEXPR_contextDATAIMPDOITEM_
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextDATAIMPDOINDEX_
argument_list|,
name|ffeexpr_token_elements_
argument_list|)
return|;
case|case
name|FFEEXPR_contextEQUIVALENCE
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextEQVINDEX_
argument_list|,
name|ffeexpr_token_elements_
argument_list|)
return|;
case|case
name|FFEEXPR_contextSFUNCDEF
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEX_
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextSFUNCDEFINDEX_
argument_list|,
name|ffeexpr_token_elements_
argument_list|)
return|;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|assert
argument_list|(
literal|"bad context"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextINDEX_
argument_list|,
name|ffeexpr_token_elements_
argument_list|)
return|;
block|}
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|ffeexpr_stack_
operator|->
name|rank
operator|!=
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|)
operator|&&
operator|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
name|num
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|rank
operator|<
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
condition|)
block|{
if|if
condition|(
name|ffebad_start
argument_list|(
name|FFEBAD_TOO_FEW_ELEMENTS
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
operator|-
name|ffeexpr_stack_
operator|->
name|rank
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ffebad_start
argument_list|(
name|FFEBAD_TOO_MANY_ELEMENTS
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ffeexpr_stack_
operator|->
name|rank
operator|-
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|ffeexpr_stack_
operator|->
name|rank
operator|++
operator|<
name|ffeinfo_rank
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|expr
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_integerdefault_val
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|expr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_append_item
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
name|ffebld_end_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|array
operator|->
name|u
operator|.
name|operand
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
block|{
name|reduced
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reduced
operator|=
name|ffebld_new_arrayref
argument_list|(
name|array
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeexpr_stack_
operator|->
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|constant
condition|)
name|where
operator|=
name|FFEINFO_whereFLEETING_CADDR
expr_stmt|;
elseif|else
if|if
condition|(
name|ffeexpr_stack_
operator|->
name|immediate
condition|)
name|where
operator|=
name|FFEINFO_whereFLEETING_IADDR
expr_stmt|;
else|else
name|where
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|where
argument_list|,
name|ffeinfo_size
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_arrayref
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|ffeexpr_stack_
operator|->
name|exprstack
operator|=
name|array
operator|->
name|previous
expr_stmt|;
comment|/* Pops not-quite-operand off 						   stack. */
name|array
operator|->
name|u
operator|.
name|operand
operator|=
name|reduced
expr_stmt|;
comment|/* Save the line/column ffewhere info. */
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|array
argument_list|)
expr_stmt|;
comment|/* Push it back on stack. */
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeCHARACTER
case|:
name|ffeexpr_is_substr_ok_
operator|=
name|TRUE
expr_stmt|;
comment|/* Everyone likes "FOO(3)(1:1)".... */
break|break;
case|case
name|FFEINFO_basictypeNONE
case|:
name|ffeexpr_is_substr_ok_
operator|=
name|TRUE
expr_stmt|;
name|assert
argument_list|(
name|ffeexpr_stack_
operator|->
name|context
operator|==
name|FFEEXPR_contextEQUIVALENCE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ffeexpr_is_substr_ok_
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCLOSE_PAREN
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_substrp_
return|;
block|}
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_INVALID_TOKEN_IN_EXPRESSION
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_find_close_paren_
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_substrp_
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_equivalence_ -- OPEN_PAREN expr     Return a pointer to this array to the lexer (ffelex), which will    invoke it for the next token.     If token is COLON, pass off to _substr_, else init list and pass off    to _elements_.  This handles the case "EQUIVALENCE (FOO(expr?", where    ? marks the token, and where FOO's rank/type has not yet been established,    meaning we could be in a list of indices or in a substring    specification.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_equivalence_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOLON
condition|)
return|return
name|ffeexpr_token_substring_
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
return|;
name|ffebld_init_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
return|return
name|ffeexpr_token_elements_
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_substring_ -- NAME(of kindENTITY) OPEN_PAREN expr     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Handle expression (which may be null) and COLON.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_substring_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|string
decl_stmt|;
name|ffeinfo
name|info
decl_stmt|;
name|ffetargetIntegerDefault
name|i
decl_stmt|;
name|ffeexprContext
name|ctx
decl_stmt|;
name|ffetargetCharacterSize
name|size
decl_stmt|;
name|string
operator|=
name|ffeexpr_stack_
operator|->
name|exprstack
expr_stmt|;
name|info
operator|=
name|ffebld_info
argument_list|(
name|string
operator|->
name|u
operator|.
name|operand
argument_list|)
expr_stmt|;
name|size
operator|=
name|ffebld_size_max
argument_list|(
name|string
operator|->
name|u
operator|.
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOLON
condition|)
block|{
if|if
condition|(
operator|(
name|expr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|&&
operator|(
operator|(
operator|(
name|i
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|<
literal|1
operator|)
operator|||
operator|(
operator|(
name|size
operator|!=
name|FFETARGET_charactersizeNONE
operator|)
operator|&&
operator|(
name|i
operator|>
name|size
operator|)
operator|)
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_RANGE_SUBSTR
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ft
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffeexpr_stack_
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextSFUNCDEF
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEX_
case|:
name|ctx
operator|=
name|FFEEXPR_contextSFUNCDEFINDEX_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|assert
argument_list|(
literal|"bad context"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|FFEEXPR_context
expr_stmt|;
break|break;
default|default:
name|ctx
operator|=
name|FFEEXPR_contextINDEX_
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|ctx
argument_list|,
name|ffeexpr_token_substring_1_
argument_list|)
return|;
block|}
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_MISSING_COLON_IN_SUBSTR
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffeexpr_stack_
operator|->
name|expr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_substring_1_
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_substring_1_ -- NAME OPEN_PAREN [expr COMMA]...expr     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     Handle expression (which might be null) and CLOSE_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_substring_1_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|last
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|string
decl_stmt|;
name|ffebld
name|reduced
decl_stmt|;
name|ffebld
name|substrlist
decl_stmt|;
name|ffebld
name|first
init|=
name|ffeexpr_stack_
operator|->
name|expr
decl_stmt|;
name|ffebld
name|strop
decl_stmt|;
name|ffeinfo
name|info
decl_stmt|;
name|ffeinfoWhere
name|lwh
decl_stmt|;
name|ffeinfoWhere
name|rwh
decl_stmt|;
name|ffeinfoWhere
name|where
decl_stmt|;
name|ffeinfoKindtype
name|first_kt
decl_stmt|;
name|ffeinfoKindtype
name|last_kt
decl_stmt|;
name|ffetargetIntegerDefault
name|first_val
decl_stmt|;
name|ffetargetIntegerDefault
name|last_val
decl_stmt|;
name|ffetargetCharacterSize
name|size
decl_stmt|;
name|ffetargetCharacterSize
name|strop_size_max
decl_stmt|;
name|bool
name|first_known
decl_stmt|;
name|string
operator|=
name|ffeexpr_stack_
operator|->
name|exprstack
expr_stmt|;
name|strop
operator|=
name|string
operator|->
name|u
operator|.
name|operand
expr_stmt|;
name|info
operator|=
name|ffebld_info
argument_list|(
name|strop
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|NULL
operator|||
operator|(
name|ffebld_op
argument_list|(
name|first
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|&&
name|ffebld_kindtype
argument_list|(
name|first
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
operator|)
condition|)
block|{
comment|/* The starting point is known. */
name|first_val
operator|=
operator|(
name|first
operator|==
name|NULL
operator|)
condition|?
literal|1
else|:
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|first_known
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Assume start of the entity. */
name|first_val
operator|=
literal|1
expr_stmt|;
name|first_known
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|!=
name|NULL
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|last
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|&&
name|ffebld_kindtype
argument_list|(
name|last
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
operator|)
condition|)
block|{
comment|/* The ending point is known. */
name|last_val
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_known
condition|)
block|{
comment|/* The beginning point is a constant. */
if|if
condition|(
name|first_val
operator|<=
name|last_val
condition|)
name|size
operator|=
name|last_val
operator|-
name|first_val
operator|+
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
literal|0
operator|&&
name|ffe_is_90
argument_list|()
condition|)
name|size
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|size
operator|=
literal|1
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_ZERO_SIZE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ft
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
name|size
operator|=
name|FFETARGET_charactersizeNONE
expr_stmt|;
name|strop_size_max
operator|=
name|ffebld_size_max
argument_list|(
name|strop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strop_size_max
operator|!=
name|FFETARGET_charactersizeNONE
operator|)
operator|&&
operator|(
name|last_val
operator|>
name|strop_size_max
operator|)
condition|)
block|{
comment|/* Beyond maximum possible end of string. */
name|ffebad_start
argument_list|(
name|FFEBAD_RANGE_SUBSTR
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ft
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|size
operator|=
name|FFETARGET_charactersizeNONE
expr_stmt|;
comment|/* The size is not known. */
if|#
directive|if
literal|0
comment|/* Don't do this, or "is size of target 				   known?" would no longer be easily 				   answerable.	To see if there is a max 				   size, use ffebld_size_max; to get only the 				   known size, else NONE, use 				   ffebld_size_known; use ffebld_size if 				   values are sure to be the same (not 				   opSUBSTR or opCONCATENATE or known to have 				   known length). By getting rid of this 				   "useful info" stuff, we don't end up 				   blank-padding the constant in the 				   assignment "A(I:J)='XYZ'" to the known 				   length of A. */
block|if (size == FFETARGET_charactersizeNONE)     size = strop_size_max;
comment|/* Assume we use the entire string. */
endif|#
directive|endif
name|substrlist
operator|=
name|ffebld_new_item
argument_list|(
name|first
argument_list|,
name|ffebld_new_item
argument_list|(
name|last
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
name|lwh
operator|=
name|FFEINFO_whereCONSTANT
expr_stmt|;
else|else
name|lwh
operator|=
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
name|rwh
operator|=
name|FFEINFO_whereCONSTANT
expr_stmt|;
else|else
name|rwh
operator|=
name|ffeinfo_where
argument_list|(
name|ffebld_info
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
name|where
operator|=
name|FFEINFO_whereCONSTANT
expr_stmt|;
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|where
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|where
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
switch|switch
condition|(
name|rwh
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
case|case
name|FFEINFO_whereIMMEDIATE
case|:
name|where
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|where
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|where
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
name|first_kt
operator|=
name|FFEINFO_kindtypeINTEGERDEFAULT
expr_stmt|;
else|else
name|first_kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
name|last_kt
operator|=
name|FFEINFO_kindtypeINTEGERDEFAULT
expr_stmt|;
else|else
name|last_kt
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|where
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
switch|switch
condition|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
comment|/* Not possible, actually. */
name|where
operator|=
name|FFEINFO_whereIMMEDIATE
expr_stmt|;
break|break;
default|default:
name|where
operator|=
name|FFEINFO_whereFLEETING_CADDR
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
switch|switch
condition|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
case|case
name|FFEINFO_whereIMMEDIATE
case|:
comment|/* Not possible, actually. */
break|break;
default|default:
name|where
operator|=
name|FFEINFO_whereFLEETING_IADDR
expr_stmt|;
break|break;
block|}
break|break;
default|default:
switch|switch
condition|(
name|ffeinfo_where
argument_list|(
name|info
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_whereCONSTANT
case|:
name|where
operator|=
name|FFEINFO_whereCONSTANT_SUBOBJECT
expr_stmt|;
comment|/* An F90 concept. */
break|break;
case|case
name|FFEINFO_whereIMMEDIATE
case|:
comment|/* Not possible, actually. */
default|default:
name|where
operator|=
name|FFEINFO_whereFLEETING
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|ffebld_op
argument_list|(
name|strop
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
block|{
name|reduced
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reduced
operator|=
name|ffebld_new_substr
argument_list|(
name|strop
argument_list|,
name|substrlist
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|reduced
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeCHARACTER
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|info
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|where
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|reduced
operator|=
name|ffeexpr_collapse_substr
argument_list|(
name|reduced
argument_list|,
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|ffeexpr_stack_
operator|->
name|exprstack
operator|=
name|string
operator|->
name|previous
expr_stmt|;
comment|/* Pops not-quite-operand off 						   stack. */
name|string
operator|->
name|u
operator|.
name|operand
operator|=
name|reduced
expr_stmt|;
comment|/* Save the line/column ffewhere info. */
name|ffeexpr_exprstack_push_operand_
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|/* Push it back on stack. */
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCLOSE_PAREN
condition|)
block|{
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffeexpr_is_substr_ok_
operator|=
name|FALSE
expr_stmt|;
comment|/* Nobody likes "FOO(3:5)(1:1)".... */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_substrp_
return|;
block|}
if|if
condition|(
name|ffest_ffebad_start
argument_list|(
name|FFEBAD_INVALID_TOKEN_IN_EXPRESSION
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffeexpr_is_substr_ok_
operator|=
name|FALSE
expr_stmt|;
comment|/* Nobody likes "FOO(3:5)(1:1)".... */
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_find_close_paren_
argument_list|(
name|t
argument_list|,
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_substrp_
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_substrp_ -- Rhs<character entity>     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     If OPEN_PAREN, treat as start of a substring ("(3:4)") construct, and    issue error message if flag (serves as argument) is set.  Else, just    forward token to binary_.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_substrp_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprContext
name|ctx
decl_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeOPEN_PAREN
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_binary_
argument_list|(
name|t
argument_list|)
return|;
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
operator|=
name|ffelex_token_use
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffeexpr_stack_
operator|->
name|context
condition|)
block|{
case|case
name|FFEEXPR_contextSFUNCDEF
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEX_
case|:
name|ctx
operator|=
name|FFEEXPR_contextSFUNCDEFINDEX_
expr_stmt|;
break|break;
case|case
name|FFEEXPR_contextSFUNCDEFACTUALARG_
case|:
case|case
name|FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_
case|:
name|assert
argument_list|(
literal|"bad context"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|FFEEXPR_context
expr_stmt|;
break|break;
default|default:
name|ctx
operator|=
name|FFEEXPR_contextINDEX_
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffeexpr_is_substr_ok_
condition|)
block|{
if|if
condition|(
name|ffebad_start
argument_list|(
name|FFEBAD_BAD_SUBSTR
argument_list|)
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|ctx
argument_list|,
name|ffeexpr_token_anything_
argument_list|)
return|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|ctx
argument_list|,
name|ffeexpr_token_substring_
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_intrincheck_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|!=
name|FFELEX_typeCLOSE_PAREN
operator|)
operator|&&
name|ffebad_start
argument_list|(
name|FFEBAD_INTRINSIC_CMPAMBIG
argument_list|)
condition|)
block|{
name|ffebad_string
argument_list|(
name|ffeintrin_name_implementation
argument_list|(
name|ffebld_symter_implementation
argument_list|(
name|ffebld_left
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|u
operator|.
name|operand
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_substrp_
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_funsubstr_ -- NAME OPEN_PAREN expr     Return a pointer to this function to the lexer (ffelex), which will    invoke it for the next token.     If COLON, do everything we would have done since _parenthesized_ if    we had known NAME represented a kindENTITY instead of a kindFUNCTION.    If not COLON, do likewise for kindFUNCTION instead.	*/
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_funsubstr_
parameter_list|(
name|ffelexToken
name|ft
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeinfoWhere
name|where
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffebld
name|symter
init|=
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|u
operator|.
name|operand
decl_stmt|;
name|bool
name|needs_type
decl_stmt|;
name|ffeintrinGen
name|gen
decl_stmt|;
name|ffeintrinSpec
name|spec
decl_stmt|;
name|ffeintrinImp
name|imp
decl_stmt|;
name|s
operator|=
name|ffebld_symter
argument_list|(
name|symter
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|where
operator|=
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* We get here only if we don't already know enough about FOO when seeing a      FOO(stuff) reference, and FOO might turn out to be a CHARACTER type.  If      "stuff" is a substring reference, then FOO is a CHARACTER scalar type.      Else FOO is a function, either intrinsic or external.  If intrinsic, it      wouldn't necessarily be CHARACTER type, so unless it has already been      declared DUMMY, it hasn't had its type established yet.  It can't be      CHAR*(*) in any case, though it can have an explicit CHAR*n type.  */
name|assert
argument_list|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|needs_type
operator|=
operator|!
operator|(
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
operator|&
name|FFESYMBOL_attrsDUMMY
operator|)
expr_stmt|;
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Probably already done, but in case.... */
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCOLON
condition|)
block|{
comment|/* Definitely an ENTITY (char substring). */
if|if
condition|(
name|needs_type
operator|&&
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_arguments_
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
return|;
block|}
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
operator|(
name|where
operator|==
name|FFEINFO_whereNONE
operator|)
condition|?
name|FFEINFO_whereLOCAL
else|:
name|where
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|symter
argument_list|,
name|ffeinfo_use
argument_list|(
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
name|ffeexpr_stack_
operator|->
name|exprstack
operator|->
name|u
operator|.
name|operand
operator|=
name|ffeexpr_collapse_symter
argument_list|(
name|symter
argument_list|,
name|ffeexpr_tokens_
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_substring_
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
return|;
block|}
comment|/* The "stuff" isn't a substring notation, so we now know the overall      reference is to a function.  */
if|if
condition|(
name|ffeintrin_is_intrinsic
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|,
name|FALSE
argument_list|,
operator|&
name|gen
argument_list|,
operator|&
name|spec
argument_list|,
operator|&
name|imp
argument_list|)
condition|)
block|{
name|ffebld_symter_set_generic
argument_list|(
name|symter
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|ffebld_symter_set_specific
argument_list|(
name|symter
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|ffebld_symter_set_implementation
argument_list|(
name|symter
argument_list|,
name|imp
argument_list|)
expr_stmt|;
name|ffesymbol_set_generic
argument_list|(
name|s
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|ffesymbol_set_specific
argument_list|(
name|s
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|ffesymbol_set_implementation
argument_list|(
name|s
argument_list|,
name|imp
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindFUNCTION
argument_list|,
name|FFEINFO_whereINTRINSIC
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not intrinsic, now needs CHAR type. */
if|if
condition|(
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_arguments_
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
return|;
block|}
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
name|FFEINFO_kindFUNCTION
argument_list|,
operator|(
name|where
operator|==
name|FFEINFO_whereNONE
operator|)
condition|?
name|FFEINFO_whereGLOBAL
else|:
name|where
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffebld_set_info
argument_list|(
name|symter
argument_list|,
name|ffeinfo_use
argument_list|(
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* For debugging purposes. */
name|ffebld_init_list
argument_list|(
operator|&
name|ffeexpr_stack_
operator|->
name|expr
argument_list|,
operator|&
name|ffeexpr_stack_
operator|->
name|bottom
argument_list|)
expr_stmt|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_arguments_
argument_list|(
name|ft
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeexpr_token_anything_ -- NAME OPEN_PAREN any-expr     Handle basically any expression, looking for CLOSE_PAREN.  */
end_comment

begin_function
specifier|static
name|ffelexHandler
name|ffeexpr_token_anything_
parameter_list|(
name|ffelexToken
name|ft
name|UNUSED
parameter_list|,
name|ffebld
name|expr
name|UNUSED
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffeexprExpr_
name|e
init|=
name|ffeexpr_stack_
operator|->
name|exprstack
decl_stmt|;
switch|switch
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FFELEX_typeCOMMA
case|:
case|case
name|FFELEX_typeCOLON
case|:
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_rhs
argument_list|(
name|ffeexpr_stack_
operator|->
name|pool
argument_list|,
name|FFEEXPR_contextACTUALARG_
argument_list|,
name|ffeexpr_token_anything_
argument_list|)
return|;
default|default:
name|e
operator|->
name|u
operator|.
name|operand
operator|=
name|ffebld_new_any
argument_list|()
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
operator|->
name|u
operator|.
name|operand
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffeexpr_stack_
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffeexpr_is_substr_ok_
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeCLOSE_PAREN
condition|)
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_substrp_
return|;
return|return
operator|(
name|ffelexHandler
operator|)
name|ffeexpr_token_substrp_
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Terminate module.  */
end_comment

begin_function
name|void
name|ffeexpr_terminate_2
parameter_list|()
block|{
name|assert
argument_list|(
name|ffeexpr_stack_
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeexpr_level_
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

