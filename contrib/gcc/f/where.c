begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* where.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995, 2002, 2003 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:     Description:       Simple data abstraction for Fortran source lines (called card images).     Modifications: */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"where.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_decl_stmt
name|struct
name|_ffewhere_line_
name|ffewhere_unknown_line_
init|=
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|_ffewhere_ll_
modifier|*
name|ffewhereLL_
typedef|;
end_typedef

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_decl_stmt
name|struct
name|_ffewhere_ll_
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|ffewhereLL_
name|next
decl_stmt|;
name|ffewhereLL_
name|previous
decl_stmt|;
name|ffewhereFile
name|wf
decl_stmt|;
name|ffewhereLineNumber
name|line_no
decl_stmt|;
comment|/* ffelex_line_number() at time of creation. */
name|ffewhereLineNumber
name|offset
decl_stmt|;
comment|/* User-desired offset (usually 1). */
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|struct
name|_ffewhere_root_ll_
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|ffewhereLL_
name|first
decl_stmt|;
name|ffewhereLL_
name|last
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|_ffewhere_root_line_
block|{
name|ffewhereLine
name|first
decl_stmt|;
name|ffewhereLine
name|last
decl_stmt|;
name|ffewhereLineNumber
name|none
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|_ffewhere_root_ll_
operator|*
name|ffewhere_root_ll_
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|_ffewhere_root_line_
name|ffewhere_root_line_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_function_decl
specifier|static
name|ffewhereLL_
name|ffewhere_ll_lookup_
parameter_list|(
name|ffewhereLineNumber
name|ln
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Internal macros. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Look up line-to-line object from absolute line num.  */
end_comment

begin_function
specifier|static
name|ffewhereLL_
name|ffewhere_ll_lookup_
parameter_list|(
name|ffewhereLineNumber
name|ln
parameter_list|)
block|{
name|ffewhereLL_
name|ll
decl_stmt|;
if|if
condition|(
name|ln
operator|==
literal|0
condition|)
return|return
name|ffewhere_root_ll_
operator|->
name|first
return|;
for|for
control|(
name|ll
operator|=
name|ffewhere_root_ll_
operator|->
name|last
init|;
name|ll
operator|!=
operator|(
name|ffewhereLL_
operator|)
operator|&
name|ffewhere_root_ll_
operator|->
name|first
condition|;
name|ll
operator|=
name|ll
operator|->
name|previous
control|)
block|{
if|if
condition|(
name|ll
operator|->
name|line_no
operator|<=
name|ln
condition|)
return|return
name|ll
return|;
block|}
name|assert
argument_list|(
literal|"no line num"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Create file object.  */
end_comment

begin_function
name|ffewhereFile
name|ffewhere_file_new
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|ffewhereFile
name|wf
decl_stmt|;
name|wf
operator|=
name|ggc_alloc
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|_ffewhere_file_
argument_list|,
name|text
argument_list|)
operator|+
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|wf
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|wf
operator|->
name|text
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|wf
operator|->
name|text
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|wf
return|;
block|}
end_function

begin_comment
comment|/* Set file and first line number.     Pass FALSE if no line number is specified.  */
end_comment

begin_function
name|void
name|ffewhere_file_set
parameter_list|(
name|ffewhereFile
name|wf
parameter_list|,
name|bool
name|have_num
parameter_list|,
name|ffewhereLineNumber
name|ln
parameter_list|)
block|{
name|ffewhereLL_
name|ll
decl_stmt|;
name|ll
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ll
argument_list|)
argument_list|)
expr_stmt|;
name|ll
operator|->
name|next
operator|=
operator|(
name|ffewhereLL_
operator|)
operator|&
name|ffewhere_root_ll_
operator|->
name|first
expr_stmt|;
name|ll
operator|->
name|previous
operator|=
name|ffewhere_root_ll_
operator|->
name|last
expr_stmt|;
name|ll
operator|->
name|next
operator|->
name|previous
operator|=
name|ll
expr_stmt|;
name|ll
operator|->
name|previous
operator|->
name|next
operator|=
name|ll
expr_stmt|;
if|if
condition|(
name|wf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ll
operator|->
name|previous
operator|==
name|ll
operator|->
name|next
condition|)
name|ll
operator|->
name|wf
operator|=
name|NULL
expr_stmt|;
else|else
name|ll
operator|->
name|wf
operator|=
name|ll
operator|->
name|previous
operator|->
name|wf
expr_stmt|;
block|}
else|else
name|ll
operator|->
name|wf
operator|=
name|wf
expr_stmt|;
name|ll
operator|->
name|line_no
operator|=
name|ffelex_line_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|have_num
condition|)
name|ll
operator|->
name|offset
operator|=
name|ln
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ll
operator|->
name|previous
operator|==
name|ll
operator|->
name|next
condition|)
name|ll
operator|->
name|offset
operator|=
literal|1
expr_stmt|;
else|else
name|ll
operator|->
name|offset
operator|=
name|ll
operator|->
name|line_no
operator|-
name|ll
operator|->
name|previous
operator|->
name|line_no
operator|+
name|ll
operator|->
name|previous
operator|->
name|offset
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do initializations.  */
end_comment

begin_function
name|void
name|ffewhere_init_1
parameter_list|(
name|void
parameter_list|)
block|{
name|ffewhere_root_line_
operator|.
name|first
operator|=
name|ffewhere_root_line_
operator|.
name|last
operator|=
operator|(
name|ffewhereLine
operator|)
operator|&
name|ffewhere_root_line_
operator|.
name|first
expr_stmt|;
name|ffewhere_root_line_
operator|.
name|none
operator|=
literal|0
expr_stmt|;
comment|/* The sentinel is (must be) GGC-allocated.  It is accessed as a      struct _ffewhere_ll_/ffewhereLL_ though its type contains just the      first two fields (layout-wise).  */
name|ffewhere_root_ll_
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_ffewhere_ll_
argument_list|)
argument_list|)
expr_stmt|;
name|ffewhere_root_ll_
operator|->
name|first
operator|=
name|ffewhere_root_ll_
operator|->
name|last
operator|=
operator|(
name|ffewhereLL_
operator|)
operator|&
name|ffewhere_root_ll_
operator|->
name|first
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the textual content of the line.  */
end_comment

begin_function
name|char
modifier|*
name|ffewhere_line_content
parameter_list|(
name|ffewhereLine
name|wl
parameter_list|)
block|{
name|assert
argument_list|(
name|wl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|wl
operator|->
name|content
return|;
block|}
end_function

begin_comment
comment|/* Look up file object from line object.  */
end_comment

begin_function
name|ffewhereFile
name|ffewhere_line_file
parameter_list|(
name|ffewhereLine
name|wl
parameter_list|)
block|{
name|ffewhereLL_
name|ll
decl_stmt|;
name|assert
argument_list|(
name|wl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ll
operator|=
name|ffewhere_ll_lookup_
argument_list|(
name|wl
operator|->
name|line_num
argument_list|)
expr_stmt|;
return|return
name|ll
operator|->
name|wf
return|;
block|}
end_function

begin_comment
comment|/* Lookup file object from line object, calc line#.  */
end_comment

begin_function
name|ffewhereLineNumber
name|ffewhere_line_filelinenum
parameter_list|(
name|ffewhereLine
name|wl
parameter_list|)
block|{
name|ffewhereLL_
name|ll
decl_stmt|;
name|assert
argument_list|(
name|wl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ll
operator|=
name|ffewhere_ll_lookup_
argument_list|(
name|wl
operator|->
name|line_num
argument_list|)
expr_stmt|;
return|return
name|wl
operator|->
name|line_num
operator|+
name|ll
operator|->
name|offset
operator|-
name|ll
operator|->
name|line_no
return|;
block|}
end_function

begin_comment
comment|/* Decrement use count for line, deallocate if no uses left.  */
end_comment

begin_function
name|void
name|ffewhere_line_kill
parameter_list|(
name|ffewhereLine
name|wl
parameter_list|)
block|{
if|#
directive|if
literal|0
block|if (!ffewhere_line_is_unknown (wl))     fprintf (dmpout, "; ffewhere_line_kill %" ffewhereLineNumber_f "u, uses=%" 	     ffewhereUses_f_ "u\n", 	     wl->line_num, wl->uses);
endif|#
directive|endif
name|assert
argument_list|(
name|ffewhere_line_is_unknown
argument_list|(
name|wl
argument_list|)
operator|||
operator|(
name|wl
operator|->
name|uses
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffewhere_line_is_unknown
argument_list|(
name|wl
argument_list|)
operator|&&
operator|(
operator|--
name|wl
operator|->
name|uses
operator|==
literal|0
operator|)
condition|)
block|{
name|wl
operator|->
name|previous
operator|->
name|next
operator|=
name|wl
operator|->
name|next
expr_stmt|;
name|wl
operator|->
name|next
operator|->
name|previous
operator|=
name|wl
operator|->
name|previous
expr_stmt|;
name|malloc_kill_ks
argument_list|(
name|ffe_pool_file
argument_list|()
argument_list|,
name|wl
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|_ffewhere_line_
argument_list|,
name|content
argument_list|)
operator|+
name|wl
operator|->
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make a new line or increment use count of existing one.     Find out where line object is, if anywhere.	If in lexer, it might also    be at the end of the list of lines, else put it on the end of the list.    Then, if in the list of lines, increment the use count and return the    line object.	 Else, make an empty line object (no line) and return    that.  */
end_comment

begin_function
name|ffewhereLine
name|ffewhere_line_new
parameter_list|(
name|ffewhereLineNumber
name|ln
parameter_list|)
block|{
name|ffewhereLine
name|wl
init|=
name|ffewhere_root_line_
operator|.
name|last
decl_stmt|;
comment|/* If this is the lexer's current line, see if it is already at the end of      the list, and if not, make it and return it. */
if|if
condition|(
operator|(
operator|(
name|ln
operator|==
literal|0
operator|)
comment|/* Presumably asking for EOF pointer. */
operator|||
operator|(
name|wl
operator|->
name|line_num
operator|!=
name|ln
operator|)
operator|)
operator|&&
operator|(
name|ffelex_line_number
argument_list|()
operator|==
name|ln
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|fprintf (dmpout, 	       "; ffewhere_line_new %" ffewhereLineNumber_f "u, lexer\n", 	       ln);
endif|#
directive|endif
name|wl
operator|=
name|malloc_new_ks
argument_list|(
name|ffe_pool_file
argument_list|()
argument_list|,
literal|"FFEWHERE line"
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|_ffewhere_line_
argument_list|,
name|content
argument_list|)
operator|+
operator|(
name|size_t
operator|)
name|ffelex_line_length
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|wl
operator|->
name|next
operator|=
operator|(
name|ffewhereLine
operator|)
operator|&
name|ffewhere_root_line_
expr_stmt|;
name|wl
operator|->
name|previous
operator|=
name|ffewhere_root_line_
operator|.
name|last
expr_stmt|;
name|wl
operator|->
name|previous
operator|->
name|next
operator|=
name|wl
expr_stmt|;
name|wl
operator|->
name|next
operator|->
name|previous
operator|=
name|wl
expr_stmt|;
name|wl
operator|->
name|line_num
operator|=
name|ln
expr_stmt|;
name|wl
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|wl
operator|->
name|length
operator|=
name|ffelex_line_length
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|wl
operator|->
name|content
argument_list|,
name|ffelex_line
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|wl
return|;
block|}
comment|/* See if line is on list already. */
while|while
condition|(
name|wl
operator|->
name|line_num
operator|>
name|ln
condition|)
name|wl
operator|=
name|wl
operator|->
name|previous
expr_stmt|;
comment|/* If line is there, increment its use count and return. */
if|if
condition|(
name|wl
operator|->
name|line_num
operator|==
name|ln
condition|)
block|{
if|#
directive|if
literal|0
block|fprintf (dmpout, "; ffewhere_line_new %" ffewhereLineNumber_f "u, uses=%" 	       ffewhereUses_f_ "u\n", ln, 	       wl->uses);
endif|#
directive|endif
name|wl
operator|->
name|uses
operator|++
expr_stmt|;
return|return
name|wl
return|;
block|}
comment|/* Else, make a new one with a blank line (since we've obviously lost it,      which should never happen) and return it. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(Cannot resurrect line %lu for error reporting purposes.)\n"
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|wl
operator|=
name|malloc_new_ks
argument_list|(
name|ffe_pool_file
argument_list|()
argument_list|,
literal|"FFEWHERE line"
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|_ffewhere_line_
argument_list|,
name|content
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|wl
operator|->
name|next
operator|=
operator|(
name|ffewhereLine
operator|)
operator|&
name|ffewhere_root_line_
expr_stmt|;
name|wl
operator|->
name|previous
operator|=
name|ffewhere_root_line_
operator|.
name|last
expr_stmt|;
name|wl
operator|->
name|previous
operator|->
name|next
operator|=
name|wl
expr_stmt|;
name|wl
operator|->
name|next
operator|->
name|previous
operator|=
name|wl
expr_stmt|;
name|wl
operator|->
name|line_num
operator|=
name|ln
expr_stmt|;
name|wl
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|wl
operator|->
name|length
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|wl
operator|->
name|content
operator|)
operator|=
literal|'\0'
expr_stmt|;
return|return
name|wl
return|;
block|}
end_function

begin_comment
comment|/* Increment use count of line, as in a copy.  */
end_comment

begin_function
name|ffewhereLine
name|ffewhere_line_use
parameter_list|(
name|ffewhereLine
name|wl
parameter_list|)
block|{
if|#
directive|if
literal|0
block|fprintf (dmpout, "; ffewhere_line_use %" ffewhereLineNumber_f "u, uses=%" ffewhereUses_f_ 	   "u\n", wl->line_num, wl->uses);
endif|#
directive|endif
name|assert
argument_list|(
name|ffewhere_line_is_unknown
argument_list|(
name|wl
argument_list|)
operator|||
operator|(
name|wl
operator|->
name|uses
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffewhere_line_is_unknown
argument_list|(
name|wl
argument_list|)
condition|)
operator|++
name|wl
operator|->
name|uses
expr_stmt|;
return|return
name|wl
return|;
block|}
end_function

begin_comment
comment|/* Set an ffewhere object based on a track index.     Determines the absolute line and column number of a character at a given    index into an ffewhereTrack array.  wr* is the reference position, wt is    the tracking information, and i is the index desired.  wo* is set to wr*    plus the continual offsets described by wt[0...i-1], or unknown if any of    the continual offsets are not known.	 */
end_comment

begin_function
name|void
name|ffewhere_set_from_track
parameter_list|(
name|ffewhereLine
modifier|*
name|wol
parameter_list|,
name|ffewhereColumn
modifier|*
name|woc
parameter_list|,
name|ffewhereLine
name|wrl
parameter_list|,
name|ffewhereColumn
name|wrc
parameter_list|,
name|ffewhereTrack
name|wt
parameter_list|,
name|ffewhereIndex
name|i
parameter_list|)
block|{
name|ffewhereLineNumber
name|ln
decl_stmt|;
name|ffewhereColumnNumber
name|cn
decl_stmt|;
name|ffewhereIndex
name|j
decl_stmt|;
name|ffewhereIndex
name|k
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
operator|(
name|i
operator|>=
name|FFEWHERE_indexMAX
operator|)
condition|)
block|{
operator|*
name|wol
operator|=
name|ffewhere_line_use
argument_list|(
name|wrl
argument_list|)
expr_stmt|;
operator|*
name|woc
operator|=
name|ffewhere_column_use
argument_list|(
name|wrc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|=
name|ffewhere_line_number
argument_list|(
name|wrl
argument_list|)
expr_stmt|;
name|cn
operator|=
name|ffewhere_column_number
argument_list|(
name|wrc
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
operator|,
name|k
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|wt
index|[
name|k
index|]
operator|==
name|FFEWHERE_indexUNKNOWN
operator|)
operator|||
operator|(
name|wt
index|[
name|k
operator|+
literal|1
index|]
operator|==
name|FFEWHERE_indexUNKNOWN
operator|)
condition|)
block|{
operator|*
name|wol
operator|=
name|ffewhere_line_unknown
argument_list|()
expr_stmt|;
operator|*
name|woc
operator|=
name|ffewhere_column_unknown
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wt
index|[
name|k
index|]
operator|==
literal|0
condition|)
name|cn
operator|+=
name|wt
index|[
name|k
operator|+
literal|1
index|]
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|ln
operator|+=
name|wt
index|[
name|k
index|]
expr_stmt|;
name|cn
operator|=
name|wt
index|[
name|k
operator|+
literal|1
index|]
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ln
operator|==
name|ffewhere_line_number
argument_list|(
name|wrl
argument_list|)
condition|)
block|{
comment|/* Already have the line object, just use it 				   directly. */
operator|*
name|wol
operator|=
name|ffewhere_line_use
argument_list|(
name|wrl
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Must search for the line object. */
operator|*
name|wol
operator|=
name|ffewhere_line_new
argument_list|(
name|ln
argument_list|)
expr_stmt|;
operator|*
name|woc
operator|=
name|ffewhere_column_new
argument_list|(
name|cn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build next tracking index.     Set wt[i-1] continual offset so that it offsets from w* to (ln,cn).	Update    w* to contain (ln,cn).  DO NOT call this routine if i>= FFEWHERE_indexMAX    or i == 0.  */
end_comment

begin_function
name|void
name|ffewhere_track
parameter_list|(
name|ffewhereLine
modifier|*
name|wl
parameter_list|,
name|ffewhereColumn
modifier|*
name|wc
parameter_list|,
name|ffewhereTrack
name|wt
parameter_list|,
name|ffewhereIndex
name|i
parameter_list|,
name|ffewhereLineNumber
name|ln
parameter_list|,
name|ffewhereColumnNumber
name|cn
parameter_list|)
block|{
name|unsigned
name|int
name|lo
decl_stmt|;
name|unsigned
name|int
name|co
decl_stmt|;
if|if
condition|(
operator|(
name|ffewhere_line_is_unknown
argument_list|(
operator|*
name|wl
argument_list|)
operator|)
operator|||
operator|(
name|ffewhere_column_is_unknown
argument_list|(
operator|*
name|wc
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|lo
operator|=
name|ln
operator|-
name|ffewhere_line_number
argument_list|(
operator|*
name|wl
argument_list|)
operator|)
operator|>=
name|FFEWHERE_indexUNKNOWN
operator|)
condition|)
block|{
name|wt
index|[
name|i
operator|*
literal|2
operator|-
literal|2
index|]
operator|=
name|wt
index|[
name|i
operator|*
literal|2
operator|-
literal|1
index|]
operator|=
name|FFEWHERE_indexUNKNOWN
expr_stmt|;
name|ffewhere_line_kill
argument_list|(
operator|*
name|wl
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
operator|*
name|wc
argument_list|)
expr_stmt|;
operator|*
name|wl
operator|=
name|FFEWHERE_lineUNKNOWN
expr_stmt|;
operator|*
name|wc
operator|=
name|FFEWHERE_columnUNKNOWN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lo
operator|==
literal|0
condition|)
block|{
name|wt
index|[
name|i
operator|*
literal|2
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|co
operator|=
name|cn
operator|-
name|ffewhere_column_number
argument_list|(
operator|*
name|wc
argument_list|)
operator|)
operator|>
name|FFEWHERE_indexUNKNOWN
condition|)
block|{
name|wt
index|[
name|i
operator|*
literal|2
operator|-
literal|1
index|]
operator|=
name|FFEWHERE_indexUNKNOWN
expr_stmt|;
name|ffewhere_line_kill
argument_list|(
operator|*
name|wl
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
operator|*
name|wc
argument_list|)
expr_stmt|;
operator|*
name|wl
operator|=
name|FFEWHERE_lineUNKNOWN
expr_stmt|;
operator|*
name|wc
operator|=
name|FFEWHERE_columnUNKNOWN
expr_stmt|;
block|}
else|else
block|{
name|wt
index|[
name|i
operator|*
literal|2
operator|-
literal|1
index|]
operator|=
name|co
operator|-
literal|1
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
operator|*
name|wc
argument_list|)
expr_stmt|;
operator|*
name|wc
operator|=
name|ffewhere_column_use
argument_list|(
name|ffewhere_column_new
argument_list|(
name|cn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|wt
index|[
name|i
operator|*
literal|2
operator|-
literal|2
index|]
operator|=
name|lo
expr_stmt|;
name|wt
index|[
name|i
operator|*
literal|2
operator|-
literal|1
index|]
operator|=
name|cn
operator|-
literal|1
expr_stmt|;
name|ffewhere_line_kill
argument_list|(
operator|*
name|wl
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
operator|*
name|wc
argument_list|)
expr_stmt|;
operator|*
name|wl
operator|=
name|ffewhere_line_use
argument_list|(
name|ffewhere_line_new
argument_list|(
name|ln
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|wc
operator|=
name|ffewhere_column_use
argument_list|(
name|ffewhere_column_new
argument_list|(
name|cn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear tracking index for internally created track.     Set the tracking information to indicate that the tracking is at its    simplest (no spaces or newlines within the tracking).  This means set    everything to zero in the current implementation.  Length is the total    length of the token; length must be 2 or greater, since length-1 tracking    characters are set.	*/
end_comment

begin_function
name|void
name|ffewhere_track_clear
parameter_list|(
name|ffewhereTrack
name|wt
parameter_list|,
name|ffewhereIndex
name|length
parameter_list|)
block|{
name|ffewhereIndex
name|i
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|FFEWHERE_indexMAX
condition|)
name|length
operator|=
name|FFEWHERE_indexMAX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
name|wt
index|[
name|i
operator|*
literal|2
operator|-
literal|2
index|]
operator|=
name|wt
index|[
name|i
operator|*
literal|2
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy tracking index from one place to another.     Copy tracking information from swt[start] to dwt[0] and so on, presumably    after an ffewhere_set_from_track call.  Length is the total    length of the token; length must be 2 or greater, since length-1 tracking    characters are set.	*/
end_comment

begin_function
name|void
name|ffewhere_track_copy
parameter_list|(
name|ffewhereTrack
name|dwt
parameter_list|,
name|ffewhereTrack
name|swt
parameter_list|,
name|ffewhereIndex
name|start
parameter_list|,
name|ffewhereIndex
name|length
parameter_list|)
block|{
name|ffewhereIndex
name|i
decl_stmt|;
name|ffewhereIndex
name|copy
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|FFEWHERE_indexMAX
condition|)
name|length
operator|=
name|FFEWHERE_indexMAX
expr_stmt|;
if|if
condition|(
name|length
operator|+
name|start
operator|>
name|FFEWHERE_indexMAX
condition|)
name|copy
operator|=
name|FFEWHERE_indexMAX
operator|-
name|start
expr_stmt|;
else|else
name|copy
operator|=
name|length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|copy
condition|;
operator|++
name|i
control|)
block|{
name|dwt
index|[
name|i
operator|*
literal|2
operator|-
literal|2
index|]
operator|=
name|swt
index|[
operator|(
name|i
operator|+
name|start
operator|)
operator|*
literal|2
operator|-
literal|2
index|]
expr_stmt|;
name|dwt
index|[
name|i
operator|*
literal|2
operator|-
literal|1
index|]
operator|=
name|swt
index|[
operator|(
name|i
operator|+
name|start
operator|)
operator|*
literal|2
operator|-
literal|1
index|]
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
name|dwt
index|[
name|i
operator|*
literal|2
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|dwt
index|[
name|i
operator|*
literal|2
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Kill tracking data.     Kill all the tracking information by killing incremented lines from the    first line number.  */
end_comment

begin_function
name|void
name|ffewhere_track_kill
parameter_list|(
name|ffewhereLine
name|wrl
parameter_list|,
name|ffewhereColumn
name|wrc
name|UNUSED
parameter_list|,
name|ffewhereTrack
name|wt
parameter_list|,
name|ffewhereIndex
name|length
parameter_list|)
block|{
name|ffewhereLineNumber
name|ln
decl_stmt|;
name|unsigned
name|int
name|lo
decl_stmt|;
name|ffewhereIndex
name|i
decl_stmt|;
name|ln
operator|=
name|ffewhere_line_number
argument_list|(
name|wrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|FFEWHERE_indexMAX
condition|)
name|length
operator|=
name|FFEWHERE_indexMAX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|lo
operator|=
name|wt
index|[
name|i
operator|*
literal|2
index|]
operator|)
operator|==
name|FFEWHERE_indexUNKNOWN
condition|)
break|break;
elseif|else
if|if
condition|(
name|lo
operator|!=
literal|0
condition|)
block|{
name|ln
operator|+=
name|lo
expr_stmt|;
name|wrl
operator|=
name|ffewhere_line_new
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|ffewhere_line_kill
argument_list|(
name|wrl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"gt-f-where.h"
end_include

end_unit

