begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* implic.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       None.     Description:       The GNU Fortran Front End.     Modifications: */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"implic.h"
end_include

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"src.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|FFEIMPLIC_stateINITIAL_
block|,
name|FFEIMPLIC_stateASSUMED_
block|,
name|FFEIMPLIC_stateESTABLISHED_
block|,
name|FFEIMPLIC_state
block|}
name|ffeimplicState_
typedef|;
end_typedef

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|_ffeimplic_
modifier|*
name|ffeimplic_
typedef|;
end_typedef

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_struct
struct|struct
name|_ffeimplic_
block|{
name|ffeimplicState_
name|state
decl_stmt|;
name|ffeinfo
name|info
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_comment
comment|/* NOTE: This is definitely ASCII-specific!!  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|_ffeimplic_
name|ffeimplic_table_
index|[
literal|'z'
operator|-
literal|'A'
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_function_decl
specifier|static
name|ffeimplic_
name|ffeimplic_lookup_
parameter_list|(
name|unsigned
name|char
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Internal macros. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* ffeimplic_lookup_ -- Look up implicit descriptor for initial character     ffeimplic_ imp;    if ((imp = ffeimplic_lookup_('A')) == NULL)        // error     Returns a pointer to an implicit descriptor block based on the character    passed, or NULL if it is not a valid initial character for an implicit    data type.  */
end_comment

begin_function
specifier|static
name|ffeimplic_
name|ffeimplic_lookup_
parameter_list|(
name|unsigned
name|char
name|c
parameter_list|)
block|{
comment|/* NOTE: This is definitely ASCII-specific!!  */
if|if
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|c
operator|==
literal|'_'
operator|)
condition|)
return|return
operator|&
name|ffeimplic_table_
index|[
name|c
operator|-
literal|'A'
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ffeimplic_establish_initial -- Establish type of implicit initial letter     ffesymbol s;    if (!ffeimplic_establish_initial(s))        // error     Assigns implicit type information to the symbol based on the first    character of the symbol's name.  */
end_comment

begin_function
name|bool
name|ffeimplic_establish_initial
parameter_list|(
name|char
name|c
parameter_list|,
name|ffeinfoBasictype
name|basic_type
parameter_list|,
name|ffeinfoKindtype
name|kind_type
parameter_list|,
name|ffetargetCharacterSize
name|size
parameter_list|)
block|{
name|ffeimplic_
name|imp
decl_stmt|;
name|imp
operator|=
name|ffeimplic_lookup_
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Character not A-Z or some such thing. */
if|if
condition|(
name|ffeinfo_basictype
argument_list|(
name|imp
operator|->
name|info
argument_list|)
operator|==
name|FFEINFO_basictypeNONE
condition|)
return|return
name|FALSE
return|;
comment|/* IMPLICIT NONE in effect here. */
switch|switch
condition|(
name|imp
operator|->
name|state
condition|)
block|{
case|case
name|FFEIMPLIC_stateINITIAL_
case|:
name|imp
operator|->
name|info
operator|=
name|ffeinfo_new
argument_list|(
name|basic_type
argument_list|,
name|kind_type
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindNONE
argument_list|,
name|FFEINFO_whereNONE
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|imp
operator|->
name|state
operator|=
name|FFEIMPLIC_stateESTABLISHED_
expr_stmt|;
return|return
name|TRUE
return|;
case|case
name|FFEIMPLIC_stateASSUMED_
case|:
if|if
condition|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|imp
operator|->
name|info
argument_list|)
operator|!=
name|basic_type
operator|)
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|imp
operator|->
name|info
argument_list|)
operator|!=
name|kind_type
operator|)
operator|||
operator|(
name|ffeinfo_size
argument_list|(
name|imp
operator|->
name|info
argument_list|)
operator|!=
name|size
operator|)
condition|)
return|return
name|FALSE
return|;
name|imp
operator|->
name|state
operator|=
name|FFEIMPLIC_stateESTABLISHED_
expr_stmt|;
return|return
name|TRUE
return|;
case|case
name|FFEIMPLIC_stateESTABLISHED_
case|:
return|return
name|FALSE
return|;
default|default:
name|assert
argument_list|(
literal|"Weird state for implicit object"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffeimplic_establish_symbol -- Establish implicit type of a symbol     ffesymbol s;    if (!ffeimplic_establish_symbol(s))        // error     Assigns implicit type information to the symbol based on the first    character of the symbol's name.     If symbol already has a type, return TRUE.    Get first character of symbol's name.    Get ffeimplic_ object for it (return FALSE if NULL returned).    Return FALSE if object has no assigned type (IMPLICIT NONE).    Copy the type information from the object to the symbol.    If the object is state "INITIAL", set to state "ASSUMED" so no        subsequent IMPLICIT statement may change the state.    Return TRUE.	 */
end_comment

begin_function
name|bool
name|ffeimplic_establish_symbol
parameter_list|(
name|ffesymbol
name|s
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|ffeimplic_
name|imp
decl_stmt|;
if|if
condition|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_basictypeNONE
condition|)
return|return
name|TRUE
return|;
name|c
operator|=
operator|*
operator|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
operator|)
expr_stmt|;
name|imp
operator|=
name|ffeimplic_lookup_
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* First character not A-Z or some such 				   thing. */
if|if
condition|(
name|ffeinfo_basictype
argument_list|(
name|imp
operator|->
name|info
argument_list|)
operator|==
name|FFEINFO_basictypeNONE
condition|)
return|return
name|FALSE
return|;
comment|/* IMPLICIT NONE in effect here. */
name|ffesymbol_signal_change
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Gonna change, save existing? */
comment|/* Establish basictype, kindtype, size; preserve rank, kind, where. */
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|imp
operator|->
name|info
argument_list|)
argument_list|,
name|ffeinfo_kindtype
argument_list|(
name|imp
operator|->
name|info
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffeinfo_size
argument_list|(
name|imp
operator|->
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp
operator|->
name|state
operator|==
name|FFEIMPLIC_stateINITIAL_
condition|)
name|imp
operator|->
name|state
operator|=
name|FFEIMPLIC_stateASSUMED_
expr_stmt|;
if|if
condition|(
name|ffe_is_warn_implicit
argument_list|()
condition|)
block|{
name|ffebad_start_msg
argument_list|(
literal|"Implicit declaration of `%A' at %0"
argument_list|,
name|FFEBAD_severityWARNING
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffesymbol_where_line
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where_column
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ffeimplic_init_2 -- Initialize table     ffeimplic_init_2();     Assigns initial type information to all initial letters.     Allows for holes in the sequence of letters (i.e. EBCDIC).  */
end_comment

begin_function
name|void
name|ffeimplic_init_2
parameter_list|()
block|{
name|ffeimplic_
name|imp
decl_stmt|;
name|char
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|'A'
init|;
name|c
operator|<=
literal|'z'
condition|;
operator|++
name|c
control|)
block|{
name|imp
operator|=
operator|&
name|ffeimplic_table_
index|[
name|c
operator|-
literal|'A'
index|]
expr_stmt|;
name|imp
operator|->
name|state
operator|=
name|FFEIMPLIC_stateINITIAL_
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
name|imp
operator|->
name|info
operator|=
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeREAL
argument_list|,
name|FFEINFO_kindtypeREALDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindNONE
argument_list|,
name|FFEINFO_whereNONE
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
name|imp
operator|->
name|info
operator|=
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindNONE
argument_list|,
name|FFEINFO_whereNONE
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|imp
operator|->
name|info
operator|=
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindNONE
argument_list|,
name|FFEINFO_whereNONE
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ffeimplic_none -- Implement IMPLICIT NONE statement     ffeimplic_none();     Assigns null type information to all initial letters.  */
end_comment

begin_function
name|void
name|ffeimplic_none
parameter_list|()
block|{
name|ffeimplic_
name|imp
decl_stmt|;
for|for
control|(
name|imp
operator|=
operator|&
name|ffeimplic_table_
index|[
literal|0
index|]
init|;
name|imp
operator|!=
operator|&
name|ffeimplic_table_
index|[
name|ARRAY_SIZE
argument_list|(
name|ffeimplic_table_
argument_list|)
index|]
condition|;
name|imp
operator|++
control|)
block|{
name|imp
operator|->
name|info
operator|=
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindNONE
argument_list|,
name|FFEINFO_whereNONE
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffeimplic_peek_symbol_type -- Determine implicit type of a symbol     ffesymbol s;    const char *name; // name for s in case it is NULL, or NULL if s never NULL    if (ffeimplic_peek_symbol_type(s,name) == FFEINFO_basictypeCHARACTER)        // is or will be a CHARACTER-typed name     Like establish_symbol, but doesn't change anything.     If symbol is non-NULL and already has a type, return it.    Get first character of symbol's name or from name arg if symbol is NULL.    Get ffeimplic_ object for it (return FALSE if NULL returned).    Return NONE if object has no assigned type (IMPLICIT NONE).    Return the data type indicated in the object.     24-Oct-91  JCB  2.0       Take a char * instead of ffelexToken, since the latter isn't always       needed anyway (as when ffecom calls it).	*/
end_comment

begin_function
name|ffeinfoBasictype
name|ffeimplic_peek_symbol_type
parameter_list|(
name|ffesymbol
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|ffeimplic_
name|imp
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|c
operator|=
operator|*
name|name
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_basictypeNONE
condition|)
return|return
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
return|;
name|c
operator|=
operator|*
operator|(
name|ffesymbol_text
argument_list|(
name|s
argument_list|)
operator|)
expr_stmt|;
block|}
name|imp
operator|=
name|ffeimplic_lookup_
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp
operator|==
name|NULL
condition|)
return|return
name|FFEINFO_basictypeNONE
return|;
comment|/* First character not A-Z or 					   something. */
return|return
name|ffeinfo_basictype
argument_list|(
name|imp
operator|->
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffeimplic_terminate_2 -- Terminate table     ffeimplic_terminate_2();     Kills info object for each entry in table.  */
end_comment

begin_function
name|void
name|ffeimplic_terminate_2
parameter_list|()
block|{ }
end_function

end_unit

