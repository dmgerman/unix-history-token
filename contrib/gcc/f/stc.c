begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* stc.c -- Implementation File (module.c template V1.0)    Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.    Contributed by James Craig Burley.  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:       st.c     Description:       Verifies the proper semantics for statements, checking expressions already       semantically analyzed individually, collectively, checking label defs and       refs, and so on.	Uses ffebad to indicate errors in semantics.        In many cases, both a token and a keyword (ffestrFirst, ffestrSecond,       or ffestrOther) is provided.  ONLY USE THE TOKEN as a pointer to the       source-code location for an error message or similar; use the keyword       as the semantic matching for the token, since the token's text might       not match the keyword's code.  For example, INTENT(IN OUT) A in free       source form passes to ffestc_R519_start the token "IN" but the keyword       FFESTR_otherINOUT, and the latter is correct.        Generally, either a single ffestc function handles an entire statement,       in which case its name is ffestc_xyz_, or more than one function is       needed, in which case its names are ffestc_xyz_start_,       ffestc_xyz_item_ or ffestc_xyz_item_abc_, and ffestc_xyz_finish_.       The caller must call _start_ before calling any _item_ functions, and       must call _finish_ afterwards.  If it is clearly a syntactic matter as       to restrictions on the number and variety of _item_ calls, then the caller       should report any errors and ffestc_ should presume it has been taken       care of and handle any semantic problems with grace and no error messages.       If the permitted number and variety of _item_ calls has some basis in       semantics, then the caller should not generate any messages and ffestc       should do all the checking.        A few ffestc functions have names rather than grammar numbers, like       ffestc_elsewhere and ffestc_end.	These are cases where the actual       statement depends on its context rather than just its form; ELSE WHERE       may be the obvious (WHERE...ELSE WHERE...END WHERE) or something a little       more subtle (WHERE: IF THEN...ELSE WHERE...END IF WHERE).	 The actual       ffestc functions do exist and do work, but may or may not be invoked       by ffestb depending on whether some form of resolution is possible.       For example, ffestc_R1103 end-program-stmt is reachable directly when       END PROGRAM [name] is specified, or via ffestc_end when END is specified       and the context is a main program.  So ffestc_xyz_ should make a quick       determination of the context and pick the appropriate ffestc_Nxyz_       function to invoke, without a lot of ceremony.     Modifications: */
end_comment

begin_comment
comment|/* Include files. */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"stc.h"
end_include

begin_include
include|#
directive|include
file|"bad.h"
end_include

begin_include
include|#
directive|include
file|"bld.h"
end_include

begin_include
include|#
directive|include
file|"data.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"implic.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"src.h"
end_include

begin_include
include|#
directive|include
file|"sta.h"
end_include

begin_include
include|#
directive|include
file|"std.h"
end_include

begin_include
include|#
directive|include
file|"stp.h"
end_include

begin_include
include|#
directive|include
file|"str.h"
end_include

begin_include
include|#
directive|include
file|"stt.h"
end_include

begin_include
include|#
directive|include
file|"stw.h"
end_include

begin_comment
comment|/* Externals defined here. */
end_comment

begin_decl_stmt
name|ffeexprContext
name|ffestc_iolist_context_
init|=
name|FFEEXPR_contextIOLIST
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Valid only from READ/WRITE start to finish. */
end_comment

begin_comment
comment|/* Simple definitions and enumerations. */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|FFESTC_orderOK_
block|,
comment|/* Statement ok in this context, process. */
name|FFESTC_orderBAD_
block|,
comment|/* Statement not ok in this context, don't 				   process. */
name|FFESTC_orderBADOK_
block|,
comment|/* Don't process but push block if 				   applicable. */
name|FFESTC
block|}
name|ffestcOrder_
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|FFESTC_stateletSIMPLE_
block|,
comment|/* Expecting simple/start. */
name|FFESTC_stateletATTRIB_
block|,
comment|/* Expecting attrib/item/itemstart. */
name|FFESTC_stateletITEM_
block|,
comment|/* Expecting item/itemstart/finish. */
name|FFESTC_stateletITEMVALS_
block|,
comment|/* Expecting itemvalue/itemendvals. */
name|FFESTC_
block|}
name|ffestcStatelet_
typedef|;
end_typedef

begin_comment
comment|/* Internal typedefs. */
end_comment

begin_comment
comment|/* Private include files. */
end_comment

begin_comment
comment|/* Internal structure definitions. */
end_comment

begin_union
union|union
name|ffestc_local_u_
block|{
struct|struct
block|{
name|ffebld
name|initlist
decl_stmt|;
comment|/* For list of one sym in INTEGER I/3/ case. */
name|ffetargetCharacterSize
name|stmt_size
decl_stmt|;
name|ffetargetCharacterSize
name|size
decl_stmt|;
name|ffeinfoBasictype
name|basic_type
decl_stmt|;
name|ffeinfoKindtype
name|stmt_kind_type
decl_stmt|;
name|ffeinfoKindtype
name|kind_type
decl_stmt|;
name|bool
name|per_var_kind_ok
decl_stmt|;
name|char
name|is_R426
decl_stmt|;
comment|/* 1=R426, 2=R501. */
block|}
name|decl
struct|;
struct|struct
block|{
name|ffebld
name|objlist
decl_stmt|;
comment|/* For list of target objects. */
name|ffebldListBottom
name|list_bottom
decl_stmt|;
comment|/* For building lists. */
block|}
name|data
struct|;
struct|struct
block|{
name|ffebldListBottom
name|list_bottom
decl_stmt|;
comment|/* For building lists. */
name|int
name|entry_num
decl_stmt|;
block|}
name|dummy
struct|;
struct|struct
block|{
name|ffesymbol
name|symbol
decl_stmt|;
comment|/* NML symbol. */
block|}
name|namelist
struct|;
struct|struct
block|{
name|ffelexToken
name|t
decl_stmt|;
comment|/* First token in list. */
name|ffeequiv
name|eq
decl_stmt|;
comment|/* Current equivalence being built up. */
name|ffebld
name|list
decl_stmt|;
comment|/* List of expressions in equivalence. */
name|ffebldListBottom
name|bottom
decl_stmt|;
name|bool
name|ok
decl_stmt|;
comment|/* TRUE while current list still being 				   processed. */
name|bool
name|save
decl_stmt|;
comment|/* TRUE if any var in list is SAVEd. */
block|}
name|equiv
struct|;
struct|struct
block|{
name|ffesymbol
name|symbol
decl_stmt|;
comment|/* BCB/NCB symbol. */
block|}
name|common
struct|;
struct|struct
block|{
name|ffesymbol
name|symbol
decl_stmt|;
comment|/* SFN symbol. */
block|}
name|sfunc
struct|;
if|#
directive|if
name|FFESTR_VXT
struct|struct
block|{
name|char
name|list_state
decl_stmt|;
comment|/* 0=>no field names allowed, 1=>error 				   reported already, 2=>field names req'd, 				   3=>have a field name. */
block|}
name|V003
struct|;
endif|#
directive|endif
block|}
union|;
end_union

begin_comment
comment|/* Merge with the one in ffestc later. */
end_comment

begin_comment
comment|/* Static objects accessed by functions in this module. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffestc_ok_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _start_ fn's send this to _xyz_ fn's. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ffestc_parent_ok_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parent sym for baby sym fn's ok. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ffestc_namelist_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0=>not namelist, 1=>namelist, 2=>error. */
end_comment

begin_decl_stmt
specifier|static
name|union
name|ffestc_local_u_
name|ffestc_local_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffestcStatelet_
name|ffestc_statelet_
init|=
name|FFESTC_stateletSIMPLE_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffestwShriek
name|ffestc_shriek_after1_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|ffestc_blocknum_
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next block# to assign. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ffestc_entry_num_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ffestc_sfdummy_argno_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ffestc_saved_entry_num_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ffelab
name|ffestc_label_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static functions (internal). */
end_comment

begin_function_decl
specifier|static
name|void
name|ffestc_R544_equiv_
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_establish_declinfo_
parameter_list|(
name|ffebld
name|kind
parameter_list|,
name|ffelexToken
name|kindt
parameter_list|,
name|ffebld
name|len
parameter_list|,
name|ffelexToken
name|lent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_establish_declstmt_
parameter_list|(
name|ffestpType
name|type
parameter_list|,
name|ffelexToken
name|typet
parameter_list|,
name|ffebld
name|kind
parameter_list|,
name|ffelexToken
name|kindt
parameter_list|,
name|ffebld
name|len
parameter_list|,
name|ffelexToken
name|lent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_establish_impletter_
parameter_list|(
name|ffelexToken
name|first
parameter_list|,
name|ffelexToken
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffeinfoKindtype
name|ffestc_kindtype_kind_
parameter_list|(
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffetargetCharacterSize
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffeinfoKindtype
name|ffestc_kindtype_star_
parameter_list|(
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffetargetCharacterSize
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_labeldef_any_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffestc_labeldef_begin_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_labeldef_branch_begin_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_labeldef_branch_end_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_labeldef_endif_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_labeldef_format_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_labeldef_invalid_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_labeldef_notloop_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_labeldef_notloop_begin_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_labeldef_useless_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffestc_labelref_is_assignable_
parameter_list|(
name|ffelexToken
name|label_token
parameter_list|,
name|ffelab
modifier|*
name|label
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffestc_labelref_is_branch_
parameter_list|(
name|ffelexToken
name|label_token
parameter_list|,
name|ffelab
modifier|*
name|label
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffestc_labelref_is_format_
parameter_list|(
name|ffelexToken
name|label_token
parameter_list|,
name|ffelab
modifier|*
name|label
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffestc_labelref_is_loopend_
parameter_list|(
name|ffelexToken
name|label_token
parameter_list|,
name|ffelab
modifier|*
name|label
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_access_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_actiondo_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_actionif_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_actionwhere_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_order_any_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_order_bad_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_blockdata_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_blockspec_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_component_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_contains_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_data_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_data77_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_derivedtype_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_do_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_entry_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_exec_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_format_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_function_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_iface_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_ifthen_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_implicit_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_implicitnone_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_interface_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_map_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_module_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_parameter_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_program_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_progspec_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_record_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_selectcase_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_sfunc_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_spec_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_structure_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_subroutine_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_type_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_typedecl_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_union_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_unit_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_use_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_vxtstructure_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|ffestcOrder_
name|ffestc_order_where_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ffestc_promote_dummy_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_promote_execdummy_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_promote_sfdummy_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_begin_program_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_begin_uses_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_blockdata_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_do_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_end_program_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_end_uses_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_function_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_if_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_ifthen_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_interface_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_map_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_module_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_select_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_structure_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_subroutine_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_type_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_union_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_where_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function_decl
specifier|static
name|void
name|ffestc_shriek_wherethen_
parameter_list|(
name|bool
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ffestc_subr_binsrch_
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|list
parameter_list|,
name|int
name|size
parameter_list|,
name|ffestpFile
modifier|*
name|spec
parameter_list|,
specifier|const
name|char
modifier|*
name|whine
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestvFormat
name|ffestc_subr_format_
parameter_list|(
name|ffestpFile
modifier|*
name|spec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffestc_subr_is_branch_
parameter_list|(
name|ffestpFile
modifier|*
name|spec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffestc_subr_is_format_
parameter_list|(
name|ffestpFile
modifier|*
name|spec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ffestc_subr_is_present_
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ffestpFile
modifier|*
name|spec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ffestc_subr_speccmp_
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|ffestpFile
modifier|*
name|spec
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|target
parameter_list|,
name|int
modifier|*
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ffestvUnit
name|ffestc_subr_unit_
parameter_list|(
name|ffestpFile
modifier|*
name|spec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffestc_try_shriek_do_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Internal macros. */
end_comment

begin_define
define|#
directive|define
name|ffestc_check_simple_
parameter_list|()
define|\
value|assert(ffestc_statelet_ == FFESTC_stateletSIMPLE_)
end_define

begin_define
define|#
directive|define
name|ffestc_check_start_
parameter_list|()
define|\
value|assert(ffestc_statelet_ == FFESTC_stateletSIMPLE_); \       ffestc_statelet_ = FFESTC_stateletATTRIB_
end_define

begin_define
define|#
directive|define
name|ffestc_check_attrib_
parameter_list|()
define|\
value|assert(ffestc_statelet_ == FFESTC_stateletATTRIB_)
end_define

begin_define
define|#
directive|define
name|ffestc_check_item_
parameter_list|()
define|\
value|assert(ffestc_statelet_ == FFESTC_stateletATTRIB_	 \ 	    || ffestc_statelet_ == FFESTC_stateletITEM_); \       ffestc_statelet_ = FFESTC_stateletITEM_
end_define

begin_define
define|#
directive|define
name|ffestc_check_item_startvals_
parameter_list|()
define|\
value|assert(ffestc_statelet_ == FFESTC_stateletATTRIB_	 \ 	    || ffestc_statelet_ == FFESTC_stateletITEM_); \       ffestc_statelet_ = FFESTC_stateletITEMVALS_
end_define

begin_define
define|#
directive|define
name|ffestc_check_item_value_
parameter_list|()
define|\
value|assert(ffestc_statelet_ == FFESTC_stateletITEMVALS_)
end_define

begin_define
define|#
directive|define
name|ffestc_check_item_endvals_
parameter_list|()
define|\
value|assert(ffestc_statelet_ == FFESTC_stateletITEMVALS_); \       ffestc_statelet_ = FFESTC_stateletITEM_
end_define

begin_define
define|#
directive|define
name|ffestc_check_finish_
parameter_list|()
define|\
value|assert(ffestc_statelet_ == FFESTC_stateletATTRIB_	 \ 	    || ffestc_statelet_ == FFESTC_stateletITEM_); \       ffestc_statelet_ = FFESTC_stateletSIMPLE_
end_define

begin_define
define|#
directive|define
name|ffestc_order_action_
parameter_list|()
value|ffestc_order_exec_()
end_define

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_define
define|#
directive|define
name|ffestc_order_interfacespec_
parameter_list|()
value|ffestc_order_derivedtype_()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ffestc_shriek_if_lost_
value|ffestc_shriek_if_
end_define

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_define
define|#
directive|define
name|ffestc_shriek_where_lost_
value|ffestc_shriek_where_
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* ffestc_establish_declinfo_ -- Determine specific type/params info for entity     ffestc_establish_declinfo_(kind,kind_token,len,len_token);     Must be called after _declstmt_ called to establish base type.  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_establish_declinfo_
parameter_list|(
name|ffebld
name|kind
parameter_list|,
name|ffelexToken
name|kindt
parameter_list|,
name|ffebld
name|len
parameter_list|,
name|ffelexToken
name|lent
parameter_list|)
block|{
name|ffeinfoBasictype
name|bt
init|=
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|ffetargetCharacterSize
name|val
decl_stmt|;
if|if
condition|(
name|kindt
operator|==
name|NULL
condition|)
name|kt
operator|=
name|ffestc_local_
operator|.
name|decl
operator|.
name|stmt_kind_type
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ffestc_local_
operator|.
name|decl
operator|.
name|per_var_kind_ok
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_KINDTYPE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|kindt
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|kindt
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|kt
operator|=
name|ffestc_local_
operator|.
name|decl
operator|.
name|stmt_kind_type
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|kind
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|kindt
argument_list|)
operator|==
name|FFELEX_typeNUMBER
argument_list|)
expr_stmt|;
name|val
operator|=
name|atol
argument_list|(
name|ffelex_token_text
argument_list|(
name|kindt
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffestc_kindtype_star_
argument_list|(
name|bt
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|kind
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
name|kt
operator|=
name|ffestc_local_
operator|.
name|decl
operator|.
name|stmt_kind_type
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|kind
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|kind
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|kind
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|val
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|kind
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffestc_kindtype_kind_
argument_list|(
name|bt
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeNONE
condition|)
block|{
comment|/* Not valid kind type. */
name|ffebad_start
argument_list|(
name|FFEBAD_KINDTYPE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|kindt
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|kindt
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|kt
operator|=
name|ffestc_local_
operator|.
name|decl
operator|.
name|stmt_kind_type
expr_stmt|;
block|}
block|}
name|ffestc_local_
operator|.
name|decl
operator|.
name|kind_type
operator|=
name|kt
expr_stmt|;
comment|/* Now check length specification for CHARACTER data type. */
if|if
condition|(
operator|(
operator|(
name|len
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|lent
operator|==
name|NULL
operator|)
operator|)
operator|||
operator|(
name|bt
operator|!=
name|FFEINFO_basictypeCHARACTER
operator|)
condition|)
name|val
operator|=
name|ffestc_local_
operator|.
name|decl
operator|.
name|stmt_size
expr_stmt|;
else|else
block|{
if|if
condition|(
name|len
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|lent
argument_list|)
operator|==
name|FFELEX_typeNUMBER
argument_list|)
expr_stmt|;
name|val
operator|=
name|atol
argument_list|(
name|ffelex_token_text
argument_list|(
name|lent
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|len
argument_list|)
operator|==
name|FFEBLD_opSTAR
condition|)
name|val
operator|=
name|FFETARGET_charactersizeNONE
expr_stmt|;
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|len
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
name|val
operator|=
name|FFETARGET_charactersizeNONE
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|len
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|len
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|len
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|val
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|val
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
literal|0
operator|&&
name|ffe_is_90
argument_list|()
operator|)
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_ZERO_SIZE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|lent
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|lent
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_local_
operator|.
name|decl
operator|.
name|size
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_establish_declstmt_ -- Establish host-specific type/params info     ffestc_establish_declstmt_(type,type_token,kind,kind_token,len, 	 len_token);  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_establish_declstmt_
parameter_list|(
name|ffestpType
name|type
parameter_list|,
name|ffelexToken
name|typet
parameter_list|,
name|ffebld
name|kind
parameter_list|,
name|ffelexToken
name|kindt
parameter_list|,
name|ffebld
name|len
parameter_list|,
name|ffelexToken
name|lent
parameter_list|)
block|{
name|ffeinfoBasictype
name|bt
decl_stmt|;
name|ffeinfoKindtype
name|ktd
decl_stmt|;
comment|/* Default kindtype. */
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|ffetargetCharacterSize
name|val
decl_stmt|;
name|bool
name|per_var_kind_ok
init|=
name|TRUE
decl_stmt|;
comment|/* Determine basictype and default kindtype. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|FFESTP_typeINTEGER
case|:
name|bt
operator|=
name|FFEINFO_basictypeINTEGER
expr_stmt|;
name|ktd
operator|=
name|FFEINFO_kindtypeINTEGERDEFAULT
expr_stmt|;
break|break;
case|case
name|FFESTP_typeBYTE
case|:
name|bt
operator|=
name|FFEINFO_basictypeINTEGER
expr_stmt|;
name|ktd
operator|=
name|FFEINFO_kindtypeINTEGER2
expr_stmt|;
break|break;
case|case
name|FFESTP_typeWORD
case|:
name|bt
operator|=
name|FFEINFO_basictypeINTEGER
expr_stmt|;
name|ktd
operator|=
name|FFEINFO_kindtypeINTEGER3
expr_stmt|;
break|break;
case|case
name|FFESTP_typeREAL
case|:
name|bt
operator|=
name|FFEINFO_basictypeREAL
expr_stmt|;
name|ktd
operator|=
name|FFEINFO_kindtypeREALDEFAULT
expr_stmt|;
break|break;
case|case
name|FFESTP_typeCOMPLEX
case|:
name|bt
operator|=
name|FFEINFO_basictypeCOMPLEX
expr_stmt|;
name|ktd
operator|=
name|FFEINFO_kindtypeREALDEFAULT
expr_stmt|;
break|break;
case|case
name|FFESTP_typeLOGICAL
case|:
name|bt
operator|=
name|FFEINFO_basictypeLOGICAL
expr_stmt|;
name|ktd
operator|=
name|FFEINFO_kindtypeLOGICALDEFAULT
expr_stmt|;
break|break;
case|case
name|FFESTP_typeCHARACTER
case|:
name|bt
operator|=
name|FFEINFO_basictypeCHARACTER
expr_stmt|;
name|ktd
operator|=
name|FFEINFO_kindtypeCHARACTERDEFAULT
expr_stmt|;
break|break;
case|case
name|FFESTP_typeDBLPRCSN
case|:
name|bt
operator|=
name|FFEINFO_basictypeREAL
expr_stmt|;
name|ktd
operator|=
name|FFEINFO_kindtypeREALDOUBLE
expr_stmt|;
name|per_var_kind_ok
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTP_typeDBLCMPLX
case|:
name|bt
operator|=
name|FFEINFO_basictypeCOMPLEX
expr_stmt|;
if|#
directive|if
name|FFETARGET_okCOMPLEX2
name|ktd
operator|=
name|FFEINFO_kindtypeREALDOUBLE
expr_stmt|;
else|#
directive|else
name|ktd
operator|=
name|FFEINFO_kindtypeREALDEFAULT
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_BAD_DBLCMPLX
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|per_var_kind_ok
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Unexpected type (F90 TYPE?)!"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|bt
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
name|ktd
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|kindt
operator|==
name|NULL
condition|)
name|kt
operator|=
name|ktd
expr_stmt|;
else|else
block|{
comment|/* Not necessarily default kind type. */
if|if
condition|(
name|kind
operator|==
name|NULL
condition|)
block|{
comment|/* Shouldn't happen for CHARACTER. */
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|kindt
argument_list|)
operator|==
name|FFELEX_typeNUMBER
argument_list|)
expr_stmt|;
name|val
operator|=
name|atol
argument_list|(
name|ffelex_token_text
argument_list|(
name|kindt
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffestc_kindtype_star_
argument_list|(
name|bt
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|kind
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
name|kt
operator|=
name|ktd
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|kind
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|kind
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|kind
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|val
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|kind
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|ffestc_kindtype_kind_
argument_list|(
name|bt
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kt
operator|==
name|FFEINFO_kindtypeNONE
condition|)
block|{
comment|/* Not valid kind type. */
name|ffebad_start
argument_list|(
name|FFEBAD_KINDTYPE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|kindt
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|kindt
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|typet
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|typet
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|kt
operator|=
name|ktd
expr_stmt|;
block|}
block|}
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
operator|=
name|bt
expr_stmt|;
name|ffestc_local_
operator|.
name|decl
operator|.
name|stmt_kind_type
operator|=
name|kt
expr_stmt|;
name|ffestc_local_
operator|.
name|decl
operator|.
name|per_var_kind_ok
operator|=
name|per_var_kind_ok
expr_stmt|;
comment|/* Now check length specification for CHARACTER data type. */
if|if
condition|(
operator|(
operator|(
name|len
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|lent
operator|==
name|NULL
operator|)
operator|)
operator|||
operator|(
name|type
operator|!=
name|FFESTP_typeCHARACTER
operator|)
condition|)
name|val
operator|=
operator|(
name|type
operator|==
name|FFESTP_typeCHARACTER
operator|)
condition|?
literal|1
else|:
name|FFETARGET_charactersizeNONE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|len
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|lent
argument_list|)
operator|==
name|FFELEX_typeNUMBER
argument_list|)
expr_stmt|;
name|val
operator|=
name|atol
argument_list|(
name|ffelex_token_text
argument_list|(
name|lent
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|len
argument_list|)
operator|==
name|FFEBLD_opSTAR
condition|)
name|val
operator|=
name|FFETARGET_charactersizeNONE
expr_stmt|;
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|len
argument_list|)
operator|==
name|FFEBLD_opANY
condition|)
name|val
operator|=
name|FFETARGET_charactersizeNONE
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|len
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|len
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeINTEGER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|len
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|)
expr_stmt|;
name|val
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|val
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
literal|0
operator|&&
name|ffe_is_90
argument_list|()
operator|)
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_ZERO_SIZE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|lent
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|lent
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_local_
operator|.
name|decl
operator|.
name|stmt_size
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_establish_impletter_ -- Establish type/params for IMPLICIT letter(s)     ffestc_establish_impletter_(first_letter_token,last_letter_token);  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_establish_impletter_
parameter_list|(
name|ffelexToken
name|first
parameter_list|,
name|ffelexToken
name|last
parameter_list|)
block|{
name|bool
name|ok
init|=
name|FALSE
decl_stmt|;
comment|/* Stays FALSE if first letter> last. */
name|char
name|c
decl_stmt|;
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
name|ok
operator|=
name|ffeimplic_establish_initial
argument_list|(
name|c
operator|=
operator|*
operator|(
name|ffelex_token_text
argument_list|(
name|first
argument_list|)
operator|)
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|kind_type
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|size
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|c
operator|=
operator|*
operator|(
name|ffelex_token_text
argument_list|(
name|first
argument_list|)
operator|)
init|;
name|c
operator|<=
operator|*
operator|(
name|ffelex_token_text
argument_list|(
name|last
argument_list|)
operator|)
condition|;
name|c
operator|++
control|)
block|{
name|ok
operator|=
name|ffeimplic_establish_initial
argument_list|(
name|c
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|kind_type
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|char
name|cs
index|[
literal|2
index|]
decl_stmt|;
name|cs
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|cs
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_BAD_IMPLICIT
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|first
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_init_3 -- Initialize ffestc for new program unit     ffestc_init_3();  */
end_comment

begin_function
name|void
name|ffestc_init_3
parameter_list|()
block|{
name|ffestv_save_state_
operator|=
name|FFESTV_savestateNONE
expr_stmt|;
name|ffestc_entry_num_
operator|=
literal|0
expr_stmt|;
name|ffestv_num_label_defines_
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_init_4 -- Initialize ffestc for new scoping unit     ffestc_init_4();     For SUBROUTINEs/FUNCTIONs within INTERFACE/END INTERFACE, derived-TYPE-    defs, and statement function defs.  */
end_comment

begin_function
name|void
name|ffestc_init_4
parameter_list|()
block|{
name|ffestc_saved_entry_num_
operator|=
name|ffestc_entry_num_
expr_stmt|;
name|ffestc_entry_num_
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_kindtype_kind_ -- Determine kindtype from basictype and KIND= value     ffeinfoKindtype kt;    ffeinfoBasictype bt;    ffetargetCharacterSize val;    kt = ffestc_kindtype_kind_(bt,val);    if (kt == FFEINFO_kindtypeNONE)        // unsupported/invalid KIND= value for type  */
end_comment

begin_function
specifier|static
name|ffeinfoKindtype
name|ffestc_kindtype_kind_
parameter_list|(
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffetargetCharacterSize
name|val
parameter_list|)
block|{
name|ffetype
name|type
decl_stmt|;
name|ffetype
name|base_type
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|base_type
operator|=
name|ffeinfo_type
argument_list|(
name|bt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ~~ */
name|assert
argument_list|(
name|base_type
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffetype_lookup_kind
argument_list|(
name|base_type
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|FFEINFO_kindtypeNONE
return|;
for|for
control|(
name|kt
operator|=
literal|1
init|;
name|kt
operator|<
name|FFEINFO_kindtype
condition|;
operator|++
name|kt
control|)
if|if
condition|(
name|ffeinfo_type
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|)
operator|==
name|type
condition|)
return|return
name|kt
return|;
return|return
name|FFEINFO_kindtypeNONE
return|;
block|}
end_function

begin_comment
comment|/* ffestc_kindtype_star_ -- Determine kindtype from basictype and * value     ffeinfoKindtype kt;    ffeinfoBasictype bt;    ffetargetCharacterSize val;    kt = ffestc_kindtype_star_(bt,val);    if (kt == FFEINFO_kindtypeNONE)        // unsupported/invalid * value for type	*/
end_comment

begin_function
specifier|static
name|ffeinfoKindtype
name|ffestc_kindtype_star_
parameter_list|(
name|ffeinfoBasictype
name|bt
parameter_list|,
name|ffetargetCharacterSize
name|val
parameter_list|)
block|{
name|ffetype
name|type
decl_stmt|;
name|ffetype
name|base_type
decl_stmt|;
name|ffeinfoKindtype
name|kt
decl_stmt|;
name|base_type
operator|=
name|ffeinfo_type
argument_list|(
name|bt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ~~ */
name|assert
argument_list|(
name|base_type
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|type
operator|=
name|ffetype_lookup_star
argument_list|(
name|base_type
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|FFEINFO_kindtypeNONE
return|;
for|for
control|(
name|kt
operator|=
literal|1
init|;
name|kt
operator|<
name|FFEINFO_kindtype
condition|;
operator|++
name|kt
control|)
if|if
condition|(
name|ffeinfo_type
argument_list|(
name|bt
argument_list|,
name|kt
argument_list|)
operator|==
name|type
condition|)
return|return
name|kt
return|;
return|return
name|FFEINFO_kindtypeNONE
return|;
block|}
end_function

begin_comment
comment|/* Define label as usable for anything without complaint.  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_labeldef_any_
parameter_list|()
block|{
if|if
condition|(
operator|(
name|ffesta_label_token
operator|==
name|NULL
operator|)
operator|||
operator|!
name|ffestc_labeldef_begin_
argument_list|()
condition|)
return|return;
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_labeldef_begin_ -- Define label as unknown, initially     ffestc_labeldef_begin_();  */
end_comment

begin_function
specifier|static
name|bool
name|ffestc_labeldef_begin_
parameter_list|()
block|{
name|ffelabValue
name|label_value
decl_stmt|;
name|ffelab
name|label
decl_stmt|;
name|label_value
operator|=
operator|(
name|ffelabValue
operator|)
name|atol
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|label_value
operator|==
literal|0
operator|)
operator|||
operator|(
name|label_value
operator|>
name|FFELAB_valueMAX
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_NUMBER_INVALID
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|label
operator|=
name|ffelab_find
argument_list|(
name|label_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|NULL
condition|)
block|{
name|label
operator|=
name|ffestc_label_
operator|=
name|ffelab_new
argument_list|(
name|label_value
argument_list|)
expr_stmt|;
name|ffestv_num_label_defines_
operator|++
expr_stmt|;
name|ffelab_set_definition_line
argument_list|(
name|label
argument_list|,
name|ffewhere_line_use
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffelab_set_definition_column
argument_list|(
name|label
argument_list|,
name|ffewhere_column_use
argument_list|(
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|ffewhere_line_is_unknown
argument_list|(
name|ffelab_definition_line
argument_list|(
name|label
argument_list|)
argument_list|)
condition|)
block|{
name|ffestv_num_label_defines_
operator|++
expr_stmt|;
name|ffestc_label_
operator|=
name|label
expr_stmt|;
name|ffelab_set_definition_line
argument_list|(
name|label
argument_list|,
name|ffewhere_line_use
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffelab_set_definition_column
argument_list|(
name|label
argument_list|,
name|ffewhere_column_use
argument_list|(
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_ALREADY_DEFINED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_definition_line
argument_list|(
name|label
argument_list|)
argument_list|,
name|ffelab_definition_column
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffelex_token_text
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_label_token
argument_list|)
expr_stmt|;
name|ffesta_label_token
operator|=
name|NULL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ffestc_labeldef_branch_begin_ -- Define label as a branch target one     ffestc_labeldef_branch_begin_();  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_labeldef_branch_begin_
parameter_list|()
block|{
if|if
condition|(
operator|(
name|ffesta_label_token
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
operator|)
operator|||
operator|!
name|ffestc_labeldef_begin_
argument_list|()
condition|)
return|return;
switch|switch
condition|(
name|ffelab_type
argument_list|(
name|ffestc_label_
argument_list|)
condition|)
block|{
case|case
name|FFELAB_typeUNKNOWN
case|:
case|case
name|FFELAB_typeASSIGNABLE
case|:
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeNOTLOOP
argument_list|)
expr_stmt|;
name|ffelab_set_blocknum
argument_list|(
name|ffestc_label_
argument_list|,
name|ffestw_blocknum
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffestd_labeldef_branch
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeNOTLOOP
case|:
if|if
condition|(
name|ffelab_blocknum
argument_list|(
name|ffestc_label_
argument_list|)
operator|<
name|ffestw_blocknum
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_BLOCK
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelab_set_blocknum
argument_list|(
name|ffestc_label_
argument_list|,
name|ffestw_blocknum
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffestd_labeldef_branch
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeLOOPEND
case|:
if|if
condition|(
operator|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|FFESTV_stateDO
operator|)
operator|||
operator|(
name|ffestw_label
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|ffestc_label_
operator|)
condition|)
block|{
comment|/* Unterminated block. */
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_DO_BLOCK_END
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_doref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_doref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
block|}
name|ffestd_labeldef_branch
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
comment|/* Leave something around for _branch_end_() to handle. */
return|return;
case|case
name|FFELAB_typeFORMAT
case|:
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad label"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FFELAB_typeANY
case|:
break|break;
block|}
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_label_token
argument_list|)
expr_stmt|;
name|ffesta_label_token
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define possible end of labeled-DO-loop.  Call only after calling    ffestc_labeldef_branch_begin_, or when other branch_* functions    recognize that a label might also be serving as a branch end (in    which case they must issue a diagnostic).  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_labeldef_branch_end_
parameter_list|()
block|{
if|if
condition|(
name|ffesta_label_token
operator|==
name|NULL
condition|)
return|return;
name|assert
argument_list|(
name|ffestc_label_
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|ffelab_type
argument_list|(
name|ffestc_label_
argument_list|)
operator|==
name|FFELAB_typeLOOPEND
operator|)
operator|||
operator|(
name|ffelab_type
argument_list|(
name|ffestc_label_
argument_list|)
operator|==
name|FFELAB_typeANY
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|FFESTV_stateDO
operator|)
operator|&&
operator|(
name|ffestw_label
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|ffestc_label_
operator|)
condition|)
name|ffestc_shriek_do_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_label_token
argument_list|)
expr_stmt|;
name|ffesta_label_token
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_labeldef_endif_ -- Define label as an END IF one     ffestc_labeldef_endif_();  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_labeldef_endif_
parameter_list|()
block|{
if|if
condition|(
operator|(
name|ffesta_label_token
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
operator|)
operator|||
operator|!
name|ffestc_labeldef_begin_
argument_list|()
condition|)
return|return;
switch|switch
condition|(
name|ffelab_type
argument_list|(
name|ffestc_label_
argument_list|)
condition|)
block|{
case|case
name|FFELAB_typeUNKNOWN
case|:
case|case
name|FFELAB_typeASSIGNABLE
case|:
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeENDIF
argument_list|)
expr_stmt|;
name|ffelab_set_blocknum
argument_list|(
name|ffestc_label_
argument_list|,
name|ffestw_blocknum
argument_list|(
name|ffestw_previous
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffestd_labeldef_endif
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeNOTLOOP
case|:
if|if
condition|(
name|ffelab_blocknum
argument_list|(
name|ffestc_label_
argument_list|)
operator|<
name|ffestw_blocknum
argument_list|(
name|ffestw_previous
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_BLOCK
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelab_set_blocknum
argument_list|(
name|ffestc_label_
argument_list|,
name|ffestw_blocknum
argument_list|(
name|ffestw_previous
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffestd_labeldef_endif
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeLOOPEND
case|:
if|if
condition|(
operator|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|FFESTV_stateDO
operator|)
operator|||
operator|(
name|ffestw_label
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|ffestc_label_
operator|)
condition|)
block|{
comment|/* Unterminated block. */
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_DO_BLOCK_END
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_doref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_doref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
block|}
name|ffestd_labeldef_endif
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_doref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_doref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
return|return;
case|case
name|FFELAB_typeFORMAT
case|:
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad label"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FFELAB_typeANY
case|:
break|break;
block|}
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_label_token
argument_list|)
expr_stmt|;
name|ffesta_label_token
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_labeldef_format_ -- Define label as a FORMAT one     ffestc_labeldef_format_();  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_labeldef_format_
parameter_list|()
block|{
if|if
condition|(
operator|(
name|ffesta_label_token
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_FORMAT_NO_LABEL_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ffestc_labeldef_begin_
argument_list|()
condition|)
return|return;
switch|switch
condition|(
name|ffelab_type
argument_list|(
name|ffestc_label_
argument_list|)
condition|)
block|{
case|case
name|FFELAB_typeUNKNOWN
case|:
case|case
name|FFELAB_typeASSIGNABLE
case|:
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeFORMAT
argument_list|)
expr_stmt|;
name|ffestd_labeldef_format
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeFORMAT
case|:
name|ffestd_labeldef_format
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeLOOPEND
case|:
if|if
condition|(
operator|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|FFESTV_stateDO
operator|)
operator|||
operator|(
name|ffestw_label
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|ffestc_label_
operator|)
condition|)
block|{
comment|/* Unterminated block. */
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_DO_BLOCK_END
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_doref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_doref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
block|}
name|ffestd_labeldef_format
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_doref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_doref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
return|return;
case|case
name|FFELAB_typeNOTLOOP
case|:
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad label"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FFELAB_typeANY
case|:
break|break;
block|}
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_label_token
argument_list|)
expr_stmt|;
name|ffesta_label_token
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_labeldef_invalid_ -- Label definition invalid, complain if present     ffestc_labeldef_invalid_();	*/
end_comment

begin_function
specifier|static
name|void
name|ffestc_labeldef_invalid_
parameter_list|()
block|{
if|if
condition|(
operator|(
name|ffesta_label_token
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
operator|)
operator|||
operator|!
name|ffestc_labeldef_begin_
argument_list|()
condition|)
return|return;
name|ffebad_start
argument_list|(
name|FFEBAD_INVALID_LABEL_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_label_token
argument_list|)
expr_stmt|;
name|ffesta_label_token
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define label as a non-loop-ending one on a statement that can't    be in the "then" part of a logical IF, such as a block-IF statement.  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_labeldef_notloop_
parameter_list|()
block|{
if|if
condition|(
name|ffesta_label_token
operator|==
name|NULL
condition|)
return|return;
name|assert
argument_list|(
name|ffestc_shriek_after1_
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_labeldef_begin_
argument_list|()
condition|)
return|return;
switch|switch
condition|(
name|ffelab_type
argument_list|(
name|ffestc_label_
argument_list|)
condition|)
block|{
case|case
name|FFELAB_typeUNKNOWN
case|:
case|case
name|FFELAB_typeASSIGNABLE
case|:
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeNOTLOOP
argument_list|)
expr_stmt|;
name|ffelab_set_blocknum
argument_list|(
name|ffestc_label_
argument_list|,
name|ffestw_blocknum
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffestd_labeldef_notloop
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeNOTLOOP
case|:
if|if
condition|(
name|ffelab_blocknum
argument_list|(
name|ffestc_label_
argument_list|)
operator|<
name|ffestw_blocknum
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_BLOCK
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelab_set_blocknum
argument_list|(
name|ffestc_label_
argument_list|,
name|ffestw_blocknum
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffestd_labeldef_notloop
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeLOOPEND
case|:
if|if
condition|(
operator|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|FFESTV_stateDO
operator|)
operator|||
operator|(
name|ffestw_label
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|ffestc_label_
operator|)
condition|)
block|{
comment|/* Unterminated block. */
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_DO_BLOCK_END
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_doref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_doref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
block|}
name|ffestd_labeldef_notloop
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_doref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_doref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
return|return;
case|case
name|FFELAB_typeFORMAT
case|:
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad label"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FFELAB_typeANY
case|:
break|break;
block|}
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_label_token
argument_list|)
expr_stmt|;
name|ffesta_label_token
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define label as a non-loop-ending one.  Use this when it is    possible that the pending label is inhibited because we're in    the midst of a logical-IF, and thus _branch_end_ is going to    be called after the current statement to resolve a potential    loop-ending label.  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_labeldef_notloop_begin_
parameter_list|()
block|{
if|if
condition|(
operator|(
name|ffesta_label_token
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
operator|)
operator|||
operator|!
name|ffestc_labeldef_begin_
argument_list|()
condition|)
return|return;
switch|switch
condition|(
name|ffelab_type
argument_list|(
name|ffestc_label_
argument_list|)
condition|)
block|{
case|case
name|FFELAB_typeUNKNOWN
case|:
case|case
name|FFELAB_typeASSIGNABLE
case|:
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeNOTLOOP
argument_list|)
expr_stmt|;
name|ffelab_set_blocknum
argument_list|(
name|ffestc_label_
argument_list|,
name|ffestw_blocknum
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffestd_labeldef_notloop
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeNOTLOOP
case|:
if|if
condition|(
name|ffelab_blocknum
argument_list|(
name|ffestc_label_
argument_list|)
operator|<
name|ffestw_blocknum
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_BLOCK
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffelab_set_blocknum
argument_list|(
name|ffestc_label_
argument_list|,
name|ffestw_blocknum
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffestd_labeldef_notloop
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeLOOPEND
case|:
if|if
condition|(
operator|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|FFESTV_stateDO
operator|)
operator|||
operator|(
name|ffestw_label
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|ffestc_label_
operator|)
condition|)
block|{
comment|/* Unterminated block. */
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_DO_BLOCK_END
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_doref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_doref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
block|}
name|ffestd_labeldef_branch
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_doref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_doref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return;
case|case
name|FFELAB_typeFORMAT
case|:
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad label"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FFELAB_typeANY
case|:
break|break;
block|}
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_label_token
argument_list|)
expr_stmt|;
name|ffesta_label_token
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_labeldef_useless_ -- Define label as a useless one     ffestc_labeldef_useless_();	*/
end_comment

begin_function
specifier|static
name|void
name|ffestc_labeldef_useless_
parameter_list|()
block|{
if|if
condition|(
operator|(
name|ffesta_label_token
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
operator|)
operator|||
operator|!
name|ffestc_labeldef_begin_
argument_list|()
condition|)
return|return;
switch|switch
condition|(
name|ffelab_type
argument_list|(
name|ffestc_label_
argument_list|)
condition|)
block|{
case|case
name|FFELAB_typeUNKNOWN
case|:
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeUSELESS
argument_list|)
expr_stmt|;
name|ffestd_labeldef_useless
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeLOOPEND
case|:
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|FFESTV_stateDO
operator|)
operator|||
operator|(
name|ffestw_label
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|ffestc_label_
operator|)
condition|)
block|{
comment|/* Unterminated block. */
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_DO_BLOCK_END
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_doref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_doref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
block|}
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_doref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_doref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
return|return;
case|case
name|FFELAB_typeASSIGNABLE
case|:
case|case
name|FFELAB_typeFORMAT
case|:
case|case
name|FFELAB_typeNOTLOOP
case|:
name|ffelab_set_type
argument_list|(
name|ffestc_label_
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|ffestc_label_
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|ffestc_label_
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad label"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FFELAB_typeANY
case|:
break|break;
block|}
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffesta_label_token
argument_list|)
expr_stmt|;
name|ffesta_label_token
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_labelref_is_assignable_ -- Reference to label in ASSIGN stmt     if (ffestc_labelref_is_assignable_(label_token,&label))        // label ref is ok, label is filled in with ffelab object  */
end_comment

begin_function
specifier|static
name|bool
name|ffestc_labelref_is_assignable_
parameter_list|(
name|ffelexToken
name|label_token
parameter_list|,
name|ffelab
modifier|*
name|x_label
parameter_list|)
block|{
name|ffelab
name|label
decl_stmt|;
name|ffelabValue
name|label_value
decl_stmt|;
name|label_value
operator|=
operator|(
name|ffelabValue
operator|)
name|atol
argument_list|(
name|ffelex_token_text
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|label_value
operator|==
literal|0
operator|)
operator|||
operator|(
name|label_value
operator|>
name|FFELAB_valueMAX
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_NUMBER_INVALID
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|label
operator|=
name|ffelab_find
argument_list|(
name|label_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|NULL
condition|)
block|{
name|label
operator|=
name|ffelab_new
argument_list|(
name|label_value
argument_list|)
expr_stmt|;
name|ffelab_set_firstref_line
argument_list|(
name|label
argument_list|,
name|ffewhere_line_use
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffelab_set_firstref_column
argument_list|(
name|label
argument_list|,
name|ffewhere_column_use
argument_list|(
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ffelab_type
argument_list|(
name|label
argument_list|)
condition|)
block|{
case|case
name|FFELAB_typeUNKNOWN
case|:
name|ffelab_set_type
argument_list|(
name|label
argument_list|,
name|FFELAB_typeASSIGNABLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeASSIGNABLE
case|:
case|case
name|FFELAB_typeLOOPEND
case|:
case|case
name|FFELAB_typeFORMAT
case|:
case|case
name|FFELAB_typeNOTLOOP
case|:
case|case
name|FFELAB_typeENDIF
case|:
break|break;
case|case
name|FFELAB_typeUSELESS
case|:
name|ffelab_set_type
argument_list|(
name|label
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|label
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
default|default:
name|assert
argument_list|(
literal|"bad label"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FFELAB_typeANY
case|:
break|break;
block|}
operator|*
name|x_label
operator|=
name|label
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ffestc_labelref_is_branch_ -- Reference to label in branch stmt     if (ffestc_labelref_is_branch_(label_token,&label))        // label ref is ok, label is filled in with ffelab object  */
end_comment

begin_function
specifier|static
name|bool
name|ffestc_labelref_is_branch_
parameter_list|(
name|ffelexToken
name|label_token
parameter_list|,
name|ffelab
modifier|*
name|x_label
parameter_list|)
block|{
name|ffelab
name|label
decl_stmt|;
name|ffelabValue
name|label_value
decl_stmt|;
name|ffestw
name|block
decl_stmt|;
name|unsigned
name|long
name|blocknum
decl_stmt|;
name|label_value
operator|=
operator|(
name|ffelabValue
operator|)
name|atol
argument_list|(
name|ffelex_token_text
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|label_value
operator|==
literal|0
operator|)
operator|||
operator|(
name|label_value
operator|>
name|FFELAB_valueMAX
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_NUMBER_INVALID
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|label
operator|=
name|ffelab_find
argument_list|(
name|label_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|NULL
condition|)
block|{
name|label
operator|=
name|ffelab_new
argument_list|(
name|label_value
argument_list|)
expr_stmt|;
name|ffelab_set_firstref_line
argument_list|(
name|label
argument_list|,
name|ffewhere_line_use
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffelab_set_firstref_column
argument_list|(
name|label
argument_list|,
name|ffewhere_column_use
argument_list|(
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ffelab_type
argument_list|(
name|label
argument_list|)
condition|)
block|{
case|case
name|FFELAB_typeUNKNOWN
case|:
case|case
name|FFELAB_typeASSIGNABLE
case|:
name|ffelab_set_type
argument_list|(
name|label
argument_list|,
name|FFELAB_typeNOTLOOP
argument_list|)
expr_stmt|;
name|ffelab_set_blocknum
argument_list|(
name|label
argument_list|,
name|ffestw_blocknum
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeLOOPEND
case|:
if|if
condition|(
name|ffelab_blocknum
argument_list|(
name|label
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* Already taken care of. */
for|for
control|(
name|block
operator|=
name|ffestw_top_do
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
init|;
operator|(
name|block
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffestw_label
argument_list|(
name|block
argument_list|)
operator|!=
name|label
operator|)
condition|;
name|block
operator|=
name|ffestw_top_do
argument_list|(
name|ffestw_previous
argument_list|(
name|block
argument_list|)
argument_list|)
control|)
empty_stmt|;
comment|/* Find most recent DO<label> ancestor. */
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
block|{
comment|/* Reference to within a (dead) block. */
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_BLOCK
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_definition_line
argument_list|(
name|label
argument_list|)
argument_list|,
name|ffelab_definition_column
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
block|}
name|ffelab_set_blocknum
argument_list|(
name|label
argument_list|,
name|ffestw_blocknum
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|ffelab_set_firstref_line
argument_list|(
name|label
argument_list|,
name|ffewhere_line_use
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffelab_set_firstref_column
argument_list|(
name|label
argument_list|,
name|ffewhere_column_use
argument_list|(
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeNOTLOOP
case|:
case|case
name|FFELAB_typeENDIF
case|:
if|if
condition|(
name|ffelab_blocknum
argument_list|(
name|label
argument_list|)
operator|==
name|ffestw_blocknum
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
break|break;
name|blocknum
operator|=
name|ffelab_blocknum
argument_list|(
name|label
argument_list|)
expr_stmt|;
for|for
control|(
name|block
operator|=
name|ffestw_stack_top
argument_list|()
init|;
name|ffestw_blocknum
argument_list|(
name|block
argument_list|)
operator|>
name|blocknum
condition|;
name|block
operator|=
name|ffestw_previous
argument_list|(
name|block
argument_list|)
control|)
empty_stmt|;
comment|/* Find most recent common ancestor. */
if|if
condition|(
name|ffelab_blocknum
argument_list|(
name|label
argument_list|)
operator|==
name|ffestw_blocknum
argument_list|(
name|block
argument_list|)
condition|)
break|break;
comment|/* Check again. */
if|if
condition|(
operator|!
name|ffewhere_line_is_unknown
argument_list|(
name|ffelab_definition_line
argument_list|(
name|label
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Reference to within a (dead) block. */
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_BLOCK
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_definition_line
argument_list|(
name|label
argument_list|)
argument_list|,
name|ffelab_definition_column
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
break|break;
block|}
name|ffelab_set_blocknum
argument_list|(
name|label
argument_list|,
name|ffestw_blocknum
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeFORMAT
case|:
if|if
condition|(
name|ffewhere_line_is_unknown
argument_list|(
name|ffelab_definition_line
argument_list|(
name|label
argument_list|)
argument_list|)
condition|)
block|{
name|ffelab_set_type
argument_list|(
name|label
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_USE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|label
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Fall through. */
case|case
name|FFELAB_typeUSELESS
case|:
name|ffelab_set_type
argument_list|(
name|label
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_definition_line
argument_list|(
name|label
argument_list|)
argument_list|,
name|ffelab_definition_column
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
default|default:
name|assert
argument_list|(
literal|"bad label"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FFELAB_typeANY
case|:
break|break;
block|}
operator|*
name|x_label
operator|=
name|label
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ffestc_labelref_is_format_ -- Reference to label in [FMT=] specification     if (ffestc_labelref_is_format_(label_token,&label))        // label ref is ok, label is filled in with ffelab object  */
end_comment

begin_function
specifier|static
name|bool
name|ffestc_labelref_is_format_
parameter_list|(
name|ffelexToken
name|label_token
parameter_list|,
name|ffelab
modifier|*
name|x_label
parameter_list|)
block|{
name|ffelab
name|label
decl_stmt|;
name|ffelabValue
name|label_value
decl_stmt|;
name|label_value
operator|=
operator|(
name|ffelabValue
operator|)
name|atol
argument_list|(
name|ffelex_token_text
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|label_value
operator|==
literal|0
operator|)
operator|||
operator|(
name|label_value
operator|>
name|FFELAB_valueMAX
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_NUMBER_INVALID
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|label
operator|=
name|ffelab_find
argument_list|(
name|label_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|NULL
condition|)
block|{
name|label
operator|=
name|ffelab_new
argument_list|(
name|label_value
argument_list|)
expr_stmt|;
name|ffelab_set_firstref_line
argument_list|(
name|label
argument_list|,
name|ffewhere_line_use
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffelab_set_firstref_column
argument_list|(
name|label
argument_list|,
name|ffewhere_column_use
argument_list|(
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ffelab_type
argument_list|(
name|label
argument_list|)
condition|)
block|{
case|case
name|FFELAB_typeUNKNOWN
case|:
case|case
name|FFELAB_typeASSIGNABLE
case|:
name|ffelab_set_type
argument_list|(
name|label
argument_list|,
name|FFELAB_typeFORMAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeFORMAT
case|:
break|break;
case|case
name|FFELAB_typeLOOPEND
case|:
case|case
name|FFELAB_typeNOTLOOP
case|:
if|if
condition|(
name|ffewhere_line_is_unknown
argument_list|(
name|ffelab_definition_line
argument_list|(
name|label
argument_list|)
argument_list|)
condition|)
block|{
name|ffelab_set_type
argument_list|(
name|label
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_USE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|label
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Fall through. */
case|case
name|FFELAB_typeUSELESS
case|:
case|case
name|FFELAB_typeENDIF
case|:
name|ffelab_set_type
argument_list|(
name|label
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_definition_line
argument_list|(
name|label
argument_list|)
argument_list|,
name|ffelab_definition_column
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
default|default:
name|assert
argument_list|(
literal|"bad label"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FFELAB_typeANY
case|:
break|break;
block|}
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
operator|*
name|x_label
operator|=
name|label
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ffestc_labelref_is_loopend_ -- Reference to label in DO stmt     if (ffestc_labelref_is_loopend_(label_token,&label))        // label ref is ok, label is filled in with ffelab object  */
end_comment

begin_function
specifier|static
name|bool
name|ffestc_labelref_is_loopend_
parameter_list|(
name|ffelexToken
name|label_token
parameter_list|,
name|ffelab
modifier|*
name|x_label
parameter_list|)
block|{
name|ffelab
name|label
decl_stmt|;
name|ffelabValue
name|label_value
decl_stmt|;
name|label_value
operator|=
operator|(
name|ffelabValue
operator|)
name|atol
argument_list|(
name|ffelex_token_text
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|label_value
operator|==
literal|0
operator|)
operator|||
operator|(
name|label_value
operator|>
name|FFELAB_valueMAX
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_NUMBER_INVALID
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|label
operator|=
name|ffelab_find
argument_list|(
name|label_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|NULL
condition|)
block|{
name|label
operator|=
name|ffelab_new
argument_list|(
name|label_value
argument_list|)
expr_stmt|;
name|ffelab_set_doref_line
argument_list|(
name|label
argument_list|,
name|ffewhere_line_use
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffelab_set_doref_column
argument_list|(
name|label
argument_list|,
name|ffewhere_column_use
argument_list|(
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ffelab_type
argument_list|(
name|label
argument_list|)
condition|)
block|{
case|case
name|FFELAB_typeASSIGNABLE
case|:
name|ffelab_set_doref_line
argument_list|(
name|label
argument_list|,
name|ffewhere_line_use
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffelab_set_doref_column
argument_list|(
name|label
argument_list|,
name|ffewhere_column_use
argument_list|(
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffewhere_line_kill
argument_list|(
name|ffelab_firstref_line
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffelab_set_firstref_line
argument_list|(
name|label
argument_list|,
name|ffewhere_line_unknown
argument_list|()
argument_list|)
expr_stmt|;
name|ffewhere_column_kill
argument_list|(
name|ffelab_firstref_column
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffelab_set_firstref_column
argument_list|(
name|label
argument_list|,
name|ffewhere_column_unknown
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|FFELAB_typeUNKNOWN
case|:
name|ffelab_set_type
argument_list|(
name|label
argument_list|,
name|FFELAB_typeLOOPEND
argument_list|)
expr_stmt|;
name|ffelab_set_blocknum
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFELAB_typeLOOPEND
case|:
if|if
condition|(
operator|!
name|ffewhere_line_is_unknown
argument_list|(
name|ffelab_definition_line
argument_list|(
name|label
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Def must follow all refs. */
name|ffelab_set_type
argument_list|(
name|label
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_DEF_DO
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_definition_line
argument_list|(
name|label
argument_list|)
argument_list|,
name|ffelab_definition_column
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|ffelab_blocknum
argument_list|(
name|label
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Had a branch ref earlier, can't go inside 				   this new block! */
name|ffelab_set_type
argument_list|(
name|label
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_USE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|label
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|FFESTV_stateDO
operator|)
operator|||
operator|(
name|ffestw_label
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|label
operator|)
condition|)
block|{
comment|/* Top of stack interrupts flow between two 				   DOs specifying label. */
name|ffelab_set_type
argument_list|(
name|label
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_DO_BLOCK_DO
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_doref_line
argument_list|(
name|label
argument_list|)
argument_list|,
name|ffelab_doref_column
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|2
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
name|FFELAB_typeNOTLOOP
case|:
case|case
name|FFELAB_typeFORMAT
case|:
if|if
condition|(
name|ffewhere_line_is_unknown
argument_list|(
name|ffelab_definition_line
argument_list|(
name|label
argument_list|)
argument_list|)
condition|)
block|{
name|ffelab_set_type
argument_list|(
name|label
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_USE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_firstref_line
argument_list|(
name|label
argument_list|)
argument_list|,
name|ffelab_firstref_column
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Fall through. */
case|case
name|FFELAB_typeUSELESS
case|:
case|case
name|FFELAB_typeENDIF
case|:
name|ffelab_set_type
argument_list|(
name|label
argument_list|,
name|FFELAB_typeANY
argument_list|)
expr_stmt|;
name|ffestd_labeldef_any
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_LABEL_USE_DEF
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelab_definition_line
argument_list|(
name|label
argument_list|)
argument_list|,
name|ffelab_definition_column
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|label_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|label_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
default|default:
name|assert
argument_list|(
literal|"bad label"
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FFELAB_typeANY
case|:
break|break;
block|}
operator|*
name|x_label
operator|=
name|label
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ffestc_order_access_ -- Check ordering on<access> statement     if (ffestc_order_access_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_access_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateMODULE0
case|:
case|case
name|FFESTV_stateMODULE1
case|:
case|case
name|FFESTV_stateMODULE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateMODULE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateMODULE3
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_order_actiondo_ -- Check ordering on<actiondo> statement     if (ffestc_order_actiondo_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_actiondo_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateDO
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateIFTHEN
case|:
case|case
name|FFESTV_stateSELECT1
case|:
if|if
condition|(
name|ffestw_top_do
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|NULL
condition|)
break|break;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateIF
case|:
if|if
condition|(
name|ffestw_top_do
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|ffestc_shriek_after1_
operator|=
name|ffestc_shriek_if_
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
default|default:
break|break;
block|}
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
end_function

begin_comment
comment|/* ffestc_order_actionif_ -- Check ordering on<actionif> statement     if (ffestc_order_actionif_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_actionif_
parameter_list|()
block|{
name|bool
name|update
decl_stmt|;
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
case|case
name|FFESTV_statePROGRAM3
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM4
argument_list|)
expr_stmt|;
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE4
argument_list|)
expr_stmt|;
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION4
argument_list|)
expr_stmt|;
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_statePROGRAM4
case|:
case|case
name|FFESTV_stateSUBROUTINE4
case|:
case|case
name|FFESTV_stateFUNCTION4
case|:
name|update
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateIFTHEN
case|:
case|case
name|FFESTV_stateDO
case|:
case|case
name|FFESTV_stateSELECT1
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_shriek_after1_
operator|=
name|ffestc_shriek_if_
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_previous
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateINTERFACE0
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|if
condition|(
name|update
condition|)
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
if|if
condition|(
name|update
condition|)
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_actionwhere_ -- Check ordering on<actionwhere> statement     if (ffestc_order_actionwhere_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_actionwhere_
parameter_list|()
block|{
name|bool
name|update
decl_stmt|;
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
case|case
name|FFESTV_statePROGRAM3
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM4
argument_list|)
expr_stmt|;
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE4
argument_list|)
expr_stmt|;
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION4
argument_list|)
expr_stmt|;
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_statePROGRAM4
case|:
case|case
name|FFESTV_stateSUBROUTINE4
case|:
case|case
name|FFESTV_stateFUNCTION4
case|:
name|update
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateWHERETHEN
case|:
case|case
name|FFESTV_stateIFTHEN
case|:
case|case
name|FFESTV_stateDO
case|:
case|case
name|FFESTV_stateSELECT1
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateWHERE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_after1_
operator|=
name|ffestc_shriek_where_
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_shriek_after1_
operator|=
name|ffestc_shriek_if_
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_previous
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateINTERFACE0
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|if
condition|(
name|update
condition|)
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
if|if
condition|(
name|update
condition|)
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
block|}
block|}
end_function

begin_comment
comment|/* Check ordering on "any" statement.  Like _actionwhere_, but    doesn't produce any diagnostics.  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_order_any_
parameter_list|()
block|{
name|bool
name|update
decl_stmt|;
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
case|case
name|FFESTV_statePROGRAM3
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM4
argument_list|)
expr_stmt|;
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE4
argument_list|)
expr_stmt|;
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION4
argument_list|)
expr_stmt|;
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_statePROGRAM4
case|:
case|case
name|FFESTV_stateSUBROUTINE4
case|:
case|case
name|FFESTV_stateFUNCTION4
case|:
name|update
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateWHERETHEN
case|:
case|case
name|FFESTV_stateIFTHEN
case|:
case|case
name|FFESTV_stateDO
case|:
case|case
name|FFESTV_stateSELECT1
case|:
return|return;
case|case
name|FFESTV_stateWHERE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_after1_
operator|=
name|ffestc_shriek_where_
expr_stmt|;
endif|#
directive|endif
return|return;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_shriek_after1_
operator|=
name|ffestc_shriek_if_
expr_stmt|;
return|return;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
default|default:
return|return;
block|}
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_previous
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateINTERFACE0
case|:
if|if
condition|(
name|update
condition|)
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
default|default:
if|if
condition|(
name|update
condition|)
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_bad_ -- Whine about statement ordering violation     ffestc_order_bad_();     Uses current ffesta_tokens[0] and, if available, info on where current    state started to produce generic message.  Someday we should do    fancier things than this, but this just gets things creaking along for    now.	 */
end_comment

begin_function
specifier|static
name|void
name|ffestc_order_bad_
parameter_list|()
block|{
if|if
condition|(
name|ffewhere_line_is_unknown
argument_list|(
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_ORDER_1
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_ORDER_2
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
comment|/* Any label definition is useless. */
block|}
end_function

begin_comment
comment|/* ffestc_order_blockdata_ -- Check ordering on<blockdata> statement     if (ffestc_order_blockdata_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_blockdata_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateBLOCKDATA0
case|:
case|case
name|FFESTV_stateBLOCKDATA1
case|:
case|case
name|FFESTV_stateBLOCKDATA2
case|:
case|case
name|FFESTV_stateBLOCKDATA3
case|:
case|case
name|FFESTV_stateBLOCKDATA4
case|:
case|case
name|FFESTV_stateBLOCKDATA5
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_blockspec_ -- Check ordering on<blockspec> statement     if (ffestc_order_blockspec_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_blockspec_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateMODULE0
case|:
case|case
name|FFESTV_stateMODULE1
case|:
case|case
name|FFESTV_stateMODULE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateMODULE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateBLOCKDATA0
case|:
case|case
name|FFESTV_stateBLOCKDATA1
case|:
case|case
name|FFESTV_stateBLOCKDATA2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateBLOCKDATA3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_statePROGRAM3
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateMODULE3
case|:
case|case
name|FFESTV_stateBLOCKDATA3
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_component_ -- Check ordering on<component-decl> statement     if (ffestc_order_component_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_component_
parameter_list|()
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateTYPE
case|:
case|case
name|FFESTV_stateSTRUCTURE
case|:
case|case
name|FFESTV_stateMAP
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_order_contains_ -- Check ordering on CONTAINS statement     if (ffestc_order_contains_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_contains_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
case|case
name|FFESTV_statePROGRAM3
case|:
case|case
name|FFESTV_statePROGRAM4
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM5
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateSUBROUTINE4
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE5
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateFUNCTION4
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION5
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateMODULE0
case|:
case|case
name|FFESTV_stateMODULE1
case|:
case|case
name|FFESTV_stateMODULE2
case|:
case|case
name|FFESTV_stateMODULE3
case|:
case|case
name|FFESTV_stateMODULE4
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateMODULE5
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateUSE
case|:
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_previous
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_order_data_ -- Check ordering on DATA statement     if (ffestc_order_data_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_data_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM2
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE2
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION2
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateBLOCKDATA0
case|:
case|case
name|FFESTV_stateBLOCKDATA1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateBLOCKDATA2
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_statePROGRAM2
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateBLOCKDATA2
case|:
case|case
name|FFESTV_statePROGRAM3
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateBLOCKDATA3
case|:
case|case
name|FFESTV_statePROGRAM4
case|:
case|case
name|FFESTV_stateSUBROUTINE4
case|:
case|case
name|FFESTV_stateFUNCTION4
case|:
case|case
name|FFESTV_stateBLOCKDATA4
case|:
case|case
name|FFESTV_stateWHERETHEN
case|:
case|case
name|FFESTV_stateIFTHEN
case|:
case|case
name|FFESTV_stateDO
case|:
case|case
name|FFESTV_stateSELECT0
case|:
case|case
name|FFESTV_stateSELECT1
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_data77_ -- Check ordering on pedantic-F77 DATA statement     if (ffestc_order_data77_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_data77_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
case|case
name|FFESTV_statePROGRAM3
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM4
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE4
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION4
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateBLOCKDATA0
case|:
case|case
name|FFESTV_stateBLOCKDATA1
case|:
case|case
name|FFESTV_stateBLOCKDATA2
case|:
case|case
name|FFESTV_stateBLOCKDATA3
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateBLOCKDATA4
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_statePROGRAM4
case|:
case|case
name|FFESTV_stateSUBROUTINE4
case|:
case|case
name|FFESTV_stateFUNCTION4
case|:
case|case
name|FFESTV_stateBLOCKDATA4
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateWHERETHEN
case|:
case|case
name|FFESTV_stateIFTHEN
case|:
case|case
name|FFESTV_stateDO
case|:
case|case
name|FFESTV_stateSELECT0
case|:
case|case
name|FFESTV_stateSELECT1
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_derivedtype_ -- Check ordering on derived TYPE statement     if (ffestc_order_derivedtype_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_derivedtype_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateMODULE0
case|:
case|case
name|FFESTV_stateMODULE1
case|:
case|case
name|FFESTV_stateMODULE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateMODULE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_statePROGRAM3
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateMODULE3
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_order_do_ -- Check ordering on<do> statement     if (ffestc_order_do_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_do_
parameter_list|()
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateDO
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_entry_ -- Check ordering on ENTRY statement     if (ffestc_order_entry_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_entry_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateSUBROUTINE0
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE1
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateFUNCTION0
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION1
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateSUBROUTINE4
case|:
case|case
name|FFESTV_stateFUNCTION4
case|:
break|break;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_previous
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
case|case
name|FFESTV_stateMODULE5
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_exec_ -- Check ordering on<exec> statement     if (ffestc_order_exec_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_exec_
parameter_list|()
block|{
name|bool
name|update
decl_stmt|;
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
case|case
name|FFESTV_statePROGRAM3
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM4
argument_list|)
expr_stmt|;
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE4
argument_list|)
expr_stmt|;
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION4
argument_list|)
expr_stmt|;
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_statePROGRAM4
case|:
case|case
name|FFESTV_stateSUBROUTINE4
case|:
case|case
name|FFESTV_stateFUNCTION4
case|:
name|update
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateIFTHEN
case|:
case|case
name|FFESTV_stateDO
case|:
case|case
name|FFESTV_stateSELECT1
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_previous
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateINTERFACE0
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|if
condition|(
name|update
condition|)
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
if|if
condition|(
name|update
condition|)
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_format_ -- Check ordering on FORMAT statement     if (ffestc_order_format_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_format_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM1
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE1
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateFUNCTION0
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION1
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_statePROGRAM3
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_statePROGRAM4
case|:
case|case
name|FFESTV_stateSUBROUTINE4
case|:
case|case
name|FFESTV_stateFUNCTION4
case|:
case|case
name|FFESTV_stateWHERETHEN
case|:
case|case
name|FFESTV_stateIFTHEN
case|:
case|case
name|FFESTV_stateDO
case|:
case|case
name|FFESTV_stateSELECT0
case|:
case|case
name|FFESTV_stateSELECT1
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_function_ -- Check ordering on<function> statement     if (ffestc_order_function_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_function_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateFUNCTION4
case|:
case|case
name|FFESTV_stateFUNCTION5
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_iface_ -- Check ordering on<iface> statement     if (ffestc_order_iface_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_iface_
parameter_list|()
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
case|case
name|FFESTV_statePROGRAM5
case|:
case|case
name|FFESTV_stateSUBROUTINE5
case|:
case|case
name|FFESTV_stateFUNCTION5
case|:
case|case
name|FFESTV_stateMODULE5
case|:
case|case
name|FFESTV_stateINTERFACE0
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_ifthen_ -- Check ordering on<ifthen> statement     if (ffestc_order_ifthen_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_ifthen_
parameter_list|()
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateIFTHEN
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_implicit_ -- Check ordering on IMPLICIT statement     if (ffestc_order_implicit_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_implicit_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM2
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE2
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION2
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateMODULE0
case|:
case|case
name|FFESTV_stateMODULE1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateMODULE2
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateBLOCKDATA0
case|:
case|case
name|FFESTV_stateBLOCKDATA1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateBLOCKDATA2
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_statePROGRAM2
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateMODULE2
case|:
case|case
name|FFESTV_stateBLOCKDATA2
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_implicitnone_ -- Check ordering on IMPLICIT NONE statement     if (ffestc_order_implicitnone_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_implicitnone_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateMODULE0
case|:
case|case
name|FFESTV_stateMODULE1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateMODULE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateBLOCKDATA0
case|:
case|case
name|FFESTV_stateBLOCKDATA1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateBLOCKDATA3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_interface_ -- Check ordering on<interface> statement     if (ffestc_order_interface_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_interface_
parameter_list|()
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateINTERFACE0
case|:
case|case
name|FFESTV_stateINTERFACE1
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_order_map_ -- Check ordering on<map> statement     if (ffestc_order_map_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_map_
parameter_list|()
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateMAP
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_order_module_ -- Check ordering on<module> statement     if (ffestc_order_module_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_module_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateMODULE0
case|:
case|case
name|FFESTV_stateMODULE1
case|:
case|case
name|FFESTV_stateMODULE2
case|:
case|case
name|FFESTV_stateMODULE3
case|:
case|case
name|FFESTV_stateMODULE4
case|:
case|case
name|FFESTV_stateMODULE5
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_order_parameter_ -- Check ordering on<parameter> statement     if (ffestc_order_parameter_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_parameter_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM2
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE2
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION2
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateMODULE0
case|:
case|case
name|FFESTV_stateMODULE1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateMODULE2
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateBLOCKDATA0
case|:
case|case
name|FFESTV_stateBLOCKDATA1
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateBLOCKDATA2
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_statePROGRAM2
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateMODULE2
case|:
case|case
name|FFESTV_stateBLOCKDATA2
case|:
case|case
name|FFESTV_statePROGRAM3
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateMODULE3
case|:
case|case
name|FFESTV_stateBLOCKDATA3
case|:
case|case
name|FFESTV_stateTYPE
case|:
comment|/* GNU extension here! */
case|case
name|FFESTV_stateSTRUCTURE
case|:
case|case
name|FFESTV_stateUNION
case|:
case|case
name|FFESTV_stateMAP
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_program_ -- Check ordering on<program> statement     if (ffestc_order_program_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_program_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
case|case
name|FFESTV_statePROGRAM3
case|:
case|case
name|FFESTV_statePROGRAM4
case|:
case|case
name|FFESTV_statePROGRAM5
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_progspec_ -- Check ordering on<progspec> statement     if (ffestc_order_progspec_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_progspec_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateMODULE0
case|:
case|case
name|FFESTV_stateMODULE1
case|:
case|case
name|FFESTV_stateMODULE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateMODULE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_statePROGRAM3
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateMODULE3
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateBLOCKDATA0
case|:
case|case
name|FFESTV_stateBLOCKDATA1
case|:
case|case
name|FFESTV_stateBLOCKDATA2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateBLOCKDATA2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_BLOCKDATA_STMT
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_record_ -- Check ordering on RECORD statement     if (ffestc_order_record_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_record_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateMODULE0
case|:
case|case
name|FFESTV_stateMODULE1
case|:
case|case
name|FFESTV_stateMODULE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateMODULE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateBLOCKDATA0
case|:
case|case
name|FFESTV_stateBLOCKDATA1
case|:
case|case
name|FFESTV_stateBLOCKDATA2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateBLOCKDATA3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_statePROGRAM3
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateMODULE3
case|:
case|case
name|FFESTV_stateBLOCKDATA3
case|:
case|case
name|FFESTV_stateSTRUCTURE
case|:
case|case
name|FFESTV_stateMAP
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_order_selectcase_ -- Check ordering on<selectcase> statement     if (ffestc_order_selectcase_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_selectcase_
parameter_list|()
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateSELECT0
case|:
case|case
name|FFESTV_stateSELECT1
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_sfunc_ -- Check ordering on statement-function definition     if (ffestc_order_sfunc_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_sfunc_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_statePROGRAM3
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_spec_ -- Check ordering on<spec> statement     if (ffestc_order_spec_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_spec_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateMODULE0
case|:
case|case
name|FFESTV_stateMODULE1
case|:
case|case
name|FFESTV_stateMODULE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateMODULE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateMODULE3
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_order_structure_ -- Check ordering on<structure> statement     if (ffestc_order_structure_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_structure_
parameter_list|()
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateSTRUCTURE
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_order_subroutine_ -- Check ordering on<subroutine> statement     if (ffestc_order_subroutine_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_subroutine_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateSUBROUTINE4
case|:
case|case
name|FFESTV_stateSUBROUTINE5
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_type_ -- Check ordering on<type> statement     if (ffestc_order_type_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_type_
parameter_list|()
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateTYPE
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_order_typedecl_ -- Check ordering on<typedecl> statement     if (ffestc_order_typedecl_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_typedecl_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateMODULE0
case|:
case|case
name|FFESTV_stateMODULE1
case|:
case|case
name|FFESTV_stateMODULE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateMODULE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateBLOCKDATA0
case|:
case|case
name|FFESTV_stateBLOCKDATA1
case|:
case|case
name|FFESTV_stateBLOCKDATA2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateBLOCKDATA3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_statePROGRAM3
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateMODULE3
case|:
case|case
name|FFESTV_stateBLOCKDATA3
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_union_ -- Check ordering on<union> statement     if (ffestc_order_union_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_union_
parameter_list|()
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateUNION
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_order_unit_ -- Check ordering on<unit> statement     if (ffestc_order_unit_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_unit_
parameter_list|()
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_order_use_ -- Check ordering on USE statement     if (ffestc_order_use_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_use_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM1
argument_list|)
expr_stmt|;
name|ffestc_shriek_begin_uses_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateSUBROUTINE0
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE1
argument_list|)
expr_stmt|;
name|ffestc_shriek_begin_uses_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateFUNCTION0
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION1
argument_list|)
expr_stmt|;
name|ffestc_shriek_begin_uses_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateMODULE0
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateMODULE1
argument_list|)
expr_stmt|;
name|ffestc_shriek_begin_uses_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateUSE
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_order_vxtstructure_ -- Check ordering on STRUCTURE statement     if (ffestc_order_vxtstructure_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_vxtstructure_
parameter_list|()
block|{
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_statePROGRAM3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSUBROUTINE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateFUNCTION3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateMODULE0
case|:
case|case
name|FFESTV_stateMODULE1
case|:
case|case
name|FFESTV_stateMODULE2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateMODULE3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateBLOCKDATA0
case|:
case|case
name|FFESTV_stateBLOCKDATA1
case|:
case|case
name|FFESTV_stateBLOCKDATA2
case|:
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateBLOCKDATA3
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_statePROGRAM3
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateMODULE3
case|:
case|case
name|FFESTV_stateBLOCKDATA3
case|:
case|case
name|FFESTV_stateSTRUCTURE
case|:
case|case
name|FFESTV_stateMAP
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_order_where_ -- Check ordering on<where> statement     if (ffestc_order_where_() != FFESTC_orderOK_)        return;	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|ffestcOrder_
name|ffestc_order_where_
parameter_list|()
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateWHERETHEN
case|:
return|return
name|FFESTC_orderOK_
return|;
case|case
name|FFESTV_stateWHERE
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_where_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
case|case
name|FFESTV_stateIF
case|:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_shriek_if_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
return|return
name|FFESTC_orderBAD_
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Invoked for each token in dummy arg list of FUNCTION, SUBROUTINE, and    ENTRY (prior to the first executable statement).  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_promote_dummy_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffebld
name|e
decl_stmt|;
name|bool
name|sfref_ok
decl_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeASTERISK
condition|)
block|{
name|ffebld_append_item
argument_list|(
operator|&
name|ffestc_local_
operator|.
name|dummy
operator|.
name|list_bottom
argument_list|,
name|ffebld_new_star
argument_list|()
argument_list|)
expr_stmt|;
return|return;
comment|/* Don't bother with alternate returns! */
block|}
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
name|sfref_ok
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|na
operator|=
name|sa
expr_stmt|;
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
block|{
if|if
condition|(
name|ffestc_entry_num_
operator|==
name|ffesymbol_maxentrynum
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/* Seen this one twice in this list! */
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
block|}
else|else
name|na
operator|=
name|sa
expr_stmt|;
name|sfref_ok
operator|=
name|TRUE
expr_stmt|;
comment|/* Ok for sym to be ref'd in sfuncdef 				   previously, since already declared as a 				   dummy arg. */
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsANY
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsANYSIZE
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
condition|)
name|na
operator|=
name|sa
operator||
name|FFESYMBOL_attrsDUMMY
expr_stmt|;
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
if|if
condition|(
operator|!
name|ffesymbol_is_specable
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
operator|!
name|sfref_ok
operator|||
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereDUMMY
operator|)
operator|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Can't dcl sym ref'd in sfuncdef. */
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
name|ffesymbol_set_maxentrynum
argument_list|(
name|s
argument_list|,
name|ffestc_entry_num_
argument_list|)
expr_stmt|;
name|ffesymbol_set_numentries
argument_list|(
name|s
argument_list|,
name|ffesymbol_numentries
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|e
operator|=
name|ffebld_new_symter
argument_list|(
name|s
argument_list|,
name|FFEINTRIN_genNONE
argument_list|,
name|FFEINTRIN_specNONE
argument_list|,
name|FFEINTRIN_impNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindNONE
argument_list|,
name|FFEINFO_whereNONE
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_append_item
argument_list|(
operator|&
name|ffestc_local_
operator|.
name|dummy
operator|.
name|list_bottom
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_promote_execdummy_ -- Declare token as dummy variable in exec context     ffestc_promote_execdummy_(t);     Invoked for each token in dummy arg list of ENTRY when the statement    follows the first executable statement.  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_promote_execdummy_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffesymbolState
name|ss
decl_stmt|;
name|ffesymbolState
name|ns
decl_stmt|;
name|ffeinfoKind
name|kind
decl_stmt|;
name|ffeinfoWhere
name|where
decl_stmt|;
name|ffebld
name|e
decl_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelex_token_type
argument_list|(
name|t
argument_list|)
operator|==
name|FFELEX_typeASTERISK
condition|)
block|{
name|ffebld_append_item
argument_list|(
operator|&
name|ffestc_local_
operator|.
name|dummy
operator|.
name|list_bottom
argument_list|,
name|ffebld_new_star
argument_list|()
argument_list|)
expr_stmt|;
return|return;
comment|/* Don't bother with alternate returns! */
block|}
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|t
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|na
operator|=
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ss
operator|=
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|where
operator|=
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_entry_num_
operator|==
name|ffesymbol_maxentrynum
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/* Seen this one twice in this list! */
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
block|}
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
name|ns
operator|=
name|FFESYMBOL_stateUNDERSTOOD
expr_stmt|;
comment|/* Assume we know it all know. */
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|FFEINFO_kindENTITY
case|:
case|case
name|FFEINFO_kindFUNCTION
case|:
case|case
name|FFEINFO_kindSUBROUTINE
case|:
break|break;
comment|/* These are fine, as far as we know. */
case|case
name|FFEINFO_kindNONE
case|:
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
condition|)
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
comment|/* Learned nothing new. */
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANYLEN
condition|)
block|{
name|kind
operator|=
name|FFEINFO_kindENTITY
expr_stmt|;
name|where
operator|=
name|FFEINFO_whereDUMMY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsACTUALARG
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
else|else
block|{
name|na
operator|=
name|sa
operator||
name|FFESYMBOL_attrsDUMMY
expr_stmt|;
name|ns
operator|=
name|FFESYMBOL_stateUNCERTAIN
expr_stmt|;
block|}
break|break;
default|default:
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Error. */
break|break;
block|}
switch|switch
condition|(
name|where
condition|)
block|{
case|case
name|FFEINFO_whereDUMMY
case|:
break|break;
comment|/* This is fine. */
case|case
name|FFEINFO_whereNONE
case|:
name|where
operator|=
name|FFEINFO_whereDUMMY
expr_stmt|;
break|break;
default|default:
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Error. */
break|break;
block|}
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|ns
argument_list|)
expr_stmt|;
name|ffesymbol_set_maxentrynum
argument_list|(
name|s
argument_list|,
name|ffestc_entry_num_
argument_list|)
expr_stmt|;
name|ffesymbol_set_numentries
argument_list|(
name|s
argument_list|,
name|ffesymbol_numentries
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ns
operator|==
name|FFESYMBOL_stateUNDERSTOOD
operator|)
operator|&&
operator|(
name|kind
operator|!=
name|FFEINFO_kindSUBROUTINE
operator|)
operator|&&
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
argument_list|,
name|kind
argument_list|,
name|where
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|ffebld_new_symter
argument_list|(
name|s
argument_list|,
name|FFEINTRIN_genNONE
argument_list|,
name|FFEINTRIN_specNONE
argument_list|,
name|FFEINTRIN_impNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
argument_list|,
name|ffeinfo_use
argument_list|(
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_append_item
argument_list|(
operator|&
name|ffestc_local_
operator|.
name|dummy
operator|.
name|list_bottom
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_promote_sfdummy_ -- Declare token as stmt-func dummy variable     ffestc_promote_sfdummy_(t);     Invoked for each token in dummy arg list of statement function.     22-Oct-91  JCB  1.1       Reject arg if CHARACTER*(*).  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_promote_sfdummy_
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbol
name|sp
decl_stmt|;
comment|/* Parent symbol. */
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffebld
name|e
decl_stmt|;
name|assert
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_sfdummy
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Sets maxentrynum to 0 for new obj; 					   also sets sfa_dummy_parent to 					   parent symbol. */
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|!=
name|FFESYMBOL_stateNONE
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Dummy already in list. */
return|return;
block|}
name|sp
operator|=
name|ffesymbol_sfdummyparent
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Now flag dummy's parent as used 					   for dummy. */
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
operator|!
name|ffesymbol_is_specable
argument_list|(
name|sp
argument_list|)
operator|&&
operator|(
operator|(
name|ffesymbol_kind
argument_list|(
name|sp
argument_list|)
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
operator|(
name|ffesymbol_where
argument_list|(
name|sp
argument_list|)
operator|!=
name|FFEINFO_whereLOCAL
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|sp
argument_list|)
operator|!=
name|FFEINFO_whereCOMMON
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|sp
argument_list|)
operator|!=
name|FFEINFO_whereDUMMY
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|sp
argument_list|)
operator|!=
name|FFEINFO_whereNONE
operator|)
operator|)
operator|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Can't be PARAMETER etc., must be a var. */
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|na
operator|=
name|sa
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsRESULT
operator||
name|FFESYMBOL_attrsSAVE
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
condition|)
name|na
operator|=
name|sa
operator||
name|FFESYMBOL_attrsSFARG
expr_stmt|;
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|sp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_set_state
argument_list|(
name|sp
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
name|ffesymbol_set_attrs
argument_list|(
name|sp
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|sp
argument_list|)
operator|||
operator|(
operator|(
name|ffesymbol_basictype
argument_list|(
name|sp
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
operator|&&
operator|(
name|ffesymbol_size
argument_list|(
name|sp
argument_list|)
operator|==
name|FFETARGET_charactersizeNONE
operator|)
operator|)
condition|)
name|ffesymbol_error
argument_list|(
name|sp
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|sp
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereDUMMY
argument_list|,
name|ffesymbol_size
argument_list|(
name|sp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_set_maxentrynum
argument_list|(
name|s
argument_list|,
name|ffestc_sfdummy_argno_
operator|++
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|e
operator|=
name|ffebld_new_symter
argument_list|(
name|s
argument_list|,
name|FFEINTRIN_genNONE
argument_list|,
name|FFEINTRIN_specNONE
argument_list|,
name|FFEINTRIN_impNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
argument_list|,
name|ffeinfo_use
argument_list|(
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_append_item
argument_list|(
operator|&
name|ffestc_local_
operator|.
name|dummy
operator|.
name|list_bottom
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_shriek_begin_program_ -- Implicit PROGRAM statement     ffestc_shriek_begin_program_();     Invoked only when a PROGRAM statement is NOT present at the beginning    of a main program unit.  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_shriek_begin_program_
parameter_list|()
block|{
name|ffestw
name|b
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|ffestc_blocknum_
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_statePROGRAM0
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
name|ffestc_blocknum_
operator|++
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_end_program_
argument_list|)
expr_stmt|;
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_programunit
argument_list|(
name|NULL
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Special case: this is one symbol that won't go through      ffestu_exec_transition_ when the first statement in a main program is      executable, because the transition happens in ffest before ffestc is      reached and triggers the implicit generation of a main program.  So we      do the exec transition for the implicit main program right here, just      for cleanliness' sake (at the very least). */
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindPROGRAM
argument_list|,
name|FFEINFO_whereLOCAL
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffestd_R1102
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_shriek_begin_uses_ -- Start a bunch of USE statements     ffestc_shriek_begin_uses_();     Invoked before handling the first USE statement in a block of one or    more USE statements.	 _end_uses_(bool ok) is invoked before handling    the first statement after the block (there are no BEGIN USE and END USE    statements, but the semantics of USE statements effectively requires    handling them as a single block rather than one statement at a time).  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|void
name|ffestc_shriek_begin_uses_
parameter_list|()
block|{
name|ffestw
name|b
decl_stmt|;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateUSE
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_end_uses_
argument_list|)
expr_stmt|;
name|ffestd_begin_uses
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_shriek_blockdata_ -- End a BLOCK DATA     ffestc_shriek_blockdata_(TRUE);  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_shriek_blockdata_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ffesta_seen_first_exec
condition|)
block|{
name|ffesta_seen_first_exec
operator|=
name|TRUE
expr_stmt|;
name|ffestd_exec_begin
argument_list|()
expr_stmt|;
block|}
name|ffestd_R1112
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|ffestd_exec_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
name|ffe_terminate_2
argument_list|()
expr_stmt|;
name|ffe_init_2
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_shriek_do_ -- End of statement following DO-term-stmt etc     ffestc_shriek_do_(TRUE);     Also invoked by _labeldef_branch_end_ (or, in cases    of errors, other _labeldef_ functions) when the label definition is    for a DO-target (LOOPEND) label, once per matching/outstanding DO    block on the stack.	These cases invoke this function with ok==TRUE, so    only forced stack popping (via ffestc_eof()) invokes it with ok==FALSE.  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_shriek_do_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
name|ffelab
name|l
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|l
operator|=
name|ffestw_label
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffewhere_line_is_unknown
argument_list|(
name|ffelab_definition_line
argument_list|(
name|l
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* DO target is label that is still 				   undefined. */
name|assert
argument_list|(
operator|(
name|ffelab_type
argument_list|(
name|l
argument_list|)
operator|==
name|FFELAB_typeLOOPEND
operator|)
operator|||
operator|(
name|ffelab_type
argument_list|(
name|l
argument_list|)
operator|==
name|FFELAB_typeANY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffelab_type
argument_list|(
name|l
argument_list|)
operator|!=
name|FFELAB_typeANY
condition|)
block|{
name|ffelab_set_definition_line
argument_list|(
name|l
argument_list|,
name|ffewhere_line_use
argument_list|(
name|ffelab_doref_line
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffelab_set_definition_column
argument_list|(
name|l
argument_list|,
name|ffewhere_column_use
argument_list|(
name|ffelab_doref_column
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffestv_num_label_defines_
operator|++
expr_stmt|;
block|}
name|ffestd_labeldef_branch
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
name|ffestd_do
argument_list|(
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestw_do_iter_var_t
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestw_do_iter_var_t
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestw_do_iter_var
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|NULL
condition|)
name|ffesymbol_set_is_doiter
argument_list|(
name|ffestw_do_iter_var
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_shriek_end_program_ -- End a PROGRAM     ffestc_shriek_end_program_();  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_shriek_end_program_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ffesta_seen_first_exec
condition|)
block|{
name|ffesta_seen_first_exec
operator|=
name|TRUE
expr_stmt|;
name|ffestd_exec_begin
argument_list|()
expr_stmt|;
block|}
name|ffestd_R1103
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|ffestd_exec_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
name|ffe_terminate_2
argument_list|()
expr_stmt|;
name|ffe_init_2
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_shriek_end_uses_ -- End a bunch of USE statements     ffestc_shriek_end_uses_(TRUE);     ok==TRUE means simply not popping due to ffestc_eof()    being called, because there is no formal END USES statement in Fortran.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|void
name|ffestc_shriek_end_uses_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
name|ffestd_end_uses
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_shriek_function_ -- End a FUNCTION     ffestc_shriek_function_(TRUE);  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_shriek_function_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ffesta_seen_first_exec
condition|)
block|{
name|ffesta_seen_first_exec
operator|=
name|TRUE
expr_stmt|;
name|ffestd_exec_begin
argument_list|()
expr_stmt|;
block|}
name|ffestd_R1221
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|ffestd_exec_end
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
name|ffesta_is_entry_valid
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffe_terminate_2
argument_list|()
expr_stmt|;
name|ffe_init_2
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ffe_terminate_3
argument_list|()
expr_stmt|;
name|ffe_init_3
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTV_stateINTERFACE0
case|:
name|ffe_terminate_4
argument_list|()
expr_stmt|;
name|ffe_init_4
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_shriek_if_ -- End of statement following logical IF     ffestc_shriek_if_(TRUE);     Applies ONLY to logical IF, not to IF-THEN.	For example, does not    ffelex_token_kill the construct name for an IF-THEN block (the name    field is invalid for logical IF).  ok==TRUE iff statement following    logical IF (substatement) is valid; else, statement is invalid or    stack forcibly popped due to ffestc_eof().  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_shriek_if_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
name|ffestd_end_R807
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
name|ffestc_shriek_after1_
operator|=
name|NULL
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_shriek_ifthen_ -- End an IF-THEN     ffestc_shriek_ifthen_(TRUE);	 */
end_comment

begin_function
specifier|static
name|void
name|ffestc_shriek_ifthen_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
name|ffestd_R806
argument_list|(
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_shriek_interface_ -- End an INTERFACE     ffestc_shriek_interface_(TRUE);  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|void
name|ffestc_shriek_interface_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
name|ffestd_R1203
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_shriek_map_ -- End a MAP     ffestc_shriek_map_(TRUE);  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
specifier|static
name|void
name|ffestc_shriek_map_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
name|ffestd_V013
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_shriek_module_ -- End a MODULE     ffestc_shriek_module_(TRUE);	 */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|void
name|ffestc_shriek_module_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ffesta_seen_first_exec
condition|)
block|{
name|ffesta_seen_first_exec
operator|=
name|TRUE
expr_stmt|;
name|ffestd_exec_begin
argument_list|()
expr_stmt|;
block|}
name|ffestd_R1106
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|ffestd_exec_end
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
name|ffe_terminate_2
argument_list|()
expr_stmt|;
name|ffe_init_2
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_shriek_select_ -- End a SELECT     ffestc_shriek_select_(TRUE);	 */
end_comment

begin_function
specifier|static
name|void
name|ffestc_shriek_select_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
name|ffestwSelect
name|s
decl_stmt|;
name|ffestwCase
name|c
decl_stmt|;
name|ffestd_R811
argument_list|(
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|NULL
condition|)
name|ffelex_token_kill
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffestw_select
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|s
operator|->
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|s
operator|->
name|first_rel
init|;
name|c
operator|!=
operator|(
name|ffestwCase
operator|)
operator|&
name|s
operator|->
name|first_rel
condition|;
name|c
operator|=
name|c
operator|->
name|next_rel
control|)
name|ffelex_token_kill
argument_list|(
name|c
operator|->
name|t
argument_list|)
expr_stmt|;
name|malloc_pool_kill
argument_list|(
name|s
operator|->
name|pool
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_shriek_structure_ -- End a STRUCTURE     ffestc_shriek_structure_(TRUE);  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
specifier|static
name|void
name|ffestc_shriek_structure_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
name|ffestd_V004
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_shriek_subroutine_ -- End a SUBROUTINE     ffestc_shriek_subroutine_(TRUE);  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_shriek_subroutine_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ffesta_seen_first_exec
condition|)
block|{
name|ffesta_seen_first_exec
operator|=
name|TRUE
expr_stmt|;
name|ffestd_exec_begin
argument_list|()
expr_stmt|;
block|}
name|ffestd_R1225
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|ffestd_exec_end
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
name|ffesta_is_entry_valid
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffe_terminate_2
argument_list|()
expr_stmt|;
name|ffe_init_2
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ffe_terminate_3
argument_list|()
expr_stmt|;
name|ffe_init_3
argument_list|()
expr_stmt|;
break|break;
case|case
name|FFESTV_stateINTERFACE0
case|:
name|ffe_terminate_4
argument_list|()
expr_stmt|;
name|ffe_init_4
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_shriek_type_ -- End a TYPE     ffestc_shriek_type_(TRUE);  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|void
name|ffestc_shriek_type_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
name|ffestd_R425
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|ffe_terminate_4
argument_list|()
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_shriek_union_ -- End a UNION     ffestc_shriek_union_(TRUE);	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
specifier|static
name|void
name|ffestc_shriek_union_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
name|ffestd_V010
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_shriek_where_ -- Implicit END WHERE statement     ffestc_shriek_where_(TRUE);     Implement the end of the current WHERE "block".  ok==TRUE iff statement    following WHERE (substatement) is valid; else, statement is invalid    or stack forcibly popped due to ffestc_eof().  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|void
name|ffestc_shriek_where_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
name|ffestd_R745
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
name|ffestc_shriek_after1_
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|FFESTV_stateIF
condition|)
name|ffestc_shriek_if_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* "IF (x) WHERE (y) stmt" is only valid 				   case. */
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_shriek_wherethen_ -- End a WHERE(-THEN)     ffestc_shriek_wherethen_(TRUE);  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
specifier|static
name|void
name|ffestc_shriek_wherethen_
parameter_list|(
name|bool
name|ok
parameter_list|)
block|{
name|ffestd_end_R740
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|ffestw_kill
argument_list|(
name|ffestw_pop
argument_list|()
argument_list|)
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_subr_binsrch_ -- Binary search of char const in list of strings     i = ffestc_subr_binsrch_(search_list,search_list_size,&spec,"etc");     search_list contains search_list_size char *'s, spec is checked to see    if it is a char constant and, if so, is binary-searched against the list.    0 is returned if not found, else the "classic" index (beginning with 1)    is returned.	 Before returning 0 where the search was performed but    fruitless, if "etc" is a non-NULL char *, an error message is displayed    using "etc" as the pick-one-of-these string.	 */
end_comment

begin_function
specifier|static
name|int
name|ffestc_subr_binsrch_
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|list
parameter_list|,
name|int
name|size
parameter_list|,
name|ffestpFile
modifier|*
name|spec
parameter_list|,
specifier|const
name|char
modifier|*
name|whine
parameter_list|)
block|{
name|int
name|lowest_tested
decl_stmt|;
name|int
name|highest_tested
decl_stmt|;
name|int
name|halfway
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Nobody should pass size == 0, but for 				   elegance.... */
name|lowest_tested
operator|=
operator|-
literal|1
expr_stmt|;
name|highest_tested
operator|=
name|size
expr_stmt|;
name|halfway
operator|=
name|size
operator|>>
literal|1
expr_stmt|;
name|list
operator|+=
name|halfway
expr_stmt|;
name|c
operator|=
name|ffestc_subr_speccmp_
argument_list|(
operator|*
name|list
argument_list|,
name|spec
argument_list|,
operator|&
name|str
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|2
condition|)
return|return
literal|0
return|;
name|c
operator|=
operator|-
name|c
expr_stmt|;
comment|/* Sigh.  */
name|next
label|:
comment|/* :::::::::::::::::::: */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|offset
operator|=
operator|(
name|halfway
operator|-
name|lowest_tested
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
goto|goto
name|nope
goto|;
comment|/* :::::::::::::::::::: */
name|highest_tested
operator|=
name|halfway
expr_stmt|;
name|list
operator|-=
name|offset
expr_stmt|;
name|halfway
operator|-=
name|offset
expr_stmt|;
name|c
operator|=
name|ffesrc_strcmp_1ns2i
argument_list|(
name|ffe_case_match
argument_list|()
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
operator|*
name|list
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
comment|/* :::::::::::::::::::: */
case|case
literal|0
case|:
return|return
name|halfway
operator|+
literal|1
return|;
case|case
literal|1
case|:
name|offset
operator|=
operator|(
name|highest_tested
operator|-
name|halfway
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
goto|goto
name|nope
goto|;
comment|/* :::::::::::::::::::: */
name|lowest_tested
operator|=
name|halfway
expr_stmt|;
name|list
operator|+=
name|offset
expr_stmt|;
name|halfway
operator|+=
name|offset
expr_stmt|;
name|c
operator|=
name|ffesrc_strcmp_1ns2i
argument_list|(
name|ffe_case_match
argument_list|()
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
operator|*
name|list
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
comment|/* :::::::::::::::::::: */
default|default:
name|assert
argument_list|(
literal|"unexpected return from ffesrc_strcmp_1ns2i"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|nope
label|:
comment|/* :::::::::::::::::::: */
name|ffebad_start
argument_list|(
name|FFEBAD_SPEC_VALUE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|spec
operator|->
name|value
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|spec
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|whine
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ffestc_subr_format_ -- Return summary of format specifier     ffestc_subr_format_(&specifier);  */
end_comment

begin_function
specifier|static
name|ffestvFormat
name|ffestc_subr_format_
parameter_list|(
name|ffestpFile
modifier|*
name|spec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|spec
operator|->
name|kw_or_val_present
condition|)
return|return
name|FFESTV_formatNONE
return|;
name|assert
argument_list|(
name|spec
operator|->
name|value_present
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|->
name|value_is_label
condition|)
return|return
name|FFESTV_formatLABEL
return|;
comment|/* Ok if not a label. */
name|assert
argument_list|(
name|spec
operator|->
name|value
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|spec
operator|->
name|u
operator|.
name|expr
argument_list|)
operator|==
name|FFEBLD_opSTAR
condition|)
return|return
name|FFESTV_formatASTERISK
return|;
if|if
condition|(
name|ffeinfo_kind
argument_list|(
name|ffebld_info
argument_list|(
name|spec
operator|->
name|u
operator|.
name|expr
argument_list|)
argument_list|)
operator|==
name|FFEINFO_kindNAMELIST
condition|)
return|return
name|FFESTV_formatNAMELIST
return|;
if|if
condition|(
name|ffeinfo_rank
argument_list|(
name|ffebld_info
argument_list|(
name|spec
operator|->
name|u
operator|.
name|expr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FFESTV_formatCHAREXPR
return|;
comment|/* F77 C5. */
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|spec
operator|->
name|u
operator|.
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
return|return
name|FFESTV_formatINTEXPR
return|;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
return|return
name|FFESTV_formatCHAREXPR
return|;
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|FFESTV_formatASTERISK
return|;
default|default:
name|assert
argument_list|(
literal|"bad basictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FFESTV_formatINTEXPR
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_subr_is_branch_ -- Handle specifier as branch target label     ffestc_subr_is_branch_(&specifier);	*/
end_comment

begin_function
specifier|static
name|bool
name|ffestc_subr_is_branch_
parameter_list|(
name|ffestpFile
modifier|*
name|spec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|spec
operator|->
name|kw_or_val_present
condition|)
return|return
name|TRUE
return|;
name|assert
argument_list|(
name|spec
operator|->
name|value_present
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|spec
operator|->
name|value_is_label
argument_list|)
expr_stmt|;
name|spec
operator|->
name|value_is_label
operator|++
expr_stmt|;
comment|/* For checking purposes only; 1=>2. */
return|return
name|ffestc_labelref_is_branch_
argument_list|(
name|spec
operator|->
name|value
argument_list|,
operator|&
name|spec
operator|->
name|u
operator|.
name|label
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestc_subr_is_format_ -- Handle specifier as format target label     ffestc_subr_is_format_(&specifier);	*/
end_comment

begin_function
specifier|static
name|bool
name|ffestc_subr_is_format_
parameter_list|(
name|ffestpFile
modifier|*
name|spec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|spec
operator|->
name|kw_or_val_present
condition|)
return|return
name|TRUE
return|;
name|assert
argument_list|(
name|spec
operator|->
name|value_present
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spec
operator|->
name|value_is_label
condition|)
return|return
name|TRUE
return|;
comment|/* Ok if not a label. */
name|spec
operator|->
name|value_is_label
operator|++
expr_stmt|;
comment|/* For checking purposes only; 1=>2. */
return|return
name|ffestc_labelref_is_format_
argument_list|(
name|spec
operator|->
name|value
argument_list|,
operator|&
name|spec
operator|->
name|u
operator|.
name|label
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ffestc_subr_is_present_ -- Ensure specifier is present, else error     ffestc_subr_is_present_("SPECIFIER",&specifier);  */
end_comment

begin_function
specifier|static
name|bool
name|ffestc_subr_is_present_
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ffestpFile
modifier|*
name|spec
parameter_list|)
block|{
if|if
condition|(
name|spec
operator|->
name|kw_or_val_present
condition|)
block|{
name|assert
argument_list|(
name|spec
operator|->
name|value_present
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|ffebad_start
argument_list|(
name|FFEBAD_MISSING_SPECIFIER
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ffestc_subr_speccmp_ -- Compare string to constant expression, if present     if (ffestc_subr_speccmp_("Constant",&specifier,NULL,NULL) == 0)        // specifier value is present and is a char constant "CONSTANT"     Like strcmp, except the return values are defined as: -1 returned in place    of strcmp's generic negative value, 1 in place of it's generic positive    value, and 2 when there is no character constant string to compare.	Also,    a case-insensitive comparison is performed, where string is assumed to    already be in InitialCaps form.     If a non-NULL pointer is provided as the char **target, then *target is    written with NULL if 2 is returned, a pointer to the constant string    value of the specifier otherwise.  Similarly, length is written with    0 if 2 is returned, the length of the constant string value otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ffestc_subr_speccmp_
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|ffestpFile
modifier|*
name|spec
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|target
parameter_list|,
name|int
modifier|*
name|length
parameter_list|)
block|{
name|ffebldConstant
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|spec
operator|->
name|kw_or_val_present
operator|||
operator|!
name|spec
operator|->
name|value_present
operator|||
operator|(
name|spec
operator|->
name|u
operator|.
name|expr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|spec
operator|->
name|u
operator|.
name|expr
argument_list|)
operator|!=
name|FFEBLD_opCONTER
operator|)
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|NULL
condition|)
operator|*
name|target
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|NULL
condition|)
operator|*
name|length
operator|=
literal|0
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|ffebld_constant_type
argument_list|(
name|c
operator|=
name|ffebld_conter
argument_list|(
name|spec
operator|->
name|u
operator|.
name|expr
argument_list|)
argument_list|)
operator|!=
name|FFEBLD_constCHARACTERDEFAULT
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|NULL
condition|)
operator|*
name|target
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|NULL
condition|)
operator|*
name|length
operator|=
literal|0
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|target
operator|!=
name|NULL
condition|)
operator|*
name|target
operator|=
name|ffebld_constant_characterdefault
argument_list|(
name|c
argument_list|)
operator|.
name|text
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|NULL
condition|)
operator|*
name|length
operator|=
name|ffebld_constant_characterdefault
argument_list|(
name|c
argument_list|)
operator|.
name|length
expr_stmt|;
name|i
operator|=
name|ffesrc_strcmp_1ns2i
argument_list|(
name|ffe_case_match
argument_list|()
argument_list|,
name|ffebld_constant_characterdefault
argument_list|(
name|c
argument_list|)
operator|.
name|text
argument_list|,
name|ffebld_constant_characterdefault
argument_list|(
name|c
argument_list|)
operator|.
name|length
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Yes indeed, we reverse the strings to 				   _strcmpin_.	 */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ffestc_subr_unit_ -- Return summary of unit specifier     ffestc_subr_unit_(&specifier);  */
end_comment

begin_function
specifier|static
name|ffestvUnit
name|ffestc_subr_unit_
parameter_list|(
name|ffestpFile
modifier|*
name|spec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|spec
operator|->
name|kw_or_val_present
condition|)
return|return
name|FFESTV_unitNONE
return|;
name|assert
argument_list|(
name|spec
operator|->
name|value_present
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|spec
operator|->
name|value
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|spec
operator|->
name|u
operator|.
name|expr
argument_list|)
operator|==
name|FFEBLD_opSTAR
condition|)
return|return
name|FFESTV_unitASTERISK
return|;
switch|switch
condition|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|spec
operator|->
name|u
operator|.
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|FFEINFO_basictypeINTEGER
case|:
return|return
name|FFESTV_unitINTEXPR
return|;
case|case
name|FFEINFO_basictypeCHARACTER
case|:
return|return
name|FFESTV_unitCHAREXPR
return|;
case|case
name|FFEINFO_basictypeANY
case|:
return|return
name|FFESTV_unitASTERISK
return|;
default|default:
name|assert
argument_list|(
literal|"bad basictype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FFESTV_unitINTEXPR
return|;
block|}
block|}
end_function

begin_comment
comment|/* Call this function whenever it's possible that one or more top    stack items are label-targeting DO blocks that have had their    labels defined, but at a time when they weren't at the top of the    stack.  This prevents uninformative diagnostics for programs    like "DO 10", "IF (...) THEN", "10 ELSE", "END IF", "END".  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_try_shriek_do_
parameter_list|()
block|{
name|ffelab
name|lab
decl_stmt|;
name|ffelabType
name|ty
decl_stmt|;
while|while
condition|(
operator|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|FFESTV_stateDO
operator|)
operator|&&
operator|(
operator|(
name|lab
operator|=
operator|(
name|ffestw_label
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ty
operator|=
operator|(
name|ffelab_type
argument_list|(
name|lab
argument_list|)
operator|)
operator|)
operator|==
name|FFELAB_typeANY
operator|)
operator|||
operator|(
name|ty
operator|==
name|FFELAB_typeUSELESS
operator|)
operator|||
operator|(
name|ty
operator|==
name|FFELAB_typeFORMAT
operator|)
operator|||
operator|(
name|ty
operator|==
name|FFELAB_typeNOTLOOP
operator|)
operator|||
operator|(
name|ty
operator|==
name|FFELAB_typeENDIF
operator|)
operator|)
condition|)
name|ffestc_shriek_do_
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_decl_start -- R426 or R501     ffestc_decl_start(...);     Verify that R426 component-def-stmt or R501 type-declaration-stmt are    valid here, figure out which one, and implement.  */
end_comment

begin_function
name|void
name|ffestc_decl_start
parameter_list|(
name|ffestpType
name|type
parameter_list|,
name|ffelexToken
name|typet
parameter_list|,
name|ffebld
name|kind
parameter_list|,
name|ffelexToken
name|kindt
parameter_list|,
name|ffebld
name|len
parameter_list|,
name|ffelexToken
name|lent
parameter_list|)
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateMODULE0
case|:
case|case
name|FFESTV_stateBLOCKDATA0
case|:
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateMODULE1
case|:
case|case
name|FFESTV_stateBLOCKDATA1
case|:
case|case
name|FFESTV_statePROGRAM2
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateMODULE2
case|:
case|case
name|FFESTV_stateBLOCKDATA2
case|:
case|case
name|FFESTV_statePROGRAM3
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateMODULE3
case|:
case|case
name|FFESTV_stateBLOCKDATA3
case|:
case|case
name|FFESTV_stateUSE
case|:
name|ffestc_local_
operator|.
name|decl
operator|.
name|is_R426
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|FFESTV_stateTYPE
case|:
case|case
name|FFESTV_stateSTRUCTURE
case|:
case|case
name|FFESTV_stateMAP
case|:
name|ffestc_local_
operator|.
name|decl
operator|.
name|is_R426
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|ffestc_order_bad_
argument_list|()
expr_stmt|;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestc_local_
operator|.
name|decl
operator|.
name|is_R426
operator|=
literal|0
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|is_R426
condition|)
block|{
if|#
directive|if
name|FFESTR_F90
case|case
literal|1
case|:
name|ffestc_R426_start
argument_list|(
name|type
argument_list|,
name|typet
argument_list|,
name|kind
argument_list|,
name|kindt
argument_list|,
name|len
argument_list|,
name|lent
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|2
case|:
name|ffestc_R501_start
argument_list|(
name|type
argument_list|,
name|typet
argument_list|,
name|kind
argument_list|,
name|kindt
argument_list|,
name|len
argument_list|,
name|lent
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_decl_attrib -- R426 or R501 type attribute     ffestc_decl_attrib(...);     Verify that R426 component-def-stmt or R501 type-declaration-stmt attribute    is valid here and implement.	 */
end_comment

begin_function
name|void
name|ffestc_decl_attrib
parameter_list|(
name|ffestpAttrib
name|attrib
name|UNUSED
parameter_list|,
name|ffelexToken
name|attribt
name|UNUSED
parameter_list|,
name|ffestrOther
name|intent_kw
name|UNUSED
parameter_list|,
name|ffesttDimList
name|dims
name|UNUSED
parameter_list|)
block|{
if|#
directive|if
name|FFESTR_F90
switch|switch
condition|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|is_R426
condition|)
block|{
case|case
literal|1
case|:
name|ffestc_R426_attrib
argument_list|(
name|attrib
argument_list|,
name|attribt
argument_list|,
name|intent_kw
argument_list|,
name|dims
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ffestc_R501_attrib
argument_list|(
name|attrib
argument_list|,
name|attribt
argument_list|,
name|intent_kw
argument_list|,
name|dims
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
else|#
directive|else
name|ffebad_start
argument_list|(
name|FFEBAD_F90
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestc_decl_item -- R426 or R501     ffestc_decl_item(...);     Establish type for a particular object.  */
end_comment

begin_function
name|void
name|ffestc_decl_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffebld
name|kind
parameter_list|,
name|ffelexToken
name|kindt
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|,
name|ffebld
name|len
parameter_list|,
name|ffelexToken
name|lent
parameter_list|,
name|ffebld
name|init
parameter_list|,
name|ffelexToken
name|initt
parameter_list|,
name|bool
name|clist
parameter_list|)
block|{
switch|switch
condition|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|is_R426
condition|)
block|{
if|#
directive|if
name|FFESTR_F90
case|case
literal|1
case|:
name|ffestc_R426_item
argument_list|(
name|name
argument_list|,
name|kind
argument_list|,
name|kindt
argument_list|,
name|dims
argument_list|,
name|len
argument_list|,
name|lent
argument_list|,
name|init
argument_list|,
name|initt
argument_list|,
name|clist
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|2
case|:
name|ffestc_R501_item
argument_list|(
name|name
argument_list|,
name|kind
argument_list|,
name|kindt
argument_list|,
name|dims
argument_list|,
name|len
argument_list|,
name|lent
argument_list|,
name|init
argument_list|,
name|initt
argument_list|,
name|clist
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_decl_itemstartvals -- R426 or R501 start list of values     ffestc_decl_itemstartvals();     Gonna specify values for the object now.  */
end_comment

begin_function
name|void
name|ffestc_decl_itemstartvals
parameter_list|()
block|{
switch|switch
condition|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|is_R426
condition|)
block|{
if|#
directive|if
name|FFESTR_F90
case|case
literal|1
case|:
name|ffestc_R426_itemstartvals
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|2
case|:
name|ffestc_R501_itemstartvals
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_decl_itemvalue -- R426 or R501 source value     ffestc_decl_itemvalue(repeat,repeat_token,value,value_token);     Make sure repeat and value are valid for the object being initialized.  */
end_comment

begin_function
name|void
name|ffestc_decl_itemvalue
parameter_list|(
name|ffebld
name|repeat
parameter_list|,
name|ffelexToken
name|repeat_token
parameter_list|,
name|ffebld
name|value
parameter_list|,
name|ffelexToken
name|value_token
parameter_list|)
block|{
switch|switch
condition|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|is_R426
condition|)
block|{
if|#
directive|if
name|FFESTR_F90
case|case
literal|1
case|:
name|ffestc_R426_itemvalue
argument_list|(
name|repeat
argument_list|,
name|repeat_token
argument_list|,
name|value
argument_list|,
name|value_token
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|2
case|:
name|ffestc_R501_itemvalue
argument_list|(
name|repeat
argument_list|,
name|repeat_token
argument_list|,
name|value
argument_list|,
name|value_token
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_decl_itemendvals -- R426 or R501 end list of values     ffelexToken t;  // the SLASH token that ends the list.    ffestc_decl_itemendvals(t);     No more values, might specify more objects now.  */
end_comment

begin_function
name|void
name|ffestc_decl_itemendvals
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|is_R426
condition|)
block|{
if|#
directive|if
name|FFESTR_F90
case|case
literal|1
case|:
name|ffestc_R426_itemendvals
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|2
case|:
name|ffestc_R501_itemendvals
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_decl_finish -- R426 or R501     ffestc_decl_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_decl_finish
parameter_list|()
block|{
switch|switch
condition|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|is_R426
condition|)
block|{
if|#
directive|if
name|FFESTR_F90
case|case
literal|1
case|:
name|ffestc_R426_finish
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|2
case|:
name|ffestc_R501_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_elsewhere -- Generic ELSE WHERE statement     ffestc_end();     Decide whether ELSEWHERE or ELSE w/if-construct-name=="WHERE" is meant.  */
end_comment

begin_function
name|void
name|ffestc_elsewhere
parameter_list|(
name|ffelexToken
name|where
parameter_list|)
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateIFTHEN
case|:
name|ffestc_R805
argument_list|(
name|where
argument_list|)
expr_stmt|;
break|break;
default|default:
if|#
directive|if
name|FFESTR_F90
name|ffestc_R744
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_end -- Generic END statement     ffestc_end();     Make sure a generic END is valid in the current context, and implement    it.	*/
end_comment

begin_function
name|void
name|ffestc_end
parameter_list|()
block|{
name|ffestw
name|b
decl_stmt|;
name|b
operator|=
name|ffestw_stack_top
argument_list|()
expr_stmt|;
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|b
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateBLOCKDATA0
case|:
case|case
name|FFESTV_stateBLOCKDATA1
case|:
case|case
name|FFESTV_stateBLOCKDATA2
case|:
case|case
name|FFESTV_stateBLOCKDATA3
case|:
case|case
name|FFESTV_stateBLOCKDATA4
case|:
case|case
name|FFESTV_stateBLOCKDATA5
case|:
name|ffestc_R1112
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateFUNCTION4
case|:
case|case
name|FFESTV_stateFUNCTION5
case|:
if|if
condition|(
operator|(
name|ffestw_state
argument_list|(
name|ffestw_previous
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|FFESTV_stateNIL
operator|)
operator|&&
operator|(
name|ffestw_state
argument_list|(
name|ffestw_previous
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|FFESTV_stateINTERFACE0
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_END_WO
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_previous
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_previous
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"FUNCTION"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_R1221
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateMODULE0
case|:
case|case
name|FFESTV_stateMODULE1
case|:
case|case
name|FFESTV_stateMODULE2
case|:
case|case
name|FFESTV_stateMODULE3
case|:
case|case
name|FFESTV_stateMODULE4
case|:
case|case
name|FFESTV_stateMODULE5
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_R1106
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateSUBROUTINE4
case|:
case|case
name|FFESTV_stateSUBROUTINE5
case|:
if|if
condition|(
operator|(
name|ffestw_state
argument_list|(
name|ffestw_previous
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|FFESTV_stateNIL
operator|)
operator|&&
operator|(
name|ffestw_state
argument_list|(
name|ffestw_previous
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|FFESTV_stateINTERFACE0
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_END_WO
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_previous
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_previous
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"SUBROUTINE"
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_R1225
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_stateUSE
case|:
name|b
operator|=
name|ffestw_previous
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
default|default:
name|ffestc_R1103
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_eof -- Generic EOF     ffestc_eof();     Make sure we're at state NIL, or issue an error message and use each    block's shriek function to clean up to state NIL.  */
end_comment

begin_function
name|void
name|ffestc_eof
parameter_list|()
block|{
if|if
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|FFESTV_stateNIL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_EOF_BEFORE_BLOCK_END
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
do|do
operator|(
operator|*
name|ffestw_shriek
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|)
operator|(
name|FALSE
operator|)
expr_stmt|;
do|while
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|FFESTV_stateNIL
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_exec_transition -- Check if ok and move stmt state to executable     if (ffestc_exec_transition())        // Transition successful (kind of like a CONTINUE stmt was seen).     If the current statement state is a non-nested specification state in    which, say, a CONTINUE statement would be valid, then enter the state    we'd be in after seeing CONTINUE (without, of course, generating any    CONTINUE code), call ffestd_exec_begin, and return TRUE.  Otherwise    return FALSE.     This function cannot be invoked once the first executable statement    is seen.  This function may choose to always return TRUE by shrieking    away any interceding state stack entries to reach the base level of    specification state, but right now it doesn't, and it is (or should    be) purely an issue of how one wishes errors to be handled (for example,    an unrecognized statement in the middle of a STRUCTURE construct: after    the error message, should subsequent statements still be interpreted as    being within the construct, or should the construct be terminated upon    seeing the unrecognized statement?  we do the former at the moment).  */
end_comment

begin_function
name|bool
name|ffestc_exec_transition
parameter_list|()
block|{
name|bool
name|update
decl_stmt|;
name|recurse
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
name|ffestc_shriek_begin_program_
argument_list|()
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_statePROGRAM0
case|:
case|case
name|FFESTV_stateSUBROUTINE0
case|:
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateBLOCKDATA0
case|:
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|+=
literal|4
expr_stmt|;
comment|/* To state UNIT4. */
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_statePROGRAM1
case|:
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateBLOCKDATA1
case|:
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|+=
literal|3
expr_stmt|;
comment|/* To state UNIT4. */
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_statePROGRAM2
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateBLOCKDATA2
case|:
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|+=
literal|2
expr_stmt|;
comment|/* To state UNIT4. */
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_statePROGRAM3
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateBLOCKDATA3
case|:
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|+=
literal|1
expr_stmt|;
comment|/* To state UNIT4. */
name|update
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateUSE
case|:
if|#
directive|if
name|FFESTR_F90
name|ffestc_shriek_end_uses_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
default|default:
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|update
condition|)
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Update state line/col info. */
name|ffesta_seen_first_exec
operator|=
name|TRUE
expr_stmt|;
name|ffestd_exec_begin
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ffestc_ffebad_here_doiter -- Calls ffebad_here with ptr to DO iter var     ffesymbol s;    // call ffebad_start first, of course.    ffestc_ffebad_here_doiter(0,s);    // call ffebad_finish afterwards, naturally.     Searches the stack of blocks backwards for a DO loop that has s    as its iteration variable, then calls ffebad_here with pointers to    that particular reference to the variable.  Crashes if the DO loop    can't be found.  */
end_comment

begin_function
name|void
name|ffestc_ffebad_here_doiter
parameter_list|(
name|ffebadIndex
name|i
parameter_list|,
name|ffesymbol
name|s
parameter_list|)
block|{
name|ffestw
name|block
decl_stmt|;
for|for
control|(
name|block
operator|=
name|ffestw_top_do
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
init|;
operator|(
name|block
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffestw_blocknum
argument_list|(
name|block
argument_list|)
operator|!=
literal|0
operator|)
condition|;
name|block
operator|=
name|ffestw_top_do
argument_list|(
name|ffestw_previous
argument_list|(
name|block
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
name|ffestw_do_iter_var
argument_list|(
name|block
argument_list|)
operator|==
name|s
condition|)
block|{
name|ffebad_here
argument_list|(
name|i
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestw_do_iter_var_t
argument_list|(
name|block
argument_list|)
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestw_do_iter_var_t
argument_list|(
name|block
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|assert
argument_list|(
literal|"no do block found"
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_is_decl_not_R1219 -- Context information for FFESTB     if (ffestc_is_decl_not_R1219()) ...     When a statement with the form "type[RECURSIVE]FUNCTIONname(name-list)"    is seen, call this function.	 It returns TRUE if the statement's context    is such that it is a declaration of an object named    "[RECURSIVE]FUNCTIONname" with an array-decl spec of "name-list", FALSE    if the statement's context is such that it begins the definition of a    function named "name" havin the dummy argument list "name-list" (this    is the R1219 function-stmt case).  */
end_comment

begin_function
name|bool
name|ffestc_is_decl_not_R1219
parameter_list|()
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateNIL
case|:
case|case
name|FFESTV_statePROGRAM5
case|:
case|case
name|FFESTV_stateSUBROUTINE5
case|:
case|case
name|FFESTV_stateFUNCTION5
case|:
case|case
name|FFESTV_stateMODULE5
case|:
case|case
name|FFESTV_stateINTERFACE0
case|:
return|return
name|FALSE
return|;
default|default:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_is_entry_in_subr -- Context information for FFESTB     if (ffestc_is_entry_in_subr()) ...     When a statement with the form "ENTRY name(name-list)"    is seen, call this function.	 It returns TRUE if the statement's context    is such that it may have "*", meaning alternate return, in place of    names in the name list (i.e. if the ENTRY is in a subroutine context).    It also returns TRUE if the ENTRY is not in a function context (invalid    but prevents extra complaints about "*", if present).  It returns FALSE    if the ENTRY is in a function context.  */
end_comment

begin_function
name|bool
name|ffestc_is_entry_in_subr
parameter_list|()
block|{
name|ffestvState
name|s
decl_stmt|;
name|s
operator|=
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
expr_stmt|;
name|recurse
label|:
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|FFESTV_stateFUNCTION0
case|:
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
case|case
name|FFESTV_stateFUNCTION4
case|:
return|return
name|FALSE
return|;
case|case
name|FFESTV_stateUSE
case|:
name|s
operator|=
name|ffestw_state
argument_list|(
name|ffestw_previous
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|recurse
goto|;
comment|/* :::::::::::::::::::: */
default|default:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_is_let_not_V027 -- Context information for FFESTB     if (ffestc_is_let_not_V027()) ...     When a statement with the form "PARAMETERname=expr"    is seen, call this function.	 It returns TRUE if the statement's context    is such that it is an assignment to an object named "PARAMETERname", FALSE    if the statement's context is such that it is a V-extension PARAMETER    statement that is like a PARAMETER(name=expr) statement except that the    type of name is determined by the type of expr, not the implicit or    explicit typing of name.  */
end_comment

begin_function
name|bool
name|ffestc_is_let_not_V027
parameter_list|()
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_statePROGRAM4
case|:
case|case
name|FFESTV_stateSUBROUTINE4
case|:
case|case
name|FFESTV_stateFUNCTION4
case|:
case|case
name|FFESTV_stateWHERETHEN
case|:
case|case
name|FFESTV_stateIFTHEN
case|:
case|case
name|FFESTV_stateDO
case|:
case|case
name|FFESTV_stateSELECT0
case|:
case|case
name|FFESTV_stateSELECT1
case|:
case|case
name|FFESTV_stateWHERE
case|:
case|case
name|FFESTV_stateIF
case|:
return|return
name|TRUE
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_module -- MODULE or MODULE PROCEDURE statement     ffestc_module(module_name_token,procedure_name_token);     Decide which is intended, and implement it by calling _R1105_ or    _R1205_.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestc_module
parameter_list|(
name|ffelexToken
name|module
parameter_list|,
name|ffelexToken
name|procedure
parameter_list|)
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateINTERFACE0
case|:
case|case
name|FFESTV_stateINTERFACE1
case|:
name|ffestc_R1205_start
argument_list|()
expr_stmt|;
name|ffestc_R1205_item
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
name|ffestc_R1205_finish
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ffestc_R1105
argument_list|(
name|module
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_private -- Generic PRIVATE statement     ffestc_end();     This is either a PRIVATE within R422 derived-type statement or an    R521 PRIVATE statement.  Figure it out based on context and implement    it, or produce an error.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestc_private
parameter_list|()
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateTYPE
case|:
name|ffestc_R423A
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ffestc_R521B
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_terminate_4 -- Terminate ffestc after scoping unit     ffestc_terminate_4();     For SUBROUTINEs/FUNCTIONs within INTERFACE/END INTERFACE, derived-TYPE-    defs, and statement function defs.  */
end_comment

begin_function
name|void
name|ffestc_terminate_4
parameter_list|()
block|{
name|ffestc_entry_num_
operator|=
name|ffestc_saved_entry_num_
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R423A -- PRIVATE statement (in R422 derived-type statement)     ffestc_R423A();  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestc_R423A
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_type_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestw_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DERIVTYP_ACCESS_FIRST
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ffestw_state
argument_list|(
name|ffestw_previous
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
operator|!=
name|FFESTV_stateMODULE3
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DERIVTYP_ACCESS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return;
block|}
name|ffestw_set_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Seen 						   private-sequence-stmt. */
name|ffestd_R423A
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R423B -- SEQUENCE statement (in R422 derived-type-stmt)     ffestc_R423B();  */
end_comment

begin_function
name|void
name|ffestc_R423B
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_type_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestw_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DERIVTYP_ACCESS_FIRST
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return;
block|}
name|ffestw_set_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Seen 						   private-sequence-stmt. */
name|ffestd_R423B
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R424 -- derived-TYPE-def statement     ffestc_R424(access_token,access_kw,name_token);     Handle a derived-type definition.  */
end_comment

begin_function
name|void
name|ffestc_R424
parameter_list|(
name|ffelexToken
name|access
parameter_list|,
name|ffestrOther
name|access_kw
parameter_list|,
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_derivedtype_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|access
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|FFESTV_stateMODULE3
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DERIVTYP_ACCESS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|access
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|access
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|access
operator|=
name|NULL
expr_stmt|;
block|}
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateTYPE
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_type_
argument_list|)
expr_stmt|;
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|ffelex_token_use
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_substate
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Awaiting private-sequence-stmt and one 				   component-def-stmt. */
name|ffestd_R424
argument_list|(
name|access
argument_list|,
name|access_kw
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ffe_init_4
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R425 -- END TYPE statement     ffestc_R425(name_token);     Make sure ffestc_kind_ identifies a TYPE definition.	 If not    NULL, make sure name_token gives the correct name.  Implement the end    of the type definition.  */
end_comment

begin_function
name|void
name|ffestc_R425
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_type_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestw_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DERIVTYP_NO_COMPONENTS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|name
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffelex_token_strcmp
argument_list|(
name|name
argument_list|,
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_TYPE_WRONG_NAME
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_shriek_type_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R426_start -- component-declaration-stmt     ffestc_R426_start(...);     Verify that R426 component-declaration-stmt is    valid here and implement.  */
end_comment

begin_function
name|void
name|ffestc_R426_start
parameter_list|(
name|ffestpType
name|type
parameter_list|,
name|ffelexToken
name|typet
parameter_list|,
name|ffebld
name|kind
parameter_list|,
name|ffelexToken
name|kindt
parameter_list|,
name|ffebld
name|len
parameter_list|,
name|ffelexToken
name|lent
parameter_list|)
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_component_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_local_
operator|.
name|decl
operator|.
name|is_R426
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateSTRUCTURE
case|:
case|case
name|FFESTV_stateMAP
case|:
name|ffestw_set_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Seen at least one 							   member. */
break|break;
case|case
name|FFESTV_stateTYPE
case|:
name|ffestw_set_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Component parent state invalid"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_R426_attrib -- type attribute     ffestc_R426_attrib(...);     Verify that R426 component-declaration-stmt attribute    is valid here and implement.	 */
end_comment

begin_function
name|void
name|ffestc_R426_attrib
parameter_list|(
name|ffestpAttrib
name|attrib
parameter_list|,
name|ffelexToken
name|attribt
parameter_list|,
name|ffestrOther
name|intent_kw
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|)
block|{
name|ffestc_check_attrib_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R426_item -- declared object     ffestc_R426_item(...);     Establish type for a particular object.  */
end_comment

begin_function
name|void
name|ffestc_R426_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffebld
name|kind
parameter_list|,
name|ffelexToken
name|kindt
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|,
name|ffebld
name|len
parameter_list|,
name|ffelexToken
name|lent
parameter_list|,
name|ffebld
name|init
parameter_list|,
name|ffelexToken
name|initt
parameter_list|,
name|bool
name|clist
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|name
argument_list|)
operator|==
name|FFELEX_typeNAME
argument_list|)
expr_stmt|;
comment|/* Not NAMES. */
name|assert
argument_list|(
name|kind
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* No way an expression should get here. */
if|if
condition|(
operator|(
name|dims
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|init
operator|!=
name|NULL
operator|)
operator|||
name|clist
condition|)
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R426_itemstartvals -- Start list of values     ffestc_R426_itemstartvals();     Gonna specify values for the object now.  */
end_comment

begin_function
name|void
name|ffestc_R426_itemstartvals
parameter_list|()
block|{
name|ffestc_check_item_startvals_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R426_itemvalue -- Source value     ffestc_R426_itemvalue(repeat,repeat_token,value,value_token);     Make sure repeat and value are valid for the object being initialized.  */
end_comment

begin_function
name|void
name|ffestc_R426_itemvalue
parameter_list|(
name|ffebld
name|repeat
parameter_list|,
name|ffelexToken
name|repeat_token
parameter_list|,
name|ffebld
name|value
parameter_list|,
name|ffelexToken
name|value_token
parameter_list|)
block|{
name|ffestc_check_item_value_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R426_itemendvals -- End list of values     ffelexToken t;  // the SLASH token that ends the list.    ffestc_R426_itemendvals(t);     No more values, might specify more objects now.  */
end_comment

begin_function
name|void
name|ffestc_R426_itemendvals
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestc_check_item_endvals_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R426_finish -- Done     ffestc_R426_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R426_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_R501_start -- type-declaration-stmt     ffestc_R501_start(...);     Verify that R501 type-declaration-stmt is    valid here and implement.  */
end_comment

begin_function
name|void
name|ffestc_R501_start
parameter_list|(
name|ffestpType
name|type
parameter_list|,
name|ffelexToken
name|typet
parameter_list|,
name|ffebld
name|kind
parameter_list|,
name|ffelexToken
name|kindt
parameter_list|,
name|ffebld
name|len
parameter_list|,
name|ffelexToken
name|lent
parameter_list|)
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_typedecl_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_local_
operator|.
name|decl
operator|.
name|is_R426
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestc_establish_declstmt_
argument_list|(
name|type
argument_list|,
name|typet
argument_list|,
name|kind
argument_list|,
name|kindt
argument_list|,
name|len
argument_list|,
name|lent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R501_attrib -- type attribute     ffestc_R501_attrib(...);     Verify that R501 type-declaration-stmt attribute    is valid here and implement.	 */
end_comment

begin_function
name|void
name|ffestc_R501_attrib
parameter_list|(
name|ffestpAttrib
name|attrib
parameter_list|,
name|ffelexToken
name|attribt
parameter_list|,
name|ffestrOther
name|intent_kw
name|UNUSED
parameter_list|,
name|ffesttDimList
name|dims
name|UNUSED
parameter_list|)
block|{
name|ffestc_check_attrib_
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|attrib
condition|)
block|{
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTP_attribALLOCATABLE
case|:
break|break;
endif|#
directive|endif
case|case
name|FFESTP_attribDIMENSION
case|:
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTP_attribEXTERNAL
case|:
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTP_attribINTENT
case|:
break|break;
endif|#
directive|endif
case|case
name|FFESTP_attribINTRINSIC
case|:
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTP_attribOPTIONAL
case|:
break|break;
endif|#
directive|endif
case|case
name|FFESTP_attribPARAMETER
case|:
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTP_attribPOINTER
case|:
break|break;
endif|#
directive|endif
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTP_attribPRIVATE
case|:
break|break;
case|case
name|FFESTP_attribPUBLIC
case|:
break|break;
endif|#
directive|endif
case|case
name|FFESTP_attribSAVE
case|:
switch|switch
condition|(
name|ffestv_save_state_
condition|)
block|{
case|case
name|FFESTV_savestateNONE
case|:
name|ffestv_save_state_
operator|=
name|FFESTV_savestateSPECIFIC
expr_stmt|;
name|ffestv_save_line_
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|attribt
argument_list|)
argument_list|)
expr_stmt|;
name|ffestv_save_col_
operator|=
name|ffewhere_column_use
argument_list|(
name|ffelex_token_where_column
argument_list|(
name|attribt
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_savestateSPECIFIC
case|:
case|case
name|FFESTV_savestateANY
case|:
break|break;
case|case
name|FFESTV_savestateALL
case|:
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONFLICTING_SAVES
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffestv_save_line_
argument_list|,
name|ffestv_save_col_
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|attribt
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|attribt
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestv_save_state_
operator|=
name|FFESTV_savestateANY
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"unexpected save state"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTP_attribTARGET
case|:
break|break;
endif|#
directive|endif
default|default:
name|assert
argument_list|(
literal|"unexpected attribute"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_R501_item -- declared object     ffestc_R501_item(...);     Establish type for a particular object.  */
end_comment

begin_function
name|void
name|ffestc_R501_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffebld
name|kind
parameter_list|,
name|ffelexToken
name|kindt
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|,
name|ffebld
name|len
parameter_list|,
name|ffelexToken
name|lent
parameter_list|,
name|ffebld
name|init
parameter_list|,
name|ffelexToken
name|initt
parameter_list|,
name|bool
name|clist
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbol
name|sfn
decl_stmt|;
comment|/* FUNCTION symbol. */
name|ffebld
name|array_size
decl_stmt|;
name|ffebld
name|extents
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffestpDimtype
name|nd
decl_stmt|;
name|bool
name|is_init
init|=
operator|(
name|init
operator|!=
name|NULL
operator|)
operator|||
name|clist
decl_stmt|;
name|bool
name|is_assumed
decl_stmt|;
name|bool
name|is_ugly_assumed
decl_stmt|;
name|ffeinfoRank
name|rank
decl_stmt|;
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffelex_token_type
argument_list|(
name|name
argument_list|)
operator|==
name|FFELEX_typeNAME
argument_list|)
expr_stmt|;
comment|/* Not NAMES. */
name|assert
argument_list|(
name|kind
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* No way an expression should get here. */
name|ffestc_establish_declinfo_
argument_list|(
name|kind
argument_list|,
name|kindt
argument_list|,
name|len
argument_list|,
name|lent
argument_list|)
expr_stmt|;
name|is_assumed
operator|=
operator|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
operator|&&
operator|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|size
operator|==
name|FFETARGET_charactersizeNONE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|dims
operator|!=
name|NULL
operator|)
operator|||
name|is_init
condition|)
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|name
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* First figure out what kind of object this is based solely on the current      object situation (type params, dimension list, and initialization). */
name|na
operator|=
name|FFESYMBOL_attrsTYPE
expr_stmt|;
if|if
condition|(
name|is_assumed
condition|)
name|na
operator||=
name|FFESYMBOL_attrsANYLEN
expr_stmt|;
name|is_ugly_assumed
operator|=
operator|(
name|ffe_is_ugly_assumed
argument_list|()
operator|&&
operator|(
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
operator|)
operator|||
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereDUMMY
operator|)
operator|)
operator|)
expr_stmt|;
name|nd
operator|=
name|ffestt_dimlist_type
argument_list|(
name|dims
argument_list|,
name|is_ugly_assumed
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nd
condition|)
block|{
case|case
name|FFESTP_dimtypeNONE
case|:
break|break;
case|case
name|FFESTP_dimtypeKNOWN
case|:
name|na
operator||=
name|FFESYMBOL_attrsARRAY
expr_stmt|;
break|break;
case|case
name|FFESTP_dimtypeADJUSTABLE
case|:
name|na
operator||=
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsADJUSTABLE
expr_stmt|;
break|break;
case|case
name|FFESTP_dimtypeASSUMED
case|:
name|na
operator||=
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsANYSIZE
expr_stmt|;
break|break;
case|case
name|FFESTP_dimtypeADJUSTABLEASSUMED
case|:
name|na
operator||=
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYSIZE
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"unexpected dimtype"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ffesta_is_entry_valid
operator|&&
operator|(
operator|(
operator|(
name|na
operator|&
operator|(
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator|)
operator|)
operator|==
operator|(
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsARRAY
operator|)
operator|)
operator|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
if|if
condition|(
name|is_init
condition|)
block|{
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|na
operator|&
operator|(
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYSIZE
operator|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
else|else
name|na
operator||=
name|FFESYMBOL_attrsINIT
expr_stmt|;
block|}
comment|/* Now figure out what kind of object we've got based on previous      declarations of or references to the object. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ffesymbol_is_specable
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereCONSTANT
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereINTRINSIC
operator|)
operator|)
operator|||
operator|(
name|na
operator|&
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsINIT
operator|)
operator|)
operator|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Can't dcl sym ref'd in sfuncdef, and can't 				   dimension/init UNDERSTOODs. */
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|na
operator|=
name|sa
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sa
operator|&
name|na
operator|)
operator|||
operator|(
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsADJUSTS
operator|)
operator|)
operator|&&
operator|(
name|na
operator|&
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsANYLEN
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsRESULT
operator|)
operator|&&
operator|(
name|na
operator|&
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsINIT
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsSFUNC
operator||
name|FFESYMBOL_attrsEXTERNAL
operator||
name|FFESYMBOL_attrsINTRINSIC
operator||
name|FFESYMBOL_attrsINIT
operator|)
operator|)
operator|&&
operator|(
name|na
operator|&
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsINIT
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsARRAY
operator|)
operator|&&
operator|!
name|ffesta_is_entry_valid
operator|&&
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANYLEN
operator|)
operator|)
operator|||
operator|(
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsANYSIZE
operator||
name|FFESYMBOL_attrsDUMMY
operator|)
operator|)
operator|&&
operator|(
name|na
operator|&
name|FFESYMBOL_attrsINIT
operator|)
operator|)
operator|||
operator|(
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsSAVE
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsEQUIV
operator|)
operator|)
operator|&&
operator|(
name|na
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsANYSIZE
operator|)
operator|)
operator|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_kindENTITY
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereCONSTANT
operator|)
operator|&&
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANYLEN
operator|)
condition|)
block|{
comment|/* If CHARACTER*(*) FOO after PARAMETER FOO. */
name|na
operator||=
name|FFESYMBOL_attrsTYPE
expr_stmt|;
name|ffestc_local_
operator|.
name|decl
operator|.
name|size
operator|=
name|ffebld_size
argument_list|(
name|ffesymbol_init
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|na
operator||=
name|sa
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ffestc_parent_ok_
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|na
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|ffestc_parent_ok_
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
name|rank
operator|=
name|ffesymbol_rank
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dims
operator|!=
name|NULL
condition|)
block|{
name|ffesymbol_set_dims
argument_list|(
name|s
argument_list|,
name|ffestt_dimlist_as_expr
argument_list|(
name|dims
argument_list|,
operator|&
name|rank
argument_list|,
operator|&
name|array_size
argument_list|,
operator|&
name|extents
argument_list|,
name|is_ugly_assumed
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_arraysize
argument_list|(
name|s
argument_list|,
name|array_size
argument_list|)
expr_stmt|;
name|ffesymbol_set_extents
argument_list|(
name|s
argument_list|,
name|extents
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|0
operator|&&
name|ffe_is_90
argument_list|()
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|array_size
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|&&
operator|(
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|array_size
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_ZERO_ARRAY
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|init
operator|!=
name|NULL
condition|)
block|{
name|ffesymbol_set_init
argument_list|(
name|s
argument_list|,
name|ffeexpr_convert
argument_list|(
name|init
argument_list|,
name|initt
argument_list|,
name|name
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|kind_type
argument_list|,
name|rank
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|size
argument_list|,
name|FFEEXPR_contextDATA
argument_list|)
argument_list|)
expr_stmt|;
name|ffecom_notify_init_symbol
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_update_init
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|FFEGLOBAL_ENABLED
if|if
condition|(
name|ffesymbol_common
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
condition|)
name|ffeglobal_init_common
argument_list|(
name|ffesymbol_common
argument_list|(
name|s
argument_list|)
argument_list|,
name|initt
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|clist
condition|)
block|{
name|ffebld
name|symter
decl_stmt|;
name|symter
operator|=
name|ffebld_new_symter
argument_list|(
name|s
argument_list|,
name|FFEINTRIN_genNONE
argument_list|,
name|FFEINTRIN_specNONE
argument_list|,
name|FFEINTRIN_impNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|symter
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|kind_type
argument_list|,
name|rank
argument_list|,
name|FFEINFO_kindNONE
argument_list|,
name|FFEINFO_whereNONE
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|ffestc_local_
operator|.
name|decl
operator|.
name|initlist
operator|=
name|ffebld_new_item
argument_list|(
name|symter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_basictypeNONE
condition|)
block|{
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|kind_type
argument_list|,
name|rank
argument_list|,
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|na
operator|&
name|FFESYMBOL_attrsRESULT
operator|)
operator|&&
operator|(
operator|(
name|sfn
operator|=
name|ffesymbol_funcresult
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ffesymbol_set_info
argument_list|(
name|sfn
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|kind_type
argument_list|,
name|rank
argument_list|,
name|ffesymbol_kind
argument_list|(
name|sfn
argument_list|)
argument_list|,
name|ffesymbol_where
argument_list|(
name|sfn
argument_list|)
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|sfn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
operator|!=
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|)
operator|||
operator|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|kind_type
operator|!=
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
operator|&&
operator|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|size
operator|!=
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Explicit type disagrees with established 				   implicit type. */
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|na
operator|&
name|FFESYMBOL_attrsADJUSTS
operator|)
operator|&&
operator|(
operator|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
operator|!=
name|FFEINFO_basictypeINTEGER
operator|)
operator|||
operator|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|kind_type
operator|!=
name|FFEINFO_kindtypeINTEGER1
operator|)
operator|)
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffestc_parent_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ffestc_R501_itemstartvals -- Start list of values     ffestc_R501_itemstartvals();     Gonna specify values for the object now.  */
end_comment

begin_function
name|void
name|ffestc_R501_itemstartvals
parameter_list|()
block|{
name|ffestc_check_item_startvals_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_parent_ok_
condition|)
name|ffedata_begin
argument_list|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|initlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R501_itemvalue -- Source value     ffestc_R501_itemvalue(repeat,repeat_token,value,value_token);     Make sure repeat and value are valid for the object being initialized.  */
end_comment

begin_function
name|void
name|ffestc_R501_itemvalue
parameter_list|(
name|ffebld
name|repeat
parameter_list|,
name|ffelexToken
name|repeat_token
parameter_list|,
name|ffebld
name|value
parameter_list|,
name|ffelexToken
name|value_token
parameter_list|)
block|{
name|ffetargetIntegerDefault
name|rpt
decl_stmt|;
name|ffestc_check_item_value_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_parent_ok_
condition|)
return|return;
if|if
condition|(
name|repeat
operator|==
name|NULL
condition|)
name|rpt
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|repeat
argument_list|)
operator|==
name|FFEBLD_opCONTER
condition|)
name|rpt
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|repeat
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|ffestc_parent_ok_
operator|=
name|FALSE
expr_stmt|;
name|ffedata_end
argument_list|(
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|ffestc_parent_ok_
operator|=
name|ffedata_value
argument_list|(
name|rpt
argument_list|,
name|value
argument_list|,
operator|(
name|repeat_token
operator|==
name|NULL
operator|)
condition|?
name|value_token
else|:
name|repeat_token
argument_list|)
operator|)
condition|)
name|ffedata_end
argument_list|(
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R501_itemendvals -- End list of values     ffelexToken t;  // the SLASH token that ends the list.    ffestc_R501_itemendvals(t);     No more values, might specify more objects now.  */
end_comment

begin_function
name|void
name|ffestc_R501_itemendvals
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestc_check_item_endvals_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_parent_ok_
condition|)
name|ffestc_parent_ok_
operator|=
name|ffedata_end
argument_list|(
name|FALSE
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_parent_ok_
condition|)
name|ffesymbol_signal_unreported
argument_list|(
name|ffebld_symter
argument_list|(
name|ffebld_head
argument_list|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|initlist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R501_finish -- Done     ffestc_R501_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R501_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R519_start -- INTENT statement list begin     ffestc_R519_start();     Verify that INTENT is valid here, and begin accepting items in the list.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestc_R519_start
parameter_list|(
name|ffelexToken
name|intent
parameter_list|,
name|ffestrOther
name|intent_kw
parameter_list|)
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_spec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_R519_start
argument_list|(
name|intent_kw
argument_list|)
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R519_item -- INTENT statement for name     ffestc_R519_item(name_token);     Make sure name_token identifies a valid object to be INTENTed.  */
end_comment

begin_function
name|void
name|ffestc_R519_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R519_item
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R519_finish -- INTENT statement list complete     ffestc_R519_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R519_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R519_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R520_start -- OPTIONAL statement list begin     ffestc_R520_start();     Verify that OPTIONAL is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestc_R520_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_spec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_R520_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R520_item -- OPTIONAL statement for name     ffestc_R520_item(name_token);     Make sure name_token identifies a valid object to be OPTIONALed.  */
end_comment

begin_function
name|void
name|ffestc_R520_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R520_item
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R520_finish -- OPTIONAL statement list complete     ffestc_R520_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R520_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R520_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R521A -- PUBLIC statement     ffestc_R521A();     Verify that PUBLIC is valid here.  */
end_comment

begin_function
name|void
name|ffestc_R521A
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_access_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffestv_access_state_
condition|)
block|{
case|case
name|FFESTV_accessstateNONE
case|:
name|ffestv_access_state_
operator|=
name|FFESTV_accessstatePUBLIC
expr_stmt|;
name|ffestv_access_line_
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffestv_access_col_
operator|=
name|ffewhere_column_use
argument_list|(
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_accessstateANY
case|:
break|break;
case|case
name|FFESTV_accessstatePUBLIC
case|:
case|case
name|FFESTV_accessstatePRIVATE
case|:
name|ffebad_start
argument_list|(
name|FFEBAD_CONFLICTING_ACCESSES
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffestv_access_line_
argument_list|,
name|ffestv_access_col_
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestv_access_state_
operator|=
name|FFESTV_accessstateANY
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"unexpected access state"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|ffestd_R521A
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R521Astart -- PUBLIC statement list begin     ffestc_R521Astart();     Verify that PUBLIC is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestc_R521Astart
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_access_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_R521Astart
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R521Aitem -- PUBLIC statement for name     ffestc_R521Aitem(name_token);     Make sure name_token identifies a valid object to be PUBLICed.  */
end_comment

begin_function
name|void
name|ffestc_R521Aitem
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R521Aitem
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R521Afinish -- PUBLIC statement list complete     ffestc_R521Afinish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R521Afinish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R521Afinish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R521B -- PRIVATE statement     ffestc_R521B();     Verify that PRIVATE is valid here (outside a derived-type statement).  */
end_comment

begin_function
name|void
name|ffestc_R521B
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_access_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffestv_access_state_
condition|)
block|{
case|case
name|FFESTV_accessstateNONE
case|:
name|ffestv_access_state_
operator|=
name|FFESTV_accessstatePRIVATE
expr_stmt|;
name|ffestv_access_line_
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffestv_access_col_
operator|=
name|ffewhere_column_use
argument_list|(
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_accessstateANY
case|:
break|break;
case|case
name|FFESTV_accessstatePUBLIC
case|:
case|case
name|FFESTV_accessstatePRIVATE
case|:
name|ffebad_start
argument_list|(
name|FFEBAD_CONFLICTING_ACCESSES
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffestv_access_line_
argument_list|,
name|ffestv_access_col_
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestv_access_state_
operator|=
name|FFESTV_accessstateANY
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"unexpected access state"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|ffestd_R521B
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R521Bstart -- PRIVATE statement list begin     ffestc_R521Bstart();     Verify that PRIVATE is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestc_R521Bstart
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_access_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_R521Bstart
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R521Bitem -- PRIVATE statement for name     ffestc_R521Bitem(name_token);     Make sure name_token identifies a valid object to be PRIVATEed.  */
end_comment

begin_function
name|void
name|ffestc_R521Bitem
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R521Bitem
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R521Bfinish -- PRIVATE statement list complete     ffestc_R521Bfinish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R521Bfinish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R521Bfinish
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_R522 -- SAVE statement with no list     ffestc_R522();     Verify that SAVE is valid here, and flag everything as SAVEd.  */
end_comment

begin_function
name|void
name|ffestc_R522
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_blockspec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffestv_save_state_
condition|)
block|{
case|case
name|FFESTV_savestateNONE
case|:
name|ffestv_save_state_
operator|=
name|FFESTV_savestateALL
expr_stmt|;
name|ffestv_save_line_
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffestv_save_col_
operator|=
name|ffewhere_column_use
argument_list|(
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_savestateANY
case|:
break|break;
case|case
name|FFESTV_savestateSPECIFIC
case|:
case|case
name|FFESTV_savestateALL
case|:
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONFLICTING_SAVES
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffestv_save_line_
argument_list|,
name|ffestv_save_col_
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestv_save_state_
operator|=
name|FFESTV_savestateALL
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"unexpected save state"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|ffe_set_is_saveall
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestd_R522
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R522start -- SAVE statement list begin     ffestc_R522start();     Verify that SAVE is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestc_R522start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_blockspec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffestv_save_state_
condition|)
block|{
case|case
name|FFESTV_savestateNONE
case|:
name|ffestv_save_state_
operator|=
name|FFESTV_savestateSPECIFIC
expr_stmt|;
name|ffestv_save_line_
operator|=
name|ffewhere_line_use
argument_list|(
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffestv_save_col_
operator|=
name|ffewhere_column_use
argument_list|(
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFESTV_savestateSPECIFIC
case|:
case|case
name|FFESTV_savestateANY
case|:
break|break;
case|case
name|FFESTV_savestateALL
case|:
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONFLICTING_SAVES
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffestv_save_line_
argument_list|,
name|ffestv_save_col_
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestv_save_state_
operator|=
name|FFESTV_savestateANY
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"unexpected save state"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|ffestd_R522start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R522item_object -- SAVE statement for object-name     ffestc_R522item_object(name_token);     Make sure name_token identifies a valid object to be SAVEd.	*/
end_comment

begin_function
name|void
name|ffestc_R522item_object
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
operator|!
name|ffesymbol_is_specable
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
operator|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereLOCAL
operator|)
operator|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Can't dcl sym ref'd in sfuncdef. */
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|na
operator|=
name|sa
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
condition|)
name|na
operator|=
name|sa
operator||
name|FFESYMBOL_attrsSAVE
expr_stmt|;
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
name|ffesymbol_update_save
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|ffestd_R522item_object
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R522item_cblock -- SAVE statement for common-block-name     ffestc_R522item_cblock(name_token);     Make sure name_token identifies a valid common block to be SAVEd.  */
end_comment

begin_function
name|void
name|ffestc_R522item_cblock
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|s
operator|=
name|ffesymbol_declare_cblock
argument_list|(
name|name
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
operator|!
name|ffesymbol_is_specable
argument_list|(
name|s
argument_list|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|na
operator|=
name|sa
expr_stmt|;
comment|/* Already have an error here, say nothing. */
elseif|else
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsCBLOCK
operator|)
operator|)
condition|)
name|na
operator|=
name|sa
operator||
name|FFESYMBOL_attrsSAVECBLOCK
expr_stmt|;
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
name|ffesta_tokens
index|[
literal|0
index|]
else|:
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
name|ffesymbol_update_save
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|ffestd_R522item_cblock
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R522finish -- SAVE statement list complete     ffestc_R522finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R522finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R522finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R524_start -- DIMENSION statement list begin     ffestc_R524_start(bool virtual);     Verify that DIMENSION is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_R524_start
parameter_list|(
name|bool
name|virtual
parameter_list|)
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_blockspec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_R524_start
argument_list|(
name|virtual
argument_list|)
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R524_item -- DIMENSION statement for object-name     ffestc_R524_item(name_token,dim_list);     Make sure name_token identifies a valid object to be DIMENSIONd.  */
end_comment

begin_function
name|void
name|ffestc_R524_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffebld
name|array_size
decl_stmt|;
name|ffebld
name|extents
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffestpDimtype
name|nd
decl_stmt|;
name|ffeinfoRank
name|rank
decl_stmt|;
name|bool
name|is_ugly_assumed
decl_stmt|;
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dims
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* First figure out what kind of object this is based solely on the current      object situation (dimension list). */
name|is_ugly_assumed
operator|=
operator|(
name|ffe_is_ugly_assumed
argument_list|()
operator|&&
operator|(
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
operator|)
operator|||
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereDUMMY
operator|)
operator|)
operator|)
expr_stmt|;
name|nd
operator|=
name|ffestt_dimlist_type
argument_list|(
name|dims
argument_list|,
name|is_ugly_assumed
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nd
condition|)
block|{
case|case
name|FFESTP_dimtypeKNOWN
case|:
name|na
operator|=
name|FFESYMBOL_attrsARRAY
expr_stmt|;
break|break;
case|case
name|FFESTP_dimtypeADJUSTABLE
case|:
name|na
operator|=
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsADJUSTABLE
expr_stmt|;
break|break;
case|case
name|FFESTP_dimtypeASSUMED
case|:
name|na
operator|=
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsANYSIZE
expr_stmt|;
break|break;
case|case
name|FFESTP_dimtypeADJUSTABLEASSUMED
case|:
name|na
operator|=
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYSIZE
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"Unexpected dims type"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
break|break;
block|}
comment|/* Now figure out what kind of object we've got based on previous      declarations of or references to the object. */
if|if
condition|(
operator|!
name|ffesymbol_is_specable
argument_list|(
name|s
argument_list|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Can't dcl sym ref'd in sfuncdef. */
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|na
operator|=
name|FFESYMBOL_attrsANY
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ffesta_is_entry_valid
operator|&&
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsANYLEN
operator|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsARRAY
operator|)
operator|||
operator|(
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsSAVE
operator|)
operator|)
operator|&&
operator|(
name|na
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYSIZE
operator|)
operator|)
operator|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTABLE
operator||
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsANYSIZE
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsSAVE
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
condition|)
name|na
operator||=
name|sa
expr_stmt|;
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
name|ffesymbol_set_dims
argument_list|(
name|s
argument_list|,
name|ffestt_dimlist_as_expr
argument_list|(
name|dims
argument_list|,
operator|&
name|rank
argument_list|,
operator|&
name|array_size
argument_list|,
operator|&
name|extents
argument_list|,
name|is_ugly_assumed
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_arraysize
argument_list|(
name|s
argument_list|,
name|array_size
argument_list|)
expr_stmt|;
name|ffesymbol_set_extents
argument_list|(
name|s
argument_list|,
name|extents
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|0
operator|&&
name|ffe_is_90
argument_list|()
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|array_size
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|&&
operator|(
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|array_size
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_ZERO_ARRAY
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|rank
argument_list|,
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffestd_R524_item
argument_list|(
name|name
argument_list|,
name|dims
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R524_finish -- DIMENSION statement list complete     ffestc_R524_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R524_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R524_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R525_start -- ALLOCATABLE statement list begin     ffestc_R525_start();     Verify that ALLOCATABLE is valid here, and begin accepting items in the    list.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestc_R525_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_progspec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_R525_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R525_item -- ALLOCATABLE statement for object-name     ffestc_R525_item(name_token,dim_list);     Make sure name_token identifies a valid object to be ALLOCATABLEd.  */
end_comment

begin_function
name|void
name|ffestc_R525_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
name|ffestd_R525_item
argument_list|(
name|name
argument_list|,
name|dims
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R525_finish -- ALLOCATABLE statement list complete     ffestc_R525_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R525_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R525_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R526_start -- POINTER statement list begin     ffestc_R526_start();     Verify that POINTER is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_R526_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_progspec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_R526_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R526_item -- POINTER statement for object-name     ffestc_R526_item(name_token,dim_list);     Make sure name_token identifies a valid object to be POINTERd.  */
end_comment

begin_function
name|void
name|ffestc_R526_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
name|ffestd_R526_item
argument_list|(
name|name
argument_list|,
name|dims
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R526_finish -- POINTER statement list complete     ffestc_R526_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R526_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R526_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R527_start -- TARGET statement list begin     ffestc_R527_start();     Verify that TARGET is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_R527_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_progspec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_R527_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R527_item -- TARGET statement for object-name     ffestc_R527_item(name_token,dim_list);     Make sure name_token identifies a valid object to be TARGETd.  */
end_comment

begin_function
name|void
name|ffestc_R527_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
name|ffestd_R527_item
argument_list|(
name|name
argument_list|,
name|dims
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R527_finish -- TARGET statement list complete     ffestc_R527_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R527_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R527_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_R528_start -- DATA statement list begin     ffestc_R528_start();     Verify that DATA is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestc_R528_start
parameter_list|()
block|{
name|ffestcOrder_
name|order
decl_stmt|;
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffe_is_pedantic_not_90
argument_list|()
condition|)
name|order
operator|=
name|ffestc_order_data77_
argument_list|()
expr_stmt|;
else|else
name|order
operator|=
name|ffestc_order_data_
argument_list|()
expr_stmt|;
if|if
condition|(
name|order
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|ffestc_local_
operator|.
name|data
operator|.
name|objlist
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|ffestd_R528_start_
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R528_item_object -- DATA statement target object     ffestc_R528_item_object(object,object_token);     Make sure object is valid to be DATAd.  */
end_comment

begin_function
name|void
name|ffestc_R528_item_object
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
name|UNUSED
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|#
directive|if
literal|1
if|if
condition|(
name|ffestc_local_
operator|.
name|data
operator|.
name|objlist
operator|==
name|NULL
condition|)
name|ffebld_init_list
argument_list|(
operator|&
name|ffestc_local_
operator|.
name|data
operator|.
name|objlist
argument_list|,
operator|&
name|ffestc_local_
operator|.
name|data
operator|.
name|list_bottom
argument_list|)
expr_stmt|;
name|ffebld_append_item
argument_list|(
operator|&
name|ffestc_local_
operator|.
name|data
operator|.
name|list_bottom
argument_list|,
name|expr
argument_list|)
expr_stmt|;
else|#
directive|else
name|ffestd_R528_item_object_
argument_list|(
name|expr
argument_list|,
name|expr_token
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestc_R528_item_startvals -- DATA statement start list of values     ffestc_R528_item_startvals();     No more objects, gonna specify values for the list of objects now.  */
end_comment

begin_function
name|void
name|ffestc_R528_item_startvals
parameter_list|()
block|{
name|ffestc_check_item_startvals_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|#
directive|if
literal|1
name|assert
argument_list|(
name|ffestc_local_
operator|.
name|data
operator|.
name|objlist
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffebld_end_list
argument_list|(
operator|&
name|ffestc_local_
operator|.
name|data
operator|.
name|list_bottom
argument_list|)
expr_stmt|;
name|ffedata_begin
argument_list|(
name|ffestc_local_
operator|.
name|data
operator|.
name|objlist
argument_list|)
expr_stmt|;
else|#
directive|else
name|ffestd_R528_item_startvals_
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestc_R528_item_value -- DATA statement source value     ffestc_R528_item_value(repeat,repeat_token,value,value_token);     Make sure repeat and value are valid for the objects being initialized.  */
end_comment

begin_function
name|void
name|ffestc_R528_item_value
parameter_list|(
name|ffebld
name|repeat
parameter_list|,
name|ffelexToken
name|repeat_token
parameter_list|,
name|ffebld
name|value
parameter_list|,
name|ffelexToken
name|value_token
parameter_list|)
block|{
name|ffetargetIntegerDefault
name|rpt
decl_stmt|;
name|ffestc_check_item_value_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|#
directive|if
literal|1
if|if
condition|(
name|repeat
operator|==
name|NULL
condition|)
name|rpt
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|repeat
argument_list|)
operator|==
name|FFEBLD_opCONTER
condition|)
name|rpt
operator|=
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|repeat
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
name|ffedata_end
argument_list|(
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|ffestc_ok_
operator|=
name|ffedata_value
argument_list|(
name|rpt
argument_list|,
name|value
argument_list|,
operator|(
name|repeat_token
operator|==
name|NULL
operator|)
condition|?
name|value_token
else|:
name|repeat_token
argument_list|)
operator|)
condition|)
name|ffedata_end
argument_list|(
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|ffestd_R528_item_value_
argument_list|(
name|repeat
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestc_R528_item_endvals -- DATA statement start list of values     ffelexToken t;  // the SLASH token that ends the list.    ffestc_R528_item_endvals(t);     No more values, might specify more objects now.  */
end_comment

begin_function
name|void
name|ffestc_R528_item_endvals
parameter_list|(
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffestc_check_item_endvals_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|#
directive|if
literal|1
name|ffedata_end
argument_list|(
operator|!
name|ffestc_ok_
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ffestc_local_
operator|.
name|data
operator|.
name|objlist
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|ffestd_R528_item_endvals_
argument_list|(
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestc_R528_finish -- DATA statement list complete     ffestc_R528_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R528_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|#
directive|if
literal|1
else|#
directive|else
name|ffestd_R528_finish_
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ffestc_R537_start -- PARAMETER statement list begin     ffestc_R537_start();     Verify that PARAMETER is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_R537_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_parameter_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
name|ffestd_R537_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R537_item -- PARAMETER statement assignment     ffestc_R537_item(dest,dest_token,source,source_token);     Make sure the source is a valid source for the destination; make the    assignment.	*/
end_comment

begin_function
name|void
name|ffestc_R537_item
parameter_list|(
name|ffebld
name|dest
parameter_list|,
name|ffelexToken
name|dest_token
parameter_list|,
name|ffebld
name|source
parameter_list|,
name|ffelexToken
name|source_token
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|if
condition|(
operator|(
name|ffebld_op
argument_list|(
name|dest
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
operator|||
operator|(
name|ffebld_op
argument_list|(
name|source
argument_list|)
operator|==
name|FFEBLD_opANY
operator|)
condition|)
block|{
if|if
condition|(
name|ffebld_op
argument_list|(
name|dest
argument_list|)
operator|==
name|FFEBLD_opSYMTER
condition|)
block|{
name|s
operator|=
name|ffebld_symter
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|ffesymbol_set_init
argument_list|(
name|s
argument_list|,
name|ffebld_new_any
argument_list|()
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|ffesymbol_init
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|ffestd_R537_item
argument_list|(
name|dest
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return;
block|}
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|dest
argument_list|)
operator|==
name|FFEBLD_opSYMTER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffebld_op
argument_list|(
name|source
argument_list|)
operator|==
name|FFEBLD_opCONTER
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffebld_symter
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
operator|&&
operator|(
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
operator|==
name|FFETARGET_charactersizeNONE
operator|)
condition|)
block|{
comment|/* Destination has explicit/implicit 				   CHARACTER*(*) type; set length. */
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|,
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffebld_size
argument_list|(
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|dest
argument_list|,
name|ffeinfo_use
argument_list|(
name|ffesymbol_info
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|source
operator|=
name|ffeexpr_convert_expr
argument_list|(
name|source
argument_list|,
name|source_token
argument_list|,
name|dest
argument_list|,
name|dest_token
argument_list|,
name|FFEEXPR_contextDATA
argument_list|)
expr_stmt|;
name|ffesymbol_set_init
argument_list|(
name|s
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffestd_R537_item
argument_list|(
name|dest
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R537_finish -- PARAMETER statement list complete     ffestc_R537_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R537_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R537_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R539 -- IMPLICIT NONE statement     ffestc_R539();     Verify that the IMPLICIT NONE statement is ok here and implement.  */
end_comment

begin_function
name|void
name|ffestc_R539
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_implicitnone_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffeimplic_none
argument_list|()
expr_stmt|;
name|ffestd_R539
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R539start -- IMPLICIT statement     ffestc_R539start();     Verify that the IMPLICIT statement is ok here and implement.	 */
end_comment

begin_function
name|void
name|ffestc_R539start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_implicit_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_R539start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R539item -- IMPLICIT statement specification (R540)     ffestc_R539item(...);     Verify that the type and letter list are all ok and implement.  */
end_comment

begin_function
name|void
name|ffestc_R539item
parameter_list|(
name|ffestpType
name|type
parameter_list|,
name|ffebld
name|kind
parameter_list|,
name|ffelexToken
name|kindt
parameter_list|,
name|ffebld
name|len
parameter_list|,
name|ffelexToken
name|lent
parameter_list|,
name|ffesttImpList
name|letters
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|if
condition|(
operator|(
name|type
operator|==
name|FFESTP_typeCHARACTER
operator|)
operator|&&
operator|(
name|len
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|len
argument_list|)
operator|==
name|FFEBLD_opSTAR
operator|)
condition|)
block|{
comment|/* Complain and pretend they're CHARACTER 				   [*1]. */
name|ffebad_start
argument_list|(
name|FFEBAD_IMPLICIT_ADJLEN
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|lent
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|lent
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|len
operator|=
name|NULL
expr_stmt|;
name|lent
operator|=
name|NULL
expr_stmt|;
block|}
name|ffestc_establish_declstmt_
argument_list|(
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|kind
argument_list|,
name|kindt
argument_list|,
name|len
argument_list|,
name|lent
argument_list|)
expr_stmt|;
name|ffestc_establish_declinfo_
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestt_implist_drive
argument_list|(
name|letters
argument_list|,
name|ffestc_establish_impletter_
argument_list|)
expr_stmt|;
name|ffestd_R539item
argument_list|(
name|type
argument_list|,
name|kind
argument_list|,
name|kindt
argument_list|,
name|len
argument_list|,
name|lent
argument_list|,
name|letters
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R539finish -- IMPLICIT statement     ffestc_R539finish();     Finish up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R539finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R539finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R542_start -- NAMELIST statement list begin     ffestc_R542_start();     Verify that NAMELIST is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_R542_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_progspec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffe_is_f2c_library
argument_list|()
operator|&&
operator|(
name|ffe_case_source
argument_list|()
operator|==
name|FFE_caseNONE
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_NAMELIST_CASE
argument_list|)
expr_stmt|;
name|ffesta_ffebad_here_current_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestd_R542_start
argument_list|()
expr_stmt|;
name|ffestc_local_
operator|.
name|namelist
operator|.
name|symbol
operator|=
name|NULL
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R542_item_nlist -- NAMELIST statement for group-name     ffestc_R542_item_nlist(groupname_token);     Make sure name_token identifies a valid object to be NAMELISTd.  */
end_comment

begin_function
name|void
name|ffestc_R542_item_nlist
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|if
condition|(
name|ffestc_local_
operator|.
name|namelist
operator|.
name|symbol
operator|!=
name|NULL
condition|)
name|ffesymbol_signal_unreported
argument_list|(
name|ffestc_local_
operator|.
name|namelist
operator|.
name|symbol
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
operator|)
operator|||
operator|(
operator|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNDERSTOOD
operator|)
operator|&&
operator|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_kindNAMELIST
operator|)
operator|)
condition|)
block|{
name|ffestc_parent_ok_
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
block|{
name|ffebld_init_list
argument_list|(
name|ffesymbol_ptr_to_namelist
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_ptr_to_listbottom
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindNAMELIST
argument_list|,
name|FFEINFO_whereLOCAL
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_kindANY
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ffestc_parent_ok_
operator|=
name|FALSE
expr_stmt|;
block|}
name|ffestc_local_
operator|.
name|namelist
operator|.
name|symbol
operator|=
name|s
expr_stmt|;
name|ffestd_R542_item_nlist
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R542_item_nitem -- NAMELIST statement for variable-name     ffestc_R542_item_nitem(name_token);     Make sure name_token identifies a valid object to be NAMELISTd.  */
end_comment

begin_function
name|void
name|ffestc_R542_item_nitem
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffebld
name|e
decl_stmt|;
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
operator|!
name|ffesymbol_is_specable
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
operator|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_kindENTITY
operator|)
operator|||
operator|(
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereLOCAL
operator|)
operator|&&
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_whereCOMMON
operator|)
operator|)
operator|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|na
operator|=
name|FFESYMBOL_attrsANY
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsSAVE
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
condition|)
name|na
operator|=
name|sa
operator||
name|FFESYMBOL_attrsNAMELIST
expr_stmt|;
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
name|ffesymbol_set_namelisted
argument_list|(
name|s
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* No need to establish type yet! */
block|if (!ffeimplic_establish_symbol (s)) 	ffesymbol_error (s, name);
endif|#
directive|endif
block|}
if|if
condition|(
name|ffestc_parent_ok_
condition|)
block|{
name|e
operator|=
name|ffebld_new_symter
argument_list|(
name|s
argument_list|,
name|FFEINTRIN_genNONE
argument_list|,
name|FFEINTRIN_specNONE
argument_list|,
name|FFEINTRIN_impNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindNONE
argument_list|,
name|FFEINFO_whereNONE
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_append_item
argument_list|(
name|ffesymbol_ptr_to_listbottom
argument_list|(
name|ffestc_local_
operator|.
name|namelist
operator|.
name|symbol
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|ffestd_R542_item_nitem
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R542_finish -- NAMELIST statement list complete     ffestc_R542_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R542_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffesymbol_signal_unreported
argument_list|(
name|ffestc_local_
operator|.
name|namelist
operator|.
name|symbol
argument_list|)
expr_stmt|;
name|ffestd_R542_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R544_start -- EQUIVALENCE statement list begin     ffestc_R544_start();     Verify that EQUIVALENCE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_R544_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_blockspec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R544_item -- EQUIVALENCE statement assignment     ffestc_R544_item(exprlist);     Make sure the equivalence is valid, then implement it.  */
end_comment

begin_function
name|void
name|ffestc_R544_item
parameter_list|(
name|ffesttExprList
name|exprlist
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
comment|/* First we go through the list and come up with one ffeequiv object that      will describe all items in the list.  When an ffeequiv object is first      found, it is used (else we create one as a "local equiv" for the time      being).  If subsequent ffeequiv objects are found, they are merged with      the first so we end up with one.  However, if more than one COMMON      variable is involved, then an error condition occurs. */
name|ffestc_local_
operator|.
name|equiv
operator|.
name|ok
operator|=
name|TRUE
expr_stmt|;
name|ffestc_local_
operator|.
name|equiv
operator|.
name|t
operator|=
name|NULL
expr_stmt|;
comment|/* No token yet. */
name|ffestc_local_
operator|.
name|equiv
operator|.
name|eq
operator|=
name|NULL
expr_stmt|;
comment|/* No equiv yet. */
name|ffestc_local_
operator|.
name|equiv
operator|.
name|save
operator|=
name|FALSE
expr_stmt|;
comment|/* No SAVEd variables yet. */
name|ffebld_init_list
argument_list|(
operator|&
name|ffestc_local_
operator|.
name|equiv
operator|.
name|list
argument_list|,
operator|&
name|ffestc_local_
operator|.
name|equiv
operator|.
name|bottom
argument_list|)
expr_stmt|;
name|ffestt_exprlist_drive
argument_list|(
name|exprlist
argument_list|,
name|ffestc_R544_equiv_
argument_list|)
expr_stmt|;
comment|/* Get one equiv. */
name|ffebld_end_list
argument_list|(
operator|&
name|ffestc_local_
operator|.
name|equiv
operator|.
name|bottom
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_local_
operator|.
name|equiv
operator|.
name|ok
condition|)
return|return;
comment|/* Something went wrong, stop bothering with 				   this stuff. */
if|if
condition|(
name|ffestc_local_
operator|.
name|equiv
operator|.
name|eq
operator|==
name|NULL
condition|)
name|ffestc_local_
operator|.
name|equiv
operator|.
name|eq
operator|=
name|ffeequiv_new
argument_list|()
expr_stmt|;
comment|/* Make local equivalence. */
comment|/* Append this list of equivalences to list of such lists for this      equivalence. */
name|ffeequiv_add
argument_list|(
name|ffestc_local_
operator|.
name|equiv
operator|.
name|eq
argument_list|,
name|ffestc_local_
operator|.
name|equiv
operator|.
name|list
argument_list|,
name|ffestc_local_
operator|.
name|equiv
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_local_
operator|.
name|equiv
operator|.
name|save
condition|)
name|ffeequiv_update_save
argument_list|(
name|ffestc_local_
operator|.
name|equiv
operator|.
name|eq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R544_equiv_ -- EQUIVALENCE statement handler for item in list     ffebld expr;    ffelexToken t;    ffestc_R544_equiv_(expr,t);     Record information, if any, on symbol in expr; if symbol has equivalence    object already, merge with outstanding object if present or make it    the outstanding object.  */
end_comment

begin_function
specifier|static
name|void
name|ffestc_R544_equiv_
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|t
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|ffestc_local_
operator|.
name|equiv
operator|.
name|ok
condition|)
return|return;
if|if
condition|(
name|ffestc_local_
operator|.
name|equiv
operator|.
name|t
operator|==
name|NULL
condition|)
name|ffestc_local_
operator|.
name|equiv
operator|.
name|t
operator|=
name|t
expr_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opANY
case|:
return|return;
comment|/* Don't put this on the list. */
case|case
name|FFEBLD_opSYMTER
case|:
case|case
name|FFEBLD_opARRAYREF
case|:
case|case
name|FFEBLD_opSUBSTR
case|:
break|break;
comment|/* All of these are ok. */
default|default:
name|assert
argument_list|(
literal|"ffestc_R544_equiv_ bad op"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|ffebld_append_item
argument_list|(
operator|&
name|ffestc_local_
operator|.
name|equiv
operator|.
name|bottom
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffeequiv_symbol
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* See if symbol has an equivalence object already. */
if|if
condition|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffestc_local_
operator|.
name|equiv
operator|.
name|eq
operator|==
name|NULL
condition|)
name|ffestc_local_
operator|.
name|equiv
operator|.
name|eq
operator|=
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* New equiv obj. */
elseif|else
if|if
condition|(
name|ffestc_local_
operator|.
name|equiv
operator|.
name|eq
operator|!=
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ffestc_local_
operator|.
name|equiv
operator|.
name|eq
operator|=
name|ffeequiv_merge
argument_list|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffestc_local_
operator|.
name|equiv
operator|.
name|eq
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_local_
operator|.
name|equiv
operator|.
name|eq
operator|==
name|NULL
condition|)
name|ffestc_local_
operator|.
name|equiv
operator|.
name|ok
operator|=
name|FALSE
expr_stmt|;
comment|/* Couldn't merge. */
block|}
block|}
if|if
condition|(
name|ffesymbol_is_save
argument_list|(
name|s
argument_list|)
condition|)
name|ffestc_local_
operator|.
name|equiv
operator|.
name|save
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R544_finish -- EQUIVALENCE statement list complete     ffestc_R544_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R544_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R547_start -- COMMON statement list begin     ffestc_R547_start();     Verify that COMMON is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestc_R547_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_blockspec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
operator|=
name|NULL
expr_stmt|;
comment|/* Blank common is the default. */
name|ffestc_parent_ok_
operator|=
name|TRUE
expr_stmt|;
name|ffestd_R547_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R547_item_object -- COMMON statement for object-name     ffestc_R547_item_object(name_token,dim_list);     Make sure name_token identifies a valid object to be COMMONd.  */
end_comment

begin_function
name|void
name|ffestc_R547_item_object
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffebld
name|array_size
decl_stmt|;
name|ffebld
name|extents
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffestpDimtype
name|nd
decl_stmt|;
name|ffebld
name|e
decl_stmt|;
name|ffeinfoRank
name|rank
decl_stmt|;
name|bool
name|is_ugly_assumed
decl_stmt|;
if|if
condition|(
name|ffestc_parent_ok_
operator|&&
operator|(
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
operator|==
name|NULL
operator|)
condition|)
name|ffestc_R547_item_cblock
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* As if "COMMON [//] ...". */
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|if
condition|(
name|dims
operator|!=
name|NULL
condition|)
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* First figure out what kind of object this is based solely on the current      object situation (dimension list). */
name|is_ugly_assumed
operator|=
operator|(
name|ffe_is_ugly_assumed
argument_list|()
operator|&&
operator|(
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsDUMMY
operator|)
operator|||
operator|(
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_whereDUMMY
operator|)
operator|)
operator|)
expr_stmt|;
name|nd
operator|=
name|ffestt_dimlist_type
argument_list|(
name|dims
argument_list|,
name|is_ugly_assumed
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nd
condition|)
block|{
case|case
name|FFESTP_dimtypeNONE
case|:
name|na
operator|=
name|FFESYMBOL_attrsCOMMON
expr_stmt|;
break|break;
case|case
name|FFESTP_dimtypeKNOWN
case|:
name|na
operator|=
name|FFESYMBOL_attrsCOMMON
operator||
name|FFESYMBOL_attrsARRAY
expr_stmt|;
break|break;
default|default:
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
break|break;
block|}
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ffesymbol_is_specable
argument_list|(
name|s
argument_list|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Can't dcl sym ref'd in sfuncdef. */
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|na
operator|=
name|FFESYMBOL_attrsANY
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sa
operator|&
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsSFARG
operator|)
operator|)
operator|&&
operator|(
name|na
operator|&
name|FFESYMBOL_attrsARRAY
operator|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsADJUSTS
operator||
name|FFESYMBOL_attrsARRAY
operator||
name|FFESYMBOL_attrsEQUIV
operator||
name|FFESYMBOL_attrsINIT
operator||
name|FFESYMBOL_attrsNAMELIST
operator||
name|FFESYMBOL_attrsSFARG
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
condition|)
name|na
operator||=
name|sa
expr_stmt|;
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeequiv_common
argument_list|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffeequiv_common
argument_list|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
argument_list|)
operator|!=
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
operator|)
condition|)
block|{
comment|/* Oops, just COMMONed a symbol to a different area (via equiv).  */
name|ffebad_start
argument_list|(
name|FFEBAD_EQUIV_COMMON
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffeequiv_common
argument_list|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffesymbol_set_attr
argument_list|(
name|s
argument_list|,
name|na
operator||
name|FFESYMBOL_attrANY
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
name|ffesymbol_set_common
argument_list|(
name|s
argument_list|,
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
argument_list|)
expr_stmt|;
if|#
directive|if
name|FFEGLOBAL_ENABLED
if|if
condition|(
name|ffesymbol_is_init
argument_list|(
name|s
argument_list|)
condition|)
name|ffeglobal_init_common
argument_list|(
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ffesymbol_is_save
argument_list|(
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
argument_list|)
condition|)
name|ffesymbol_update_save
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Is this newly COMMONed symbol involved in 				   an equivalence? */
if|if
condition|(
name|ffeequiv_common
argument_list|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
name|ffeequiv_set_common
argument_list|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
argument_list|,
comment|/* Yes, tell equiv obj. */
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
argument_list|)
expr_stmt|;
if|#
directive|if
name|FFEGLOBAL_ENABLED
if|if
condition|(
name|ffeequiv_is_init
argument_list|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
name|ffeglobal_init_common
argument_list|(
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ffesymbol_is_save
argument_list|(
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
argument_list|)
condition|)
name|ffeequiv_update_save
argument_list|(
name|ffesymbol_equiv
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dims
operator|!=
name|NULL
condition|)
block|{
name|ffesymbol_set_dims
argument_list|(
name|s
argument_list|,
name|ffestt_dimlist_as_expr
argument_list|(
name|dims
argument_list|,
operator|&
name|rank
argument_list|,
operator|&
name|array_size
argument_list|,
operator|&
name|extents
argument_list|,
name|is_ugly_assumed
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_arraysize
argument_list|(
name|s
argument_list|,
name|array_size
argument_list|)
expr_stmt|;
name|ffesymbol_set_extents
argument_list|(
name|s
argument_list|,
name|extents
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|0
operator|&&
name|ffe_is_90
argument_list|()
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|array_size
argument_list|)
operator|==
name|FFEBLD_opCONTER
operator|)
operator|&&
operator|(
name|ffebld_constant_integerdefault
argument_list|(
name|ffebld_conter
argument_list|(
name|array_size
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_ZERO_ARRAY
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
name|rank
argument_list|,
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_where
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffestc_parent_ok_
condition|)
block|{
name|e
operator|=
name|ffebld_new_symter
argument_list|(
name|s
argument_list|,
name|FFEINTRIN_genNONE
argument_list|,
name|FFEINTRIN_specNONE
argument_list|,
name|FFEINTRIN_impNONE
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|e
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindNONE
argument_list|,
name|FFEINFO_whereNONE
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_append_item
argument_list|(
name|ffesymbol_ptr_to_listbottom
argument_list|(
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|ffestd_R547_item_object
argument_list|(
name|name
argument_list|,
name|dims
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R547_item_cblock -- COMMON statement for common-block-name     ffestc_R547_item_cblock(name_token);     Make sure name_token identifies a valid common block to be COMMONd.	*/
end_comment

begin_function
name|void
name|ffestc_R547_item_cblock
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|if
condition|(
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
operator|!=
name|NULL
condition|)
name|ffesymbol_signal_unreported
argument_list|(
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_cblock
argument_list|(
name|name
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
operator|!
name|ffesymbol_is_specable
argument_list|(
name|s
argument_list|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|na
operator|=
name|FFESYMBOL_attrsANY
expr_stmt|;
comment|/* Already have an error here, say nothing. */
elseif|else
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsCBLOCK
operator||
name|FFESYMBOL_attrsSAVECBLOCK
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsCBLOCK
operator|)
condition|)
name|ffebld_init_list
argument_list|(
name|ffesymbol_ptr_to_commonlist
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_ptr_to_listbottom
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|na
operator|=
name|sa
operator||
name|FFESYMBOL_attrsCBLOCK
expr_stmt|;
block|}
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|name
operator|==
name|NULL
condition|?
name|ffesta_tokens
index|[
literal|0
index|]
else|:
name|name
argument_list|)
expr_stmt|;
name|ffestc_parent_ok_
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|na
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|ffestc_parent_ok_
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|ffesymbol_update_save
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffestc_parent_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
operator|=
name|s
expr_stmt|;
name|ffestd_R547_item_cblock
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R547_finish -- COMMON statement list complete     ffestc_R547_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R547_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|if
condition|(
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
operator|!=
name|NULL
condition|)
name|ffesymbol_signal_unreported
argument_list|(
name|ffestc_local_
operator|.
name|common
operator|.
name|symbol
argument_list|)
expr_stmt|;
name|ffestd_R547_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R620 -- ALLOCATE statement     ffestc_R620(exprlist,stat,stat_token);     Make sure the expression list is valid, then implement it.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestc_R620
parameter_list|(
name|ffesttExprList
name|exprlist
parameter_list|,
name|ffebld
name|stat
parameter_list|,
name|ffelexToken
name|stat_token
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
name|ffestd_R620
argument_list|(
name|exprlist
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R624 -- NULLIFY statement     ffestc_R624(pointer_name_list);     Make sure pointer_name_list identifies valid pointers for a NULLIFY.	 */
end_comment

begin_function
name|void
name|ffestc_R624
parameter_list|(
name|ffesttExprList
name|pointers
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
name|ffestd_R624
argument_list|(
name|pointers
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R625 -- DEALLOCATE statement     ffestc_R625(exprlist,stat,stat_token);     Make sure the equivalence is valid, then implement it.  */
end_comment

begin_function
name|void
name|ffestc_R625
parameter_list|(
name|ffesttExprList
name|exprlist
parameter_list|,
name|ffebld
name|stat
parameter_list|,
name|ffelexToken
name|stat_token
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
name|ffestd_R625
argument_list|(
name|exprlist
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_let -- R1213 or R737     ffestc_let(...);     Verify that R1213 defined-assignment or R737 assignment-stmt are    valid here, figure out which one, and implement.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestc_let
parameter_list|(
name|ffebld
name|dest
parameter_list|,
name|ffebld
name|source
parameter_list|,
name|ffelexToken
name|source_token
parameter_list|)
block|{
name|ffestc_R737
argument_list|(
name|dest
argument_list|,
name|source
argument_list|,
name|source_token
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_R737 -- Assignment statement     ffestc_R737(dest_expr,source_expr,source_token);     Make sure the assignment is valid.  */
end_comment

begin_function
name|void
name|ffestc_R737
parameter_list|(
name|ffebld
name|dest
parameter_list|,
name|ffebld
name|source
parameter_list|,
name|ffelexToken
name|source_token
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTV_stateWHERE
case|:
case|case
name|FFESTV_stateWHERETHEN
case|:
if|if
condition|(
name|ffestc_order_actionwhere_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_R737B
argument_list|(
name|dest
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
default|default:
break|break;
block|}
if|if
condition|(
name|ffestc_order_actionwhere_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
name|source
operator|=
name|ffeexpr_convert_expr
argument_list|(
name|source
argument_list|,
name|source_token
argument_list|,
name|dest
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|ffestd_R737A
argument_list|(
name|dest
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R738 -- Pointer assignment statement     ffestc_R738(dest_expr,source_expr,source_token);     Make sure the assignment is valid.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestc_R738
parameter_list|(
name|ffebld
name|dest
parameter_list|,
name|ffebld
name|source
parameter_list|,
name|ffelexToken
name|source_token
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
name|ffestd_R738
argument_list|(
name|dest
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R740 -- WHERE statement     ffestc_R740(expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestc_R740
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|ffestw_top_do
argument_list|(
name|ffestw_previous
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateWHERE
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
name|ffestc_blocknum_
operator|++
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_where_lost_
argument_list|)
expr_stmt|;
name|ffestd_R740
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Leave label finishing to next statement. */
block|}
end_function

begin_comment
comment|/* ffestc_R742 -- WHERE-construct statement     ffestc_R742(expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestc_R742
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_exec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_probably_this_wont_work_
argument_list|()
expr_stmt|;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|ffestw_top_do
argument_list|(
name|ffestw_previous
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateWHERETHEN
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
name|ffestc_blocknum_
operator|++
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_wherethen_
argument_list|)
expr_stmt|;
name|ffestw_set_substate
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Haven't seen ELSEWHERE yet. */
name|ffestd_R742
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R744 -- ELSE WHERE statement     ffestc_R744();     Make sure ffestc_kind_ identifies a WHERE block.    Implement the ELSE of the current WHERE block.  */
end_comment

begin_function
name|void
name|ffestc_R744
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_where_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestw_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_SECOND_ELSE_WHERE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestw_set_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Saw ELSEWHERE. */
name|ffestd_R744
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R745 -- END WHERE statement     ffestc_R745();     Make sure ffestc_kind_ identifies a WHERE block.    Implement the end of the current WHERE block.  */
end_comment

begin_function
name|void
name|ffestc_R745
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_where_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestc_shriek_wherethen_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_R803 -- Block IF (IF-THEN) statement     ffestc_R803(construct_name,expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestc_R803
parameter_list|(
name|ffelexToken
name|construct_name
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
name|UNUSED
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_exec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_
argument_list|()
expr_stmt|;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|ffestw_top_do
argument_list|(
name|ffestw_previous
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateIFTHEN
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
name|ffestc_blocknum_
operator|++
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_ifthen_
argument_list|)
expr_stmt|;
name|ffestw_set_substate
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Haven't seen ELSE yet. */
if|if
condition|(
name|construct_name
operator|==
name|NULL
condition|)
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|ffelex_token_use
argument_list|(
name|construct_name
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|construct_name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
block|{
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindCONSTRUCT
argument_list|,
name|FFEINFO_whereLOCAL
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|construct_name
argument_list|)
expr_stmt|;
block|}
name|ffestd_R803
argument_list|(
name|construct_name
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R804 -- ELSE IF statement     ffestc_R804(expr,expr_token,name_token);     Make sure ffestc_kind_ identifies an IF block.  If not    NULL, make sure name_token gives the correct name.  Implement the else    of the IF block.  */
end_comment

begin_function
name|void
name|ffestc_R804
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
name|UNUSED
parameter_list|,
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_ifthen_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_NOT_NAMED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffelex_token_strcmp
argument_list|(
name|name
argument_list|,
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_WRONG_NAME
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ffestw_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_AFTER_ELSE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return;
comment|/* Don't upset back end with ELSEIF 				   after ELSE. */
block|}
name|ffestd_R804
argument_list|(
name|expr
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R805 -- ELSE statement     ffestc_R805(name_token);     Make sure ffestc_kind_ identifies an IF block.  If not    NULL, make sure name_token gives the correct name.  Implement the ELSE    of the IF block.  */
end_comment

begin_function
name|void
name|ffestc_R805
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_ifthen_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_NOT_NAMED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffelex_token_strcmp
argument_list|(
name|name
argument_list|,
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_WRONG_NAME
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ffestw_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_AFTER_ELSE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
return|return;
comment|/* Tell back end about only one ELSE. */
block|}
name|ffestw_set_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Saw ELSE. */
name|ffestd_R805
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R806 -- END IF statement     ffestc_R806(name_token);     Make sure ffestc_kind_ identifies an IF block.  If not    NULL, make sure name_token gives the correct name.  Implement the end    of the IF block.  */
end_comment

begin_function
name|void
name|ffestc_R806
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_ifthen_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_endif_
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_NAMED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_NOT_NAMED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffelex_token_strcmp
argument_list|(
name|name
argument_list|,
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_WRONG_NAME
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|ffestc_shriek_ifthen_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R807 -- Logical IF statement     ffestc_R807(expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestc_R807
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
name|UNUSED
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_action_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|ffestw_top_do
argument_list|(
name|ffestw_previous
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateIF
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
name|ffestc_blocknum_
operator|++
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_if_lost_
argument_list|)
expr_stmt|;
name|ffestd_R807
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Do the label finishing in the next statement. */
block|}
end_function

begin_comment
comment|/* ffestc_R809 -- SELECT CASE statement     ffestc_R809(construct_name,expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestc_R809
parameter_list|(
name|ffelexToken
name|construct_name
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|mallocPool
name|pool
decl_stmt|;
name|ffestwSelect
name|s
decl_stmt|;
name|ffesymbol
name|sym
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_exec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_
argument_list|()
expr_stmt|;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|ffestw_top_do
argument_list|(
name|ffestw_previous
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateSELECT0
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
name|ffestc_blocknum_
operator|++
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_select_
argument_list|)
expr_stmt|;
name|ffestw_set_substate
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Haven't seen CASE DEFAULT yet. */
comment|/* Init block to manage CASE list. */
name|pool
operator|=
name|malloc_pool_new
argument_list|(
literal|"Select"
argument_list|,
name|ffe_pool_any_unit
argument_list|()
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|ffestwSelect
operator|)
name|malloc_new_kp
argument_list|(
name|pool
argument_list|,
literal|"Select"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|first_rel
operator|=
operator|(
name|ffestwCase
operator|)
operator|&
name|s
operator|->
name|first_rel
expr_stmt|;
name|s
operator|->
name|last_rel
operator|=
operator|(
name|ffestwCase
operator|)
operator|&
name|s
operator|->
name|first_rel
expr_stmt|;
name|s
operator|->
name|first_stmt
operator|=
operator|(
name|ffestwCase
operator|)
operator|&
name|s
operator|->
name|first_rel
expr_stmt|;
name|s
operator|->
name|last_stmt
operator|=
operator|(
name|ffestwCase
operator|)
operator|&
name|s
operator|->
name|first_rel
expr_stmt|;
name|s
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|s
operator|->
name|cases
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|expr_token
argument_list|)
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|kindtype
operator|=
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_select
argument_list|(
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|construct_name
operator|==
name|NULL
condition|)
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|ffelex_token_use
argument_list|(
name|construct_name
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|ffesymbol_declare_local
argument_list|(
name|construct_name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|sym
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
block|{
name|ffesymbol_set_state
argument_list|(
name|sym
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|sym
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindCONSTRUCT
argument_list|,
name|FFEINFO_whereLOCAL
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|ffecom_sym_learned
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
name|ffesymbol_error
argument_list|(
name|sym
argument_list|,
name|construct_name
argument_list|)
expr_stmt|;
block|}
name|ffestd_R809
argument_list|(
name|construct_name
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R810 -- CASE statement     ffestc_R810(case_value_range_list,name);     If case_value_range_list is NULL, it's CASE DEFAULT.	 name is the case-    construct-name.  Make sure no more than one CASE DEFAULT is present for    a given case-construct and that there aren't any overlapping ranges or    duplicate case values.  */
end_comment

begin_function
name|void
name|ffestc_R810
parameter_list|(
name|ffesttCaseList
name|cases
parameter_list|,
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffesttCaseList
name|caseobj
decl_stmt|;
name|ffestwSelect
name|s
decl_stmt|;
name|ffestwCase
name|c
decl_stmt|,
name|nc
decl_stmt|;
name|ffebldConstant
name|expr1c
decl_stmt|,
name|expr2c
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_selectcase_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|s
operator|=
name|ffestw_select
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|FFESTV_stateSELECT0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Not sure we want to have msgs point here 				   instead of SELECT CASE. */
block|ffestw_update (NULL);
comment|/* Update state line/col info. */
endif|#
directive|endif
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateSELECT1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_NOT_NAMED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffelex_token_strcmp
argument_list|(
name|name
argument_list|,
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_WRONG_NAME
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cases
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ffestw_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CASE_SECOND_DEFAULT
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestw_set_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Saw ELSE. */
block|}
else|else
block|{
comment|/* For each case, try to fit into sorted list 				   of ranges. */
for|for
control|(
name|caseobj
operator|=
name|cases
operator|->
name|next
init|;
name|caseobj
operator|!=
name|cases
condition|;
name|caseobj
operator|=
name|caseobj
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|caseobj
operator|->
name|expr1
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|!
name|caseobj
operator|->
name|range
operator|||
operator|(
name|caseobj
operator|->
name|expr2
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
comment|/* "CASE (:)". */
name|ffebad_start
argument_list|(
name|FFEBAD_CASE_BAD_RANGE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|caseobj
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|caseobj
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|caseobj
operator|->
name|expr1
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|caseobj
operator|->
name|expr1
argument_list|)
argument_list|)
operator|!=
name|s
operator|->
name|type
operator|)
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|caseobj
operator|->
name|expr1
argument_list|)
argument_list|)
operator|!=
name|s
operator|->
name|kindtype
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|caseobj
operator|->
name|range
operator|)
operator|&&
operator|(
name|caseobj
operator|->
name|expr2
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|caseobj
operator|->
name|expr2
argument_list|)
argument_list|)
operator|!=
name|s
operator|->
name|type
operator|)
operator|||
operator|(
name|ffeinfo_kindtype
argument_list|(
name|ffebld_info
argument_list|(
name|caseobj
operator|->
name|expr2
argument_list|)
argument_list|)
operator|!=
name|s
operator|->
name|kindtype
operator|)
operator|)
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CASE_TYPE_DISAGREE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|caseobj
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|caseobj
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|s
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|s
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|type
operator|==
name|FFEINFO_basictypeLOGICAL
operator|)
operator|&&
operator|(
name|caseobj
operator|->
name|range
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CASE_LOGICAL_RANGE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|caseobj
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|caseobj
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|caseobj
operator|->
name|expr1
operator|==
name|NULL
condition|)
name|expr1c
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|caseobj
operator|->
name|expr1
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
continue|continue;
comment|/* opANY. */
else|else
name|expr1c
operator|=
name|ffebld_conter
argument_list|(
name|caseobj
operator|->
name|expr1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|caseobj
operator|->
name|range
condition|)
name|expr2c
operator|=
name|expr1c
expr_stmt|;
comment|/* expr1c and expr2c are NOT NULL in this 				   case. */
elseif|else
if|if
condition|(
name|caseobj
operator|->
name|expr2
operator|==
name|NULL
condition|)
name|expr2c
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|ffebld_op
argument_list|(
name|caseobj
operator|->
name|expr2
argument_list|)
operator|!=
name|FFEBLD_opCONTER
condition|)
continue|continue;
comment|/* opANY. */
else|else
name|expr2c
operator|=
name|ffebld_conter
argument_list|(
name|caseobj
operator|->
name|expr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr1c
operator|==
name|NULL
condition|)
block|{
comment|/* "CASE (:high)", must be first in list. */
name|c
operator|=
name|s
operator|->
name|first_rel
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
operator|(
name|ffestwCase
operator|)
operator|&
name|s
operator|->
name|first_rel
operator|)
operator|&&
operator|(
operator|(
name|c
operator|->
name|low
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_constant_cmp
argument_list|(
name|expr2c
argument_list|,
name|c
operator|->
name|low
argument_list|)
operator|>=
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Other "CASE (:high)" or lowest "CASE 				   (low[:high])" low. */
name|ffebad_start
argument_list|(
name|FFEBAD_CASE_DUPLICATE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|caseobj
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|caseobj
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|c
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|c
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|expr2c
operator|==
name|NULL
condition|)
block|{
comment|/* "CASE (low:)", must be last in list. */
name|c
operator|=
name|s
operator|->
name|last_rel
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
operator|(
name|ffestwCase
operator|)
operator|&
name|s
operator|->
name|first_rel
operator|)
operator|&&
operator|(
operator|(
name|c
operator|->
name|high
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_constant_cmp
argument_list|(
name|expr1c
argument_list|,
name|c
operator|->
name|high
argument_list|)
operator|<=
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Other "CASE (low:)" or lowest "CASE 				   ([low:]high)" high. */
name|ffebad_start
argument_list|(
name|FFEBAD_CASE_DUPLICATE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|caseobj
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|caseobj
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|c
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|c
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|c
operator|->
name|next_rel
expr_stmt|;
comment|/* Same as c = (ffestwCase)&s->first;. */
block|}
else|else
block|{
comment|/* (expr1c != NULL)&& (expr2c != NULL). */
if|if
condition|(
name|ffebld_constant_cmp
argument_list|(
name|expr1c
argument_list|,
name|expr2c
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Such as "CASE (3:1)" or "CASE ('B':'A')". */
name|ffebad_start
argument_list|(
name|FFEBAD_CASE_RANGE_USELESS
argument_list|)
expr_stmt|;
comment|/* Warn/inform only. */
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|caseobj
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|caseobj
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|c
operator|=
name|s
operator|->
name|first_rel
init|;
operator|(
name|c
operator|!=
operator|(
name|ffestwCase
operator|)
operator|&
name|s
operator|->
name|first_rel
operator|)
operator|&&
operator|(
operator|(
name|c
operator|->
name|low
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffebld_constant_cmp
argument_list|(
name|expr1c
argument_list|,
name|c
operator|->
name|low
argument_list|)
operator|>
literal|0
operator|)
operator|)
condition|;
name|c
operator|=
name|c
operator|->
name|next_rel
control|)
empty_stmt|;
name|nc
operator|=
name|c
expr_stmt|;
comment|/* Which one to report? */
if|if
condition|(
operator|(
operator|(
name|c
operator|!=
operator|(
name|ffestwCase
operator|)
operator|&
name|s
operator|->
name|first_rel
operator|)
operator|&&
operator|(
name|ffebld_constant_cmp
argument_list|(
name|expr2c
argument_list|,
name|c
operator|->
name|low
argument_list|)
operator|>=
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|nc
operator|=
name|c
operator|->
name|previous_rel
operator|)
operator|!=
operator|(
name|ffestwCase
operator|)
operator|&
name|s
operator|->
name|first_rel
operator|)
operator|&&
operator|(
name|ffebld_constant_cmp
argument_list|(
name|expr1c
argument_list|,
name|nc
operator|->
name|high
argument_list|)
operator|<=
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Interference with range in case nc. */
name|ffebad_start
argument_list|(
name|FFEBAD_CASE_DUPLICATE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|caseobj
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|caseobj
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|nc
operator|->
name|t
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|nc
operator|->
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If we reach here for this case range/value, it's ok (sorts into 	     the list of ranges/values) so we give it its own case object 	     sorted into the list of case statements. */
name|nc
operator|=
name|malloc_new_kp
argument_list|(
name|s
operator|->
name|pool
argument_list|,
literal|"Case range"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nc
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|next_rel
operator|=
name|c
expr_stmt|;
name|nc
operator|->
name|previous_rel
operator|=
name|c
operator|->
name|previous_rel
expr_stmt|;
name|nc
operator|->
name|next_stmt
operator|=
operator|(
name|ffestwCase
operator|)
operator|&
name|s
operator|->
name|first_rel
expr_stmt|;
name|nc
operator|->
name|previous_stmt
operator|=
name|s
operator|->
name|last_stmt
expr_stmt|;
name|nc
operator|->
name|low
operator|=
name|expr1c
expr_stmt|;
name|nc
operator|->
name|high
operator|=
name|expr2c
expr_stmt|;
name|nc
operator|->
name|casenum
operator|=
name|s
operator|->
name|cases
expr_stmt|;
name|nc
operator|->
name|t
operator|=
name|ffelex_token_use
argument_list|(
name|caseobj
operator|->
name|t
argument_list|)
expr_stmt|;
name|nc
operator|->
name|next_rel
operator|->
name|previous_rel
operator|=
name|nc
expr_stmt|;
name|nc
operator|->
name|previous_rel
operator|->
name|next_rel
operator|=
name|nc
expr_stmt|;
name|nc
operator|->
name|next_stmt
operator|->
name|previous_stmt
operator|=
name|nc
expr_stmt|;
name|nc
operator|->
name|previous_stmt
operator|->
name|next_stmt
operator|=
name|nc
expr_stmt|;
block|}
block|}
name|ffestd_R810
argument_list|(
operator|(
name|cases
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|s
operator|->
name|cases
argument_list|)
expr_stmt|;
name|s
operator|->
name|cases
operator|++
expr_stmt|;
comment|/* Increment # of cases. */
block|}
end_function

begin_comment
comment|/* ffestc_R811 -- END SELECT statement     ffestc_R811(name_token);     Make sure ffestc_kind_ identifies a SELECT block.  If not    NULL, make sure name_token gives the correct name.  Implement the end    of the SELECT block.	 */
end_comment

begin_function
name|void
name|ffestc_R811
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_selectcase_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_NAMED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_NOT_NAMED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffelex_token_strcmp
argument_list|(
name|name
argument_list|,
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_WRONG_NAME
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|ffestc_shriek_select_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R819A -- Iterative labeled DO statement     ffestc_R819A(construct_name,label_token,expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestc_R819A
parameter_list|(
name|ffelexToken
name|construct_name
parameter_list|,
name|ffelexToken
name|label_token
parameter_list|,
name|ffebld
name|var
parameter_list|,
name|ffelexToken
name|var_token
parameter_list|,
name|ffebld
name|start
parameter_list|,
name|ffelexToken
name|start_token
parameter_list|,
name|ffebld
name|end
parameter_list|,
name|ffelexToken
name|end_token
parameter_list|,
name|ffebld
name|incr
parameter_list|,
name|ffelexToken
name|incr_token
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffelab
name|label
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbol
name|varsym
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_exec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_labelref_is_loopend_
argument_list|(
name|label_token
argument_list|,
operator|&
name|label
argument_list|)
condition|)
return|return;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateDO
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
name|ffestc_blocknum_
operator|++
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_do_
argument_list|)
expr_stmt|;
name|ffestw_set_label
argument_list|(
name|b
argument_list|,
name|label
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|var
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opSYMTER
case|:
if|if
condition|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|var
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeREAL
operator|)
operator|&&
name|ffe_is_warn_surprising
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DO_REAL
argument_list|)
expr_stmt|;
comment|/* See error message!!! */
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|var_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|var_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffebld_symter
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ffesymbol_is_doiter
argument_list|(
name|varsym
operator|=
name|ffebld_symter
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Presumably already complained about by 				   ffeexpr_lhs_. */
name|ffesymbol_set_is_doiter
argument_list|(
name|varsym
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ffestw_set_do_iter_var
argument_list|(
name|b
argument_list|,
name|varsym
argument_list|)
expr_stmt|;
name|ffestw_set_do_iter_var_t
argument_list|(
name|b
argument_list|,
name|ffelex_token_use
argument_list|(
name|var_token
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
name|FFEBLD_opANY
case|:
name|ffestw_set_do_iter_var
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_do_iter_var_t
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad iter var"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|construct_name
operator|==
name|NULL
condition|)
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|ffelex_token_use
argument_list|(
name|construct_name
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|construct_name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
block|{
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindCONSTRUCT
argument_list|,
name|FFEINFO_whereLOCAL
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|construct_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|incr
operator|==
name|NULL
condition|)
block|{
name|incr
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_integerdefault_val
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|incr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|ffeexpr_convert_expr
argument_list|(
name|start
argument_list|,
name|start_token
argument_list|,
name|var
argument_list|,
name|var_token
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|end
operator|=
name|ffeexpr_convert_expr
argument_list|(
name|end
argument_list|,
name|end_token
argument_list|,
name|var
argument_list|,
name|var_token
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|incr
operator|=
name|ffeexpr_convert_expr
argument_list|(
name|incr
argument_list|,
name|incr_token
argument_list|,
name|var
argument_list|,
name|var_token
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|ffestd_R819A
argument_list|(
name|construct_name
argument_list|,
name|label
argument_list|,
name|var
argument_list|,
name|start
argument_list|,
name|start_token
argument_list|,
name|end
argument_list|,
name|end_token
argument_list|,
name|incr
argument_list|,
name|incr_token
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R819B -- Labeled DO WHILE statement     ffestc_R819B(construct_name,label_token,expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestc_R819B
parameter_list|(
name|ffelexToken
name|construct_name
parameter_list|,
name|ffelexToken
name|label_token
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
name|UNUSED
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffelab
name|label
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_exec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_labelref_is_loopend_
argument_list|(
name|label_token
argument_list|,
operator|&
name|label
argument_list|)
condition|)
return|return;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateDO
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
name|ffestc_blocknum_
operator|++
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_do_
argument_list|)
expr_stmt|;
name|ffestw_set_label
argument_list|(
name|b
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|ffestw_set_do_iter_var
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_do_iter_var_t
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|construct_name
operator|==
name|NULL
condition|)
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|ffelex_token_use
argument_list|(
name|construct_name
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|construct_name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
block|{
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindCONSTRUCT
argument_list|,
name|FFEINFO_whereLOCAL
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|construct_name
argument_list|)
expr_stmt|;
block|}
name|ffestd_R819B
argument_list|(
name|construct_name
argument_list|,
name|label
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R820A -- Iterative nonlabeled DO statement     ffestc_R820A(construct_name,expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestc_R820A
parameter_list|(
name|ffelexToken
name|construct_name
parameter_list|,
name|ffebld
name|var
parameter_list|,
name|ffelexToken
name|var_token
parameter_list|,
name|ffebld
name|start
parameter_list|,
name|ffelexToken
name|start_token
parameter_list|,
name|ffebld
name|end
parameter_list|,
name|ffelexToken
name|end_token
parameter_list|,
name|ffebld
name|incr
parameter_list|,
name|ffelexToken
name|incr_token
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbol
name|varsym
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_exec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_
argument_list|()
expr_stmt|;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateDO
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
name|ffestc_blocknum_
operator|++
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_do_
argument_list|)
expr_stmt|;
name|ffestw_set_label
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffebld_op
argument_list|(
name|var
argument_list|)
condition|)
block|{
case|case
name|FFEBLD_opSYMTER
case|:
if|if
condition|(
operator|(
name|ffeinfo_basictype
argument_list|(
name|ffebld_info
argument_list|(
name|var
argument_list|)
argument_list|)
operator|==
name|FFEINFO_basictypeREAL
operator|)
operator|&&
name|ffe_is_warn_surprising
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DO_REAL
argument_list|)
expr_stmt|;
comment|/* See error message!!! */
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|var_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|var_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
name|ffesymbol_text
argument_list|(
name|ffebld_symter
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ffesymbol_is_doiter
argument_list|(
name|varsym
operator|=
name|ffebld_symter
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Presumably already complained about by 				   ffeexpr_lhs_. */
name|ffesymbol_set_is_doiter
argument_list|(
name|varsym
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ffestw_set_do_iter_var
argument_list|(
name|b
argument_list|,
name|varsym
argument_list|)
expr_stmt|;
name|ffestw_set_do_iter_var_t
argument_list|(
name|b
argument_list|,
name|ffelex_token_use
argument_list|(
name|var_token
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
name|FFEBLD_opANY
case|:
name|ffestw_set_do_iter_var
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_do_iter_var_t
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"bad iter var"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|construct_name
operator|==
name|NULL
condition|)
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|ffelex_token_use
argument_list|(
name|construct_name
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|construct_name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
block|{
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindCONSTRUCT
argument_list|,
name|FFEINFO_whereLOCAL
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|construct_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|incr
operator|==
name|NULL
condition|)
block|{
name|incr
operator|=
name|ffebld_new_conter
argument_list|(
name|ffebld_constant_new_integerdefault_val
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|incr
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeINTEGER
argument_list|,
name|FFEINFO_kindtypeINTEGERDEFAULT
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereCONSTANT
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|ffeexpr_convert_expr
argument_list|(
name|start
argument_list|,
name|start_token
argument_list|,
name|var
argument_list|,
name|var_token
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|end
operator|=
name|ffeexpr_convert_expr
argument_list|(
name|end
argument_list|,
name|end_token
argument_list|,
name|var
argument_list|,
name|var_token
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
name|incr
operator|=
name|ffeexpr_convert_expr
argument_list|(
name|incr
argument_list|,
name|incr_token
argument_list|,
name|var
argument_list|,
name|var_token
argument_list|,
name|FFEEXPR_contextLET
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if ((ffebld_op (incr) == FFEBLD_opCONTER)&& (ffebld_constant_is_zero (ffebld_conter (incr))))     {       ffebad_start (FFEBAD_DO_STEP_ZERO);       ffebad_here (0, ffelex_token_where_line (incr_token), 		   ffelex_token_where_column (incr_token));       ffebad_string ("Iterative DO loop");       ffebad_finish ();     }
endif|#
directive|endif
name|ffestd_R819A
argument_list|(
name|construct_name
argument_list|,
name|NULL
argument_list|,
name|var
argument_list|,
name|start
argument_list|,
name|start_token
argument_list|,
name|end
argument_list|,
name|end_token
argument_list|,
name|incr
argument_list|,
name|incr_token
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R820B -- Nonlabeled DO WHILE statement     ffestc_R820B(construct_name,expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestc_R820B
parameter_list|(
name|ffelexToken
name|construct_name
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
name|UNUSED
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_exec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_
argument_list|()
expr_stmt|;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateDO
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
name|ffestc_blocknum_
operator|++
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_do_
argument_list|)
expr_stmt|;
name|ffestw_set_label
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_do_iter_var
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_do_iter_var_t
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|construct_name
operator|==
name|NULL
condition|)
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|ffelex_token_use
argument_list|(
name|construct_name
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|construct_name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
block|{
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindCONSTRUCT
argument_list|,
name|FFEINFO_whereLOCAL
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_learned
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|construct_name
argument_list|)
expr_stmt|;
block|}
name|ffestd_R819B
argument_list|(
name|construct_name
argument_list|,
name|NULL
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R825 -- END DO statement     ffestc_R825(name_token);     Make sure ffestc_kind_ identifies a DO block.  If not    NULL, make sure name_token gives the correct name.  Implement the end    of the DO block.  */
end_comment

begin_function
name|void
name|ffestc_R825
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_do_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_NAMED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_NOT_NAMED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffelex_token_strcmp
argument_list|(
name|name
argument_list|,
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_WRONG_NAME
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ffesta_label_token
operator|==
name|NULL
condition|)
block|{
comment|/* If top of stack has label, its an error! */
if|if
condition|(
name|ffestw_label
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_DO_HAD_LABEL
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_shriek_do_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_try_shriek_do_
argument_list|()
expr_stmt|;
return|return;
block|}
name|ffestd_R825
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R834 -- CYCLE statement     ffestc_R834(name_token);     Handle a CYCLE within a loop.  */
end_comment

begin_function
name|void
name|ffestc_R834
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestw
name|block
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actiondo_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|block
operator|=
name|ffestw_top_do
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Search for name. */
for|for
control|(
name|block
operator|=
name|ffestw_top_do
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
init|;
operator|(
name|block
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffestw_blocknum
argument_list|(
name|block
argument_list|)
operator|!=
literal|0
operator|)
condition|;
name|block
operator|=
name|ffestw_top_do
argument_list|(
name|ffestw_previous
argument_list|(
name|block
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|ffestw_name
argument_list|(
name|block
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffelex_token_strcmp
argument_list|(
name|name
argument_list|,
name|ffestw_name
argument_list|(
name|block
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|block
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffestw_blocknum
argument_list|(
name|block
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|block
operator|=
name|ffestw_top_do
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_NO_DO_NAME
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|ffestd_R834
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* notloop's that are actionif's can be the target of a loop-end      statement if they're in the "then" part of a logical IF, as      in "DO 10", "10 IF (...) CYCLE".  */
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R835 -- EXIT statement     ffestc_R835(name_token);     Handle a EXIT within a loop.	 */
end_comment

begin_function
name|void
name|ffestc_R835
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestw
name|block
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actiondo_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|block
operator|=
name|ffestw_top_do
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Search for name. */
for|for
control|(
name|block
operator|=
name|ffestw_top_do
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
init|;
operator|(
name|block
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffestw_blocknum
argument_list|(
name|block
argument_list|)
operator|!=
literal|0
operator|)
condition|;
name|block
operator|=
name|ffestw_top_do
argument_list|(
name|ffestw_previous
argument_list|(
name|block
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|ffestw_name
argument_list|(
name|block
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffelex_token_strcmp
argument_list|(
name|name
argument_list|,
name|ffestw_name
argument_list|(
name|block
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|block
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ffestw_blocknum
argument_list|(
name|block
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|block
operator|=
name|ffestw_top_do
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_CONSTRUCT_NO_DO_NAME
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|ffestd_R835
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* notloop's that are actionif's can be the target of a loop-end      statement if they're in the "then" part of a logical IF, as      in "DO 10", "10 IF (...) EXIT".  */
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R836 -- GOTO statement     ffestc_R836(label_token);     Make sure label_token identifies a valid label for a GOTO.  Update    that label's info to indicate it is the target of a GOTO.  */
end_comment

begin_function
name|void
name|ffestc_R836
parameter_list|(
name|ffelexToken
name|label_token
parameter_list|)
block|{
name|ffelab
name|label
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_labelref_is_branch_
argument_list|(
name|label_token
argument_list|,
operator|&
name|label
argument_list|)
condition|)
name|ffestd_R836
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* notloop's that are actionif's can be the target of a loop-end      statement if they're in the "then" part of a logical IF, as      in "DO 10", "10 IF (...) GOTO 100".  */
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R837 -- Computed GOTO statement     ffestc_R837(label_list,expr,expr_token);     Make sure label_list identifies valid labels for a GOTO.  Update    each label's info to indicate it is the target of a GOTO.  */
end_comment

begin_function
name|void
name|ffestc_R837
parameter_list|(
name|ffesttTokenList
name|label_toks
parameter_list|,
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
name|UNUSED
parameter_list|)
block|{
name|ffesttTokenItem
name|ti
decl_stmt|;
name|bool
name|ok
init|=
name|TRUE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ffelab
modifier|*
name|labels
decl_stmt|;
name|assert
argument_list|(
name|label_toks
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
name|labels
operator|=
name|malloc_new_kp
argument_list|(
name|ffesta_output_pool
argument_list|,
literal|"FFESTC labels"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|labels
argument_list|)
operator|*
name|ffestt_tokenlist_count
argument_list|(
name|label_toks
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ti
operator|=
name|label_toks
operator|->
name|first
operator|,
name|i
operator|=
literal|0
init|;
name|ti
operator|!=
operator|(
name|ffesttTokenItem
operator|)
operator|&
name|label_toks
operator|->
name|first
condition|;
name|ti
operator|=
name|ti
operator|->
name|next
operator|,
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|ffestc_labelref_is_branch_
argument_list|(
name|ti
operator|->
name|t
argument_list|,
operator|&
name|labels
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ok
condition|)
name|ffestd_R837
argument_list|(
name|labels
argument_list|,
name|ffestt_tokenlist_count
argument_list|(
name|label_toks
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R838 -- ASSIGN statement     ffestc_R838(label_token,target_variable,target_token);     Make sure label_token identifies a valid label for an assignment.  Update    that label's info to indicate it is the source of an assignment.  Update    target_variable's info to indicate it is the target the assignment of that    label.  */
end_comment

begin_function
name|void
name|ffestc_R838
parameter_list|(
name|ffelexToken
name|label_token
parameter_list|,
name|ffebld
name|target
parameter_list|,
name|ffelexToken
name|target_token
name|UNUSED
parameter_list|)
block|{
name|ffelab
name|label
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
comment|/* Mark target symbol as target of an ASSIGN.  */
if|if
condition|(
name|ffebld_op
argument_list|(
name|target
argument_list|)
operator|==
name|FFEBLD_opSYMTER
condition|)
name|ffesymbol_set_assigned
argument_list|(
name|ffebld_symter
argument_list|(
name|target
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_labelref_is_assignable_
argument_list|(
name|label_token
argument_list|,
operator|&
name|label
argument_list|)
condition|)
name|ffestd_R838
argument_list|(
name|label
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R839 -- Assigned GOTO statement     ffestc_R839(target,target_token,label_list);     Make sure label_list identifies valid labels for a GOTO.  Update    each label's info to indicate it is the target of a GOTO.  */
end_comment

begin_function
name|void
name|ffestc_R839
parameter_list|(
name|ffebld
name|target
parameter_list|,
name|ffelexToken
name|target_token
name|UNUSED
parameter_list|,
name|ffesttTokenList
name|label_toks
parameter_list|)
block|{
name|ffesttTokenItem
name|ti
decl_stmt|;
name|bool
name|ok
init|=
name|TRUE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ffelab
modifier|*
name|labels
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|label_toks
operator|==
name|NULL
condition|)
block|{
name|labels
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|labels
operator|=
name|malloc_new_kp
argument_list|(
name|ffesta_output_pool
argument_list|,
literal|"FFESTC labels"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|labels
argument_list|)
operator|*
name|ffestt_tokenlist_count
argument_list|(
name|label_toks
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ti
operator|=
name|label_toks
operator|->
name|first
operator|,
name|i
operator|=
literal|0
init|;
name|ti
operator|!=
operator|(
name|ffesttTokenItem
operator|)
operator|&
name|label_toks
operator|->
name|first
condition|;
name|ti
operator|=
name|ti
operator|->
name|next
operator|,
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|ffestc_labelref_is_branch_
argument_list|(
name|ti
operator|->
name|t
argument_list|,
operator|&
name|labels
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|ok
condition|)
name|ffestd_R839
argument_list|(
name|target
argument_list|,
name|labels
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* notloop's that are actionif's can be the target of a loop-end      statement if they're in the "then" part of a logical IF, as      in "DO 10", "10 IF (...) GOTO I".  */
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R840 -- Arithmetic IF statement     ffestc_R840(expr,expr_token,neg,zero,pos);     Make sure the labels are valid; implement.  */
end_comment

begin_function
name|void
name|ffestc_R840
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
name|UNUSED
parameter_list|,
name|ffelexToken
name|neg_token
parameter_list|,
name|ffelexToken
name|zero_token
parameter_list|,
name|ffelexToken
name|pos_token
parameter_list|)
block|{
name|ffelab
name|neg
decl_stmt|;
name|ffelab
name|zero
decl_stmt|;
name|ffelab
name|pos
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_labelref_is_branch_
argument_list|(
name|neg_token
argument_list|,
operator|&
name|neg
argument_list|)
operator|&&
name|ffestc_labelref_is_branch_
argument_list|(
name|zero_token
argument_list|,
operator|&
name|zero
argument_list|)
operator|&&
name|ffestc_labelref_is_branch_
argument_list|(
name|pos_token
argument_list|,
operator|&
name|pos
argument_list|)
condition|)
name|ffestd_R840
argument_list|(
name|expr
argument_list|,
name|neg
argument_list|,
name|zero
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* notloop's that are actionif's can be the target of a loop-end      statement if they're in the "then" part of a logical IF, as      in "DO 10", "10 IF (...) GOTO (100,200,300), I".  */
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R841 -- CONTINUE statement     ffestc_R841();  */
end_comment

begin_function
name|void
name|ffestc_R841
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionwhere_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
if|#
directive|if
name|FFESTR_F90
case|case
name|FFESTV_stateWHERE
case|:
case|case
name|FFESTV_stateWHERETHEN
case|:
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_R841
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* It's okay that we call ffestc_labeldef_branch_end_ () below, 	 since that will be a no-op after calling _useless_ () above.  */
break|break;
endif|#
directive|endif
default|default:
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
name|ffestd_R841
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R842 -- STOP statement     ffestc_R842(expr,expr_token);     Make sure statement is valid here; implement.  expr and expr_token are    both NULL if there was no expression.  */
end_comment

begin_function
name|void
name|ffestc_R842
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
name|UNUSED
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_begin_
argument_list|()
expr_stmt|;
name|ffestd_R842
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* notloop's that are actionif's can be the target of a loop-end      statement if they're in the "then" part of a logical IF, as      in "DO 10", "10 IF (...) STOP".  */
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R843 -- PAUSE statement     ffestc_R843(expr,expr_token);     Make sure statement is valid here; implement.  expr and expr_token are    both NULL if there was no expression.  */
end_comment

begin_function
name|void
name|ffestc_R843
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
name|UNUSED
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
name|ffestd_R843
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R904 -- OPEN statement     ffestc_R904();     Make sure an OPEN is valid in the current context, and implement it.	 */
end_comment

begin_function
name|void
name|ffestc_R904
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|expect_file
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|status_strs
index|[]
init|=
block|{
literal|"New"
block|,
literal|"Old"
block|,
literal|"Replace"
block|,
literal|"Scratch"
block|,
literal|"Unknown"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|access_strs
index|[]
init|=
block|{
literal|"Append"
block|,
literal|"Direct"
block|,
literal|"Keyed"
block|,
literal|"Sequential"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|blank_strs
index|[]
init|=
block|{
literal|"Null"
block|,
literal|"Zero"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|carriagecontrol_strs
index|[]
init|=
block|{
literal|"Fortran"
block|,
literal|"List"
block|,
literal|"None"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|dispose_strs
index|[]
init|=
block|{
literal|"Delete"
block|,
literal|"Keep"
block|,
literal|"Print"
block|,
literal|"Print/Delete"
block|,
literal|"Save"
block|,
literal|"Submit"
block|,
literal|"Submit/Delete"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|form_strs
index|[]
init|=
block|{
literal|"Formatted"
block|,
literal|"Unformatted"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|organization_strs
index|[]
init|=
block|{
literal|"Indexed"
block|,
literal|"Relative"
block|,
literal|"Sequential"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|position_strs
index|[]
init|=
block|{
literal|"Append"
block|,
literal|"AsIs"
block|,
literal|"Rewind"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|action_strs
index|[]
init|=
block|{
literal|"Read"
block|,
literal|"ReadWrite"
block|,
literal|"Write"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|delim_strs
index|[]
init|=
block|{
literal|"Apostrophe"
block|,
literal|"None"
block|,
literal|"Quote"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|recordtype_strs
index|[]
init|=
block|{
literal|"Fixed"
block|,
literal|"Segmented"
block|,
literal|"Stream"
block|,
literal|"Stream_CR"
block|,
literal|"Stream_LF"
block|,
literal|"Variable"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|pad_strs
index|[]
init|=
block|{
literal|"No"
block|,
literal|"Yes"
block|}
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixERR
index|]
argument_list|)
operator|&&
name|ffestc_subr_is_present_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixUNIT
index|]
argument_list|)
condition|)
block|{
name|i
operator|=
name|ffestc_subr_binsrch_
argument_list|(
name|status_strs
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|status_strs
argument_list|)
argument_list|,
operator|&
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSTATUS
index|]
argument_list|,
literal|"NEW, OLD, REPLACE, SCRATCH, or UNKNOWN"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
comment|/* Unknown. */
case|case
literal|5
case|:
comment|/* UNKNOWN. */
name|expect_file
operator|=
literal|2
expr_stmt|;
comment|/* Unknown, don't care about FILE=. */
break|break;
case|case
literal|1
case|:
comment|/* NEW. */
case|case
literal|2
case|:
comment|/* OLD. */
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
name|expect_file
operator|=
literal|1
expr_stmt|;
comment|/* Yes, need FILE=. */
else|else
name|expect_file
operator|=
literal|2
expr_stmt|;
comment|/* f2clib doesn't care about FILE=. */
break|break;
case|case
literal|3
case|:
comment|/* REPLACE. */
name|expect_file
operator|=
literal|1
expr_stmt|;
comment|/* Yes, need FILE=. */
break|break;
case|case
literal|4
case|:
comment|/* SCRATCH. */
name|expect_file
operator|=
literal|0
expr_stmt|;
comment|/* No, disallow FILE=. */
break|break;
default|default:
name|assert
argument_list|(
literal|"invalid _binsrch_ result"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|expect_file
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|expect_file
operator|==
literal|0
operator|)
operator|&&
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixFILE
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONFLICTING_SPECS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixFILE
index|]
operator|.
name|kw_or_val_present
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixFILE
index|]
operator|.
name|kw_present
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixFILE
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixFILE
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixFILE
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixFILE
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSTATUS
index|]
operator|.
name|kw_or_val_present
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSTATUS
index|]
operator|.
name|kw_present
condition|)
block|{
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSTATUS
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSTATUS
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSTATUS
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSTATUS
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|expect_file
operator|==
literal|1
operator|)
operator|&&
operator|!
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixFILE
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_MISSING_SPECIFIER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSTATUS
index|]
operator|.
name|kw_or_val_present
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSTATUS
index|]
operator|.
name|kw_present
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSTATUS
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSTATUS
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSTATUS
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixSTATUS
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffebad_string
argument_list|(
literal|"FILE="
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_subr_binsrch_
argument_list|(
name|access_strs
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|access_strs
argument_list|)
argument_list|,
operator|&
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixACCESS
index|]
argument_list|,
literal|"APPEND, DIRECT, KEYED, or SEQUENTIAL"
argument_list|)
expr_stmt|;
name|ffestc_subr_binsrch_
argument_list|(
name|blank_strs
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|blank_strs
argument_list|)
argument_list|,
operator|&
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixBLANK
index|]
argument_list|,
literal|"NULL or ZERO"
argument_list|)
expr_stmt|;
name|ffestc_subr_binsrch_
argument_list|(
name|carriagecontrol_strs
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|carriagecontrol_strs
argument_list|)
argument_list|,
operator|&
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixCARRIAGECONTROL
index|]
argument_list|,
literal|"FORTRAN, LIST, or NONE"
argument_list|)
expr_stmt|;
name|ffestc_subr_binsrch_
argument_list|(
name|dispose_strs
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|dispose_strs
argument_list|)
argument_list|,
operator|&
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixDISPOSE
index|]
argument_list|,
literal|"DELETE, KEEP, PRINT, PRINT/DELETE, SAVE, SUBMIT, or SUBMIT/DELETE"
argument_list|)
expr_stmt|;
name|ffestc_subr_binsrch_
argument_list|(
name|form_strs
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|form_strs
argument_list|)
argument_list|,
operator|&
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixFORM
index|]
argument_list|,
literal|"FORMATTED or UNFORMATTED"
argument_list|)
expr_stmt|;
name|ffestc_subr_binsrch_
argument_list|(
name|organization_strs
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|organization_strs
argument_list|)
argument_list|,
operator|&
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixORGANIZATION
index|]
argument_list|,
literal|"INDEXED, RELATIVE, or SEQUENTIAL"
argument_list|)
expr_stmt|;
name|ffestc_subr_binsrch_
argument_list|(
name|position_strs
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|position_strs
argument_list|)
argument_list|,
operator|&
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixPOSITION
index|]
argument_list|,
literal|"APPEND, ASIS, or REWIND"
argument_list|)
expr_stmt|;
name|ffestc_subr_binsrch_
argument_list|(
name|action_strs
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|action_strs
argument_list|)
argument_list|,
operator|&
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixACTION
index|]
argument_list|,
literal|"READ, READWRITE, or WRITE"
argument_list|)
expr_stmt|;
name|ffestc_subr_binsrch_
argument_list|(
name|delim_strs
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|delim_strs
argument_list|)
argument_list|,
operator|&
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixDELIM
index|]
argument_list|,
literal|"APOSTROPHE, NONE, or QUOTE"
argument_list|)
expr_stmt|;
name|ffestc_subr_binsrch_
argument_list|(
name|recordtype_strs
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|recordtype_strs
argument_list|)
argument_list|,
operator|&
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixRECORDTYPE
index|]
argument_list|,
literal|"FIXED, SEGMENTED, STREAM, STREAM_CR, STREAM_LF, or VARIABLE"
argument_list|)
expr_stmt|;
name|ffestc_subr_binsrch_
argument_list|(
name|pad_strs
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|pad_strs
argument_list|)
argument_list|,
operator|&
name|ffestp_file
operator|.
name|open
operator|.
name|open_spec
index|[
name|FFESTP_openixPAD
index|]
argument_list|,
literal|"NO or YES"
argument_list|)
expr_stmt|;
name|ffestd_R904
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R907 -- CLOSE statement     ffestc_R907();     Make sure a CLOSE is valid in the current context, and implement it.	 */
end_comment

begin_function
name|void
name|ffestc_R907
parameter_list|()
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|status_strs
index|[]
init|=
block|{
literal|"Delete"
block|,
literal|"Keep"
block|,
literal|"Print"
block|,
literal|"Print/Delete"
block|,
literal|"Save"
block|,
literal|"Submit"
block|,
literal|"Submit/Delete"
block|}
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|FFESTP_closeixERR
index|]
argument_list|)
operator|&&
name|ffestc_subr_is_present_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|FFESTP_closeixUNIT
index|]
argument_list|)
condition|)
block|{
name|ffestc_subr_binsrch_
argument_list|(
name|status_strs
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|status_strs
argument_list|)
argument_list|,
operator|&
name|ffestp_file
operator|.
name|close
operator|.
name|close_spec
index|[
name|FFESTP_closeixSTATUS
index|]
argument_list|,
literal|"DELETE, KEEP, PRINT, PRINT/DELETE, SAVE, SUBMIT, or SUBMIT/DELETE"
argument_list|)
expr_stmt|;
name|ffestd_R907
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R909_start -- READ(...) statement list begin     ffestc_R909_start(FALSE);     Verify that READ is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_R909_start
parameter_list|(
name|bool
name|only_format
parameter_list|)
block|{
name|ffestvUnit
name|unit
decl_stmt|;
name|ffestvFormat
name|format
decl_stmt|;
name|bool
name|rec
decl_stmt|;
name|bool
name|key
decl_stmt|;
name|ffestpReadIx
name|keyn
decl_stmt|;
name|ffestpReadIx
name|spec1
decl_stmt|;
name|ffestpReadIx
name|spec2
decl_stmt|;
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_subr_is_format_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
argument_list|)
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|format
operator|=
name|ffestc_subr_format_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixFORMAT
index|]
argument_list|)
expr_stmt|;
name|ffestc_namelist_
operator|=
operator|(
name|format
operator|==
name|FFESTV_formatNAMELIST
operator|)
expr_stmt|;
if|if
condition|(
name|only_format
condition|)
block|{
name|ffestd_R909_start
argument_list|(
name|TRUE
argument_list|,
name|FFESTV_unitNONE
argument_list|,
name|format
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixEOR
index|]
argument_list|)
operator|||
operator|!
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixERR
index|]
argument_list|)
operator|||
operator|!
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixEND
index|]
argument_list|)
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|unit
operator|=
name|ffestc_subr_unit_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixUNIT
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitNONE
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_NO_UNIT_SPEC
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|rec
operator|=
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixREC
index|]
operator|.
name|kw_or_val_present
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixKEYEQ
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|key
operator|=
name|TRUE
expr_stmt|;
name|keyn
operator|=
name|spec1
operator|=
name|FFESTP_readixKEYEQ
expr_stmt|;
block|}
else|else
block|{
name|key
operator|=
name|FALSE
expr_stmt|;
name|keyn
operator|=
name|spec1
operator|=
name|FFESTP_readix
expr_stmt|;
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixKEYGT
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
if|if
condition|(
name|key
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixKEYGT
expr_stmt|;
name|whine
label|:
comment|/* :::::::::::::::::::: */
name|ffebad_start
argument_list|(
name|FFEBAD_CONFLICTING_SPECS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec1
index|]
operator|.
name|kw_or_val_present
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec1
index|]
operator|.
name|kw_present
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec1
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec1
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec2
index|]
operator|.
name|kw_or_val_present
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec2
index|]
operator|.
name|kw_present
condition|)
block|{
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec2
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec2
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec2
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec2
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|key
operator|=
name|TRUE
expr_stmt|;
name|keyn
operator|=
name|spec1
operator|=
name|FFESTP_readixKEYGT
expr_stmt|;
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixKEYGE
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
if|if
condition|(
name|key
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixKEYGT
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
name|key
operator|=
name|TRUE
expr_stmt|;
name|keyn
operator|=
name|FFESTP_readixKEYGT
expr_stmt|;
block|}
if|if
condition|(
name|rec
condition|)
block|{
name|spec1
operator|=
name|FFESTP_readixREC
expr_stmt|;
if|if
condition|(
name|key
condition|)
block|{
name|spec2
operator|=
name|keyn
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixUNIT
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
operator|(
name|format
operator|==
name|FFESTV_formatASTERISK
operator|)
operator|||
operator|(
name|format
operator|==
name|FFESTV_formatNAMELIST
operator|)
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixFORMAT
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixADVANCE
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixADVANCE
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixEND
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixEND
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixNULLS
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixNULLS
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
elseif|else
if|if
condition|(
name|key
condition|)
block|{
name|spec1
operator|=
name|keyn
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixUNIT
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
operator|(
name|format
operator|==
name|FFESTV_formatASTERISK
operator|)
operator|||
operator|(
name|format
operator|==
name|FFESTV_formatNAMELIST
operator|)
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixFORMAT
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixADVANCE
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixADVANCE
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixEND
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixEND
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixEOR
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixEOR
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixNULLS
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixNULLS
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixREC
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixREC
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixSIZE
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixSIZE
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
else|else
block|{
comment|/* Sequential/Internal. */
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
block|{
comment|/* Internal file. */
name|spec1
operator|=
name|FFESTP_readixUNIT
expr_stmt|;
if|if
condition|(
name|format
operator|==
name|FFESTV_formatNAMELIST
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixFORMAT
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixADVANCE
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixADVANCE
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixADVANCE
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
comment|/* ADVANCE= specified. */
name|spec1
operator|=
name|FFESTP_readixADVANCE
expr_stmt|;
if|if
condition|(
name|format
operator|==
name|FFESTV_formatNONE
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_MISSING_FORMAT_SPEC
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|format
operator|==
name|FFESTV_formatNAMELIST
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixFORMAT
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixEOR
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
comment|/* EOR= specified. */
name|spec1
operator|=
name|FFESTP_readixEOR
expr_stmt|;
if|if
condition|(
name|ffestc_subr_speccmp_
argument_list|(
literal|"No"
argument_list|,
operator|&
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixADVANCE
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|whine_advance
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixNULLS
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
comment|/* NULLS= specified. */
name|spec1
operator|=
name|FFESTP_readixNULLS
expr_stmt|;
if|if
condition|(
name|format
operator|!=
name|FFESTV_formatASTERISK
condition|)
block|{
name|spec2
operator|=
name|FFESTP_readixFORMAT
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixSIZE
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
comment|/* SIZE= specified. */
name|spec1
operator|=
name|FFESTP_readixSIZE
expr_stmt|;
if|if
condition|(
name|ffestc_subr_speccmp_
argument_list|(
literal|"No"
argument_list|,
operator|&
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixADVANCE
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|whine_advance
label|:
comment|/* :::::::::::::::::::: */
if|if
condition|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixADVANCE
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONFLICTING_SPECS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixADVANCE
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|FFESTP_readixADVANCE
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_MISSING_ADVANCE_SPEC
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|read
operator|.
name|read_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
name|ffestc_iolist_context_
operator|=
name|FFEEXPR_contextIOLISTDF
expr_stmt|;
else|else
name|ffestc_iolist_context_
operator|=
name|FFEEXPR_contextIOLIST
expr_stmt|;
name|ffestd_R909_start
argument_list|(
name|FALSE
argument_list|,
name|unit
argument_list|,
name|format
argument_list|,
name|rec
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R909_item -- READ statement i/o item     ffestc_R909_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestc_R909_item
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|if
condition|(
name|ffestc_namelist_
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ffestc_namelist_
operator|==
literal|1
condition|)
block|{
name|ffestc_namelist_
operator|=
literal|2
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_NAMELIST_ITEMS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|expr_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|expr_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
name|ffestd_R909_item
argument_list|(
name|expr
argument_list|,
name|expr_token
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R909_finish -- READ statement list complete     ffestc_R909_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R909_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R909_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R910_start -- WRITE(...) statement list begin     ffestc_R910_start();     Verify that WRITE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_R910_start
parameter_list|()
block|{
name|ffestvUnit
name|unit
decl_stmt|;
name|ffestvFormat
name|format
decl_stmt|;
name|bool
name|rec
decl_stmt|;
name|ffestpWriteIx
name|spec1
decl_stmt|;
name|ffestpWriteIx
name|spec2
decl_stmt|;
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixEOR
index|]
argument_list|)
operator|||
operator|!
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixERR
index|]
argument_list|)
operator|||
operator|!
name|ffestc_subr_is_format_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixFORMAT
index|]
argument_list|)
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|format
operator|=
name|ffestc_subr_format_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixFORMAT
index|]
argument_list|)
expr_stmt|;
name|ffestc_namelist_
operator|=
operator|(
name|format
operator|==
name|FFESTV_formatNAMELIST
operator|)
expr_stmt|;
name|unit
operator|=
name|ffestc_subr_unit_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixUNIT
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitNONE
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_NO_UNIT_SPEC
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|rec
operator|=
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixREC
index|]
operator|.
name|kw_or_val_present
expr_stmt|;
if|if
condition|(
name|rec
condition|)
block|{
name|spec1
operator|=
name|FFESTP_writeixREC
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
block|{
name|spec2
operator|=
name|FFESTP_writeixUNIT
expr_stmt|;
name|whine
label|:
comment|/* :::::::::::::::::::: */
name|ffebad_start
argument_list|(
name|FFEBAD_CONFLICTING_SPECS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec1
index|]
operator|.
name|kw_or_val_present
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec1
index|]
operator|.
name|kw_present
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec1
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec1
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec2
index|]
operator|.
name|kw_or_val_present
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec2
index|]
operator|.
name|kw_present
condition|)
block|{
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec2
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec2
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec2
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec2
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|format
operator|==
name|FFESTV_formatASTERISK
operator|)
operator|||
operator|(
name|format
operator|==
name|FFESTV_formatNAMELIST
operator|)
condition|)
block|{
name|spec2
operator|=
name|FFESTP_writeixFORMAT
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixADVANCE
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|spec2
operator|=
name|FFESTP_writeixADVANCE
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
else|else
block|{
comment|/* Sequential/Indexed/Internal. */
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
block|{
comment|/* Internal file. */
name|spec1
operator|=
name|FFESTP_writeixUNIT
expr_stmt|;
if|if
condition|(
name|format
operator|==
name|FFESTV_formatNAMELIST
condition|)
block|{
name|spec2
operator|=
name|FFESTP_writeixFORMAT
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixADVANCE
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|spec2
operator|=
name|FFESTP_writeixADVANCE
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixADVANCE
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
comment|/* ADVANCE= specified. */
name|spec1
operator|=
name|FFESTP_writeixADVANCE
expr_stmt|;
if|if
condition|(
name|format
operator|==
name|FFESTV_formatNONE
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_MISSING_FORMAT_SPEC
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|format
operator|==
name|FFESTV_formatNAMELIST
condition|)
block|{
name|spec2
operator|=
name|FFESTP_writeixFORMAT
expr_stmt|;
goto|goto
name|whine
goto|;
comment|/* :::::::::::::::::::: */
block|}
block|}
if|if
condition|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixEOR
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
comment|/* EOR= specified. */
name|spec1
operator|=
name|FFESTP_writeixEOR
expr_stmt|;
if|if
condition|(
name|ffestc_subr_speccmp_
argument_list|(
literal|"No"
argument_list|,
operator|&
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixADVANCE
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixADVANCE
index|]
operator|.
name|kw_or_val_present
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONFLICTING_SPECS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixADVANCE
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|FFESTP_writeixADVANCE
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_MISSING_ADVANCE_SPEC
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|write
operator|.
name|write_spec
index|[
name|spec1
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|unit
operator|==
name|FFESTV_unitCHAREXPR
condition|)
name|ffestc_iolist_context_
operator|=
name|FFEEXPR_contextIOLISTDF
expr_stmt|;
else|else
name|ffestc_iolist_context_
operator|=
name|FFEEXPR_contextIOLIST
expr_stmt|;
name|ffestd_R910_start
argument_list|(
name|unit
argument_list|,
name|format
argument_list|,
name|rec
argument_list|)
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R910_item -- WRITE statement i/o item     ffestc_R910_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestc_R910_item
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|if
condition|(
name|ffestc_namelist_
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ffestc_namelist_
operator|==
literal|1
condition|)
block|{
name|ffestc_namelist_
operator|=
literal|2
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_NAMELIST_ITEMS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|expr_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|expr_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
name|ffestd_R910_item
argument_list|(
name|expr
argument_list|,
name|expr_token
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R910_finish -- WRITE statement list complete     ffestc_R910_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R910_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R910_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R911_start -- PRINT(...) statement list begin     ffestc_R911_start();     Verify that PRINT is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_R911_start
parameter_list|()
block|{
name|ffestvFormat
name|format
decl_stmt|;
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_subr_is_format_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|print
operator|.
name|print_spec
index|[
name|FFESTP_printixFORMAT
index|]
argument_list|)
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|format
operator|=
name|ffestc_subr_format_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|print
operator|.
name|print_spec
index|[
name|FFESTP_printixFORMAT
index|]
argument_list|)
expr_stmt|;
name|ffestc_namelist_
operator|=
operator|(
name|format
operator|==
name|FFESTV_formatNAMELIST
operator|)
expr_stmt|;
name|ffestd_R911_start
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R911_item -- PRINT statement i/o item     ffestc_R911_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestc_R911_item
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|if
condition|(
name|ffestc_namelist_
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ffestc_namelist_
operator|==
literal|1
condition|)
block|{
name|ffestc_namelist_
operator|=
literal|2
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_NAMELIST_ITEMS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|expr_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|expr_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
name|ffestd_R911_item
argument_list|(
name|expr
argument_list|,
name|expr_token
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R911_finish -- PRINT statement list complete     ffestc_R911_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R911_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R911_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R919 -- BACKSPACE statement     ffestc_R919();     Make sure a BACKSPACE is valid in the current context, and implement it.  */
end_comment

begin_function
name|void
name|ffestc_R919
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixERR
index|]
argument_list|)
operator|&&
name|ffestc_subr_is_present_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
argument_list|)
condition|)
name|ffestd_R919
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R920 -- ENDFILE statement     ffestc_R920();     Make sure a ENDFILE is valid in the current context, and implement it.  */
end_comment

begin_function
name|void
name|ffestc_R920
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixERR
index|]
argument_list|)
operator|&&
name|ffestc_subr_is_present_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
argument_list|)
condition|)
name|ffestd_R920
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R921 -- REWIND statement     ffestc_R921();     Make sure a REWIND is valid in the current context, and implement it.  */
end_comment

begin_function
name|void
name|ffestc_R921
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixERR
index|]
argument_list|)
operator|&&
name|ffestc_subr_is_present_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
argument_list|)
condition|)
name|ffestd_R921
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R923A -- INQUIRE statement (non-IOLENGTH version)     ffestc_R923A();     Make sure an INQUIRE is valid in the current context, and implement it.  */
end_comment

begin_function
name|void
name|ffestc_R923A
parameter_list|()
block|{
name|bool
name|by_file
decl_stmt|;
name|bool
name|by_unit
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixERR
index|]
argument_list|)
condition|)
block|{
name|by_file
operator|=
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixFILE
index|]
operator|.
name|kw_or_val_present
expr_stmt|;
name|by_unit
operator|=
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixUNIT
index|]
operator|.
name|kw_or_val_present
expr_stmt|;
if|if
condition|(
name|by_file
operator|&&
name|by_unit
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_CONFLICTING_SPECS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixUNIT
index|]
operator|.
name|kw_or_val_present
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixUNIT
index|]
operator|.
name|kw_present
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixUNIT
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixUNIT
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixUNIT
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixUNIT
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixFILE
index|]
operator|.
name|kw_or_val_present
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixFILE
index|]
operator|.
name|kw_present
condition|)
block|{
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixFILE
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixFILE
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixFILE
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|inquire
operator|.
name|inquire_spec
index|[
name|FFESTP_inquireixFILE
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|by_file
operator|&&
operator|!
name|by_unit
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_MISSING_SPECIFIER
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_string
argument_list|(
literal|"UNIT= or FILE="
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
else|else
name|ffestd_R923A
argument_list|(
name|by_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R923B_start -- INQUIRE(IOLENGTH=expr) statement list begin     ffestc_R923B_start();     Verify that INQUIRE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_R923B_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
name|ffestd_R923B_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R923B_item -- INQUIRE statement i/o item     ffestc_R923B_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestc_R923B_item
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
name|UNUSED
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R923B_item
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R923B_finish -- INQUIRE statement list complete     ffestc_R923B_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R923B_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R923B_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1001 -- FORMAT statement     ffestc_R1001(format_list);     Make sure format_list is valid.  Update label's info to indicate it is a    FORMAT label, and (perhaps) warn if there is no label!  */
end_comment

begin_function
name|void
name|ffestc_R1001
parameter_list|(
name|ffesttFormatList
name|f
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_format_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_format_
argument_list|()
expr_stmt|;
name|ffestd_R1001
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1102 -- PROGRAM statement     ffestc_R1102(name_token);     Make sure ffestc_kind_ identifies an empty block.  Make sure name_token    gives a valid name.	Implement the beginning of a main program.  */
end_comment

begin_function
name|void
name|ffestc_R1102
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_unit_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestc_blocknum_
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_statePROGRAM0
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
name|ffestc_blocknum_
operator|++
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_end_program_
argument_list|)
expr_stmt|;
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|ffelex_token_use
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_programunit
argument_list|(
name|name
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
block|{
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindPROGRAM
argument_list|,
name|FFEINFO_whereLOCAL
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ffestd_R1102
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1103 -- END PROGRAM statement     ffestc_R1103(name_token);     Make sure ffestc_kind_ identifies the current kind of program unit.	If not    NULL, make sure name_token gives the correct name.  Implement the end    of the current program unit.	 */
end_comment

begin_function
name|void
name|ffestc_R1103
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_program_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_PROGRAM_NOT_NAMED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffelex_token_strcmp
argument_list|(
name|name
argument_list|,
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_UNIT_WRONG_NAME
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|ffestc_shriek_end_program_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1105 -- MODULE statement     ffestc_R1105(name_token);     Make sure ffestc_kind_ identifies an empty block.  Make sure name_token    gives a valid name.	Implement the beginning of a module.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestc_R1105
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_unit_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestc_blocknum_
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateMODULE0
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
name|ffestc_blocknum_
operator|++
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_module_
argument_list|)
expr_stmt|;
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|ffelex_token_use
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffestd_R1105
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1106 -- END MODULE statement     ffestc_R1106(name_token);     Make sure ffestc_kind_ identifies the current kind of program unit.	If not    NULL, make sure name_token gives the correct name.  Implement the end    of the current program unit.	 */
end_comment

begin_function
name|void
name|ffestc_R1106
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_module_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffelex_token_strcmp
argument_list|(
name|name
argument_list|,
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_UNIT_WRONG_NAME
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_shriek_module_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1107_start -- USE statement list begin     ffestc_R1107_start();     Verify that USE is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestc_R1107_start
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|bool
name|only
parameter_list|)
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_use_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_R1107_start
argument_list|(
name|name
argument_list|,
name|only
argument_list|)
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1107_item -- USE statement for name     ffestc_R1107_item(local_token,use_token);     Make sure name_token identifies a valid object to be USEed.	local_token    may be NULL if _start_ was called with only==TRUE.  */
end_comment

begin_function
name|void
name|ffestc_R1107_item
parameter_list|(
name|ffelexToken
name|local
parameter_list|,
name|ffelexToken
name|use
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|use
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R1107_item
argument_list|(
name|local
argument_list|,
name|use
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1107_finish -- USE statement list complete     ffestc_R1107_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R1107_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R1107_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_R1111 -- BLOCK DATA statement     ffestc_R1111(name_token);     Make sure ffestc_kind_ identifies no current program unit.  If not    NULL, make sure name_token gives a valid name.  Implement the beginning    of a block data program unit.  */
end_comment

begin_function
name|void
name|ffestc_R1111
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_unit_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestc_blocknum_
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateBLOCKDATA0
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
name|ffestc_blocknum_
operator|++
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_blockdata_
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|ffelex_token_use
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_blockdataunit
argument_list|(
name|name
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
block|{
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindBLOCKDATA
argument_list|,
name|FFEINFO_whereLOCAL
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ffestd_R1111
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1112 -- END BLOCK DATA statement     ffestc_R1112(name_token);     Make sure ffestc_kind_ identifies the current kind of program unit.	If not    NULL, make sure name_token gives the correct name.  Implement the end    of the current program unit.	 */
end_comment

begin_function
name|void
name|ffestc_R1112
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_blockdata_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_BLOCKDATA_NOT_NAMED
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffelex_token_strcmp
argument_list|(
name|name
argument_list|,
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_UNIT_WRONG_NAME
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
block|}
name|ffestc_shriek_blockdata_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1202 -- INTERFACE statement     ffestc_R1202(operator,defined_name);     Make sure ffestc_kind_ identifies an INTERFACE block.    Implement the end of the current interface.     15-May-90  JCB  1.1       Allow no operator or name to mean INTERFACE by itself; missed this       valid form when originally doing syntactic analysis code.	 */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestc_R1202
parameter_list|(
name|ffestpDefinedOperator
name|operator
parameter_list|,
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_interfacespec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateINTERFACE0
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_interface_
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|operator
operator|==
name|FFESTP_definedoperatorNone
operator|)
operator|&&
operator|(
name|name
operator|==
name|NULL
operator|)
condition|)
name|ffestw_set_substate
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* No generic-spec, so disallow MODULE 				   PROCEDURE. */
else|else
name|ffestw_set_substate
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* MODULE PROCEDURE ok. */
name|ffestd_R1202
argument_list|(
name|operator
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ffe_init_4
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1203 -- END INTERFACE statement     ffestc_R1203();     Make sure ffestc_kind_ identifies an INTERFACE block.    Implement the end of the current interface.	*/
end_comment

begin_function
name|void
name|ffestc_R1203
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_interface_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestc_shriek_interface_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffe_terminate_4
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1205_start -- MODULE PROCEDURE statement list begin     ffestc_R1205_start();     Verify that MODULE PROCEDURE is valid here, and begin accepting items in    the list.  */
end_comment

begin_function
name|void
name|ffestc_R1205_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_interface_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestw_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_INVALID_MODULE_PROCEDURE
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|FFESTV_stateINTERFACE0
condition|)
block|{
name|ffestw_update
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Update state line/col info. */
name|ffestw_set_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
name|FFESTV_stateINTERFACE1
argument_list|)
expr_stmt|;
block|}
name|ffestd_R1205_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1205_item -- MODULE PROCEDURE statement for name     ffestc_R1205_item(name_token);     Make sure name_token identifies a valid object to be MODULE PROCEDUREed.  */
end_comment

begin_function
name|void
name|ffestc_R1205_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R1205_item
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1205_finish -- MODULE PROCEDURE statement list complete     ffestc_R1205_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R1205_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R1205_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_R1207_start -- EXTERNAL statement list begin     ffestc_R1207_start();     Verify that EXTERNAL is valid here, and begin accepting items in the list.  */
end_comment

begin_function
name|void
name|ffestc_R1207_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_progspec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_R1207_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1207_item -- EXTERNAL statement for name     ffestc_R1207_item(name_token);     Make sure name_token identifies a valid object to be EXTERNALd.  */
end_comment

begin_function
name|void
name|ffestc_R1207_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
operator|!
name|ffesymbol_is_specable
argument_list|(
name|s
argument_list|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Can't dcl sym ref'd in sfuncdef. */
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|na
operator|=
name|FFESYMBOL_attrsANY
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsDUMMY
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
condition|)
name|na
operator|=
name|sa
operator||
name|FFESYMBOL_attrsEXTERNAL
expr_stmt|;
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
name|ffesymbol_set_explicitwhere
argument_list|(
name|s
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|ffestd_R1207_item
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1207_finish -- EXTERNAL statement list complete     ffestc_R1207_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R1207_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R1207_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1208_start -- INTRINSIC statement list begin     ffestc_R1208_start();     Verify that INTRINSIC is valid here, and begin accepting items in the list.	*/
end_comment

begin_function
name|void
name|ffestc_R1208_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_progspec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_R1208_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1208_item -- INTRINSIC statement for name     ffestc_R1208_item(name_token);     Make sure name_token identifies a valid object to be INTRINSICd.  */
end_comment

begin_function
name|void
name|ffestc_R1208_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffeintrinGen
name|gen
decl_stmt|;
name|ffeintrinSpec
name|spec
decl_stmt|;
name|ffeintrinImp
name|imp
decl_stmt|;
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|name
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
operator|!
name|ffesymbol_is_specable
argument_list|(
name|s
argument_list|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Can't dcl sym ref'd in sfuncdef. */
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|na
operator|=
name|sa
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
operator|~
name|FFESYMBOL_attrsTYPE
operator|)
condition|)
block|{
if|if
condition|(
name|ffeintrin_is_intrinsic
argument_list|(
name|ffelex_token_text
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
operator|&
name|gen
argument_list|,
operator|&
name|spec
argument_list|,
operator|&
name|imp
argument_list|)
operator|&&
operator|(
operator|(
name|imp
operator|==
name|FFEINTRIN_impNONE
operator|)
if|#
directive|if
literal|0
comment|/* Don't bother with this for now. */
expr||| ((ffeintrin_basictype (spec) 		   == ffesymbol_basictype (s))&& (ffeintrin_kindtype (spec) 		      == ffesymbol_kindtype (s)))
else|#
directive|else
operator|||
literal|1
endif|#
directive|endif
operator|||
operator|!
operator|(
name|sa
operator|&
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
condition|)
name|na
operator|=
name|sa
operator||
name|FFESYMBOL_attrsINTRINSIC
expr_stmt|;
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
block|}
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
block|{
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_set_generic
argument_list|(
name|s
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|ffesymbol_set_specific
argument_list|(
name|s
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|ffesymbol_set_implementation
argument_list|(
name|s
argument_list|,
name|imp
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindNONE
argument_list|,
name|FFEINFO_whereINTRINSIC
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_set_explicitwhere
argument_list|(
name|s
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ffesymbol_reference
argument_list|(
name|s
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffestd_R1208_item
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1208_finish -- INTRINSIC statement list complete     ffestc_R1208_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_R1208_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_R1208_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1212 -- CALL statement     ffestc_R1212(expr,expr_token);     Make sure statement is valid here; implement.  */
end_comment

begin_function
name|void
name|ffestc_R1212
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
name|UNUSED
parameter_list|)
block|{
name|ffebld
name|item
decl_stmt|;
comment|/* ITEM. */
name|ffebld
name|labexpr
decl_stmt|;
comment|/* LABTOK=>LABTER. */
name|ffelab
name|label
decl_stmt|;
name|bool
name|ok
decl_stmt|;
comment|/* TRUE if all LABTOKs were ok. */
name|bool
name|ok1
decl_stmt|;
comment|/* TRUE if a particular LABTOK is ok. */
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffebld_op
argument_list|(
name|expr
argument_list|)
operator|!=
name|FFEBLD_opSUBRREF
condition|)
name|ffestd_R841
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* CONTINUE. */
else|else
block|{
name|ok
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|item
operator|=
name|ffebld_right
argument_list|(
name|expr
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|ffebld_trail
argument_list|(
name|item
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|labexpr
operator|=
name|ffebld_head
argument_list|(
name|item
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffebld_op
argument_list|(
name|labexpr
argument_list|)
operator|==
name|FFEBLD_opLABTOK
operator|)
condition|)
block|{
name|ok1
operator|=
name|ffestc_labelref_is_branch_
argument_list|(
name|ffebld_labtok
argument_list|(
name|labexpr
argument_list|)
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
name|ffelex_token_kill
argument_list|(
name|ffebld_labtok
argument_list|(
name|labexpr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok1
condition|)
block|{
name|label
operator|=
name|NULL
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
name|ffebld_set_op
argument_list|(
name|labexpr
argument_list|,
name|FFEBLD_opLABTER
argument_list|)
expr_stmt|;
name|ffebld_set_labter
argument_list|(
name|labexpr
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ok
condition|)
name|ffestd_R1212
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1213 -- Defined assignment statement     ffestc_R1213(dest_expr,source_expr,source_token);     Make sure the assignment is valid.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestc_R1213
parameter_list|(
name|ffebld
name|dest
parameter_list|,
name|ffebld
name|source
parameter_list|,
name|ffelexToken
name|source_token
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
name|ffestd_R1213
argument_list|(
name|dest
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_R1219 -- FUNCTION statement     ffestc_R1219(funcname,arglist,ending_token,kind,kindt,len,lent, 	 recursive);     Make sure statement is valid here, register arguments for the    function name, and so on.     06-Apr-90  JCB  2.0       Added the kind, len, and recursive arguments.  */
end_comment

begin_function
name|void
name|ffestc_R1219
parameter_list|(
name|ffelexToken
name|funcname
parameter_list|,
name|ffesttTokenList
name|args
parameter_list|,
name|ffelexToken
name|final
name|UNUSED
parameter_list|,
name|ffestpType
name|type
parameter_list|,
name|ffebld
name|kind
parameter_list|,
name|ffelexToken
name|kindt
parameter_list|,
name|ffebld
name|len
parameter_list|,
name|ffelexToken
name|lent
parameter_list|,
name|ffelexToken
name|recursive
parameter_list|,
name|ffelexToken
name|result
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbol
name|fs
decl_stmt|;
comment|/* FUNCTION symbol when dealing with RESULT 				   symbol. */
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffelexToken
name|res
decl_stmt|;
name|bool
name|separate_result
decl_stmt|;
name|assert
argument_list|(
operator|(
name|funcname
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|funcname
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
argument_list|)
expr_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_iface_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestc_blocknum_
operator|=
literal|0
expr_stmt|;
name|ffesta_is_entry_valid
operator|=
operator|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|FFESTV_stateNIL
operator|)
expr_stmt|;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateFUNCTION0
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
name|ffestc_blocknum_
operator|++
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_function_
argument_list|)
expr_stmt|;
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|ffelex_token_use
argument_list|(
name|funcname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|FFESTP_typeNone
condition|)
block|{
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
operator|=
name|FFEINFO_basictypeNONE
expr_stmt|;
name|ffestc_local_
operator|.
name|decl
operator|.
name|kind_type
operator|=
name|FFEINFO_kindtypeNONE
expr_stmt|;
name|ffestc_local_
operator|.
name|decl
operator|.
name|size
operator|=
name|FFETARGET_charactersizeNONE
expr_stmt|;
block|}
else|else
block|{
name|ffestc_establish_declstmt_
argument_list|(
name|type
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|,
name|kind
argument_list|,
name|kindt
argument_list|,
name|len
argument_list|,
name|lent
argument_list|)
expr_stmt|;
name|ffestc_establish_declinfo_
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|separate_result
operator|=
operator|(
name|result
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffelex_token_strcmp
argument_list|(
name|funcname
argument_list|,
name|result
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|separate_result
condition|)
name|fs
operator|=
name|ffesymbol_declare_funcnotresunit
argument_list|(
name|funcname
argument_list|)
expr_stmt|;
comment|/* Global/local. */
else|else
name|fs
operator|=
name|ffesymbol_declare_funcunit
argument_list|(
name|funcname
argument_list|)
expr_stmt|;
comment|/* Global only. */
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|fs
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
block|{
name|ffesymbol_set_state
argument_list|(
name|fs
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* Note that .basic_type and .kind_type might be NONE here. */
name|ffesymbol_set_info
argument_list|(
name|fs
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|kind_type
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindFUNCTION
argument_list|,
name|FFEINFO_whereLOCAL
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check whether the type info fits the filewide expectations; 	 set ok flag accordingly.  */
name|ffesymbol_reference
argument_list|(
name|fs
argument_list|,
name|funcname
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_attrs
argument_list|(
name|fs
argument_list|)
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|ffestc_parent_ok_
operator|=
name|FALSE
expr_stmt|;
else|else
name|ffestc_parent_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ffesymbol_kind
argument_list|(
name|fs
argument_list|)
operator|!=
name|FFEINFO_kindANY
condition|)
name|ffesymbol_error
argument_list|(
name|fs
argument_list|,
name|funcname
argument_list|)
expr_stmt|;
name|ffestc_parent_ok_
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|ffestc_parent_ok_
condition|)
block|{
name|ffebld_init_list
argument_list|(
operator|&
name|fs
operator|->
name|dummy_args
argument_list|,
operator|&
name|ffestc_local_
operator|.
name|dummy
operator|.
name|list_bottom
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_drive
argument_list|(
name|args
argument_list|,
name|ffestc_promote_dummy_
argument_list|)
expr_stmt|;
name|ffebld_end_list
argument_list|(
operator|&
name|ffestc_local_
operator|.
name|dummy
operator|.
name|list_bottom
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|res
operator|=
name|funcname
expr_stmt|;
else|else
name|res
operator|=
name|result
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_funcresult
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|na
operator|=
name|FFESYMBOL_attrsANY
expr_stmt|;
elseif|else
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|!=
name|FFESYMBOL_stateNONE
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
else|else
block|{
name|na
operator|=
name|FFESYMBOL_attrsRESULT
expr_stmt|;
if|if
condition|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
operator|!=
name|FFEINFO_basictypeNONE
condition|)
block|{
name|na
operator||=
name|FFESYMBOL_attrsTYPE
expr_stmt|;
if|if
condition|(
operator|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
operator|&&
operator|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|size
operator|==
name|FFETARGET_charactersizeNONE
operator|)
condition|)
name|na
operator||=
name|FFESYMBOL_attrsANYLEN
expr_stmt|;
block|}
block|}
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
operator|(
name|na
operator|&
operator|~
name|FFESYMBOL_attrsANY
operator|)
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|na
operator|&
name|FFESYMBOL_attrsANY
operator|)
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ffesymbol_set_funcresult
argument_list|(
name|fs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffesymbol_set_funcresult
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestc_parent_ok_
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
name|ffesymbol_set_funcresult
argument_list|(
name|fs
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_set_funcresult
argument_list|(
name|s
argument_list|,
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
operator|!=
name|FFEINFO_basictypeNONE
condition|)
block|{
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffestc_local_
operator|.
name|decl
operator|.
name|basic_type
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|kind_type
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindNONE
argument_list|,
name|FFEINFO_whereNONE
argument_list|,
name|ffestc_local_
operator|.
name|decl
operator|.
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ffesymbol_signal_unreported
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|ffestd_R1219
argument_list|(
name|fs
argument_list|,
name|funcname
argument_list|,
name|args
argument_list|,
name|type
argument_list|,
name|kind
argument_list|,
name|kindt
argument_list|,
name|len
argument_list|,
name|lent
argument_list|,
operator|(
name|recursive
operator|!=
name|NULL
operator|)
argument_list|,
name|result
argument_list|,
name|separate_result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1221 -- END FUNCTION statement     ffestc_R1221(name_token);     Make sure ffestc_kind_ identifies the current kind of program unit.	If    not NULL, make sure name_token gives the correct name.  Implement the end    of the current program unit.	 */
end_comment

begin_function
name|void
name|ffestc_R1221
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_function_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffelex_token_strcmp
argument_list|(
name|name
argument_list|,
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_UNIT_WRONG_NAME
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_shriek_function_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1223 -- SUBROUTINE statement     ffestc_R1223(subrname,arglist,ending_token,recursive_token);     Make sure statement is valid here, register arguments for the    subroutine name, and so on.     06-Apr-90  JCB  2.0       Added the recursive argument.  */
end_comment

begin_function
name|void
name|ffestc_R1223
parameter_list|(
name|ffelexToken
name|subrname
parameter_list|,
name|ffesttTokenList
name|args
parameter_list|,
name|ffelexToken
name|final
parameter_list|,
name|ffelexToken
name|recursive
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffesymbol
name|s
decl_stmt|;
name|assert
argument_list|(
operator|(
name|subrname
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|subrname
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
argument_list|)
expr_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_iface_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestc_blocknum_
operator|=
literal|0
expr_stmt|;
name|ffesta_is_entry_valid
operator|=
operator|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|==
name|FFESTV_stateNIL
operator|)
expr_stmt|;
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateSUBROUTINE0
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
name|ffestc_blocknum_
operator|++
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_subroutine_
argument_list|)
expr_stmt|;
name|ffestw_set_name
argument_list|(
name|b
argument_list|,
name|ffelex_token_use
argument_list|(
name|subrname
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_subrunit
argument_list|(
name|subrname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
block|{
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindSUBROUTINE
argument_list|,
name|FFEINFO_whereLOCAL
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
name|ffestc_parent_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ffesymbol_kind
argument_list|(
name|s
argument_list|)
operator|!=
name|FFEINFO_kindANY
condition|)
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|subrname
argument_list|)
expr_stmt|;
name|ffestc_parent_ok_
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|ffestc_parent_ok_
condition|)
block|{
name|ffebld_init_list
argument_list|(
operator|&
name|s
operator|->
name|dummy_args
argument_list|,
operator|&
name|ffestc_local_
operator|.
name|dummy
operator|.
name|list_bottom
argument_list|)
expr_stmt|;
name|ffestt_tokenlist_drive
argument_list|(
name|args
argument_list|,
name|ffestc_promote_dummy_
argument_list|)
expr_stmt|;
name|ffebld_end_list
argument_list|(
operator|&
name|ffestc_local_
operator|.
name|dummy
operator|.
name|list_bottom
argument_list|)
expr_stmt|;
block|}
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffestd_R1223
argument_list|(
name|s
argument_list|,
name|subrname
argument_list|,
name|args
argument_list|,
name|final
argument_list|,
operator|(
name|recursive
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1225 -- END SUBROUTINE statement     ffestc_R1225(name_token);     Make sure ffestc_kind_ identifies the current kind of program unit.	If    not NULL, make sure name_token gives the correct name.  Implement the end    of the current program unit.	 */
end_comment

begin_function
name|void
name|ffestc_R1225
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_subroutine_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffelex_token_strcmp
argument_list|(
name|name
argument_list|,
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_UNIT_WRONG_NAME
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestw_name
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_shriek_subroutine_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1226 -- ENTRY statement     ffestc_R1226(entryname,arglist,ending_token);     Make sure we're in a SUBROUTINE or FUNCTION, register arguments for the    entry point name, and so on.	 */
end_comment

begin_function
name|void
name|ffestc_R1226
parameter_list|(
name|ffelexToken
name|entryname
parameter_list|,
name|ffesttTokenList
name|args
parameter_list|,
name|ffelexToken
name|final
name|UNUSED
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbol
name|fs
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|bool
name|in_spec
decl_stmt|;
comment|/* TRUE if further specification statements 				   may follow, FALSE if executable stmts. */
name|bool
name|in_func
decl_stmt|;
comment|/* TRUE if ENTRY is a FUNCTION, not 				   SUBROUTINE. */
name|assert
argument_list|(
operator|(
name|entryname
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ffelex_token_type
argument_list|(
name|entryname
argument_list|)
operator|==
name|FFELEX_typeNAME
operator|)
argument_list|)
expr_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_entry_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateFUNCTION1
case|:
case|case
name|FFESTV_stateFUNCTION2
case|:
case|case
name|FFESTV_stateFUNCTION3
case|:
name|in_func
operator|=
name|TRUE
expr_stmt|;
name|in_spec
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateFUNCTION4
case|:
name|in_func
operator|=
name|TRUE
expr_stmt|;
name|in_spec
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSUBROUTINE1
case|:
case|case
name|FFESTV_stateSUBROUTINE2
case|:
case|case
name|FFESTV_stateSUBROUTINE3
case|:
name|in_func
operator|=
name|FALSE
expr_stmt|;
name|in_spec
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FFESTV_stateSUBROUTINE4
case|:
name|in_func
operator|=
name|FALSE
expr_stmt|;
name|in_spec
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|"ENTRY not in FUNCTION or SUBROUTINE?"
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|in_func
operator|=
name|FALSE
expr_stmt|;
name|in_spec
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|in_func
condition|)
name|fs
operator|=
name|ffesymbol_declare_funcunit
argument_list|(
name|entryname
argument_list|)
expr_stmt|;
else|else
name|fs
operator|=
name|ffesymbol_declare_subrunit
argument_list|(
name|entryname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|fs
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
name|ffesymbol_set_state
argument_list|(
name|fs
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ffesymbol_kind
argument_list|(
name|fs
argument_list|)
operator|!=
name|FFEINFO_kindANY
condition|)
name|ffesymbol_error
argument_list|(
name|fs
argument_list|,
name|entryname
argument_list|)
expr_stmt|;
block|}
operator|++
name|ffestc_entry_num_
expr_stmt|;
name|ffebld_init_list
argument_list|(
operator|&
name|fs
operator|->
name|dummy_args
argument_list|,
operator|&
name|ffestc_local_
operator|.
name|dummy
operator|.
name|list_bottom
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_spec
condition|)
name|ffestt_tokenlist_drive
argument_list|(
name|args
argument_list|,
name|ffestc_promote_dummy_
argument_list|)
expr_stmt|;
else|else
name|ffestt_tokenlist_drive
argument_list|(
name|args
argument_list|,
name|ffestc_promote_execdummy_
argument_list|)
expr_stmt|;
name|ffebld_end_list
argument_list|(
operator|&
name|ffestc_local_
operator|.
name|dummy
operator|.
name|list_bottom
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_func
condition|)
block|{
name|s
operator|=
name|ffesymbol_declare_funcresult
argument_list|(
name|entryname
argument_list|)
expr_stmt|;
name|ffesymbol_set_funcresult
argument_list|(
name|fs
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ffesymbol_set_funcresult
argument_list|(
name|s
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous 	 declarations of or references to the object. */
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNDERSTOOD
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|na
operator|=
name|FFESYMBOL_attrsANY
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
operator|~
operator|(
name|FFESYMBOL_attrsANYLEN
operator||
name|FFESYMBOL_attrsTYPE
operator|)
operator|)
condition|)
name|na
operator|=
name|sa
operator||
name|FFESYMBOL_attrsRESULT
expr_stmt|;
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error 	 cropped up; ANY means an old error to be ignored; otherwise, 	 everything's ok, update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|entryname
argument_list|)
expr_stmt|;
name|ffestc_parent_ok_
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|na
operator|&
name|FFESYMBOL_attrsANY
condition|)
block|{
name|ffestc_parent_ok_
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateNONE
condition|)
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ffesymbol_state
argument_list|(
name|s
argument_list|)
operator|==
name|FFESYMBOL_stateUNCERTAIN
condition|)
block|{
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateUNDERSTOOD
argument_list|)
expr_stmt|;
name|ffesymbol_set_info
argument_list|(
name|s
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindENTITY
argument_list|,
name|FFEINFO_whereRESULT
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffesymbol_resolve_intrin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ffestorag_exec_layout
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Since ENTRY might appear after executable stmts, do what would have 	 been done if it hadn't -- give symbol implicit type and 	 exec-transition it.  */
if|if
condition|(
operator|!
name|in_spec
operator|&&
name|ffesymbol_is_specable
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|s
argument_list|)
condition|)
comment|/* Do implicit typing. */
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|entryname
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffecom_sym_exec_transition
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Use whatever type info is available for ENTRY to set up type for its 	 global-name-space function symbol relative.  */
name|ffesymbol_set_info
argument_list|(
name|fs
argument_list|,
name|ffeinfo_new
argument_list|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffesymbol_kindtype
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindFUNCTION
argument_list|,
name|FFEINFO_whereLOCAL
argument_list|,
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check whether the type info fits the filewide expectations; 	 set ok flag accordingly.  */
name|ffesymbol_reference
argument_list|(
name|fs
argument_list|,
name|entryname
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* ~~Question??: 	 When ENTRY FOO() RESULT(IBAR) is supported, what will the typing be 	 if FOO and IBAR would normally end up with different types?  I think 	 the answer is that FOO is always given whatever type would be chosen 	 for IBAR, rather than the other way around, and I think it ends up 	 working that way for FUNCTION FOO() RESULT(IBAR), but this should be 	 checked out in all its different combos. Related question is, is 	 there any way that FOO in either case ends up without type info 	 filled in?  Does anyone care?  */
name|ffesymbol_signal_unreported
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffesymbol_set_info
argument_list|(
name|fs
argument_list|,
name|ffeinfo_new
argument_list|(
name|FFEINFO_basictypeNONE
argument_list|,
name|FFEINFO_kindtypeNONE
argument_list|,
literal|0
argument_list|,
name|FFEINFO_kindSUBROUTINE
argument_list|,
name|FFEINFO_whereLOCAL
argument_list|,
name|FFETARGET_charactersizeNONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|in_spec
condition|)
name|fs
operator|=
name|ffecom_sym_exec_transition
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|ffestd_R1226
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1227 -- RETURN statement     ffestc_R1227(expr,expr_token);     Make sure statement is valid here; implement.  expr and expr_token are    both NULL if there was no expression.  */
end_comment

begin_function
name|void
name|ffestc_R1227
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_notloop_begin_
argument_list|()
expr_stmt|;
for|for
control|(
name|b
operator|=
name|ffestw_stack_top
argument_list|()
init|;
condition|;
name|b
operator|=
name|ffestw_previous
argument_list|(
name|b
argument_list|)
control|)
block|{
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|b
argument_list|)
condition|)
block|{
case|case
name|FFESTV_statePROGRAM4
case|:
case|case
name|FFESTV_stateSUBROUTINE4
case|:
case|case
name|FFESTV_stateFUNCTION4
case|:
goto|goto
name|base
goto|;
comment|/* :::::::::::::::::::: */
case|case
name|FFESTV_stateNIL
case|:
name|assert
argument_list|(
literal|"bad state"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|base
label|:
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|b
argument_list|)
condition|)
block|{
case|case
name|FFESTV_statePROGRAM4
case|:
if|if
condition|(
name|ffe_is_pedantic
argument_list|()
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_RETURN_IN_MAIN
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|!=
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_ALTRETURN_IN_PROGRAM
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|expr_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|expr_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|expr
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|FFESTV_stateSUBROUTINE4
case|:
break|break;
case|case
name|FFESTV_stateFUNCTION4
case|:
if|if
condition|(
name|expr
operator|!=
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_ALTRETURN_IN_FUNCTION
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|expr_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|expr_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
name|expr
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad state #2"
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|ffestd_R1227
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* notloop's that are actionif's can be the target of a loop-end      statement if they're in the "then" part of a logical IF, as      in "DO 10", "10 IF (...) RETURN".  */
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1228 -- CONTAINS statement     ffestc_R1228();  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_F90
end_if

begin_function
name|void
name|ffestc_R1228
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_contains_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_R1228
argument_list|()
expr_stmt|;
name|ffe_terminate_3
argument_list|()
expr_stmt|;
name|ffe_init_3
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_R1229_start -- STMTFUNCTION statement begin     ffestc_R1229_start(func_name,func_arg_list,close_paren);     Verify that STMTFUNCTION is valid here, establish func_arg_list in a new    "live" scope within the current scope, and expect the actual expression    (or NULL) in ffestc_R1229_finish.  The reason there are two ffestc    functions to handle this is so the scope can be established, allowing    ffeexpr to assign proper characteristics to references to the dummy    arguments.  */
end_comment

begin_function
name|void
name|ffestc_R1229_start
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffesttTokenList
name|args
parameter_list|,
name|ffelexToken
name|final
name|UNUSED
parameter_list|)
block|{
name|ffesymbol
name|s
decl_stmt|;
name|ffesymbolAttrs
name|sa
decl_stmt|;
name|ffesymbolAttrs
name|na
decl_stmt|;
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_sfunc_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|args
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|ffesymbol_declare_local
argument_list|(
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sa
operator|=
name|ffesymbol_attrs
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of object we've got based on previous declarations      of or references to the object. */
if|if
condition|(
operator|!
name|ffesymbol_is_specable
argument_list|(
name|s
argument_list|)
condition|)
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Can't dcl sym ref'd in sfuncdef. */
elseif|else
if|if
condition|(
name|sa
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|na
operator|=
name|FFESYMBOL_attrsANY
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|sa
operator|&
operator|~
name|FFESYMBOL_attrsTYPE
operator|)
condition|)
name|na
operator|=
name|sa
operator||
name|FFESYMBOL_attrsSFUNC
expr_stmt|;
else|else
name|na
operator|=
name|FFESYMBOL_attrsetNONE
expr_stmt|;
comment|/* Now see what we've got for a new object: NONE means a new error cropped      up; ANY means an old error to be ignored; otherwise, everything's ok,      update the object (symbol) and continue on. */
if|if
condition|(
name|na
operator|==
name|FFESYMBOL_attrsetNONE
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ffestc_parent_ok_
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|na
operator|&
name|FFESYMBOL_attrsANY
condition|)
name|ffestc_parent_ok_
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|ffesymbol_set_attrs
argument_list|(
name|s
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|ffesymbol_set_state
argument_list|(
name|s
argument_list|,
name|FFESYMBOL_stateSEEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffeimplic_establish_symbol
argument_list|(
name|s
argument_list|)
operator|||
operator|(
operator|(
name|ffesymbol_basictype
argument_list|(
name|s
argument_list|)
operator|==
name|FFEINFO_basictypeCHARACTER
operator|)
operator|&&
operator|(
name|ffesymbol_size
argument_list|(
name|s
argument_list|)
operator|==
name|FFETARGET_charactersizeNONE
operator|)
operator|)
condition|)
block|{
name|ffesymbol_error
argument_list|(
name|s
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ffestc_parent_ok_
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* Tell ffeexpr that sfunc def is in progress.  */
name|ffesymbol_set_sfexpr
argument_list|(
name|s
argument_list|,
name|ffebld_new_any
argument_list|()
argument_list|)
expr_stmt|;
name|ffebld_set_info
argument_list|(
name|ffesymbol_sfexpr
argument_list|(
name|s
argument_list|)
argument_list|,
name|ffeinfo_new_any
argument_list|()
argument_list|)
expr_stmt|;
name|ffestc_parent_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|ffe_init_4
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_parent_ok_
condition|)
block|{
name|ffebld_init_list
argument_list|(
operator|&
name|s
operator|->
name|dummy_args
argument_list|,
operator|&
name|ffestc_local_
operator|.
name|dummy
operator|.
name|list_bottom
argument_list|)
expr_stmt|;
name|ffestc_sfdummy_argno_
operator|=
literal|0
expr_stmt|;
name|ffestt_tokenlist_drive
argument_list|(
name|args
argument_list|,
name|ffestc_promote_sfdummy_
argument_list|)
expr_stmt|;
name|ffebld_end_list
argument_list|(
operator|&
name|ffestc_local_
operator|.
name|dummy
operator|.
name|list_bottom
argument_list|)
expr_stmt|;
block|}
name|ffestc_local_
operator|.
name|sfunc
operator|.
name|symbol
operator|=
name|s
expr_stmt|;
name|ffestd_R1229_start
argument_list|(
name|name
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_R1229_finish -- STMTFUNCTION statement list complete     ffestc_R1229_finish(expr,expr_token);     If expr is NULL, an error occurred parsing the expansion expression, so    just cancel the effects of ffestc_R1229_start and pretend nothing    happened.  Otherwise, install the expression as the expansion for the    statement function named in _start_, then clean up.	*/
end_comment

begin_function
name|void
name|ffestc_R1229_finish
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|if
condition|(
name|ffestc_parent_ok_
operator|&&
operator|(
name|expr
operator|!=
name|NULL
operator|)
condition|)
name|ffesymbol_set_sfexpr
argument_list|(
name|ffestc_local_
operator|.
name|sfunc
operator|.
name|symbol
argument_list|,
name|ffeexpr_convert_to_sym
argument_list|(
name|expr
argument_list|,
name|expr_token
argument_list|,
name|ffestc_local_
operator|.
name|sfunc
operator|.
name|symbol
argument_list|,
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffestd_R1229_finish
argument_list|(
name|ffestc_local_
operator|.
name|sfunc
operator|.
name|symbol
argument_list|)
expr_stmt|;
name|ffesymbol_signal_unreported
argument_list|(
name|ffestc_local_
operator|.
name|sfunc
operator|.
name|symbol
argument_list|)
expr_stmt|;
name|ffe_terminate_4
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_S3P4 -- INCLUDE line     ffestc_S3P4(filename,filename_token);     Make sure INCLUDE not preceded by any semicolons or a label def; implement.	*/
end_comment

begin_function
name|void
name|ffestc_S3P4
parameter_list|(
name|ffebld
name|filename
parameter_list|,
name|ffelexToken
name|filename_token
name|UNUSED
parameter_list|)
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
name|ffestc_labeldef_invalid_
argument_list|()
expr_stmt|;
name|ffestd_S3P4
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V003_start -- STRUCTURE statement list begin     ffestc_V003_start(structure_name);     Verify that STRUCTURE is valid here, and begin accepting items in the list.	*/
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
name|void
name|ffestc_V003_start
parameter_list|(
name|ffelexToken
name|structure_name
parameter_list|)
block|{
name|ffestw
name|b
decl_stmt|;
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_vxtstructure_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateSTRUCTURE
case|:
case|case
name|FFESTV_stateMAP
case|:
name|ffestc_local_
operator|.
name|V003
operator|.
name|list_state
operator|=
literal|2
expr_stmt|;
comment|/* Require at least one field 						   name. */
name|ffestw_set_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Seen at least one 							   member. */
break|break;
default|default:
name|ffestc_local_
operator|.
name|V003
operator|.
name|list_state
operator|=
literal|0
expr_stmt|;
comment|/* No field names required. */
if|if
condition|(
name|structure_name
operator|==
name|NULL
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_STRUCT_MISSING_NAME
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateSTRUCTURE
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_structure_
argument_list|)
expr_stmt|;
name|ffestw_set_substate
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* No field-declarations seen yet. */
name|ffestd_V003_start
argument_list|(
name|structure_name
argument_list|)
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V003_item -- STRUCTURE statement for object-name     ffestc_V003_item(name_token,dim_list);     Make sure name_token identifies a valid object to be STRUCTUREd.  */
end_comment

begin_function
name|void
name|ffestc_V003_item
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|if
condition|(
name|ffestc_local_
operator|.
name|V003
operator|.
name|list_state
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|ffestc_local_
operator|.
name|V003
operator|.
name|list_state
operator|==
literal|0
condition|)
block|{
name|ffestc_local_
operator|.
name|V003
operator|.
name|list_state
operator|=
literal|1
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_STRUCT_IGNORING_FIELD
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|name
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
name|ffestc_local_
operator|.
name|V003
operator|.
name|list_state
operator|=
literal|3
expr_stmt|;
comment|/* Have at least one field name. */
if|if
condition|(
name|dims
operator|!=
name|NULL
condition|)
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
name|ffestd_V003_item
argument_list|(
name|name
argument_list|,
name|dims
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V003_finish -- STRUCTURE statement list complete     ffestc_V003_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_V003_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|if
condition|(
name|ffestc_local_
operator|.
name|V003
operator|.
name|list_state
operator|==
literal|2
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_STRUCT_MISSING_FIELD
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_previous
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_previous
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestd_V003_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V004 -- END STRUCTURE statement     ffestc_V004();     Make sure ffestc_kind_ identifies a STRUCTURE block.    Implement the end of the current STRUCTURE block.  */
end_comment

begin_function
name|void
name|ffestc_V004
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_structure_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestw_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_STRUCT_NO_COMPONENTS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_shriek_structure_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V009 -- UNION statement     ffestc_V009();  */
end_comment

begin_function
name|void
name|ffestc_V009
parameter_list|()
block|{
name|ffestw
name|b
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_structure_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestw_set_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Seen at least one member. */
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateUNION
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_union_
argument_list|)
expr_stmt|;
name|ffestw_set_substate
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* No map decls seen yet. */
name|ffestd_V009
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V010 -- END UNION statement     ffestc_V010();     Make sure ffestc_kind_ identifies a UNION block.    Implement the end of the current UNION block.  */
end_comment

begin_function
name|void
name|ffestc_V010
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_union_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestw_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_UNION_NO_TWO_MAPS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_shriek_union_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V012 -- MAP statement     ffestc_V012();  */
end_comment

begin_function
name|void
name|ffestc_V012
parameter_list|()
block|{
name|ffestw
name|b
decl_stmt|;
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_union_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestw_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
literal|2
condition|)
name|ffestw_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|++
expr_stmt|;
comment|/* 0=>1, 1=>2. */
name|b
operator|=
name|ffestw_update
argument_list|(
name|ffestw_push
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ffestw_set_top_do
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ffestw_set_state
argument_list|(
name|b
argument_list|,
name|FFESTV_stateMAP
argument_list|)
expr_stmt|;
name|ffestw_set_blocknum
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffestw_set_shriek
argument_list|(
name|b
argument_list|,
name|ffestc_shriek_map_
argument_list|)
expr_stmt|;
name|ffestw_set_substate
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* No field-declarations seen yet. */
name|ffestd_V012
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V013 -- END MAP statement     ffestc_V013();     Make sure ffestc_kind_ identifies a MAP block.    Implement the end of the current MAP block.	*/
end_comment

begin_function
name|void
name|ffestc_V013
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_map_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestw_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ffebad_start
argument_list|(
name|FFEBAD_MAP_NO_COMPONENTS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffestw_line
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|,
name|ffestw_col
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
name|ffestc_shriek_map_
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_V014_start -- VOLATILE statement list begin     ffestc_V014_start();     Verify that VOLATILE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_V014_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_progspec_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_V014_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V014_item_object -- VOLATILE statement for object-name     ffestc_V014_item_object(name_token);     Make sure name_token identifies a valid object to be VOLATILEd.  */
end_comment

begin_function
name|void
name|ffestc_V014_item_object
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V014_item_object
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V014_item_cblock -- VOLATILE statement for common-block-name     ffestc_V014_item_cblock(name_token);     Make sure name_token identifies a valid common block to be VOLATILEd.  */
end_comment

begin_function
name|void
name|ffestc_V014_item_cblock
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V014_item_cblock
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V014_finish -- VOLATILE statement list complete     ffestc_V014_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_V014_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V014_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V016_start -- RECORD statement list begin     ffestc_V016_start();     Verify that RECORD is valid here, and begin accepting items in the list.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
name|void
name|ffestc_V016_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_record_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ffestw_state
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|FFESTV_stateSTRUCTURE
case|:
case|case
name|FFESTV_stateMAP
case|:
name|ffestw_set_substate
argument_list|(
name|ffestw_stack_top
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Seen at least one 							   member. */
break|break;
default|default:
break|break;
block|}
name|ffestd_V016_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V016_item_structure -- RECORD statement for common-block-name     ffestc_V016_item_structure(name_token);     Make sure name_token identifies a valid structure to be RECORDed.  */
end_comment

begin_function
name|void
name|ffestc_V016_item_structure
parameter_list|(
name|ffelexToken
name|name
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V016_item_structure
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V016_item_object -- RECORD statement for object-name     ffestc_V016_item_object(name_token,dim_list);     Make sure name_token identifies a valid object to be RECORDd.  */
end_comment

begin_function
name|void
name|ffestc_V016_item_object
parameter_list|(
name|ffelexToken
name|name
parameter_list|,
name|ffesttDimList
name|dims
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|if
condition|(
name|dims
operator|!=
name|NULL
condition|)
name|ffesta_set_outpooldisp
argument_list|(
name|FFESTA_pooldispPRESERVE
argument_list|)
expr_stmt|;
name|ffestd_V016_item_object
argument_list|(
name|name
argument_list|,
name|dims
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V016_finish -- RECORD statement list complete     ffestc_V016_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_V016_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V016_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V018_start -- REWRITE(...) statement list begin     ffestc_V018_start();     Verify that REWRITE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_V018_start
parameter_list|()
block|{
name|ffestvFormat
name|format
decl_stmt|;
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|rewrite
operator|.
name|rewrite_spec
index|[
name|FFESTP_rewriteixERR
index|]
argument_list|)
operator|||
operator|!
name|ffestc_subr_is_format_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|rewrite
operator|.
name|rewrite_spec
index|[
name|FFESTP_rewriteixFMT
index|]
argument_list|)
operator|||
operator|!
name|ffestc_subr_is_present_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|ffestp_file
operator|.
name|rewrite
operator|.
name|rewrite_spec
index|[
name|FFESTP_rewriteixUNIT
index|]
argument_list|)
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|format
operator|=
name|ffestc_subr_format_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|rewrite
operator|.
name|rewrite_spec
index|[
name|FFESTP_rewriteixFMT
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FFESTV_formatNAMELIST
case|:
case|case
name|FFESTV_formatASTERISK
case|:
name|ffebad_start
argument_list|(
name|FFEBAD_CONFLICTING_SPECS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffesta_tokens
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffestp_file
operator|.
name|rewrite
operator|.
name|rewrite_spec
index|[
name|FFESTP_rewriteixFMT
index|]
operator|.
name|kw_or_val_present
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffestp_file
operator|.
name|rewrite
operator|.
name|rewrite_spec
index|[
name|FFESTP_rewriteixFMT
index|]
operator|.
name|kw_present
condition|)
block|{
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|rewrite
operator|.
name|rewrite_spec
index|[
name|FFESTP_rewriteixFMT
index|]
operator|.
name|kw
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|rewrite
operator|.
name|rewrite_spec
index|[
name|FFESTP_rewriteixFMT
index|]
operator|.
name|kw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffebad_here
argument_list|(
literal|1
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|ffestp_file
operator|.
name|rewrite
operator|.
name|rewrite_spec
index|[
name|FFESTP_rewriteixFMT
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|ffestp_file
operator|.
name|rewrite
operator|.
name|rewrite_spec
index|[
name|FFESTP_rewriteixFMT
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffebad_finish
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|ffestd_V018_start
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V018_item -- REWRITE statement i/o item     ffestc_V018_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestc_V018_item
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V018_item
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V018_finish -- REWRITE statement list complete     ffestc_V018_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_V018_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V018_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V019_start -- ACCEPT statement list begin     ffestc_V019_start();     Verify that ACCEPT is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_V019_start
parameter_list|()
block|{
name|ffestvFormat
name|format
decl_stmt|;
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_subr_is_format_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|accept
operator|.
name|accept_spec
index|[
name|FFESTP_acceptixFORMAT
index|]
argument_list|)
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|format
operator|=
name|ffestc_subr_format_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|accept
operator|.
name|accept_spec
index|[
name|FFESTP_acceptixFORMAT
index|]
argument_list|)
expr_stmt|;
name|ffestc_namelist_
operator|=
operator|(
name|format
operator|==
name|FFESTV_formatNAMELIST
operator|)
expr_stmt|;
name|ffestd_V019_start
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V019_item -- ACCEPT statement i/o item     ffestc_V019_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestc_V019_item
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|if
condition|(
name|ffestc_namelist_
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ffestc_namelist_
operator|==
literal|1
condition|)
block|{
name|ffestc_namelist_
operator|=
literal|2
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_NAMELIST_ITEMS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|expr_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|expr_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
name|ffestd_V019_item
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V019_finish -- ACCEPT statement list complete     ffestc_V019_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_V019_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V019_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_V020_start -- TYPE statement list begin     ffestc_V020_start();     Verify that TYPE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_V020_start
parameter_list|()
block|{
name|ffestvFormat
name|format
decl_stmt|;
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_subr_is_format_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|type
operator|.
name|type_spec
index|[
name|FFESTP_typeixFORMAT
index|]
argument_list|)
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|format
operator|=
name|ffestc_subr_format_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|type
operator|.
name|type_spec
index|[
name|FFESTP_typeixFORMAT
index|]
argument_list|)
expr_stmt|;
name|ffestc_namelist_
operator|=
operator|(
name|format
operator|==
name|FFESTV_formatNAMELIST
operator|)
expr_stmt|;
name|ffestd_V020_start
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V020_item -- TYPE statement i/o item     ffestc_V020_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestc_V020_item
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
if|if
condition|(
name|ffestc_namelist_
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ffestc_namelist_
operator|==
literal|1
condition|)
block|{
name|ffestc_namelist_
operator|=
literal|2
expr_stmt|;
name|ffebad_start
argument_list|(
name|FFEBAD_NAMELIST_ITEMS
argument_list|)
expr_stmt|;
name|ffebad_here
argument_list|(
literal|0
argument_list|,
name|ffelex_token_where_line
argument_list|(
name|expr_token
argument_list|)
argument_list|,
name|ffelex_token_where_column
argument_list|(
name|expr_token
argument_list|)
argument_list|)
expr_stmt|;
name|ffebad_finish
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
name|ffestd_V020_item
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V020_finish -- TYPE statement list complete     ffestc_V020_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_V020_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V020_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V021 -- DELETE statement     ffestc_V021();     Make sure a DELETE is valid in the current context, and implement it.  */
end_comment

begin_if
if|#
directive|if
name|FFESTR_VXT
end_if

begin_function
name|void
name|ffestc_V021
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|delete
operator|.
name|delete_spec
index|[
name|FFESTP_deleteixERR
index|]
argument_list|)
operator|&&
name|ffestc_subr_is_present_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|ffestp_file
operator|.
name|delete
operator|.
name|delete_spec
index|[
name|FFESTP_deleteixUNIT
index|]
argument_list|)
condition|)
name|ffestd_V021
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V022 -- UNLOCK statement     ffestc_V022();     Make sure a UNLOCK is valid in the current context, and implement it.  */
end_comment

begin_function
name|void
name|ffestc_V022
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixERR
index|]
argument_list|)
operator|&&
name|ffestc_subr_is_present_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|ffestp_file
operator|.
name|beru
operator|.
name|beru_spec
index|[
name|FFESTP_beruixUNIT
index|]
argument_list|)
condition|)
name|ffestd_V022
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V023_start -- ENCODE(...) statement list begin     ffestc_V023_start();     Verify that ENCODE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_V023_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|vxtcode
operator|.
name|vxtcode_spec
index|[
name|FFESTP_vxtcodeixERR
index|]
argument_list|)
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestd_V023_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V023_item -- ENCODE statement i/o item     ffestc_V023_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestc_V023_item
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V023_item
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V023_finish -- ENCODE statement list complete     ffestc_V023_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_V023_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V023_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V024_start -- DECODE(...) statement list begin     ffestc_V024_start();     Verify that DECODE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_V024_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|vxtcode
operator|.
name|vxtcode_spec
index|[
name|FFESTP_vxtcodeixERR
index|]
argument_list|)
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestd_V024_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V024_item -- DECODE statement i/o item     ffestc_V024_item(expr,expr_token);     Implement output-list expression.  */
end_comment

begin_function
name|void
name|ffestc_V024_item
parameter_list|(
name|ffebld
name|expr
parameter_list|,
name|ffelexToken
name|expr_token
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V024_item
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V024_finish -- DECODE statement list complete     ffestc_V024_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_V024_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V024_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V025_start -- DEFINEFILE statement list begin     ffestc_V025_start();     Verify that DEFINEFILE is valid here, and begin accepting items in the    list.  */
end_comment

begin_function
name|void
name|ffestc_V025_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
name|ffestd_V025_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V025_item -- DEFINE FILE statement item     ffestc_V025_item(u,ut,m,mt,n,nt,asv,asvt);     Implement item.  */
end_comment

begin_function
name|void
name|ffestc_V025_item
parameter_list|(
name|ffebld
name|u
parameter_list|,
name|ffelexToken
name|ut
parameter_list|,
name|ffebld
name|m
parameter_list|,
name|ffelexToken
name|mt
parameter_list|,
name|ffebld
name|n
parameter_list|,
name|ffelexToken
name|nt
parameter_list|,
name|ffebld
name|asv
parameter_list|,
name|ffelexToken
name|asvt
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V025_item
argument_list|(
name|u
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|asv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V025_finish -- DEFINE FILE statement list complete     ffestc_V025_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_V025_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V025_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V026 -- FIND statement     ffestc_V026();     Make sure a FIND is valid in the current context, and implement it.	*/
end_comment

begin_function
name|void
name|ffestc_V026
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_actionif_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
return|return;
name|ffestc_labeldef_branch_begin_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_subr_is_branch_
argument_list|(
operator|&
name|ffestp_file
operator|.
name|find
operator|.
name|find_spec
index|[
name|FFESTP_findixERR
index|]
argument_list|)
operator|&&
name|ffestc_subr_is_present_
argument_list|(
literal|"UNIT"
argument_list|,
operator|&
name|ffestp_file
operator|.
name|find
operator|.
name|find_spec
index|[
name|FFESTP_findixUNIT
index|]
argument_list|)
operator|&&
name|ffestc_subr_is_present_
argument_list|(
literal|"REC"
argument_list|,
operator|&
name|ffestp_file
operator|.
name|find
operator|.
name|find_spec
index|[
name|FFESTP_findixREC
index|]
argument_list|)
condition|)
name|ffestd_V026
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ffestc_labeldef_branch_end_
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ffestc_V027_start -- VXT PARAMETER statement list begin     ffestc_V027_start();     Verify that PARAMETER is valid here, and begin accepting items in the list.	*/
end_comment

begin_function
name|void
name|ffestc_V027_start
parameter_list|()
block|{
name|ffestc_check_start_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_order_parameter_
argument_list|()
operator|!=
name|FFESTC_orderOK_
condition|)
block|{
name|ffestc_ok_
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ffestc_labeldef_useless_
argument_list|()
expr_stmt|;
name|ffestd_V027_start
argument_list|()
expr_stmt|;
name|ffestc_ok_
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V027_item -- VXT PARAMETER statement assignment     ffestc_V027_item(dest,dest_token,source,source_token);     Make sure the source is a valid source for the destination; make the    assignment.	*/
end_comment

begin_function
name|void
name|ffestc_V027_item
parameter_list|(
name|ffelexToken
name|dest_token
parameter_list|,
name|ffebld
name|source
parameter_list|,
name|ffelexToken
name|source_token
name|UNUSED
parameter_list|)
block|{
name|ffestc_check_item_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V027_item
argument_list|(
name|dest_token
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ffestc_V027_finish -- VXT PARAMETER statement list complete     ffestc_V027_finish();     Just wrap up any local activities.  */
end_comment

begin_function
name|void
name|ffestc_V027_finish
parameter_list|()
block|{
name|ffestc_check_finish_
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ffestc_ok_
condition|)
return|return;
name|ffestd_V027_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Any executable statement.  Mainly make sure that one-shot things    like the statement for a logical IF are reset.  */
end_comment

begin_function
name|void
name|ffestc_any
parameter_list|()
block|{
name|ffestc_check_simple_
argument_list|()
expr_stmt|;
name|ffestc_order_any_
argument_list|()
expr_stmt|;
name|ffestc_labeldef_any_
argument_list|()
expr_stmt|;
if|if
condition|(
name|ffestc_shriek_after1_
operator|==
name|NULL
condition|)
return|return;
name|ffestd_any
argument_list|()
expr_stmt|;
call|(
modifier|*
name|ffestc_shriek_after1_
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

