begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* src.c -- Implementation File    Copyright (C) 1995 Free Software Foundation, Inc.    Contributed by James Craig Burley (burley@gnu.org).  This file is part of GNU Fortran.  GNU Fortran is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Fortran; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Related Modules:     Description:       Source-file functions to handle various combinations of case sensitivity       and insensitivity at run time.     Modifications: */
end_comment

begin_include
include|#
directive|include
file|"proj.h"
end_include

begin_include
include|#
directive|include
file|"src.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_comment
comment|/* This array does a toupper (), but any valid char type is valid as an    index and returns identity if not a lower-case character.  */
end_comment

begin_decl_stmt
name|char
name|ffesrc_toupper_
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array does a tolower (), but any valid char type is valid as an    index and returns identity if not an upper-case character.  */
end_comment

begin_decl_stmt
name|char
name|ffesrc_tolower_
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array is set up so that, given a source-mapped character, the result    of indexing into this array will match an upper-cased character depending    on the source-mapped character's case and the established ffe_case_match()    setting.  So the uppercase cells contain identies (e.g. ['A'] == 'A')    as long as uppercase matching is permitted (!FFE_caseLOWER) and the    lowercase cells contain uppercased identities (e.g. ['a'] == 'A') as long    as lowercase matching is permitted (!FFE_caseUPPER).	 Else the case    cells contain -1.  _init_ is for the first character of a keyword,    and _noninit_ is for other characters.  */
end_comment

begin_decl_stmt
name|char
name|ffesrc_char_match_init_
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ffesrc_char_match_noninit_
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array is used to map input source according to the established    ffe_case_source() setting: for FFE_caseNONE, the array is all    identities; for FFE_caseUPPER, the lowercase cells contain    uppercased identities; and vice versa for FFE_caseLOWER.  */
end_comment

begin_decl_stmt
name|char
name|ffesrc_char_source_
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array is used to map an internally generated character so that it    will be accepted as an initial character in a keyword.  The assumption    is that the incoming character is uppercase.  */
end_comment

begin_decl_stmt
name|char
name|ffesrc_char_internal_init_
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array is used to determine if a particular character is valid in    a symbol name according to the established ffe_case_symbol() setting:    for FFE_caseNONE, the array is all FFEBAD; for FFE_caseUPPER, the    lowercase cells contain a non-FFEBAD error code (FFEBAD_SYMBOL_UPPER_CASE);    and vice versa for FFE_caseLOWER.  _init_ and _noninit_ distinguish    between initial and subsequent characters for the caseINITCAP case,    and their error codes are different for appropriate messages --    specifically, _noninit_ contains a non-FFEBAD error code for all    except lowercase characters for the caseINITCAP case.     See ffesrc_check_symbol_, it must be TRUE if this array is not all    FFEBAD.  */
end_comment

begin_decl_stmt
name|ffebad
name|ffesrc_bad_symbol_init_
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ffebad
name|ffesrc_bad_symbol_noninit_
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set TRUE if any element in ffesrc_bad_symbol (with an index representing    a character that can also be in the text of a token passed to    ffename_find, strictly speaking) is not FFEBAD.  I.e., TRUE if it is    necessary to check token characters against the ffesrc_bad_symbol_    array.  */
end_comment

begin_decl_stmt
name|bool
name|ffesrc_check_symbol_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are set TRUE if the kind of character (upper/lower) is ok as a match    in the context (initial/noninitial character of keyword).  */
end_comment

begin_decl_stmt
name|bool
name|ffesrc_ok_match_init_upper_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|ffesrc_ok_match_init_lower_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|ffesrc_ok_match_noninit_upper_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|ffesrc_ok_match_noninit_lower_
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize table of alphabetic matches. */
end_comment

begin_function
name|void
name|ffesrc_init_1
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
name|ffesrc_char_match_init_
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|ffesrc_char_match_noninit_
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|ffesrc_char_source_
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|ffesrc_char_internal_init_
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|ffesrc_toupper_
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|ffesrc_tolower_
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|ffesrc_bad_symbol_init_
index|[
name|i
index|]
operator|=
name|FFEBAD
expr_stmt|;
name|ffesrc_bad_symbol_noninit_
index|[
name|i
index|]
operator|=
name|FFEBAD
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
operator|++
name|i
control|)
name|ffesrc_tolower_
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
operator|++
name|i
control|)
name|ffesrc_toupper_
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ffesrc_check_symbol_
operator|=
operator|(
name|ffe_case_symbol
argument_list|()
operator|!=
name|FFE_caseNONE
operator|)
expr_stmt|;
name|ffesrc_ok_match_init_upper_
operator|=
operator|(
name|ffe_case_match
argument_list|()
operator|!=
name|FFE_caseLOWER
operator|)
expr_stmt|;
name|ffesrc_ok_match_init_lower_
operator|=
operator|(
name|ffe_case_match
argument_list|()
operator|!=
name|FFE_caseUPPER
operator|)
operator|&&
operator|(
name|ffe_case_match
argument_list|()
operator|!=
name|FFE_caseINITCAP
operator|)
expr_stmt|;
name|ffesrc_ok_match_noninit_upper_
operator|=
operator|(
name|ffe_case_match
argument_list|()
operator|!=
name|FFE_caseLOWER
operator|)
operator|&&
operator|(
name|ffe_case_match
argument_list|()
operator|!=
name|FFE_caseINITCAP
operator|)
expr_stmt|;
name|ffesrc_ok_match_noninit_lower_
operator|=
operator|(
name|ffe_case_match
argument_list|()
operator|!=
name|FFE_caseUPPER
operator|)
expr_stmt|;
comment|/* Note that '-' is used to flag an invalid match character.	'-' is      somewhat arbitrary, actually.  -1 was used, but that's not wise on a      system with unsigned chars as default -- it'd turn into 255 or some such      large positive number, which would sort higher than the alphabetics and      thus possibly cause problems.  So '-' is picked just because it's never      likely to be a symbol character in Fortran and because it's "less than"      any alphabetic character.	EBCDIC might see things differently, I don't      remember it well enough, but that's just tough -- lots of other things      might have to change to support EBCDIC -- anyway, some other character      could easily be picked.  */
define|#
directive|define
name|FFESRC_INVALID_SYMBOL_CHAR_
value|'-'
if|if
condition|(
operator|!
name|ffesrc_ok_match_init_upper_
condition|)
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
operator|++
name|i
control|)
name|ffesrc_char_match_init_
index|[
name|i
index|]
operator|=
name|FFESRC_INVALID_SYMBOL_CHAR_
expr_stmt|;
if|if
condition|(
name|ffesrc_ok_match_init_lower_
condition|)
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
operator|++
name|i
control|)
name|ffesrc_char_match_init_
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
operator|++
name|i
control|)
name|ffesrc_char_match_init_
index|[
name|i
index|]
operator|=
name|FFESRC_INVALID_SYMBOL_CHAR_
expr_stmt|;
if|if
condition|(
operator|!
name|ffesrc_ok_match_noninit_upper_
condition|)
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
operator|++
name|i
control|)
name|ffesrc_char_match_noninit_
index|[
name|i
index|]
operator|=
name|FFESRC_INVALID_SYMBOL_CHAR_
expr_stmt|;
if|if
condition|(
name|ffesrc_ok_match_noninit_lower_
condition|)
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
operator|++
name|i
control|)
name|ffesrc_char_match_noninit_
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
operator|++
name|i
control|)
name|ffesrc_char_match_noninit_
index|[
name|i
index|]
operator|=
name|FFESRC_INVALID_SYMBOL_CHAR_
expr_stmt|;
if|if
condition|(
name|ffe_case_source
argument_list|()
operator|==
name|FFE_caseLOWER
condition|)
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
operator|++
name|i
control|)
name|ffesrc_char_source_
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ffe_case_source
argument_list|()
operator|==
name|FFE_caseUPPER
condition|)
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
operator|++
name|i
control|)
name|ffesrc_char_source_
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffe_case_match
argument_list|()
operator|==
name|FFE_caseLOWER
condition|)
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
operator|++
name|i
control|)
name|ffesrc_char_internal_init_
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ffe_case_symbol
argument_list|()
condition|)
block|{
case|case
name|FFE_caseLOWER
case|:
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
operator|++
name|i
control|)
block|{
name|ffesrc_bad_symbol_init_
index|[
name|i
index|]
operator|=
name|FFEBAD_SYMBOL_UPPER_CASE
expr_stmt|;
name|ffesrc_bad_symbol_noninit_
index|[
name|i
index|]
operator|=
name|FFEBAD_SYMBOL_UPPER_CASE
expr_stmt|;
block|}
break|break;
case|case
name|FFE_caseUPPER
case|:
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
operator|++
name|i
control|)
block|{
name|ffesrc_bad_symbol_init_
index|[
name|i
index|]
operator|=
name|FFEBAD_SYMBOL_LOWER_CASE
expr_stmt|;
name|ffesrc_bad_symbol_noninit_
index|[
name|i
index|]
operator|=
name|FFEBAD_SYMBOL_LOWER_CASE
expr_stmt|;
block|}
break|break;
case|case
name|FFE_caseINITCAP
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|ffesrc_bad_symbol_noninit_
index|[
name|i
index|]
operator|=
name|FFEBAD_SYMBOL_NOLOWER_INITCAP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
operator|++
name|i
control|)
block|{
name|ffesrc_bad_symbol_init_
index|[
name|i
index|]
operator|=
name|FFEBAD_SYMBOL_LOWER_INITCAP
expr_stmt|;
name|ffesrc_bad_symbol_noninit_
index|[
name|i
index|]
operator|=
name|FFEBAD
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Compare two strings a la strcmp, the first being a source string with its    length passed, and the second being a constant string passed    in InitialCaps form.	 Also, the return value is always -1, 0, or 1. */
end_comment

begin_function
name|int
name|ffesrc_strcmp_1ns2i
parameter_list|(
name|ffeCase
name|mcase
parameter_list|,
specifier|const
name|char
modifier|*
name|var
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|str_ic
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|char
name|d
decl_stmt|;
switch|switch
condition|(
name|mcase
condition|)
block|{
case|case
name|FFE_caseNONE
case|:
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
operator|,
operator|++
name|var
operator|,
operator|++
name|str_ic
control|)
block|{
name|c
operator|=
name|ffesrc_char_source
argument_list|(
operator|*
name|var
argument_list|)
expr_stmt|;
comment|/* Transform source. */
name|c
operator|=
name|ffesrc_toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Upcase source. */
name|d
operator|=
name|ffesrc_toupper
argument_list|(
operator|*
name|str_ic
argument_list|)
expr_stmt|;
comment|/* Upcase InitialCaps char. */
if|if
condition|(
name|c
operator|!=
name|d
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|<
name|d
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
block|}
break|break;
case|case
name|FFE_caseUPPER
case|:
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
operator|,
operator|++
name|var
operator|,
operator|++
name|str_ic
control|)
block|{
name|c
operator|=
name|ffesrc_char_source
argument_list|(
operator|*
name|var
argument_list|)
expr_stmt|;
comment|/* Transform source. */
name|d
operator|=
name|ffesrc_toupper
argument_list|(
operator|*
name|str_ic
argument_list|)
expr_stmt|;
comment|/* Transform InitialCaps char. */
if|if
condition|(
name|c
operator|!=
name|d
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|<
name|d
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
block|}
break|break;
case|case
name|FFE_caseLOWER
case|:
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
operator|,
operator|++
name|var
operator|,
operator|++
name|str_ic
control|)
block|{
name|c
operator|=
name|ffesrc_char_source
argument_list|(
operator|*
name|var
argument_list|)
expr_stmt|;
comment|/* Transform source. */
name|d
operator|=
name|ffesrc_tolower
argument_list|(
operator|*
name|str_ic
argument_list|)
expr_stmt|;
comment|/* Transform InitialCaps char. */
if|if
condition|(
name|c
operator|!=
name|d
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|<
name|d
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
block|}
break|break;
case|case
name|FFE_caseINITCAP
case|:
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
operator|,
operator|++
name|var
operator|,
operator|++
name|str_ic
control|)
block|{
name|c
operator|=
name|ffesrc_char_source
argument_list|(
operator|*
name|var
argument_list|)
expr_stmt|;
comment|/* Transform source. */
name|d
operator|=
operator|*
name|str_ic
expr_stmt|;
comment|/* No transform of InitialCaps char. */
if|if
condition|(
name|c
operator|!=
name|d
condition|)
block|{
name|c
operator|=
name|ffesrc_toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|d
operator|=
name|ffesrc_toupper
argument_list|(
name|d
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|c
operator|==
name|d
operator|)
condition|)
block|{
comment|/* Skip past equivalent (case-ins) chars. */
operator|--
name|len
operator|,
operator|++
name|var
operator|,
operator|++
name|str_ic
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|c
operator|=
name|ffesrc_toupper
argument_list|(
operator|*
name|var
argument_list|)
expr_stmt|;
name|d
operator|=
name|ffesrc_toupper
argument_list|(
operator|*
name|str_ic
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|d
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|<
name|d
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|"bad case value"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|str_ic
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Compare two strings a la strcmp, the second being a constant string passed    in both uppercase and lowercase form.  If not equal, the uppercase string    is used to determine the sign of the return value.  Also, the return    value is always -1, 0, or 1. */
end_comment

begin_function
name|int
name|ffesrc_strcmp_2c
parameter_list|(
name|ffeCase
name|mcase
parameter_list|,
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|str_uc
parameter_list|,
specifier|const
name|char
modifier|*
name|str_lc
parameter_list|,
specifier|const
name|char
modifier|*
name|str_ic
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
switch|switch
condition|(
name|mcase
condition|)
block|{
case|case
name|FFE_caseNONE
case|:
for|for
control|(
init|;
operator|*
name|var
operator|!=
literal|'\0'
condition|;
operator|++
name|var
operator|,
operator|++
name|str_uc
control|)
block|{
name|c
operator|=
name|ffesrc_toupper
argument_list|(
operator|*
name|var
argument_list|)
expr_stmt|;
comment|/* Upcase source. */
if|if
condition|(
name|c
operator|!=
operator|*
name|str_uc
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|str_uc
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|<
operator|*
name|str_uc
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|*
name|str_uc
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
case|case
name|FFE_caseUPPER
case|:
name|i
operator|=
name|strcmp
argument_list|(
name|var
argument_list|,
name|str_uc
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFE_caseLOWER
case|:
name|i
operator|=
name|strcmp
argument_list|(
name|var
argument_list|,
name|str_lc
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFE_caseINITCAP
case|:
for|for
control|(
init|;
operator|*
name|var
operator|!=
literal|'\0'
condition|;
operator|++
name|var
operator|,
operator|++
name|str_ic
operator|,
operator|++
name|str_uc
control|)
block|{
if|if
condition|(
operator|*
name|var
operator|!=
operator|*
name|str_ic
condition|)
block|{
name|c
operator|=
name|ffesrc_toupper
argument_list|(
operator|*
name|var
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|==
operator|*
name|str_uc
operator|)
condition|)
block|{
comment|/* Skip past equivalent (case-ins) chars. */
operator|++
name|var
operator|,
operator|++
name|str_uc
expr_stmt|;
name|c
operator|=
name|ffesrc_toupper
argument_list|(
operator|*
name|var
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|str_uc
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|<
operator|*
name|str_uc
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|*
name|str_ic
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
default|default:
name|assert
argument_list|(
literal|"bad case value"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Compare two strings a la strncmp, the second being a constant string passed    in uppercase, lowercase, and InitialCaps form.  If not equal, the    uppercase string is used to determine the sign of the return value.	*/
end_comment

begin_function
name|int
name|ffesrc_strncmp_2c
parameter_list|(
name|ffeCase
name|mcase
parameter_list|,
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|str_uc
parameter_list|,
specifier|const
name|char
modifier|*
name|str_lc
parameter_list|,
specifier|const
name|char
modifier|*
name|str_ic
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
switch|switch
condition|(
name|mcase
condition|)
block|{
case|case
name|FFE_caseNONE
case|:
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|++
name|var
operator|,
operator|++
name|str_uc
operator|,
operator|--
name|len
control|)
block|{
name|c
operator|=
name|ffesrc_toupper
argument_list|(
operator|*
name|var
argument_list|)
expr_stmt|;
comment|/* Upcase source. */
if|if
condition|(
name|c
operator|!=
operator|*
name|str_uc
condition|)
block|{
if|if
condition|(
name|c
operator|<
operator|*
name|str_uc
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
case|case
name|FFE_caseUPPER
case|:
name|i
operator|=
name|strncmp
argument_list|(
name|var
argument_list|,
name|str_uc
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFE_caseLOWER
case|:
name|i
operator|=
name|strncmp
argument_list|(
name|var
argument_list|,
name|str_lc
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFE_caseINITCAP
case|:
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|++
name|var
operator|,
operator|++
name|str_ic
operator|,
operator|++
name|str_uc
operator|,
operator|--
name|len
control|)
block|{
if|if
condition|(
operator|*
name|var
operator|!=
operator|*
name|str_ic
condition|)
block|{
name|c
operator|=
name|ffesrc_toupper
argument_list|(
operator|*
name|var
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|c
operator|==
operator|*
name|str_uc
operator|)
condition|)
block|{
comment|/* Skip past equivalent (case-ins) chars. */
operator|--
name|len
operator|,
operator|++
name|var
operator|,
operator|++
name|str_uc
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|c
operator|=
name|ffesrc_toupper
argument_list|(
operator|*
name|var
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|c
operator|<
operator|*
name|str_uc
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
default|default:
name|assert
argument_list|(
literal|"bad case value"
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_function

end_unit

