begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This file contains the definitions and documentation for the common    tree codes used in the GNU C and C++ compilers (see c-common.def    for the standard codes).      Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.    Written by Benjamin Chelf (chelf@codesourcery.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_comment
comment|/* If non-NULL, the address of a language-specific function for    expanding statements.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*lang_expand_stmt
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If non-NULL, the address of a language-specific function for    expanding a DECL_STMT.  After the language-independent cases are    handled, this function will be called.  If this function is not    defined, it is assumed that declarations other than those for    variables and labels do not require any RTL generation.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*lang_expand_decl_stmt
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Create an empty statement tree rooted at T.  */
end_comment

begin_function
name|void
name|begin_stmt_tree
parameter_list|(
name|t
parameter_list|)
name|tree
modifier|*
name|t
decl_stmt|;
block|{
comment|/* We create a trivial EXPR_STMT so that last_tree is never NULL in      what follows.  We remove the extraneous statement in      finish_stmt_tree.  */
operator|*
name|t
operator|=
name|build_nt
argument_list|(
name|EXPR_STMT
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
name|last_tree
operator|=
operator|*
name|t
expr_stmt|;
name|last_expr_type
operator|=
name|NULL_TREE
expr_stmt|;
name|last_expr_filename
operator|=
name|input_filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/* T is a statement.  Add it to the statement-tree.  */
end_comment

begin_function
name|tree
name|add_stmt
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|input_filename
operator|!=
name|last_expr_filename
condition|)
block|{
comment|/* If the filename has changed, also add in a FILE_STMT.  Do a string 	 compare first, though, as it might be an equivalent string.  */
name|int
name|add
init|=
operator|(
name|strcmp
argument_list|(
name|input_filename
argument_list|,
name|last_expr_filename
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|last_expr_filename
operator|=
name|input_filename
expr_stmt|;
if|if
condition|(
name|add
condition|)
block|{
name|tree
name|pos
init|=
name|build_nt
argument_list|(
name|FILE_STMT
argument_list|,
name|get_identifier
argument_list|(
name|input_filename
argument_list|)
argument_list|)
decl_stmt|;
name|add_stmt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add T to the statement-tree.  */
name|TREE_CHAIN
argument_list|(
name|last_tree
argument_list|)
operator|=
name|t
expr_stmt|;
name|last_tree
operator|=
name|t
expr_stmt|;
comment|/* When we expand a statement-tree, we must know whether or not the      statements are full-expressions.  We record that fact here.  */
name|STMT_IS_FULL_EXPR_P
argument_list|(
name|last_tree
argument_list|)
operator|=
name|stmts_are_full_exprs_p
argument_list|()
expr_stmt|;
comment|/* Keep track of the number of statements in this function.  */
if|if
condition|(
name|current_function_decl
condition|)
operator|++
name|DECL_NUM_STMTS
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Create a declaration statement for the declaration given by the    DECL.  */
end_comment

begin_function
name|void
name|add_decl_stmt
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|decl_stmt
decl_stmt|;
comment|/* We need the type to last until instantiation time.  */
name|decl_stmt
operator|=
name|build_stmt
argument_list|(
name|DECL_STMT
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|decl_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a scope-statement to the statement-tree.  BEGIN_P indicates    whether this statements opens or closes a scope.  PARTIAL_P is true    for a partial scope, i.e, the scope that begins after a label when    an object that needs a cleanup is created.  If BEGIN_P is nonzero,    returns a new TREE_LIST representing the top of the SCOPE_STMT    stack.  The TREE_PURPOSE is the new SCOPE_STMT.  If BEGIN_P is    zero, returns a TREE_LIST whose TREE_VALUE is the new SCOPE_STMT,    and whose TREE_PURPOSE is the matching SCOPE_STMT with    SCOPE_BEGIN_P set.  */
end_comment

begin_function
name|tree
name|add_scope_stmt
parameter_list|(
name|begin_p
parameter_list|,
name|partial_p
parameter_list|)
name|int
name|begin_p
decl_stmt|;
name|int
name|partial_p
decl_stmt|;
block|{
name|tree
modifier|*
name|stack_ptr
init|=
name|current_scope_stmt_stack
argument_list|()
decl_stmt|;
name|tree
name|ss
decl_stmt|;
name|tree
name|top
init|=
operator|*
name|stack_ptr
decl_stmt|;
comment|/* Build the statement.  */
name|ss
operator|=
name|build_stmt
argument_list|(
name|SCOPE_STMT
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SCOPE_BEGIN_P
argument_list|(
name|ss
argument_list|)
operator|=
name|begin_p
expr_stmt|;
name|SCOPE_PARTIAL_P
argument_list|(
name|ss
argument_list|)
operator|=
name|partial_p
expr_stmt|;
comment|/* Keep the scope stack up to date.  */
if|if
condition|(
name|begin_p
condition|)
block|{
name|top
operator|=
name|tree_cons
argument_list|(
name|ss
argument_list|,
name|NULL_TREE
argument_list|,
name|top
argument_list|)
expr_stmt|;
operator|*
name|stack_ptr
operator|=
name|top
expr_stmt|;
block|}
else|else
block|{
name|TREE_VALUE
argument_list|(
name|top
argument_list|)
operator|=
name|ss
expr_stmt|;
operator|*
name|stack_ptr
operator|=
name|TREE_CHAIN
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new statement to the statement-tree.  */
name|add_stmt
argument_list|(
name|ss
argument_list|)
expr_stmt|;
return|return
name|top
return|;
block|}
end_function

begin_comment
comment|/* Finish the statement tree rooted at T.  */
end_comment

begin_function
name|void
name|finish_stmt_tree
parameter_list|(
name|t
parameter_list|)
name|tree
modifier|*
name|t
decl_stmt|;
block|{
name|tree
name|stmt
decl_stmt|;
comment|/* Remove the fake extra statement added in begin_stmt_tree.  */
name|stmt
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
name|stmt
expr_stmt|;
name|last_tree
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|cfun
operator|&&
name|stmt
condition|)
block|{
comment|/* The line-number recorded in the outermost statement in a function 	 is the line number of the end of the function.  */
name|STMT_LINENO
argument_list|(
name|stmt
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|STMT_LINENO_FOR_FN_P
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build a generic statement based on the given type of node and    arguments. Similar to `build_nt', except that we set    STMT_LINENO to be the current line number.  */
end_comment

begin_comment
comment|/* ??? This should be obsolete with the lineno_stmt productions    in the grammar.  */
end_comment

begin_decl_stmt
name|tree
name|build_stmt
name|VPARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
name|code
operator|,
operator|...
operator|)
argument_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VA_OPEN
argument_list|(
name|p
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
expr|enum
name|tree_code
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|STMT_LINENO
argument_list|(
name|t
argument_list|)
operator|=
name|lineno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Some statements, like for-statements or if-statements, require a    condition.  This condition can be a declaration.  If T is such a    declaration it is processed, and an expression appropriate to use    as the condition is returned.  Otherwise, T itself is returned.  */
end_comment

begin_function
name|tree
name|expand_cond
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|expand_stmt
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
return|;
block|}
else|else
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Create RTL for the local static variable DECL.  */
end_comment

begin_function
name|void
name|make_rtl_for_local_static
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|asmspec
init|=
name|NULL
decl_stmt|;
comment|/* If we inlined this variable, we could see it's declaration      again.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* If the DECL_ASSEMBLER_NAME is not the same as the DECL_NAME, then      either we already created RTL for this DECL (and since it was a      local variable, its DECL_ASSEMBLER_NAME got hacked up to prevent      clashes with other local statics with the same name by a previous      call to make_decl_rtl), or the user explicitly requested a      particular assembly name for this variable, using the GNU      extension for this purpose:         int i asm ("j");       There's no way to know which case we're in, here.  But, it turns      out we're safe.  If there's already RTL, then      rest_of_decl_compilation ignores the ASMSPEC parameter, so we      may as well not pass it in.  If there isn't RTL, then we didn't      already create RTL, which means that the modification to      DECL_ASSEMBLER_NAME came only via the explicit extension.  */
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
name|asmspec
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
comment|/*top_level=*/
literal|0
argument_list|,
comment|/*at_end=*/
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Let the back-end know about DECL.  */
end_comment

begin_function
name|void
name|emit_local_var
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* Create RTL for this variable.  */
if|if
condition|(
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_C_HARD_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* The user specified an assembler name for this variable. 	   Set that up now.  */
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
comment|/*top_level=*/
literal|0
argument_list|,
comment|/*at_end=*/
literal|0
argument_list|)
expr_stmt|;
else|else
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Actually do the initialization.  */
if|if
condition|(
name|stmts_are_full_exprs_p
argument_list|()
condition|)
name|expand_start_target_temps
argument_list|()
expr_stmt|;
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts_are_full_exprs_p
argument_list|()
condition|)
name|expand_end_target_temps
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper for generating the RTL at the beginning of a scope.  */
end_comment

begin_function
name|void
name|genrtl_do_pushlevel
parameter_list|()
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for DESTINATION, which is a GOTO_STMT.  */
end_comment

begin_function
name|void
name|genrtl_goto_stmt
parameter_list|(
name|destination
parameter_list|)
name|tree
name|destination
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|destination
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We warn about unused labels with -Wunused.  That means we have to      mark the used labels as used.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|destination
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|TREE_USED
argument_list|(
name|destination
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|destination
argument_list|)
operator|==
name|LABEL_DECL
condition|)
block|{
name|label_rtx
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|expand_goto
argument_list|(
name|destination
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_computed_goto
argument_list|(
name|destination
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for EXPR, which is an EXPR_STMT.  Provided just    for backward compatibility.  genrtl_expr_stmt_value() should be    used for new code.  */
end_comment

begin_function
name|void
name|genrtl_expr_stmt
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|genrtl_expr_stmt_value
argument_list|(
name|expr
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for EXPR, which is an EXPR_STMT.  WANT_VALUE tells    whether to (1) save the value of the expression, (0) discard it or    (-1) use expr_stmts_for_value to tell.  The use of -1 is    deprecated, and retained only for backward compatibility.    MAYBE_LAST is non-zero if this EXPR_STMT might be the last statement    in expression statement.  */
end_comment

begin_function
name|void
name|genrtl_expr_stmt_value
parameter_list|(
name|expr
parameter_list|,
name|want_value
parameter_list|,
name|maybe_last
parameter_list|)
name|tree
name|expr
decl_stmt|;
name|int
name|want_value
decl_stmt|,
name|maybe_last
decl_stmt|;
block|{
if|if
condition|(
name|expr
operator|!=
name|NULL_TREE
condition|)
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts_are_full_exprs_p
argument_list|()
condition|)
name|expand_start_target_temps
argument_list|()
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|error_mark_node
condition|)
name|expand_expr_stmt_value
argument_list|(
name|expr
argument_list|,
name|want_value
argument_list|,
name|maybe_last
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts_are_full_exprs_p
argument_list|()
condition|)
name|expand_end_target_temps
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a DECL_STMT.  */
end_comment

begin_function
name|void
name|genrtl_decl_stmt
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|decl
operator|=
name|DECL_STMT_DECL
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If this is a declaration for an automatic local      variable, initialize it.  Note that we might also see a      declaration for a namespace-scope object (declared with      `extern').  We don't have to handle the initialization      of those objects here; they can only be declarations,      rather than definitions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Let the back-end know about this variable.  */
if|if
condition|(
operator|!
name|anon_aggr_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|emit_local_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|expand_anon_union_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|DECL_ANON_UNION_ELEMS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|make_rtl_for_local_static
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|LABEL_DECL
operator|&&
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|decl
argument_list|)
condition|)
name|declare_nonlocal_label
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lang_expand_decl_stmt
condition|)
call|(
modifier|*
name|lang_expand_decl_stmt
call|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is an IF_STMT.  */
end_comment

begin_function
name|void
name|genrtl_if_stmt
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|cond
decl_stmt|;
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
name|cond
operator|=
name|expand_cond
argument_list|(
name|IF_COND
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|THEN_CLAUSE
argument_list|(
name|t
argument_list|)
condition|)
name|expand_stmt
argument_list|(
name|THEN_CLAUSE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELSE_CLAUSE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|expand_start_else
argument_list|()
expr_stmt|;
name|expand_stmt
argument_list|(
name|ELSE_CLAUSE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a WHILE_STMT.  */
end_comment

begin_function
name|void
name|genrtl_while_stmt
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|cond
decl_stmt|;
name|emit_nop
argument_list|()
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_start_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
name|cond
operator|=
name|expand_cond
argument_list|(
name|WHILE_COND
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_exit_loop_top_cond
argument_list|(
literal|0
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
name|expand_stmt
argument_list|(
name|WHILE_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a DO_STMT.  */
end_comment

begin_function
name|void
name|genrtl_do_stmt
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|cond
init|=
name|DO_COND
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Recognize the common special-case of do { ... } while (0) and do      not emit the loop widgetry in this case.  In particular this      avoids cluttering the rtl with dummy loop notes, which can affect      alignment of adjacent labels.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|expand_start_null_loop
argument_list|()
expr_stmt|;
name|expand_stmt
argument_list|(
name|DO_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_null_loop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|emit_nop
argument_list|()
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_start_loop_continue_elsewhere
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|expand_stmt
argument_list|(
name|DO_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_loop_continue_here
argument_list|()
expr_stmt|;
name|cond
operator|=
name|expand_cond
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_exit_loop_if_false
argument_list|(
literal|0
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build the node for a return statement and return it.  */
end_comment

begin_function
name|tree
name|build_return_stmt
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
return|return
operator|(
name|build_stmt
argument_list|(
name|RETURN_STMT
argument_list|,
name|expr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for STMT, which is a RETURN_STMT.  */
end_comment

begin_function
name|void
name|genrtl_return_stmt
parameter_list|(
name|stmt
parameter_list|)
name|tree
name|stmt
decl_stmt|;
block|{
name|tree
name|expr
decl_stmt|;
name|expr
operator|=
name|RETURN_EXPR
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expr
condition|)
name|expand_null_return
argument_list|()
expr_stmt|;
else|else
block|{
name|expand_start_target_temps
argument_list|()
expr_stmt|;
name|expand_return
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expand_end_target_temps
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a FOR_STMT.  */
end_comment

begin_function
name|void
name|genrtl_for_stmt
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|cond
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_filename
decl_stmt|;
name|int
name|saved_lineno
decl_stmt|;
if|if
condition|(
name|NEW_FOR_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
name|expand_stmt
argument_list|(
name|FOR_INIT_STMT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Expand the initialization.  */
name|emit_nop
argument_list|()
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_start_loop_continue_elsewhere
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
name|cond
operator|=
name|expand_cond
argument_list|(
name|FOR_COND
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save the filename and line number so that we expand the FOR_EXPR      we can reset them back to the saved values.  */
name|saved_filename
operator|=
name|input_filename
expr_stmt|;
name|saved_lineno
operator|=
name|lineno
expr_stmt|;
comment|/* Expand the condition.  */
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
condition|)
name|expand_exit_loop_top_cond
argument_list|(
literal|0
argument_list|,
name|cond
argument_list|)
expr_stmt|;
comment|/* Expand the body.  */
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
name|expand_stmt
argument_list|(
name|FOR_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Expand the increment expression.  */
name|input_filename
operator|=
name|saved_filename
expr_stmt|;
name|lineno
operator|=
name|saved_lineno
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_loop_continue_here
argument_list|()
expr_stmt|;
if|if
condition|(
name|FOR_EXPR
argument_list|(
name|t
argument_list|)
condition|)
name|genrtl_expr_stmt
argument_list|(
name|FOR_EXPR
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a break statement node and return it.  */
end_comment

begin_function
name|tree
name|build_break_stmt
parameter_list|()
block|{
return|return
operator|(
name|build_stmt
argument_list|(
name|BREAK_STMT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for a BREAK_STMT.  */
end_comment

begin_function
name|void
name|genrtl_break_stmt
parameter_list|()
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_exit_something
argument_list|()
condition|)
name|error
argument_list|(
literal|"break statement not within loop or switch"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a continue statement node and return it.  */
end_comment

begin_function
name|tree
name|build_continue_stmt
parameter_list|()
block|{
return|return
operator|(
name|build_stmt
argument_list|(
name|CONTINUE_STMT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for a CONTINUE_STMT.  */
end_comment

begin_function
name|void
name|genrtl_continue_stmt
parameter_list|()
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_continue_loop
argument_list|(
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|"continue statement not within a loop"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a SCOPE_STMT.  */
end_comment

begin_function
name|void
name|genrtl_scope_stmt
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|block
init|=
name|SCOPE_STMT_BLOCK
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SCOPE_NO_CLEANUPS_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCOPE_BEGIN_P
argument_list|(
name|t
argument_list|)
condition|)
name|expand_start_bindings_and_block
argument_list|(
literal|2
operator|*
name|SCOPE_NULLIFIED_P
argument_list|(
name|t
argument_list|)
argument_list|,
name|block
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SCOPE_END_P
argument_list|(
name|t
argument_list|)
condition|)
name|expand_end_bindings
argument_list|(
name|NULL_TREE
argument_list|,
operator|!
name|SCOPE_NULLIFIED_P
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|SCOPE_NULLIFIED_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
operator|(
name|SCOPE_BEGIN_P
argument_list|(
name|t
argument_list|)
condition|?
name|NOTE_INSN_BLOCK_BEG
else|:
name|NOTE_INSN_BLOCK_END
operator|)
argument_list|)
decl_stmt|;
name|NOTE_BLOCK
argument_list|(
name|note
argument_list|)
operator|=
name|block
expr_stmt|;
block|}
comment|/* If we're at the end of a scope that contains inlined nested      functions, we have to decide whether or not to write them out.  */
if|if
condition|(
name|block
operator|&&
name|SCOPE_END_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|fn
decl_stmt|;
for|for
control|(
name|fn
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|==
name|current_function_decl
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|fn
argument_list|)
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|push_function_context
argument_list|()
expr_stmt|;
name|output_inline_function
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_function_context
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a SWITCH_STMT.  */
end_comment

begin_function
name|void
name|genrtl_switch_stmt
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|cond
decl_stmt|;
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
name|cond
operator|=
name|expand_cond
argument_list|(
name|SWITCH_COND
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|error_mark_node
condition|)
comment|/* The code is in error, but we don't want expand_end_case to        crash.  */
name|cond
operator|=
name|boolean_false_node
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_start_case
argument_list|(
literal|1
argument_list|,
name|cond
argument_list|,
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|,
literal|"switch statement"
argument_list|)
expr_stmt|;
name|expand_stmt
argument_list|(
name|SWITCH_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_case
argument_list|(
name|cond
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a CASE_LABEL tree node and return it.  */
end_comment

begin_function
name|tree
name|build_case_label
parameter_list|(
name|low_value
parameter_list|,
name|high_value
parameter_list|,
name|label_decl
parameter_list|)
name|tree
name|low_value
decl_stmt|;
name|tree
name|high_value
decl_stmt|;
name|tree
name|label_decl
decl_stmt|;
block|{
return|return
name|build_stmt
argument_list|(
name|CASE_LABEL
argument_list|,
name|low_value
argument_list|,
name|high_value
argument_list|,
name|label_decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for a CASE_LABEL.  */
end_comment

begin_function
name|void
name|genrtl_case_label
parameter_list|(
name|case_label
parameter_list|)
name|tree
name|case_label
decl_stmt|;
block|{
name|tree
name|duplicate
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
name|cleanup
operator|=
name|last_cleanup_this_contour
argument_list|()
expr_stmt|;
if|if
condition|(
name|cleanup
condition|)
block|{
specifier|static
name|int
name|explained
init|=
literal|0
decl_stmt|;
name|warning_with_decl
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|cleanup
argument_list|)
argument_list|,
literal|"destructor needed for `%#D'"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"where case label appears here"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained
condition|)
block|{
name|warning
argument_list|(
literal|"(enclose actions of previous case statements requiring destructors in their own scope.)"
argument_list|)
expr_stmt|;
name|explained
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|add_case_node
argument_list|(
name|CASE_LOW
argument_list|(
name|case_label
argument_list|)
argument_list|,
name|CASE_HIGH
argument_list|(
name|case_label
argument_list|)
argument_list|,
name|CASE_LABEL_DECL
argument_list|(
name|case_label
argument_list|)
argument_list|,
operator|&
name|duplicate
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a COMPOUND_STMT.  */
end_comment

begin_function
name|void
name|genrtl_compound_stmt
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|struct
name|nesting
modifier|*
name|n
init|=
name|current_nesting_level
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|expand_stmt
argument_list|(
name|COMPOUND_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Make sure that we've pushed and popped the same number of levels.  */
if|if
condition|(
operator|!
name|COMPOUND_STMT_NO_SCOPE
argument_list|(
name|t
argument_list|)
operator|&&
name|n
operator|!=
name|current_nesting_level
argument_list|()
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Generate the RTL for an ASM_STMT.  */
end_comment

begin_function
name|void
name|genrtl_asm_stmt
parameter_list|(
name|cv_qualifier
parameter_list|,
name|string
parameter_list|,
name|output_operands
parameter_list|,
name|input_operands
parameter_list|,
name|clobbers
parameter_list|,
name|asm_input_p
parameter_list|)
name|tree
name|cv_qualifier
decl_stmt|;
name|tree
name|string
decl_stmt|;
name|tree
name|output_operands
decl_stmt|;
name|tree
name|input_operands
decl_stmt|;
name|tree
name|clobbers
decl_stmt|;
name|int
name|asm_input_p
decl_stmt|;
block|{
if|if
condition|(
name|cv_qualifier
operator|!=
name|NULL_TREE
operator|&&
name|cv_qualifier
operator|!=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
block|{
name|warning
argument_list|(
literal|"%s qualifier ignored on asm"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cv_qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|cv_qualifier
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_input_p
condition|)
name|expand_asm
argument_list|(
name|string
argument_list|)
expr_stmt|;
else|else
name|c_expand_asm_operands
argument_list|(
name|string
argument_list|,
name|output_operands
argument_list|,
name|input_operands
argument_list|,
name|clobbers
argument_list|,
name|cv_qualifier
operator|!=
name|NULL_TREE
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for a DECL_CLEANUP.  */
end_comment

begin_function
name|void
name|genrtl_decl_cleanup
parameter_list|(
name|decl
parameter_list|,
name|cleanup
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|decl
operator|||
operator|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|)
condition|)
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We're about to expand T, a statement.  Set up appropriate context    for the substitution.  */
end_comment

begin_function
name|void
name|prep_stmt
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|STMT_LINENO_FOR_FN_P
argument_list|(
name|t
argument_list|)
condition|)
name|lineno
operator|=
name|STMT_LINENO
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
name|STMT_IS_FULL_EXPR_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for the statement T, its substatements, and any    other statements at its nesting level.  */
end_comment

begin_function
name|void
name|expand_stmt
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
while|while
condition|(
name|t
operator|&&
name|t
operator|!=
name|error_mark_node
condition|)
block|{
name|int
name|saved_stmts_are_full_exprs_p
decl_stmt|;
comment|/* Set up context appropriately for handling this statement.  */
name|saved_stmts_are_full_exprs_p
operator|=
name|stmts_are_full_exprs_p
argument_list|()
expr_stmt|;
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FILE_STMT
case|:
name|input_filename
operator|=
name|FILE_STMT_FILENAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN_STMT
case|:
name|genrtl_return_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPR_STMT
case|:
name|genrtl_expr_stmt_value
argument_list|(
name|EXPR_STMT_EXPR
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_ADDRESSABLE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|NULL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|SCOPE_STMT
operator|&&
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECL_STMT
case|:
name|genrtl_decl_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOR_STMT
case|:
name|genrtl_for_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|WHILE_STMT
case|:
name|genrtl_while_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DO_STMT
case|:
name|genrtl_do_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|IF_STMT
case|:
name|genrtl_if_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_STMT
case|:
name|genrtl_compound_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|BREAK_STMT
case|:
name|genrtl_break_stmt
argument_list|()
expr_stmt|;
break|break;
case|case
name|CONTINUE_STMT
case|:
name|genrtl_continue_stmt
argument_list|()
expr_stmt|;
break|break;
case|case
name|SWITCH_STMT
case|:
name|genrtl_switch_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CASE_LABEL
case|:
name|genrtl_case_label
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_STMT
case|:
name|expand_label
argument_list|(
name|LABEL_STMT_LABEL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GOTO_STMT
case|:
name|genrtl_goto_stmt
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_STMT
case|:
name|genrtl_asm_stmt
argument_list|(
name|ASM_CV_QUAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|ASM_STRING
argument_list|(
name|t
argument_list|)
argument_list|,
name|ASM_OUTPUTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|ASM_INPUTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|ASM_CLOBBERS
argument_list|(
name|t
argument_list|)
argument_list|,
name|ASM_INPUT_P
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCOPE_STMT
case|:
name|genrtl_scope_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|lang_expand_stmt
condition|)
call|(
modifier|*
name|lang_expand_stmt
call|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* Restore saved state.  */
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
name|saved_stmts_are_full_exprs_p
expr_stmt|;
comment|/* Go on to the next statement in this scope.  */
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

