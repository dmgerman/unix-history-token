begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This file contains the definitions and documentation for the common    tree codes used in the GNU C and C++ compilers (see c-common.def    for the standard codes).    Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.    Written by Benjamin Chelf (chelf@codesourcery.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_comment
comment|/* In order for the format checking to accept the C frontend    diagnostic framework extensions, you must define this token before    including toplev.h.  */
end_comment

begin_define
define|#
directive|define
name|GCC_DIAG_STYLE
value|__gcc_cdiag__
end_define

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"predict.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_comment
comment|/* If non-NULL, the address of a language-specific function for    expanding statements.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|lang_expand_stmt
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* If non-NULL, the address of a language-specific function for    expanding a DECL_STMT.  After the language-independent cases are    handled, this function will be called.  If this function is not    defined, it is assumed that declarations other than those for    variables and labels do not require any RTL generation.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|lang_expand_decl_stmt
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|find_reachable_label_1
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|find_reachable_label
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|expand_unreachable_if_stmt
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|expand_unreachable_stmt
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|genrtl_do_stmt_1
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Create an empty statement tree rooted at T.  */
end_comment

begin_function
name|void
name|begin_stmt_tree
parameter_list|(
name|tree
modifier|*
name|t
parameter_list|)
block|{
comment|/* We create a trivial EXPR_STMT so that last_tree is never NULL in      what follows.  We remove the extraneous statement in      finish_stmt_tree.  */
operator|*
name|t
operator|=
name|build_nt
argument_list|(
name|EXPR_STMT
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
name|last_tree
operator|=
operator|*
name|t
expr_stmt|;
name|last_expr_type
operator|=
name|NULL_TREE
expr_stmt|;
name|last_expr_filename
operator|=
name|input_filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/* T is a statement.  Add it to the statement-tree.  */
end_comment

begin_function
name|tree
name|add_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|input_filename
operator|!=
name|last_expr_filename
condition|)
block|{
comment|/* If the filename has changed, also add in a FILE_STMT.  Do a string 	 compare first, though, as it might be an equivalent string.  */
name|int
name|add
init|=
operator|(
name|strcmp
argument_list|(
name|input_filename
argument_list|,
name|last_expr_filename
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|last_expr_filename
operator|=
name|input_filename
expr_stmt|;
if|if
condition|(
name|add
condition|)
block|{
name|tree
name|pos
init|=
name|build_nt
argument_list|(
name|FILE_STMT
argument_list|,
name|get_identifier
argument_list|(
name|input_filename
argument_list|)
argument_list|)
decl_stmt|;
name|add_stmt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add T to the statement-tree.  */
name|TREE_CHAIN
argument_list|(
name|last_tree
argument_list|)
operator|=
name|t
expr_stmt|;
name|last_tree
operator|=
name|t
expr_stmt|;
comment|/* When we expand a statement-tree, we must know whether or not the      statements are full-expressions.  We record that fact here.  */
name|STMT_IS_FULL_EXPR_P
argument_list|(
name|last_tree
argument_list|)
operator|=
name|stmts_are_full_exprs_p
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Create a declaration statement for the declaration given by the    DECL.  */
end_comment

begin_function
name|void
name|add_decl_stmt
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|decl_stmt
decl_stmt|;
comment|/* We need the type to last until instantiation time.  */
name|decl_stmt
operator|=
name|build_stmt
argument_list|(
name|DECL_STMT
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|decl_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a scope-statement to the statement-tree.  BEGIN_P indicates    whether this statements opens or closes a scope.  PARTIAL_P is true    for a partial scope, i.e, the scope that begins after a label when    an object that needs a cleanup is created.  If BEGIN_P is nonzero,    returns a new TREE_LIST representing the top of the SCOPE_STMT    stack.  The TREE_PURPOSE is the new SCOPE_STMT.  If BEGIN_P is    zero, returns a TREE_LIST whose TREE_VALUE is the new SCOPE_STMT,    and whose TREE_PURPOSE is the matching SCOPE_STMT with    SCOPE_BEGIN_P set.  */
end_comment

begin_function
name|tree
name|add_scope_stmt
parameter_list|(
name|int
name|begin_p
parameter_list|,
name|int
name|partial_p
parameter_list|)
block|{
name|tree
modifier|*
name|stack_ptr
init|=
name|current_scope_stmt_stack
argument_list|()
decl_stmt|;
name|tree
name|ss
decl_stmt|;
name|tree
name|top
init|=
operator|*
name|stack_ptr
decl_stmt|;
comment|/* Build the statement.  */
name|ss
operator|=
name|build_stmt
argument_list|(
name|SCOPE_STMT
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SCOPE_BEGIN_P
argument_list|(
name|ss
argument_list|)
operator|=
name|begin_p
expr_stmt|;
name|SCOPE_PARTIAL_P
argument_list|(
name|ss
argument_list|)
operator|=
name|partial_p
expr_stmt|;
comment|/* Keep the scope stack up to date.  */
if|if
condition|(
name|begin_p
condition|)
block|{
name|top
operator|=
name|tree_cons
argument_list|(
name|ss
argument_list|,
name|NULL_TREE
argument_list|,
name|top
argument_list|)
expr_stmt|;
operator|*
name|stack_ptr
operator|=
name|top
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|partial_p
operator|!=
name|SCOPE_PARTIAL_P
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|top
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|top
argument_list|)
operator|=
name|ss
expr_stmt|;
operator|*
name|stack_ptr
operator|=
name|TREE_CHAIN
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new statement to the statement-tree.  */
name|add_stmt
argument_list|(
name|ss
argument_list|)
expr_stmt|;
return|return
name|top
return|;
block|}
end_function

begin_comment
comment|/* Finish the statement tree rooted at T.  */
end_comment

begin_function
name|void
name|finish_stmt_tree
parameter_list|(
name|tree
modifier|*
name|t
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
comment|/* Remove the fake extra statement added in begin_stmt_tree.  */
name|stmt
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
name|stmt
expr_stmt|;
name|last_tree
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|cfun
operator|&&
name|stmt
condition|)
block|{
comment|/* The line-number recorded in the outermost statement in a function 	 is the line number of the end of the function.  */
name|STMT_LINENO
argument_list|(
name|stmt
argument_list|)
operator|=
name|input_line
expr_stmt|;
name|STMT_LINENO_FOR_FN_P
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build a generic statement based on the given type of node and    arguments. Similar to `build_nt', except that we set    STMT_LINENO to be the current line number.  */
end_comment

begin_comment
comment|/* ??? This should be obsolete with the lineno_stmt productions    in the grammar.  */
end_comment

begin_function
name|tree
name|build_stmt
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
modifier|...
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|va_list
name|p
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|STMT_LINENO
argument_list|(
name|t
argument_list|)
operator|=
name|input_line
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Some statements, like for-statements or if-statements, require a    condition.  This condition can be a declaration.  If T is such a    declaration it is processed, and an expression appropriate to use    as the condition is returned.  Otherwise, T itself is returned.  */
end_comment

begin_function
name|tree
name|expand_cond
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|expand_stmt
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
return|;
block|}
else|else
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Create RTL for the local static variable DECL.  */
end_comment

begin_function
name|void
name|make_rtl_for_local_static
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|asmspec
init|=
name|NULL
decl_stmt|;
comment|/* If we inlined this variable, we could see it's declaration      again.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* If the DECL_ASSEMBLER_NAME is not the same as the DECL_NAME, then      either we already created RTL for this DECL (and since it was a      local variable, its DECL_ASSEMBLER_NAME got hacked up to prevent      clashes with other local statics with the same name by a previous      call to make_decl_rtl), or the user explicitly requested a      particular assembly name for this variable, using the GNU      extension for this purpose:         int i asm ("j");       There's no way to know which case we're in, here.  But, it turns      out we're safe.  If there's already RTL, then      rest_of_decl_compilation ignores the ASMSPEC parameter, so we      may as well not pass it in.  If there isn't RTL, then we didn't      already create RTL, which means that the modification to      DECL_ASSEMBLER_NAME came only via the explicit extension.  */
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
name|asmspec
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
comment|/*top_level=*/
literal|0
argument_list|,
comment|/*at_end=*/
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Let the back-end know about DECL.  */
end_comment

begin_function
name|void
name|emit_local_var
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* Create RTL for this variable.  */
if|if
condition|(
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_C_HARD_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* The user specified an assembler name for this variable. 	   Set that up now.  */
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
comment|/*top_level=*/
literal|0
argument_list|,
comment|/*at_end=*/
literal|0
argument_list|)
expr_stmt|;
else|else
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Actually do the initialization.  */
if|if
condition|(
name|stmts_are_full_exprs_p
argument_list|()
condition|)
name|expand_start_target_temps
argument_list|()
expr_stmt|;
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts_are_full_exprs_p
argument_list|()
condition|)
name|expand_end_target_temps
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Helper for generating the RTL at the beginning of a scope.  */
end_comment

begin_function
name|void
name|genrtl_do_pushlevel
parameter_list|(
name|void
parameter_list|)
block|{
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for DESTINATION, which is a GOTO_STMT.  */
end_comment

begin_function
name|void
name|genrtl_goto_stmt
parameter_list|(
name|tree
name|destination
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|destination
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We warn about unused labels with -Wunused.  That means we have to      mark the used labels as used.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|destination
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|TREE_USED
argument_list|(
name|destination
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|destination
argument_list|)
operator|==
name|LABEL_DECL
condition|)
block|{
name|label_rtx
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|expand_goto
argument_list|(
name|destination
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_computed_goto
argument_list|(
name|destination
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for EXPR, which is an EXPR_STMT.  Provided just    for backward compatibility.  genrtl_expr_stmt_value() should be    used for new code.  */
end_comment

begin_function
name|void
name|genrtl_expr_stmt
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|genrtl_expr_stmt_value
argument_list|(
name|expr
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for EXPR, which is an EXPR_STMT.  WANT_VALUE tells    whether to (1) save the value of the expression, (0) discard it or    (-1) use expr_stmts_for_value to tell.  The use of -1 is    deprecated, and retained only for backward compatibility.    MAYBE_LAST is nonzero if this EXPR_STMT might be the last statement    in expression statement.  */
end_comment

begin_function
name|void
name|genrtl_expr_stmt_value
parameter_list|(
name|tree
name|expr
parameter_list|,
name|int
name|want_value
parameter_list|,
name|int
name|maybe_last
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|!=
name|NULL_TREE
condition|)
block|{
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts_are_full_exprs_p
argument_list|()
condition|)
name|expand_start_target_temps
argument_list|()
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|error_mark_node
condition|)
name|expand_expr_stmt_value
argument_list|(
name|expr
argument_list|,
name|want_value
argument_list|,
name|maybe_last
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts_are_full_exprs_p
argument_list|()
condition|)
name|expand_end_target_temps
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a DECL_STMT.  */
end_comment

begin_function
name|void
name|genrtl_decl_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
name|decl
operator|=
name|DECL_STMT_DECL
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If this is a declaration for an automatic local      variable, initialize it.  Note that we might also see a      declaration for a namespace-scope object (declared with      `extern').  We don't have to handle the initialization      of those objects here; they can only be declarations,      rather than definitions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Let the back-end know about this variable.  */
if|if
condition|(
operator|!
name|anon_aggr_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|emit_local_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|expand_anon_union_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|DECL_ANON_UNION_ELEMS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|make_rtl_for_local_static
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|LABEL_DECL
operator|&&
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|decl
argument_list|)
condition|)
name|declare_nonlocal_label
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lang_expand_decl_stmt
condition|)
call|(
modifier|*
name|lang_expand_decl_stmt
call|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is an IF_STMT.  */
end_comment

begin_function
name|void
name|genrtl_if_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|cond
decl_stmt|;
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
name|cond
operator|=
name|expand_cond
argument_list|(
name|IF_COND
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|THEN_CLAUSE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|nextt
init|=
name|THEN_CLAUSE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|cond
operator|&&
name|integer_zerop
argument_list|(
name|cond
argument_list|)
condition|)
name|nextt
operator|=
name|expand_unreachable_stmt
argument_list|(
name|nextt
argument_list|,
name|warn_notreached
argument_list|)
expr_stmt|;
name|expand_stmt
argument_list|(
name|nextt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ELSE_CLAUSE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|nextt
init|=
name|ELSE_CLAUSE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|expand_start_else
argument_list|()
expr_stmt|;
if|if
condition|(
name|cond
operator|&&
name|integer_nonzerop
argument_list|(
name|cond
argument_list|)
condition|)
name|nextt
operator|=
name|expand_unreachable_stmt
argument_list|(
name|nextt
argument_list|,
name|warn_notreached
argument_list|)
expr_stmt|;
name|expand_stmt
argument_list|(
name|nextt
argument_list|)
expr_stmt|;
block|}
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a WHILE_STMT.  */
end_comment

begin_function
name|void
name|genrtl_while_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|cond
init|=
name|WHILE_COND
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
name|expand_start_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
if|if
condition|(
name|cond
operator|&&
operator|!
name|integer_nonzerop
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|cond
operator|=
name|expand_cond
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
name|expand_exit_loop_top_cond
argument_list|(
literal|0
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
block|}
name|expand_stmt
argument_list|(
name|WHILE_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for a DO_STMT with condition COND and loop BODY    body.  This is reused for expanding unreachable WHILE_STMTS.  */
end_comment

begin_function
specifier|static
name|void
name|genrtl_do_stmt_1
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|body
parameter_list|)
block|{
comment|/* Recognize the common special-case of do { ... } while (0) and do      not emit the loop widgetry in this case.  In particular this      avoids cluttering the rtl with dummy loop notes, which can affect      alignment of adjacent labels.  COND can be NULL due to parse      errors.  */
if|if
condition|(
operator|!
name|cond
operator|||
name|integer_zerop
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|expand_start_null_loop
argument_list|()
expr_stmt|;
name|expand_stmt
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|expand_end_null_loop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_nonzerop
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
name|expand_start_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|expand_stmt
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
name|expand_start_loop_continue_elsewhere
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|expand_stmt
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|expand_loop_continue_here
argument_list|()
expr_stmt|;
name|cond
operator|=
name|expand_cond
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
name|expand_exit_loop_if_false
argument_list|(
literal|0
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a DO_STMT.  */
end_comment

begin_function
name|void
name|genrtl_do_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|genrtl_do_stmt_1
argument_list|(
name|DO_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|DO_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build the node for a return statement and return it.  */
end_comment

begin_function
name|tree
name|build_return_stmt
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
return|return
operator|(
name|build_stmt
argument_list|(
name|RETURN_STMT
argument_list|,
name|expr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for STMT, which is a RETURN_STMT.  */
end_comment

begin_function
name|void
name|genrtl_return_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|expr
decl_stmt|;
name|expr
operator|=
name|RETURN_STMT_EXPR
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expr
condition|)
name|expand_null_return
argument_list|()
expr_stmt|;
else|else
block|{
name|expand_start_target_temps
argument_list|()
expr_stmt|;
name|expand_return
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expand_end_target_temps
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a FOR_STMT.  */
end_comment

begin_function
name|void
name|genrtl_for_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|cond
init|=
name|FOR_COND
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|location_t
name|saved_loc
decl_stmt|;
if|if
condition|(
name|NEW_FOR_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
name|expand_stmt
argument_list|(
name|FOR_INIT_STMT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Expand the initialization.  */
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|FOR_EXPR
argument_list|(
name|t
argument_list|)
condition|)
name|expand_start_loop_continue_elsewhere
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|expand_start_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
comment|/* Save the filename and line number so that we expand the FOR_EXPR      we can reset them back to the saved values.  */
name|saved_loc
operator|=
name|input_location
expr_stmt|;
comment|/* Expand the condition.  */
if|if
condition|(
name|cond
operator|&&
operator|!
name|integer_nonzerop
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|cond
operator|=
name|expand_cond
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
name|expand_exit_loop_top_cond
argument_list|(
literal|0
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
block|}
comment|/* Expand the body.  */
name|expand_stmt
argument_list|(
name|FOR_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Expand the increment expression.  */
name|input_location
operator|=
name|saved_loc
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|FOR_EXPR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|expand_loop_continue_here
argument_list|()
expr_stmt|;
name|genrtl_expr_stmt
argument_list|(
name|FOR_EXPR
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_end_loop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a break statement node and return it.  */
end_comment

begin_function
name|tree
name|build_break_stmt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|build_stmt
argument_list|(
name|BREAK_STMT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for a BREAK_STMT.  */
end_comment

begin_function
name|void
name|genrtl_break_stmt
parameter_list|(
name|void
parameter_list|)
block|{
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_exit_something
argument_list|()
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a continue statement node and return it.  */
end_comment

begin_function
name|tree
name|build_continue_stmt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|build_stmt
argument_list|(
name|CONTINUE_STMT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for a CONTINUE_STMT.  */
end_comment

begin_function
name|void
name|genrtl_continue_stmt
parameter_list|(
name|void
parameter_list|)
block|{
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_continue_loop
argument_list|(
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a SCOPE_STMT.  */
end_comment

begin_function
name|void
name|genrtl_scope_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|block
init|=
name|SCOPE_STMT_BLOCK
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SCOPE_NO_CLEANUPS_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCOPE_BEGIN_P
argument_list|(
name|t
argument_list|)
condition|)
name|expand_start_bindings_and_block
argument_list|(
literal|2
operator|*
name|SCOPE_NULLIFIED_P
argument_list|(
name|t
argument_list|)
argument_list|,
name|block
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SCOPE_END_P
argument_list|(
name|t
argument_list|)
condition|)
name|expand_end_bindings
argument_list|(
name|NULL_TREE
argument_list|,
operator|!
name|SCOPE_NULLIFIED_P
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|SCOPE_NULLIFIED_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|emit_note
argument_list|(
name|SCOPE_BEGIN_P
argument_list|(
name|t
argument_list|)
condition|?
name|NOTE_INSN_BLOCK_BEG
else|:
name|NOTE_INSN_BLOCK_END
argument_list|)
decl_stmt|;
name|NOTE_BLOCK
argument_list|(
name|note
argument_list|)
operator|=
name|block
expr_stmt|;
block|}
comment|/* If we're at the end of a scope that contains inlined nested      functions, we have to decide whether or not to write them out.  */
if|if
condition|(
name|block
operator|&&
name|SCOPE_END_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|fn
decl_stmt|;
for|for
control|(
name|fn
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|==
name|current_function_decl
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|fn
argument_list|)
operator|->
name|saved_for_inline
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|fn
argument_list|)
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|push_function_context
argument_list|()
expr_stmt|;
name|output_inline_function
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_function_context
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a SWITCH_STMT.  */
end_comment

begin_function
name|void
name|genrtl_switch_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|cond
decl_stmt|;
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
name|cond
operator|=
name|expand_cond
argument_list|(
name|SWITCH_COND
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|error_mark_node
condition|)
comment|/* The code is in error, but we don't want expand_end_case to        crash.  */
name|cond
operator|=
name|truthvalue_false_node
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
name|expand_start_case
argument_list|(
literal|1
argument_list|,
name|cond
argument_list|,
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|,
literal|"switch statement"
argument_list|)
expr_stmt|;
name|expand_stmt
argument_list|(
name|expand_unreachable_stmt
argument_list|(
name|SWITCH_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|warn_notreached
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_case_type
argument_list|(
name|cond
argument_list|,
name|SWITCH_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a CASE_LABEL tree node and return it.  */
end_comment

begin_function
name|tree
name|build_case_label
parameter_list|(
name|tree
name|low_value
parameter_list|,
name|tree
name|high_value
parameter_list|,
name|tree
name|label_decl
parameter_list|)
block|{
return|return
name|build_stmt
argument_list|(
name|CASE_LABEL
argument_list|,
name|low_value
argument_list|,
name|high_value
argument_list|,
name|label_decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for a CASE_LABEL.  */
end_comment

begin_function
name|void
name|genrtl_case_label
parameter_list|(
name|tree
name|case_label
parameter_list|)
block|{
name|tree
name|duplicate
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
name|cleanup
operator|=
name|last_cleanup_this_contour
argument_list|()
expr_stmt|;
if|if
condition|(
name|cleanup
condition|)
block|{
specifier|static
name|int
name|explained
init|=
literal|0
decl_stmt|;
name|warning
argument_list|(
literal|"destructor needed for `%D'"
argument_list|,
operator|(
name|TREE_PURPOSE
argument_list|(
name|cleanup
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"where case label appears here"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained
condition|)
block|{
name|warning
argument_list|(
literal|"(enclose actions of previous case statements requiring destructors in their own scope.)"
argument_list|)
expr_stmt|;
name|explained
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|add_case_node
argument_list|(
name|CASE_LOW
argument_list|(
name|case_label
argument_list|)
argument_list|,
name|CASE_HIGH
argument_list|(
name|case_label
argument_list|)
argument_list|,
name|CASE_LABEL_DECL
argument_list|(
name|case_label
argument_list|)
argument_list|,
operator|&
name|duplicate
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a COMPOUND_STMT.  */
end_comment

begin_function
name|void
name|genrtl_compound_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|struct
name|nesting
modifier|*
name|n
init|=
name|current_nesting_level
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|expand_stmt
argument_list|(
name|COMPOUND_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Make sure that we've pushed and popped the same number of levels.  */
if|if
condition|(
operator|!
name|COMPOUND_STMT_NO_SCOPE
argument_list|(
name|t
argument_list|)
operator|&&
name|n
operator|!=
name|current_nesting_level
argument_list|()
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Generate the RTL for an ASM_STMT.  */
end_comment

begin_function
name|void
name|genrtl_asm_stmt
parameter_list|(
name|tree
name|cv_qualifier
parameter_list|,
name|tree
name|string
parameter_list|,
name|tree
name|output_operands
parameter_list|,
name|tree
name|input_operands
parameter_list|,
name|tree
name|clobbers
parameter_list|,
name|int
name|asm_input_p
parameter_list|)
block|{
if|if
condition|(
name|cv_qualifier
operator|!=
name|NULL_TREE
operator|&&
name|cv_qualifier
operator|!=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
block|{
name|warning
argument_list|(
literal|"%s qualifier ignored on asm"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cv_qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|cv_qualifier
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_input_p
condition|)
name|expand_asm
argument_list|(
name|string
argument_list|,
name|cv_qualifier
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|c_expand_asm_operands
argument_list|(
name|string
argument_list|,
name|output_operands
argument_list|,
name|input_operands
argument_list|,
name|clobbers
argument_list|,
name|cv_qualifier
operator|!=
name|NULL_TREE
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for a CLEANUP_STMT.  */
end_comment

begin_function
name|void
name|genrtl_cleanup_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|decl
init|=
name|CLEANUP_DECL
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|decl
operator|||
operator|!
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|)
condition|)
name|expand_decl_cleanup_eh
argument_list|(
name|decl
argument_list|,
name|CLEANUP_EXPR
argument_list|(
name|t
argument_list|)
argument_list|,
name|CLEANUP_EH_ONLY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We're about to expand T, a statement.  Set up appropriate context    for the substitution.  */
end_comment

begin_function
name|void
name|prep_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|STMT_LINENO_FOR_FN_P
argument_list|(
name|t
argument_list|)
condition|)
name|input_line
operator|=
name|STMT_LINENO
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
name|STMT_IS_FULL_EXPR_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for the statement T, its substatements, and any    other statements at its nesting level.  */
end_comment

begin_function
name|void
name|expand_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
while|while
condition|(
name|t
operator|&&
name|t
operator|!=
name|error_mark_node
condition|)
block|{
name|int
name|saved_stmts_are_full_exprs_p
decl_stmt|;
comment|/* Set up context appropriately for handling this statement.  */
name|saved_stmts_are_full_exprs_p
operator|=
name|stmts_are_full_exprs_p
argument_list|()
expr_stmt|;
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FILE_STMT
case|:
name|input_filename
operator|=
name|FILE_STMT_FILENAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN_STMT
case|:
name|genrtl_return_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|expand_unreachable_stmt
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|warn_notreached
argument_list|)
expr_stmt|;
goto|goto
name|process_t
goto|;
case|case
name|EXPR_STMT
case|:
name|genrtl_expr_stmt_value
argument_list|(
name|EXPR_STMT_EXPR
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_ADDRESSABLE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|NULL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|SCOPE_STMT
operator|&&
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECL_STMT
case|:
name|genrtl_decl_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOR_STMT
case|:
name|genrtl_for_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|WHILE_STMT
case|:
name|genrtl_while_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DO_STMT
case|:
name|genrtl_do_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|IF_STMT
case|:
name|genrtl_if_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_STMT
case|:
name|genrtl_compound_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|BREAK_STMT
case|:
name|genrtl_break_stmt
argument_list|()
expr_stmt|;
name|t
operator|=
name|expand_unreachable_stmt
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|warn_notreached
argument_list|)
expr_stmt|;
goto|goto
name|process_t
goto|;
case|case
name|CONTINUE_STMT
case|:
name|genrtl_continue_stmt
argument_list|()
expr_stmt|;
name|t
operator|=
name|expand_unreachable_stmt
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|warn_notreached
argument_list|)
expr_stmt|;
goto|goto
name|process_t
goto|;
case|case
name|SWITCH_STMT
case|:
name|genrtl_switch_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CASE_LABEL
case|:
name|genrtl_case_label
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_STMT
case|:
name|expand_label
argument_list|(
name|LABEL_STMT_LABEL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GOTO_STMT
case|:
comment|/* Emit information for branch prediction.  */
if|if
condition|(
operator|!
name|GOTO_FAKE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
operator|&&
name|flag_guess_branch_prob
condition|)
block|{
name|rtx
name|note
init|=
name|emit_note
argument_list|(
name|NOTE_INSN_PREDICTION
argument_list|)
decl_stmt|;
name|NOTE_PREDICTION
argument_list|(
name|note
argument_list|)
operator|=
name|NOTE_PREDICT
argument_list|(
name|PRED_GOTO
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
block|}
name|genrtl_goto_stmt
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|expand_unreachable_stmt
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|warn_notreached
argument_list|)
expr_stmt|;
goto|goto
name|process_t
goto|;
case|case
name|ASM_STMT
case|:
name|genrtl_asm_stmt
argument_list|(
name|ASM_CV_QUAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|ASM_STRING
argument_list|(
name|t
argument_list|)
argument_list|,
name|ASM_OUTPUTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|ASM_INPUTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|ASM_CLOBBERS
argument_list|(
name|t
argument_list|)
argument_list|,
name|ASM_INPUT_P
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCOPE_STMT
case|:
name|genrtl_scope_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEANUP_STMT
case|:
name|genrtl_cleanup_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|lang_expand_stmt
condition|)
call|(
modifier|*
name|lang_expand_stmt
call|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* Go on to the next statement in this scope.  */
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|process_t
label|:
comment|/* Restore saved state.  */
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
name|saved_stmts_are_full_exprs_p
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If *TP is a potentially reachable label, return nonzero.  */
end_comment

begin_function
specifier|static
name|tree
name|find_reachable_label_1
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
case|case
name|LABEL_STMT
case|:
case|case
name|CASE_LABEL
case|:
return|return
operator|*
name|tp
return|;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Determine whether expression EXP contains a potentially    reachable label.  */
end_comment

begin_function
specifier|static
name|tree
name|find_reachable_label
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|location_t
name|saved_loc
init|=
name|input_location
decl_stmt|;
name|tree
name|ret
init|=
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|exp
argument_list|,
name|find_reachable_label_1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|input_location
operator|=
name|saved_loc
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Expand an unreachable if statement, T.  This function returns    true if the IF_STMT contains a potentially reachable code_label.  */
end_comment

begin_function
specifier|static
name|bool
name|expand_unreachable_if_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|n
decl_stmt|;
if|if
condition|(
name|find_reachable_label
argument_list|(
name|IF_COND
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|genrtl_if_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|THEN_CLAUSE
argument_list|(
name|t
argument_list|)
operator|&&
name|ELSE_CLAUSE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|n
operator|=
name|expand_unreachable_stmt
argument_list|(
name|THEN_CLAUSE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL_TREE
condition|)
block|{
name|rtx
name|label
decl_stmt|;
name|expand_stmt
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|expand_stmt
argument_list|(
name|expand_unreachable_stmt
argument_list|(
name|ELSE_CLAUSE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
name|n
operator|=
name|expand_unreachable_stmt
argument_list|(
name|ELSE_CLAUSE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|THEN_CLAUSE
argument_list|(
name|t
argument_list|)
condition|)
name|n
operator|=
name|expand_unreachable_stmt
argument_list|(
name|THEN_CLAUSE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ELSE_CLAUSE
argument_list|(
name|t
argument_list|)
condition|)
name|n
operator|=
name|expand_unreachable_stmt
argument_list|(
name|ELSE_CLAUSE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|NULL_TREE
expr_stmt|;
name|expand_stmt
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|n
operator|!=
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Expand an unreachable statement list.  This function skips all    statements preceding the first potentially reachable label and    then returns the label (or, in same cases, the statement after    one containing the label).  */
end_comment

begin_function
specifier|static
name|tree
name|expand_unreachable_stmt
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|warn
parameter_list|)
block|{
name|int
name|saved
decl_stmt|;
while|while
condition|(
name|t
operator|&&
name|t
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|warn
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|BREAK_STMT
case|:
case|case
name|CONTINUE_STMT
case|:
case|case
name|EXPR_STMT
case|:
case|case
name|GOTO_STMT
case|:
case|case
name|IF_STMT
case|:
case|case
name|RETURN_STMT
case|:
if|if
condition|(
operator|!
name|STMT_LINENO_FOR_FN_P
argument_list|(
name|t
argument_list|)
condition|)
name|input_line
operator|=
name|STMT_LINENO
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"will never be executed"
argument_list|)
expr_stmt|;
name|warn
operator|=
name|false
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|GOTO_STMT
case|:
case|case
name|CONTINUE_STMT
case|:
case|case
name|BREAK_STMT
case|:
break|break;
case|case
name|FILE_STMT
case|:
name|input_filename
operator|=
name|FILE_STMT_FILENAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN_STMT
case|:
if|if
condition|(
name|find_reachable_label
argument_list|(
name|RETURN_STMT_EXPR
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
return|return
name|t
return|;
break|break;
case|case
name|EXPR_STMT
case|:
if|if
condition|(
name|find_reachable_label
argument_list|(
name|EXPR_STMT_EXPR
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
return|return
name|t
return|;
break|break;
case|case
name|IF_STMT
case|:
if|if
condition|(
name|expand_unreachable_if_stmt
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
return|;
break|break;
case|case
name|WHILE_STMT
case|:
comment|/* If the start of a while statement is unreachable, there is 	     no need to rotate the loop, instead the WHILE_STMT can be 	     expanded like a DO_STMT.  */
name|genrtl_do_stmt_1
argument_list|(
name|WHILE_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|WHILE_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
return|;
case|case
name|COMPOUND_STMT
case|:
block|{
name|tree
name|n
decl_stmt|;
name|n
operator|=
name|expand_unreachable_stmt
argument_list|(
name|COMPOUND_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|warn
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL_TREE
condition|)
block|{
name|expand_stmt
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
return|;
block|}
name|warn
operator|=
name|false
expr_stmt|;
break|break;
block|}
case|case
name|SCOPE_STMT
case|:
name|saved
operator|=
name|stmts_are_full_exprs_p
argument_list|()
expr_stmt|;
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|genrtl_scope_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
name|saved
expr_stmt|;
break|break;
default|default:
return|return
name|t
return|;
block|}
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

end_unit

