begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPP Library.    Copyright (C) 1986, 87, 89, 92-98, 1999 Free Software Foundation, Inc.    Contributed by Per Bothner, 1994-95.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_define
define|#
directive|define
name|FAKE_CONST
end_define

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"prefix.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_comment
comment|/* XXX Should be in a header file. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Predefined symbols, built-in macros, and the default include path. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GET_ENV_PATH_LIST
end_ifndef

begin_define
define|#
directive|define
name|GET_ENV_PATH_LIST
parameter_list|(
name|VAR
parameter_list|,
name|NAME
parameter_list|)
value|do { (VAR) = getenv (NAME); } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* By default, colon separates directories in a path.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|PATH_SEPARATOR
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STANDARD_INCLUDE_DIR
end_ifndef

begin_define
define|#
directive|define
name|STANDARD_INCLUDE_DIR
value|"/usr/include"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We let tm.h override the types used here, to handle trivial differences    such as the choice of unsigned int or long unsigned int for size_t.    When machines start needing nontrivial differences in the size type,    it would be best to do something here to figure out automatically    from other information what type to use.  */
end_comment

begin_comment
comment|/* The string value for __SIZE_TYPE__.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_TYPE
end_ifndef

begin_define
define|#
directive|define
name|SIZE_TYPE
value|"long unsigned int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The string value for __PTRDIFF_TYPE__.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PTRDIFF_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PTRDIFF_TYPE
value|"long int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The string value for __WCHAR_TYPE__.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_TYPE
value|"int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CPP_WCHAR_TYPE
parameter_list|(
name|PFILE
parameter_list|)
define|\
value|(CPP_OPTIONS (PFILE)->cplusplus ? "__wchar_t" : WCHAR_TYPE)
end_define

begin_comment
comment|/* The string value for __USER_LABEL_PREFIX__ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USER_LABEL_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|USER_LABEL_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The string value for __REGISTER_PREFIX__ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Suffix for object files, and known input-file extensions. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|known_suffixes
index|[]
init|=
block|{
literal|".c"
block|,
literal|".C"
block|,
literal|".s"
block|,
literal|".S"
block|,
literal|".m"
block|,
literal|".cc"
block|,
literal|".cxx"
block|,
literal|".cpp"
block|,
literal|".cp"
block|,
literal|".c++"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OBJECT_SUFFIX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|OBJECT_SUFFIX
value|".obj"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OBJECT_SUFFIX
value|".o"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the default list of directories to search for include files.    It may be overridden by the various -I and -ixxx options.     #include "file" looks in the same directory as the current file,    then this list.     #include<file> just looks in this list.     All these directories are treated as `system' include directories    (they are not subject to pedantic warnings in some cases).  */
end_comment

begin_struct
specifier|static
struct|struct
name|default_include
block|{
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* The name of the directory.  */
name|char
modifier|*
name|component
decl_stmt|;
comment|/* The component containing the directory 				   (see update_path in prefix.c) */
name|int
name|cplusplus
decl_stmt|;
comment|/* Only look here if we're compiling C++.  */
name|int
name|cxx_aware
decl_stmt|;
comment|/* Includes in this directory don't need to 				   be wrapped in extern "C" when compiling 				   C++.  This is not used anymore.  */
block|}
name|include_defaults_array
index|[]
ifdef|#
directive|ifdef
name|INCLUDE_DEFAULTS
init|=
name|INCLUDE_DEFAULTS
struct|;
end_struct

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|=
block|{
comment|/* Pick up GNU C++ specific include files.  */
block|{
name|GPLUSPLUS_INCLUDE_DIR
block|,
literal|"G++"
block|,
literal|1
block|,
literal|1
block|}
block|,
ifdef|#
directive|ifdef
name|CROSS_COMPILE
comment|/* This is the dir for fixincludes.  Put it just before        the files that we fix.  */
block|{
name|GCC_INCLUDE_DIR
block|,
literal|"GCC"
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* For cross-compilation, this dir name is generated        automatically in Makefile.in.  */
block|{
name|CROSS_INCLUDE_DIR
block|,
literal|"GCC"
block|,
literal|0
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|TOOL_INCLUDE_DIR
comment|/* This is another place that the target system's headers might be.  */
block|{
name|TOOL_INCLUDE_DIR
block|,
literal|"BINUTILS"
block|,
literal|0
block|,
literal|1
block|}
block|,
endif|#
directive|endif
else|#
directive|else
comment|/* not CROSS_COMPILE */
ifdef|#
directive|ifdef
name|LOCAL_INCLUDE_DIR
comment|/* This should be /usr/local/include and should come before        the fixincludes-fixed header files.  */
block|{
name|LOCAL_INCLUDE_DIR
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TOOL_INCLUDE_DIR
comment|/* This is here ahead of GCC_INCLUDE_DIR because assert.h goes here.        Likewise, behind LOCAL_INCLUDE_DIR, where glibc puts its assert.h.  */
block|{
name|TOOL_INCLUDE_DIR
block|,
literal|"BINUTILS"
block|,
literal|0
block|,
literal|1
block|}
block|,
endif|#
directive|endif
comment|/* This is the dir for fixincludes.  Put it just before        the files that we fix.  */
block|{
name|GCC_INCLUDE_DIR
block|,
literal|"GCC"
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Some systems have an extra dir of include files.  */
ifdef|#
directive|ifdef
name|SYSTEM_INCLUDE_DIR
block|{
name|SYSTEM_INCLUDE_DIR
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|STANDARD_INCLUDE_COMPONENT
define|#
directive|define
name|STANDARD_INCLUDE_COMPONENT
value|0
endif|#
directive|endif
block|{
name|STANDARD_INCLUDE_DIR
block|,
name|STANDARD_INCLUDE_COMPONENT
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* not CROSS_COMPILE */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no INCLUDE_DEFAULTS */
end_comment

begin_comment
comment|/* Internal structures and prototypes. */
end_comment

begin_comment
comment|/* A `struct pending_option' remembers one -D, -A, -U, -include, or -imacros    switch.  There are four lists: one for -D and -U, one for -A, one    for -include, one for -imacros.  `undef' is set for -U, clear for    -D, ignored for the others.    (Future: add an equivalent of -U for -A) */
end_comment

begin_struct
struct|struct
name|pending_option
block|{
name|struct
name|pending_option
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|undef
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|APPEND
parameter_list|(
name|pend
parameter_list|,
name|list
parameter_list|,
name|elt
parameter_list|)
define|\
value|do {  if (!(pend)->list##_head) (pend)->list##_head = (elt); \ 	else (pend)->list##_tail->next = (elt); \ 	(pend)->list##_tail = (elt); \   } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|APPEND
parameter_list|(
name|pend
parameter_list|,
name|list
parameter_list|,
name|elt
parameter_list|)
define|\
value|do {  if (!(pend)->list
comment|/**/
value|_head) (pend)->list
comment|/**/
value|_head = (elt); \ 	else (pend)->list
comment|/**/
value|_tail->next = (elt); \ 	(pend)->list
comment|/**/
value|_tail = (elt); \   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|initialize_char_syntax
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_help
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|path_include
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|cpp_pending
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_builtins
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_include_chain
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|cpp_pending
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last argument to append_include_chain: chain to use */
end_comment

begin_enum
enum|enum
block|{
name|QUOTE
init|=
literal|0
block|,
name|BRACKET
block|,
name|SYSTEM
block|,
name|AFTER
block|}
enum|;
end_enum

begin_comment
comment|/* If gcc is in use (stage2/stage3) we can make these tables initialized    data. */
end_comment

begin_if
if|#
directive|if
name|defined
name|__GNUC__
operator|&&
name|__GNUC__
operator|>=
literal|2
end_if

begin_comment
comment|/* Table to tell if a character is legal as the second or later character    of a C identifier. */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_idchar
index|[
literal|256
index|]
init|=
block|{
index|[
literal|'a'
index|]
operator|=
literal|1
block|,
index|[
literal|'b'
index|]
operator|=
literal|1
block|,
index|[
literal|'c'
index|]
operator|=
literal|1
block|,
index|[
literal|'d'
index|]
operator|=
literal|1
block|,
index|[
literal|'e'
index|]
operator|=
literal|1
block|,
index|[
literal|'f'
index|]
operator|=
literal|1
block|,
index|[
literal|'g'
index|]
operator|=
literal|1
block|,
index|[
literal|'h'
index|]
operator|=
literal|1
block|,
index|[
literal|'i'
index|]
operator|=
literal|1
block|,
index|[
literal|'j'
index|]
operator|=
literal|1
block|,
index|[
literal|'k'
index|]
operator|=
literal|1
block|,
index|[
literal|'l'
index|]
operator|=
literal|1
block|,
index|[
literal|'m'
index|]
operator|=
literal|1
block|,
index|[
literal|'n'
index|]
operator|=
literal|1
block|,
index|[
literal|'o'
index|]
operator|=
literal|1
block|,
index|[
literal|'p'
index|]
operator|=
literal|1
block|,
index|[
literal|'q'
index|]
operator|=
literal|1
block|,
index|[
literal|'r'
index|]
operator|=
literal|1
block|,
index|[
literal|'s'
index|]
operator|=
literal|1
block|,
index|[
literal|'t'
index|]
operator|=
literal|1
block|,
index|[
literal|'u'
index|]
operator|=
literal|1
block|,
index|[
literal|'v'
index|]
operator|=
literal|1
block|,
index|[
literal|'w'
index|]
operator|=
literal|1
block|,
index|[
literal|'x'
index|]
operator|=
literal|1
block|,
index|[
literal|'y'
index|]
operator|=
literal|1
block|,
index|[
literal|'z'
index|]
operator|=
literal|1
block|,
index|[
literal|'A'
index|]
operator|=
literal|1
block|,
index|[
literal|'B'
index|]
operator|=
literal|1
block|,
index|[
literal|'C'
index|]
operator|=
literal|1
block|,
index|[
literal|'D'
index|]
operator|=
literal|1
block|,
index|[
literal|'E'
index|]
operator|=
literal|1
block|,
index|[
literal|'F'
index|]
operator|=
literal|1
block|,
index|[
literal|'G'
index|]
operator|=
literal|1
block|,
index|[
literal|'H'
index|]
operator|=
literal|1
block|,
index|[
literal|'I'
index|]
operator|=
literal|1
block|,
index|[
literal|'J'
index|]
operator|=
literal|1
block|,
index|[
literal|'K'
index|]
operator|=
literal|1
block|,
index|[
literal|'L'
index|]
operator|=
literal|1
block|,
index|[
literal|'M'
index|]
operator|=
literal|1
block|,
index|[
literal|'N'
index|]
operator|=
literal|1
block|,
index|[
literal|'O'
index|]
operator|=
literal|1
block|,
index|[
literal|'P'
index|]
operator|=
literal|1
block|,
index|[
literal|'Q'
index|]
operator|=
literal|1
block|,
index|[
literal|'R'
index|]
operator|=
literal|1
block|,
index|[
literal|'S'
index|]
operator|=
literal|1
block|,
index|[
literal|'T'
index|]
operator|=
literal|1
block|,
index|[
literal|'U'
index|]
operator|=
literal|1
block|,
index|[
literal|'V'
index|]
operator|=
literal|1
block|,
index|[
literal|'W'
index|]
operator|=
literal|1
block|,
index|[
literal|'X'
index|]
operator|=
literal|1
block|,
index|[
literal|'Y'
index|]
operator|=
literal|1
block|,
index|[
literal|'Z'
index|]
operator|=
literal|1
block|,
index|[
literal|'1'
index|]
operator|=
literal|1
block|,
index|[
literal|'2'
index|]
operator|=
literal|1
block|,
index|[
literal|'3'
index|]
operator|=
literal|1
block|,
index|[
literal|'4'
index|]
operator|=
literal|1
block|,
index|[
literal|'5'
index|]
operator|=
literal|1
block|,
index|[
literal|'6'
index|]
operator|=
literal|1
block|,
index|[
literal|'7'
index|]
operator|=
literal|1
block|,
index|[
literal|'8'
index|]
operator|=
literal|1
block|,
index|[
literal|'9'
index|]
operator|=
literal|1
block|,
index|[
literal|'0'
index|]
operator|=
literal|1
block|,
index|[
literal|'_'
index|]
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table to tell if a character is legal as the first character of    a C identifier. */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_idstart
index|[
literal|256
index|]
init|=
block|{
index|[
literal|'a'
index|]
operator|=
literal|1
block|,
index|[
literal|'b'
index|]
operator|=
literal|1
block|,
index|[
literal|'c'
index|]
operator|=
literal|1
block|,
index|[
literal|'d'
index|]
operator|=
literal|1
block|,
index|[
literal|'e'
index|]
operator|=
literal|1
block|,
index|[
literal|'f'
index|]
operator|=
literal|1
block|,
index|[
literal|'g'
index|]
operator|=
literal|1
block|,
index|[
literal|'h'
index|]
operator|=
literal|1
block|,
index|[
literal|'i'
index|]
operator|=
literal|1
block|,
index|[
literal|'j'
index|]
operator|=
literal|1
block|,
index|[
literal|'k'
index|]
operator|=
literal|1
block|,
index|[
literal|'l'
index|]
operator|=
literal|1
block|,
index|[
literal|'m'
index|]
operator|=
literal|1
block|,
index|[
literal|'n'
index|]
operator|=
literal|1
block|,
index|[
literal|'o'
index|]
operator|=
literal|1
block|,
index|[
literal|'p'
index|]
operator|=
literal|1
block|,
index|[
literal|'q'
index|]
operator|=
literal|1
block|,
index|[
literal|'r'
index|]
operator|=
literal|1
block|,
index|[
literal|'s'
index|]
operator|=
literal|1
block|,
index|[
literal|'t'
index|]
operator|=
literal|1
block|,
index|[
literal|'u'
index|]
operator|=
literal|1
block|,
index|[
literal|'v'
index|]
operator|=
literal|1
block|,
index|[
literal|'w'
index|]
operator|=
literal|1
block|,
index|[
literal|'x'
index|]
operator|=
literal|1
block|,
index|[
literal|'y'
index|]
operator|=
literal|1
block|,
index|[
literal|'z'
index|]
operator|=
literal|1
block|,
index|[
literal|'A'
index|]
operator|=
literal|1
block|,
index|[
literal|'B'
index|]
operator|=
literal|1
block|,
index|[
literal|'C'
index|]
operator|=
literal|1
block|,
index|[
literal|'D'
index|]
operator|=
literal|1
block|,
index|[
literal|'E'
index|]
operator|=
literal|1
block|,
index|[
literal|'F'
index|]
operator|=
literal|1
block|,
index|[
literal|'G'
index|]
operator|=
literal|1
block|,
index|[
literal|'H'
index|]
operator|=
literal|1
block|,
index|[
literal|'I'
index|]
operator|=
literal|1
block|,
index|[
literal|'J'
index|]
operator|=
literal|1
block|,
index|[
literal|'K'
index|]
operator|=
literal|1
block|,
index|[
literal|'L'
index|]
operator|=
literal|1
block|,
index|[
literal|'M'
index|]
operator|=
literal|1
block|,
index|[
literal|'N'
index|]
operator|=
literal|1
block|,
index|[
literal|'O'
index|]
operator|=
literal|1
block|,
index|[
literal|'P'
index|]
operator|=
literal|1
block|,
index|[
literal|'Q'
index|]
operator|=
literal|1
block|,
index|[
literal|'R'
index|]
operator|=
literal|1
block|,
index|[
literal|'S'
index|]
operator|=
literal|1
block|,
index|[
literal|'T'
index|]
operator|=
literal|1
block|,
index|[
literal|'U'
index|]
operator|=
literal|1
block|,
index|[
literal|'V'
index|]
operator|=
literal|1
block|,
index|[
literal|'W'
index|]
operator|=
literal|1
block|,
index|[
literal|'X'
index|]
operator|=
literal|1
block|,
index|[
literal|'Y'
index|]
operator|=
literal|1
block|,
index|[
literal|'Z'
index|]
operator|=
literal|1
block|,
index|[
literal|'_'
index|]
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table to tell if a character is horizontal space.    \r is magical, so it is not in here.  */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_hor_space
index|[
literal|256
index|]
init|=
block|{
index|[
literal|' '
index|]
operator|=
literal|1
block|,
index|[
literal|'\t'
index|]
operator|=
literal|1
block|,
index|[
literal|'\v'
index|]
operator|=
literal|1
block|,
index|[
literal|'\f'
index|]
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if a character is horizontal or vertical space.  */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_space
index|[
literal|256
index|]
init|=
block|{
index|[
literal|' '
index|]
operator|=
literal|1
block|,
index|[
literal|'\t'
index|]
operator|=
literal|1
block|,
index|[
literal|'\v'
index|]
operator|=
literal|1
block|,
index|[
literal|'\f'
index|]
operator|=
literal|1
block|,
index|[
literal|'\n'
index|]
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table to handle trigraph conversion, which occurs before all other    processing, everywhere in the file.  (This is necessary since one    of the trigraphs encodes backslash.)  Note it's off by default.  	from	to	from	to	from	to 	?? =	#	?? )	]	?? !	| 	?? (	[	?? '	^	??>	} 	?? /	\	??<	{	?? -	~     There is not a space between the ?? and the third char.  I put spaces    there to avoid warnings when compiling this file. */
end_comment

begin_decl_stmt
name|U_CHAR
name|trigraph_table
index|[
literal|256
index|]
init|=
block|{
index|[
literal|'='
index|]
operator|=
literal|'#'
block|,
index|[
literal|')'
index|]
operator|=
literal|']'
block|,
index|[
literal|'!'
index|]
operator|=
literal|'|'
block|,
index|[
literal|'('
index|]
operator|=
literal|'['
block|,
index|[
literal|'\''
index|]
operator|=
literal|'^'
block|,
index|[
literal|'>'
index|]
operator|=
literal|'}'
block|,
index|[
literal|'/'
index|]
operator|=
literal|'\\'
block|,
index|[
literal|'<'
index|]
operator|=
literal|'{'
block|,
index|[
literal|'-'
index|]
operator|=
literal|'~'
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function will be entirely removed soon. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|initialize_char_syntax
parameter_list|(
name|dollar_in_ident
parameter_list|)
name|int
name|dollar_in_ident
decl_stmt|;
block|{
name|is_idchar
index|[
literal|'$'
index|]
operator|=
name|dollar_in_ident
expr_stmt|;
name|is_idstart
index|[
literal|'$'
index|]
operator|=
name|dollar_in_ident
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Not GCC. */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_idchar
index|[
literal|256
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U_CHAR
name|is_idstart
index|[
literal|256
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U_CHAR
name|is_hor_space
index|[
literal|256
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U_CHAR
name|is_space
index|[
literal|256
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U_CHAR
name|trigraph_table
index|[
literal|256
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize syntactic classifications of characters. */
end_comment

begin_function
specifier|static
name|void
name|initialize_char_syntax
parameter_list|(
name|dollar_in_ident
parameter_list|)
name|int
name|dollar_in_ident
decl_stmt|;
block|{
name|is_idstart
index|[
literal|'a'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'b'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'c'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'d'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'e'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'f'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'g'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'h'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'i'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'j'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'k'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'l'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'m'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'n'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'o'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'p'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'q'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'r'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'s'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'t'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'u'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'v'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'w'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'x'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'y'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'z'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'A'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'B'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'C'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'D'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'E'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'F'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'G'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'H'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'I'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'J'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'K'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'L'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'M'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'N'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'O'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'P'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'Q'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'R'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'S'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'T'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'U'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'V'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'W'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'X'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'Y'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'Z'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'_'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'a'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'b'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'c'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'d'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'e'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'f'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'g'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'h'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'i'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'j'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'k'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'l'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'m'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'n'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'o'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'p'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'q'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'r'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'s'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'t'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'u'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'v'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'w'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'x'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'y'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'z'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'A'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'B'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'C'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'D'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'E'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'F'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'G'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'H'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'I'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'J'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'K'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'L'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'M'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'N'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'O'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'P'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'Q'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'R'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'S'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'T'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'U'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'V'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'W'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'X'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'Y'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'Z'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'1'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'2'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'3'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'4'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'5'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'6'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'7'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'8'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'9'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'0'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'_'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'$'
index|]
operator|=
name|dollar_in_ident
expr_stmt|;
name|is_idstart
index|[
literal|'$'
index|]
operator|=
name|dollar_in_ident
expr_stmt|;
comment|/* white space tables */
name|is_hor_space
index|[
literal|' '
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\t'
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\v'
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\f'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|' '
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\t'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\v'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\f'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\n'
index|]
operator|=
literal|1
expr_stmt|;
comment|/* trigraph conversion */
name|trigraph_table
index|[
literal|'='
index|]
operator|=
literal|'#'
expr_stmt|;
name|trigraph_table
index|[
literal|')'
index|]
operator|=
literal|']'
expr_stmt|;
name|trigraph_table
index|[
literal|'!'
index|]
operator|=
literal|'|'
expr_stmt|;
name|trigraph_table
index|[
literal|'('
index|]
operator|=
literal|'['
expr_stmt|;
name|trigraph_table
index|[
literal|'\''
index|]
operator|=
literal|'^'
expr_stmt|;
name|trigraph_table
index|[
literal|'>'
index|]
operator|=
literal|'}'
expr_stmt|;
name|trigraph_table
index|[
literal|'/'
index|]
operator|=
literal|'\\'
expr_stmt|;
name|trigraph_table
index|[
literal|'<'
index|]
operator|=
literal|'{'
expr_stmt|;
name|trigraph_table
index|[
literal|'-'
index|]
operator|=
literal|'~'
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not GCC. */
end_comment

begin_comment
comment|/* Given a colon-separated list of file names PATH,    add all the names to the search path for include files.  */
end_comment

begin_function
specifier|static
name|void
name|path_include
parameter_list|(
name|pfile
parameter_list|,
name|pend
parameter_list|,
name|list
parameter_list|,
name|path
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|cpp_pending
modifier|*
name|pend
decl_stmt|;
name|char
modifier|*
name|list
decl_stmt|;
name|int
name|path
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|p
operator|=
name|list
expr_stmt|;
do|do
block|{
comment|/* Find the end of this name.  */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|0
operator|&&
operator|*
name|q
operator|!=
name|PATH_SEPARATOR
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|p
condition|)
block|{
comment|/* An empty name in the path stands for the current directory.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise use the directory that is named.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|q
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|name
index|[
name|q
operator|-
name|p
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|pend
argument_list|,
name|name
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Advance past this name.  */
if|if
condition|(
operator|*
name|q
operator|==
literal|0
condition|)
break|break;
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Find the base name of a (partial) pathname FNAME.    Returns a pointer into the string passed in.    Accepts Unix (/-separated) paths on all systems,    DOS and VMS paths on those systems.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|base_name
parameter_list|(
name|fname
parameter_list|)
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|fname
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DOS_BASED_FILE_SYSTEM
argument_list|)
if|if
condition|(
name|ISALPHA
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|s
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
literal|'\\'
argument_list|)
operator|)
condition|)
name|s
operator|=
name|p
operator|+
literal|1
expr_stmt|;
elif|#
directive|elif
name|defined
name|VMS
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
name|s
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Skip device.  */
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
literal|']'
argument_list|)
operator|)
condition|)
name|s
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Skip directory.  */
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
literal|'>'
argument_list|)
operator|)
condition|)
name|s
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Skip alternate (int'n'l) dir.  */
endif|#
directive|endif
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|s
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Append DIR to include path PATH.  DIR must be permanently allocated    and writable. */
end_comment

begin_function
specifier|static
name|void
name|append_include_chain
parameter_list|(
name|pfile
parameter_list|,
name|pend
parameter_list|,
name|dir
parameter_list|,
name|path
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|cpp_pending
modifier|*
name|pend
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|path
decl_stmt|;
block|{
name|struct
name|file_name_list
modifier|*
name|new
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|simplify_pathname
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dir
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
comment|/* Dirs that don't exist are silently ignored. */
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|cpp_perror_with_name
argument_list|(
name|pfile
argument_list|,
name|dir
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|verbose
condition|)
name|cpp_notice
argument_list|(
literal|"ignoring nonexistent directory `%s'\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|cpp_message
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
literal|"%s: %s: Not a directory"
argument_list|,
name|progname
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|pfile
operator|->
name|max_include_len
condition|)
name|pfile
operator|->
name|max_include_len
operator|=
name|len
expr_stmt|;
name|new
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|dir
expr_stmt|;
name|new
operator|->
name|nlen
operator|=
name|len
expr_stmt|;
name|new
operator|->
name|ino
operator|=
name|st
operator|.
name|st_ino
expr_stmt|;
name|new
operator|->
name|dev
operator|=
name|st
operator|.
name|st_dev
expr_stmt|;
name|new
operator|->
name|sysp
operator|=
operator|(
name|path
operator|==
name|SYSTEM
operator|)
expr_stmt|;
name|new
operator|->
name|name_map
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|path
condition|)
block|{
case|case
name|QUOTE
case|:
name|APPEND
argument_list|(
name|pend
argument_list|,
name|quote
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
case|case
name|BRACKET
case|:
name|APPEND
argument_list|(
name|pend
argument_list|,
name|brack
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYSTEM
case|:
name|APPEND
argument_list|(
name|pend
argument_list|,
name|systm
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
case|case
name|AFTER
case|:
name|APPEND
argument_list|(
name|pend
argument_list|,
name|after
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Write out a #define command for the special named MACRO_NAME    to PFILE's token_buffer.  */
end_comment

begin_function
specifier|static
name|void
name|dump_special_to_buffer
parameter_list|(
name|pfile
parameter_list|,
name|macro_name
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|macro_name
decl_stmt|;
block|{
specifier|static
name|char
name|define_directive
index|[]
init|=
literal|"#define "
decl_stmt|;
name|int
name|macro_name_length
init|=
name|strlen
argument_list|(
name|macro_name
argument_list|)
decl_stmt|;
name|output_line_command
argument_list|(
name|pfile
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
sizeof|sizeof
argument_list|(
name|define_directive
argument_list|)
operator|+
name|macro_name_length
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|define_directive
argument_list|,
sizeof|sizeof
argument_list|(
name|define_directive
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|macro_name
argument_list|,
name|macro_name_length
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|cpp_expand_to_buffer
argument_list|(
name|pfile
argument_list|,
name|macro_name
argument_list|,
name|macro_name_length
argument_list|)
expr_stmt|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize a cpp_options structure. */
end_comment

begin_function
name|void
name|cpp_options_init
parameter_list|(
name|opts
parameter_list|)
name|cpp_options
modifier|*
name|opts
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|opts
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cpp_options
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|->
name|dollars_in_ident
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|warn_import
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|pending
operator|=
operator|(
expr|struct
name|cpp_pending
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cpp_pending
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|opts
operator|->
name|pending
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cpp_pending
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize a cpp_reader structure. */
end_comment

begin_function
name|void
name|cpp_reader_init
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pfile
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_reader
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|pfile->get_token = cpp_get_token;
endif|#
directive|endif
name|pfile
operator|->
name|token_buffer_size
operator|=
literal|200
expr_stmt|;
name|pfile
operator|->
name|token_buffer
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|pfile
operator|->
name|token_buffer_size
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|hashtab
operator|=
operator|(
name|HASHNODE
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|HASHSIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|HASHNODE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free resources used by PFILE.    This is the cpp_reader 'finalizer' or 'destructor' (in C++ terminology).  */
end_comment

begin_function
name|void
name|cpp_cleanup
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
while|while
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|token_buffer
condition|)
block|{
name|free
argument_list|(
name|pfile
operator|->
name|token_buffer
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|token_buffer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|deps_buffer
condition|)
block|{
name|free
argument_list|(
name|pfile
operator|->
name|deps_buffer
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|deps_buffer
operator|=
name|NULL
expr_stmt|;
name|pfile
operator|->
name|deps_allocated_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|input_buffer
condition|)
block|{
name|free
argument_list|(
name|pfile
operator|->
name|input_buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfile
operator|->
name|input_speccase
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|input_buffer
operator|=
name|pfile
operator|->
name|input_speccase
operator|=
name|NULL
expr_stmt|;
name|pfile
operator|->
name|input_buffer_len
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|pfile
operator|->
name|if_stack
condition|)
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
init|=
name|pfile
operator|->
name|if_stack
decl_stmt|;
name|pfile
operator|->
name|if_stack
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|ALL_INCLUDE_HASHSIZE
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|struct
name|include_hash
modifier|*
name|imp
init|=
name|pfile
operator|->
name|all_include_files
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|imp
condition|)
block|{
name|struct
name|include_hash
modifier|*
name|next
init|=
name|imp
operator|->
name|next
decl_stmt|;
if|#
directive|if
literal|0
comment|/* This gets freed elsewhere - I think. */
block|free (imp->name);
endif|#
directive|endif
name|free
argument_list|(
name|imp
argument_list|)
expr_stmt|;
name|imp
operator|=
name|next
expr_stmt|;
block|}
name|pfile
operator|->
name|all_include_files
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|HASHSIZE
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
while|while
condition|(
name|pfile
operator|->
name|hashtab
index|[
name|i
index|]
condition|)
name|delete_macro
argument_list|(
name|pfile
operator|->
name|hashtab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pfile
operator|->
name|hashtab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the built-in macros.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_builtins
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
define|#
directive|define
name|NAME
parameter_list|(
name|str
parameter_list|)
value|(U_CHAR *)str, sizeof str - 1
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|NAME
argument_list|(
literal|"__TIME__"
argument_list|)
argument_list|,
name|T_TIME
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|NAME
argument_list|(
literal|"__DATE__"
argument_list|)
argument_list|,
name|T_DATE
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|NAME
argument_list|(
literal|"__FILE__"
argument_list|)
argument_list|,
name|T_FILE
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|NAME
argument_list|(
literal|"__BASE_FILE__"
argument_list|)
argument_list|,
name|T_BASE_FILE
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|NAME
argument_list|(
literal|"__LINE__"
argument_list|)
argument_list|,
name|T_SPECLINE
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|NAME
argument_list|(
literal|"__INCLUDE_LEVEL__"
argument_list|)
argument_list|,
name|T_INCLUDE_LEVEL
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|NAME
argument_list|(
literal|"__VERSION__"
argument_list|)
argument_list|,
name|T_VERSION
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_BUILTIN_SIZE_TYPE
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|NAME
argument_list|(
literal|"__SIZE_TYPE__"
argument_list|)
argument_list|,
name|T_CONST
argument_list|,
name|SIZE_TYPE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_PTRDIFF_TYPE
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|NAME
argument_list|(
literal|"__PTRDIFF_TYPE__ "
argument_list|)
argument_list|,
name|T_CONST
argument_list|,
name|PTRDIFF_TYPE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|NAME
argument_list|(
literal|"__WCHAR_TYPE__"
argument_list|)
argument_list|,
name|T_CONST
argument_list|,
name|WCHAR_TYPE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|NAME
argument_list|(
literal|"__USER_LABEL_PREFIX__"
argument_list|)
argument_list|,
name|T_CONST
argument_list|,
name|user_label_prefix
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|NAME
argument_list|(
literal|"__REGISTER_PREFIX__"
argument_list|)
argument_list|,
name|T_CONST
argument_list|,
name|REGISTER_PREFIX
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|NAME
argument_list|(
literal|"__HAVE_BUILTIN_SETJMP__"
argument_list|)
argument_list|,
name|T_CONST
argument_list|,
literal|"1"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|NAME
argument_list|(
literal|"__STDC__"
argument_list|)
argument_list|,
name|T_STDC
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (CPP_OPTIONS (pfile)->c9x) 	cpp_install (pfile, NAME("__STDC_VERSION__"),T_CONST, "199909L", -1);       else
endif|#
directive|endif
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|NAME
argument_list|(
literal|"__STDC_VERSION__"
argument_list|)
argument_list|,
name|T_CONST
argument_list|,
literal|"199409L"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|NAME
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|debug_output
condition|)
block|{
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__BASE_FILE__"
argument_list|)
expr_stmt|;
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__VERSION__"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_BUILTIN_SIZE_TYPE
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__SIZE_TYPE__"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_PTRDIFF_TYPE
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__PTRDIFF_TYPE__"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__WCHAR_TYPE__"
argument_list|)
expr_stmt|;
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__DATE__"
argument_list|)
expr_stmt|;
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__TIME__"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__STDC__"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Another subroutine of cpp_start_read.  This one sets up to do    dependency-file output. */
end_comment

begin_function
specifier|static
name|void
name|initialize_dependency_output
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_options
modifier|*
name|opts
init|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|char
modifier|*
name|spec
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|output_file
decl_stmt|;
comment|/* Either of two environment variables can specify output of deps.      Its value is either "OUTPUT_FILE" or "OUTPUT_FILE DEPS_TARGET",      where OUTPUT_FILE is the file to write deps info to      and DEPS_TARGET is the target to mention in the deps.  */
if|if
condition|(
name|opts
operator|->
name|print_deps
operator|==
literal|0
condition|)
block|{
name|spec
operator|=
name|getenv
argument_list|(
literal|"DEPENDENCIES_OUTPUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
name|opts
operator|->
name|print_deps
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|spec
operator|=
name|getenv
argument_list|(
literal|"SUNPRO_DEPENDENCIES"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
name|opts
operator|->
name|print_deps
operator|=
literal|2
expr_stmt|;
else|else
return|return;
block|}
comment|/* Find the space before the DEPS_TARGET, if there is one.  */
name|s
operator|=
name|strchr
argument_list|(
name|spec
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|opts
operator|->
name|deps_target
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|output_file
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|s
operator|-
name|spec
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|output_file
argument_list|,
name|spec
argument_list|,
name|s
operator|-
name|spec
argument_list|)
expr_stmt|;
name|output_file
index|[
name|s
operator|-
name|spec
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|opts
operator|->
name|deps_target
operator|=
literal|0
expr_stmt|;
name|output_file
operator|=
name|spec
expr_stmt|;
block|}
name|opts
operator|->
name|deps_file
operator|=
name|output_file
expr_stmt|;
name|opts
operator|->
name|print_deps_append
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Print the expected object file name as the target of this Make-rule.  */
name|pfile
operator|->
name|deps_allocated_size
operator|=
literal|200
expr_stmt|;
name|pfile
operator|->
name|deps_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|pfile
operator|->
name|deps_allocated_size
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|deps_buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|deps_size
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|deps_column
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|deps_target
condition|)
name|deps_output
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|deps_target
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|opts
operator|->
name|in_fname
operator|==
literal|0
condition|)
name|deps_output
argument_list|(
name|pfile
argument_list|,
literal|"-"
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|int
name|len
decl_stmt|,
name|x
decl_stmt|;
comment|/* Discard all directory prefixes from filename.  */
name|q
operator|=
name|base_name
argument_list|(
name|opts
operator|->
name|in_fname
argument_list|)
expr_stmt|;
comment|/* Copy remainder to mungable area.  */
name|len
operator|=
name|strlen
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|8
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Output P, but remove known suffixes.  */
name|q
operator|=
name|p
operator|+
name|len
expr_stmt|;
comment|/* Point to the filename suffix.  */
name|r
operator|=
name|rindex
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
comment|/* Compare against the known suffixes.  */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|known_suffixes
index|[
name|x
index|]
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|known_suffixes
index|[
name|x
index|]
argument_list|,
name|r
argument_list|,
name|q
operator|-
name|r
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Make q point to the bit we're going to overwrite 		 with an object suffix.  */
name|q
operator|=
name|r
expr_stmt|;
break|break;
block|}
block|}
comment|/* Supply our own suffix.  */
name|strcpy
argument_list|(
name|q
argument_list|,
name|OBJECT_SUFFIX
argument_list|)
expr_stmt|;
name|deps_output
argument_list|(
name|pfile
argument_list|,
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|deps_output
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|in_fname
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is called after options have been processed.  * Check options for consistency, and setup for processing input  * from the file named FNAME.  (Use standard input if FNAME==NULL.)  * Return 1 on success, 0 on failure.  */
end_comment

begin_function
name|int
name|cpp_start_read
parameter_list|(
name|pfile
parameter_list|,
name|fname
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|struct
name|cpp_options
modifier|*
name|opts
init|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|struct
name|pending_option
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|f
decl_stmt|;
name|cpp_buffer
modifier|*
name|fp
decl_stmt|;
name|struct
name|include_hash
modifier|*
name|ih_fake
decl_stmt|;
comment|/* -MG doesn't select the form of output and must be specified with one of      -M or -MM.  -MG doesn't make sense with -MD or -MMD since they don't      inhibit compilation.  */
if|if
condition|(
name|opts
operator|->
name|print_deps_missing_files
operator|&&
operator|(
name|opts
operator|->
name|print_deps
operator|==
literal|0
operator|||
operator|!
name|opts
operator|->
name|no_output
operator|)
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"-MG must be specified with one of -M or -MM"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Chill should not be used with -trigraphs. */
if|if
condition|(
name|opts
operator|->
name|chill
operator|&&
name|opts
operator|->
name|trigraphs
condition|)
block|{
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"-lang-chill and -trigraphs are mutually exclusive"
argument_list|)
expr_stmt|;
name|opts
operator|->
name|trigraphs
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Set this if it hasn't been set already. */
if|if
condition|(
name|user_label_prefix
operator|==
name|NULL
condition|)
name|user_label_prefix
operator|=
name|USER_LABEL_PREFIX
expr_stmt|;
comment|/* Now that we know dollars_in_ident, we can initialize the syntax      tables. */
name|initialize_char_syntax
argument_list|(
name|opts
operator|->
name|dollars_in_ident
argument_list|)
expr_stmt|;
comment|/* Do partial setup of input buffer for the sake of generating      early #line directives (when -g is in effect).  */
name|fp
operator|=
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|opts
operator|->
name|in_fname
operator|==
name|NULL
operator|||
operator|*
name|opts
operator|->
name|in_fname
operator|==
literal|0
condition|)
block|{
name|opts
operator|->
name|in_fname
operator|=
name|fname
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|in_fname
operator|==
name|NULL
condition|)
name|opts
operator|->
name|in_fname
operator|=
literal|""
expr_stmt|;
block|}
name|fp
operator|->
name|nominal_fname
operator|=
name|fp
operator|->
name|fname
operator|=
name|opts
operator|->
name|in_fname
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|0
expr_stmt|;
comment|/* Install __LINE__, etc.  Must follow initialize_char_syntax      and option processing.  */
name|initialize_builtins
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Do -U's, -D's and -A's in the order they were seen.  */
name|p
operator|=
name|opts
operator|->
name|pending
operator|->
name|define_head
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|debug_output
condition|)
name|output_line_command
argument_list|(
name|pfile
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|undef
condition|)
name|cpp_undef
argument_list|(
name|pfile
argument_list|,
name|p
operator|->
name|arg
argument_list|)
expr_stmt|;
else|else
name|cpp_define
argument_list|(
name|pfile
argument_list|,
name|p
operator|->
name|arg
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|p
operator|=
name|opts
operator|->
name|pending
operator|->
name|assert_head
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|debug_output
condition|)
name|output_line_command
argument_list|(
name|pfile
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|undef
condition|)
name|cpp_unassert
argument_list|(
name|pfile
argument_list|,
name|p
operator|->
name|arg
argument_list|)
expr_stmt|;
else|else
name|cpp_assert
argument_list|(
name|pfile
argument_list|,
name|p
operator|->
name|arg
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|opts
operator|->
name|done_initializing
operator|=
literal|1
expr_stmt|;
comment|/* Several environment variables may add to the include search path.      CPATH specifies an additional list of directories to be searched      as if specified with -I, while C_INCLUDE_PATH, CPLUS_INCLUDE_PATH,      etc. specify an additional list of directories to be searched as      if specified with -isystem, for the language indicated.       These variables are ignored if -nostdinc is on.  */
if|if
condition|(
operator|!
name|opts
operator|->
name|no_standard_includes
condition|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|GET_ENV_PATH_LIST
argument_list|(
name|path
argument_list|,
literal|"CPATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|!=
literal|0
operator|&&
operator|*
name|path
operator|!=
literal|0
condition|)
name|path_include
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|pending
argument_list|,
name|path
argument_list|,
name|BRACKET
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|opts
operator|->
name|objc
operator|<<
literal|1
operator|)
operator|+
name|opts
operator|->
name|cplusplus
condition|)
block|{
case|case
literal|0
case|:
name|GET_ENV_PATH_LIST
argument_list|(
name|path
argument_list|,
literal|"C_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|GET_ENV_PATH_LIST
argument_list|(
name|path
argument_list|,
literal|"CPLUS_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|GET_ENV_PATH_LIST
argument_list|(
name|path
argument_list|,
literal|"OBJC_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|GET_ENV_PATH_LIST
argument_list|(
name|path
argument_list|,
literal|"OBJCPLUS_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|path
operator|!=
literal|0
operator|&&
operator|*
name|path
operator|!=
literal|0
condition|)
name|path_include
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|pending
argument_list|,
name|path
argument_list|,
name|SYSTEM
argument_list|)
expr_stmt|;
block|}
comment|/* Unless -nostdinc, add the compiled-in include path to the list,      translating prefixes. */
if|if
condition|(
operator|!
name|opts
operator|->
name|no_standard_includes
condition|)
block|{
name|struct
name|default_include
modifier|*
name|p
init|=
name|include_defaults_array
decl_stmt|;
name|char
modifier|*
name|specd_prefix
init|=
name|opts
operator|->
name|include_prefix
decl_stmt|;
comment|/* Search "translated" versions of GNU directories. 	 These have /usr/local/lib/gcc... replaced by specd_prefix.  */
if|if
condition|(
name|specd_prefix
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|default_prefix
init|=
name|alloca
argument_list|(
sizeof|sizeof
name|GCC_INCLUDE_DIR
operator|-
literal|7
argument_list|)
decl_stmt|;
comment|/* Remove the `include' from /usr/local/lib/gcc.../include. 	     GCC_INCLUDE_DIR will always end in /include. */
name|int
name|default_len
init|=
sizeof|sizeof
name|GCC_INCLUDE_DIR
operator|-
literal|8
decl_stmt|;
name|int
name|specd_len
init|=
name|strlen
argument_list|(
name|specd_prefix
argument_list|)
decl_stmt|;
name|default_len
operator|=
sizeof|sizeof
name|GCC_INCLUDE_DIR
operator|-
literal|8
expr_stmt|;
name|memcpy
argument_list|(
name|default_prefix
argument_list|,
name|GCC_INCLUDE_DIR
argument_list|,
name|default_len
argument_list|)
expr_stmt|;
name|default_prefix
index|[
name|default_len
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|include_defaults_array
init|;
name|p
operator|->
name|fname
condition|;
name|p
operator|++
control|)
block|{
comment|/* Some standard dirs are only for C++.  */
if|if
condition|(
operator|!
name|p
operator|->
name|cplusplus
operator|||
operator|(
name|opts
operator|->
name|cplusplus
operator|&&
operator|!
name|opts
operator|->
name|no_standard_cplusplus_includes
operator|)
condition|)
block|{
comment|/* Does this dir start with the prefix?  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
operator|->
name|fname
argument_list|,
name|default_prefix
argument_list|,
name|default_len
argument_list|)
condition|)
block|{
comment|/* Yes; change prefix and add to search list.  */
name|int
name|flen
init|=
name|strlen
argument_list|(
name|p
operator|->
name|fname
argument_list|)
decl_stmt|;
name|int
name|this_len
init|=
name|specd_len
operator|+
name|flen
operator|-
name|default_len
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|this_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|specd_prefix
argument_list|,
name|specd_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|str
operator|+
name|specd_len
argument_list|,
name|p
operator|->
name|fname
operator|+
name|default_len
argument_list|,
name|flen
operator|-
name|default_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|pending
argument_list|,
name|str
argument_list|,
name|SYSTEM
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Search ordinary names for GNU include directories.  */
for|for
control|(
name|p
operator|=
name|include_defaults_array
init|;
name|p
operator|->
name|fname
condition|;
name|p
operator|++
control|)
block|{
comment|/* Some standard dirs are only for C++.  */
if|if
condition|(
operator|!
name|p
operator|->
name|cplusplus
operator|||
operator|(
name|opts
operator|->
name|cplusplus
operator|&&
operator|!
name|opts
operator|->
name|no_standard_cplusplus_includes
operator|)
condition|)
block|{
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
name|update_path
argument_list|(
name|p
operator|->
name|fname
argument_list|,
name|p
operator|->
name|component
argument_list|)
decl_stmt|;
name|str
operator|=
name|xstrdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* XXX Potential memory leak! */
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|pending
argument_list|,
name|str
argument_list|,
name|SYSTEM
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|merge_include_chains
argument_list|(
name|opts
argument_list|)
expr_stmt|;
comment|/* With -v, print the list of dirs to search.  */
if|if
condition|(
name|opts
operator|->
name|verbose
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|p
decl_stmt|;
name|cpp_message
argument_list|(
name|pfile
argument_list|,
operator|-
literal|1
argument_list|,
literal|"#include \"...\" search starts here:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|opts
operator|->
name|quote_include
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|==
name|opts
operator|->
name|bracket_include
condition|)
name|cpp_message
argument_list|(
name|pfile
argument_list|,
operator|-
literal|1
argument_list|,
literal|"#include<...> search starts here:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s\n"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|cpp_message
argument_list|(
name|pfile
argument_list|,
operator|-
literal|1
argument_list|,
literal|"End of search list.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Open the main input file.      We do this in nonblocking mode so we don't get stuck here if      someone clever has asked cpp to process /dev/rmt0;      finclude() will check that we have a real file to work with.  */
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
operator|*
name|fname
operator|==
literal|0
condition|)
block|{
name|fname
operator|=
literal|""
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
operator||
name|O_NOCTTY
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|cpp_pfatal_with_name
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|initialize_dependency_output
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Must call finclude() on the main input before processing      -include switches; otherwise the -included text winds up      after the main input. */
name|ih_fake
operator|=
operator|(
expr|struct
name|include_hash
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|include_hash
argument_list|)
argument_list|)
expr_stmt|;
name|ih_fake
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|ih_fake
operator|->
name|next_this_file
operator|=
literal|0
expr_stmt|;
name|ih_fake
operator|->
name|foundhere
operator|=
name|ABSOLUTE_PATH
expr_stmt|;
comment|/* well sort of ... */
name|ih_fake
operator|->
name|name
operator|=
name|fname
expr_stmt|;
name|ih_fake
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|ih_fake
operator|->
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|ih_fake
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|finclude
argument_list|(
name|pfile
argument_list|,
name|f
argument_list|,
name|ih_fake
argument_list|)
condition|)
return|return
literal|0
return|;
name|output_line_command
argument_list|(
name|pfile
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|2
expr_stmt|;
comment|/* The -imacros files can be scanned now, but the -include files      have to be pushed onto the include stack and processed later,      in the main loop calling cpp_get_token.  */
name|pfile
operator|->
name|no_record_file
operator|++
expr_stmt|;
name|opts
operator|->
name|no_output
operator|++
expr_stmt|;
name|p
operator|=
name|opts
operator|->
name|pending
operator|->
name|imacros_head
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|p
operator|->
name|arg
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
operator||
name|O_NOCTTY
argument_list|,
literal|0666
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|cpp_perror_with_name
argument_list|(
name|pfile
argument_list|,
name|p
operator|->
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|ih_fake
operator|=
operator|(
expr|struct
name|include_hash
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|include_hash
argument_list|)
argument_list|)
expr_stmt|;
name|ih_fake
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|ih_fake
operator|->
name|next_this_file
operator|=
literal|0
expr_stmt|;
name|ih_fake
operator|->
name|foundhere
operator|=
name|ABSOLUTE_PATH
expr_stmt|;
comment|/* well sort of ... */
name|ih_fake
operator|->
name|name
operator|=
name|p
operator|->
name|arg
expr_stmt|;
name|ih_fake
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|ih_fake
operator|->
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|ih_fake
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|finclude
argument_list|(
name|pfile
argument_list|,
name|fd
argument_list|,
name|ih_fake
argument_list|)
condition|)
name|cpp_scan_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ih_fake
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|opts
operator|->
name|no_output
operator|--
expr_stmt|;
name|p
operator|=
name|opts
operator|->
name|pending
operator|->
name|include_head
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|p
operator|->
name|arg
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
operator||
name|O_NOCTTY
argument_list|,
literal|0666
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|cpp_perror_with_name
argument_list|(
name|pfile
argument_list|,
name|p
operator|->
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|ih_fake
operator|=
operator|(
expr|struct
name|include_hash
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|include_hash
argument_list|)
argument_list|)
expr_stmt|;
name|ih_fake
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|ih_fake
operator|->
name|next_this_file
operator|=
literal|0
expr_stmt|;
name|ih_fake
operator|->
name|foundhere
operator|=
name|ABSOLUTE_PATH
expr_stmt|;
comment|/* well sort of ... */
name|ih_fake
operator|->
name|name
operator|=
name|p
operator|->
name|arg
expr_stmt|;
name|ih_fake
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|ih_fake
operator|->
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|ih_fake
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|finclude
argument_list|(
name|pfile
argument_list|,
name|fd
argument_list|,
name|ih_fake
argument_list|)
condition|)
name|output_line_command
argument_list|(
name|pfile
argument_list|,
name|enter_file
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|pfile
operator|->
name|no_record_file
operator|--
expr_stmt|;
name|free
argument_list|(
name|opts
operator|->
name|pending
argument_list|)
expr_stmt|;
name|opts
operator|->
name|pending
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This is called at the end of preprocessing.  It pops the    last buffer and writes dependency output.  It should also    clear macro definitions, such that you could call cpp_start_read    with a new filename to restart processing. */
end_comment

begin_function
name|void
name|cpp_finish
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|struct
name|cpp_options
modifier|*
name|opts
init|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|CPP_PREV_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"cpplib internal error: buffers still stacked in cpp_finish"
argument_list|)
expr_stmt|;
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|print_deps
condition|)
block|{
comment|/* Stream on which to print the dependency information.  */
name|FILE
modifier|*
name|deps_stream
decl_stmt|;
comment|/* Don't actually write the deps file if compilation has failed.  */
if|if
condition|(
name|pfile
operator|->
name|errors
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|deps_mode
init|=
name|opts
operator|->
name|print_deps_append
condition|?
literal|"a"
else|:
literal|"w"
decl_stmt|;
if|if
condition|(
name|opts
operator|->
name|deps_file
operator|==
literal|0
condition|)
name|deps_stream
operator|=
name|stdout
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|deps_stream
operator|=
name|fopen
argument_list|(
name|opts
operator|->
name|deps_file
argument_list|,
name|deps_mode
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|cpp_pfatal_with_name
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|deps_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|pfile
operator|->
name|deps_buffer
argument_list|,
name|deps_stream
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|deps_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|deps_file
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|deps_stream
argument_list|)
operator|||
name|fclose
argument_list|(
name|deps_stream
argument_list|)
operator|!=
literal|0
condition|)
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"I/O error on output"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|opts
operator|->
name|dump_macros
operator|==
name|dump_only
condition|)
block|{
name|int
name|i
decl_stmt|;
name|HASHNODE
modifier|*
name|h
decl_stmt|;
name|MACRODEF
name|m
decl_stmt|;
for|for
control|(
name|i
operator|=
name|HASHSIZE
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
for|for
control|(
name|h
operator|=
name|pfile
operator|->
name|hashtab
index|[
name|i
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|T_MACRO
condition|)
block|{
name|m
operator|.
name|defn
operator|=
name|h
operator|->
name|value
operator|.
name|defn
expr_stmt|;
name|m
operator|.
name|symnam
operator|=
name|h
operator|->
name|name
expr_stmt|;
name|m
operator|.
name|symlen
operator|=
name|h
operator|->
name|length
expr_stmt|;
name|dump_definition
argument_list|(
name|pfile
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle one command-line option in (argc, argv).    Can be called multiple times, to handle multiple sets of options.    Returns number of strings consumed.  */
end_comment

begin_function
name|int
name|cpp_handle_option
parameter_list|(
name|pfile
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|cpp_options
modifier|*
name|opts
init|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|out_fname
operator|!=
name|NULL
condition|)
block|{
name|print_help
argument_list|()
expr_stmt|;
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"Too many arguments"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opts
operator|->
name|in_fname
operator|!=
name|NULL
condition|)
name|opts
operator|->
name|out_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
else|else
name|opts
operator|->
name|in_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'f'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fleading-underscore"
argument_list|)
condition|)
name|user_label_prefix
operator|=
literal|"_"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fno-leading-underscore"
argument_list|)
condition|)
name|user_label_prefix
operator|=
literal|""
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Add directory to path for includes.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
comment|/* -I- means: 	       Use the preceding -I directories for #include "..." 	       but not #include<...>. 	       Don't search the directory of the present file 	       for #include "...".  (Note that -I. -I- is not the same as 	       the default setup; -I. uses the compiler's working dir.)  */
if|if
condition|(
operator|!
name|opts
operator|->
name|ignore_srcdir
condition|)
block|{
name|opts
operator|->
name|ignore_srcdir
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|pending
operator|->
name|quote_head
operator|=
name|opts
operator|->
name|pending
operator|->
name|brack_head
expr_stmt|;
name|opts
operator|->
name|pending
operator|->
name|quote_tail
operator|=
name|opts
operator|->
name|pending
operator|->
name|brack_tail
expr_stmt|;
name|opts
operator|->
name|pending
operator|->
name|brack_head
operator|=
literal|0
expr_stmt|;
name|opts
operator|->
name|pending
operator|->
name|brack_tail
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"-I- specified twice"
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|fname
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_dirname
goto|;
else|else
name|fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|pending
argument_list|,
name|xstrdup
argument_list|(
name|fname
argument_list|)
argument_list|,
name|BRACKET
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
comment|/* Add directory to beginning of system include path, as a system 	   include directory. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-isystem"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_filename
goto|;
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|pending
argument_list|,
name|xstrdup
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
argument_list|,
name|SYSTEM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-include"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_filename
goto|;
else|else
block|{
name|struct
name|pending_option
modifier|*
name|o
init|=
operator|(
expr|struct
name|pending_option
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_option
argument_list|)
argument_list|)
decl_stmt|;
name|o
operator|->
name|arg
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
comment|/* This list has to be built in reverse order so that 		   when cpp_start_read pushes all the -include files onto 		   the buffer stack, they will be scanned in forward order.  */
name|o
operator|->
name|next
operator|=
name|opts
operator|->
name|pending
operator|->
name|include_head
expr_stmt|;
name|opts
operator|->
name|pending
operator|->
name|include_head
operator|=
name|o
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-imacros"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_filename
goto|;
else|else
block|{
name|struct
name|pending_option
modifier|*
name|o
init|=
operator|(
expr|struct
name|pending_option
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_option
argument_list|)
argument_list|)
decl_stmt|;
name|o
operator|->
name|arg
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|o
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|APPEND
argument_list|(
name|opts
operator|->
name|pending
argument_list|,
name|imacros
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add directory to end of path for includes, 	   with the default prefix at the front of its name.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iwithprefix"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_dirname
goto|;
operator|++
name|i
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|include_prefix
operator|!=
literal|0
condition|)
block|{
name|fname
operator|=
name|xmalloc
argument_list|(
name|opts
operator|->
name|include_prefix_len
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
argument_list|,
name|opts
operator|->
name|include_prefix
argument_list|,
name|opts
operator|->
name|include_prefix_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
operator|+
name|opts
operator|->
name|include_prefix_len
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fname
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
name|GCC_INCLUDE_DIR
operator|-
literal|8
operator|+
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
argument_list|,
name|GCC_INCLUDE_DIR
argument_list|,
sizeof|sizeof
name|GCC_INCLUDE_DIR
operator|-
literal|9
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
operator|+
sizeof|sizeof
name|GCC_INCLUDE_DIR
operator|-
literal|9
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|pending
argument_list|,
name|fname
argument_list|,
name|SYSTEM
argument_list|)
expr_stmt|;
block|}
comment|/* Add directory to main path for includes, 	   with the default prefix at the front of its name.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iwithprefixbefore"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_dirname
goto|;
operator|++
name|i
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|include_prefix
operator|!=
literal|0
condition|)
block|{
name|fname
operator|=
name|xmalloc
argument_list|(
name|opts
operator|->
name|include_prefix_len
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
argument_list|,
name|opts
operator|->
name|include_prefix
argument_list|,
name|opts
operator|->
name|include_prefix_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
operator|+
name|opts
operator|->
name|include_prefix_len
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fname
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
name|GCC_INCLUDE_DIR
operator|-
literal|8
operator|+
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
argument_list|,
name|GCC_INCLUDE_DIR
argument_list|,
sizeof|sizeof
name|GCC_INCLUDE_DIR
operator|-
literal|9
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
operator|+
sizeof|sizeof
name|GCC_INCLUDE_DIR
operator|-
literal|9
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|pending
argument_list|,
name|fname
argument_list|,
name|BRACKET
argument_list|)
expr_stmt|;
block|}
comment|/* Add directory to end of path for includes.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-idirafter"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_dirname
goto|;
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|pending
argument_list|,
name|xstrdup
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
argument_list|,
name|AFTER
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iprefix"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_filename
goto|;
else|else
block|{
name|opts
operator|->
name|include_prefix
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|opts
operator|->
name|include_prefix_len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-ifoutput"
argument_list|)
condition|)
name|opts
operator|->
name|output_conditionals
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|opts
operator|->
name|out_fname
operator|!=
name|NULL
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"Output filename specified twice"
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_filename
goto|;
name|opts
operator|->
name|out_fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|opts
operator|->
name|out_fname
argument_list|,
literal|"-"
argument_list|)
condition|)
name|opts
operator|->
name|out_fname
operator|=
literal|""
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pedantic"
argument_list|)
condition|)
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pedantic-errors"
argument_list|)
condition|)
block|{
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|pedantic_errors
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else if (!strcmp (argv[i], "-pcp")) { 	  char *pcp_fname = argv[++i]; 	  pcp_outfile = ((pcp_fname[0] != '-' || pcp_fname[1] != '\0') 			 ? fopen (pcp_fname, "w") 			 : fdopen (dup (fileno (stdout)), "w")); 	  if (pcp_outfile == 0) 	    cpp_pfatal_with_name (pfile, pcp_fname); 	  no_precomp = 1; 	}
endif|#
directive|endif
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-traditional"
argument_list|)
condition|)
block|{
name|opts
operator|->
name|traditional
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-trigraphs"
argument_list|)
condition|)
name|opts
operator|->
name|trigraphs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-c"
argument_list|)
condition|)
name|opts
operator|->
name|cplusplus
operator|=
literal|0
operator|,
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|1
operator|,
name|opts
operator|->
name|c89
operator|=
literal|0
operator|,
name|opts
operator|->
name|c9x
operator|=
literal|1
operator|,
name|opts
operator|->
name|objc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-c89"
argument_list|)
condition|)
name|opts
operator|->
name|cplusplus
operator|=
literal|0
operator|,
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|0
operator|,
name|opts
operator|->
name|c89
operator|=
literal|1
operator|,
name|opts
operator|->
name|c9x
operator|=
literal|0
operator|,
name|opts
operator|->
name|objc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-c++"
argument_list|)
condition|)
name|opts
operator|->
name|cplusplus
operator|=
literal|1
operator|,
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|1
operator|,
name|opts
operator|->
name|c89
operator|=
literal|0
operator|,
name|opts
operator|->
name|c9x
operator|=
literal|0
operator|,
name|opts
operator|->
name|objc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-objc"
argument_list|)
condition|)
name|opts
operator|->
name|cplusplus
operator|=
literal|0
operator|,
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|1
operator|,
name|opts
operator|->
name|c89
operator|=
literal|0
operator|,
name|opts
operator|->
name|c9x
operator|=
literal|0
operator|,
name|opts
operator|->
name|objc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-objc++"
argument_list|)
condition|)
name|opts
operator|->
name|cplusplus
operator|=
literal|1
operator|,
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|1
operator|,
name|opts
operator|->
name|c89
operator|=
literal|0
operator|,
name|opts
operator|->
name|c9x
operator|=
literal|0
operator|,
name|opts
operator|->
name|objc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-asm"
argument_list|)
condition|)
name|opts
operator|->
name|lang_asm
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lint"
argument_list|)
condition|)
name|opts
operator|->
name|for_lint
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-chill"
argument_list|)
condition|)
name|opts
operator|->
name|objc
operator|=
literal|0
operator|,
name|opts
operator|->
name|cplusplus
operator|=
literal|0
operator|,
name|opts
operator|->
name|chill
operator|=
literal|1
operator|,
name|opts
operator|->
name|traditional
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|opts
operator|->
name|cplusplus
operator|=
literal|1
operator|,
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-std=iso9899:1990"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-std=iso9899:199409"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-std=c89"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-std=gnu89"
argument_list|)
condition|)
name|opts
operator|->
name|cplusplus
operator|=
literal|0
operator|,
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|0
operator|,
name|opts
operator|->
name|c89
operator|=
literal|1
operator|,
name|opts
operator|->
name|c9x
operator|=
literal|0
operator|,
name|opts
operator|->
name|objc
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-std=iso9899:199x"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-std=c9x"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-std=gnu9x"
argument_list|)
condition|)
name|opts
operator|->
name|cplusplus
operator|=
literal|0
operator|,
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|1
operator|,
name|opts
operator|->
name|c89
operator|=
literal|0
operator|,
name|opts
operator|->
name|c9x
operator|=
literal|1
operator|,
name|opts
operator|->
name|objc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|opts
operator|->
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wtrigraphs"
argument_list|)
condition|)
name|opts
operator|->
name|warn_trigraphs
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-trigraphs"
argument_list|)
condition|)
name|opts
operator|->
name|warn_trigraphs
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wcomment"
argument_list|)
condition|)
name|opts
operator|->
name|warn_comments
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-comment"
argument_list|)
condition|)
name|opts
operator|->
name|warn_comments
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wcomments"
argument_list|)
condition|)
name|opts
operator|->
name|warn_comments
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-comments"
argument_list|)
condition|)
name|opts
operator|->
name|warn_comments
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wtraditional"
argument_list|)
condition|)
name|opts
operator|->
name|warn_stringify
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-traditional"
argument_list|)
condition|)
name|opts
operator|->
name|warn_stringify
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wundef"
argument_list|)
condition|)
name|opts
operator|->
name|warn_undef
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-undef"
argument_list|)
condition|)
name|opts
operator|->
name|warn_undef
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wimport"
argument_list|)
condition|)
name|opts
operator|->
name|warn_import
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-import"
argument_list|)
condition|)
name|opts
operator|->
name|warn_import
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Werror"
argument_list|)
condition|)
name|opts
operator|->
name|warnings_are_errors
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-error"
argument_list|)
condition|)
name|opts
operator|->
name|warnings_are_errors
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wall"
argument_list|)
condition|)
block|{
name|opts
operator|->
name|warn_trigraphs
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|warn_comments
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'M'
case|:
comment|/* The style of the choices here is a bit mixed. 	   The chosen scheme is a hybrid of keeping all options in one string 	   and specifying each option in a separate argument: 	   -M|-MM|-MD file|-MMD file [-MG].  An alternative is: 	   -M|-MM|-MD file|-MMD file|-MG|-MMG; or more concisely: 	   -M[M][G][D file].  This is awkward to handle in specs, and is not 	   as extensible.  */
comment|/* ??? -MG must be specified in addition to one of -M or -MM. 	   This can be relaxed in the future without breaking anything. 	   The converse isn't true.  */
comment|/* -MG isn't valid with -MD or -MMD.  This is checked for later.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MG"
argument_list|)
condition|)
block|{
name|opts
operator|->
name|print_deps_missing_files
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-M"
argument_list|)
condition|)
name|opts
operator|->
name|print_deps
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MM"
argument_list|)
condition|)
name|opts
operator|->
name|print_deps
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MD"
argument_list|)
condition|)
name|opts
operator|->
name|print_deps
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MMD"
argument_list|)
condition|)
name|opts
operator|->
name|print_deps
operator|=
literal|1
expr_stmt|;
comment|/* For -MD and -MMD options, write deps on file named by next arg.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MD"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MMD"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_filename
goto|;
name|opts
operator|->
name|deps_file
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* For -M and -MM, write deps on standard output 	       and suppress the usual output.  */
name|opts
operator|->
name|no_output
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
block|{
name|char
modifier|*
name|p
init|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Arg to -d specifies what parts of macros to dump */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'M'
case|:
name|opts
operator|->
name|dump_macros
operator|=
name|dump_only
expr_stmt|;
name|opts
operator|->
name|no_output
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|opts
operator|->
name|dump_macros
operator|=
name|dump_names
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|opts
operator|->
name|dump_macros
operator|=
name|dump_definitions
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|opts
operator|->
name|dump_includes
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|'3'
condition|)
name|opts
operator|->
name|debug_output
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"--help"
argument_list|)
condition|)
name|print_help
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"--version"
argument_list|)
condition|)
name|cpp_notice
argument_list|(
literal|"GNU CPP version %s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
case|case
literal|'v'
case|:
name|cpp_notice
argument_list|(
literal|"GNU CPP version %s"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_VERSION
name|TARGET_VERSION
expr_stmt|;
endif|#
directive|endif
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|opts
operator|->
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|opts
operator|->
name|print_include_names
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
block|{
name|struct
name|pending_option
modifier|*
name|o
init|=
operator|(
expr|struct
name|pending_option
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_option
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|o
operator|->
name|arg
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"Macro name missing after -D option"
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
else|else
name|o
operator|->
name|arg
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|o
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|o
operator|->
name|undef
operator|=
literal|0
expr_stmt|;
name|APPEND
argument_list|(
name|opts
operator|->
name|pending
argument_list|,
name|define
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'A'
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|p
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"Assertion missing after -A option"
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
else|else
name|p
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|struct
name|pending_option
modifier|*
name|o
init|=
operator|(
expr|struct
name|pending_option
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_option
argument_list|)
argument_list|)
decl_stmt|;
name|o
operator|->
name|arg
operator|=
name|p
expr_stmt|;
name|o
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|o
operator|->
name|undef
operator|=
literal|0
expr_stmt|;
name|APPEND
argument_list|(
name|opts
operator|->
name|pending
argument_list|,
name|assert
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* -A- eliminates all predefined macros and assertions. 		 Let's include also any that were specified earlier 		 on the command line.  That way we can get rid of any 		 that were passed automatically in from GCC.  */
name|struct
name|pending_option
modifier|*
name|o1
decl_stmt|,
modifier|*
name|o2
decl_stmt|;
name|o1
operator|=
name|opts
operator|->
name|pending
operator|->
name|define_head
expr_stmt|;
while|while
condition|(
name|o1
condition|)
block|{
name|o2
operator|=
name|o1
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|o1
argument_list|)
expr_stmt|;
name|o1
operator|=
name|o2
expr_stmt|;
block|}
name|o1
operator|=
name|opts
operator|->
name|pending
operator|->
name|assert_head
expr_stmt|;
while|while
condition|(
name|o1
condition|)
block|{
name|o2
operator|=
name|o1
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|o1
argument_list|)
expr_stmt|;
name|o1
operator|=
name|o2
expr_stmt|;
block|}
name|opts
operator|->
name|pending
operator|->
name|assert_head
operator|=
name|NULL
expr_stmt|;
name|opts
operator|->
name|pending
operator|->
name|assert_tail
operator|=
name|NULL
expr_stmt|;
name|opts
operator|->
name|pending
operator|->
name|define_head
operator|=
name|NULL
expr_stmt|;
name|opts
operator|->
name|pending
operator|->
name|define_tail
operator|=
name|NULL
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'U'
case|:
block|{
name|struct
name|pending_option
modifier|*
name|o
init|=
operator|(
expr|struct
name|pending_option
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_option
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|o
operator|->
name|arg
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"Macro name missing after -U option"
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
else|else
name|o
operator|->
name|arg
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|o
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|o
operator|->
name|undef
operator|=
literal|1
expr_stmt|;
name|APPEND
argument_list|(
name|opts
operator|->
name|pending
argument_list|,
name|define
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
name|opts
operator|->
name|put_out_comments
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* -E comes from cc -E; ignore it.  */
break|break;
case|case
literal|'P'
case|:
name|opts
operator|->
name|no_line_commands
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
comment|/* Don't include $ in identifiers.  */
name|opts
operator|->
name|dollars_in_ident
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-nostdinc"
argument_list|)
condition|)
comment|/* -nostdinc causes no default include directories. 	     You must specify all include-file directories with -I.  */
name|opts
operator|->
name|no_standard_includes
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-nostdinc++"
argument_list|)
condition|)
comment|/* -nostdinc++ causes no default C++-specific include directories. */
name|opts
operator|->
name|no_standard_cplusplus_includes
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|else if (!strcmp (argv[i], "-noprecomp")) 	  no_precomp = 1;
endif|#
directive|endif
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-remap"
argument_list|)
condition|)
name|opts
operator|->
name|remap
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
comment|/* JF handle '-' as file name meaning stdin or stdout */
if|if
condition|(
name|opts
operator|->
name|in_fname
operator|==
name|NULL
condition|)
name|opts
operator|->
name|in_fname
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|opts
operator|->
name|out_fname
operator|==
name|NULL
condition|)
name|opts
operator|->
name|out_fname
operator|=
literal|""
expr_stmt|;
else|else
return|return
name|i
return|;
comment|/* error */
break|break;
default|default:
return|return
name|i
return|;
block|}
return|return
name|i
operator|+
literal|1
return|;
name|missing_filename
label|:
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"Filename missing after `%s' option"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
name|missing_dirname
label|:
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"Directory name missing after `%s' option"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
end_function

begin_comment
comment|/* Handle command-line options in (argc, argv).    Can be called multiple times, to handle multiple sets of options.    Returns if an unrecognized option is seen.    Returns number of strings consumed.  */
end_comment

begin_function
name|int
name|cpp_handle_options
parameter_list|(
name|pfile
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|strings_processed
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|+=
name|strings_processed
control|)
block|{
name|strings_processed
operator|=
name|cpp_handle_option
argument_list|(
name|pfile
argument_list|,
name|argc
operator|-
name|i
argument_list|,
name|argv
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings_processed
operator|==
literal|0
condition|)
break|break;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_help
parameter_list|()
block|{
name|cpp_notice
argument_list|(
literal|"Usage: %s [switches] input output\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ Switches:\n\   -include<file>           Include the contents of<file> before other files\n\   -imacros<file>           Accept definition of macros in<file>\n\   -iprefix<path>           Specify<path> as a prefix for next two options\n\   -iwithprefix<dir>        Add<dir> to the end of the system include path\n\   -iwithprefixbefore<dir>  Add<dir> to the end of the main include path\n\   -isystem<dir>            Add<dir> to the start of the system include path\n\   -idirafter<dir>          Add<dir> to the end of the system include path\n\   -I<dir>                  Add<dir> to the end of the main include path\n\   -nostdinc                 Do not search system include directories\n\                              (dirs specified with -isystem will still be used)\n\   -nostdinc++               Do not search system include directories for C++\n\   -o<file>                 Put output into<file>\n\   -pedantic                 Issue all warnings demanded by strict ANSI C\n\   -traditional              Follow K&R pre-processor behaviour\n\   -trigraphs                Support ANSI C trigraphs\n\   -lang-c                   Assume that the input sources are in C\n\   -lang-c89                 Assume that the input sources are in C89\n\   -lang-c++                 Assume that the input sources are in C++\n\   -lang-objc                Assume that the input sources are in ObjectiveC\n\   -lang-objc++              Assume that the input sources are in ObjectiveC++\n\   -lang-asm                 Assume that the input sources are in assembler\n\   -lang-chill               Assume that the input sources are in Chill\n\   -std=<std name>           Specify the conformance standard; one of:\n\                             gnu89, gnu9x, c89, c9x, iso9899:1990,\n\                             iso9899:199409, iso9899:199x\n\   -+                        Allow parsing of C++ style features\n\   -w                        Inhibit warning messages\n\   -Wtrigraphs               Warn if trigraphs are encountered\n\   -Wno-trigraphs            Do not warn about trigraphs\n\   -Wcomment{s}              Warn if one comment starts inside another\n\   -Wno-comment{s}           Do not warn about comments\n\   -Wtraditional             Warn if a macro argument is/would be turned into\n\                              a string if -traditional is specified\n\   -Wno-traditional          Do not warn about stringification\n\   -Wundef                   Warn if an undefined macro is used by #if\n\   -Wno-undef                Do not warn about testing undefined macros\n\   -Wimport                  Warn about the use of the #import directive\n\   -Wno-import               Do not warn about the use of #import\n\   -Werror                   Treat all warnings as errors\n\   -Wno-error                Do not treat warnings as errors\n\   -Wall                     Enable all preprocessor warnings\n\   -M                        Generate make dependencies\n\   -MM                       As -M, but ignore system header files\n\   -MD                       As -M, but put output in a .d file\n\   -MMD                      As -MD, but ignore system header files\n\   -MG                       Treat missing header file as generated files\n\   -g                        Include #define and #undef directives in the output\n\   -D<macro>                 Define a<macro> with string '1' as its value\n\   -D<macro>=<val>           Define a<macro> with<val> as its value\n\   -A<question> (<answer>)   Assert the<answer> to<question>\n\   -U<macro>                 Undefine<macro> \n\   -v                        Display the version number\n\   -H                        Print the name of header files as they are used\n\   -C                        Do not discard comments\n\   -dM                       Display a list of macro definitions active at end\n\   -dD                       Preserve macro definitions in output\n\   -dN                       As -dD except that only the names are preserved\n\   -dI                       Include #include directives in the output\n\   -ifoutput                 Describe skipped code blocks in output \n\   -P                        Do not generate #line directives\n\   -$                        Do not allow '$' in identifiers\n\   -remap                    Remap file names when including files.\n\   -h or --help              Display this information\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

