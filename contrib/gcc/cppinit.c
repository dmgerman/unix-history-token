begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPP Library.    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Per Bothner, 1994-95.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_include
include|#
directive|include
file|"prefix.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"mkdeps.h"
end_include

begin_include
include|#
directive|include
file|"cppdefault.h"
end_include

begin_comment
comment|/* Windows does not natively support inodes, and neither does MSDOS.    Cygwin's emulation can generate non-unique inodes, so don't use it.    VMS has non-numeric inodes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|INO_T_EQ
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|(!memcmp (&(A),&(B), sizeof (A)))
end_define

begin_define
define|#
directive|define
name|INO_T_COPY
parameter_list|(
name|DEST
parameter_list|,
name|SRC
parameter_list|)
value|memcpy(&(DEST),&(SRC), sizeof (SRC))
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|(
name|defined
name|_WIN32
operator|&&
operator|!
name|defined
argument_list|(
name|_UWIN
argument_list|)
operator|)
operator|||
name|defined
name|__MSDOS__
end_if

begin_define
define|#
directive|define
name|INO_T_EQ
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INO_T_EQ
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A) == (B))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INO_T_COPY
parameter_list|(
name|DEST
parameter_list|,
name|SRC
parameter_list|)
value|(DEST) = (SRC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Internal structures and prototypes.  */
end_comment

begin_comment
comment|/* A `struct pending_option' remembers one -D, -A, -U, -include, or    -imacros switch.  */
end_comment

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|* cl_directive_handler
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_struct
struct|struct
name|pending_option
block|{
name|struct
name|pending_option
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|cl_directive_handler
name|handler
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The `pending' structure accumulates all the options that are not    actually processed until we hit cpp_read_main_file.  It consists of    several lists, one for each type of option.  We keep both head and    tail pointers for quick insertion.  */
end_comment

begin_struct
struct|struct
name|cpp_pending
block|{
name|struct
name|pending_option
modifier|*
name|directive_head
decl_stmt|,
modifier|*
name|directive_tail
decl_stmt|;
name|struct
name|search_path
modifier|*
name|quote_head
decl_stmt|,
modifier|*
name|quote_tail
decl_stmt|;
name|struct
name|search_path
modifier|*
name|brack_head
decl_stmt|,
modifier|*
name|brack_tail
decl_stmt|;
name|struct
name|search_path
modifier|*
name|systm_head
decl_stmt|,
modifier|*
name|systm_tail
decl_stmt|;
name|struct
name|search_path
modifier|*
name|after_head
decl_stmt|,
modifier|*
name|after_tail
decl_stmt|;
name|struct
name|pending_option
modifier|*
name|imacros_head
decl_stmt|,
modifier|*
name|imacros_tail
decl_stmt|;
name|struct
name|pending_option
modifier|*
name|include_head
decl_stmt|,
modifier|*
name|include_tail
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|APPEND
parameter_list|(
name|pend
parameter_list|,
name|list
parameter_list|,
name|elt
parameter_list|)
define|\
value|do {  if (!(pend)->list##_head) (pend)->list##_head = (elt); \ 	else (pend)->list##_tail->next = (elt); \ 	(pend)->list##_tail = (elt); \   } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|APPEND
parameter_list|(
name|pend
parameter_list|,
name|list
parameter_list|,
name|elt
parameter_list|)
define|\
value|do {  if (!(pend)->list
comment|/**/
value|_head) (pend)->list
comment|/**/
value|_head = (elt); \ 	else (pend)->list
comment|/**/
value|_tail->next = (elt); \ 	(pend)->list
comment|/**/
value|_tail = (elt); \   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|path_include
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_library
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_builtins
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_named_operators
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_include_chain
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|search_path
modifier|*
name|remove_dup_dir
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|search_path
operator|*
operator|,
expr|struct
name|search_path
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|search_path
modifier|*
name|remove_dup_nonsys_dirs
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|search_path
operator|*
operator|*
operator|,
expr|struct
name|search_path
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|search_path
modifier|*
name|remove_dup_dirs
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|search_path
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_include_chains
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|push_include
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|pending_option
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_chain
name|PARAMS
argument_list|(
operator|(
expr|struct
name|pending_option
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_standard_includes
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_original_filename
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_pending_directive
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cpp_pending
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|cl_directive_handler
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_option
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|post_options
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fourth argument to append_include_chain: chain to use.    Note it's never asked to append to the quote chain.  */
end_comment

begin_enum
enum|enum
block|{
name|BRACKET
init|=
literal|0
block|,
name|SYSTEM
block|,
name|AFTER
block|}
enum|;
end_enum

begin_comment
comment|/* If we have designated initializers (GCC>2.7) these tables can be    initialized, constant data.  Otherwise, they have to be filled in at    runtime.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_DESIGNATED_INITIALIZERS
end_if

begin_define
define|#
directive|define
name|init_trigraph_map
parameter_list|()
end_define

begin_comment
comment|/* Nothing.  */
end_comment

begin_define
define|#
directive|define
name|TRIGRAPH_MAP
define|\
value|__extension__ const uchar _cpp_trigraph_map[UCHAR_MAX + 1] = {
end_define

begin_define
define|#
directive|define
name|END
value|};
end_define

begin_define
define|#
directive|define
name|s
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|[p] = v,
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TRIGRAPH_MAP
value|uchar _cpp_trigraph_map[UCHAR_MAX + 1] = { 0 }; \  static void init_trigraph_map PARAMS ((void)) { \  unsigned char *x = _cpp_trigraph_map;
end_define

begin_define
define|#
directive|define
name|END
value|}
end_define

begin_define
define|#
directive|define
name|s
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|x[p] = v;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|TRIGRAPH_MAP
name|s
argument_list|(
literal|'='
argument_list|,
literal|'#'
argument_list|)
name|s
argument_list|(
literal|')'
argument_list|,
literal|']'
argument_list|)
name|s
argument_list|(
literal|'!'
argument_list|,
literal|'|'
argument_list|)
name|s
argument_list|(
literal|'('
argument_list|,
literal|'['
argument_list|)
name|s
argument_list|(
literal|'\''
argument_list|,
literal|'^'
argument_list|)
name|s
argument_list|(
literal|'>'
argument_list|,
literal|'}'
argument_list|)
name|s
argument_list|(
literal|'/'
argument_list|,
literal|'\\'
argument_list|)
name|s
argument_list|(
literal|'<'
argument_list|,
literal|'{'
argument_list|)
name|s
argument_list|(
literal|'-'
argument_list|,
literal|'~'
argument_list|)
name|END
undef|#
directive|undef
name|s
undef|#
directive|undef
name|END
undef|#
directive|undef
name|TRIGRAPH_MAP
comment|/* Given a colon-separated list of file names PATH,    add all the names to the search path for include files.  */
decl|static
name|void
name|path_include
argument_list|(
name|pfile
argument_list|,
name|list
argument_list|,
name|path
argument_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|path
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|p
operator|=
name|list
expr_stmt|;
do|do
block|{
comment|/* Find the end of this name.  */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|0
operator|&&
operator|*
name|q
operator|!=
name|PATH_SEPARATOR
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|p
condition|)
block|{
comment|/* An empty name in the path stands for the current directory.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise use the directory that is named.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|q
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|name
index|[
name|q
operator|-
name|p
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|name
argument_list|,
name|path
argument_list|,
name|path
operator|==
name|SYSTEM
argument_list|)
expr_stmt|;
comment|/* Advance past this name.  */
if|if
condition|(
operator|*
name|q
operator|==
literal|0
condition|)
break|break;
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
end_block

begin_comment
comment|/* Append DIR to include path PATH.  DIR must be allocated on the    heap; this routine takes responsibility for freeing it.  CXX_AWARE    is nonzero if the header contains extern "C" guards for C++,    otherwise it is zero.  */
end_comment

begin_function
specifier|static
name|void
name|append_include_chain
parameter_list|(
name|pfile
parameter_list|,
name|dir
parameter_list|,
name|path
parameter_list|,
name|cxx_aware
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|path
decl_stmt|;
name|int
name|cxx_aware
decl_stmt|;
block|{
name|struct
name|cpp_pending
modifier|*
name|pend
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
decl_stmt|;
name|struct
name|search_path
modifier|*
name|new
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|dir
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|dir
operator|=
name|xstrdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|_cpp_simplify_pathname
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dir
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
comment|/* Dirs that don't exist are silently ignored.  */
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|DL_ERROR
argument_list|,
name|dir
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|verbose
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"ignoring nonexistent directory \"%s\"\n"
argument_list|)
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|DL_ERROR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: Not a directory"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|pfile
operator|->
name|max_include_len
condition|)
name|pfile
operator|->
name|max_include_len
operator|=
name|len
expr_stmt|;
name|new
operator|=
operator|(
expr|struct
name|search_path
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|search_path
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|dir
expr_stmt|;
name|new
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|INO_T_COPY
argument_list|(
name|new
operator|->
name|ino
argument_list|,
name|st
operator|.
name|st_ino
argument_list|)
expr_stmt|;
name|new
operator|->
name|dev
operator|=
name|st
operator|.
name|st_dev
expr_stmt|;
comment|/* Both systm and after include file lists should be treated as system      include files since these two lists are really just a concatenation      of one "system" list.  */
if|if
condition|(
name|path
operator|==
name|SYSTEM
operator|||
name|path
operator|==
name|AFTER
condition|)
name|new
operator|->
name|sysp
operator|=
name|cxx_aware
condition|?
literal|1
else|:
literal|2
expr_stmt|;
else|else
name|new
operator|->
name|sysp
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|name_map
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|path
condition|)
block|{
case|case
name|BRACKET
case|:
name|APPEND
argument_list|(
name|pend
argument_list|,
name|brack
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYSTEM
case|:
name|APPEND
argument_list|(
name|pend
argument_list|,
name|systm
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
case|case
name|AFTER
case|:
name|APPEND
argument_list|(
name|pend
argument_list|,
name|after
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Handle a duplicated include path.  PREV is the link in the chain    before the duplicate, or NULL if the duplicate is at the head of    the chain.  The duplicate is removed from the chain and freed.    Returns PREV.  */
end_comment

begin_function
specifier|static
name|struct
name|search_path
modifier|*
name|remove_dup_dir
parameter_list|(
name|pfile
parameter_list|,
name|prev
parameter_list|,
name|head_ptr
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|search_path
modifier|*
name|prev
decl_stmt|;
name|struct
name|search_path
modifier|*
modifier|*
name|head_ptr
decl_stmt|;
block|{
name|struct
name|search_path
modifier|*
name|cur
decl_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|cur
operator|=
name|prev
operator|->
name|next
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|cur
operator|=
operator|*
name|head_ptr
expr_stmt|;
operator|*
name|head_ptr
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|verbose
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"ignoring duplicate directory \"%s\"\n"
argument_list|)
argument_list|,
name|cur
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|cur
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cur
argument_list|)
expr_stmt|;
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Remove duplicate non-system directories for which there is an equivalent    system directory latter in the chain.  The range for removal is between    *HEAD_PTR and END.  Returns the directory before END, or NULL if none.    This algorithm is quadratic in the number system directories, which is    acceptable since there aren't usually that many of them.  */
end_comment

begin_function
specifier|static
name|struct
name|search_path
modifier|*
name|remove_dup_nonsys_dirs
parameter_list|(
name|pfile
parameter_list|,
name|head_ptr
parameter_list|,
name|end
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|search_path
modifier|*
modifier|*
name|head_ptr
decl_stmt|;
name|struct
name|search_path
modifier|*
name|end
decl_stmt|;
block|{
name|int
name|sysdir
init|=
literal|0
decl_stmt|;
name|struct
name|search_path
modifier|*
name|prev
init|=
name|NULL
decl_stmt|,
modifier|*
name|cur
decl_stmt|,
modifier|*
name|other
decl_stmt|;
for|for
control|(
name|cur
operator|=
operator|*
name|head_ptr
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|sysp
condition|)
block|{
name|sysdir
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|other
operator|=
operator|*
name|head_ptr
operator|,
name|prev
operator|=
name|NULL
init|;
name|other
operator|!=
name|end
condition|;
name|other
operator|=
name|other
condition|?
name|other
operator|->
name|next
else|:
operator|*
name|head_ptr
control|)
block|{
if|if
condition|(
operator|!
name|other
operator|->
name|sysp
operator|&&
name|INO_T_EQ
argument_list|(
name|cur
operator|->
name|ino
argument_list|,
name|other
operator|->
name|ino
argument_list|)
operator|&&
name|cur
operator|->
name|dev
operator|==
name|other
operator|->
name|dev
condition|)
block|{
name|other
operator|=
name|remove_dup_dir
argument_list|(
name|pfile
argument_list|,
name|prev
argument_list|,
name|head_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|verbose
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  as it is a non-system directory that duplicates a system directory\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|other
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|sysdir
condition|)
for|for
control|(
name|cur
operator|=
operator|*
name|head_ptr
init|;
name|cur
operator|!=
name|end
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
name|prev
operator|=
name|cur
expr_stmt|;
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Remove duplicate directories from a chain.  Returns the tail of the    chain, or NULL if the chain is empty.  This algorithm is quadratic    in the number of -I switches, which is acceptable since there    aren't usually that many of them.  */
end_comment

begin_function
specifier|static
name|struct
name|search_path
modifier|*
name|remove_dup_dirs
parameter_list|(
name|pfile
parameter_list|,
name|head_ptr
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|search_path
modifier|*
modifier|*
name|head_ptr
decl_stmt|;
block|{
name|struct
name|search_path
modifier|*
name|prev
init|=
name|NULL
decl_stmt|,
modifier|*
name|cur
decl_stmt|,
modifier|*
name|other
decl_stmt|;
for|for
control|(
name|cur
operator|=
operator|*
name|head_ptr
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
for|for
control|(
name|other
operator|=
operator|*
name|head_ptr
init|;
name|other
operator|!=
name|cur
condition|;
name|other
operator|=
name|other
operator|->
name|next
control|)
if|if
condition|(
name|INO_T_EQ
argument_list|(
name|cur
operator|->
name|ino
argument_list|,
name|other
operator|->
name|ino
argument_list|)
operator|&&
name|cur
operator|->
name|dev
operator|==
name|other
operator|->
name|dev
condition|)
block|{
name|cur
operator|=
name|remove_dup_dir
argument_list|(
name|pfile
argument_list|,
name|prev
argument_list|,
name|head_ptr
argument_list|)
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|cur
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Merge the four include chains together in the order quote, bracket,    system, after.  Remove duplicate dirs (as determined by    INO_T_EQ()).  The system_include and after_include chains are never    referred to again after this function; all access is through the    bracket_include path.  */
end_comment

begin_function
specifier|static
name|void
name|merge_include_chains
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|struct
name|search_path
modifier|*
name|quote
decl_stmt|,
modifier|*
name|brack
decl_stmt|,
modifier|*
name|systm
decl_stmt|,
modifier|*
name|qtail
decl_stmt|;
name|struct
name|cpp_pending
modifier|*
name|pend
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
decl_stmt|;
name|quote
operator|=
name|pend
operator|->
name|quote_head
expr_stmt|;
name|brack
operator|=
name|pend
operator|->
name|brack_head
expr_stmt|;
name|systm
operator|=
name|pend
operator|->
name|systm_head
expr_stmt|;
name|qtail
operator|=
name|pend
operator|->
name|quote_tail
expr_stmt|;
comment|/* Paste together bracket, system, and after include chains.  */
if|if
condition|(
name|systm
condition|)
name|pend
operator|->
name|systm_tail
operator|->
name|next
operator|=
name|pend
operator|->
name|after_head
expr_stmt|;
else|else
name|systm
operator|=
name|pend
operator|->
name|after_head
expr_stmt|;
if|if
condition|(
name|brack
condition|)
name|pend
operator|->
name|brack_tail
operator|->
name|next
operator|=
name|systm
expr_stmt|;
else|else
name|brack
operator|=
name|systm
expr_stmt|;
comment|/* This is a bit tricky.  First we drop non-system dupes of system      directories from the merged bracket-include list.  Next we drop      dupes from the bracket and quote include lists.  Then we drop      non-system dupes from the merged quote-include list.  Finally,      if qtail and brack are the same directory, we cut out brack and      move brack up to point to qtail.       We can't just merge the lists and then uniquify them because      then we may lose directories from the<> search path that should      be there; consider -Ifoo -Ibar -I- -Ifoo -Iquux.  It is however      safe to treat -Ibar -Ifoo -I- -Ifoo -Iquux as if written      -Ibar -I- -Ifoo -Iquux.  */
name|remove_dup_nonsys_dirs
argument_list|(
name|pfile
argument_list|,
operator|&
name|brack
argument_list|,
name|systm
argument_list|)
expr_stmt|;
name|remove_dup_dirs
argument_list|(
name|pfile
argument_list|,
operator|&
name|brack
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
condition|)
block|{
name|qtail
operator|=
name|remove_dup_dirs
argument_list|(
name|pfile
argument_list|,
operator|&
name|quote
argument_list|)
expr_stmt|;
name|qtail
operator|->
name|next
operator|=
name|brack
expr_stmt|;
name|qtail
operator|=
name|remove_dup_nonsys_dirs
argument_list|(
name|pfile
argument_list|,
operator|&
name|quote
argument_list|,
name|brack
argument_list|)
expr_stmt|;
comment|/* If brack == qtail, remove brack as it's simpler.  */
if|if
condition|(
name|qtail
operator|&&
name|brack
operator|&&
name|INO_T_EQ
argument_list|(
name|qtail
operator|->
name|ino
argument_list|,
name|brack
operator|->
name|ino
argument_list|)
operator|&&
name|qtail
operator|->
name|dev
operator|==
name|brack
operator|->
name|dev
condition|)
name|brack
operator|=
name|remove_dup_dir
argument_list|(
name|pfile
argument_list|,
name|qtail
argument_list|,
operator|&
name|quote
argument_list|)
expr_stmt|;
block|}
else|else
name|quote
operator|=
name|brack
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|quote_include
argument_list|)
operator|=
name|quote
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|bracket_include
argument_list|)
operator|=
name|brack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A set of booleans indicating what CPP features each source language    requires.  */
end_comment

begin_struct
struct|struct
name|lang_flags
block|{
name|char
name|c99
decl_stmt|;
name|char
name|cplusplus
decl_stmt|;
name|char
name|extended_numbers
decl_stmt|;
name|char
name|std
decl_stmt|;
name|char
name|dollars_in_ident
decl_stmt|;
name|char
name|cplusplus_comments
decl_stmt|;
name|char
name|digraphs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ??? Enable $ in identifiers in assembly? */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|lang_flags
name|lang_defaults
index|[]
init|=
block|{
comment|/*              c99 c++ xnum std dollar c++comm digr  */
comment|/* GNUC89 */
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* GNUC99 */
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* STDC89 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* STDC94 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* STDC99 */
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* GNUCXX */
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* CXX98  */
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* ASM    */
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sets internal flags correctly for a given language.  */
end_comment

begin_function
name|void
name|cpp_set_lang
parameter_list|(
name|pfile
parameter_list|,
name|lang
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|enum
name|c_lang
name|lang
decl_stmt|;
block|{
specifier|const
name|struct
name|lang_flags
modifier|*
name|l
init|=
operator|&
name|lang_defaults
index|[
operator|(
name|int
operator|)
name|lang
index|]
decl_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|=
name|lang
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
operator|=
name|l
operator|->
name|c99
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
operator|=
name|l
operator|->
name|cplusplus
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|extended_numbers
argument_list|)
operator|=
name|l
operator|->
name|extended_numbers
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|std
argument_list|)
operator|=
name|l
operator|->
name|std
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|trigraphs
argument_list|)
operator|=
name|l
operator|->
name|std
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|dollars_in_ident
argument_list|)
operator|=
name|l
operator|->
name|dollars_in_ident
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus_comments
argument_list|)
operator|=
name|l
operator|->
name|cplusplus_comments
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|digraphs
argument_list|)
operator|=
name|l
operator|->
name|digraphs
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HOST_EBCDIC
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|opt_comp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Run-time sorting of options array.  */
end_comment

begin_function
specifier|static
name|int
name|opt_comp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|void
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|strcmp
argument_list|(
operator|(
operator|(
expr|struct
name|cl_option
operator|*
operator|)
name|p1
operator|)
operator|->
name|opt_text
argument_list|,
operator|(
operator|(
expr|struct
name|cl_option
operator|*
operator|)
name|p2
operator|)
operator|->
name|opt_text
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* init initializes library global state.  It might not need to    do anything depending on the platform and compiler.  */
end_comment

begin_function
specifier|static
name|void
name|init_library
parameter_list|()
block|{
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HOST_EBCDIC
comment|/* For non-ASCII hosts, the cl_options array needs to be sorted at 	 runtime.  */
name|qsort
argument_list|(
name|cl_options
argument_list|,
name|N_OPTS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cl_option
argument_list|)
argument_list|,
name|opt_comp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set up the trigraph map.  This doesn't need to do anything if 	 we were compiled with a compiler that supports C99 designated 	 initializers.  */
name|init_trigraph_map
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize a cpp_reader structure.  */
end_comment

begin_function
name|cpp_reader
modifier|*
name|cpp_create_reader
parameter_list|(
name|lang
parameter_list|)
name|enum
name|c_lang
name|lang
decl_stmt|;
block|{
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
comment|/* Initialize this instance of the library if it hasn't been already.  */
name|init_library
argument_list|()
expr_stmt|;
name|pfile
operator|=
operator|(
name|cpp_reader
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_reader
argument_list|)
argument_list|)
expr_stmt|;
name|cpp_set_lang
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_import
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_multichar
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments_in_macro_exp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|show_column
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|tabstop
argument_list|)
operator|=
literal|8
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|operator_names
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_endif_labels
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_long_long
argument_list|)
operator|=
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|=
operator|(
expr|struct
name|cpp_pending
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cpp_pending
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Default CPP arithmetic to something sensible for the host for the      benefit of dumb users like fix-header.  */
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
operator|=
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|char_precision
argument_list|)
operator|=
name|CHAR_BIT
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wchar_precision
argument_list|)
operator|=
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|int_precision
argument_list|)
operator|=
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|unsigned_char
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|unsigned_wchar
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Initialize the line map.  Start at logical line 1, so we can use      a line number of zero for special states.  */
name|init_line_maps
argument_list|(
operator|&
name|pfile
operator|->
name|line_maps
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|line
operator|=
literal|1
expr_stmt|;
comment|/* Initialize lexer state.  */
name|pfile
operator|->
name|state
operator|.
name|save_comments
operator|=
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments
argument_list|)
expr_stmt|;
comment|/* Set up static tokens.  */
name|pfile
operator|->
name|avoid_paste
operator|.
name|type
operator|=
name|CPP_PADDING
expr_stmt|;
name|pfile
operator|->
name|avoid_paste
operator|.
name|val
operator|.
name|source
operator|=
name|NULL
expr_stmt|;
name|pfile
operator|->
name|eof
operator|.
name|type
operator|=
name|CPP_EOF
expr_stmt|;
name|pfile
operator|->
name|eof
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* Create a token buffer for the lexer.  */
name|_cpp_init_tokenrun
argument_list|(
operator|&
name|pfile
operator|->
name|base_run
argument_list|,
literal|250
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|cur_run
operator|=
operator|&
name|pfile
operator|->
name|base_run
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|pfile
operator|->
name|base_run
operator|.
name|base
expr_stmt|;
comment|/* Initialize the base context.  */
name|pfile
operator|->
name|context
operator|=
operator|&
name|pfile
operator|->
name|base_context
expr_stmt|;
name|pfile
operator|->
name|base_context
operator|.
name|macro
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|base_context
operator|.
name|prev
operator|=
name|pfile
operator|->
name|base_context
operator|.
name|next
operator|=
literal|0
expr_stmt|;
comment|/* Aligned and unaligned storage.  */
name|pfile
operator|->
name|a_buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|u_buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The expression parser stack.  */
name|_cpp_expand_op_stack
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Initialize the buffer obstack.  */
name|gcc_obstack_init
argument_list|(
operator|&
name|pfile
operator|->
name|buffer_ob
argument_list|)
expr_stmt|;
name|_cpp_init_includes
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|pfile
return|;
block|}
end_function

begin_comment
comment|/* Free resources used by PFILE.  Accessing PFILE after this function    returns leads to undefined behavior.  Returns the error count.  */
end_comment

begin_function
name|void
name|cpp_destroy
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|struct
name|search_path
modifier|*
name|dir
decl_stmt|,
modifier|*
name|dirn
decl_stmt|;
name|cpp_context
modifier|*
name|context
decl_stmt|,
modifier|*
name|contextn
decl_stmt|;
name|tokenrun
modifier|*
name|run
decl_stmt|,
modifier|*
name|runn
decl_stmt|;
name|free_chain
argument_list|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|->
name|include_head
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfile
operator|->
name|op_stack
argument_list|)
expr_stmt|;
while|while
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|!=
name|NULL
condition|)
name|_cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|out
operator|.
name|base
condition|)
name|free
argument_list|(
name|pfile
operator|->
name|out
operator|.
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|macro_buffer
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|pfile
operator|->
name|macro_buffer
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|macro_buffer
operator|=
name|NULL
expr_stmt|;
name|pfile
operator|->
name|macro_buffer_len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|deps
condition|)
name|deps_free
argument_list|(
name|pfile
operator|->
name|deps
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|pfile
operator|->
name|buffer_ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_cpp_destroy_hashtable
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_cleanup_includes
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_free_buff
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
expr_stmt|;
name|_cpp_free_buff
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
name|_cpp_free_buff
argument_list|(
name|pfile
operator|->
name|free_buffs
argument_list|)
expr_stmt|;
for|for
control|(
name|run
operator|=
operator|&
name|pfile
operator|->
name|base_run
init|;
name|run
condition|;
name|run
operator|=
name|runn
control|)
block|{
name|runn
operator|=
name|run
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|run
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|!=
operator|&
name|pfile
operator|->
name|base_run
condition|)
name|free
argument_list|(
name|run
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|dir
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|quote_include
argument_list|)
init|;
name|dir
condition|;
name|dir
operator|=
name|dirn
control|)
block|{
name|dirn
operator|=
name|dir
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|dir
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|context
operator|=
name|pfile
operator|->
name|base_context
operator|.
name|next
init|;
name|context
condition|;
name|context
operator|=
name|contextn
control|)
block|{
name|contextn
operator|=
name|context
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|free_line_maps
argument_list|(
operator|&
name|pfile
operator|->
name|line_maps
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This structure defines one built-in identifier.  A node will be    entered in the hash table under the name NAME, with value VALUE.     There are two tables of these.  builtin_array holds all the    "builtin" macros: these are handled by builtin_macro() in    cppmacro.c.  Builtin is somewhat of a misnomer -- the property of    interest is that these macros require special code to compute their    expansions.  The value is a "builtin_type" enumerator.     operator_array holds the C++ named operators.  These are keywords    which act as aliases for punctuators.  In C++, they cannot be    altered through #define, and #if recognizes them as operators.  In    C, these are not entered into the hash table at all (but see<iso646.h>).  The value is a token-type enumerator.  */
end_comment

begin_struct
struct|struct
name|builtin
block|{
specifier|const
name|uchar
modifier|*
name|name
decl_stmt|;
name|unsigned
name|short
name|len
decl_stmt|;
name|unsigned
name|short
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|B
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
value|{ DSC(n), t }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin
name|builtin_array
index|[]
init|=
block|{
name|B
argument_list|(
literal|"__TIME__"
argument_list|,
name|BT_TIME
argument_list|)
block|,
name|B
argument_list|(
literal|"__DATE__"
argument_list|,
name|BT_DATE
argument_list|)
block|,
name|B
argument_list|(
literal|"__FILE__"
argument_list|,
name|BT_FILE
argument_list|)
block|,
name|B
argument_list|(
literal|"__BASE_FILE__"
argument_list|,
name|BT_BASE_FILE
argument_list|)
block|,
name|B
argument_list|(
literal|"__LINE__"
argument_list|,
name|BT_SPECLINE
argument_list|)
block|,
name|B
argument_list|(
literal|"__INCLUDE_LEVEL__"
argument_list|,
name|BT_INCLUDE_LEVEL
argument_list|)
block|,
comment|/* Keep builtins not used for -traditional-cpp at the end, and      update init_builtins() if any more are added.  */
name|B
argument_list|(
literal|"_Pragma"
argument_list|,
name|BT_PRAGMA
argument_list|)
block|,
name|B
argument_list|(
literal|"__STDC__"
argument_list|,
name|BT_STDC
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin
name|operator_array
index|[]
init|=
block|{
name|B
argument_list|(
literal|"and"
argument_list|,
name|CPP_AND_AND
argument_list|)
block|,
name|B
argument_list|(
literal|"and_eq"
argument_list|,
name|CPP_AND_EQ
argument_list|)
block|,
name|B
argument_list|(
literal|"bitand"
argument_list|,
name|CPP_AND
argument_list|)
block|,
name|B
argument_list|(
literal|"bitor"
argument_list|,
name|CPP_OR
argument_list|)
block|,
name|B
argument_list|(
literal|"compl"
argument_list|,
name|CPP_COMPL
argument_list|)
block|,
name|B
argument_list|(
literal|"not"
argument_list|,
name|CPP_NOT
argument_list|)
block|,
name|B
argument_list|(
literal|"not_eq"
argument_list|,
name|CPP_NOT_EQ
argument_list|)
block|,
name|B
argument_list|(
literal|"or"
argument_list|,
name|CPP_OR_OR
argument_list|)
block|,
name|B
argument_list|(
literal|"or_eq"
argument_list|,
name|CPP_OR_EQ
argument_list|)
block|,
name|B
argument_list|(
literal|"xor"
argument_list|,
name|CPP_XOR
argument_list|)
block|,
name|B
argument_list|(
literal|"xor_eq"
argument_list|,
argument|CPP_XOR_EQ
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|B
end_undef

begin_comment
comment|/* Mark the C++ named operators in the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|mark_named_operators
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|struct
name|builtin
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|operator_array
init|;
name|b
operator|<
operator|(
name|operator_array
operator|+
name|ARRAY_SIZE
argument_list|(
name|operator_array
argument_list|)
operator|)
condition|;
name|b
operator|++
control|)
block|{
name|cpp_hashnode
modifier|*
name|hp
init|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|b
operator|->
name|name
argument_list|,
name|b
operator|->
name|len
argument_list|)
decl_stmt|;
name|hp
operator|->
name|flags
operator||=
name|NODE_OPERATOR
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|operator
operator|=
name|b
operator|->
name|value
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of cpp_read_main_file; reads the builtins table above and    enters them, and language-specific macros, into the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|init_builtins
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|struct
name|builtin
modifier|*
name|b
decl_stmt|;
name|size_t
name|n
init|=
name|ARRAY_SIZE
argument_list|(
name|builtin_array
argument_list|)
decl_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
name|n
operator|-=
literal|2
expr_stmt|;
for|for
control|(
name|b
operator|=
name|builtin_array
init|;
name|b
operator|<
name|builtin_array
operator|+
name|n
condition|;
name|b
operator|++
control|)
block|{
name|cpp_hashnode
modifier|*
name|hp
init|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|b
operator|->
name|name
argument_list|,
name|b
operator|->
name|len
argument_list|)
decl_stmt|;
name|hp
operator|->
name|type
operator|=
name|NT_MACRO
expr_stmt|;
name|hp
operator|->
name|flags
operator||=
name|NODE_BUILTIN
operator||
name|NODE_WARN
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|builtin
operator|=
name|b
operator|->
name|value
expr_stmt|;
block|}
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__cplusplus 1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|==
name|CLK_ASM
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__ASSEMBLER__ 1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|==
name|CLK_STDC94
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__STDC_VERSION__ 199409L"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__STDC_VERSION__ 199901L"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|objc
argument_list|)
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__OBJC__ 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|register_builtins
condition|)
call|(
modifier|*
name|pfile
operator|->
name|cb
operator|.
name|register_builtins
call|)
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* And another subroutine.  This one sets up the standard include path.  */
end_comment

begin_function
specifier|static
name|void
name|init_standard_includes
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|struct
name|default_include
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|specd_prefix
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|include_prefix
argument_list|)
decl_stmt|;
comment|/* Several environment variables may add to the include search path.      CPATH specifies an additional list of directories to be searched      as if specified with -I, while C_INCLUDE_PATH, CPLUS_INCLUDE_PATH,      etc. specify an additional list of directories to be searched as      if specified with -isystem, for the language indicated.  */
name|GET_ENVIRONMENT
argument_list|(
name|path
argument_list|,
literal|"CPATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|!=
literal|0
operator|&&
operator|*
name|path
operator|!=
literal|0
condition|)
name|path_include
argument_list|(
name|pfile
argument_list|,
name|path
argument_list|,
name|BRACKET
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|objc
argument_list|)
operator|<<
literal|1
operator|)
operator|+
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|GET_ENVIRONMENT
argument_list|(
name|path
argument_list|,
literal|"C_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|GET_ENVIRONMENT
argument_list|(
name|path
argument_list|,
literal|"CPLUS_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|GET_ENVIRONMENT
argument_list|(
name|path
argument_list|,
literal|"OBJC_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|GET_ENVIRONMENT
argument_list|(
name|path
argument_list|,
literal|"OBJCPLUS_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|path
operator|!=
literal|0
operator|&&
operator|*
name|path
operator|!=
literal|0
condition|)
name|path_include
argument_list|(
name|pfile
argument_list|,
name|path
argument_list|,
name|SYSTEM
argument_list|)
expr_stmt|;
comment|/* Search "translated" versions of GNU directories.      These have /usr/local/lib/gcc... replaced by specd_prefix.  */
if|if
condition|(
name|specd_prefix
operator|!=
literal|0
operator|&&
name|cpp_GCC_INCLUDE_DIR_len
condition|)
block|{
comment|/* Remove the `include' from /usr/local/lib/gcc.../include. 	 GCC_INCLUDE_DIR will always end in /include.  */
name|int
name|default_len
init|=
name|cpp_GCC_INCLUDE_DIR_len
decl_stmt|;
name|char
modifier|*
name|default_prefix
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|default_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|specd_len
init|=
name|strlen
argument_list|(
name|specd_prefix
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|default_prefix
argument_list|,
name|cpp_GCC_INCLUDE_DIR
argument_list|,
name|default_len
argument_list|)
expr_stmt|;
name|default_prefix
index|[
name|default_len
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cpp_include_defaults
init|;
name|p
operator|->
name|fname
condition|;
name|p
operator|++
control|)
block|{
comment|/* Some standard dirs are only for C++.  */
if|if
condition|(
operator|!
name|p
operator|->
name|cplusplus
operator|||
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|no_standard_cplusplus_includes
argument_list|)
operator|)
condition|)
block|{
comment|/* Does this dir start with the prefix?  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
operator|->
name|fname
argument_list|,
name|default_prefix
argument_list|,
name|default_len
argument_list|)
condition|)
block|{
comment|/* Yes; change prefix and add to search list.  */
name|int
name|flen
init|=
name|strlen
argument_list|(
name|p
operator|->
name|fname
argument_list|)
decl_stmt|;
name|int
name|this_len
init|=
name|specd_len
operator|+
name|flen
operator|-
name|default_len
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|this_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|specd_prefix
argument_list|,
name|specd_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|str
operator|+
name|specd_len
argument_list|,
name|p
operator|->
name|fname
operator|+
name|default_len
argument_list|,
name|flen
operator|-
name|default_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|str
argument_list|,
name|SYSTEM
argument_list|,
name|p
operator|->
name|cxx_aware
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Search ordinary names for GNU include directories.  */
for|for
control|(
name|p
operator|=
name|cpp_include_defaults
init|;
name|p
operator|->
name|fname
condition|;
name|p
operator|++
control|)
block|{
comment|/* Some standard dirs are only for C++.  */
if|if
condition|(
operator|!
name|p
operator|->
name|cplusplus
operator|||
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|no_standard_cplusplus_includes
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|str
init|=
name|update_path
argument_list|(
name|p
operator|->
name|fname
argument_list|,
name|p
operator|->
name|component
argument_list|)
decl_stmt|;
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|str
argument_list|,
name|SYSTEM
argument_list|,
name|p
operator|->
name|cxx_aware
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Pushes a command line -imacro and -include file indicated by P onto    the buffer stack.  Returns nonzero if successful.  */
end_comment

begin_function
specifier|static
name|bool
name|push_include
parameter_list|(
name|pfile
parameter_list|,
name|p
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|pending_option
modifier|*
name|p
decl_stmt|;
block|{
name|cpp_token
name|header
decl_stmt|;
comment|/* Later: maybe update this to use the #include "" search path      if cpp_read_file fails.  */
name|header
operator|.
name|type
operator|=
name|CPP_STRING
expr_stmt|;
name|header
operator|.
name|val
operator|.
name|str
operator|.
name|text
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
operator|->
name|arg
expr_stmt|;
name|header
operator|.
name|val
operator|.
name|str
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|p
operator|->
name|arg
argument_list|)
expr_stmt|;
comment|/* Make the command line directive take up a line.  */
name|pfile
operator|->
name|line
operator|++
expr_stmt|;
return|return
name|_cpp_execute_include
argument_list|(
name|pfile
argument_list|,
operator|&
name|header
argument_list|,
name|IT_CMDLINE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Frees a pending_option chain.  */
end_comment

begin_function
specifier|static
name|void
name|free_chain
parameter_list|(
name|head
parameter_list|)
name|struct
name|pending_option
modifier|*
name|head
decl_stmt|;
block|{
name|struct
name|pending_option
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|head
condition|)
block|{
name|next
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sanity-checks are dependent on command-line options, so it is    called as a subroutine of cpp_read_main_file ().  */
end_comment

begin_if
if|#
directive|if
name|ENABLE_CHECKING
end_if

begin_decl_stmt
specifier|static
name|void
name|sanity_checks
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sanity_checks
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cppchar_t
name|test
init|=
literal|0
decl_stmt|;
name|size_t
name|max_precision
init|=
literal|2
operator|*
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|cpp_num_part
argument_list|)
decl_stmt|;
comment|/* Sanity checks for assumptions about CPP arithmetic and target      type precisions made by cpplib.  */
name|test
operator|--
expr_stmt|;
if|if
condition|(
name|test
operator|<
literal|1
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ICE
argument_list|,
literal|"cppchar_t must be an unsigned type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
operator|>
name|max_precision
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ICE
argument_list|,
literal|"preprocessor arithmetic has maximum precision of %lu bits; target requires %lu bits"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|max_precision
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
operator|<
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|int_precision
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ICE
argument_list|,
literal|"CPP arithmetic must be at least as precise as a target int"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|char_precision
argument_list|)
operator|<
literal|8
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ICE
argument_list|,
literal|"target char is less than 8 bits wide"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wchar_precision
argument_list|)
operator|<
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|char_precision
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ICE
argument_list|,
literal|"target wchar_t is narrower than target char"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|int_precision
argument_list|)
operator|<
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|char_precision
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ICE
argument_list|,
literal|"target int is narrower than target char"
argument_list|)
expr_stmt|;
comment|/* This is assumed in eval_token() and could be fixed if necessary.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|cppchar_t
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|cpp_num_part
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ICE
argument_list|,
literal|"CPP half-integer narrower than CPP character"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wchar_precision
argument_list|)
operator|>
name|BITS_PER_CPPCHAR_T
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ICE
argument_list|,
literal|"CPP on this host cannot handle wide character constants over %lu bits, but the target requires %lu bits"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|BITS_PER_CPPCHAR_T
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wchar_precision
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|sanity_checks
parameter_list|(
name|PFILE
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Add a dependency target.  Can be called any number of times before    cpp_read_main_file().  If no targets have been added before    cpp_read_main_file(), then the default target is used.  */
end_comment

begin_function
name|void
name|cpp_add_dependency_target
parameter_list|(
name|pfile
parameter_list|,
name|target
parameter_list|,
name|quote
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|int
name|quote
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|pfile
operator|->
name|deps
condition|)
name|pfile
operator|->
name|deps
operator|=
name|deps_init
argument_list|()
expr_stmt|;
name|deps_add_target
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|target
argument_list|,
name|quote
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called after options have been parsed, and partially    processed.  Setup for processing input from the file named FNAME,    or stdin if it is the empty string.  Return the original filename    on success (e.g. foo.i->foo.c), or NULL on failure.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cpp_read_main_file
parameter_list|(
name|pfile
parameter_list|,
name|fname
parameter_list|,
name|table
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|hash_table
modifier|*
name|table
decl_stmt|;
block|{
name|sanity_checks
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|post_options
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* The front ends don't set up the hash table until they have      finished processing the command line options, so initializing the      hashtable is deferred until now.  */
name|_cpp_init_hashtable
argument_list|(
name|pfile
argument_list|,
name|table
argument_list|)
expr_stmt|;
comment|/* Set up the include search path now.  */
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|no_standard_includes
argument_list|)
condition|)
name|init_standard_includes
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|merge_include_chains
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* With -v, print the list of dirs to search.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|verbose
argument_list|)
condition|)
block|{
name|struct
name|search_path
modifier|*
name|l
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"#include \"...\" search starts here:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|quote_include
argument_list|)
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l
operator|==
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|bracket_include
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"#include<...> search starts here:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s\n"
argument_list|,
name|l
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"End of search list.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps
operator|.
name|style
argument_list|)
operator|!=
name|DEPS_NONE
condition|)
block|{
if|if
condition|(
operator|!
name|pfile
operator|->
name|deps
condition|)
name|pfile
operator|->
name|deps
operator|=
name|deps_init
argument_list|()
expr_stmt|;
comment|/* Set the default target (if there is none already).  */
name|deps_add_default_target
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
comment|/* Open the main input file.  */
if|if
condition|(
operator|!
name|_cpp_read_file
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Set this here so the client can change the option if it wishes,      and after stacking the main file so we don't trace the main      file.  */
name|pfile
operator|->
name|line_maps
operator|.
name|trace_includes
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_include_names
argument_list|)
expr_stmt|;
comment|/* For foo.i, read the original filename foo.c now, for the benefit      of the front ends.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
condition|)
name|read_original_filename
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|pfile
operator|->
name|map
operator|->
name|to_file
return|;
block|}
end_function

begin_comment
comment|/* For preprocessed files, if the first tokens are of the form # NUM.    handle the directive so we know the original file name.  This will    generate file_change callbacks, which the front ends must handle    appropriately given their state of initialization.  */
end_comment

begin_function
specifier|static
name|void
name|read_original_filename
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|,
modifier|*
name|token1
decl_stmt|;
comment|/* Lex ahead; if the first tokens are of the form # NUM, then      process the directive, otherwise back up.  */
name|token
operator|=
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_HASH
condition|)
block|{
name|token1
operator|=
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If it's a #line directive, handle it.  */
if|if
condition|(
name|token1
operator|->
name|type
operator|==
name|CPP_NUMBER
condition|)
block|{
name|_cpp_handle_directive
argument_list|(
name|pfile
argument_list|,
name|token
operator|->
name|flags
operator|&
name|PREV_WHITE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Backup as if nothing happened.  */
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle pending command line options: -D, -U, -A, -imacros and    -include.  This should be called after debugging has been properly    set up in the front ends.  */
end_comment

begin_function
name|void
name|cpp_finish_options
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
comment|/* Mark named operators before handling command line macros.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|operator_names
argument_list|)
condition|)
name|mark_named_operators
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Install builtins and process command line macros etc. in the order      they appeared, but only if not already preprocessed.  */
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
condition|)
block|{
name|struct
name|pending_option
modifier|*
name|p
decl_stmt|;
comment|/* Prevent -Wunused-macros with command-line redefinitions.  */
name|pfile
operator|->
name|first_unused_line
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|LC_RENAME
argument_list|,
name|_
argument_list|(
literal|"<built-in>"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_builtins
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|LC_RENAME
argument_list|,
name|_
argument_list|(
literal|"<command line>"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|->
name|directive_head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
call|(
modifier|*
name|p
operator|->
name|handler
call|)
argument_list|(
name|pfile
argument_list|,
name|p
operator|->
name|arg
argument_list|)
expr_stmt|;
comment|/* Scan -imacros files after -D, -U, but before -include. 	 pfile->next_include_file is NULL, so _cpp_pop_buffer does not 	 push -include files.  */
for|for
control|(
name|p
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|->
name|imacros_head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|push_include
argument_list|(
name|pfile
argument_list|,
name|p
argument_list|)
condition|)
name|cpp_scan_nooutput
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|next_include_file
operator|=
operator|&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|->
name|include_head
expr_stmt|;
name|_cpp_maybe_push_include_file
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|first_unused_line
operator|=
name|pfile
operator|->
name|line
expr_stmt|;
name|free_chain
argument_list|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|->
name|imacros_head
argument_list|)
expr_stmt|;
name|free_chain
argument_list|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|->
name|directive_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push the next buffer on the stack given by -include, if any.  */
end_comment

begin_function
name|void
name|_cpp_maybe_push_include_file
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
if|if
condition|(
name|pfile
operator|->
name|next_include_file
condition|)
block|{
name|struct
name|pending_option
modifier|*
name|head
init|=
operator|*
name|pfile
operator|->
name|next_include_file
decl_stmt|;
while|while
condition|(
name|head
operator|&&
operator|!
name|push_include
argument_list|(
name|pfile
argument_list|,
name|head
argument_list|)
condition|)
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|head
condition|)
name|pfile
operator|->
name|next_include_file
operator|=
operator|&
name|head
operator|->
name|next
expr_stmt|;
else|else
block|{
comment|/* All done; restore the line map from<command line>.  */
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|LC_RENAME
argument_list|,
name|pfile
operator|->
name|line_maps
operator|.
name|maps
index|[
literal|0
index|]
operator|.
name|to_file
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't come back here again.  */
name|pfile
operator|->
name|next_include_file
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This is called at the end of preprocessing.  It pops the last    buffer and writes dependency output, and returns the number of    errors.      Maybe it should also reset state, such that you could call    cpp_start_read with a new filename to restart processing.  */
end_comment

begin_function
name|int
name|cpp_finish
parameter_list|(
name|pfile
parameter_list|,
name|deps_stream
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|FILE
modifier|*
name|deps_stream
decl_stmt|;
block|{
comment|/* Warn about unused macros before popping the final buffer.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_unused_macros
argument_list|)
condition|)
name|cpp_forall_identifiers
argument_list|(
name|pfile
argument_list|,
name|_cpp_warn_if_unused_macro
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* cpplex.c leaves the final buffer on the stack.  This it so that      it returns an unending stream of CPP_EOFs to the client.  If we      popped the buffer, we'd dereference a NULL buffer pointer and      segfault.  It's nice to allow the client to do worry-free excess      cpp_get_token calls.  */
while|while
condition|(
name|pfile
operator|->
name|buffer
condition|)
name|_cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Don't write the deps file if there are errors.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps
operator|.
name|style
argument_list|)
operator|!=
name|DEPS_NONE
operator|&&
name|deps_stream
operator|&&
name|pfile
operator|->
name|errors
operator|==
literal|0
condition|)
block|{
name|deps_write
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|deps_stream
argument_list|,
literal|72
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps
operator|.
name|phony_targets
argument_list|)
condition|)
name|deps_phony_targets
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|deps_stream
argument_list|)
expr_stmt|;
block|}
comment|/* Report on headers that could use multiple include guards.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_include_names
argument_list|)
condition|)
name|_cpp_report_missing_guards
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|pfile
operator|->
name|errors
return|;
block|}
end_function

begin_comment
comment|/* Add a directive to be handled later in the initialization phase.  */
end_comment

begin_function
specifier|static
name|void
name|new_pending_directive
parameter_list|(
name|pend
parameter_list|,
name|text
parameter_list|,
name|handler
parameter_list|)
name|struct
name|cpp_pending
modifier|*
name|pend
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|cl_directive_handler
name|handler
decl_stmt|;
block|{
name|struct
name|pending_option
modifier|*
name|o
init|=
operator|(
expr|struct
name|pending_option
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_option
argument_list|)
argument_list|)
decl_stmt|;
name|o
operator|->
name|arg
operator|=
name|text
expr_stmt|;
name|o
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|o
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
name|APPEND
argument_list|(
name|pend
argument_list|,
name|directive
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Irix6 "cc -n32" and OSF4 cc have problems with char foo[] = ("string");    I.e. a const string initializer with parens around it.  That is    what N_("string") resolves to, so we make no_* be macros instead.  */
end_comment

begin_define
define|#
directive|define
name|no_ass
value|N_("assertion missing after %s")
end_define

begin_define
define|#
directive|define
name|no_dir
value|N_("directory name missing after %s")
end_define

begin_define
define|#
directive|define
name|no_fil
value|N_("file name missing after %s")
end_define

begin_define
define|#
directive|define
name|no_mac
value|N_("macro name missing after %s")
end_define

begin_define
define|#
directive|define
name|no_pth
value|N_("path name missing after %s")
end_define

begin_comment
comment|/* This is the list of all command line options, with the leading    "-" removed.  It must be sorted in ASCII collating order.  */
end_comment

begin_define
define|#
directive|define
name|COMMAND_LINE_OPTIONS
define|\
value|DEF_OPT("A",                        no_ass, OPT_A)                          \   DEF_OPT("D",                        no_mac, OPT_D)                          \   DEF_OPT("I",                        no_dir, OPT_I)                          \   DEF_OPT("U",                        no_mac, OPT_U)                          \   DEF_OPT("idirafter",                no_dir, OPT_idirafter)                  \   DEF_OPT("imacros",                  no_fil, OPT_imacros)                    \   DEF_OPT("include",                  no_fil, OPT_include)                    \   DEF_OPT("iprefix",                  no_pth, OPT_iprefix)                    \   DEF_OPT("isystem",                  no_dir, OPT_isystem)                    \   DEF_OPT("iwithprefix",              no_dir, OPT_iwithprefix)                \   DEF_OPT("iwithprefixbefore",        no_dir, OPT_iwithprefixbefore)
end_define

begin_define
define|#
directive|define
name|DEF_OPT
parameter_list|(
name|text
parameter_list|,
name|msg
parameter_list|,
name|code
parameter_list|)
value|code,
end_define

begin_enum
enum|enum
name|opt_code
block|{
name|COMMAND_LINE_OPTIONS
name|N_OPTS
block|}
enum|;
end_enum

begin_undef
undef|#
directive|undef
name|DEF_OPT
end_undef

begin_struct
struct|struct
name|cl_option
block|{
specifier|const
name|char
modifier|*
name|opt_text
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|size_t
name|opt_len
decl_stmt|;
name|enum
name|opt_code
name|opt_code
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DEF_OPT
parameter_list|(
name|text
parameter_list|,
name|msg
parameter_list|,
name|code
parameter_list|)
value|{ text, msg, sizeof(text) - 1, code },
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HOST_EBCDIC
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|cl_option
name|cl_options
index|[]
init|=
else|#
directive|else
specifier|static
specifier|const
expr|struct
name|cl_option
name|cl_options
index|[]
operator|=
endif|#
directive|endif
block|{
name|COMMAND_LINE_OPTIONS
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_OPT
end_undef

begin_undef
undef|#
directive|undef
name|COMMAND_LINE_OPTIONS
end_undef

begin_comment
comment|/* Perform a binary search to find which, if any, option the given    command-line matches.  Returns its index in the option array,    negative on failure.  Complications arise since some options can be    suffixed with an argument, and multiple complete matches can occur,    e.g. -pedantic and -pedantic-errors.  */
end_comment

begin_function
specifier|static
name|int
name|parse_option
parameter_list|(
name|input
parameter_list|)
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
block|{
name|unsigned
name|int
name|md
decl_stmt|,
name|mn
decl_stmt|,
name|mx
decl_stmt|;
name|size_t
name|opt_len
decl_stmt|;
name|int
name|comp
decl_stmt|;
name|mn
operator|=
literal|0
expr_stmt|;
name|mx
operator|=
name|N_OPTS
expr_stmt|;
while|while
condition|(
name|mx
operator|>
name|mn
condition|)
block|{
name|md
operator|=
operator|(
name|mn
operator|+
name|mx
operator|)
operator|/
literal|2
expr_stmt|;
name|opt_len
operator|=
name|cl_options
index|[
name|md
index|]
operator|.
name|opt_len
expr_stmt|;
name|comp
operator|=
name|strncmp
argument_list|(
name|input
argument_list|,
name|cl_options
index|[
name|md
index|]
operator|.
name|opt_text
argument_list|,
name|opt_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|>
literal|0
condition|)
name|mn
operator|=
name|md
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
operator|<
literal|0
condition|)
name|mx
operator|=
name|md
expr_stmt|;
else|else
block|{
if|if
condition|(
name|input
index|[
name|opt_len
index|]
operator|==
literal|'\0'
condition|)
return|return
name|md
return|;
comment|/* We were passed more text.  If the option takes an argument, 	     we may match a later option or we may have been passed the 	     argument.  The longest possible option match succeeds. 	     If the option takes no arguments we have not matched and 	     continue the search (e.g. input="stdc++" match was "stdc").  */
name|mn
operator|=
name|md
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cl_options
index|[
name|md
index|]
operator|.
name|msg
condition|)
block|{
comment|/* Scan forwards.  If we get an exact match, return it. 		 Otherwise, return the longest option-accepting match. 		 This loops no more than twice with current options.  */
name|mx
operator|=
name|md
expr_stmt|;
for|for
control|(
init|;
name|mn
operator|<
operator|(
name|unsigned
name|int
operator|)
name|N_OPTS
condition|;
name|mn
operator|++
control|)
block|{
name|opt_len
operator|=
name|cl_options
index|[
name|mn
index|]
operator|.
name|opt_len
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|input
argument_list|,
name|cl_options
index|[
name|mn
index|]
operator|.
name|opt_text
argument_list|,
name|opt_len
argument_list|)
condition|)
break|break;
if|if
condition|(
name|input
index|[
name|opt_len
index|]
operator|==
literal|'\0'
condition|)
return|return
name|mn
return|;
if|if
condition|(
name|cl_options
index|[
name|mn
index|]
operator|.
name|msg
condition|)
name|mx
operator|=
name|mn
expr_stmt|;
block|}
return|return
name|mx
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Handle one command-line option in (argc, argv).    Can be called multiple times, to handle multiple sets of options.    Returns number of strings consumed.  */
end_comment

begin_function
name|int
name|cpp_handle_option
parameter_list|(
name|pfile
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|cpp_pending
modifier|*
name|pend
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
decl_stmt|;
block|{
name|enum
name|opt_code
name|opt_code
decl_stmt|;
name|int
name|opt_index
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
init|=
literal|0
decl_stmt|;
comment|/* Skip over '-'.  */
name|opt_index
operator|=
name|parse_option
argument_list|(
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_index
operator|<
literal|0
condition|)
return|return
name|i
return|;
name|opt_code
operator|=
name|cl_options
index|[
name|opt_index
index|]
operator|.
name|opt_code
expr_stmt|;
if|if
condition|(
name|cl_options
index|[
name|opt_index
index|]
operator|.
name|msg
condition|)
block|{
name|arg
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
name|cl_options
index|[
name|opt_index
index|]
operator|.
name|opt_len
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|arg
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ERROR
argument_list|,
name|cl_options
index|[
name|opt_index
index|]
operator|.
name|msg
argument_list|,
name|argv
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
block|}
block|}
switch|switch
condition|(
name|opt_code
condition|)
block|{
case|case
name|N_OPTS
case|:
comment|/* Shut GCC up.  */
break|break;
case|case
name|OPT_D
case|:
name|new_pending_directive
argument_list|(
name|pend
argument_list|,
name|arg
argument_list|,
name|cpp_define
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_iprefix
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|include_prefix
argument_list|)
operator|=
name|arg
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|include_prefix_len
argument_list|)
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_A
case|:
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|new_pending_directive
argument_list|(
name|pend
argument_list|,
name|arg
operator|+
literal|1
argument_list|,
name|cpp_unassert
argument_list|)
expr_stmt|;
else|else
name|new_pending_directive
argument_list|(
name|pend
argument_list|,
name|arg
argument_list|,
name|cpp_assert
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_U
case|:
name|new_pending_directive
argument_list|(
name|pend
argument_list|,
name|arg
argument_list|,
name|cpp_undef
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_I
case|:
comment|/* Add directory to path for includes.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
comment|/* -I- means: 		 Use the preceding -I directories for #include "..." 		 but not #include<...>. 		 Don't search the directory of the present file 		 for #include "...".  (Note that -I. -I- is not the same as 		 the default setup; -I. uses the compiler's working dir.)  */
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|ignore_srcdir
argument_list|)
condition|)
block|{
name|pend
operator|->
name|quote_head
operator|=
name|pend
operator|->
name|brack_head
expr_stmt|;
name|pend
operator|->
name|quote_tail
operator|=
name|pend
operator|->
name|brack_tail
expr_stmt|;
name|pend
operator|->
name|brack_head
operator|=
literal|0
expr_stmt|;
name|pend
operator|->
name|brack_tail
operator|=
literal|0
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|ignore_srcdir
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ERROR
argument_list|,
literal|"-I- specified twice"
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
block|}
else|else
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|xstrdup
argument_list|(
name|arg
argument_list|)
argument_list|,
name|BRACKET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_isystem
case|:
comment|/* Add directory to beginning of system include path, as a system 	     include directory.  */
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|xstrdup
argument_list|(
name|arg
argument_list|)
argument_list|,
name|SYSTEM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_include
case|:
case|case
name|OPT_imacros
case|:
block|{
name|struct
name|pending_option
modifier|*
name|o
init|=
operator|(
expr|struct
name|pending_option
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_option
argument_list|)
argument_list|)
decl_stmt|;
name|o
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|o
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|opt_code
operator|==
name|OPT_include
condition|)
name|APPEND
argument_list|(
name|pend
argument_list|,
name|include
argument_list|,
name|o
argument_list|)
expr_stmt|;
else|else
name|APPEND
argument_list|(
name|pend
argument_list|,
name|imacros
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPT_iwithprefix
case|:
comment|/* Add directory to end of path for includes, 	     with the default prefix at the front of its name.  */
comment|/* fall through */
case|case
name|OPT_iwithprefixbefore
case|:
comment|/* Add directory to main path for includes, 	     with the default prefix at the front of its name.  */
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|include_prefix
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|size_t
name|ipl
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|include_prefix_len
argument_list|)
decl_stmt|;
name|fname
operator|=
name|xmalloc
argument_list|(
name|ipl
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
argument_list|,
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|include_prefix
argument_list|)
argument_list|,
name|ipl
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
operator|+
name|ipl
argument_list|,
name|arg
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cpp_GCC_INCLUDE_DIR_len
condition|)
block|{
name|fname
operator|=
name|xmalloc
argument_list|(
name|cpp_GCC_INCLUDE_DIR_len
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
argument_list|,
name|cpp_GCC_INCLUDE_DIR
argument_list|,
name|cpp_GCC_INCLUDE_DIR_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
operator|+
name|cpp_GCC_INCLUDE_DIR_len
argument_list|,
name|arg
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|fname
operator|=
name|xstrdup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|opt_code
operator|==
name|OPT_iwithprefix
condition|?
name|SYSTEM
else|:
name|BRACKET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPT_idirafter
case|:
comment|/* Add directory to end of path for includes.  */
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|xstrdup
argument_list|(
name|arg
argument_list|)
argument_list|,
name|AFTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|i
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Handle command-line options in (argc, argv).    Can be called multiple times, to handle multiple sets of options.    Returns if an unrecognized option is seen.    Returns number of strings consumed.  */
end_comment

begin_function
name|int
name|cpp_handle_options
parameter_list|(
name|pfile
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|strings_processed
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|+=
name|strings_processed
control|)
block|{
name|strings_processed
operator|=
name|cpp_handle_option
argument_list|(
name|pfile
argument_list|,
name|argc
operator|-
name|i
argument_list|,
name|argv
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings_processed
operator|==
literal|0
condition|)
break|break;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_options
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
comment|/* -Wtraditional is not useful in C++ mode.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_traditional
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Permanently disable macro expansion if we are rescanning      preprocessed text.  Read preprocesed source in ISO mode.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
condition|)
block|{
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Traditional CPP does not accurately track column information.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|show_column
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

