begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPP Library.    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Per Bothner, 1994-95.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_include
include|#
directive|include
file|"prefix.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_include
include|#
directive|include
file|"mkdeps.h"
end_include

begin_include
include|#
directive|include
file|"cppdefault.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_comment
comment|/* for USING_SJLJ_EXCEPTIONS */
end_comment

begin_comment
comment|/* Predefined symbols, built-in macros, and the default include path.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GET_ENV_PATH_LIST
end_ifndef

begin_define
define|#
directive|define
name|GET_ENV_PATH_LIST
parameter_list|(
name|VAR
parameter_list|,
name|NAME
parameter_list|)
value|do { (VAR) = getenv (NAME); } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Windows does not natively support inodes, and neither does MSDOS.    Cygwin's emulation can generate non-unique inodes, so don't use it.    VMS has non-numeric inodes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|INO_T_EQ
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|(!memcmp (&(A),&(B), sizeof (A)))
end_define

begin_define
define|#
directive|define
name|INO_T_COPY
parameter_list|(
name|DEST
parameter_list|,
name|SRC
parameter_list|)
value|memcpy(&(DEST),&(SRC), sizeof (SRC))
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|(
name|defined
name|_WIN32
operator|&&
operator|!
name|defined
argument_list|(
name|_UWIN
argument_list|)
operator|)
operator|||
name|defined
name|__MSDOS__
end_if

begin_define
define|#
directive|define
name|INO_T_EQ
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INO_T_EQ
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A) == (B))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INO_T_COPY
parameter_list|(
name|DEST
parameter_list|,
name|SRC
parameter_list|)
value|(DEST) = (SRC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Internal structures and prototypes.  */
end_comment

begin_comment
comment|/* A `struct pending_option' remembers one -D, -A, -U, -include, or    -imacros switch.  */
end_comment

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|* cl_directive_handler
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_struct
struct|struct
name|pending_option
block|{
name|struct
name|pending_option
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|cl_directive_handler
name|handler
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The `pending' structure accumulates all the options that are not    actually processed until we hit cpp_read_main_file.  It consists of    several lists, one for each type of option.  We keep both head and    tail pointers for quick insertion.  */
end_comment

begin_struct
struct|struct
name|cpp_pending
block|{
name|struct
name|pending_option
modifier|*
name|directive_head
decl_stmt|,
modifier|*
name|directive_tail
decl_stmt|;
name|struct
name|search_path
modifier|*
name|quote_head
decl_stmt|,
modifier|*
name|quote_tail
decl_stmt|;
name|struct
name|search_path
modifier|*
name|brack_head
decl_stmt|,
modifier|*
name|brack_tail
decl_stmt|;
name|struct
name|search_path
modifier|*
name|systm_head
decl_stmt|,
modifier|*
name|systm_tail
decl_stmt|;
name|struct
name|search_path
modifier|*
name|after_head
decl_stmt|,
modifier|*
name|after_tail
decl_stmt|;
name|struct
name|pending_option
modifier|*
name|imacros_head
decl_stmt|,
modifier|*
name|imacros_tail
decl_stmt|;
name|struct
name|pending_option
modifier|*
name|include_head
decl_stmt|,
modifier|*
name|include_tail
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|APPEND
parameter_list|(
name|pend
parameter_list|,
name|list
parameter_list|,
name|elt
parameter_list|)
define|\
value|do {  if (!(pend)->list##_head) (pend)->list##_head = (elt); \ 	else (pend)->list##_tail->next = (elt); \ 	(pend)->list##_tail = (elt); \   } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|APPEND
parameter_list|(
name|pend
parameter_list|,
name|list
parameter_list|,
name|elt
parameter_list|)
define|\
value|do {  if (!(pend)->list
comment|/**/
value|_head) (pend)->list
comment|/**/
value|_head = (elt); \ 	else (pend)->list
comment|/**/
value|_tail->next = (elt); \ 	(pend)->list
comment|/**/
value|_tail = (elt); \   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|print_help
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|path_include
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_library
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_builtins
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_include_chain
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|search_path
modifier|*
name|remove_dup_dir
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|search_path
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|search_path
modifier|*
name|remove_dup_dirs
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|search_path
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_include_chains
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|push_include
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|pending_option
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_chain
name|PARAMS
argument_list|(
operator|(
expr|struct
name|pending_option
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_lang
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|enum
name|c_lang
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_dependency_output
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_standard_includes
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_original_filename
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_pending_directive
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cpp_pending
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|cl_directive_handler
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_deps
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_option
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fourth argument to append_include_chain: chain to use.    Note it's never asked to append to the quote chain.  */
end_comment

begin_enum
enum|enum
block|{
name|BRACKET
init|=
literal|0
block|,
name|SYSTEM
block|,
name|AFTER
block|}
enum|;
end_enum

begin_comment
comment|/* If we have designated initializers (GCC>2.7) these tables can be    initialized, constant data.  Otherwise, they have to be filled in at    runtime.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_DESIGNATED_INITIALIZERS
end_if

begin_define
define|#
directive|define
name|init_trigraph_map
parameter_list|()
end_define

begin_comment
comment|/* Nothing.  */
end_comment

begin_define
define|#
directive|define
name|TRIGRAPH_MAP
define|\
value|__extension__ const U_CHAR _cpp_trigraph_map[UCHAR_MAX + 1] = {
end_define

begin_define
define|#
directive|define
name|END
value|};
end_define

begin_define
define|#
directive|define
name|s
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|[p] = v,
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TRIGRAPH_MAP
value|U_CHAR _cpp_trigraph_map[UCHAR_MAX + 1] = { 0 }; \  static void init_trigraph_map PARAMS ((void)) { \  unsigned char *x = _cpp_trigraph_map;
end_define

begin_define
define|#
directive|define
name|END
value|}
end_define

begin_define
define|#
directive|define
name|s
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|x[p] = v;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|TRIGRAPH_MAP
name|s
argument_list|(
literal|'='
argument_list|,
literal|'#'
argument_list|)
name|s
argument_list|(
literal|')'
argument_list|,
literal|']'
argument_list|)
name|s
argument_list|(
literal|'!'
argument_list|,
literal|'|'
argument_list|)
name|s
argument_list|(
literal|'('
argument_list|,
literal|'['
argument_list|)
name|s
argument_list|(
literal|'\''
argument_list|,
literal|'^'
argument_list|)
name|s
argument_list|(
literal|'>'
argument_list|,
literal|'}'
argument_list|)
name|s
argument_list|(
literal|'/'
argument_list|,
literal|'\\'
argument_list|)
name|s
argument_list|(
literal|'<'
argument_list|,
literal|'{'
argument_list|)
name|s
argument_list|(
literal|'-'
argument_list|,
literal|'~'
argument_list|)
name|END
undef|#
directive|undef
name|s
undef|#
directive|undef
name|END
undef|#
directive|undef
name|TRIGRAPH_MAP
comment|/* Given a colon-separated list of file names PATH,    add all the names to the search path for include files.  */
decl|static
name|void
name|path_include
argument_list|(
name|pfile
argument_list|,
name|list
argument_list|,
name|path
argument_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|path
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|p
operator|=
name|list
expr_stmt|;
do|do
block|{
comment|/* Find the end of this name.  */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|0
operator|&&
operator|*
name|q
operator|!=
name|PATH_SEPARATOR
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|p
condition|)
block|{
comment|/* An empty name in the path stands for the current directory.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise use the directory that is named.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|q
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|name
index|[
name|q
operator|-
name|p
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|name
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Advance past this name.  */
if|if
condition|(
operator|*
name|q
operator|==
literal|0
condition|)
break|break;
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
end_block

begin_comment
comment|/* Append DIR to include path PATH.  DIR must be allocated on the    heap; this routine takes responsibility for freeing it.  CXX_AWARE    is non-zero if the header contains extern "C" guards for C++,    otherwise it is zero.  */
end_comment

begin_function
specifier|static
name|void
name|append_include_chain
parameter_list|(
name|pfile
parameter_list|,
name|dir
parameter_list|,
name|path
parameter_list|,
name|cxx_aware
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|path
decl_stmt|;
name|int
name|cxx_aware
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|cpp_pending
modifier|*
name|pend
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
decl_stmt|;
name|struct
name|search_path
modifier|*
name|new
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|dir
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|dir
operator|=
name|xstrdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|_cpp_simplify_pathname
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dir
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
comment|/* Dirs that don't exist are silently ignored.  */
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|cpp_notice_from_errno
argument_list|(
name|pfile
argument_list|,
name|dir
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|verbose
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"ignoring nonexistent directory \"%s\"\n"
argument_list|)
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|cpp_notice
argument_list|(
name|pfile
argument_list|,
literal|"%s: Not a directory"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|pfile
operator|->
name|max_include_len
condition|)
name|pfile
operator|->
name|max_include_len
operator|=
name|len
expr_stmt|;
name|new
operator|=
operator|(
expr|struct
name|search_path
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|search_path
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|dir
expr_stmt|;
name|new
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|INO_T_COPY
argument_list|(
name|new
operator|->
name|ino
argument_list|,
name|st
operator|.
name|st_ino
argument_list|)
expr_stmt|;
name|new
operator|->
name|dev
operator|=
name|st
operator|.
name|st_dev
expr_stmt|;
comment|/* Both systm and after include file lists should be treated as system      include files since these two lists are really just a concatenation      of one "system" list.  */
if|if
condition|(
name|path
operator|==
name|SYSTEM
operator|||
name|path
operator|==
name|AFTER
condition|)
ifdef|#
directive|ifdef
name|NO_IMPLICIT_EXTERN_C
name|new
operator|->
name|sysp
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|new
operator|->
name|sysp
operator|=
name|cxx_aware
condition|?
literal|1
else|:
literal|2
expr_stmt|;
endif|#
directive|endif
else|else
name|new
operator|->
name|sysp
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|name_map
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|path
condition|)
block|{
case|case
name|BRACKET
case|:
name|APPEND
argument_list|(
name|pend
argument_list|,
name|brack
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYSTEM
case|:
name|APPEND
argument_list|(
name|pend
argument_list|,
name|systm
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
case|case
name|AFTER
case|:
name|APPEND
argument_list|(
name|pend
argument_list|,
name|after
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Handle a duplicated include path.  PREV is the link in the chain    before the duplicate.  The duplicate is removed from the chain and    freed.  Returns PREV.  */
end_comment

begin_function
specifier|static
name|struct
name|search_path
modifier|*
name|remove_dup_dir
parameter_list|(
name|pfile
parameter_list|,
name|prev
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|search_path
modifier|*
name|prev
decl_stmt|;
block|{
name|struct
name|search_path
modifier|*
name|cur
init|=
name|prev
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|verbose
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"ignoring duplicate directory \"%s\"\n"
argument_list|)
argument_list|,
name|cur
operator|->
name|name
argument_list|)
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|cur
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cur
argument_list|)
expr_stmt|;
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Remove duplicate directories from a chain.  Returns the tail of the    chain, or NULL if the chain is empty.  This algorithm is quadratic    in the number of -I switches, which is acceptable since there    aren't usually that many of them.  */
end_comment

begin_function
specifier|static
name|struct
name|search_path
modifier|*
name|remove_dup_dirs
parameter_list|(
name|pfile
parameter_list|,
name|head
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|search_path
modifier|*
name|head
decl_stmt|;
block|{
name|struct
name|search_path
modifier|*
name|prev
init|=
name|NULL
decl_stmt|,
modifier|*
name|cur
decl_stmt|,
modifier|*
name|other
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|head
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
for|for
control|(
name|other
operator|=
name|head
init|;
name|other
operator|!=
name|cur
condition|;
name|other
operator|=
name|other
operator|->
name|next
control|)
if|if
condition|(
name|INO_T_EQ
argument_list|(
name|cur
operator|->
name|ino
argument_list|,
name|other
operator|->
name|ino
argument_list|)
operator|&&
name|cur
operator|->
name|dev
operator|==
name|other
operator|->
name|dev
condition|)
block|{
if|if
condition|(
name|cur
operator|->
name|sysp
operator|&&
operator|!
name|other
operator|->
name|sysp
condition|)
block|{
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"changing search order for system directory \"%s\""
argument_list|,
name|cur
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cur
operator|->
name|name
argument_list|,
name|other
operator|->
name|name
argument_list|)
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"  as it is the same as non-system directory \"%s\""
argument_list|,
name|other
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"  as it has already been specified as a non-system directory"
argument_list|)
expr_stmt|;
block|}
name|cur
operator|=
name|remove_dup_dir
argument_list|(
name|pfile
argument_list|,
name|prev
argument_list|)
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|cur
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Merge the four include chains together in the order quote, bracket,    system, after.  Remove duplicate dirs (as determined by    INO_T_EQ()).  The system_include and after_include chains are never    referred to again after this function; all access is through the    bracket_include path.  */
end_comment

begin_function
specifier|static
name|void
name|merge_include_chains
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|struct
name|search_path
modifier|*
name|quote
decl_stmt|,
modifier|*
name|brack
decl_stmt|,
modifier|*
name|systm
decl_stmt|,
modifier|*
name|qtail
decl_stmt|;
name|struct
name|cpp_pending
modifier|*
name|pend
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
decl_stmt|;
name|quote
operator|=
name|pend
operator|->
name|quote_head
expr_stmt|;
name|brack
operator|=
name|pend
operator|->
name|brack_head
expr_stmt|;
name|systm
operator|=
name|pend
operator|->
name|systm_head
expr_stmt|;
name|qtail
operator|=
name|pend
operator|->
name|quote_tail
expr_stmt|;
comment|/* Paste together bracket, system, and after include chains.  */
if|if
condition|(
name|systm
condition|)
name|pend
operator|->
name|systm_tail
operator|->
name|next
operator|=
name|pend
operator|->
name|after_head
expr_stmt|;
else|else
name|systm
operator|=
name|pend
operator|->
name|after_head
expr_stmt|;
if|if
condition|(
name|brack
condition|)
name|pend
operator|->
name|brack_tail
operator|->
name|next
operator|=
name|systm
expr_stmt|;
else|else
name|brack
operator|=
name|systm
expr_stmt|;
comment|/* This is a bit tricky.  First we drop dupes from the quote-include      list.  Then we drop dupes from the bracket-include list.      Finally, if qtail and brack are the same directory, we cut out      brack and move brack up to point to qtail.       We can't just merge the lists and then uniquify them because      then we may lose directories from the<> search path that should      be there; consider -Ifoo -Ibar -I- -Ifoo -Iquux. It is however      safe to treat -Ibar -Ifoo -I- -Ifoo -Iquux as if written      -Ibar -I- -Ifoo -Iquux.  */
name|remove_dup_dirs
argument_list|(
name|pfile
argument_list|,
name|brack
argument_list|)
expr_stmt|;
name|qtail
operator|=
name|remove_dup_dirs
argument_list|(
name|pfile
argument_list|,
name|quote
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
condition|)
block|{
name|qtail
operator|->
name|next
operator|=
name|brack
expr_stmt|;
comment|/* If brack == qtail, remove brack as it's simpler.  */
if|if
condition|(
name|INO_T_EQ
argument_list|(
name|qtail
operator|->
name|ino
argument_list|,
name|brack
operator|->
name|ino
argument_list|)
operator|&&
name|qtail
operator|->
name|dev
operator|==
name|brack
operator|->
name|dev
condition|)
name|brack
operator|=
name|remove_dup_dir
argument_list|(
name|pfile
argument_list|,
name|qtail
argument_list|)
expr_stmt|;
block|}
else|else
name|quote
operator|=
name|brack
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|quote_include
argument_list|)
operator|=
name|quote
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|bracket_include
argument_list|)
operator|=
name|brack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A set of booleans indicating what CPP features each source language    requires.  */
end_comment

begin_struct
struct|struct
name|lang_flags
block|{
name|char
name|c99
decl_stmt|;
name|char
name|objc
decl_stmt|;
name|char
name|cplusplus
decl_stmt|;
name|char
name|extended_numbers
decl_stmt|;
name|char
name|trigraphs
decl_stmt|;
name|char
name|dollars_in_ident
decl_stmt|;
name|char
name|cplusplus_comments
decl_stmt|;
name|char
name|digraphs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ??? Enable $ in identifiers in assembly? */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|lang_flags
name|lang_defaults
index|[]
init|=
block|{
comment|/*              c99 objc c++ xnum trig dollar c++comm digr  */
comment|/* GNUC89 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* GNUC99 */
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* STDC89 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* STDC94 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* STDC99 */
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* GNUCXX */
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* CXX98  */
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* OBJC   */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* OBJCXX */
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* ASM    */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sets internal flags correctly for a given language.  */
end_comment

begin_function
specifier|static
name|void
name|set_lang
parameter_list|(
name|pfile
parameter_list|,
name|lang
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|enum
name|c_lang
name|lang
decl_stmt|;
block|{
specifier|const
name|struct
name|lang_flags
modifier|*
name|l
init|=
operator|&
name|lang_defaults
index|[
operator|(
name|int
operator|)
name|lang
index|]
decl_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|=
name|lang
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
operator|=
name|l
operator|->
name|c99
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|objc
argument_list|)
operator|=
name|l
operator|->
name|objc
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
operator|=
name|l
operator|->
name|cplusplus
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|extended_numbers
argument_list|)
operator|=
name|l
operator|->
name|extended_numbers
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|trigraphs
argument_list|)
operator|=
name|l
operator|->
name|trigraphs
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|dollars_in_ident
argument_list|)
operator|=
name|l
operator|->
name|dollars_in_ident
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus_comments
argument_list|)
operator|=
name|l
operator|->
name|cplusplus_comments
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|digraphs
argument_list|)
operator|=
name|l
operator|->
name|digraphs
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HOST_EBCDIC
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|opt_comp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Run-time sorting of options array.  */
end_comment

begin_function
specifier|static
name|int
name|opt_comp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|void
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|strcmp
argument_list|(
operator|(
operator|(
expr|struct
name|cl_option
operator|*
operator|)
name|p1
operator|)
operator|->
name|opt_text
argument_list|,
operator|(
operator|(
expr|struct
name|cl_option
operator|*
operator|)
name|p2
operator|)
operator|->
name|opt_text
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* init initializes library global state.  It might not need to    do anything depending on the platform and compiler.  */
end_comment

begin_function
specifier|static
name|void
name|init_library
parameter_list|()
block|{
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HOST_EBCDIC
comment|/* For non-ASCII hosts, the cl_options array needs to be sorted at 	 runtime.  */
name|qsort
argument_list|(
name|cl_options
argument_list|,
name|N_OPTS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cl_option
argument_list|)
argument_list|,
name|opt_comp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set up the trigraph map.  This doesn't need to do anything if 	 we were compiled with a compiler that supports C99 designated 	 initializers.  */
name|init_trigraph_map
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize a cpp_reader structure.  */
end_comment

begin_function
name|cpp_reader
modifier|*
name|cpp_create_reader
parameter_list|(
name|lang
parameter_list|)
name|enum
name|c_lang
name|lang
decl_stmt|;
block|{
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
comment|/* Initialise this instance of the library if it hasn't been already.  */
name|init_library
argument_list|()
expr_stmt|;
name|pfile
operator|=
operator|(
name|cpp_reader
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_reader
argument_list|)
argument_list|)
expr_stmt|;
name|set_lang
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_import
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|show_column
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|tabstop
argument_list|)
operator|=
literal|8
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|operator_names
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|=
operator|(
expr|struct
name|cpp_pending
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cpp_pending
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It's simplest to just create this struct whether or not it will      be needed.  */
name|pfile
operator|->
name|deps
operator|=
name|deps_init
argument_list|()
expr_stmt|;
comment|/* Initialise the line map.  Start at logical line 1, so we can use      a line number of zero for special states.  */
name|init_line_maps
argument_list|(
operator|&
name|pfile
operator|->
name|line_maps
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|line
operator|=
literal|1
expr_stmt|;
comment|/* Initialize lexer state.  */
name|pfile
operator|->
name|state
operator|.
name|save_comments
operator|=
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments
argument_list|)
expr_stmt|;
comment|/* Set up static tokens.  */
name|pfile
operator|->
name|date
operator|.
name|type
operator|=
name|CPP_EOF
expr_stmt|;
name|pfile
operator|->
name|avoid_paste
operator|.
name|type
operator|=
name|CPP_PADDING
expr_stmt|;
name|pfile
operator|->
name|avoid_paste
operator|.
name|val
operator|.
name|source
operator|=
name|NULL
expr_stmt|;
name|pfile
operator|->
name|eof
operator|.
name|type
operator|=
name|CPP_EOF
expr_stmt|;
name|pfile
operator|->
name|eof
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* Create a token buffer for the lexer.  */
name|_cpp_init_tokenrun
argument_list|(
operator|&
name|pfile
operator|->
name|base_run
argument_list|,
literal|250
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|cur_run
operator|=
operator|&
name|pfile
operator|->
name|base_run
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|pfile
operator|->
name|base_run
operator|.
name|base
expr_stmt|;
comment|/* Initialise the base context.  */
name|pfile
operator|->
name|context
operator|=
operator|&
name|pfile
operator|->
name|base_context
expr_stmt|;
name|pfile
operator|->
name|base_context
operator|.
name|macro
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|base_context
operator|.
name|prev
operator|=
name|pfile
operator|->
name|base_context
operator|.
name|next
operator|=
literal|0
expr_stmt|;
comment|/* Aligned and unaligned storage.  */
name|pfile
operator|->
name|a_buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|u_buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialise the buffer obstack.  */
name|gcc_obstack_init
argument_list|(
operator|&
name|pfile
operator|->
name|buffer_ob
argument_list|)
expr_stmt|;
name|_cpp_init_includes
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|pfile
return|;
block|}
end_function

begin_comment
comment|/* Free resources used by PFILE.  Accessing PFILE after this function    returns leads to undefined behaviour.  Returns the error count.  */
end_comment

begin_function
name|int
name|cpp_destroy
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|struct
name|search_path
modifier|*
name|dir
decl_stmt|,
modifier|*
name|dirn
decl_stmt|;
name|cpp_context
modifier|*
name|context
decl_stmt|,
modifier|*
name|contextn
decl_stmt|;
name|tokenrun
modifier|*
name|run
decl_stmt|,
modifier|*
name|runn
decl_stmt|;
while|while
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|!=
name|NULL
condition|)
name|_cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|macro_buffer
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|pfile
operator|->
name|macro_buffer
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|macro_buffer
operator|=
name|NULL
expr_stmt|;
name|pfile
operator|->
name|macro_buffer_len
operator|=
literal|0
expr_stmt|;
block|}
name|deps_free
argument_list|(
name|pfile
operator|->
name|deps
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|pfile
operator|->
name|buffer_ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_cpp_destroy_hashtable
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_cleanup_includes
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_free_buff
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
expr_stmt|;
name|_cpp_free_buff
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
name|_cpp_free_buff
argument_list|(
name|pfile
operator|->
name|free_buffs
argument_list|)
expr_stmt|;
for|for
control|(
name|run
operator|=
operator|&
name|pfile
operator|->
name|base_run
init|;
name|run
condition|;
name|run
operator|=
name|runn
control|)
block|{
name|runn
operator|=
name|run
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|run
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|!=
operator|&
name|pfile
operator|->
name|base_run
condition|)
name|free
argument_list|(
name|run
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|dir
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|quote_include
argument_list|)
init|;
name|dir
condition|;
name|dir
operator|=
name|dirn
control|)
block|{
name|dirn
operator|=
name|dir
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|dir
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|context
operator|=
name|pfile
operator|->
name|base_context
operator|.
name|next
init|;
name|context
condition|;
name|context
operator|=
name|contextn
control|)
block|{
name|contextn
operator|=
name|context
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|free_line_maps
argument_list|(
operator|&
name|pfile
operator|->
name|line_maps
argument_list|)
expr_stmt|;
name|result
operator|=
name|pfile
operator|->
name|errors
expr_stmt|;
name|free
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* This structure defines one built-in identifier.  A node will be    entered in the hash table under the name NAME, with value VALUE (if    any).  If flags has OPERATOR, the node's operator field is used; if    flags has BUILTIN the node's builtin field is used.  Macros that are    known at build time should not be flagged BUILTIN, as then they do    not appear in macro dumps with e.g. -dM or -dD.     Two values are not compile time constants, so we tag    them in the FLAGS field instead:    VERS		value is the global version_string, quoted    ULP		value is the global user_label_prefix     Also, macros with CPLUS set in the flags field are entered only for C++.  */
end_comment

begin_struct
struct|struct
name|builtin
block|{
specifier|const
name|U_CHAR
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|unsigned
name|char
name|builtin
decl_stmt|;
name|unsigned
name|char
name|operator
decl_stmt|;
name|unsigned
name|short
name|flags
decl_stmt|;
name|unsigned
name|short
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|VERS
value|0x01
end_define

begin_define
define|#
directive|define
name|ULP
value|0x02
end_define

begin_define
define|#
directive|define
name|CPLUS
value|0x04
end_define

begin_define
define|#
directive|define
name|BUILTIN
value|0x08
end_define

begin_define
define|#
directive|define
name|OPERATOR
value|0x10
end_define

begin_define
define|#
directive|define
name|B
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
value|{ U n, 0, t, 0, BUILTIN, sizeof n - 1 }
end_define

begin_define
define|#
directive|define
name|C
parameter_list|(
name|n
parameter_list|,
name|v
parameter_list|)
value|{ U n, v, 0, 0, 0, sizeof n - 1 }
end_define

begin_define
define|#
directive|define
name|X
parameter_list|(
name|n
parameter_list|,
name|f
parameter_list|)
value|{ U n, 0, 0, 0, f, sizeof n - 1 }
end_define

begin_define
define|#
directive|define
name|O
parameter_list|(
name|n
parameter_list|,
name|c
parameter_list|,
name|f
parameter_list|)
value|{ U n, 0, 0, c, OPERATOR | f, sizeof n - 1 }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin
name|builtin_array
index|[]
init|=
block|{
name|B
argument_list|(
literal|"__TIME__"
argument_list|,
name|BT_TIME
argument_list|)
block|,
name|B
argument_list|(
literal|"__DATE__"
argument_list|,
name|BT_DATE
argument_list|)
block|,
name|B
argument_list|(
literal|"__FILE__"
argument_list|,
name|BT_FILE
argument_list|)
block|,
name|B
argument_list|(
literal|"__BASE_FILE__"
argument_list|,
name|BT_BASE_FILE
argument_list|)
block|,
name|B
argument_list|(
literal|"__LINE__"
argument_list|,
name|BT_SPECLINE
argument_list|)
block|,
name|B
argument_list|(
literal|"__INCLUDE_LEVEL__"
argument_list|,
name|BT_INCLUDE_LEVEL
argument_list|)
block|,
name|B
argument_list|(
literal|"_Pragma"
argument_list|,
name|BT_PRAGMA
argument_list|)
block|,
name|X
argument_list|(
literal|"__VERSION__"
argument_list|,
name|VERS
argument_list|)
block|,
name|X
argument_list|(
literal|"__USER_LABEL_PREFIX__"
argument_list|,
name|ULP
argument_list|)
block|,
name|C
argument_list|(
literal|"__REGISTER_PREFIX__"
argument_list|,
name|REGISTER_PREFIX
argument_list|)
block|,
name|C
argument_list|(
literal|"__HAVE_BUILTIN_SETJMP__"
argument_list|,
literal|"1"
argument_list|)
block|,
if|#
directive|if
name|USING_SJLJ_EXCEPTIONS
comment|/* libgcc needs to know this.  */
name|C
argument_list|(
literal|"__USING_SJLJ_EXCEPTIONS__"
argument_list|,
literal|"1"
argument_list|)
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_SIZE_TYPE
name|C
argument_list|(
literal|"__SIZE_TYPE__"
argument_list|,
name|SIZE_TYPE
argument_list|)
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_PTRDIFF_TYPE
name|C
argument_list|(
literal|"__PTRDIFF_TYPE__"
argument_list|,
name|PTRDIFF_TYPE
argument_list|)
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_WCHAR_TYPE
name|C
argument_list|(
literal|"__WCHAR_TYPE__"
argument_list|,
name|WCHAR_TYPE
argument_list|)
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_WINT_TYPE
name|C
argument_list|(
literal|"__WINT_TYPE__"
argument_list|,
name|WINT_TYPE
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STDC_0_IN_SYSTEM_HEADERS
name|B
argument_list|(
literal|"__STDC__"
argument_list|,
name|BT_STDC
argument_list|)
block|,
else|#
directive|else
name|C
argument_list|(
literal|"__STDC__"
argument_list|,
literal|"1"
argument_list|)
block|,
endif|#
directive|endif
comment|/* Named operators known to the preprocessor.  These cannot be #defined      and always have their stated meaning.  They are treated like normal      identifiers except for the type code and the meaning.  Most of them      are only for C++ (but see iso646.h).  */
name|O
argument_list|(
literal|"and"
argument_list|,
name|CPP_AND_AND
argument_list|,
name|CPLUS
argument_list|)
block|,
name|O
argument_list|(
literal|"and_eq"
argument_list|,
name|CPP_AND_EQ
argument_list|,
name|CPLUS
argument_list|)
block|,
name|O
argument_list|(
literal|"bitand"
argument_list|,
name|CPP_AND
argument_list|,
name|CPLUS
argument_list|)
block|,
name|O
argument_list|(
literal|"bitor"
argument_list|,
name|CPP_OR
argument_list|,
name|CPLUS
argument_list|)
block|,
name|O
argument_list|(
literal|"compl"
argument_list|,
name|CPP_COMPL
argument_list|,
name|CPLUS
argument_list|)
block|,
name|O
argument_list|(
literal|"not"
argument_list|,
name|CPP_NOT
argument_list|,
name|CPLUS
argument_list|)
block|,
name|O
argument_list|(
literal|"not_eq"
argument_list|,
name|CPP_NOT_EQ
argument_list|,
name|CPLUS
argument_list|)
block|,
name|O
argument_list|(
literal|"or"
argument_list|,
name|CPP_OR_OR
argument_list|,
name|CPLUS
argument_list|)
block|,
name|O
argument_list|(
literal|"or_eq"
argument_list|,
name|CPP_OR_EQ
argument_list|,
name|CPLUS
argument_list|)
block|,
name|O
argument_list|(
literal|"xor"
argument_list|,
name|CPP_XOR
argument_list|,
name|CPLUS
argument_list|)
block|,
name|O
argument_list|(
literal|"xor_eq"
argument_list|,
argument|CPP_XOR_EQ
argument_list|,
argument|CPLUS
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|B
end_undef

begin_undef
undef|#
directive|undef
name|C
end_undef

begin_undef
undef|#
directive|undef
name|X
end_undef

begin_undef
undef|#
directive|undef
name|O
end_undef

begin_define
define|#
directive|define
name|builtin_array_end
define|\
value|builtin_array + sizeof(builtin_array)/sizeof(struct builtin)
end_define

begin_comment
comment|/* Subroutine of cpp_read_main_file; reads the builtins table above and    enters them, and language-specific macros, into the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|init_builtins
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|struct
name|builtin
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|builtin_array
init|;
name|b
operator|<
name|builtin_array_end
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|b
operator|->
name|flags
operator|&
name|CPLUS
operator|)
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|b
operator|->
name|flags
operator|&
name|OPERATOR
operator|)
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|operator_names
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|b
operator|->
name|flags
operator|&
operator|(
name|OPERATOR
operator||
name|BUILTIN
operator|)
condition|)
block|{
name|cpp_hashnode
modifier|*
name|hp
init|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|b
operator|->
name|name
argument_list|,
name|b
operator|->
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|flags
operator|&
name|OPERATOR
condition|)
block|{
name|hp
operator|->
name|flags
operator||=
name|NODE_OPERATOR
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|operator
operator|=
name|b
operator|->
name|operator
expr_stmt|;
block|}
else|else
block|{
name|hp
operator|->
name|type
operator|=
name|NT_MACRO
expr_stmt|;
name|hp
operator|->
name|flags
operator||=
name|NODE_BUILTIN
operator||
name|NODE_WARN
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|builtin
operator|=
name|b
operator|->
name|builtin
expr_stmt|;
block|}
block|}
else|else
comment|/* A standard macro of some kind.  */
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|flags
operator|&
name|VERS
condition|)
block|{
comment|/* Allocate enough space for 'name "value"\n\0'.  */
name|str
operator|=
name|alloca
argument_list|(
name|b
operator|->
name|len
operator|+
name|strlen
argument_list|(
name|version_string
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%s \"%s\"\n"
argument_list|,
name|b
operator|->
name|name
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|b
operator|->
name|flags
operator|&
name|ULP
condition|)
name|val
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|user_label_prefix
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|b
operator|->
name|value
expr_stmt|;
comment|/* Allocate enough space for "name value\n\0".  */
name|str
operator|=
name|alloca
argument_list|(
name|b
operator|->
name|len
operator|+
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%s %s\n"
argument_list|,
name|b
operator|->
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
block|{
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__cplusplus 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUPPORTS_ONE_ONLY
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__GXX_WEAK__ 1"
argument_list|)
expr_stmt|;
else|else
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__GXX_WEAK__ 0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|objc
argument_list|)
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__OBJC__ 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|==
name|CLK_STDC94
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__STDC_VERSION__ 199409L"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__STDC_VERSION__ 199901L"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|==
name|CLK_STDC89
operator|||
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|==
name|CLK_STDC94
operator|||
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|==
name|CLK_STDC99
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__STRICT_ANSI__ 1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|==
name|CLK_ASM
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__ASSEMBLER__ 1"
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|BUILTIN
end_undef

begin_undef
undef|#
directive|undef
name|OPERATOR
end_undef

begin_undef
undef|#
directive|undef
name|VERS
end_undef

begin_undef
undef|#
directive|undef
name|ULP
end_undef

begin_undef
undef|#
directive|undef
name|CPLUS
end_undef

begin_undef
undef|#
directive|undef
name|builtin_array_end
end_undef

begin_comment
comment|/* And another subroutine.  This one sets up the standard include path.  */
end_comment

begin_function
specifier|static
name|void
name|init_standard_includes
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|struct
name|default_include
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|specd_prefix
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|include_prefix
argument_list|)
decl_stmt|;
comment|/* Several environment variables may add to the include search path.      CPATH specifies an additional list of directories to be searched      as if specified with -I, while C_INCLUDE_PATH, CPLUS_INCLUDE_PATH,      etc. specify an additional list of directories to be searched as      if specified with -isystem, for the language indicated.  */
name|GET_ENV_PATH_LIST
argument_list|(
name|path
argument_list|,
literal|"CPATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|!=
literal|0
operator|&&
operator|*
name|path
operator|!=
literal|0
condition|)
name|path_include
argument_list|(
name|pfile
argument_list|,
name|path
argument_list|,
name|BRACKET
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|objc
argument_list|)
operator|<<
literal|1
operator|)
operator|+
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|GET_ENV_PATH_LIST
argument_list|(
name|path
argument_list|,
literal|"C_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|GET_ENV_PATH_LIST
argument_list|(
name|path
argument_list|,
literal|"CPLUS_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|GET_ENV_PATH_LIST
argument_list|(
name|path
argument_list|,
literal|"OBJC_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|GET_ENV_PATH_LIST
argument_list|(
name|path
argument_list|,
literal|"OBJCPLUS_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|path
operator|!=
literal|0
operator|&&
operator|*
name|path
operator|!=
literal|0
condition|)
name|path_include
argument_list|(
name|pfile
argument_list|,
name|path
argument_list|,
name|SYSTEM
argument_list|)
expr_stmt|;
comment|/* Search "translated" versions of GNU directories.      These have /usr/local/lib/gcc... replaced by specd_prefix.  */
if|if
condition|(
name|specd_prefix
operator|!=
literal|0
operator|&&
name|cpp_GCC_INCLUDE_DIR_len
condition|)
block|{
comment|/* Remove the `include' from /usr/local/lib/gcc.../include. 	 GCC_INCLUDE_DIR will always end in /include.  */
name|int
name|default_len
init|=
name|cpp_GCC_INCLUDE_DIR_len
decl_stmt|;
name|char
modifier|*
name|default_prefix
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|default_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|specd_len
init|=
name|strlen
argument_list|(
name|specd_prefix
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|default_prefix
argument_list|,
name|cpp_GCC_INCLUDE_DIR
argument_list|,
name|default_len
argument_list|)
expr_stmt|;
name|default_prefix
index|[
name|default_len
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cpp_include_defaults
init|;
name|p
operator|->
name|fname
condition|;
name|p
operator|++
control|)
block|{
comment|/* Some standard dirs are only for C++.  */
if|if
condition|(
operator|!
name|p
operator|->
name|cplusplus
operator|||
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|no_standard_cplusplus_includes
argument_list|)
operator|)
condition|)
block|{
comment|/* Does this dir start with the prefix?  */
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|p
operator|->
name|fname
argument_list|,
name|default_prefix
argument_list|,
name|default_len
argument_list|)
condition|)
block|{
comment|/* Yes; change prefix and add to search list.  */
name|int
name|flen
init|=
name|strlen
argument_list|(
name|p
operator|->
name|fname
argument_list|)
decl_stmt|;
name|int
name|this_len
init|=
name|specd_len
operator|+
name|flen
operator|-
name|default_len
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|this_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|specd_prefix
argument_list|,
name|specd_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|str
operator|+
name|specd_len
argument_list|,
name|p
operator|->
name|fname
operator|+
name|default_len
argument_list|,
name|flen
operator|-
name|default_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|str
argument_list|,
name|SYSTEM
argument_list|,
name|p
operator|->
name|cxx_aware
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Search ordinary names for GNU include directories.  */
for|for
control|(
name|p
operator|=
name|cpp_include_defaults
init|;
name|p
operator|->
name|fname
condition|;
name|p
operator|++
control|)
block|{
comment|/* Some standard dirs are only for C++.  */
if|if
condition|(
operator|!
name|p
operator|->
name|cplusplus
operator|||
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|no_standard_cplusplus_includes
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|str
init|=
name|update_path
argument_list|(
name|p
operator|->
name|fname
argument_list|,
name|p
operator|->
name|component
argument_list|)
decl_stmt|;
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|str
argument_list|,
name|SYSTEM
argument_list|,
name|p
operator|->
name|cxx_aware
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Pushes a command line -imacro and -include file indicated by P onto    the buffer stack.  Returns non-zero if successful.  */
end_comment

begin_function
specifier|static
name|bool
name|push_include
parameter_list|(
name|pfile
parameter_list|,
name|p
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|pending_option
modifier|*
name|p
decl_stmt|;
block|{
name|cpp_token
name|header
decl_stmt|;
comment|/* Later: maybe update this to use the #include "" search path      if cpp_read_file fails.  */
name|header
operator|.
name|type
operator|=
name|CPP_STRING
expr_stmt|;
name|header
operator|.
name|val
operator|.
name|str
operator|.
name|text
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
operator|->
name|arg
expr_stmt|;
name|header
operator|.
name|val
operator|.
name|str
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|p
operator|->
name|arg
argument_list|)
expr_stmt|;
comment|/* Make the command line directive take up a line.  */
name|pfile
operator|->
name|line
operator|++
expr_stmt|;
return|return
name|_cpp_execute_include
argument_list|(
name|pfile
argument_list|,
operator|&
name|header
argument_list|,
name|IT_CMDLINE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Frees a pending_option chain.  */
end_comment

begin_function
specifier|static
name|void
name|free_chain
parameter_list|(
name|head
parameter_list|)
name|struct
name|pending_option
modifier|*
name|head
decl_stmt|;
block|{
name|struct
name|pending_option
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|head
condition|)
block|{
name|next
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is called after options have been parsed, and partially    processed.  Setup for processing input from the file named FNAME,    or stdin if it is the empty string.  Return the original filename    on success (e.g. foo.i->foo.c), or NULL on failure.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cpp_read_main_file
parameter_list|(
name|pfile
parameter_list|,
name|fname
parameter_list|,
name|table
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|hash_table
modifier|*
name|table
decl_stmt|;
block|{
comment|/* The front ends don't set up the hash table until they have      finished processing the command line options, so initializing the      hashtable is deferred until now.  */
name|_cpp_init_hashtable
argument_list|(
name|pfile
argument_list|,
name|table
argument_list|)
expr_stmt|;
comment|/* Set up the include search path now.  */
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|no_standard_includes
argument_list|)
condition|)
name|init_standard_includes
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|merge_include_chains
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* With -v, print the list of dirs to search.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|verbose
argument_list|)
condition|)
block|{
name|struct
name|search_path
modifier|*
name|l
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"#include \"...\" search starts here:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|quote_include
argument_list|)
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l
operator|==
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|bracket_include
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"#include<...> search starts here:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s\n"
argument_list|,
name|l
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"End of search list.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps
argument_list|)
condition|)
comment|/* Set the default target (if there is none already).  */
name|deps_add_default_target
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* Open the main input file.  */
if|if
condition|(
operator|!
name|_cpp_read_file
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Set this after cpp_post_options so the client can change the      option if it wishes, and after stacking the main file so we don't      trace the main file.  */
name|pfile
operator|->
name|line_maps
operator|.
name|trace_includes
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_include_names
argument_list|)
expr_stmt|;
comment|/* For foo.i, read the original filename foo.c now, for the benefit      of the front ends.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
condition|)
name|read_original_filename
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|pfile
operator|->
name|map
operator|->
name|to_file
return|;
block|}
end_function

begin_comment
comment|/* For preprocessed files, if the first tokens are of the form # NUM.    handle the directive so we know the original file name.  This will    generate file_change callbacks, which the front ends must handle    appropriately given their state of initialization.  */
end_comment

begin_function
specifier|static
name|void
name|read_original_filename
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|,
modifier|*
name|token1
decl_stmt|;
comment|/* Lex ahead; if the first tokens are of the form # NUM, then      process the directive, otherwise back up.  */
name|token
operator|=
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_HASH
condition|)
block|{
name|token1
operator|=
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If it's a #line directive, handle it.  */
if|if
condition|(
name|token1
operator|->
name|type
operator|==
name|CPP_NUMBER
condition|)
block|{
name|_cpp_handle_directive
argument_list|(
name|pfile
argument_list|,
name|token
operator|->
name|flags
operator|&
name|PREV_WHITE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Backup as if nothing happened.  */
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle pending command line options: -D, -U, -A, -imacros and    -include.  This should be called after debugging has been properly    set up in the front ends.  */
end_comment

begin_function
name|void
name|cpp_finish_options
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
comment|/* Install builtins and process command line macros etc. in the order      they appeared, but only if not already preprocessed.  */
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
condition|)
block|{
name|struct
name|pending_option
modifier|*
name|p
decl_stmt|;
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|LC_RENAME
argument_list|,
name|_
argument_list|(
literal|"<built-in>"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_builtins
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|LC_RENAME
argument_list|,
name|_
argument_list|(
literal|"<command line>"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|->
name|directive_head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
call|(
modifier|*
name|p
operator|->
name|handler
call|)
argument_list|(
name|pfile
argument_list|,
name|p
operator|->
name|arg
argument_list|)
expr_stmt|;
comment|/* Scan -imacros files after command line defines, but before 	 files given with -include.  */
while|while
condition|(
operator|(
name|p
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|->
name|imacros_head
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|push_include
argument_list|(
name|pfile
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|pfile
operator|->
name|buffer
operator|->
name|return_at_eof
operator|=
name|true
expr_stmt|;
name|cpp_scan_nooutput
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|->
name|imacros_head
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|free_chain
argument_list|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|->
name|directive_head
argument_list|)
expr_stmt|;
name|_cpp_push_next_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called to push the next buffer on the stack given by -include.  If    there are none, free the pending structure and restore the line map    for the main file.  */
end_comment

begin_function
name|bool
name|_cpp_push_next_buffer
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|bool
name|pushed
init|=
name|false
decl_stmt|;
comment|/* This is't pretty; we'd rather not be relying on this as a boolean      for reverting the line map.  Further, we only free the chains in      this conditional, so an early call to cpp_finish / cpp_destroy      will leak that memory.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|->
name|imacros_head
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|!
name|pushed
condition|)
block|{
name|struct
name|pending_option
modifier|*
name|p
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|->
name|include_head
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
condition|)
name|pushed
operator|=
name|push_include
argument_list|(
name|pfile
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|->
name|include_head
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pushed
condition|)
block|{
name|free
argument_list|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
argument_list|)
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* Restore the line map for the main file.  */
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
condition|)
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|LC_RENAME
argument_list|,
name|pfile
operator|->
name|line_maps
operator|.
name|maps
index|[
literal|0
index|]
operator|.
name|to_file
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pushed
return|;
block|}
end_function

begin_comment
comment|/* Use mkdeps.c to output dependency information.  */
end_comment

begin_function
specifier|static
name|void
name|output_deps
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
comment|/* Stream on which to print the dependency information.  */
name|FILE
modifier|*
name|deps_stream
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|deps_mode
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps_append
argument_list|)
condition|?
literal|"a"
else|:
literal|"w"
decl_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps_file
argument_list|)
operator|==
literal|0
condition|)
name|deps_stream
operator|=
name|stdout
expr_stmt|;
else|else
block|{
name|deps_stream
operator|=
name|fopen
argument_list|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps_file
argument_list|)
argument_list|,
name|deps_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|deps_stream
operator|==
literal|0
condition|)
block|{
name|cpp_notice_from_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps_file
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|deps_write
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|deps_stream
argument_list|,
literal|72
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps_phony_targets
argument_list|)
condition|)
name|deps_phony_targets
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|deps_stream
argument_list|)
expr_stmt|;
comment|/* Don't close stdout.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps_file
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|deps_stream
argument_list|)
operator|||
name|fclose
argument_list|(
name|deps_stream
argument_list|)
operator|!=
literal|0
condition|)
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"I/O error on output"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is called at the end of preprocessing.  It pops the    last buffer and writes dependency output.  It should also    clear macro definitions, such that you could call cpp_start_read    with a new filename to restart processing.  */
end_comment

begin_function
name|void
name|cpp_finish
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
comment|/* cpplex.c leaves the final buffer on the stack.  This it so that      it returns an unending stream of CPP_EOFs to the client.  If we      popped the buffer, we'd dereference a NULL buffer pointer and      segfault.  It's nice to allow the client to do worry-free excess      cpp_get_token calls.  */
while|while
condition|(
name|pfile
operator|->
name|buffer
condition|)
name|_cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Don't write the deps file if preprocessing has failed.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps
argument_list|)
operator|&&
name|pfile
operator|->
name|errors
operator|==
literal|0
condition|)
name|output_deps
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Report on headers that could use multiple include guards.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_include_names
argument_list|)
condition|)
name|_cpp_report_missing_guards
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a directive to be handled later in the initialization phase.  */
end_comment

begin_function
specifier|static
name|void
name|new_pending_directive
parameter_list|(
name|pend
parameter_list|,
name|text
parameter_list|,
name|handler
parameter_list|)
name|struct
name|cpp_pending
modifier|*
name|pend
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|cl_directive_handler
name|handler
decl_stmt|;
block|{
name|struct
name|pending_option
modifier|*
name|o
init|=
operator|(
expr|struct
name|pending_option
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_option
argument_list|)
argument_list|)
decl_stmt|;
name|o
operator|->
name|arg
operator|=
name|text
expr_stmt|;
name|o
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|o
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
name|APPEND
argument_list|(
name|pend
argument_list|,
name|directive
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Irix6 "cc -n32" and OSF4 cc have problems with char foo[] = ("string");    I.e. a const string initializer with parens around it.  That is    what N_("string") resolves to, so we make no_* be macros instead.  */
end_comment

begin_define
define|#
directive|define
name|no_arg
value|N_("argument missing after %s")
end_define

begin_define
define|#
directive|define
name|no_ass
value|N_("assertion missing after %s")
end_define

begin_define
define|#
directive|define
name|no_dir
value|N_("directory name missing after %s")
end_define

begin_define
define|#
directive|define
name|no_fil
value|N_("file name missing after %s")
end_define

begin_define
define|#
directive|define
name|no_mac
value|N_("macro name missing after %s")
end_define

begin_define
define|#
directive|define
name|no_pth
value|N_("path name missing after %s")
end_define

begin_define
define|#
directive|define
name|no_num
value|N_("number missing after %s")
end_define

begin_define
define|#
directive|define
name|no_tgt
value|N_("target missing after %s")
end_define

begin_comment
comment|/* This is the list of all command line options, with the leading    "-" removed.  It must be sorted in ASCII collating order.  */
end_comment

begin_define
define|#
directive|define
name|COMMAND_LINE_OPTIONS
define|\
value|DEF_OPT("$",                        0,      OPT_dollar)                     \   DEF_OPT("+",                        0,      OPT_plus)                       \   DEF_OPT("-help",                    0,      OPT__help)                      \   DEF_OPT("-target-help",             0,      OPT_target__help)               \   DEF_OPT("-version",                 0,      OPT__version)                   \   DEF_OPT("A",                        no_ass, OPT_A)                          \   DEF_OPT("C",                        0,      OPT_C)                          \   DEF_OPT("D",                        no_mac, OPT_D)                          \   DEF_OPT("H",                        0,      OPT_H)                          \   DEF_OPT("I",                        no_dir, OPT_I)                          \   DEF_OPT("M",                        0,      OPT_M)                          \   DEF_OPT("MD",                       no_fil, OPT_MD)                         \   DEF_OPT("MF",                       no_fil, OPT_MF)                         \   DEF_OPT("MG",                       0,      OPT_MG)                         \   DEF_OPT("MM",                       0,      OPT_MM)                         \   DEF_OPT("MMD",                      no_fil, OPT_MMD)                        \   DEF_OPT("MP",                       0,      OPT_MP)                         \   DEF_OPT("MQ",                       no_tgt, OPT_MQ)                         \   DEF_OPT("MT",                       no_tgt, OPT_MT)                         \   DEF_OPT("P",                        0,      OPT_P)                          \   DEF_OPT("U",                        no_mac, OPT_U)                          \   DEF_OPT("W",                        no_arg, OPT_W)
comment|/* arg optional */
value|\   DEF_OPT("d",                        no_arg, OPT_d)                          \   DEF_OPT("fleading-underscore",      0,      OPT_fleading_underscore)        \   DEF_OPT("fno-leading-underscore",   0,      OPT_fno_leading_underscore)     \   DEF_OPT("fno-operator-names",       0,      OPT_fno_operator_names)         \   DEF_OPT("fno-preprocessed",         0,      OPT_fno_preprocessed)           \   DEF_OPT("fno-show-column",          0,      OPT_fno_show_column)            \   DEF_OPT("fpreprocessed",            0,      OPT_fpreprocessed)              \   DEF_OPT("fshow-column",             0,      OPT_fshow_column)               \   DEF_OPT("ftabstop=",                no_num, OPT_ftabstop)                   \   DEF_OPT("h",                        0,      OPT_h)                          \   DEF_OPT("idirafter",                no_dir, OPT_idirafter)                  \   DEF_OPT("imacros",                  no_fil, OPT_imacros)                    \   DEF_OPT("include",                  no_fil, OPT_include)                    \   DEF_OPT("iprefix",                  no_pth, OPT_iprefix)                    \   DEF_OPT("isystem",                  no_dir, OPT_isystem)                    \   DEF_OPT("iwithprefix",              no_dir, OPT_iwithprefix)                \   DEF_OPT("iwithprefixbefore",        no_dir, OPT_iwithprefixbefore)          \   DEF_OPT("lang-asm",                 0,      OPT_lang_asm)                   \   DEF_OPT("lang-c",                   0,      OPT_lang_c)                     \   DEF_OPT("lang-c++",                 0,      OPT_lang_cplusplus)             \   DEF_OPT("lang-c89",                 0,      OPT_lang_c89)                   \   DEF_OPT("lang-objc",                0,      OPT_lang_objc)                  \   DEF_OPT("lang-objc++",              0,      OPT_lang_objcplusplus)          \   DEF_OPT("nostdinc",                 0,      OPT_nostdinc)                   \   DEF_OPT("nostdinc++",               0,      OPT_nostdincplusplus)           \   DEF_OPT("o",                        no_fil, OPT_o)                          \   DEF_OPT("pedantic",                 0,      OPT_pedantic)                   \   DEF_OPT("pedantic-errors",          0,      OPT_pedantic_errors)            \   DEF_OPT("remap",                    0,      OPT_remap)                      \   DEF_OPT("std=c++98",                0,      OPT_std_cplusplus98)            \   DEF_OPT("std=c89",                  0,      OPT_std_c89)                    \   DEF_OPT("std=c99",                  0,      OPT_std_c99)                    \   DEF_OPT("std=c9x",                  0,      OPT_std_c9x)                    \   DEF_OPT("std=gnu89",                0,      OPT_std_gnu89)                  \   DEF_OPT("std=gnu99",                0,      OPT_std_gnu99)                  \   DEF_OPT("std=gnu9x",                0,      OPT_std_gnu9x)                  \   DEF_OPT("std=iso9899:1990",         0,      OPT_std_iso9899_1990)           \   DEF_OPT("std=iso9899:199409",       0,      OPT_std_iso9899_199409)         \   DEF_OPT("std=iso9899:1999",         0,      OPT_std_iso9899_1999)           \   DEF_OPT("std=iso9899:199x",         0,      OPT_std_iso9899_199x)           \   DEF_OPT("trigraphs",                0,      OPT_trigraphs)                  \   DEF_OPT("v",                        0,      OPT_v)                          \   DEF_OPT("version",                  0,      OPT_version)                    \   DEF_OPT("w",                        0,      OPT_w)
end_define

begin_define
define|#
directive|define
name|DEF_OPT
parameter_list|(
name|text
parameter_list|,
name|msg
parameter_list|,
name|code
parameter_list|)
value|code,
end_define

begin_enum
enum|enum
name|opt_code
block|{
name|COMMAND_LINE_OPTIONS
name|N_OPTS
block|}
enum|;
end_enum

begin_undef
undef|#
directive|undef
name|DEF_OPT
end_undef

begin_struct
struct|struct
name|cl_option
block|{
specifier|const
name|char
modifier|*
name|opt_text
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|size_t
name|opt_len
decl_stmt|;
name|enum
name|opt_code
name|opt_code
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DEF_OPT
parameter_list|(
name|text
parameter_list|,
name|msg
parameter_list|,
name|code
parameter_list|)
value|{ text, msg, sizeof(text) - 1, code },
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HOST_EBCDIC
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|cl_option
name|cl_options
index|[]
init|=
else|#
directive|else
specifier|static
specifier|const
expr|struct
name|cl_option
name|cl_options
index|[]
operator|=
endif|#
directive|endif
block|{
name|COMMAND_LINE_OPTIONS
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_OPT
end_undef

begin_undef
undef|#
directive|undef
name|COMMAND_LINE_OPTIONS
end_undef

begin_comment
comment|/* Perform a binary search to find which, if any, option the given    command-line matches.  Returns its index in the option array,    negative on failure.  Complications arise since some options can be    suffixed with an argument, and multiple complete matches can occur,    e.g. -iwithprefix and -iwithprefixbefore.  Moreover, we need to    accept options beginning with -W that we do not recognise, but not    to swallow any subsequent command line argument; this is handled as    special cases in cpp_handle_option.  */
end_comment

begin_function
specifier|static
name|int
name|parse_option
parameter_list|(
name|input
parameter_list|)
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
block|{
name|unsigned
name|int
name|md
decl_stmt|,
name|mn
decl_stmt|,
name|mx
decl_stmt|;
name|size_t
name|opt_len
decl_stmt|;
name|int
name|comp
decl_stmt|;
name|mn
operator|=
literal|0
expr_stmt|;
name|mx
operator|=
name|N_OPTS
expr_stmt|;
while|while
condition|(
name|mx
operator|>
name|mn
condition|)
block|{
name|md
operator|=
operator|(
name|mn
operator|+
name|mx
operator|)
operator|/
literal|2
expr_stmt|;
name|opt_len
operator|=
name|cl_options
index|[
name|md
index|]
operator|.
name|opt_len
expr_stmt|;
name|comp
operator|=
name|memcmp
argument_list|(
name|input
argument_list|,
name|cl_options
index|[
name|md
index|]
operator|.
name|opt_text
argument_list|,
name|opt_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|>
literal|0
condition|)
name|mn
operator|=
name|md
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
operator|<
literal|0
condition|)
name|mx
operator|=
name|md
expr_stmt|;
else|else
block|{
if|if
condition|(
name|input
index|[
name|opt_len
index|]
operator|==
literal|'\0'
condition|)
return|return
name|md
return|;
comment|/* We were passed more text.  If the option takes an argument, 	     we may match a later option or we may have been passed the 	     argument.  The longest possible option match succeeds. 	     If the option takes no arguments we have not matched and 	     continue the search (e.g. input="stdc++" match was "stdc").  */
name|mn
operator|=
name|md
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cl_options
index|[
name|md
index|]
operator|.
name|msg
condition|)
block|{
comment|/* Scan forwards.  If we get an exact match, return it. 		 Otherwise, return the longest option-accepting match. 		 This loops no more than twice with current options.  */
name|mx
operator|=
name|md
expr_stmt|;
for|for
control|(
init|;
name|mn
operator|<
operator|(
name|unsigned
name|int
operator|)
name|N_OPTS
condition|;
name|mn
operator|++
control|)
block|{
name|opt_len
operator|=
name|cl_options
index|[
name|mn
index|]
operator|.
name|opt_len
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|input
argument_list|,
name|cl_options
index|[
name|mn
index|]
operator|.
name|opt_text
argument_list|,
name|opt_len
argument_list|)
condition|)
break|break;
if|if
condition|(
name|input
index|[
name|opt_len
index|]
operator|==
literal|'\0'
condition|)
return|return
name|mn
return|;
if|if
condition|(
name|cl_options
index|[
name|mn
index|]
operator|.
name|msg
condition|)
name|mx
operator|=
name|mn
expr_stmt|;
block|}
return|return
name|mx
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Handle one command-line option in (argc, argv).    Can be called multiple times, to handle multiple sets of options.    If ignore is non-zero, this will ignore unrecognized -W* options.    Returns number of strings consumed.  */
end_comment

begin_function
name|int
name|cpp_handle_option
parameter_list|(
name|pfile
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|ignore
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|ignore
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|cpp_pending
modifier|*
name|pend
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pending
argument_list|)
decl_stmt|;
comment|/* Interpret "-" or a non-option as a file name.  */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|in_fname
argument_list|)
operator|==
name|NULL
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|in_fname
argument_list|)
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|out_fname
argument_list|)
operator|==
name|NULL
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|out_fname
argument_list|)
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
else|else
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"too many filenames. Type %s --help for usage info"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|opt_code
name|opt_code
decl_stmt|;
name|int
name|opt_index
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
init|=
literal|0
decl_stmt|;
comment|/* Skip over '-'.  */
name|opt_index
operator|=
name|parse_option
argument_list|(
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_index
operator|<
literal|0
condition|)
return|return
name|i
return|;
name|opt_code
operator|=
name|cl_options
index|[
name|opt_index
index|]
operator|.
name|opt_code
expr_stmt|;
if|if
condition|(
name|cl_options
index|[
name|opt_index
index|]
operator|.
name|msg
condition|)
block|{
name|arg
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
name|cl_options
index|[
name|opt_index
index|]
operator|.
name|opt_len
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Yuk. Special case for -W as it must not swallow 	     up any following argument.  If this becomes common, add 	     another field to the cl_options table.  */
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|opt_code
operator|!=
name|OPT_W
condition|)
block|{
name|arg
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
name|cl_options
index|[
name|opt_index
index|]
operator|.
name|msg
argument_list|,
name|argv
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
block|}
block|}
switch|switch
condition|(
name|opt_code
condition|)
block|{
case|case
name|N_OPTS
case|:
comment|/* Shut GCC up.  */
break|break;
case|case
name|OPT_fleading_underscore
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|user_label_prefix
argument_list|)
operator|=
literal|"_"
expr_stmt|;
break|break;
case|case
name|OPT_fno_leading_underscore
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|user_label_prefix
argument_list|)
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|OPT_fno_operator_names
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|operator_names
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPT_fpreprocessed
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_fno_preprocessed
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPT_fshow_column
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|show_column
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_fno_show_column
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|show_column
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPT_ftabstop
case|:
comment|/* Silently ignore empty string, non-longs and silly values.  */
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|long
name|tabstop
init|=
name|strtol
argument_list|(
name|arg
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|==
literal|'\0'
operator|&&
name|tabstop
operator|>=
literal|1
operator|&&
name|tabstop
operator|<=
literal|100
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|tabstop
argument_list|)
operator|=
name|tabstop
expr_stmt|;
block|}
break|break;
case|case
name|OPT_w
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|inhibit_warnings
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_h
case|:
case|case
name|OPT__help
case|:
name|print_help
argument_list|()
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|help_only
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_target__help
case|:
comment|/* Print if any target specific options. cpplib has none, but 	     make sure help_only gets set.  */
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|help_only
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* --version inhibits compilation, -version doesn't. -v means 	     verbose and -version.  Historical reasons, don't ask.  */
case|case
name|OPT__version
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|help_only
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pfile
operator|->
name|print_version
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_v
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|verbose
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pfile
operator|->
name|print_version
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_version
case|:
name|pfile
operator|->
name|print_version
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_C
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPT_P
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|no_line_commands
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_dollar
case|:
comment|/* Don't include $ in identifiers.  */
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|dollars_in_ident
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPT_H
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_include_names
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_D
case|:
name|new_pending_directive
argument_list|(
name|pend
argument_list|,
name|arg
argument_list|,
name|cpp_define
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_pedantic_errors
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pedantic_errors
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* fall through */
case|case
name|OPT_pedantic
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pedantic
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_trigraphs
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|trigraphs
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_plus
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus_comments
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_remap
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|remap
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_iprefix
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|include_prefix
argument_list|)
operator|=
name|arg
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|include_prefix_len
argument_list|)
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_lang_c
case|:
name|set_lang
argument_list|(
name|pfile
argument_list|,
name|CLK_GNUC89
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_lang_cplusplus
case|:
name|set_lang
argument_list|(
name|pfile
argument_list|,
name|CLK_GNUCXX
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_lang_objc
case|:
name|set_lang
argument_list|(
name|pfile
argument_list|,
name|CLK_OBJC
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_lang_objcplusplus
case|:
name|set_lang
argument_list|(
name|pfile
argument_list|,
name|CLK_OBJCXX
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_lang_asm
case|:
name|set_lang
argument_list|(
name|pfile
argument_list|,
name|CLK_ASM
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_std_cplusplus98
case|:
name|set_lang
argument_list|(
name|pfile
argument_list|,
name|CLK_CXX98
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_std_gnu89
case|:
name|set_lang
argument_list|(
name|pfile
argument_list|,
name|CLK_GNUC89
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_std_gnu9x
case|:
case|case
name|OPT_std_gnu99
case|:
name|set_lang
argument_list|(
name|pfile
argument_list|,
name|CLK_GNUC99
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_std_iso9899_199409
case|:
name|set_lang
argument_list|(
name|pfile
argument_list|,
name|CLK_STDC94
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_std_iso9899_1990
case|:
case|case
name|OPT_std_c89
case|:
case|case
name|OPT_lang_c89
case|:
name|set_lang
argument_list|(
name|pfile
argument_list|,
name|CLK_STDC89
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_std_iso9899_199x
case|:
case|case
name|OPT_std_iso9899_1999
case|:
case|case
name|OPT_std_c9x
case|:
case|case
name|OPT_std_c99
case|:
name|set_lang
argument_list|(
name|pfile
argument_list|,
name|CLK_STDC99
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_nostdinc
case|:
comment|/* -nostdinc causes no default include directories. 	     You must specify all include-file directories with -I.  */
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|no_standard_includes
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_nostdincplusplus
case|:
comment|/* -nostdinc++ causes no default C++-specific include directories.  */
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|no_standard_cplusplus_includes
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_o
case|:
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|out_fname
argument_list|)
operator|==
name|NULL
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|out_fname
argument_list|)
operator|=
name|arg
expr_stmt|;
else|else
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"output filename specified twice"
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
break|break;
case|case
name|OPT_d
case|:
comment|/* Args to -d specify what parts of macros to dump. 	     Silently ignore unrecognised options; they may 	     be aimed at the compiler proper.  */
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|arg
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'M'
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|dump_macros
argument_list|)
operator|=
name|dump_only
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|no_output
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|dump_macros
argument_list|)
operator|=
name|dump_names
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|dump_macros
argument_list|)
operator|=
name|dump_definitions
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|dump_includes
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|OPT_MG
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps_missing_files
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_M
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps
argument_list|)
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|OPT_MM
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_MF
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps_file
argument_list|)
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_MP
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps_phony_targets
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_MQ
case|:
case|case
name|OPT_MT
case|:
comment|/* Add a target.  -MQ quotes for Make.  */
name|deps_add_target
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|arg
argument_list|,
name|opt_code
operator|==
name|OPT_MQ
argument_list|)
expr_stmt|;
break|break;
comment|/* -MD and -MMD for cpp0 are deprecated and undocumented 	     (use -M or -MM with -MF instead), and probably should be 	     removed with the next major GCC version.  For the moment 	     we allow these for the benefit of Automake 1.4, which 	     uses these when dependency tracking is enabled.  Automake 	     1.5 will fix this.  */
case|case
name|OPT_MD
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps
argument_list|)
operator|=
literal|2
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps_file
argument_list|)
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_MMD
case|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps_file
argument_list|)
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_A
case|:
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* -A with an argument beginning with '-' acts as 		 #unassert on whatever immediately follows the '-'. 		 If "-" is the whole argument, we eliminate all 		 predefined macros and assertions, including those 		 that were specified earlier on the command line. 		 That way we can get rid of any that were passed 		 automatically in from GCC.  */
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|free_chain
argument_list|(
name|pend
operator|->
name|directive_head
argument_list|)
expr_stmt|;
name|pend
operator|->
name|directive_head
operator|=
name|NULL
expr_stmt|;
name|pend
operator|->
name|directive_tail
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|new_pending_directive
argument_list|(
name|pend
argument_list|,
name|arg
operator|+
literal|1
argument_list|,
name|cpp_unassert
argument_list|)
expr_stmt|;
block|}
else|else
name|new_pending_directive
argument_list|(
name|pend
argument_list|,
name|arg
argument_list|,
name|cpp_assert
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_U
case|:
name|new_pending_directive
argument_list|(
name|pend
argument_list|,
name|arg
argument_list|,
name|cpp_undef
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_I
case|:
comment|/* Add directory to path for includes.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
comment|/* -I- means: 		 Use the preceding -I directories for #include "..." 		 but not #include<...>. 		 Don't search the directory of the present file 		 for #include "...".  (Note that -I. -I- is not the same as 		 the default setup; -I. uses the compiler's working dir.)  */
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|ignore_srcdir
argument_list|)
condition|)
block|{
name|pend
operator|->
name|quote_head
operator|=
name|pend
operator|->
name|brack_head
expr_stmt|;
name|pend
operator|->
name|quote_tail
operator|=
name|pend
operator|->
name|brack_tail
expr_stmt|;
name|pend
operator|->
name|brack_head
operator|=
literal|0
expr_stmt|;
name|pend
operator|->
name|brack_tail
operator|=
literal|0
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|ignore_srcdir
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"-I- specified twice"
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
block|}
else|else
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|xstrdup
argument_list|(
name|arg
argument_list|)
argument_list|,
name|BRACKET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_isystem
case|:
comment|/* Add directory to beginning of system include path, as a system 	     include directory.  */
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|xstrdup
argument_list|(
name|arg
argument_list|)
argument_list|,
name|SYSTEM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_include
case|:
case|case
name|OPT_imacros
case|:
block|{
name|struct
name|pending_option
modifier|*
name|o
init|=
operator|(
expr|struct
name|pending_option
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_option
argument_list|)
argument_list|)
decl_stmt|;
name|o
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|o
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|opt_code
operator|==
name|OPT_include
condition|)
name|APPEND
argument_list|(
name|pend
argument_list|,
name|include
argument_list|,
name|o
argument_list|)
expr_stmt|;
else|else
name|APPEND
argument_list|(
name|pend
argument_list|,
name|imacros
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPT_iwithprefix
case|:
comment|/* Add directory to end of path for includes, 	     with the default prefix at the front of its name.  */
comment|/* fall through */
case|case
name|OPT_iwithprefixbefore
case|:
comment|/* Add directory to main path for includes, 	     with the default prefix at the front of its name.  */
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|include_prefix
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|size_t
name|ipl
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|include_prefix_len
argument_list|)
decl_stmt|;
name|fname
operator|=
name|xmalloc
argument_list|(
name|ipl
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
argument_list|,
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|include_prefix
argument_list|)
argument_list|,
name|ipl
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
operator|+
name|ipl
argument_list|,
name|arg
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cpp_GCC_INCLUDE_DIR_len
condition|)
block|{
name|fname
operator|=
name|xmalloc
argument_list|(
name|cpp_GCC_INCLUDE_DIR_len
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
argument_list|,
name|cpp_GCC_INCLUDE_DIR
argument_list|,
name|cpp_GCC_INCLUDE_DIR_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
operator|+
name|cpp_GCC_INCLUDE_DIR_len
argument_list|,
name|arg
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|fname
operator|=
name|xstrdup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|opt_code
operator|==
name|OPT_iwithprefix
condition|?
name|SYSTEM
else|:
name|BRACKET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPT_idirafter
case|:
comment|/* Add directory to end of path for includes.  */
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|xstrdup
argument_list|(
name|arg
argument_list|)
argument_list|,
name|AFTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_W
case|:
comment|/* Silently ignore unrecognised options.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wall"
argument_list|)
condition|)
block|{
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_trigraphs
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_comments
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wtraditional"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_traditional
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wtrigraphs"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_trigraphs
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wcomment"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_comments
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wcomments"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_comments
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wundef"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_undef
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wimport"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_import
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Werror"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warnings_are_errors
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wsystem-headers"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_system_headers
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-traditional"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_traditional
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-trigraphs"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_trigraphs
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-comment"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_comments
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-comments"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_comments
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-undef"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_undef
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-import"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_import
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-error"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warnings_are_errors
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-system-headers"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_system_headers
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ignore
condition|)
return|return
name|i
return|;
break|break;
block|}
block|}
return|return
name|i
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Handle command-line options in (argc, argv).    Can be called multiple times, to handle multiple sets of options.    Returns if an unrecognized option is seen.    Returns number of strings consumed.  */
end_comment

begin_function
name|int
name|cpp_handle_options
parameter_list|(
name|pfile
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|strings_processed
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|+=
name|strings_processed
control|)
block|{
name|strings_processed
operator|=
name|cpp_handle_option
argument_list|(
name|pfile
argument_list|,
name|argc
operator|-
name|i
argument_list|,
name|argv
operator|+
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings_processed
operator|==
literal|0
condition|)
break|break;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Extra processing when all options are parsed, after all calls to    cpp_handle_option[s].  Consistency checks etc.  */
end_comment

begin_function
name|void
name|cpp_post_options
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
if|if
condition|(
name|pfile
operator|->
name|print_version
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"GNU CPP version %s (cpplib)"
argument_list|)
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_VERSION
name|TARGET_VERSION
expr_stmt|;
endif|#
directive|endif
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/* Canonicalize in_fname and out_fname.  We guarantee they are not      NULL, and that the empty string represents stdin / stdout.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|in_fname
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|strcmp
argument_list|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|in_fname
argument_list|)
argument_list|,
literal|"-"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|in_fname
argument_list|)
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|out_fname
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|strcmp
argument_list|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|out_fname
argument_list|)
argument_list|,
literal|"-"
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|out_fname
argument_list|)
operator|=
literal|""
expr_stmt|;
comment|/* -Wtraditional is not useful in C++ mode.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_traditional
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Set this if it hasn't been set already.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|user_label_prefix
argument_list|)
operator|==
name|NULL
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|user_label_prefix
argument_list|)
operator|=
name|USER_LABEL_PREFIX
expr_stmt|;
comment|/* Permanently disable macro expansion if we are rescanning      preprocessed text.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
condition|)
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|=
literal|1
expr_stmt|;
comment|/* We need to do this after option processing and before      cpp_start_read, as cppmain.c relies on the options->no_output to      set its callbacks correctly before calling cpp_start_read.  */
name|init_dependency_output
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* After checking the environment variables, check if -M or -MM has      not been specified, but other -M options have.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps_missing_files
argument_list|)
operator|||
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps_file
argument_list|)
operator|||
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps_phony_targets
argument_list|)
operator|)
condition|)
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"you must additionally specify either -M or -MM"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up dependency-file output.  */
end_comment

begin_function
specifier|static
name|void
name|init_dependency_output
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|char
modifier|*
name|spec
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|output_file
decl_stmt|;
comment|/* Either of two environment variables can specify output of deps.      Its value is either "OUTPUT_FILE" or "OUTPUT_FILE DEPS_TARGET",      where OUTPUT_FILE is the file to write deps info to      and DEPS_TARGET is the target to mention in the deps.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps
argument_list|)
operator|==
literal|0
condition|)
block|{
name|spec
operator|=
name|getenv
argument_list|(
literal|"DEPENDENCIES_OUTPUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|spec
operator|=
name|getenv
argument_list|(
literal|"SUNPRO_DEPENDENCIES"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps
argument_list|)
operator|=
literal|2
expr_stmt|;
else|else
return|return;
block|}
comment|/* Find the space before the DEPS_TARGET, if there is one.  */
name|s
operator|=
name|strchr
argument_list|(
name|spec
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
comment|/* Let the caller perform MAKE quoting.  */
name|deps_add_target
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|s
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_file
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|s
operator|-
name|spec
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|output_file
argument_list|,
name|spec
argument_list|,
name|s
operator|-
name|spec
argument_list|)
expr_stmt|;
name|output_file
index|[
name|s
operator|-
name|spec
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|output_file
operator|=
name|spec
expr_stmt|;
comment|/* Command line overrides environment variables.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps_file
argument_list|)
operator|==
literal|0
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps_file
argument_list|)
operator|=
name|output_file
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps_append
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If dependencies go to standard output, or -MG is used, we should      suppress output, including -dM, -dI etc.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps_file
argument_list|)
operator|==
literal|0
operator|||
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps_missing_files
argument_list|)
condition|)
block|{
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|no_output
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|dump_macros
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|dump_includes
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle --help output.  */
end_comment

begin_function
specifier|static
name|void
name|print_help
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Usage: %s [switches] input output\n"
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
comment|/* To keep the lines from getting too long for some compilers, limit      to about 500 characters (6 lines) per chunk.  */
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ Switches:\n\   -include<file>           Include the contents of<file> before other files\n\   -imacros<file>           Accept definition of macros in<file>\n\   -iprefix<path>           Specify<path> as a prefix for next two options\n\   -iwithprefix<dir>        Add<dir> to the end of the system include path\n\   -iwithprefixbefore<dir>  Add<dir> to the end of the main include path\n\   -isystem<dir>            Add<dir> to the start of the system include path\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -idirafter<dir>          Add<dir> to the end of the system include path\n\   -I<dir>                  Add<dir> to the end of the main include path\n\   -I-                       Fine-grained include path control; see info docs\n\   -nostdinc                 Do not search system include directories\n\                              (dirs specified with -isystem will still be used)\n\   -nostdinc++               Do not search system include directories for C++\n\   -o<file>                 Put output into<file>\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -pedantic                 Issue all warnings demanded by strict ISO C\n\   -pedantic-errors          Issue -pedantic warnings as errors instead\n\   -trigraphs                Support ISO C trigraphs\n\   -lang-c                   Assume that the input sources are in C\n\   -lang-c89                 Assume that the input sources are in C89\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -lang-c++                 Assume that the input sources are in C++\n\   -lang-objc                Assume that the input sources are in ObjectiveC\n\   -lang-objc++              Assume that the input sources are in ObjectiveC++\n\   -lang-asm                 Assume that the input sources are in assembler\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -std=<std name>           Specify the conformance standard; one of:\n\                             gnu89, gnu99, c89, c99, iso9899:1990,\n\                             iso9899:199409, iso9899:1999\n\   -+                        Allow parsing of C++ style features\n\   -w                        Inhibit warning messages\n\   -Wtrigraphs               Warn if trigraphs are encountered\n\   -Wno-trigraphs            Do not warn about trigraphs\n\   -Wcomment{s}              Warn if one comment starts inside another\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -Wno-comment{s}           Do not warn about comments\n\   -Wtraditional             Warn about features not present in traditional C\n\   -Wno-traditional          Do not warn about traditional C\n\   -Wundef                   Warn if an undefined macro is used by #if\n\   -Wno-undef                Do not warn about testing undefined macros\n\   -Wimport                  Warn about the use of the #import directive\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -Wno-import               Do not warn about the use of #import\n\   -Werror                   Treat all warnings as errors\n\   -Wno-error                Do not treat warnings as errors\n\   -Wsystem-headers          Do not suppress warnings from system headers\n\   -Wno-system-headers       Suppress warnings from system headers\n\   -Wall                     Enable all preprocessor warnings\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -M                        Generate make dependencies\n\   -MM                       As -M, but ignore system header files\n\   -MF<file>                Write dependency output to the given file\n\   -MG                       Treat missing header file as generated files\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -MP			    Generate phony targets for all headers\n\   -MQ<target>              Add a MAKE-quoted target\n\   -MT<target>              Add an unquoted target\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -D<macro>                 Define a<macro> with string '1' as its value\n\   -D<macro>=<val>           Define a<macro> with<val> as its value\n\   -A<question> (<answer>)   Assert the<answer> to<question>\n\   -A-<question> (<answer>)  Disable the<answer> to<question>\n\   -U<macro>                 Undefine<macro> \n\   -v                        Display the version number\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -H                        Print the name of header files as they are used\n\   -C                        Do not discard comments\n\   -dM                       Display a list of macro definitions active at end\n\   -dD                       Preserve macro definitions in output\n\   -dN                       As -dD except that only the names are preserved\n\   -dI                       Include #include directives in the output\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -fpreprocessed            Treat the input file as already preprocessed\n\   -ftabstop=<number>        Distance between tab stops for column reporting\n\   -P                        Do not generate #line directives\n\   -$                        Do not allow '$' in identifiers\n\   -remap                    Remap file names when including files.\n\   --version                 Display version information\n\   -h or --help              Display this information\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

