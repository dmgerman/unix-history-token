begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Vector API for GNU compiler.    Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.    Contributed by Nathan Sidwell<nathan@codesourcery.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file is compiled twice: once for the generator programs    once for the compiler.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GENERATOR_FILE
end_ifdef

begin_include
include|#
directive|include
file|"bconfig.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"vec.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_struct
struct|struct
name|vec_prefix
block|{
name|unsigned
name|num
decl_stmt|;
name|unsigned
name|alloc
decl_stmt|;
name|void
modifier|*
name|vec
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Calculate the new ALLOC value, making sure that RESERVE slots are    free.  If EXACT grow exactly, otherwise grow exponentially.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|calculate_allocation
parameter_list|(
specifier|const
name|struct
name|vec_prefix
modifier|*
name|pfx
parameter_list|,
name|int
name|reserve
parameter_list|,
name|bool
name|exact
parameter_list|)
block|{
name|unsigned
name|alloc
init|=
literal|0
decl_stmt|;
name|unsigned
name|num
init|=
literal|0
decl_stmt|;
name|gcc_assert
argument_list|(
name|reserve
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfx
condition|)
block|{
name|alloc
operator|=
name|pfx
operator|->
name|alloc
expr_stmt|;
name|num
operator|=
name|pfx
operator|->
name|num
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|reserve
condition|)
comment|/* If there's no prefix, and we've not requested anything, then we        will create a NULL vector.  */
return|return
literal|0
return|;
comment|/* We must have run out of room.  */
name|gcc_assert
argument_list|(
name|alloc
operator|-
name|num
operator|<
operator|(
name|unsigned
operator|)
name|reserve
argument_list|)
expr_stmt|;
if|if
condition|(
name|exact
condition|)
comment|/* Exact size.  */
name|alloc
operator|=
name|num
operator|+
name|reserve
expr_stmt|;
else|else
block|{
comment|/* Exponential growth. */
if|if
condition|(
operator|!
name|alloc
condition|)
name|alloc
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|alloc
operator|<
literal|16
condition|)
comment|/* Double when small.  */
name|alloc
operator|=
name|alloc
operator|*
literal|2
expr_stmt|;
else|else
comment|/* Grow slower when large.  */
name|alloc
operator|=
operator|(
name|alloc
operator|*
literal|3
operator|/
literal|2
operator|)
expr_stmt|;
comment|/* If this is still too small, set it to the right size. */
if|if
condition|(
name|alloc
operator|<
name|num
operator|+
name|reserve
condition|)
name|alloc
operator|=
name|num
operator|+
name|reserve
expr_stmt|;
block|}
return|return
name|alloc
return|;
block|}
end_function

begin_comment
comment|/* Ensure there are at least RESERVE free slots in VEC.  If EXACT grow    exactly, else grow exponentially.  As a special case, if VEC is    NULL and RESERVE is 0, no vector will be created.  The vector's    trailing array is at VEC_OFFSET offset and consists of ELT_SIZE    sized elements.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|vec_gc_o_reserve_1
parameter_list|(
name|void
modifier|*
name|vec
parameter_list|,
name|int
name|reserve
parameter_list|,
name|size_t
name|vec_offset
parameter_list|,
name|size_t
name|elt_size
parameter_list|,
name|bool
name|exact
name|MEM_STAT_DECL
parameter_list|)
block|{
name|struct
name|vec_prefix
modifier|*
name|pfx
init|=
name|vec
decl_stmt|;
name|unsigned
name|alloc
init|=
name|alloc
operator|=
name|calculate_allocation
argument_list|(
name|pfx
argument_list|,
name|reserve
argument_list|,
name|exact
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alloc
condition|)
return|return
name|NULL
return|;
name|vec
operator|=
name|ggc_realloc_stat
argument_list|(
argument|vec
argument_list|,
argument|vec_offset + alloc * elt_size PASS_MEM_STAT
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|vec_prefix
operator|*
operator|)
name|vec
operator|)
operator|->
name|alloc
operator|=
name|alloc
expr_stmt|;
if|if
condition|(
operator|!
name|pfx
condition|)
operator|(
operator|(
expr|struct
name|vec_prefix
operator|*
operator|)
name|vec
operator|)
operator|->
name|num
operator|=
literal|0
expr_stmt|;
return|return
name|vec
return|;
block|}
end_function

begin_comment
comment|/* Ensure there are at least RESERVE free slots in VEC, growing    exponentially.  If RESERVE< 0 grow exactly, else grow    exponentially.  As a special case, if VEC is NULL, and RESERVE is    0, no vector will be created. */
end_comment

begin_function
name|void
modifier|*
name|vec_gc_p_reserve
parameter_list|(
name|void
modifier|*
name|vec
parameter_list|,
name|int
name|reserve
name|MEM_STAT_DECL
parameter_list|)
block|{
return|return
name|vec_gc_o_reserve_1
argument_list|(
argument|vec
argument_list|,
argument|reserve
argument_list|,
argument|offsetof (struct vec_prefix, vec)
argument_list|,
argument|sizeof (void *)
argument_list|,
argument|false 			     PASS_MEM_STAT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Ensure there are at least RESERVE free slots in VEC, growing    exactly.  If RESERVE< 0 grow exactly, else grow exponentially.  As    a special case, if VEC is NULL, and RESERVE is 0, no vector will be    created. */
end_comment

begin_function
name|void
modifier|*
name|vec_gc_p_reserve_exact
parameter_list|(
name|void
modifier|*
name|vec
parameter_list|,
name|int
name|reserve
name|MEM_STAT_DECL
parameter_list|)
block|{
return|return
name|vec_gc_o_reserve_1
argument_list|(
argument|vec
argument_list|,
argument|reserve
argument_list|,
argument|offsetof (struct vec_prefix, vec)
argument_list|,
argument|sizeof (void *)
argument_list|,
argument|true 			     PASS_MEM_STAT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* As for vec_gc_p_reserve, but for object vectors.  The vector's    trailing array is at VEC_OFFSET offset and consists of ELT_SIZE    sized elements.  */
end_comment

begin_function
name|void
modifier|*
name|vec_gc_o_reserve
parameter_list|(
name|void
modifier|*
name|vec
parameter_list|,
name|int
name|reserve
parameter_list|,
name|size_t
name|vec_offset
parameter_list|,
name|size_t
name|elt_size
name|MEM_STAT_DECL
parameter_list|)
block|{
return|return
name|vec_gc_o_reserve_1
argument_list|(
argument|vec
argument_list|,
argument|reserve
argument_list|,
argument|vec_offset
argument_list|,
argument|elt_size
argument_list|,
argument|false 			     PASS_MEM_STAT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* As for vec_gc_p_reserve_exact, but for object vectors.  The    vector's trailing array is at VEC_OFFSET offset and consists of    ELT_SIZE sized elements.  */
end_comment

begin_function
name|void
modifier|*
name|vec_gc_o_reserve_exact
parameter_list|(
name|void
modifier|*
name|vec
parameter_list|,
name|int
name|reserve
parameter_list|,
name|size_t
name|vec_offset
parameter_list|,
name|size_t
name|elt_size
name|MEM_STAT_DECL
parameter_list|)
block|{
return|return
name|vec_gc_o_reserve_1
argument_list|(
argument|vec
argument_list|,
argument|reserve
argument_list|,
argument|vec_offset
argument_list|,
argument|elt_size
argument_list|,
argument|true 			     PASS_MEM_STAT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* As for vec_gc_o_reserve_1, but for heap allocated vectors.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|vec_heap_o_reserve_1
parameter_list|(
name|void
modifier|*
name|vec
parameter_list|,
name|int
name|reserve
parameter_list|,
name|size_t
name|vec_offset
parameter_list|,
name|size_t
name|elt_size
parameter_list|,
name|bool
name|exact
name|MEM_STAT_DECL
parameter_list|)
block|{
name|struct
name|vec_prefix
modifier|*
name|pfx
init|=
name|vec
decl_stmt|;
name|unsigned
name|alloc
init|=
name|calculate_allocation
argument_list|(
name|pfx
argument_list|,
name|reserve
argument_list|,
name|exact
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alloc
condition|)
return|return
name|NULL
return|;
name|vec
operator|=
name|xrealloc
argument_list|(
name|vec
argument_list|,
name|vec_offset
operator|+
name|alloc
operator|*
name|elt_size
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|vec_prefix
operator|*
operator|)
name|vec
operator|)
operator|->
name|alloc
operator|=
name|alloc
expr_stmt|;
if|if
condition|(
operator|!
name|pfx
condition|)
operator|(
operator|(
expr|struct
name|vec_prefix
operator|*
operator|)
name|vec
operator|)
operator|->
name|num
operator|=
literal|0
expr_stmt|;
return|return
name|vec
return|;
block|}
end_function

begin_comment
comment|/* As for vec_gc_p_reserve, but for heap allocated vectors.  */
end_comment

begin_function
name|void
modifier|*
name|vec_heap_p_reserve
parameter_list|(
name|void
modifier|*
name|vec
parameter_list|,
name|int
name|reserve
name|MEM_STAT_DECL
parameter_list|)
block|{
return|return
name|vec_heap_o_reserve_1
argument_list|(
argument|vec
argument_list|,
argument|reserve
argument_list|,
argument|offsetof (struct vec_prefix, vec)
argument_list|,
argument|sizeof (void *)
argument_list|,
argument|false 			       PASS_MEM_STAT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* As for vec_gc_p_reserve_exact, but for heap allocated vectors.  */
end_comment

begin_function
name|void
modifier|*
name|vec_heap_p_reserve_exact
parameter_list|(
name|void
modifier|*
name|vec
parameter_list|,
name|int
name|reserve
name|MEM_STAT_DECL
parameter_list|)
block|{
return|return
name|vec_heap_o_reserve_1
argument_list|(
argument|vec
argument_list|,
argument|reserve
argument_list|,
argument|offsetof (struct vec_prefix, vec)
argument_list|,
argument|sizeof (void *)
argument_list|,
argument|true 			       PASS_MEM_STAT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* As for vec_gc_o_reserve, but for heap allocated vectors.  */
end_comment

begin_function
name|void
modifier|*
name|vec_heap_o_reserve
parameter_list|(
name|void
modifier|*
name|vec
parameter_list|,
name|int
name|reserve
parameter_list|,
name|size_t
name|vec_offset
parameter_list|,
name|size_t
name|elt_size
name|MEM_STAT_DECL
parameter_list|)
block|{
return|return
name|vec_heap_o_reserve_1
argument_list|(
argument|vec
argument_list|,
argument|reserve
argument_list|,
argument|vec_offset
argument_list|,
argument|elt_size
argument_list|,
argument|false 			       PASS_MEM_STAT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* As for vec_gc_o_reserve_exact, but for heap allocated vectors.  */
end_comment

begin_function
name|void
modifier|*
name|vec_heap_o_reserve_exact
parameter_list|(
name|void
modifier|*
name|vec
parameter_list|,
name|int
name|reserve
parameter_list|,
name|size_t
name|vec_offset
parameter_list|,
name|size_t
name|elt_size
name|MEM_STAT_DECL
parameter_list|)
block|{
return|return
name|vec_heap_o_reserve_1
argument_list|(
argument|vec
argument_list|,
argument|reserve
argument_list|,
argument|vec_offset
argument_list|,
argument|elt_size
argument_list|,
argument|true 			       PASS_MEM_STAT
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|ENABLE_CHECKING
end_if

begin_comment
comment|/* Issue a vector domain error, and then fall over.  */
end_comment

begin_function
name|void
name|vec_assert_fail
parameter_list|(
specifier|const
name|char
modifier|*
name|op
parameter_list|,
specifier|const
name|char
modifier|*
name|struct_name
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"vector %s %s domain error, in %s at %s:%u"
argument_list|,
name|struct_name
argument_list|,
name|op
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

