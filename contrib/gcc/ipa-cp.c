begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Interprocedural constant propagation    Copyright (C) 2005 Free Software Foundation, Inc.    Contributed by Razya Ladelsky<RAZYA@il.ibm.com>     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Interprocedural constant propagation.    The aim of interprocedural constant propagation (IPCP) is to find which     function's argument has the same constant value in each invocation throughout     the whole program. For example, for an application consisting of two files,     foo1.c, foo2.c:     foo1.c contains :        int f (int x)    {      g (x);    }    void main (void)    {      f (3);      h (3);    }        foo2.c contains :        int h (int y)    {      g (y);    }    int g (int y)    {      printf ("value is %d",y);    }        The IPCP algorithm will find that g's formal argument y    is always called with the value 3.        The algorithm used is based on "Interprocedural Constant Propagation",    by Challahan David, Keith D Cooper, Ken Kennedy, Linda Torczon, Comp86,     pg 152-161        The optimization is divided into three stages:     First stage - intraprocedural analysis    =======================================    This phase computes jump_function and modify information.        A jump function for a callsite represents the values passed as actual     arguments    of the callsite. There are three types of values :    Formal - the caller's formal parameter is passed as an actual argument.    Constant - a constant is passed as a an actual argument.    Unknown - neither of the above.        In order to compute the jump functions, we need the modify information for     the formal parameters of methods.        The jump function info, ipa_jump_func, is defined in ipa_edge    structure (defined in ipa_prop.h and pointed to by cgraph_node->aux)    The modify info, ipa_modify, is defined in ipa_node structure    (defined in ipa_prop.h and pointed to by cgraph_edge->aux).        -ipcp_init_stage() is the first stage driver.     Second stage - interprocedural analysis    ========================================    This phase does the interprocedural constant propagation.    It computes for all formal parameters in the program    their cval value that may be:    TOP - unknown.    BOTTOM - non constant.    CONSTANT_TYPE - constant value.        Cval of formal f will have a constant value if all callsites to this    function have the same constant value passed to f.        The cval info, ipcp_formal, is defined in ipa_node structure    (defined in ipa_prop.h and pointed to by cgraph_edge->aux).     -ipcp_iterate_stage() is the second stage driver.     Third phase - transformation of methods code    ============================================    Propagates the constant-valued formals into the function.    For each method mt, whose parameters are consts, we create a clone/version.     We use two ways to annotate the versioned function with the constant     formal information:    1. We insert an assignment statement 'parameter = const' at the beginning    of the cloned method.    2. For read-only formals whose address is not taken, we replace all uses     of the formal with the constant (we provide versioning with an     ipa_replace_map struct representing the trees we want to replace).     We also need to modify some callsites to call to the cloned methods instead    of the original ones. For a callsite passing an argument found to be a    constant by IPCP, there are two different cases to handle:    1. A constant is passed as an argument.    2. A parameter (of the caller) passed as an argument (pass through argument).     In the first case, the callsite in the original caller should be redirected    to call the cloned callee.    In the second case, both the caller and the callee have clones    and the callsite of the cloned caller would be redirected to call to    the cloned callee.     The callgraph is updated accordingly.     This update is done in two stages:    First all cloned methods are created during a traversal of the callgraph,    during which all callsites are redirected to call the cloned method.    Then the callsites are traversed and updated as described above.     -ipcp_insert_stage() is the third phase driver.     */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"ipa-prop.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_comment
comment|/* Get orig node field of ipa_node associated with method MT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|cgraph_node
modifier|*
name|ipcp_method_orig_node
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|)
block|{
return|return
name|IPA_NODE_REF
argument_list|(
name|mt
argument_list|)
operator|->
name|ipcp_orig_node
return|;
block|}
end_function

begin_comment
comment|/* Return true if NODE is a cloned/versioned method.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|ipcp_method_is_cloned
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
name|ipcp_method_orig_node
argument_list|(
name|node
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set ORIG_NODE in ipa_node associated with method NODE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipcp_method_set_orig_node
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|orig_node
parameter_list|)
block|{
name|IPA_NODE_REF
argument_list|(
name|node
argument_list|)
operator|->
name|ipcp_orig_node
operator|=
name|orig_node
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create ipa_node and its data structures for NEW_NODE.    Set ORIG_NODE as the orig_node field in ipa_node.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_cloned_create
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|orig_node
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|new_node
parameter_list|)
block|{
name|ipa_node_create
argument_list|(
name|new_node
argument_list|)
expr_stmt|;
name|ipcp_method_set_orig_node
argument_list|(
name|new_node
argument_list|,
name|orig_node
argument_list|)
expr_stmt|;
name|ipa_method_formal_compute_count
argument_list|(
name|new_node
argument_list|)
expr_stmt|;
name|ipa_method_compute_tree_map
argument_list|(
name|new_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return cval_type field of CVAL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|enum
name|cvalue_type
name|ipcp_cval_get_cvalue_type
parameter_list|(
name|struct
name|ipcp_formal
modifier|*
name|cval
parameter_list|)
block|{
return|return
name|cval
operator|->
name|cval_type
return|;
block|}
end_function

begin_comment
comment|/* Return scale for MT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|gcov_type
name|ipcp_method_get_scale
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|)
block|{
return|return
name|IPA_NODE_REF
argument_list|(
name|mt
argument_list|)
operator|->
name|count_scale
return|;
block|}
end_function

begin_comment
comment|/* Set COUNT as scale for MT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipcp_method_set_scale
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|gcov_type
name|count
parameter_list|)
block|{
name|IPA_NODE_REF
argument_list|(
name|node
argument_list|)
operator|->
name|count_scale
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set TYPE as cval_type field of CVAL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipcp_cval_set_cvalue_type
parameter_list|(
name|struct
name|ipcp_formal
modifier|*
name|cval
parameter_list|,
name|enum
name|cvalue_type
name|type
parameter_list|)
block|{
name|cval
operator|->
name|cval_type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return cvalue field of CVAL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|union
name|parameter_info
modifier|*
name|ipcp_cval_get_cvalue
parameter_list|(
name|struct
name|ipcp_formal
modifier|*
name|cval
parameter_list|)
block|{
return|return
operator|&
operator|(
name|cval
operator|->
name|cvalue
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set VALUE as cvalue field  CVAL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipcp_cval_set_cvalue
parameter_list|(
name|struct
name|ipcp_formal
modifier|*
name|cval
parameter_list|,
name|union
name|parameter_info
modifier|*
name|value
parameter_list|,
name|enum
name|cvalue_type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|CONST_VALUE
operator|||
name|type
operator|==
name|CONST_VALUE_REF
condition|)
name|cval
operator|->
name|cvalue
operator|.
name|value
operator|=
name|value
operator|->
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether TYPE is a constant type.  */
end_comment

begin_function
specifier|static
name|bool
name|ipcp_type_is_const
parameter_list|(
name|enum
name|cvalue_type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|CONST_VALUE
operator|||
name|type
operator|==
name|CONST_VALUE_REF
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if CONST_VAL1 and CONST_VAL2 are equal.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|ipcp_cval_equal_cvalues
parameter_list|(
name|union
name|parameter_info
modifier|*
name|const_val1
parameter_list|,
name|union
name|parameter_info
modifier|*
name|const_val2
parameter_list|,
name|enum
name|cvalue_type
name|type1
parameter_list|,
name|enum
name|cvalue_type
name|type2
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|ipcp_type_is_const
argument_list|(
name|type1
argument_list|)
operator|&&
name|ipcp_type_is_const
argument_list|(
name|type2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|!=
name|type2
condition|)
return|return
name|false
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|const_val1
operator|->
name|value
argument_list|,
name|const_val2
operator|->
name|value
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Compute Meet arithmetics:    Meet (BOTTOM, x) = BOTTOM    Meet (TOP,x) = x    Meet (const_a,const_b) = BOTTOM,  if const_a != const_b.      MEET (const_a,const_b) = const_a, if const_a == const_b.*/
end_comment

begin_function
specifier|static
name|void
name|ipcp_cval_meet
parameter_list|(
name|struct
name|ipcp_formal
modifier|*
name|cval
parameter_list|,
name|struct
name|ipcp_formal
modifier|*
name|cval1
parameter_list|,
name|struct
name|ipcp_formal
modifier|*
name|cval2
parameter_list|)
block|{
if|if
condition|(
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval1
argument_list|)
operator|==
name|BOTTOM
operator|||
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval2
argument_list|)
operator|==
name|BOTTOM
condition|)
block|{
name|ipcp_cval_set_cvalue_type
argument_list|(
name|cval
argument_list|,
name|BOTTOM
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval1
argument_list|)
operator|==
name|TOP
condition|)
block|{
name|ipcp_cval_set_cvalue_type
argument_list|(
name|cval
argument_list|,
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval2
argument_list|)
argument_list|)
expr_stmt|;
name|ipcp_cval_set_cvalue
argument_list|(
name|cval
argument_list|,
name|ipcp_cval_get_cvalue
argument_list|(
name|cval2
argument_list|)
argument_list|,
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval2
argument_list|)
operator|==
name|TOP
condition|)
block|{
name|ipcp_cval_set_cvalue_type
argument_list|(
name|cval
argument_list|,
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval1
argument_list|)
argument_list|)
expr_stmt|;
name|ipcp_cval_set_cvalue
argument_list|(
name|cval
argument_list|,
name|ipcp_cval_get_cvalue
argument_list|(
name|cval1
argument_list|)
argument_list|,
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ipcp_cval_equal_cvalues
argument_list|(
name|ipcp_cval_get_cvalue
argument_list|(
name|cval1
argument_list|)
argument_list|,
name|ipcp_cval_get_cvalue
argument_list|(
name|cval2
argument_list|)
argument_list|,
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval1
argument_list|)
argument_list|,
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval2
argument_list|)
argument_list|)
condition|)
block|{
name|ipcp_cval_set_cvalue_type
argument_list|(
name|cval
argument_list|,
name|BOTTOM
argument_list|)
expr_stmt|;
return|return;
block|}
name|ipcp_cval_set_cvalue_type
argument_list|(
name|cval
argument_list|,
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval1
argument_list|)
argument_list|)
expr_stmt|;
name|ipcp_cval_set_cvalue
argument_list|(
name|cval
argument_list|,
name|ipcp_cval_get_cvalue
argument_list|(
name|cval1
argument_list|)
argument_list|,
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return cval structure for the formal at index INFO_TYPE in MT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|ipcp_formal
modifier|*
name|ipcp_method_cval
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|,
name|int
name|info_type
parameter_list|)
block|{
return|return
operator|&
operator|(
name|IPA_NODE_REF
argument_list|(
name|mt
argument_list|)
operator|->
name|ipcp_cval
index|[
name|info_type
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given the jump function (TYPE, INFO_TYPE), compute a new value of CVAL.      If TYPE is FORMAL_IPA_TYPE, the cval of the corresponding formal is     drawn from MT.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_cval_compute
parameter_list|(
name|struct
name|ipcp_formal
modifier|*
name|cval
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|,
name|enum
name|jump_func_type
name|type
parameter_list|,
name|union
name|parameter_info
modifier|*
name|info_type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|UNKNOWN_IPATYPE
condition|)
name|ipcp_cval_set_cvalue_type
argument_list|(
name|cval
argument_list|,
name|BOTTOM
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|CONST_IPATYPE
condition|)
block|{
name|ipcp_cval_set_cvalue_type
argument_list|(
name|cval
argument_list|,
name|CONST_VALUE
argument_list|)
expr_stmt|;
name|ipcp_cval_set_cvalue
argument_list|(
name|cval
argument_list|,
name|info_type
argument_list|,
name|CONST_VALUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|CONST_IPATYPE_REF
condition|)
block|{
name|ipcp_cval_set_cvalue_type
argument_list|(
name|cval
argument_list|,
name|CONST_VALUE_REF
argument_list|)
expr_stmt|;
name|ipcp_cval_set_cvalue
argument_list|(
name|cval
argument_list|,
name|info_type
argument_list|,
name|CONST_VALUE_REF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|FORMAL_IPATYPE
condition|)
block|{
name|enum
name|cvalue_type
name|type
init|=
name|ipcp_cval_get_cvalue_type
argument_list|(
name|ipcp_method_cval
argument_list|(
name|mt
argument_list|,
name|info_type
operator|->
name|formal_id
argument_list|)
argument_list|)
decl_stmt|;
name|ipcp_cval_set_cvalue_type
argument_list|(
name|cval
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ipcp_cval_set_cvalue
argument_list|(
name|cval
argument_list|,
name|ipcp_cval_get_cvalue
argument_list|(
name|ipcp_method_cval
argument_list|(
name|mt
argument_list|,
name|info_type
operator|->
name|formal_id
argument_list|)
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* True when CVAL1 and CVAL2 values are not the same.  */
end_comment

begin_function
specifier|static
name|bool
name|ipcp_cval_changed
parameter_list|(
name|struct
name|ipcp_formal
modifier|*
name|cval1
parameter_list|,
name|struct
name|ipcp_formal
modifier|*
name|cval2
parameter_list|)
block|{
if|if
condition|(
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval1
argument_list|)
operator|==
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval2
argument_list|)
condition|)
block|{
if|if
condition|(
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval1
argument_list|)
operator|!=
name|CONST_VALUE
operator|&&
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval1
argument_list|)
operator|!=
name|CONST_VALUE_REF
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ipcp_cval_equal_cvalues
argument_list|(
name|ipcp_cval_get_cvalue
argument_list|(
name|cval1
argument_list|)
argument_list|,
name|ipcp_cval_get_cvalue
argument_list|(
name|cval2
argument_list|)
argument_list|,
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval1
argument_list|)
argument_list|,
name|ipcp_cval_get_cvalue_type
argument_list|(
name|cval2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create cval structure for method MT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipcp_formal_create
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|)
block|{
name|IPA_NODE_REF
argument_list|(
name|mt
argument_list|)
operator|->
name|ipcp_cval
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|ipcp_formal
argument_list|,
name|ipa_method_formal_count
argument_list|(
name|mt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set cval structure of I-th formal of MT to CVAL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipcp_method_cval_set
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|,
name|int
name|i
parameter_list|,
name|struct
name|ipcp_formal
modifier|*
name|cval
parameter_list|)
block|{
name|IPA_NODE_REF
argument_list|(
name|mt
argument_list|)
operator|->
name|ipcp_cval
index|[
name|i
index|]
operator|.
name|cval_type
operator|=
name|cval
operator|->
name|cval_type
expr_stmt|;
name|ipcp_cval_set_cvalue
argument_list|(
name|ipcp_method_cval
argument_list|(
name|mt
argument_list|,
name|i
argument_list|)
argument_list|,
name|ipcp_cval_get_cvalue
argument_list|(
name|cval
argument_list|)
argument_list|,
name|cval
operator|->
name|cval_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set type of cval structure of formal I of MT to CVAL_TYPE1.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipcp_method_cval_set_cvalue_type
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|,
name|int
name|i
parameter_list|,
name|enum
name|cvalue_type
name|cval_type1
parameter_list|)
block|{
name|IPA_NODE_REF
argument_list|(
name|mt
argument_list|)
operator|->
name|ipcp_cval
index|[
name|i
index|]
operator|.
name|cval_type
operator|=
name|cval_type1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print ipcp_cval data structures to F.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_method_cval_print
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|tree
name|cvalue
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nCVAL PRINT\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Printing cvals %s:\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|ipa_method_formal_count
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ipcp_cval_get_cvalue_type
argument_list|(
name|ipcp_method_cval
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CONST_VALUE
operator|||
name|ipcp_cval_get_cvalue_type
argument_list|(
name|ipcp_method_cval
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CONST_VALUE_REF
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" param [%d]: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"type is CONST "
argument_list|)
expr_stmt|;
name|cvalue
operator|=
name|ipcp_cval_get_cvalue
argument_list|(
name|ipcp_method_cval
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|)
operator|->
name|value
expr_stmt|;
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|cvalue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ipcp_method_cval
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
operator|->
name|cval_type
operator|==
name|TOP
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"param [%d]: type is TOP  \n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"param [%d]: type is BOTTOM  \n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Initialize ipcp_cval array of MT with TOP values.    All cvals for a method's formal parameters are initialized to BOTTOM    The currently supported types are integer types, real types and    Fortran constants (i.e. references to constants defined as    const_decls). All other types are not analyzed and therefore are    assigned with BOTTOM.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_method_cval_init
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|parm_tree
decl_stmt|;
name|ipcp_formal_create
argument_list|(
name|mt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ipa_method_formal_count
argument_list|(
name|mt
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|parm_tree
operator|=
name|ipa_method_get_tree
argument_list|(
name|mt
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm_tree
argument_list|)
argument_list|)
operator|||
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm_tree
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm_tree
argument_list|)
argument_list|)
condition|)
name|ipcp_method_cval_set_cvalue_type
argument_list|(
name|mt
argument_list|,
name|i
argument_list|,
name|TOP
argument_list|)
expr_stmt|;
else|else
name|ipcp_method_cval_set_cvalue_type
argument_list|(
name|mt
argument_list|,
name|i
argument_list|,
name|BOTTOM
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a new assignment statment and make    it the first statement in the function FN    tree.    PARM1 is the lhs of the assignment and    VAL is the rhs. */
end_comment

begin_function
specifier|static
name|void
name|constant_val_insert
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|parm1
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|struct
name|function
modifier|*
name|func
decl_stmt|;
name|tree
name|init_stmt
decl_stmt|;
name|edge
name|e_step
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|init_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|parm1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|func
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|cfun
operator|=
name|func
expr_stmt|;
name|current_function_decl
operator|=
name|fn
expr_stmt|;
if|if
condition|(
name|ENTRY_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|func
argument_list|)
operator|->
name|succs
condition|)
name|FOR_EACH_EDGE
argument_list|(
argument|e_step
argument_list|,
argument|ei
argument_list|,
argument|ENTRY_BLOCK_PTR_FOR_FUNCTION (func)->succs
argument_list|)
name|bsi_insert_on_edge_immediate
argument_list|(
name|e_step
argument_list|,
name|init_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* build INTEGER_CST tree with type TREE_TYPE and     value according to CVALUE. Return the tree.   */
end_comment

begin_function
specifier|static
name|tree
name|build_const_val
parameter_list|(
name|union
name|parameter_info
modifier|*
name|cvalue
parameter_list|,
name|enum
name|cvalue_type
name|type
parameter_list|,
name|tree
name|tree_type
parameter_list|)
block|{
name|tree
name|const_val
init|=
name|NULL
decl_stmt|;
name|gcc_assert
argument_list|(
name|ipcp_type_is_const
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|const_val
operator|=
name|fold_convert
argument_list|(
name|tree_type
argument_list|,
name|cvalue
operator|->
name|value
argument_list|)
expr_stmt|;
return|return
name|const_val
return|;
block|}
end_function

begin_comment
comment|/* Build the tree representing the constant and call     constant_val_insert().  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_propagate_const
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|,
name|int
name|param
parameter_list|,
name|union
name|parameter_info
modifier|*
name|cvalue
parameter_list|,
name|enum
name|cvalue_type
name|type
parameter_list|)
block|{
name|tree
name|fndecl
decl_stmt|;
name|tree
name|const_val
decl_stmt|;
name|tree
name|parm_tree
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"propagating const to %s\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|mt
argument_list|)
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|mt
operator|->
name|decl
expr_stmt|;
name|parm_tree
operator|=
name|ipa_method_get_tree
argument_list|(
name|mt
argument_list|,
name|param
argument_list|)
expr_stmt|;
name|const_val
operator|=
name|build_const_val
argument_list|(
name|cvalue
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm_tree
argument_list|)
argument_list|)
expr_stmt|;
name|constant_val_insert
argument_list|(
name|fndecl
argument_list|,
name|parm_tree
argument_list|,
name|const_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the proper scale for NODE.  It is the ratio between     the number of direct calls (represented on the incoming     cgraph_edges) and sum of all invocations of NODE (represented     as count in cgraph_node). */
end_comment

begin_function
specifier|static
name|void
name|ipcp_method_compute_scale
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|gcov_type
name|sum
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|cs
decl_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
comment|/* Compute sum of all counts of callers. */
for|for
control|(
name|cs
operator|=
name|node
operator|->
name|callers
init|;
name|cs
operator|!=
name|NULL
condition|;
name|cs
operator|=
name|cs
operator|->
name|next_caller
control|)
name|sum
operator|+=
name|cs
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|count
operator|==
literal|0
condition|)
name|ipcp_method_set_scale
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ipcp_method_set_scale
argument_list|(
name|node
argument_list|,
name|sum
operator|*
name|REG_BR_PROB_BASE
operator|/
name|node
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialization and computation of IPCP data structures.     It is an intraprocedural    analysis of methods, which gathers information to be propagated    later on.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_init_stage
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|cs
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|ipa_method_formal_compute_count
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ipa_method_compute_tree_map
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ipcp_method_cval_init
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ipa_method_compute_modify
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ipcp_method_compute_scale
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
comment|/* building jump functions  */
for|for
control|(
name|cs
operator|=
name|node
operator|->
name|callees
init|;
name|cs
condition|;
name|cs
operator|=
name|cs
operator|->
name|next_callee
control|)
block|{
name|ipa_callsite_compute_count
argument_list|(
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipa_callsite_param_count
argument_list|(
name|cs
argument_list|)
operator|!=
name|ipa_method_formal_count
argument_list|(
name|cs
operator|->
name|callee
argument_list|)
condition|)
block|{
comment|/* Handle cases of functions with  	         a variable number of parameters.  */
name|ipa_callsite_param_count_set
argument_list|(
name|cs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ipa_method_formal_count_set
argument_list|(
name|cs
operator|->
name|callee
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|ipa_callsite_compute_param
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return true if there are some formal parameters whose value is TOP.    Change their values to BOTTOM, since they weren't determined.  */
end_comment

begin_function
specifier|static
name|bool
name|ipcp_after_propagate
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|bool
name|prop_again
decl_stmt|;
name|prop_again
operator|=
name|false
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|count
operator|=
name|ipa_method_formal_count
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ipcp_cval_get_cvalue_type
argument_list|(
name|ipcp_method_cval
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|TOP
condition|)
block|{
name|prop_again
operator|=
name|true
expr_stmt|;
name|ipcp_method_cval_set_cvalue_type
argument_list|(
name|node
argument_list|,
name|i
argument_list|,
name|BOTTOM
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|prop_again
return|;
block|}
end_function

begin_comment
comment|/* Interprocedural analysis. The algorithm propagates constants from    the caller's parameters to the callee's arguments.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_propagate_stage
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ipcp_formal
name|cval1
init|=
block|{
literal|0
block|,
block|{
literal|0
block|}
block|}
decl_stmt|,
name|cval
init|=
block|{
literal|0
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|struct
name|ipcp_formal
modifier|*
name|cval2
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|mt
decl_stmt|,
modifier|*
name|callee
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|cs
decl_stmt|;
name|struct
name|ipa_jump_func
modifier|*
name|jump_func
decl_stmt|;
name|enum
name|jump_func_type
name|type
decl_stmt|;
name|union
name|parameter_info
modifier|*
name|info_type
decl_stmt|;
name|ipa_methodlist_p
name|wl
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* Initialize worklist to contain all methods.  */
name|wl
operator|=
name|ipa_methodlist_init
argument_list|()
expr_stmt|;
while|while
condition|(
name|ipa_methodlist_not_empty
argument_list|(
name|wl
argument_list|)
condition|)
block|{
name|mt
operator|=
name|ipa_remove_method
argument_list|(
operator|&
name|wl
argument_list|)
expr_stmt|;
for|for
control|(
name|cs
operator|=
name|mt
operator|->
name|callees
init|;
name|cs
condition|;
name|cs
operator|=
name|cs
operator|->
name|next_callee
control|)
block|{
name|callee
operator|=
name|ipa_callsite_callee
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|count
operator|=
name|ipa_callsite_param_count
argument_list|(
name|cs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|jump_func
operator|=
name|ipa_callsite_param
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|type
operator|=
name|get_type
argument_list|(
name|jump_func
argument_list|)
expr_stmt|;
name|info_type
operator|=
name|ipa_jf_get_info_type
argument_list|(
name|jump_func
argument_list|)
expr_stmt|;
name|ipcp_cval_compute
argument_list|(
operator|&
name|cval1
argument_list|,
name|mt
argument_list|,
name|type
argument_list|,
name|info_type
argument_list|)
expr_stmt|;
name|cval2
operator|=
name|ipcp_method_cval
argument_list|(
name|callee
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ipcp_cval_meet
argument_list|(
operator|&
name|cval
argument_list|,
operator|&
name|cval1
argument_list|,
name|cval2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipcp_cval_changed
argument_list|(
operator|&
name|cval
argument_list|,
name|cval2
argument_list|)
condition|)
block|{
name|ipcp_method_cval_set
argument_list|(
name|callee
argument_list|,
name|i
argument_list|,
operator|&
name|cval
argument_list|)
expr_stmt|;
name|ipa_add_method
argument_list|(
operator|&
name|wl
argument_list|,
name|callee
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Call the constant propagation algorithm and re-call it if necessary    (if there are undetermined values left).  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_iterate_stage
parameter_list|(
name|void
parameter_list|)
block|{
name|ipcp_propagate_stage
argument_list|()
expr_stmt|;
if|if
condition|(
name|ipcp_after_propagate
argument_list|()
condition|)
comment|/* Some cvals have changed from TOP to BOTTOM.          This change should be propagated.  */
name|ipcp_propagate_stage
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check conditions to forbid constant insertion to MT.  */
end_comment

begin_function
specifier|static
name|bool
name|ipcp_method_dont_insert_const
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|)
block|{
comment|/* ??? Handle pending sizes case.  */
if|if
condition|(
name|DECL_UNINLINABLE
argument_list|(
name|mt
operator|->
name|decl
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Print ipa_jump_func data structures to F.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_callsite_param_print
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|cs
decl_stmt|;
name|struct
name|ipa_jump_func
modifier|*
name|jump_func
decl_stmt|;
name|enum
name|jump_func_type
name|type
decl_stmt|;
name|tree
name|info_type
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nCALLSITE PARAM PRINT\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
for|for
control|(
name|cs
operator|=
name|node
operator|->
name|callees
init|;
name|cs
condition|;
name|cs
operator|=
name|cs
operator|->
name|next_callee
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"callsite  %s "
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"-> %s :: \n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|cs
operator|->
name|callee
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|ipa_callsite_param_count
argument_list|(
name|cs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|jump_func
operator|=
name|ipa_callsite_param
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|type
operator|=
name|get_type
argument_list|(
name|jump_func
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" param %d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|UNKNOWN_IPATYPE
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"UNKNOWN\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|CONST_IPATYPE
operator|||
name|type
operator|==
name|CONST_IPATYPE_REF
condition|)
block|{
name|info_type
operator|=
name|ipa_jf_get_info_type
argument_list|(
name|jump_func
argument_list|)
operator|->
name|value
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"CONST : "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|info_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|FORMAL_IPATYPE
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"FORMAL : "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%d\n"
argument_list|,
name|ipa_jf_get_info_type
argument_list|(
name|jump_func
argument_list|)
operator|->
name|formal_id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print count scale data structures.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_method_scale_print
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"printing scale for %s: "
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"value is  "
name|HOST_WIDE_INT_PRINT_DEC
literal|"  \n"
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|ipcp_method_get_scale
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print counts of all cgraph nodes.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_profile_mt_count_print
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"method %s: "
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"count is  "
name|HOST_WIDE_INT_PRINT_DEC
literal|"  \n"
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|node
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print counts of all cgraph edges.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_profile_cs_count_print
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|cs
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
for|for
control|(
name|cs
operator|=
name|node
operator|->
name|callees
init|;
name|cs
condition|;
name|cs
operator|=
name|cs
operator|->
name|next_callee
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s -> %s "
argument_list|,
name|cgraph_node_name
argument_list|(
name|cs
operator|->
name|caller
argument_list|)
argument_list|,
name|cgraph_node_name
argument_list|(
name|cs
operator|->
name|callee
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"count is  "
name|HOST_WIDE_INT_PRINT_DEC
literal|"  \n"
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|cs
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print all counts and probabilities of cfg edges of all methods.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_profile_edge_print
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"method %s: \n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
block|{
name|bb
operator|=
name|ENTRY_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|node
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"ENTRY: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" "
name|HOST_WIDE_INT_PRINT_DEC
literal|" %d\n"
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|bb
operator|->
name|count
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|succs
condition|)
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|node
operator|->
name|decl
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"edge ENTRY -> EXIT,  Count"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"edge ENTRY -> %d,  Count"
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" "
name|HOST_WIDE_INT_PRINT_DEC
literal|" Prob %d\n"
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|e
operator|->
name|count
argument_list|,
name|e
operator|->
name|probability
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_BB_FN
argument_list|(
argument|bb
argument_list|,
argument|DECL_STRUCT_FUNCTION (node->decl)
argument_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"bb[%d]: "
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" "
name|HOST_WIDE_INT_PRINT_DEC
literal|" %d\n"
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|bb
operator|->
name|count
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|node
operator|->
name|decl
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"edge %d -> EXIT,  Count"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"edge %d -> %d,  Count"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" "
name|HOST_WIDE_INT_PRINT_DEC
literal|" Prob %d\n"
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|e
operator|->
name|count
argument_list|,
name|e
operator|->
name|probability
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print counts and frequencies for all basic blocks of all methods.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_profile_bb_print
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"method %s: \n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
block|{
name|bb
operator|=
name|ENTRY_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|node
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"ENTRY: Count"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" "
name|HOST_WIDE_INT_PRINT_DEC
literal|" Frquency  %d\n"
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|bb
operator|->
name|count
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|FOR_EACH_BB_FN
argument_list|(
argument|bb
argument_list|,
argument|DECL_STRUCT_FUNCTION (node->decl)
argument_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"bb[%d]: Count"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" "
name|HOST_WIDE_INT_PRINT_DEC
literal|" Frequency %d\n"
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|bb
operator|->
name|count
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
block|}
name|bb
operator|=
name|EXIT_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|node
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"EXIT: Count"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" "
name|HOST_WIDE_INT_PRINT_DEC
literal|" Frequency %d\n"
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|bb
operator|->
name|count
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print all IPCP data structures to F.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_structures_print
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|ipcp_method_cval_print
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ipcp_method_scale_print
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ipa_method_tree_print
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ipa_method_modify_print
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ipcp_callsite_param_print
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print profile info for all methods.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_profile_print
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nNODE COUNTS :\n"
argument_list|)
expr_stmt|;
name|ipcp_profile_mt_count_print
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nCS COUNTS stage:\n"
argument_list|)
expr_stmt|;
name|ipcp_profile_cs_count_print
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nBB COUNTS and FREQUENCIES :\n"
argument_list|)
expr_stmt|;
name|ipcp_profile_bb_print
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nCFG EDGES COUNTS and PROBABILITIES :\n"
argument_list|)
expr_stmt|;
name|ipcp_profile_edge_print
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build and initialize ipa_replace_map struct    according to TYPE. This struct is read by versioning, which    operates according to the flags sent.  PARM_TREE is the     formal's tree found to be constant.  CVALUE represents the constant.  */
end_comment

begin_function
specifier|static
name|struct
name|ipa_replace_map
modifier|*
name|ipcp_replace_map_create
parameter_list|(
name|enum
name|cvalue_type
name|type
parameter_list|,
name|tree
name|parm_tree
parameter_list|,
name|union
name|parameter_info
modifier|*
name|cvalue
parameter_list|)
block|{
name|struct
name|ipa_replace_map
modifier|*
name|replace_map
decl_stmt|;
name|tree
name|const_val
decl_stmt|;
name|replace_map
operator|=
name|XCNEW
argument_list|(
expr|struct
name|ipa_replace_map
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ipcp_type_is_const
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CONST_VALUE_REF
condition|)
block|{
name|const_val
operator|=
name|build_const_val
argument_list|(
name|cvalue
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm_tree
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replace_map
operator|->
name|old_tree
operator|=
name|parm_tree
expr_stmt|;
name|replace_map
operator|->
name|new_tree
operator|=
name|const_val
expr_stmt|;
name|replace_map
operator|->
name|replace_p
operator|=
name|true
expr_stmt|;
name|replace_map
operator|->
name|ref_p
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|parm_tree
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|parm_tree
argument_list|)
condition|)
block|{
name|const_val
operator|=
name|build_const_val
argument_list|(
name|cvalue
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm_tree
argument_list|)
argument_list|)
expr_stmt|;
name|replace_map
operator|->
name|old_tree
operator|=
name|parm_tree
expr_stmt|;
name|replace_map
operator|->
name|new_tree
operator|=
name|const_val
expr_stmt|;
name|replace_map
operator|->
name|replace_p
operator|=
name|true
expr_stmt|;
name|replace_map
operator|->
name|ref_p
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|replace_map
operator|->
name|old_tree
operator|=
name|NULL
expr_stmt|;
name|replace_map
operator|->
name|new_tree
operator|=
name|NULL
expr_stmt|;
name|replace_map
operator|->
name|replace_p
operator|=
name|false
expr_stmt|;
name|replace_map
operator|->
name|ref_p
operator|=
name|false
expr_stmt|;
block|}
return|return
name|replace_map
return|;
block|}
end_function

begin_comment
comment|/* Return true if this callsite should be redirected to    the orig callee (instead of the cloned one).  */
end_comment

begin_function
specifier|static
name|bool
name|ipcp_redirect
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|cs
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|caller
decl_stmt|,
modifier|*
name|callee
decl_stmt|,
modifier|*
name|orig_callee
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|struct
name|ipa_jump_func
modifier|*
name|jump_func
decl_stmt|;
name|enum
name|jump_func_type
name|type
decl_stmt|;
name|enum
name|cvalue_type
name|cval_type
decl_stmt|;
name|caller
operator|=
name|cs
operator|->
name|caller
expr_stmt|;
name|callee
operator|=
name|cs
operator|->
name|callee
expr_stmt|;
name|orig_callee
operator|=
name|ipcp_method_orig_node
argument_list|(
name|callee
argument_list|)
expr_stmt|;
name|count
operator|=
name|ipa_method_formal_count
argument_list|(
name|orig_callee
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|cval_type
operator|=
name|ipcp_cval_get_cvalue_type
argument_list|(
name|ipcp_method_cval
argument_list|(
name|orig_callee
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipcp_type_is_const
argument_list|(
name|cval_type
argument_list|)
condition|)
block|{
name|jump_func
operator|=
name|ipa_callsite_param
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|type
operator|=
name|get_type
argument_list|(
name|jump_func
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|CONST_IPATYPE
operator|&&
name|type
operator|!=
name|CONST_IPATYPE_REF
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Fix the callsites and the callgraph after function cloning was done.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_update_callgraph
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|,
modifier|*
name|orig_callee
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|cs
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
comment|/* want to fix only original nodes  */
if|if
condition|(
name|ipcp_method_is_cloned
argument_list|(
name|node
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|cs
operator|=
name|node
operator|->
name|callees
init|;
name|cs
condition|;
name|cs
operator|=
name|cs
operator|->
name|next_callee
control|)
if|if
condition|(
name|ipcp_method_is_cloned
argument_list|(
name|cs
operator|->
name|callee
argument_list|)
condition|)
block|{
comment|/* Callee is a cloned node  */
name|orig_callee
operator|=
name|ipcp_method_orig_node
argument_list|(
name|cs
operator|->
name|callee
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipcp_redirect
argument_list|(
name|cs
argument_list|)
condition|)
block|{
name|cgraph_redirect_edge_callee
argument_list|(
name|cs
argument_list|,
name|orig_callee
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|get_call_expr_in
argument_list|(
name|cs
operator|->
name|call_stmt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|orig_callee
operator|->
name|decl
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Update all cfg basic blocks in NODE according to SCALE.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_update_bb_counts
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|gcov_type
name|scale
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_ALL_BB_FN
argument_list|(
argument|bb
argument_list|,
argument|DECL_STRUCT_FUNCTION (node->decl)
argument_list|)
name|bb
operator|->
name|count
operator|=
name|bb
operator|->
name|count
operator|*
name|scale
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update all cfg edges in NODE according to SCALE.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_update_edges_counts
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|gcov_type
name|scale
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|FOR_ALL_BB_FN
argument_list|(
argument|bb
argument_list|,
argument|DECL_STRUCT_FUNCTION (node->decl)
argument_list|)
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|e
operator|->
name|count
operator|=
name|e
operator|->
name|count
operator|*
name|scale
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update profiling info for versioned methods and the    methods they were versioned from.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_update_profiling
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|,
modifier|*
name|orig_node
decl_stmt|;
name|gcov_type
name|scale
decl_stmt|,
name|scale_complement
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|cs
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ipcp_method_is_cloned
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|orig_node
operator|=
name|ipcp_method_orig_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|scale
operator|=
name|ipcp_method_get_scale
argument_list|(
name|orig_node
argument_list|)
expr_stmt|;
name|node
operator|->
name|count
operator|=
name|orig_node
operator|->
name|count
operator|*
name|scale
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
name|scale_complement
operator|=
name|REG_BR_PROB_BASE
operator|-
name|scale
expr_stmt|;
name|orig_node
operator|->
name|count
operator|=
name|orig_node
operator|->
name|count
operator|*
name|scale_complement
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
for|for
control|(
name|cs
operator|=
name|node
operator|->
name|callees
init|;
name|cs
condition|;
name|cs
operator|=
name|cs
operator|->
name|next_callee
control|)
name|cs
operator|->
name|count
operator|=
name|cs
operator|->
name|count
operator|*
name|scale
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
for|for
control|(
name|cs
operator|=
name|orig_node
operator|->
name|callees
init|;
name|cs
condition|;
name|cs
operator|=
name|cs
operator|->
name|next_callee
control|)
name|cs
operator|->
name|count
operator|=
name|cs
operator|->
name|count
operator|*
name|scale_complement
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
name|ipcp_update_bb_counts
argument_list|(
name|node
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|ipcp_update_bb_counts
argument_list|(
name|orig_node
argument_list|,
name|scale_complement
argument_list|)
expr_stmt|;
name|ipcp_update_edges_counts
argument_list|(
name|node
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|ipcp_update_edges_counts
argument_list|(
name|orig_node
argument_list|,
name|scale_complement
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Propagate the constant parameters found by ipcp_iterate_stage()    to the function's code.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_insert_stage
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|,
modifier|*
name|node1
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|const_param
decl_stmt|;
name|union
name|parameter_info
modifier|*
name|cvalue
decl_stmt|;
name|VEC
argument_list|(
name|cgraph_edge_p
argument_list|,
name|heap
argument_list|)
operator|*
name|redirect_callers
expr_stmt|;
name|varray_type
name|replace_trees
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|cs
decl_stmt|;
name|int
name|node_callers
decl_stmt|,
name|count
decl_stmt|;
name|tree
name|parm_tree
decl_stmt|;
name|enum
name|cvalue_type
name|type
decl_stmt|;
name|struct
name|ipa_replace_map
modifier|*
name|replace_param
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
comment|/* Propagation of the constant is forbidden in           certain conditions.  */
if|if
condition|(
name|ipcp_method_dont_insert_const
argument_list|(
name|node
argument_list|)
condition|)
continue|continue;
name|const_param
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|ipa_method_formal_count
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|type
operator|=
name|ipcp_cval_get_cvalue_type
argument_list|(
name|ipcp_method_cval
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipcp_type_is_const
argument_list|(
name|type
argument_list|)
condition|)
name|const_param
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|const_param
operator|==
literal|0
condition|)
continue|continue;
name|VARRAY_GENERIC_PTR_INIT
argument_list|(
name|replace_trees
argument_list|,
name|const_param
argument_list|,
literal|"replace_trees"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|type
operator|=
name|ipcp_cval_get_cvalue_type
argument_list|(
name|ipcp_method_cval
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipcp_type_is_const
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cvalue
operator|=
name|ipcp_cval_get_cvalue
argument_list|(
name|ipcp_method_cval
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|parm_tree
operator|=
name|ipa_method_get_tree
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|replace_param
operator|=
name|ipcp_replace_map_create
argument_list|(
name|type
argument_list|,
name|parm_tree
argument_list|,
name|cvalue
argument_list|)
expr_stmt|;
name|VARRAY_PUSH_GENERIC_PTR
argument_list|(
name|replace_trees
argument_list|,
name|replace_param
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Compute how many callers node has.  */
name|node_callers
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cs
operator|=
name|node
operator|->
name|callers
init|;
name|cs
operator|!=
name|NULL
condition|;
name|cs
operator|=
name|cs
operator|->
name|next_caller
control|)
name|node_callers
operator|++
expr_stmt|;
name|redirect_callers
operator|=
name|VEC_alloc
argument_list|(
name|cgraph_edge_p
argument_list|,
name|heap
argument_list|,
name|node_callers
argument_list|)
expr_stmt|;
for|for
control|(
name|cs
operator|=
name|node
operator|->
name|callers
init|;
name|cs
operator|!=
name|NULL
condition|;
name|cs
operator|=
name|cs
operator|->
name|next_caller
control|)
name|VEC_quick_push
argument_list|(
name|cgraph_edge_p
argument_list|,
name|redirect_callers
argument_list|,
name|cs
argument_list|)
expr_stmt|;
comment|/* Redirecting all the callers of the node to the          new versioned node.  */
name|node1
operator|=
name|cgraph_function_versioning
argument_list|(
name|node
argument_list|,
name|redirect_callers
argument_list|,
name|replace_trees
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|cgraph_edge_p
argument_list|,
name|heap
argument_list|,
name|redirect_callers
argument_list|)
expr_stmt|;
name|VARRAY_CLEAR
argument_list|(
name|replace_trees
argument_list|)
expr_stmt|;
if|if
condition|(
name|node1
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"versioned function %s\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|ipcp_cloned_create
argument_list|(
name|node
argument_list|,
name|node1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|type
operator|=
name|ipcp_cval_get_cvalue_type
argument_list|(
name|ipcp_method_cval
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipcp_type_is_const
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cvalue
operator|=
name|ipcp_cval_get_cvalue
argument_list|(
name|ipcp_method_cval
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|parm_tree
operator|=
name|ipa_method_get_tree
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|CONST_VALUE_REF
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|parm_tree
argument_list|)
condition|)
name|ipcp_propagate_const
argument_list|(
name|node1
argument_list|,
name|i
argument_list|,
name|cvalue
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ipcp_update_callgraph
argument_list|()
expr_stmt|;
name|ipcp_update_profiling
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The IPCP driver.  */
end_comment

begin_function
name|unsigned
name|int
name|ipcp_driver
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nIPA constant propagation start:\n"
argument_list|)
expr_stmt|;
name|ipa_nodes_create
argument_list|()
expr_stmt|;
name|ipa_edges_create
argument_list|()
expr_stmt|;
comment|/* 1. Call the init stage to initialize       the ipa_node and ipa_edge structures.  */
name|ipcp_init_stage
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nIPA structures before propagation:\n"
argument_list|)
expr_stmt|;
name|ipcp_structures_print
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
block|}
comment|/* 2. Do the interprocedural propagation.  */
name|ipcp_iterate_stage
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nIPA structures after propagation:\n"
argument_list|)
expr_stmt|;
name|ipcp_structures_print
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nProfiling info before insert stage:\n"
argument_list|)
expr_stmt|;
name|ipcp_profile_print
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
block|}
comment|/* 3. Insert the constants found to the functions.  */
name|ipcp_insert_stage
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nProfiling info after insert stage:\n"
argument_list|)
expr_stmt|;
name|ipcp_profile_print
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
block|}
comment|/* Free all IPCP structures.  */
name|ipa_free
argument_list|()
expr_stmt|;
name|ipa_nodes_free
argument_list|()
expr_stmt|;
name|ipa_edges_free
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nIPA constant propagation end\n"
argument_list|)
expr_stmt|;
name|cgraph_remove_unreachable_nodes
argument_list|(
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Gate for IPCP optimization.  */
end_comment

begin_function
specifier|static
name|bool
name|cgraph_gate_cp
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_ipa_cp
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_ipa_cp
init|=
block|{
literal|"cp"
block|,
comment|/* name */
name|cgraph_gate_cp
block|,
comment|/* gate */
name|ipcp_driver
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_IPA_CONSTANT_PROP
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
name|PROP_trees
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_cgraph
operator||
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

