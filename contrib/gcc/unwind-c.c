begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Supporting functions for C exception handling.    Copyright (C) 2002, 2003 Free Software Foundation, Inc.    Contributed by Aldy Hernandez<aldy@quesejoda.com>.    Shamelessly stolen from the Java front end.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"tsystem.h"
end_include

begin_include
include|#
directive|include
file|"unwind.h"
end_include

begin_include
include|#
directive|include
file|"unwind-pe.h"
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
name|_Unwind_Ptr
name|Start
decl_stmt|;
name|_Unwind_Ptr
name|LPStart
decl_stmt|;
name|_Unwind_Ptr
name|ttype_base
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|TType
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|action_table
decl_stmt|;
name|unsigned
name|char
name|ttype_encoding
decl_stmt|;
name|unsigned
name|char
name|call_site_encoding
decl_stmt|;
block|}
name|lsda_header_info
typedef|;
end_typedef

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|parse_lsda_header
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|lsda_header_info
modifier|*
name|info
parameter_list|)
block|{
name|_Unwind_Word
name|tmp
decl_stmt|;
name|unsigned
name|char
name|lpstart_encoding
decl_stmt|;
name|info
operator|->
name|Start
operator|=
operator|(
name|context
condition|?
name|_Unwind_GetRegionStart
argument_list|(
name|context
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Find @LPStart, the base to which landing pad offsets are relative.  */
name|lpstart_encoding
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|lpstart_encoding
operator|!=
name|DW_EH_PE_omit
condition|)
name|p
operator|=
name|read_encoded_value
argument_list|(
name|context
argument_list|,
name|lpstart_encoding
argument_list|,
name|p
argument_list|,
operator|&
name|info
operator|->
name|LPStart
argument_list|)
expr_stmt|;
else|else
name|info
operator|->
name|LPStart
operator|=
name|info
operator|->
name|Start
expr_stmt|;
comment|/* Find @TType, the base of the handler and exception spec type data.  */
name|info
operator|->
name|ttype_encoding
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|ttype_encoding
operator|!=
name|DW_EH_PE_omit
condition|)
block|{
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|info
operator|->
name|TType
operator|=
name|p
operator|+
name|tmp
expr_stmt|;
block|}
else|else
name|info
operator|->
name|TType
operator|=
literal|0
expr_stmt|;
comment|/* The encoding and length of the call-site table; the action table      immediately follows.  */
name|info
operator|->
name|call_site_encoding
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|info
operator|->
name|action_table
operator|=
name|p
operator|+
name|tmp
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__USING_SJLJ_EXCEPTIONS__
end_ifdef

begin_define
define|#
directive|define
name|PERSONALITY_FUNCTION
value|__gcc_personality_sj0
end_define

begin_define
define|#
directive|define
name|__builtin_eh_return_data_regno
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERSONALITY_FUNCTION
value|__gcc_personality_v0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|_Unwind_Reason_Code
name|PERSONALITY_FUNCTION
parameter_list|(
name|int
parameter_list|,
name|_Unwind_Action
parameter_list|,
name|_Unwind_Exception_Class
parameter_list|,
name|struct
name|_Unwind_Exception
modifier|*
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|_Unwind_Reason_Code
name|PERSONALITY_FUNCTION
parameter_list|(
name|int
name|version
parameter_list|,
name|_Unwind_Action
name|actions
parameter_list|,
name|_Unwind_Exception_Class
name|exception_class
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|_Unwind_Exception
modifier|*
name|ue_header
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
name|lsda_header_info
name|info
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|language_specific_data
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|action_record
decl_stmt|;
name|_Unwind_Ptr
name|landing_pad
decl_stmt|,
name|ip
decl_stmt|;
if|if
condition|(
name|version
operator|!=
literal|1
condition|)
return|return
name|_URC_FATAL_PHASE1_ERROR
return|;
comment|/* Currently we only support cleanups for C.  */
if|if
condition|(
operator|(
name|actions
operator|&
name|_UA_CLEANUP_PHASE
operator|)
operator|==
literal|0
condition|)
return|return
name|_URC_CONTINUE_UNWIND
return|;
name|language_specific_data
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_Unwind_GetLanguageSpecificData
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* If no LSDA, then there are no handlers or cleanups.  */
if|if
condition|(
operator|!
name|language_specific_data
condition|)
return|return
name|_URC_CONTINUE_UNWIND
return|;
comment|/* Parse the LSDA header.  */
name|p
operator|=
name|parse_lsda_header
argument_list|(
name|context
argument_list|,
name|language_specific_data
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|ip
operator|=
name|_Unwind_GetIP
argument_list|(
name|context
argument_list|)
operator|-
literal|1
expr_stmt|;
name|landing_pad
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|__USING_SJLJ_EXCEPTIONS__
comment|/* The given "IP" is an index into the call-site table, with two      exceptions -- -1 means no-action, and 0 means terminate.  But      since we're using uleb128 values, we've not got random access      to the array.  */
if|if
condition|(
operator|(
name|int
operator|)
name|ip
operator|<=
literal|0
condition|)
return|return
name|_URC_CONTINUE_UNWIND
return|;
else|else
block|{
name|_Unwind_Word
name|cs_lp
decl_stmt|,
name|cs_action
decl_stmt|;
do|do
block|{
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|cs_lp
argument_list|)
expr_stmt|;
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|cs_action
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ip
condition|)
do|;
comment|/* Can never have null landing pad for sjlj -- that would have 	 been indicated by a -1 call site index.  */
name|landing_pad
operator|=
name|cs_lp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cs_action
condition|)
name|action_record
operator|=
name|info
operator|.
name|action_table
operator|+
name|cs_action
operator|-
literal|1
expr_stmt|;
goto|goto
name|found_something
goto|;
block|}
else|#
directive|else
comment|/* Search the call-site table for the action associated with this IP.  */
while|while
condition|(
name|p
operator|<
name|info
operator|.
name|action_table
condition|)
block|{
name|_Unwind_Ptr
name|cs_start
decl_stmt|,
name|cs_len
decl_stmt|,
name|cs_lp
decl_stmt|;
name|_Unwind_Word
name|cs_action
decl_stmt|;
comment|/* Note that all call-site encodings are "absolute" displacements.  */
name|p
operator|=
name|read_encoded_value
argument_list|(
literal|0
argument_list|,
name|info
operator|.
name|call_site_encoding
argument_list|,
name|p
argument_list|,
operator|&
name|cs_start
argument_list|)
expr_stmt|;
name|p
operator|=
name|read_encoded_value
argument_list|(
literal|0
argument_list|,
name|info
operator|.
name|call_site_encoding
argument_list|,
name|p
argument_list|,
operator|&
name|cs_len
argument_list|)
expr_stmt|;
name|p
operator|=
name|read_encoded_value
argument_list|(
literal|0
argument_list|,
name|info
operator|.
name|call_site_encoding
argument_list|,
name|p
argument_list|,
operator|&
name|cs_lp
argument_list|)
expr_stmt|;
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|cs_action
argument_list|)
expr_stmt|;
comment|/* The table is sorted, so if we've passed the ip, stop.  */
if|if
condition|(
name|ip
operator|<
name|info
operator|.
name|Start
operator|+
name|cs_start
condition|)
name|p
operator|=
name|info
operator|.
name|action_table
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|<
name|info
operator|.
name|Start
operator|+
name|cs_start
operator|+
name|cs_len
condition|)
block|{
if|if
condition|(
name|cs_lp
condition|)
name|landing_pad
operator|=
name|info
operator|.
name|LPStart
operator|+
name|cs_lp
expr_stmt|;
if|if
condition|(
name|cs_action
condition|)
name|action_record
operator|=
name|info
operator|.
name|action_table
operator|+
name|cs_action
operator|-
literal|1
expr_stmt|;
goto|goto
name|found_something
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* IP is not in table.  No associated cleanups.  */
comment|/* ??? This is where C++ calls std::terminate to catch throw      from a destructor.  */
return|return
name|_URC_CONTINUE_UNWIND
return|;
name|found_something
label|:
if|if
condition|(
name|landing_pad
operator|==
literal|0
condition|)
block|{
comment|/* IP is present, but has a null landing pad. 	 No handler to be run.  */
return|return
name|_URC_CONTINUE_UNWIND
return|;
block|}
name|_Unwind_SetGR
argument_list|(
name|context
argument_list|,
name|__builtin_eh_return_data_regno
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|_Unwind_Ptr
operator|)
name|ue_header
argument_list|)
expr_stmt|;
name|_Unwind_SetGR
argument_list|(
name|context
argument_list|,
name|__builtin_eh_return_data_regno
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_Unwind_SetIP
argument_list|(
name|context
argument_list|,
name|landing_pad
argument_list|)
expr_stmt|;
return|return
name|_URC_INSTALL_CONTEXT
return|;
block|}
end_function

end_unit

