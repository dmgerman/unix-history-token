begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic partial redundancy elimination with lazy code motion support.    Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* These routines are meant to be used by various optimization    passes which can be modeled as lazy code motion problems.    Including, but not limited to:  	* Traditional partial redundancy elimination.  	* Placement of caller/caller register save/restores.  	* Load/store motion.  	* Copy motion.  	* Conversion of flat register files to a stacked register 	model.  	* Dead load/store elimination.    These routines accept as input:  	* Basic block information (number of blocks, lists of 	predecessors and successors).  Note the granularity 	does not need to be basic block, they could be statements 	or functions.  	* Bitmaps of local properties (computed, transparent and 	anticipatable expressions).    The output of these routines is bitmap of redundant computations   and a bitmap of optimal placement points.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_comment
comment|/* We want target macros for the mode switching code to be able to refer    to instruction attribute values.  */
end_comment

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_comment
comment|/* Edge based LCM routines.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|compute_antinout_edge
name|PARAMS
argument_list|(
operator|(
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_earliest
name|PARAMS
argument_list|(
operator|(
expr|struct
name|edge_list
operator|*
operator|,
name|int
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_laterin
name|PARAMS
argument_list|(
operator|(
expr|struct
name|edge_list
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_insert_delete
name|PARAMS
argument_list|(
operator|(
expr|struct
name|edge_list
operator|*
name|edge_list
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Edge based LCM routines on a reverse flowgraph.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|compute_farthest
name|PARAMS
argument_list|(
operator|(
expr|struct
name|edge_list
operator|*
operator|,
name|int
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_nearerout
name|PARAMS
argument_list|(
operator|(
expr|struct
name|edge_list
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_rev_insert_delete
name|PARAMS
argument_list|(
operator|(
expr|struct
name|edge_list
operator|*
name|edge_list
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Edge based lcm routines.  */
end_comment

begin_comment
comment|/* Compute expression anticipatability at entrance and exit of each block.    This is done based on the flow graph, and not on the pred-succ lists.    Other than that, its pretty much identical to compute_antinout.  */
end_comment

begin_function
specifier|static
name|void
name|compute_antinout_edge
parameter_list|(
name|antloc
parameter_list|,
name|transp
parameter_list|,
name|antin
parameter_list|,
name|antout
parameter_list|)
name|sbitmap
modifier|*
name|antloc
decl_stmt|;
name|sbitmap
modifier|*
name|transp
decl_stmt|;
name|sbitmap
modifier|*
name|antin
decl_stmt|;
name|sbitmap
modifier|*
name|antout
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|basic_block
modifier|*
name|worklist
decl_stmt|,
modifier|*
name|qin
decl_stmt|,
modifier|*
name|qout
decl_stmt|,
modifier|*
name|qend
decl_stmt|;
name|unsigned
name|int
name|qlen
decl_stmt|;
comment|/* Allocate a worklist array/queue.  Entries are only added to the      list if they were not already on the list.  So the size is      bounded by the number of basic blocks.  */
name|qin
operator|=
name|qout
operator|=
name|worklist
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* We want a maximal solution, so make an optimistic initialization of      ANTIN.  */
name|sbitmap_vector_ones
argument_list|(
name|antin
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Put every block on the worklist; this is necessary because of the      optimistic initialization of ANTIN above.  */
for|for
control|(
name|bb
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|bb
operator|>=
literal|0
condition|;
name|bb
operator|--
control|)
block|{
operator|*
name|qin
operator|++
operator|=
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
operator|->
name|aux
operator|=
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
name|qin
operator|=
name|worklist
expr_stmt|;
name|qend
operator|=
operator|&
name|worklist
index|[
name|n_basic_blocks
index|]
expr_stmt|;
name|qlen
operator|=
name|n_basic_blocks
expr_stmt|;
comment|/* Mark blocks which are predecessors of the exit block so that we      can easily identify them below.  */
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
name|e
operator|->
name|src
operator|->
name|aux
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
comment|/* Iterate until the worklist is empty.  */
while|while
condition|(
name|qlen
condition|)
block|{
comment|/* Take the first entry off the worklist.  */
name|basic_block
name|b
init|=
operator|*
name|qout
operator|++
decl_stmt|;
name|bb
operator|=
name|b
operator|->
name|index
expr_stmt|;
name|qlen
operator|--
expr_stmt|;
if|if
condition|(
name|qout
operator|>=
name|qend
condition|)
name|qout
operator|=
name|worklist
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|aux
operator|==
name|EXIT_BLOCK_PTR
condition|)
comment|/* Do not clear the aux field for blocks which are predecessors of 	   the EXIT block.  That way we never add then to the worklist 	   again.  */
name|sbitmap_zero
argument_list|(
name|antout
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Clear the aux field of this block so that it can be added to 	     the worklist again if necessary.  */
name|b
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|sbitmap_intersection_of_succs
argument_list|(
name|antout
index|[
name|bb
index|]
argument_list|,
name|antin
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbitmap_a_or_b_and_c
argument_list|(
name|antin
index|[
name|bb
index|]
argument_list|,
name|antloc
index|[
name|bb
index|]
argument_list|,
name|transp
index|[
name|bb
index|]
argument_list|,
name|antout
index|[
name|bb
index|]
argument_list|)
condition|)
comment|/* If the in state of this block changed, then we need 	   to add the predecessors of this block to the worklist 	   if they are not already on the worklist.  */
for|for
control|(
name|e
operator|=
name|b
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|src
operator|->
name|aux
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
block|{
operator|*
name|qin
operator|++
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|e
operator|->
name|src
operator|->
name|aux
operator|=
name|e
expr_stmt|;
name|qlen
operator|++
expr_stmt|;
if|if
condition|(
name|qin
operator|>=
name|qend
condition|)
name|qin
operator|=
name|worklist
expr_stmt|;
block|}
block|}
name|clear_aux_for_edges
argument_list|()
expr_stmt|;
name|clear_aux_for_blocks
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the earliest vector for edge based lcm.  */
end_comment

begin_function
specifier|static
name|void
name|compute_earliest
parameter_list|(
name|edge_list
parameter_list|,
name|n_exprs
parameter_list|,
name|antin
parameter_list|,
name|antout
parameter_list|,
name|avout
parameter_list|,
name|kill
parameter_list|,
name|earliest
parameter_list|)
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
name|int
name|n_exprs
decl_stmt|;
name|sbitmap
modifier|*
name|antin
decl_stmt|,
decl|*
name|antout
decl_stmt|,
modifier|*
name|avout
decl_stmt|,
modifier|*
name|kill
decl_stmt|,
modifier|*
name|earliest
decl_stmt|;
end_function

begin_block
block|{
name|sbitmap
name|difference
decl_stmt|,
name|temp_bitmap
decl_stmt|;
name|int
name|x
decl_stmt|,
name|num_edges
decl_stmt|;
name|basic_block
name|pred
decl_stmt|,
name|succ
decl_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
name|difference
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
name|temp_bitmap
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num_edges
condition|;
name|x
operator|++
control|)
block|{
name|pred
operator|=
name|INDEX_EDGE_PRED_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|succ
operator|=
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|sbitmap_copy
argument_list|(
name|earliest
index|[
name|x
index|]
argument_list|,
name|antin
index|[
name|succ
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We refer to the EXIT_BLOCK index, instead of testing for 	     EXIT_BLOCK_PTR, so that EXIT_BLOCK_PTR's index can be 	     changed so as to pretend it's a regular block, so that 	     its antin can be taken into account.  */
if|if
condition|(
name|succ
operator|->
name|index
operator|==
name|EXIT_BLOCK
condition|)
name|sbitmap_zero
argument_list|(
name|earliest
index|[
name|x
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|sbitmap_difference
argument_list|(
name|difference
argument_list|,
name|antin
index|[
name|succ
operator|->
name|index
index|]
argument_list|,
name|avout
index|[
name|pred
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|sbitmap_not
argument_list|(
name|temp_bitmap
argument_list|,
name|antout
index|[
name|pred
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|sbitmap_a_and_b_or_c
argument_list|(
name|earliest
index|[
name|x
index|]
argument_list|,
name|difference
argument_list|,
name|kill
index|[
name|pred
operator|->
name|index
index|]
argument_list|,
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sbitmap_free
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|difference
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* later(p,s) is dependent on the calculation of laterin(p).    laterin(p) is dependent on the calculation of later(p2,p).       laterin(ENTRY) is defined as all 0's      later(ENTRY, succs(ENTRY)) are defined using laterin(ENTRY)      laterin(succs(ENTRY)) is defined by later(ENTRY, succs(ENTRY)).     If we progress in this manner, starting with all basic blocks    in the work list, anytime we change later(bb), we need to add    succs(bb) to the worklist if they are not already on the worklist.     Boundary conditions:       We prime the worklist all the normal basic blocks.   The ENTRY block can      never be added to the worklist since it is never the successor of any      block.  We explicitly prevent the EXIT block from being added to the      worklist.       We optimistically initialize LATER.  That is the only time this routine      will compute LATER for an edge out of the entry block since the entry      block is never on the worklist.  Thus, LATERIN is neither used nor      computed for the ENTRY block.       Since the EXIT block is never added to the worklist, we will neither      use nor compute LATERIN for the exit block.  Edges which reach the      EXIT block are handled in the normal fashion inside the loop.  However,      the insertion/deletion computation needs LATERIN(EXIT), so we have      to compute it.  */
end_comment

begin_function
specifier|static
name|void
name|compute_laterin
parameter_list|(
name|edge_list
parameter_list|,
name|earliest
parameter_list|,
name|antloc
parameter_list|,
name|later
parameter_list|,
name|laterin
parameter_list|)
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
name|sbitmap
modifier|*
name|earliest
decl_stmt|,
decl|*
name|antloc
decl_stmt|,
modifier|*
name|later
decl_stmt|,
modifier|*
name|laterin
decl_stmt|;
end_function

begin_block
block|{
name|int
name|bb
decl_stmt|,
name|num_edges
decl_stmt|,
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|basic_block
modifier|*
name|worklist
decl_stmt|,
modifier|*
name|qin
decl_stmt|,
modifier|*
name|qout
decl_stmt|,
modifier|*
name|qend
decl_stmt|;
name|unsigned
name|int
name|qlen
decl_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
comment|/* Allocate a worklist array/queue.  Entries are only added to the      list if they were not already on the list.  So the size is      bounded by the number of basic blocks.  */
name|qin
operator|=
name|qout
operator|=
name|worklist
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
operator|(
name|n_basic_blocks
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Initialize a mapping from each edge to its index.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
name|INDEX_EDGE
argument_list|(
name|edge_list
argument_list|,
name|i
argument_list|)
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|size_t
operator|)
name|i
expr_stmt|;
comment|/* We want a maximal solution, so initially consider LATER true for      all edges.  This allows propagation through a loop since the incoming      loop edge will have LATER set, so if all the other incoming edges      to the loop are set, then LATERIN will be set for the head of the      loop.       If the optimistic setting of LATER on that edge was incorrect (for      example the expression is ANTLOC in a block within the loop) then      this algorithm will detect it when we process the block at the head      of the optimistic edge.  That will requeue the affected blocks.  */
name|sbitmap_vector_ones
argument_list|(
name|later
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
comment|/* Note that even though we want an optimistic setting of LATER, we      do not want to be overly optimistic.  Consider an outgoing edge from      the entry block.  That edge should always have a LATER value the      same as EARLIEST for that edge.  */
for|for
control|(
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|sbitmap_copy
argument_list|(
name|later
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|,
name|earliest
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|)
expr_stmt|;
comment|/* Add all the blocks to the worklist.  This prevents an early exit from      the loop given our optimistic initialization of LATER above.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
decl_stmt|;
operator|*
name|qin
operator|++
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|aux
operator|=
name|b
expr_stmt|;
block|}
name|qin
operator|=
name|worklist
expr_stmt|;
comment|/* Note that we do not use the last allocated element for our queue,      as EXIT_BLOCK is never inserted into it. In fact the above allocation      of n_basic_blocks + 1 elements is not encessary.  */
name|qend
operator|=
operator|&
name|worklist
index|[
name|n_basic_blocks
index|]
expr_stmt|;
name|qlen
operator|=
name|n_basic_blocks
expr_stmt|;
comment|/* Iterate until the worklist is empty.  */
while|while
condition|(
name|qlen
condition|)
block|{
comment|/* Take the first entry off the worklist.  */
name|basic_block
name|b
init|=
operator|*
name|qout
operator|++
decl_stmt|;
name|b
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|qlen
operator|--
expr_stmt|;
if|if
condition|(
name|qout
operator|>=
name|qend
condition|)
name|qout
operator|=
name|worklist
expr_stmt|;
comment|/* Compute the intersection of LATERIN for each incoming edge to B.  */
name|bb
operator|=
name|b
operator|->
name|index
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|laterin
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|pred
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
name|sbitmap_a_and_b
argument_list|(
name|laterin
index|[
name|bb
index|]
argument_list|,
name|laterin
index|[
name|bb
index|]
argument_list|,
name|later
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|)
expr_stmt|;
comment|/* Calculate LATER for all outgoing edges.  */
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|sbitmap_union_of_diff
argument_list|(
name|later
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|,
name|earliest
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|,
name|laterin
index|[
name|e
operator|->
name|src
operator|->
name|index
index|]
argument_list|,
name|antloc
index|[
name|e
operator|->
name|src
operator|->
name|index
index|]
argument_list|)
comment|/* If LATER for an outgoing edge was changed, then we need 	       to add the target of the outgoing edge to the worklist.  */
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|->
name|aux
operator|==
literal|0
condition|)
block|{
operator|*
name|qin
operator|++
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|e
operator|->
name|dest
operator|->
name|aux
operator|=
name|e
expr_stmt|;
name|qlen
operator|++
expr_stmt|;
if|if
condition|(
name|qin
operator|>=
name|qend
condition|)
name|qin
operator|=
name|worklist
expr_stmt|;
block|}
block|}
comment|/* Computation of insertion and deletion points requires computing LATERIN      for the EXIT block.  We allocated an extra entry in the LATERIN array      for just this purpose.  */
name|sbitmap_ones
argument_list|(
name|laterin
index|[
name|n_basic_blocks
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
name|sbitmap_a_and_b
argument_list|(
name|laterin
index|[
name|n_basic_blocks
index|]
argument_list|,
name|laterin
index|[
name|n_basic_blocks
index|]
argument_list|,
name|later
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|)
expr_stmt|;
name|clear_aux_for_edges
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Compute the insertion and deletion points for edge based LCM.  */
end_comment

begin_function
specifier|static
name|void
name|compute_insert_delete
parameter_list|(
name|edge_list
parameter_list|,
name|antloc
parameter_list|,
name|later
parameter_list|,
name|laterin
parameter_list|,
name|insert
parameter_list|,
name|delete
parameter_list|)
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
name|sbitmap
modifier|*
name|antloc
decl_stmt|,
decl|*
name|later
decl_stmt|,
modifier|*
name|laterin
decl_stmt|,
modifier|*
name|insert
decl_stmt|,
modifier|*
name|delete
decl_stmt|;
end_function

begin_block
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|n_basic_blocks
condition|;
name|x
operator|++
control|)
name|sbitmap_difference
argument_list|(
name|delete
index|[
name|x
index|]
argument_list|,
name|antloc
index|[
name|x
index|]
argument_list|,
name|laterin
index|[
name|x
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
name|basic_block
name|b
init|=
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|sbitmap_difference
argument_list|(
name|insert
index|[
name|x
index|]
argument_list|,
name|later
index|[
name|x
index|]
argument_list|,
name|laterin
index|[
name|n_basic_blocks
index|]
argument_list|)
expr_stmt|;
else|else
name|sbitmap_difference
argument_list|(
name|insert
index|[
name|x
index|]
argument_list|,
name|later
index|[
name|x
index|]
argument_list|,
name|laterin
index|[
name|b
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Given local properties TRANSP, ANTLOC, AVOUT, KILL return the insert and    delete vectors for edge based LCM.  Returns an edgelist which is used to    map the insert vector to what edge an expression should be inserted on.  */
end_comment

begin_function
name|struct
name|edge_list
modifier|*
name|pre_edge_lcm
parameter_list|(
name|file
parameter_list|,
name|n_exprs
parameter_list|,
name|transp
parameter_list|,
name|avloc
parameter_list|,
name|antloc
parameter_list|,
name|kill
parameter_list|,
name|insert
parameter_list|,
name|delete
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|n_exprs
decl_stmt|;
name|sbitmap
modifier|*
name|transp
decl_stmt|;
name|sbitmap
modifier|*
name|avloc
decl_stmt|;
name|sbitmap
modifier|*
name|antloc
decl_stmt|;
name|sbitmap
modifier|*
name|kill
decl_stmt|;
name|sbitmap
modifier|*
modifier|*
name|insert
decl_stmt|;
name|sbitmap
modifier|*
modifier|*
name|delete
decl_stmt|;
block|{
name|sbitmap
modifier|*
name|antin
decl_stmt|,
modifier|*
name|antout
decl_stmt|,
modifier|*
name|earliest
decl_stmt|;
name|sbitmap
modifier|*
name|avin
decl_stmt|,
modifier|*
name|avout
decl_stmt|;
name|sbitmap
modifier|*
name|later
decl_stmt|,
modifier|*
name|laterin
decl_stmt|;
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
name|int
name|num_edges
decl_stmt|;
name|edge_list
operator|=
name|create_edge_list
argument_list|()
expr_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Edge List:\n"
argument_list|)
expr_stmt|;
name|verify_edge_list
argument_list|(
name|file
argument_list|,
name|edge_list
argument_list|)
expr_stmt|;
name|print_edge_list
argument_list|(
name|file
argument_list|,
name|edge_list
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"transp"
argument_list|,
literal|""
argument_list|,
name|transp
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"antloc"
argument_list|,
literal|""
argument_list|,
name|antloc
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"avloc"
argument_list|,
literal|""
argument_list|,
name|avloc
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"kill"
argument_list|,
literal|""
argument_list|,
name|kill
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Compute global availability.  */
name|avin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|avout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_available
argument_list|(
name|avloc
argument_list|,
name|kill
argument_list|,
name|avout
argument_list|,
name|avin
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|avin
argument_list|)
expr_stmt|;
comment|/* Compute global anticipatability.  */
name|antin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|antout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_antinout_edge
argument_list|(
name|antloc
argument_list|,
name|transp
argument_list|,
name|antin
argument_list|,
name|antout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|file
condition|)
block|{
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"antin"
argument_list|,
literal|""
argument_list|,
name|antin
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"antout"
argument_list|,
literal|""
argument_list|,
name|antout
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Compute earliestness.  */
name|earliest
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|num_edges
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_earliest
argument_list|(
name|edge_list
argument_list|,
name|n_exprs
argument_list|,
name|antin
argument_list|,
name|antout
argument_list|,
name|avout
argument_list|,
name|kill
argument_list|,
name|earliest
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|file
condition|)
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"earliest"
argument_list|,
literal|""
argument_list|,
name|earliest
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sbitmap_vector_free
argument_list|(
name|antout
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|antin
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|avout
argument_list|)
expr_stmt|;
name|later
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|num_edges
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
comment|/* Allocate an extra element for the exit block in the laterin vector.  */
name|laterin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
operator|+
literal|1
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_laterin
argument_list|(
name|edge_list
argument_list|,
name|earliest
argument_list|,
name|antloc
argument_list|,
name|later
argument_list|,
name|laterin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|file
condition|)
block|{
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"laterin"
argument_list|,
literal|""
argument_list|,
name|laterin
argument_list|,
name|n_basic_blocks
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"later"
argument_list|,
literal|""
argument_list|,
name|later
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sbitmap_vector_free
argument_list|(
name|earliest
argument_list|)
expr_stmt|;
operator|*
name|insert
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|num_edges
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
operator|*
name|delete
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_insert_delete
argument_list|(
name|edge_list
argument_list|,
name|antloc
argument_list|,
name|later
argument_list|,
name|laterin
argument_list|,
operator|*
name|insert
argument_list|,
operator|*
name|delete
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|laterin
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|later
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|file
condition|)
block|{
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"pre_insert_map"
argument_list|,
literal|""
argument_list|,
operator|*
name|insert
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"pre_delete_map"
argument_list|,
literal|""
argument_list|,
operator|*
name|delete
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|edge_list
return|;
block|}
end_function

begin_comment
comment|/* Compute the AVIN and AVOUT vectors from the AVLOC and KILL vectors.    Return the number of passes we performed to iterate to a solution.  */
end_comment

begin_function
name|void
name|compute_available
parameter_list|(
name|avloc
parameter_list|,
name|kill
parameter_list|,
name|avout
parameter_list|,
name|avin
parameter_list|)
name|sbitmap
modifier|*
name|avloc
decl_stmt|,
decl|*
name|kill
decl_stmt|,
modifier|*
name|avout
decl_stmt|,
modifier|*
name|avin
decl_stmt|;
end_function

begin_block
block|{
name|int
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|basic_block
modifier|*
name|worklist
decl_stmt|,
modifier|*
name|qin
decl_stmt|,
modifier|*
name|qout
decl_stmt|,
modifier|*
name|qend
decl_stmt|;
name|unsigned
name|int
name|qlen
decl_stmt|;
comment|/* Allocate a worklist array/queue.  Entries are only added to the      list if they were not already on the list.  So the size is      bounded by the number of basic blocks.  */
name|qin
operator|=
name|qout
operator|=
name|worklist
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* We want a maximal solution.  */
name|sbitmap_vector_ones
argument_list|(
name|avout
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Put every block on the worklist; this is necessary because of the      optimistic initialization of AVOUT above.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
operator|*
name|qin
operator|++
operator|=
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
operator|->
name|aux
operator|=
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
name|qin
operator|=
name|worklist
expr_stmt|;
name|qend
operator|=
operator|&
name|worklist
index|[
name|n_basic_blocks
index|]
expr_stmt|;
name|qlen
operator|=
name|n_basic_blocks
expr_stmt|;
comment|/* Mark blocks which are successors of the entry block so that we      can easily identify them below.  */
for|for
control|(
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|dest
operator|->
name|aux
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
comment|/* Iterate until the worklist is empty.  */
while|while
condition|(
name|qlen
condition|)
block|{
comment|/* Take the first entry off the worklist.  */
name|basic_block
name|b
init|=
operator|*
name|qout
operator|++
decl_stmt|;
name|bb
operator|=
name|b
operator|->
name|index
expr_stmt|;
name|qlen
operator|--
expr_stmt|;
if|if
condition|(
name|qout
operator|>=
name|qend
condition|)
name|qout
operator|=
name|worklist
expr_stmt|;
comment|/* If one of the predecessor blocks is the ENTRY block, then the 	 intersection of avouts is the null set.  We can identify such blocks 	 by the special value in the AUX field in the block structure.  */
if|if
condition|(
name|b
operator|->
name|aux
operator|==
name|ENTRY_BLOCK_PTR
condition|)
comment|/* Do not clear the aux field for blocks which are successors of the 	   ENTRY block.  That way we never add then to the worklist again.  */
name|sbitmap_zero
argument_list|(
name|avin
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Clear the aux field of this block so that it can be added to 	     the worklist again if necessary.  */
name|b
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|sbitmap_intersection_of_preds
argument_list|(
name|avin
index|[
name|bb
index|]
argument_list|,
name|avout
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbitmap_union_of_diff
argument_list|(
name|avout
index|[
name|bb
index|]
argument_list|,
name|avloc
index|[
name|bb
index|]
argument_list|,
name|avin
index|[
name|bb
index|]
argument_list|,
name|kill
index|[
name|bb
index|]
argument_list|)
condition|)
comment|/* If the out state of this block changed, then we need 	   to add the successors of this block to the worklist 	   if they are not already on the worklist.  */
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|dest
operator|->
name|aux
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
operator|*
name|qin
operator|++
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|e
operator|->
name|dest
operator|->
name|aux
operator|=
name|e
expr_stmt|;
name|qlen
operator|++
expr_stmt|;
if|if
condition|(
name|qin
operator|>=
name|qend
condition|)
name|qin
operator|=
name|worklist
expr_stmt|;
block|}
block|}
name|clear_aux_for_edges
argument_list|()
expr_stmt|;
name|clear_aux_for_blocks
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Compute the farthest vector for edge based lcm.  */
end_comment

begin_function
specifier|static
name|void
name|compute_farthest
parameter_list|(
name|edge_list
parameter_list|,
name|n_exprs
parameter_list|,
name|st_avout
parameter_list|,
name|st_avin
parameter_list|,
name|st_antin
parameter_list|,
name|kill
parameter_list|,
name|farthest
parameter_list|)
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
name|int
name|n_exprs
decl_stmt|;
name|sbitmap
modifier|*
name|st_avout
decl_stmt|,
decl|*
name|st_avin
decl_stmt|,
modifier|*
name|st_antin
decl_stmt|,
modifier|*
name|kill
decl_stmt|,
modifier|*
name|farthest
decl_stmt|;
end_function

begin_block
block|{
name|sbitmap
name|difference
decl_stmt|,
name|temp_bitmap
decl_stmt|;
name|int
name|x
decl_stmt|,
name|num_edges
decl_stmt|;
name|basic_block
name|pred
decl_stmt|,
name|succ
decl_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
name|difference
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
name|temp_bitmap
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num_edges
condition|;
name|x
operator|++
control|)
block|{
name|pred
operator|=
name|INDEX_EDGE_PRED_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|succ
operator|=
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|succ
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|sbitmap_copy
argument_list|(
name|farthest
index|[
name|x
index|]
argument_list|,
name|st_avout
index|[
name|pred
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pred
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|sbitmap_zero
argument_list|(
name|farthest
index|[
name|x
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|sbitmap_difference
argument_list|(
name|difference
argument_list|,
name|st_avout
index|[
name|pred
operator|->
name|index
index|]
argument_list|,
name|st_antin
index|[
name|succ
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|sbitmap_not
argument_list|(
name|temp_bitmap
argument_list|,
name|st_avin
index|[
name|succ
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|sbitmap_a_and_b_or_c
argument_list|(
name|farthest
index|[
name|x
index|]
argument_list|,
name|difference
argument_list|,
name|kill
index|[
name|succ
operator|->
name|index
index|]
argument_list|,
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sbitmap_free
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|difference
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Compute nearer and nearerout vectors for edge based lcm.     This is the mirror of compute_laterin, additional comments on the    implementation can be found before compute_laterin.  */
end_comment

begin_function
specifier|static
name|void
name|compute_nearerout
parameter_list|(
name|edge_list
parameter_list|,
name|farthest
parameter_list|,
name|st_avloc
parameter_list|,
name|nearer
parameter_list|,
name|nearerout
parameter_list|)
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
name|sbitmap
modifier|*
name|farthest
decl_stmt|,
decl|*
name|st_avloc
decl_stmt|,
modifier|*
name|nearer
decl_stmt|,
modifier|*
name|nearerout
decl_stmt|;
end_function

begin_block
block|{
name|int
name|bb
decl_stmt|,
name|num_edges
decl_stmt|,
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|basic_block
modifier|*
name|worklist
decl_stmt|,
modifier|*
name|tos
decl_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
comment|/* Allocate a worklist array/queue.  Entries are only added to the      list if they were not already on the list.  So the size is      bounded by the number of basic blocks.  */
name|tos
operator|=
name|worklist
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
operator|(
name|n_basic_blocks
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Initialize NEARER for each edge and build a mapping from an edge to      its index.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
name|INDEX_EDGE
argument_list|(
name|edge_list
argument_list|,
name|i
argument_list|)
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|size_t
operator|)
name|i
expr_stmt|;
comment|/* We want a maximal solution.  */
name|sbitmap_vector_ones
argument_list|(
name|nearer
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
comment|/* Note that even though we want an optimistic setting of NEARER, we      do not want to be overly optimistic.  Consider an incoming edge to      the exit block.  That edge should always have a NEARER value the      same as FARTHEST for that edge.  */
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
name|sbitmap_copy
argument_list|(
name|nearer
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|,
name|farthest
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|)
expr_stmt|;
comment|/* Add all the blocks to the worklist.  This prevents an early exit      from the loop given our optimistic initialization of NEARER.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
decl_stmt|;
operator|*
name|tos
operator|++
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|aux
operator|=
name|b
expr_stmt|;
block|}
comment|/* Iterate until the worklist is empty.  */
while|while
condition|(
name|tos
operator|!=
name|worklist
condition|)
block|{
comment|/* Take the first entry off the worklist.  */
name|basic_block
name|b
init|=
operator|*
operator|--
name|tos
decl_stmt|;
name|b
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
comment|/* Compute the intersection of NEARER for each outgoing edge from B.  */
name|bb
operator|=
name|b
operator|->
name|index
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|nearerout
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|sbitmap_a_and_b
argument_list|(
name|nearerout
index|[
name|bb
index|]
argument_list|,
name|nearerout
index|[
name|bb
index|]
argument_list|,
name|nearer
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|)
expr_stmt|;
comment|/* Calculate NEARER for all incoming edges.  */
for|for
control|(
name|e
operator|=
name|b
operator|->
name|pred
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|sbitmap_union_of_diff
argument_list|(
name|nearer
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|,
name|farthest
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|,
name|nearerout
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
argument_list|,
name|st_avloc
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
argument_list|)
comment|/* If NEARER for an incoming edge was changed, then we need 	       to add the source of the incoming edge to the worklist.  */
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|e
operator|->
name|src
operator|->
name|aux
operator|==
literal|0
condition|)
block|{
operator|*
name|tos
operator|++
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|e
operator|->
name|src
operator|->
name|aux
operator|=
name|e
expr_stmt|;
block|}
block|}
comment|/* Computation of insertion and deletion points requires computing NEAREROUT      for the ENTRY block.  We allocated an extra entry in the NEAREROUT array      for just this purpose.  */
name|sbitmap_ones
argument_list|(
name|nearerout
index|[
name|n_basic_blocks
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|sbitmap_a_and_b
argument_list|(
name|nearerout
index|[
name|n_basic_blocks
index|]
argument_list|,
name|nearerout
index|[
name|n_basic_blocks
index|]
argument_list|,
name|nearer
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|)
expr_stmt|;
name|clear_aux_for_edges
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|tos
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Compute the insertion and deletion points for edge based LCM.  */
end_comment

begin_function
specifier|static
name|void
name|compute_rev_insert_delete
parameter_list|(
name|edge_list
parameter_list|,
name|st_avloc
parameter_list|,
name|nearer
parameter_list|,
name|nearerout
parameter_list|,
name|insert
parameter_list|,
name|delete
parameter_list|)
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
name|sbitmap
modifier|*
name|st_avloc
decl_stmt|,
decl|*
name|nearer
decl_stmt|,
modifier|*
name|nearerout
decl_stmt|,
modifier|*
name|insert
decl_stmt|,
modifier|*
name|delete
decl_stmt|;
end_function

begin_block
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|n_basic_blocks
condition|;
name|x
operator|++
control|)
name|sbitmap_difference
argument_list|(
name|delete
index|[
name|x
index|]
argument_list|,
name|st_avloc
index|[
name|x
index|]
argument_list|,
name|nearerout
index|[
name|x
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
name|basic_block
name|b
init|=
name|INDEX_EDGE_PRED_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|sbitmap_difference
argument_list|(
name|insert
index|[
name|x
index|]
argument_list|,
name|nearer
index|[
name|x
index|]
argument_list|,
name|nearerout
index|[
name|n_basic_blocks
index|]
argument_list|)
expr_stmt|;
else|else
name|sbitmap_difference
argument_list|(
name|insert
index|[
name|x
index|]
argument_list|,
name|nearer
index|[
name|x
index|]
argument_list|,
name|nearerout
index|[
name|b
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Given local properties TRANSP, ST_AVLOC, ST_ANTLOC, KILL return the    insert and delete vectors for edge based reverse LCM.  Returns an    edgelist which is used to map the insert vector to what edge    an expression should be inserted on.  */
end_comment

begin_function
name|struct
name|edge_list
modifier|*
name|pre_edge_rev_lcm
parameter_list|(
name|file
parameter_list|,
name|n_exprs
parameter_list|,
name|transp
parameter_list|,
name|st_avloc
parameter_list|,
name|st_antloc
parameter_list|,
name|kill
parameter_list|,
name|insert
parameter_list|,
name|delete
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|n_exprs
decl_stmt|;
name|sbitmap
modifier|*
name|transp
decl_stmt|;
name|sbitmap
modifier|*
name|st_avloc
decl_stmt|;
name|sbitmap
modifier|*
name|st_antloc
decl_stmt|;
name|sbitmap
modifier|*
name|kill
decl_stmt|;
name|sbitmap
modifier|*
modifier|*
name|insert
decl_stmt|;
name|sbitmap
modifier|*
modifier|*
name|delete
decl_stmt|;
block|{
name|sbitmap
modifier|*
name|st_antin
decl_stmt|,
modifier|*
name|st_antout
decl_stmt|;
name|sbitmap
modifier|*
name|st_avout
decl_stmt|,
modifier|*
name|st_avin
decl_stmt|,
modifier|*
name|farthest
decl_stmt|;
name|sbitmap
modifier|*
name|nearer
decl_stmt|,
modifier|*
name|nearerout
decl_stmt|;
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
name|int
name|num_edges
decl_stmt|;
name|edge_list
operator|=
name|create_edge_list
argument_list|()
expr_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
name|st_antin
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|st_antout
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|st_antin
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|st_antout
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|compute_antinout_edge
argument_list|(
name|st_antloc
argument_list|,
name|transp
argument_list|,
name|st_antin
argument_list|,
name|st_antout
argument_list|)
expr_stmt|;
comment|/* Compute global anticipatability.  */
name|st_avout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|st_avin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_available
argument_list|(
name|st_avloc
argument_list|,
name|kill
argument_list|,
name|st_avout
argument_list|,
name|st_avin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Edge List:\n"
argument_list|)
expr_stmt|;
name|verify_edge_list
argument_list|(
name|file
argument_list|,
name|edge_list
argument_list|)
expr_stmt|;
name|print_edge_list
argument_list|(
name|file
argument_list|,
name|edge_list
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"transp"
argument_list|,
literal|""
argument_list|,
name|transp
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"st_avloc"
argument_list|,
literal|""
argument_list|,
name|st_avloc
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"st_antloc"
argument_list|,
literal|""
argument_list|,
name|st_antloc
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"st_antin"
argument_list|,
literal|""
argument_list|,
name|st_antin
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"st_antout"
argument_list|,
literal|""
argument_list|,
name|st_antout
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"st_kill"
argument_list|,
literal|""
argument_list|,
name|kill
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|file
condition|)
block|{
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"st_avout"
argument_list|,
literal|""
argument_list|,
name|st_avout
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"st_avin"
argument_list|,
literal|""
argument_list|,
name|st_avin
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Compute farthestness.  */
name|farthest
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|num_edges
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_farthest
argument_list|(
name|edge_list
argument_list|,
name|n_exprs
argument_list|,
name|st_avout
argument_list|,
name|st_avin
argument_list|,
name|st_antin
argument_list|,
name|kill
argument_list|,
name|farthest
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|file
condition|)
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"farthest"
argument_list|,
literal|""
argument_list|,
name|farthest
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sbitmap_vector_free
argument_list|(
name|st_antin
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|st_antout
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|st_avin
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|st_avout
argument_list|)
expr_stmt|;
name|nearer
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|num_edges
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
comment|/* Allocate an extra element for the entry block.  */
name|nearerout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
operator|+
literal|1
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_nearerout
argument_list|(
name|edge_list
argument_list|,
name|farthest
argument_list|,
name|st_avloc
argument_list|,
name|nearer
argument_list|,
name|nearerout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|file
condition|)
block|{
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"nearerout"
argument_list|,
literal|""
argument_list|,
name|nearerout
argument_list|,
name|n_basic_blocks
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"nearer"
argument_list|,
literal|""
argument_list|,
name|nearer
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sbitmap_vector_free
argument_list|(
name|farthest
argument_list|)
expr_stmt|;
operator|*
name|insert
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|num_edges
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
operator|*
name|delete
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_rev_insert_delete
argument_list|(
name|edge_list
argument_list|,
name|st_avloc
argument_list|,
name|nearer
argument_list|,
name|nearerout
argument_list|,
operator|*
name|insert
argument_list|,
operator|*
name|delete
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|nearerout
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|nearer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|file
condition|)
block|{
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"pre_insert_map"
argument_list|,
literal|""
argument_list|,
operator|*
name|insert
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|file
argument_list|,
literal|"pre_delete_map"
argument_list|,
literal|""
argument_list|,
operator|*
name|delete
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|edge_list
return|;
block|}
end_function

begin_comment
comment|/* Mode switching:     The algorithm for setting the modes consists of scanning the insn list    and finding all the insns which require a specific mode.  Each insn gets    a unique struct seginfo element.  These structures are inserted into a list    for each basic block.  For each entity, there is an array of bb_info over    the flow graph basic blocks (local var 'bb_info'), and contains a list    of all insns within that basic block, in the order they are encountered.     For each entity, any basic block WITHOUT any insns requiring a specific    mode are given a single entry, without a mode.  (Each basic block    in the flow graph must have at least one entry in the segment table.)     The LCM algorithm is then run over the flow graph to determine where to    place the sets to the highest-priority value in respect of first the first    insn in any one block.  Any adjustments required to the transparancy    vectors are made, then the next iteration starts for the next-lower    priority mode, till for each entity all modes are exhasted.     More details are located in the code for optimize_mode_switching().  */
end_comment

begin_comment
comment|/* This structure contains the information for each insn which requires    either single or double mode to be set.    MODE is the mode this insn must be executed in.    INSN_PTR is the insn to be executed (may be the note that marks the    beginning of a basic block).    BBNUM is the flow graph basic block this insn occurs in.    NEXT is the next insn in the same basic block.  */
end_comment

begin_struct
struct|struct
name|seginfo
block|{
name|int
name|mode
decl_stmt|;
name|rtx
name|insn_ptr
decl_stmt|;
name|int
name|bbnum
decl_stmt|;
name|struct
name|seginfo
modifier|*
name|next
decl_stmt|;
name|HARD_REG_SET
name|regs_live
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|bb_info
block|{
name|struct
name|seginfo
modifier|*
name|seginfo
decl_stmt|;
name|int
name|computing
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* These bitmaps are used for the LCM algorithm.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPTIMIZE_MODE_SWITCHING
end_ifdef

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|antic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|transp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|comp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|delete
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|insert
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|seginfo
modifier|*
name|new_seginfo
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|,
name|HARD_REG_SET
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_seginfo
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bb_info
operator|*
operator|,
expr|struct
name|seginfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reg_dies
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|HARD_REG_SET
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reg_becomes_live
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_preds_opaque
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OPTIMIZE_MODE_SWITCHING
end_ifdef

begin_comment
comment|/* This function will allocate a new BBINFO structure, initialized    with the MODE, INSN, and basic block BB parameters.  */
end_comment

begin_function
specifier|static
name|struct
name|seginfo
modifier|*
name|new_seginfo
parameter_list|(
name|mode
parameter_list|,
name|insn
parameter_list|,
name|bb
parameter_list|,
name|regs_live
parameter_list|)
name|int
name|mode
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|HARD_REG_SET
name|regs_live
decl_stmt|;
block|{
name|struct
name|seginfo
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|seginfo
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|ptr
operator|->
name|insn_ptr
operator|=
name|insn
expr_stmt|;
name|ptr
operator|->
name|bbnum
operator|=
name|bb
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|ptr
operator|->
name|regs_live
argument_list|,
name|regs_live
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Add a seginfo element to the end of a list.    HEAD is a pointer to the list beginning.    INFO is the structure to be linked in.  */
end_comment

begin_function
specifier|static
name|void
name|add_seginfo
parameter_list|(
name|head
parameter_list|,
name|info
parameter_list|)
name|struct
name|bb_info
modifier|*
name|head
decl_stmt|;
name|struct
name|seginfo
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|seginfo
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|head
operator|->
name|seginfo
operator|==
name|NULL
condition|)
name|head
operator|->
name|seginfo
operator|=
name|info
expr_stmt|;
else|else
block|{
name|ptr
operator|=
name|head
operator|->
name|seginfo
expr_stmt|;
while|while
condition|(
name|ptr
operator|->
name|next
operator|!=
name|NULL
condition|)
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
name|info
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make all predecessors of basic block B opaque, recursively, till we hit    some that are already non-transparent, or an edge where aux is set; that    denotes that a mode set is to be done on that edge.    J is the bit number in the bitmaps that corresponds to the entity that    we are currently handling mode-switching for.  */
end_comment

begin_function
specifier|static
name|void
name|make_preds_opaque
parameter_list|(
name|b
parameter_list|,
name|j
parameter_list|)
name|basic_block
name|b
decl_stmt|;
name|int
name|j
decl_stmt|;
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|pb
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|aux
operator|||
operator|!
name|TEST_BIT
argument_list|(
name|transp
index|[
name|pb
operator|->
name|index
index|]
argument_list|,
name|j
argument_list|)
condition|)
continue|continue;
name|RESET_BIT
argument_list|(
name|transp
index|[
name|pb
operator|->
name|index
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|make_preds_opaque
argument_list|(
name|pb
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record in LIVE that register REG died.  */
end_comment

begin_function
specifier|static
name|void
name|reg_dies
parameter_list|(
name|reg
parameter_list|,
name|live
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|HARD_REG_SET
name|live
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|nregs
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|nregs
operator|>=
literal|0
condition|;
name|nregs
operator|--
control|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|live
argument_list|,
name|regno
operator|+
name|nregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record in LIVE that register REG became live.    This is called via note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|reg_becomes_live
parameter_list|(
name|reg
parameter_list|,
name|setter
parameter_list|,
name|live
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|live
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|nregs
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|nregs
operator|>=
literal|0
condition|;
name|nregs
operator|--
control|)
name|SET_HARD_REG_BIT
argument_list|(
operator|*
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|live
argument_list|,
name|regno
operator|+
name|nregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find all insns that need a particular mode setting, and insert the    necessary mode switches.  Return true if we did work.  */
end_comment

begin_function
name|int
name|optimize_mode_switching
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|bb
decl_stmt|,
name|e
decl_stmt|;
name|int
name|need_commit
init|=
literal|0
decl_stmt|;
name|sbitmap
modifier|*
name|kill
decl_stmt|;
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
specifier|static
specifier|const
name|int
name|num_modes
index|[]
init|=
name|NUM_MODES_FOR_MODE_SWITCHING
decl_stmt|;
define|#
directive|define
name|N_ENTITIES
value|(sizeof num_modes / sizeof (int))
name|int
name|entity_map
index|[
name|N_ENTITIES
index|]
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_info
index|[
name|N_ENTITIES
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|n_entities
decl_stmt|;
name|int
name|max_num_modes
init|=
literal|0
decl_stmt|;
name|bool
name|emited
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|NORMAL_MODE
comment|/* Increment n_basic_blocks before allocating bb_info.  */
name|n_basic_blocks
operator|++
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|e
operator|=
name|N_ENTITIES
operator|-
literal|1
operator|,
name|n_entities
operator|=
literal|0
init|;
name|e
operator|>=
literal|0
condition|;
name|e
operator|--
control|)
if|if
condition|(
name|OPTIMIZE_MODE_SWITCHING
argument_list|(
name|e
argument_list|)
condition|)
block|{
comment|/* Create the list of segments within each basic block.  */
name|bb_info
index|[
name|n_entities
index|]
operator|=
operator|(
expr|struct
name|bb_info
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
expr|*
operator|*
name|bb_info
argument_list|)
expr_stmt|;
name|entity_map
index|[
name|n_entities
operator|++
index|]
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|num_modes
index|[
name|e
index|]
operator|>
name|max_num_modes
condition|)
name|max_num_modes
operator|=
name|num_modes
index|[
name|e
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NORMAL_MODE
comment|/* Decrement it back in case we return below.  */
name|n_basic_blocks
operator|--
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|n_entities
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|NORMAL_MODE
comment|/* We're going to pretend the EXIT_BLOCK is a regular basic block,      so that switching back to normal mode when entering the      EXIT_BLOCK isn't optimized away.  We do this by incrementing the      basic block count, growing the VARRAY of basic_block_info and      appending the EXIT_BLOCK_PTR to it.  */
name|n_basic_blocks
operator|++
expr_stmt|;
if|if
condition|(
name|VARRAY_SIZE
argument_list|(
name|basic_block_info
argument_list|)
operator|<
name|n_basic_blocks
condition|)
name|VARRAY_GROW
argument_list|(
name|basic_block_info
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|BASIC_BLOCK
argument_list|(
name|n_basic_blocks
operator|-
literal|1
argument_list|)
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|index
operator|=
name|n_basic_blocks
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Create the bitmap vectors.  */
name|antic
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_entities
argument_list|)
expr_stmt|;
name|transp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_entities
argument_list|)
expr_stmt|;
name|comp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_entities
argument_list|)
expr_stmt|;
name|sbitmap_vector_ones
argument_list|(
name|transp
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|n_entities
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|int
name|e
init|=
name|entity_map
index|[
name|j
index|]
decl_stmt|;
name|int
name|no_mode
init|=
name|num_modes
index|[
name|e
index|]
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|info
init|=
name|bb_info
index|[
name|j
index|]
decl_stmt|;
comment|/* Determine what the first use (if any) need for a mode of entity E is. 	 This will be the mode that is anticipatable for this block. 	 Also compute the initial transparency settings.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|struct
name|seginfo
modifier|*
name|ptr
decl_stmt|;
name|int
name|last_mode
init|=
name|no_mode
decl_stmt|;
name|HARD_REG_SET
name|live_now
decl_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|live_now
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NULL
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|mode
init|=
name|MODE_NEEDED
argument_list|(
name|e
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|link
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|no_mode
operator|&&
name|mode
operator|!=
name|last_mode
condition|)
block|{
name|last_mode
operator|=
name|mode
expr_stmt|;
name|ptr
operator|=
name|new_seginfo
argument_list|(
name|mode
argument_list|,
name|insn
argument_list|,
name|bb
argument_list|,
name|live_now
argument_list|)
expr_stmt|;
name|add_seginfo
argument_list|(
name|info
operator|+
name|bb
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|transp
index|[
name|bb
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* Update LIVE_NOW.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
name|reg_dies
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|live_now
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg_becomes_live
argument_list|,
operator|&
name|live_now
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_UNUSED
condition|)
name|reg_dies
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|live_now
argument_list|)
expr_stmt|;
block|}
block|}
name|info
index|[
name|bb
index|]
operator|.
name|computing
operator|=
name|last_mode
expr_stmt|;
comment|/* Check for blocks without ANY mode requirements.  */
if|if
condition|(
name|last_mode
operator|==
name|no_mode
condition|)
block|{
name|ptr
operator|=
name|new_seginfo
argument_list|(
name|no_mode
argument_list|,
name|insn
argument_list|,
name|bb
argument_list|,
name|live_now
argument_list|)
expr_stmt|;
name|add_seginfo
argument_list|(
name|info
operator|+
name|bb
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|NORMAL_MODE
block|{
name|int
name|mode
init|=
name|NORMAL_MODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|no_mode
condition|)
block|{
name|edge
name|eg
decl_stmt|;
for|for
control|(
name|eg
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|eg
condition|;
name|eg
operator|=
name|eg
operator|->
name|succ_next
control|)
block|{
name|bb
operator|=
name|eg
operator|->
name|dest
operator|->
name|index
expr_stmt|;
comment|/* By always making this nontransparent, we save 		   an extra check in make_preds_opaque.  We also 		   need this to avoid confusing pre_edge_lcm when 		   antic is cleared but transp and comp are set.  */
name|RESET_BIT
argument_list|(
name|transp
index|[
name|bb
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* If the block already has MODE, pretend it 		   has none (because we don't need to set it), 		   but retain whatever mode it computes.  */
if|if
condition|(
name|info
index|[
name|bb
index|]
operator|.
name|seginfo
operator|->
name|mode
operator|==
name|mode
condition|)
name|info
index|[
name|bb
index|]
operator|.
name|seginfo
operator|->
name|mode
operator|=
name|no_mode
expr_stmt|;
comment|/* Insert a fake computing definition of MODE into entry 		   blocks which compute no mode. This represents the mode on 		   entry.  */
elseif|else
if|if
condition|(
name|info
index|[
name|bb
index|]
operator|.
name|computing
operator|==
name|no_mode
condition|)
block|{
name|info
index|[
name|bb
index|]
operator|.
name|computing
operator|=
name|mode
expr_stmt|;
name|info
index|[
name|bb
index|]
operator|.
name|seginfo
operator|->
name|mode
operator|=
name|no_mode
expr_stmt|;
block|}
block|}
name|bb
operator|=
name|n_basic_blocks
operator|-
literal|1
expr_stmt|;
name|info
index|[
name|bb
index|]
operator|.
name|seginfo
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NORMAL_MODE */
block|}
name|kill
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_entities
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_num_modes
condition|;
name|i
operator|++
control|)
block|{
name|int
name|current_mode
index|[
name|N_ENTITIES
index|]
decl_stmt|;
comment|/* Set the anticipatable and computing arrays.  */
name|sbitmap_vector_zero
argument_list|(
name|antic
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|comp
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|n_entities
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|int
name|m
init|=
name|current_mode
index|[
name|j
index|]
operator|=
name|MODE_PRIORITY_TO_MODE
argument_list|(
name|entity_map
index|[
name|j
index|]
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|info
init|=
name|bb_info
index|[
name|j
index|]
decl_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
if|if
condition|(
name|info
index|[
name|bb
index|]
operator|.
name|seginfo
operator|->
name|mode
operator|==
name|m
condition|)
name|SET_BIT
argument_list|(
name|antic
index|[
name|bb
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
index|[
name|bb
index|]
operator|.
name|computing
operator|==
name|m
condition|)
name|SET_BIT
argument_list|(
name|comp
index|[
name|bb
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Calculate the optimal locations for the 	 placement mode switches to modes with priority I.  */
for|for
control|(
name|bb
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|bb
operator|>=
literal|0
condition|;
name|bb
operator|--
control|)
name|sbitmap_not
argument_list|(
name|kill
index|[
name|bb
index|]
argument_list|,
name|transp
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|edge_list
operator|=
name|pre_edge_lcm
argument_list|(
name|file
argument_list|,
literal|1
argument_list|,
name|transp
argument_list|,
name|comp
argument_list|,
name|antic
argument_list|,
name|kill
argument_list|,
operator|&
name|insert
argument_list|,
operator|&
name|delete
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|n_entities
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
comment|/* Insert all mode sets that have been inserted by lcm.  */
name|int
name|no_mode
init|=
name|num_modes
index|[
name|entity_map
index|[
name|j
index|]
index|]
decl_stmt|;
comment|/* Wherever we have moved a mode setting upwards in the flow graph, 	     the blocks between the new setting site and the now redundant 	     computation ceases to be transparent for any lower-priority 	     mode of the same entity.  First set the aux field of each 	     insertion site edge non-transparent, then propagate the new 	     non-transparency from the redundant computation upwards till 	     we hit an insertion site or an already non-transparent block.  */
for|for
control|(
name|e
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
operator|-
literal|1
init|;
name|e
operator|>=
literal|0
condition|;
name|e
operator|--
control|)
block|{
name|edge
name|eg
init|=
name|INDEX_EDGE
argument_list|(
name|edge_list
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|basic_block
name|src_bb
decl_stmt|;
name|HARD_REG_SET
name|live_at_edge
decl_stmt|;
name|rtx
name|mode_set
decl_stmt|;
name|eg
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|insert
index|[
name|e
index|]
argument_list|,
name|j
argument_list|)
condition|)
continue|continue;
name|eg
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
name|mode
operator|=
name|current_mode
index|[
name|j
index|]
expr_stmt|;
name|src_bb
operator|=
name|eg
operator|->
name|src
expr_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|live_at_edge
argument_list|,
name|src_bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|EMIT_MODE_SET
argument_list|(
name|entity_map
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|,
name|live_at_edge
argument_list|)
expr_stmt|;
name|mode_set
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Do not bother to insert empty sequence.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|mode_set
argument_list|)
operator|==
name|SEQUENCE
operator|&&
operator|!
name|XVECLEN
argument_list|(
name|mode_set
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
comment|/* If this is an abnormal edge, we'll insert at the end 		 of the previous block.  */
if|if
condition|(
name|eg
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
block|{
name|emited
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_bb
operator|->
name|end
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|emit_insn_before
argument_list|(
name|mode_set
argument_list|,
name|src_bb
operator|->
name|end
argument_list|)
expr_stmt|;
comment|/* It doesn't make sense to switch to normal mode 		     after a CALL_INSN, so we're going to abort if we 		     find one.  The cases in which a CALL_INSN may 		     have an abnormal edge are sibcalls and EH edges. 		     In the case of sibcalls, the dest basic-block is 		     the EXIT_BLOCK, that runs in normal mode; it is 		     assumed that a sibcall insn requires normal mode 		     itself, so no mode switch would be required after 		     the call (it wouldn't make sense, anyway).  In 		     the case of EH edges, EH entry points also start 		     in normal mode, so a similar reasoning applies.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_bb
operator|->
name|end
argument_list|)
operator|==
name|INSN
condition|)
name|emit_insn_after
argument_list|(
name|mode_set
argument_list|,
name|src_bb
operator|->
name|end
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|bb_info
index|[
name|j
index|]
index|[
name|src_bb
operator|->
name|index
index|]
operator|.
name|computing
operator|=
name|mode
expr_stmt|;
name|RESET_BIT
argument_list|(
name|transp
index|[
name|src_bb
operator|->
name|index
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|need_commit
operator|=
literal|1
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|mode_set
argument_list|,
name|eg
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|bb
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|bb
operator|>=
literal|0
condition|;
name|bb
operator|--
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|delete
index|[
name|bb
index|]
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|make_preds_opaque
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* Cancel the 'deleted' mode set.  */
name|bb_info
index|[
name|j
index|]
index|[
name|bb
index|]
operator|.
name|seginfo
operator|->
name|mode
operator|=
name|no_mode
expr_stmt|;
block|}
block|}
name|clear_aux_for_edges
argument_list|()
expr_stmt|;
name|free_edge_list
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NORMAL_MODE
comment|/* Restore the special status of EXIT_BLOCK.  */
name|n_basic_blocks
operator|--
expr_stmt|;
name|VARRAY_POP
argument_list|(
name|basic_block_info
argument_list|)
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|index
operator|=
name|EXIT_BLOCK
expr_stmt|;
endif|#
directive|endif
comment|/* Now output the remaining mode sets in all the segments.  */
for|for
control|(
name|j
operator|=
name|n_entities
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|int
name|no_mode
init|=
name|num_modes
index|[
name|entity_map
index|[
name|j
index|]
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|NORMAL_MODE
if|if
condition|(
name|bb_info
index|[
name|j
index|]
index|[
name|n_basic_blocks
index|]
operator|.
name|seginfo
operator|->
name|mode
operator|!=
name|no_mode
condition|)
block|{
name|edge
name|eg
decl_stmt|;
name|struct
name|seginfo
modifier|*
name|ptr
init|=
name|bb_info
index|[
name|j
index|]
index|[
name|n_basic_blocks
index|]
operator|.
name|seginfo
decl_stmt|;
for|for
control|(
name|eg
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|eg
condition|;
name|eg
operator|=
name|eg
operator|->
name|pred_next
control|)
block|{
name|rtx
name|mode_set
decl_stmt|;
if|if
condition|(
name|bb_info
index|[
name|j
index|]
index|[
name|eg
operator|->
name|src
operator|->
name|index
index|]
operator|.
name|computing
operator|==
name|ptr
operator|->
name|mode
condition|)
continue|continue;
name|start_sequence
argument_list|()
expr_stmt|;
name|EMIT_MODE_SET
argument_list|(
name|entity_map
index|[
name|j
index|]
argument_list|,
name|ptr
operator|->
name|mode
argument_list|,
name|ptr
operator|->
name|regs_live
argument_list|)
expr_stmt|;
name|mode_set
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Do not bother to insert empty sequence.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|mode_set
argument_list|)
operator|==
name|SEQUENCE
operator|&&
operator|!
name|XVECLEN
argument_list|(
name|mode_set
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
comment|/* If this is an abnormal edge, we'll insert at the end of the 		 previous block.  */
if|if
condition|(
name|eg
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
block|{
name|emited
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|eg
operator|->
name|src
operator|->
name|end
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|emit_insn_before
argument_list|(
name|mode_set
argument_list|,
name|eg
operator|->
name|src
operator|->
name|end
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|eg
operator|->
name|src
operator|->
name|end
argument_list|)
operator|==
name|INSN
condition|)
name|emit_insn_after
argument_list|(
name|mode_set
argument_list|,
name|eg
operator|->
name|src
operator|->
name|end
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|need_commit
operator|=
literal|1
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|mode_set
argument_list|,
name|eg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
for|for
control|(
name|bb
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|bb
operator|>=
literal|0
condition|;
name|bb
operator|--
control|)
block|{
name|struct
name|seginfo
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|bb_info
index|[
name|j
index|]
index|[
name|bb
index|]
operator|.
name|seginfo
init|;
name|ptr
condition|;
name|ptr
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|mode
operator|!=
name|no_mode
condition|)
block|{
name|rtx
name|mode_set
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|EMIT_MODE_SET
argument_list|(
name|entity_map
index|[
name|j
index|]
argument_list|,
name|ptr
operator|->
name|mode
argument_list|,
name|ptr
operator|->
name|regs_live
argument_list|)
expr_stmt|;
name|mode_set
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Do not bother to insert empty sequence.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|mode_set
argument_list|)
operator|==
name|SEQUENCE
operator|&&
operator|!
name|XVECLEN
argument_list|(
name|mode_set
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
name|emited
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ptr
operator|->
name|insn_ptr
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|ptr
operator|->
name|insn_ptr
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
operator|)
condition|)
name|emit_insn_after
argument_list|(
name|mode_set
argument_list|,
name|ptr
operator|->
name|insn_ptr
argument_list|)
expr_stmt|;
else|else
name|emit_insn_before
argument_list|(
name|mode_set
argument_list|,
name|ptr
operator|->
name|insn_ptr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|bb_info
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Finished. Free up all the things we've allocated.  */
name|sbitmap_vector_free
argument_list|(
name|kill
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|antic
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|delete
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|insert
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_commit
condition|)
name|commit_edge_insertions
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|need_commit
operator|&&
operator|!
name|emited
condition|)
return|return
literal|0
return|;
comment|/* Ideally we'd figure out what blocks were affected and start from      there, but this is enormously complicated by commit_edge_insertions,      which would screw up any indices we'd collected, and also need to      be involved in the update.  Bail and recompute global life info for      everything.  */
name|allocate_reg_life_data
argument_list|()
expr_stmt|;
name|update_life_info
argument_list|(
name|NULL
argument_list|,
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
operator|(
name|PROP_DEATH_NOTES
operator||
name|PROP_KILL_DEAD_CODE
operator||
name|PROP_SCAN_DEAD_CODE
operator||
name|PROP_REG_INFO
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPTIMIZE_MODE_SWITCHING */
end_comment

end_unit

