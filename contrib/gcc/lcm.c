begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic partial redundancy elimination with lazy code motion    support.    Copyright (C) 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* These routines are meant to be used by various optimization    passes which can be modeled as lazy code motion problems.     Including, but not limited to:  	* Traditional partial redundancy elimination.  	* Placement of caller/caller register save/restores.  	* Load/store motion.  	* Copy motion.  	* Conversion of flat register files to a stacked register 	model.  	* Dead load/store elimination.    These routines accept as input:  	* Basic block information (number of blocks, lists of 	predecessors and successors).  Note the granularity 	does not need to be basic block, they could be statements 	or functions.  	* Bitmaps of local properties (computed, transparent and 	anticipatable expressions).    The output of these routines is bitmap of redundant computations   and a bitmap of optimal placement points.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|compute_antinout
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int_list_ptr
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_earlyinout
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int_list_ptr
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_delayinout
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int_list_ptr
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_latein
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int_list_ptr
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_isoinout
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int_list_ptr
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_optimal
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_redundant
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similarly, but for the reversed flowgraph.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|compute_avinout
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int_list_ptr
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_fartherinout
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int_list_ptr
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_earlierinout
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int_list_ptr
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_firstout
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int_list_ptr
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_rev_isoinout
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int_list_ptr
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given local properties TRANSP, ANTLOC, return the redundant and optimal    computation points for expressions.     To reduce overall memory consumption, we allocate memory immediately    before its needed and deallocate it as soon as possible.  */
end_comment

begin_function
name|void
name|pre_lcm
parameter_list|(
name|n_blocks
parameter_list|,
name|n_exprs
parameter_list|,
name|s_preds
parameter_list|,
name|s_succs
parameter_list|,
name|transp
parameter_list|,
name|antloc
parameter_list|,
name|redundant
parameter_list|,
name|optimal
parameter_list|)
name|int
name|n_blocks
decl_stmt|;
name|int
name|n_exprs
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
name|sbitmap
modifier|*
name|transp
decl_stmt|;
name|sbitmap
modifier|*
name|antloc
decl_stmt|;
name|sbitmap
modifier|*
name|redundant
decl_stmt|;
name|sbitmap
modifier|*
name|optimal
decl_stmt|;
block|{
name|sbitmap
modifier|*
name|antin
decl_stmt|,
modifier|*
name|antout
decl_stmt|,
modifier|*
name|earlyin
decl_stmt|,
modifier|*
name|earlyout
decl_stmt|,
modifier|*
name|delayin
decl_stmt|,
modifier|*
name|delayout
decl_stmt|;
name|sbitmap
modifier|*
name|latein
decl_stmt|,
modifier|*
name|isoin
decl_stmt|,
modifier|*
name|isoout
decl_stmt|;
comment|/* Compute global anticipatability.  ANTOUT is not needed except to      compute ANTIN, so free its memory as soon as we return from      compute_antinout.  */
name|antin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|antout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_antinout
argument_list|(
name|n_blocks
argument_list|,
name|s_succs
argument_list|,
name|antloc
argument_list|,
name|transp
argument_list|,
name|antin
argument_list|,
name|antout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|antout
argument_list|)
expr_stmt|;
name|antout
operator|=
name|NULL
expr_stmt|;
comment|/* Compute earliestness.  EARLYOUT is not needed except to compute      EARLYIN, so free its memory as soon as we return from      compute_earlyinout.  */
name|earlyin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|earlyout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_earlyinout
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|,
name|s_preds
argument_list|,
name|transp
argument_list|,
name|antin
argument_list|,
name|earlyin
argument_list|,
name|earlyout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|earlyout
argument_list|)
expr_stmt|;
name|earlyout
operator|=
name|NULL
expr_stmt|;
comment|/* Compute delayedness.  DELAYOUT is not needed except to compute      DELAYIN, so free its memory as soon as we return from      compute_delayinout.  We also no longer need ANTIN and EARLYIN.  */
name|delayin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|delayout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_delayinout
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|,
name|s_preds
argument_list|,
name|antloc
argument_list|,
name|antin
argument_list|,
name|earlyin
argument_list|,
name|delayin
argument_list|,
name|delayout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|delayout
argument_list|)
expr_stmt|;
name|delayout
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|antin
argument_list|)
expr_stmt|;
name|antin
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|earlyin
argument_list|)
expr_stmt|;
name|earlyin
operator|=
name|NULL
expr_stmt|;
comment|/* Compute latestness.  We no longer need DELAYIN after we compute      LATEIN.  */
name|latein
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_latein
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|,
name|s_succs
argument_list|,
name|antloc
argument_list|,
name|delayin
argument_list|,
name|latein
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|delayin
argument_list|)
expr_stmt|;
name|delayin
operator|=
name|NULL
expr_stmt|;
comment|/* Compute isolatedness.  ISOIN is not needed except to compute      ISOOUT, so free its memory as soon as we return from      compute_isoinout.  */
name|isoin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|isoout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_isoinout
argument_list|(
name|n_blocks
argument_list|,
name|s_succs
argument_list|,
name|antloc
argument_list|,
name|latein
argument_list|,
name|isoin
argument_list|,
name|isoout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isoin
argument_list|)
expr_stmt|;
name|isoin
operator|=
name|NULL
expr_stmt|;
comment|/* Now compute optimal placement points and the redundant expressions.  */
name|compute_optimal
argument_list|(
name|n_blocks
argument_list|,
name|latein
argument_list|,
name|isoout
argument_list|,
name|optimal
argument_list|)
expr_stmt|;
name|compute_redundant
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|,
name|antloc
argument_list|,
name|latein
argument_list|,
name|isoout
argument_list|,
name|redundant
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|latein
argument_list|)
expr_stmt|;
name|latein
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|isoout
argument_list|)
expr_stmt|;
name|isoout
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given local properties TRANSP, AVLOC, return the redundant and optimal    computation points for expressions on the reverse flowgraph.     To reduce overall memory consumption, we allocate memory immediately    before its needed and deallocate it as soon as possible.  */
end_comment

begin_function
name|void
name|pre_rev_lcm
parameter_list|(
name|n_blocks
parameter_list|,
name|n_exprs
parameter_list|,
name|s_preds
parameter_list|,
name|s_succs
parameter_list|,
name|transp
parameter_list|,
name|avloc
parameter_list|,
name|redundant
parameter_list|,
name|optimal
parameter_list|)
name|int
name|n_blocks
decl_stmt|;
name|int
name|n_exprs
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
name|sbitmap
modifier|*
name|transp
decl_stmt|;
name|sbitmap
modifier|*
name|avloc
decl_stmt|;
name|sbitmap
modifier|*
name|redundant
decl_stmt|;
name|sbitmap
modifier|*
name|optimal
decl_stmt|;
block|{
name|sbitmap
modifier|*
name|avin
decl_stmt|,
modifier|*
name|avout
decl_stmt|,
modifier|*
name|fartherin
decl_stmt|,
modifier|*
name|fartherout
decl_stmt|,
modifier|*
name|earlierin
decl_stmt|,
modifier|*
name|earlierout
decl_stmt|;
name|sbitmap
modifier|*
name|firstout
decl_stmt|,
modifier|*
name|rev_isoin
decl_stmt|,
modifier|*
name|rev_isoout
decl_stmt|;
comment|/* Compute global availability.  AVIN is not needed except to      compute AVOUT, so free its memory as soon as we return from      compute_avinout.  */
name|avin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|avout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_avinout
argument_list|(
name|n_blocks
argument_list|,
name|s_preds
argument_list|,
name|avloc
argument_list|,
name|transp
argument_list|,
name|avin
argument_list|,
name|avout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|avin
argument_list|)
expr_stmt|;
name|avin
operator|=
name|NULL
expr_stmt|;
comment|/* Compute fartherness.  FARTHERIN is not needed except to compute      FARTHEROUT, so free its memory as soon as we return from      compute_earlyinout.  */
name|fartherin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|fartherout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_fartherinout
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|,
name|s_succs
argument_list|,
name|transp
argument_list|,
name|avout
argument_list|,
name|fartherin
argument_list|,
name|fartherout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fartherin
argument_list|)
expr_stmt|;
name|fartherin
operator|=
name|NULL
expr_stmt|;
comment|/* Compute earlierness.  EARLIERIN is not needed except to compute      EARLIEROUT, so free its memory as soon as we return from      compute_delayinout.  We also no longer need AVOUT and FARTHEROUT.  */
name|earlierin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|earlierout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_earlierinout
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|,
name|s_succs
argument_list|,
name|avloc
argument_list|,
name|avout
argument_list|,
name|fartherout
argument_list|,
name|earlierin
argument_list|,
name|earlierout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|earlierin
argument_list|)
expr_stmt|;
name|earlierin
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|avout
argument_list|)
expr_stmt|;
name|avout
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|fartherout
argument_list|)
expr_stmt|;
name|fartherout
operator|=
name|NULL
expr_stmt|;
comment|/* Compute firstness.  We no longer need EARLIEROUT after we compute      FIRSTOUT.  */
name|firstout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_firstout
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|,
name|s_preds
argument_list|,
name|avloc
argument_list|,
name|earlierout
argument_list|,
name|firstout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|earlierout
argument_list|)
expr_stmt|;
name|earlierout
operator|=
name|NULL
expr_stmt|;
comment|/* Compute rev_isolatedness.  ISOIN is not needed except to compute      ISOOUT, so free its memory as soon as we return from      compute_isoinout.  */
name|rev_isoin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|rev_isoout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_rev_isoinout
argument_list|(
name|n_blocks
argument_list|,
name|s_preds
argument_list|,
name|avloc
argument_list|,
name|firstout
argument_list|,
name|rev_isoin
argument_list|,
name|rev_isoout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev_isoout
argument_list|)
expr_stmt|;
name|rev_isoout
operator|=
name|NULL
expr_stmt|;
comment|/* Now compute optimal placement points and the redundant expressions.  */
name|compute_optimal
argument_list|(
name|n_blocks
argument_list|,
name|firstout
argument_list|,
name|rev_isoin
argument_list|,
name|optimal
argument_list|)
expr_stmt|;
name|compute_redundant
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|,
name|avloc
argument_list|,
name|firstout
argument_list|,
name|rev_isoin
argument_list|,
name|redundant
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|firstout
argument_list|)
expr_stmt|;
name|firstout
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|rev_isoin
argument_list|)
expr_stmt|;
name|rev_isoin
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute expression anticipatability at entrance and exit of each block.  */
end_comment

begin_function
specifier|static
name|void
name|compute_antinout
parameter_list|(
name|n_blocks
parameter_list|,
name|s_succs
parameter_list|,
name|antloc
parameter_list|,
name|transp
parameter_list|,
name|antin
parameter_list|,
name|antout
parameter_list|)
name|int
name|n_blocks
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
name|sbitmap
modifier|*
name|antloc
decl_stmt|;
name|sbitmap
modifier|*
name|transp
decl_stmt|;
name|sbitmap
modifier|*
name|antin
decl_stmt|;
name|sbitmap
modifier|*
name|antout
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|,
name|passes
decl_stmt|;
name|sbitmap
name|old_changed
decl_stmt|,
name|new_changed
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|antout
index|[
name|n_blocks
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|sbitmap_vector_ones
argument_list|(
name|antin
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
name|old_changed
operator|=
name|sbitmap_alloc
argument_list|(
name|n_blocks
argument_list|)
expr_stmt|;
name|new_changed
operator|=
name|sbitmap_alloc
argument_list|(
name|n_blocks
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|old_changed
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|new_changed
argument_list|)
expr_stmt|;
comment|/* We scan the blocks in the reverse order to speed up 	 the convergence.  */
for|for
control|(
name|bb
operator|=
name|n_blocks
operator|-
literal|1
init|;
name|bb
operator|>=
literal|0
condition|;
name|bb
operator|--
control|)
block|{
name|int_list_ptr
name|ps
decl_stmt|;
comment|/* If none of the successors of this block have changed, 	     then this block is not going to change.  */
for|for
control|(
name|ps
operator|=
name|s_succs
index|[
name|bb
index|]
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
if|if
condition|(
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
operator|==
name|EXIT_BLOCK
operator|||
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
operator|==
name|ENTRY_BLOCK
condition|)
break|break;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|old_changed
argument_list|,
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
argument_list|)
operator|||
name|TEST_BIT
argument_list|(
name|new_changed
argument_list|,
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|ps
condition|)
continue|continue;
if|if
condition|(
name|bb
operator|!=
name|n_blocks
operator|-
literal|1
condition|)
name|sbitmap_intersect_of_successors
argument_list|(
name|antout
index|[
name|bb
index|]
argument_list|,
name|antin
argument_list|,
name|bb
argument_list|,
name|s_succs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbitmap_a_or_b_and_c
argument_list|(
name|antin
index|[
name|bb
index|]
argument_list|,
name|antloc
index|[
name|bb
index|]
argument_list|,
name|transp
index|[
name|bb
index|]
argument_list|,
name|antout
index|[
name|bb
index|]
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|SET_BIT
argument_list|(
name|new_changed
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
name|sbitmap_copy
argument_list|(
name|old_changed
argument_list|,
name|new_changed
argument_list|)
expr_stmt|;
name|passes
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|old_changed
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_changed
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute expression earliestness at entrance and exit of each block.     From Advanced Compiler Design and Implementation pp411.     An expression is earliest at the entrance to basic block BB if no    block from entry to block BB both evaluates the expression and    produces the same value as evaluating it at the entry to block BB    does.  Similarly for earlistness at basic block BB exit.  */
end_comment

begin_function
specifier|static
name|void
name|compute_earlyinout
parameter_list|(
name|n_blocks
parameter_list|,
name|n_exprs
parameter_list|,
name|s_preds
parameter_list|,
name|transp
parameter_list|,
name|antin
parameter_list|,
name|earlyin
parameter_list|,
name|earlyout
parameter_list|)
name|int
name|n_blocks
decl_stmt|;
name|int
name|n_exprs
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
name|sbitmap
modifier|*
name|transp
decl_stmt|;
name|sbitmap
modifier|*
name|antin
decl_stmt|;
name|sbitmap
modifier|*
name|earlyin
decl_stmt|;
name|sbitmap
modifier|*
name|earlyout
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|,
name|passes
decl_stmt|;
name|sbitmap
name|temp_bitmap
decl_stmt|;
name|sbitmap
name|old_changed
decl_stmt|,
name|new_changed
decl_stmt|;
name|temp_bitmap
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|earlyout
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|earlyin
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|old_changed
operator|=
name|sbitmap_alloc
argument_list|(
name|n_blocks
argument_list|)
expr_stmt|;
name|new_changed
operator|=
name|sbitmap_alloc
argument_list|(
name|n_blocks
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|old_changed
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|new_changed
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|int_list_ptr
name|ps
decl_stmt|;
comment|/* If none of the predecessors of this block have changed, 	     then this block is not going to change.  */
for|for
control|(
name|ps
operator|=
name|s_preds
index|[
name|bb
index|]
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
if|if
condition|(
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
operator|==
name|EXIT_BLOCK
operator|||
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
operator|==
name|ENTRY_BLOCK
condition|)
break|break;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|old_changed
argument_list|,
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
argument_list|)
operator|||
name|TEST_BIT
argument_list|(
name|new_changed
argument_list|,
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|ps
condition|)
continue|continue;
if|if
condition|(
name|bb
operator|!=
literal|0
condition|)
name|sbitmap_union_of_predecessors
argument_list|(
name|earlyin
index|[
name|bb
index|]
argument_list|,
name|earlyout
argument_list|,
name|bb
argument_list|,
name|s_preds
argument_list|)
expr_stmt|;
name|sbitmap_not
argument_list|(
name|temp_bitmap
argument_list|,
name|transp
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbitmap_union_of_diff
argument_list|(
name|earlyout
index|[
name|bb
index|]
argument_list|,
name|temp_bitmap
argument_list|,
name|earlyin
index|[
name|bb
index|]
argument_list|,
name|antin
index|[
name|bb
index|]
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|SET_BIT
argument_list|(
name|new_changed
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
name|sbitmap_copy
argument_list|(
name|old_changed
argument_list|,
name|new_changed
argument_list|)
expr_stmt|;
name|passes
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|old_changed
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_changed
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute expression delayedness at entrance and exit of each block.     From Advanced Compiler Design and Implementation pp411.     An expression is delayed at the entrance to BB if it is anticipatable    and earliest at that point and if all subsequent computations of    the expression are in block BB.   */
end_comment

begin_function
specifier|static
name|void
name|compute_delayinout
parameter_list|(
name|n_blocks
parameter_list|,
name|n_exprs
parameter_list|,
name|s_preds
parameter_list|,
name|antloc
parameter_list|,
name|antin
parameter_list|,
name|earlyin
parameter_list|,
name|delayin
parameter_list|,
name|delayout
parameter_list|)
name|int
name|n_blocks
decl_stmt|;
name|int
name|n_exprs
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
name|sbitmap
modifier|*
name|antloc
decl_stmt|;
name|sbitmap
modifier|*
name|antin
decl_stmt|;
name|sbitmap
modifier|*
name|earlyin
decl_stmt|;
name|sbitmap
modifier|*
name|delayin
decl_stmt|;
name|sbitmap
modifier|*
name|delayout
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|,
name|passes
decl_stmt|;
name|sbitmap
modifier|*
name|anti_and_early
decl_stmt|;
name|sbitmap
name|temp_bitmap
decl_stmt|;
name|temp_bitmap
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
comment|/* This is constant throughout the flow equations below, so compute      it once to save time.  */
name|anti_and_early
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_blocks
condition|;
name|bb
operator|++
control|)
name|sbitmap_a_and_b
argument_list|(
name|anti_and_early
index|[
name|bb
index|]
argument_list|,
name|antin
index|[
name|bb
index|]
argument_list|,
name|earlyin
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|delayout
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
name|sbitmap_copy
argument_list|(
name|delayin
index|[
literal|0
index|]
argument_list|,
name|anti_and_early
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_blocks
condition|;
name|bb
operator|++
control|)
block|{
if|if
condition|(
name|bb
operator|!=
literal|0
condition|)
block|{
name|sbitmap_intersect_of_predecessors
argument_list|(
name|temp_bitmap
argument_list|,
name|delayout
argument_list|,
name|bb
argument_list|,
name|s_preds
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_a_or_b
argument_list|(
name|delayin
index|[
name|bb
index|]
argument_list|,
name|anti_and_early
index|[
name|bb
index|]
argument_list|,
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
name|sbitmap_not
argument_list|(
name|temp_bitmap
argument_list|,
name|antloc
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_a_and_b
argument_list|(
name|delayout
index|[
name|bb
index|]
argument_list|,
name|temp_bitmap
argument_list|,
name|delayin
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
name|passes
operator|++
expr_stmt|;
block|}
comment|/* We're done with this, so go ahead and free it's memory now instead      of waiting until the end of pre.  */
name|free
argument_list|(
name|anti_and_early
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute latestness.     From Advanced Compiler Design and Implementation pp412.     An expression is latest at the entrance to block BB if that is an optimal    point for computing the expression and if on every path from block BB's    entrance to the exit block, any optimal computation point for the     expression occurs after one of the points at which the expression was    computed in the original flowgraph.  */
end_comment

begin_function
specifier|static
name|void
name|compute_latein
parameter_list|(
name|n_blocks
parameter_list|,
name|n_exprs
parameter_list|,
name|s_succs
parameter_list|,
name|antloc
parameter_list|,
name|delayin
parameter_list|,
name|latein
parameter_list|)
name|int
name|n_blocks
decl_stmt|;
name|int
name|n_exprs
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
name|sbitmap
modifier|*
name|antloc
decl_stmt|;
name|sbitmap
modifier|*
name|delayin
decl_stmt|;
name|sbitmap
modifier|*
name|latein
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|;
name|sbitmap
name|temp_bitmap
decl_stmt|;
name|temp_bitmap
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_blocks
condition|;
name|bb
operator|++
control|)
block|{
comment|/* The last block is succeeded only by the exit block; therefore, 	 temp_bitmap will not be set by the following call!  */
if|if
condition|(
name|bb
operator|==
name|n_blocks
operator|-
literal|1
condition|)
block|{
name|sbitmap_intersect_of_successors
argument_list|(
name|temp_bitmap
argument_list|,
name|delayin
argument_list|,
name|bb
argument_list|,
name|s_succs
argument_list|)
expr_stmt|;
name|sbitmap_not
argument_list|(
name|temp_bitmap
argument_list|,
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
else|else
name|sbitmap_ones
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
name|sbitmap_a_and_b_or_c
argument_list|(
name|latein
index|[
name|bb
index|]
argument_list|,
name|delayin
index|[
name|bb
index|]
argument_list|,
name|antloc
index|[
name|bb
index|]
argument_list|,
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute isolated.     From Advanced Compiler Design and Implementation pp413.     A computationally optimal placement for the evaluation of an expression    is defined to be isolated if and only if on every path from a successor    of the block in which it is computed to the exit block, every original    computation of the expression is preceded by the optimal placement point.  */
end_comment

begin_function
specifier|static
name|void
name|compute_isoinout
parameter_list|(
name|n_blocks
parameter_list|,
name|s_succs
parameter_list|,
name|antloc
parameter_list|,
name|latein
parameter_list|,
name|isoin
parameter_list|,
name|isoout
parameter_list|)
name|int
name|n_blocks
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
name|sbitmap
modifier|*
name|antloc
decl_stmt|;
name|sbitmap
modifier|*
name|latein
decl_stmt|;
name|sbitmap
modifier|*
name|isoin
decl_stmt|;
name|sbitmap
modifier|*
name|isoout
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|,
name|passes
decl_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|isoin
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|isoout
index|[
name|n_blocks
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|n_blocks
operator|-
literal|1
init|;
name|bb
operator|>=
literal|0
condition|;
name|bb
operator|--
control|)
block|{
if|if
condition|(
name|bb
operator|!=
name|n_blocks
operator|-
literal|1
condition|)
name|sbitmap_intersect_of_successors
argument_list|(
name|isoout
index|[
name|bb
index|]
argument_list|,
name|isoin
argument_list|,
name|bb
argument_list|,
name|s_succs
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_union_of_diff
argument_list|(
name|isoin
index|[
name|bb
index|]
argument_list|,
name|latein
index|[
name|bb
index|]
argument_list|,
name|isoout
index|[
name|bb
index|]
argument_list|,
name|antloc
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
name|passes
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute the set of expressions which have optimal computational points    in each basic block.  This is the set of expressions that are latest, but    that are not isolated in the block.  */
end_comment

begin_function
specifier|static
name|void
name|compute_optimal
parameter_list|(
name|n_blocks
parameter_list|,
name|latein
parameter_list|,
name|isoout
parameter_list|,
name|optimal
parameter_list|)
name|int
name|n_blocks
decl_stmt|;
name|sbitmap
modifier|*
name|latein
decl_stmt|;
name|sbitmap
modifier|*
name|isoout
decl_stmt|;
name|sbitmap
modifier|*
name|optimal
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_blocks
condition|;
name|bb
operator|++
control|)
name|sbitmap_difference
argument_list|(
name|optimal
index|[
name|bb
index|]
argument_list|,
name|latein
index|[
name|bb
index|]
argument_list|,
name|isoout
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the set of expressions that are redundant in a block.  They are    the expressions that are used in the block and that are neither isolated    or latest.  */
end_comment

begin_function
specifier|static
name|void
name|compute_redundant
parameter_list|(
name|n_blocks
parameter_list|,
name|n_exprs
parameter_list|,
name|antloc
parameter_list|,
name|latein
parameter_list|,
name|isoout
parameter_list|,
name|redundant
parameter_list|)
name|int
name|n_blocks
decl_stmt|;
name|int
name|n_exprs
decl_stmt|;
name|sbitmap
modifier|*
name|antloc
decl_stmt|;
name|sbitmap
modifier|*
name|latein
decl_stmt|;
name|sbitmap
modifier|*
name|isoout
decl_stmt|;
name|sbitmap
modifier|*
name|redundant
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|;
name|sbitmap
name|temp_bitmap
decl_stmt|;
name|temp_bitmap
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|sbitmap_a_or_b
argument_list|(
name|temp_bitmap
argument_list|,
name|latein
index|[
name|bb
index|]
argument_list|,
name|isoout
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|sbitmap_difference
argument_list|(
name|redundant
index|[
name|bb
index|]
argument_list|,
name|antloc
index|[
name|bb
index|]
argument_list|,
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute expression availability at entrance and exit of each block.  */
end_comment

begin_function
specifier|static
name|void
name|compute_avinout
parameter_list|(
name|n_blocks
parameter_list|,
name|s_preds
parameter_list|,
name|avloc
parameter_list|,
name|transp
parameter_list|,
name|avin
parameter_list|,
name|avout
parameter_list|)
name|int
name|n_blocks
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
name|sbitmap
modifier|*
name|avloc
decl_stmt|;
name|sbitmap
modifier|*
name|transp
decl_stmt|;
name|sbitmap
modifier|*
name|avin
decl_stmt|;
name|sbitmap
modifier|*
name|avout
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|,
name|passes
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|avin
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sbitmap_vector_ones
argument_list|(
name|avout
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_blocks
condition|;
name|bb
operator|++
control|)
block|{
if|if
condition|(
name|bb
operator|!=
literal|0
condition|)
name|sbitmap_intersect_of_predecessors
argument_list|(
name|avin
index|[
name|bb
index|]
argument_list|,
name|avout
argument_list|,
name|bb
argument_list|,
name|s_preds
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_a_or_b_and_c
argument_list|(
name|avout
index|[
name|bb
index|]
argument_list|,
name|avloc
index|[
name|bb
index|]
argument_list|,
name|transp
index|[
name|bb
index|]
argument_list|,
name|avin
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
name|passes
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute expression latestness.     This is effectively the same as earliestness computed on the reverse    flow graph.  */
end_comment

begin_function
specifier|static
name|void
name|compute_fartherinout
parameter_list|(
name|n_blocks
parameter_list|,
name|n_exprs
parameter_list|,
name|s_succs
parameter_list|,
name|transp
parameter_list|,
name|avout
parameter_list|,
name|fartherin
parameter_list|,
name|fartherout
parameter_list|)
name|int
name|n_blocks
decl_stmt|;
name|int
name|n_exprs
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
name|sbitmap
modifier|*
name|transp
decl_stmt|;
name|sbitmap
modifier|*
name|avout
decl_stmt|;
name|sbitmap
modifier|*
name|fartherin
decl_stmt|;
name|sbitmap
modifier|*
name|fartherout
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|,
name|passes
decl_stmt|;
name|sbitmap
name|temp_bitmap
decl_stmt|;
name|temp_bitmap
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|fartherin
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|fartherout
index|[
name|n_blocks
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|n_blocks
operator|-
literal|1
init|;
name|bb
operator|>=
literal|0
condition|;
name|bb
operator|--
control|)
block|{
if|if
condition|(
name|bb
operator|!=
name|n_blocks
operator|-
literal|1
condition|)
name|sbitmap_union_of_successors
argument_list|(
name|fartherout
index|[
name|bb
index|]
argument_list|,
name|fartherin
argument_list|,
name|bb
argument_list|,
name|s_succs
argument_list|)
expr_stmt|;
name|sbitmap_not
argument_list|(
name|temp_bitmap
argument_list|,
name|transp
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_union_of_diff
argument_list|(
name|fartherin
index|[
name|bb
index|]
argument_list|,
name|temp_bitmap
argument_list|,
name|fartherout
index|[
name|bb
index|]
argument_list|,
name|avout
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
name|passes
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute expression earlierness at entrance and exit of each block.     This is effectively the same as delayedness computed on the reverse    flow graph.  */
end_comment

begin_function
specifier|static
name|void
name|compute_earlierinout
parameter_list|(
name|n_blocks
parameter_list|,
name|n_exprs
parameter_list|,
name|s_succs
parameter_list|,
name|avloc
parameter_list|,
name|avout
parameter_list|,
name|fartherout
parameter_list|,
name|earlierin
parameter_list|,
name|earlierout
parameter_list|)
name|int
name|n_blocks
decl_stmt|;
name|int
name|n_exprs
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
name|sbitmap
modifier|*
name|avloc
decl_stmt|;
name|sbitmap
modifier|*
name|avout
decl_stmt|;
name|sbitmap
modifier|*
name|fartherout
decl_stmt|;
name|sbitmap
modifier|*
name|earlierin
decl_stmt|;
name|sbitmap
modifier|*
name|earlierout
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|,
name|passes
decl_stmt|;
name|sbitmap
modifier|*
name|av_and_farther
decl_stmt|;
name|sbitmap
name|temp_bitmap
decl_stmt|;
name|temp_bitmap
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
comment|/* This is constant throughout the flow equations below, so compute      it once to save time.  */
name|av_and_farther
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_blocks
condition|;
name|bb
operator|++
control|)
name|sbitmap_a_and_b
argument_list|(
name|av_and_farther
index|[
name|bb
index|]
argument_list|,
name|avout
index|[
name|bb
index|]
argument_list|,
name|fartherout
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|earlierin
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
name|sbitmap_copy
argument_list|(
name|earlierout
index|[
name|n_blocks
operator|-
literal|1
index|]
argument_list|,
name|av_and_farther
index|[
name|n_blocks
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|n_blocks
operator|-
literal|1
init|;
name|bb
operator|>=
literal|0
condition|;
name|bb
operator|--
control|)
block|{
if|if
condition|(
name|bb
operator|!=
name|n_blocks
operator|-
literal|1
condition|)
block|{
name|sbitmap_intersect_of_successors
argument_list|(
name|temp_bitmap
argument_list|,
name|earlierin
argument_list|,
name|bb
argument_list|,
name|s_succs
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_a_or_b
argument_list|(
name|earlierout
index|[
name|bb
index|]
argument_list|,
name|av_and_farther
index|[
name|bb
index|]
argument_list|,
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
name|sbitmap_not
argument_list|(
name|temp_bitmap
argument_list|,
name|avloc
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_a_and_b
argument_list|(
name|earlierin
index|[
name|bb
index|]
argument_list|,
name|temp_bitmap
argument_list|,
name|earlierout
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
name|passes
operator|++
expr_stmt|;
block|}
comment|/* We're done with this, so go ahead and free it's memory now instead      of waiting until the end of pre.  */
name|free
argument_list|(
name|av_and_farther
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute firstness.      This is effectively the same as latestness computed on the reverse    flow graph.  */
end_comment

begin_function
specifier|static
name|void
name|compute_firstout
parameter_list|(
name|n_blocks
parameter_list|,
name|n_exprs
parameter_list|,
name|s_preds
parameter_list|,
name|avloc
parameter_list|,
name|earlierout
parameter_list|,
name|firstout
parameter_list|)
name|int
name|n_blocks
decl_stmt|;
name|int
name|n_exprs
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
name|sbitmap
modifier|*
name|avloc
decl_stmt|;
name|sbitmap
modifier|*
name|earlierout
decl_stmt|;
name|sbitmap
modifier|*
name|firstout
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|;
name|sbitmap
name|temp_bitmap
decl_stmt|;
name|temp_bitmap
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_blocks
condition|;
name|bb
operator|++
control|)
block|{
comment|/* The first block is preceded only by the entry block; therefore, 	 temp_bitmap will not be set by the following call!  */
if|if
condition|(
name|bb
operator|!=
literal|0
condition|)
block|{
name|sbitmap_intersect_of_predecessors
argument_list|(
name|temp_bitmap
argument_list|,
name|earlierout
argument_list|,
name|bb
argument_list|,
name|s_preds
argument_list|)
expr_stmt|;
name|sbitmap_not
argument_list|(
name|temp_bitmap
argument_list|,
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbitmap_ones
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
name|sbitmap_a_and_b_or_c
argument_list|(
name|firstout
index|[
name|bb
index|]
argument_list|,
name|earlierout
index|[
name|bb
index|]
argument_list|,
name|avloc
index|[
name|bb
index|]
argument_list|,
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute reverse isolated.     This is effectively the same as isolatedness computed on the reverse    flow graph.  */
end_comment

begin_function
specifier|static
name|void
name|compute_rev_isoinout
parameter_list|(
name|n_blocks
parameter_list|,
name|s_preds
parameter_list|,
name|avloc
parameter_list|,
name|firstout
parameter_list|,
name|rev_isoin
parameter_list|,
name|rev_isoout
parameter_list|)
name|int
name|n_blocks
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
name|sbitmap
modifier|*
name|avloc
decl_stmt|;
name|sbitmap
modifier|*
name|firstout
decl_stmt|;
name|sbitmap
modifier|*
name|rev_isoin
decl_stmt|;
name|sbitmap
modifier|*
name|rev_isoout
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|,
name|passes
decl_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|rev_isoout
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|rev_isoin
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_blocks
condition|;
name|bb
operator|++
control|)
block|{
if|if
condition|(
name|bb
operator|!=
literal|0
condition|)
name|sbitmap_intersect_of_predecessors
argument_list|(
name|rev_isoin
index|[
name|bb
index|]
argument_list|,
name|rev_isoout
argument_list|,
name|bb
argument_list|,
name|s_preds
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_union_of_diff
argument_list|(
name|rev_isoout
index|[
name|bb
index|]
argument_list|,
name|firstout
index|[
name|bb
index|]
argument_list|,
name|rev_isoin
index|[
name|bb
index|]
argument_list|,
name|avloc
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
name|passes
operator|++
expr_stmt|;
block|}
block|}
end_function

end_unit

