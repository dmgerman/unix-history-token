begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Hash tables.    Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"hashtable.h"
end_include

begin_comment
comment|/* The code below is a specialization of Vladimir Makarov's expandable    hash tables (see libiberty/hashtab.c).  The abstraction penalty was    too high to continue using the generic form.  This code knows    intrinsically how to calculate a hash value, and how to compare an    existing entry with a potential new one.  Also, the ability to    delete members from the table has been removed.  */
end_comment

begin_function_decl
specifier|static
name|unsigned
name|int
name|calc_hash
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ht_expand
parameter_list|(
name|hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|approx_sqrt
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Calculate the hash of the string STR of length LEN.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|calc_hash
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|n
init|=
name|len
decl_stmt|;
name|unsigned
name|int
name|r
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|HASHSTEP
parameter_list|(
name|r
parameter_list|,
name|c
parameter_list|)
value|((r) * 67 + ((c) - 113));
while|while
condition|(
name|n
operator|--
condition|)
name|r
operator|=
name|HASHSTEP
argument_list|(
name|r
argument_list|,
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
return|return
name|r
operator|+
name|len
return|;
undef|#
directive|undef
name|HASHSTEP
block|}
end_function

begin_comment
comment|/* Initialize an identifier hashtable.  */
end_comment

begin_function
name|hash_table
modifier|*
name|ht_create
parameter_list|(
name|unsigned
name|int
name|order
parameter_list|)
block|{
name|unsigned
name|int
name|nslots
init|=
literal|1
operator|<<
name|order
decl_stmt|;
name|hash_table
modifier|*
name|table
decl_stmt|;
name|table
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|hash_table
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Strings need no alignment.  */
name|_obstack_begin
argument_list|(
operator|&
name|table
operator|->
name|stack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
call|(
modifier|*
call|)
argument_list|(
name|long
argument_list|)
operator|)
name|xmalloc
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|free
argument_list|)
expr_stmt|;
name|obstack_alignment_mask
argument_list|(
operator|&
name|table
operator|->
name|stack
argument_list|)
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|entries
operator|=
name|xcalloc
argument_list|(
name|nslots
argument_list|,
sizeof|sizeof
argument_list|(
name|hashnode
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|->
name|nslots
operator|=
name|nslots
expr_stmt|;
return|return
name|table
return|;
block|}
end_function

begin_comment
comment|/* Frees all memory associated with a hash table.  */
end_comment

begin_function
name|void
name|ht_destroy
parameter_list|(
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|obstack_free
argument_list|(
operator|&
name|table
operator|->
name|stack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
operator|->
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the hash entry for the a STR of length LEN.  If that string    already exists in the table, returns the existing entry, and, if    INSERT is CPP_ALLOCED, frees the last obstack object.  If the    identifier hasn't been seen before, and INSERT is CPP_NO_INSERT,    returns NULL.  Otherwise insert and returns a new entry.  A new    string is alloced if INSERT is CPP_ALLOC, otherwise INSERT is    CPP_ALLOCED and the item is assumed to be at the top of the    obstack.  */
end_comment

begin_function
name|hashnode
name|ht_lookup
parameter_list|(
name|hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|,
name|enum
name|ht_lookup_option
name|insert
parameter_list|)
block|{
name|unsigned
name|int
name|hash
init|=
name|calc_hash
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|hash2
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|size_t
name|sizemask
decl_stmt|;
name|hashnode
name|node
decl_stmt|;
name|sizemask
operator|=
name|table
operator|->
name|nslots
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|hash
operator|&
name|sizemask
expr_stmt|;
name|table
operator|->
name|searches
operator|++
expr_stmt|;
name|node
operator|=
name|table
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|hash_value
operator|==
name|hash
operator|&&
name|HT_LEN
argument_list|(
name|node
argument_list|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|HT_STR
argument_list|(
name|node
argument_list|)
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|insert
operator|==
name|HT_ALLOCED
condition|)
comment|/* The string we search for was placed at the end of the 	       obstack.  Release it.  */
name|obstack_free
argument_list|(
operator|&
name|table
operator|->
name|stack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
comment|/* hash2 must be odd, so we're guaranteed to visit every possible 	 location in the table during rehashing.  */
name|hash2
operator|=
operator|(
operator|(
name|hash
operator|*
literal|17
operator|)
operator|&
name|sizemask
operator|)
operator||
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|table
operator|->
name|collisions
operator|++
expr_stmt|;
name|index
operator|=
operator|(
name|index
operator|+
name|hash2
operator|)
operator|&
name|sizemask
expr_stmt|;
name|node
operator|=
name|table
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|node
operator|->
name|hash_value
operator|==
name|hash
operator|&&
name|HT_LEN
argument_list|(
name|node
argument_list|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|HT_STR
argument_list|(
name|node
argument_list|)
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|insert
operator|==
name|HT_ALLOCED
condition|)
comment|/* The string we search for was placed at the end of the 		 obstack.  Release it.  */
name|obstack_free
argument_list|(
operator|&
name|table
operator|->
name|stack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
block|}
block|}
if|if
condition|(
name|insert
operator|==
name|HT_NO_INSERT
condition|)
return|return
name|NULL
return|;
name|node
operator|=
call|(
modifier|*
name|table
operator|->
name|alloc_node
call|)
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|table
operator|->
name|entries
index|[
name|index
index|]
operator|=
name|node
expr_stmt|;
name|HT_LEN
argument_list|(
name|node
argument_list|)
operator|=
operator|(
name|unsigned
name|int
operator|)
name|len
expr_stmt|;
name|node
operator|->
name|hash_value
operator|=
name|hash
expr_stmt|;
if|if
condition|(
name|insert
operator|==
name|HT_ALLOC
condition|)
name|HT_STR
argument_list|(
name|node
argument_list|)
operator|=
name|obstack_copy0
argument_list|(
operator|&
name|table
operator|->
name|stack
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|HT_STR
argument_list|(
name|node
argument_list|)
operator|=
name|str
expr_stmt|;
if|if
condition|(
operator|++
name|table
operator|->
name|nelements
operator|*
literal|4
operator|>=
name|table
operator|->
name|nslots
operator|*
literal|3
condition|)
comment|/* Must expand the string table.  */
name|ht_expand
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Double the size of a hash table, re-hashing existing entries.  */
end_comment

begin_function
specifier|static
name|void
name|ht_expand
parameter_list|(
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|hashnode
modifier|*
name|nentries
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|,
name|sizemask
decl_stmt|;
name|size
operator|=
name|table
operator|->
name|nslots
operator|*
literal|2
expr_stmt|;
name|nentries
operator|=
name|xcalloc
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hashnode
argument_list|)
argument_list|)
expr_stmt|;
name|sizemask
operator|=
name|size
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|table
operator|->
name|entries
expr_stmt|;
name|limit
operator|=
name|p
operator|+
name|table
operator|->
name|nslots
expr_stmt|;
do|do
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|unsigned
name|int
name|index
decl_stmt|,
name|hash
decl_stmt|,
name|hash2
decl_stmt|;
name|hash
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|hash_value
expr_stmt|;
name|index
operator|=
name|hash
operator|&
name|sizemask
expr_stmt|;
if|if
condition|(
name|nentries
index|[
name|index
index|]
condition|)
block|{
name|hash2
operator|=
operator|(
operator|(
name|hash
operator|*
literal|17
operator|)
operator|&
name|sizemask
operator|)
operator||
literal|1
expr_stmt|;
do|do
block|{
name|index
operator|=
operator|(
name|index
operator|+
name|hash2
operator|)
operator|&
name|sizemask
expr_stmt|;
block|}
do|while
condition|(
name|nentries
index|[
name|index
index|]
condition|)
do|;
block|}
name|nentries
index|[
name|index
index|]
operator|=
operator|*
name|p
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|p
operator|<
name|limit
condition|)
do|;
name|free
argument_list|(
name|table
operator|->
name|entries
argument_list|)
expr_stmt|;
name|table
operator|->
name|entries
operator|=
name|nentries
expr_stmt|;
name|table
operator|->
name|nslots
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For all nodes in TABLE, callback CB with parameters TABLE->PFILE,    the node, and V.  */
end_comment

begin_function
name|void
name|ht_forall
parameter_list|(
name|hash_table
modifier|*
name|table
parameter_list|,
name|ht_cb
name|cb
parameter_list|,
specifier|const
name|void
modifier|*
name|v
parameter_list|)
block|{
name|hashnode
modifier|*
name|p
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
name|p
operator|=
name|table
operator|->
name|entries
expr_stmt|;
name|limit
operator|=
name|p
operator|+
name|table
operator|->
name|nslots
expr_stmt|;
do|do
if|if
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|cb
call|)
argument_list|(
name|table
operator|->
name|pfile
argument_list|,
operator|*
name|p
argument_list|,
name|v
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
do|while
condition|(
operator|++
name|p
operator|<
name|limit
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Dump allocation statistics to stderr.  */
end_comment

begin_function
name|void
name|ht_dump_statistics
parameter_list|(
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|size_t
name|nelts
decl_stmt|,
name|nids
decl_stmt|,
name|overhead
decl_stmt|,
name|headers
decl_stmt|;
name|size_t
name|total_bytes
decl_stmt|,
name|longest
decl_stmt|,
name|sum_of_squares
decl_stmt|;
name|double
name|exp_len
decl_stmt|,
name|exp_len2
decl_stmt|,
name|exp2_len
decl_stmt|;
name|hashnode
modifier|*
name|p
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
define|#
directive|define
name|SCALE
parameter_list|(
name|x
parameter_list|)
value|((unsigned long) ((x)< 1024*10 \ 		  ? (x) \ 		  : ((x)< 1024*1024*10 \ 		     ? (x) / 1024 \ 		     : (x) / (1024*1024))))
define|#
directive|define
name|LABEL
parameter_list|(
name|x
parameter_list|)
value|((x)< 1024*10 ? ' ' : ((x)< 1024*1024*10 ? 'k' : 'M'))
name|total_bytes
operator|=
name|longest
operator|=
name|sum_of_squares
operator|=
name|nids
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|table
operator|->
name|entries
expr_stmt|;
name|limit
operator|=
name|p
operator|+
name|table
operator|->
name|nslots
expr_stmt|;
do|do
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|size_t
name|n
init|=
name|HT_LEN
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
name|total_bytes
operator|+=
name|n
expr_stmt|;
name|sum_of_squares
operator|+=
name|n
operator|*
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|longest
condition|)
name|longest
operator|=
name|n
expr_stmt|;
name|nids
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|p
operator|<
name|limit
condition|)
do|;
name|nelts
operator|=
name|table
operator|->
name|nelements
expr_stmt|;
name|overhead
operator|=
name|obstack_memory_used
argument_list|(
operator|&
name|table
operator|->
name|stack
argument_list|)
operator|-
name|total_bytes
expr_stmt|;
name|headers
operator|=
name|table
operator|->
name|nslots
operator|*
sizeof|sizeof
argument_list|(
name|hashnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nString pool\nentries\t\t%lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|nelts
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"identifiers\t%lu (%.2f%%)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|nids
argument_list|,
name|nids
operator|*
literal|100.0
operator|/
name|nelts
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"slots\t\t%lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|table
operator|->
name|nslots
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bytes\t\t%lu%c (%lu%c overhead)\n"
argument_list|,
name|SCALE
argument_list|(
name|total_bytes
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|total_bytes
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|overhead
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|overhead
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"table size\t%lu%c\n"
argument_list|,
name|SCALE
argument_list|(
name|headers
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|headers
argument_list|)
argument_list|)
expr_stmt|;
name|exp_len
operator|=
operator|(
name|double
operator|)
name|total_bytes
operator|/
operator|(
name|double
operator|)
name|nelts
expr_stmt|;
name|exp2_len
operator|=
name|exp_len
operator|*
name|exp_len
expr_stmt|;
name|exp_len2
operator|=
operator|(
name|double
operator|)
name|sum_of_squares
operator|/
operator|(
name|double
operator|)
name|nelts
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"coll/search\t%.4f\n"
argument_list|,
operator|(
name|double
operator|)
name|table
operator|->
name|collisions
operator|/
operator|(
name|double
operator|)
name|table
operator|->
name|searches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ins/search\t%.4f\n"
argument_list|,
operator|(
name|double
operator|)
name|nelts
operator|/
operator|(
name|double
operator|)
name|table
operator|->
name|searches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"avg. entry\t%.2f bytes (+/- %.2f)\n"
argument_list|,
name|exp_len
argument_list|,
name|approx_sqrt
argument_list|(
name|exp_len2
operator|-
name|exp2_len
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"longest entry\t%lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|longest
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SCALE
undef|#
directive|undef
name|LABEL
block|}
end_function

begin_comment
comment|/* Return the approximate positive square root of a number N.  This is for    statistical reports, not code generation.  */
end_comment

begin_function
specifier|static
name|double
name|approx_sqrt
parameter_list|(
name|double
name|x
parameter_list|)
block|{
name|double
name|s
decl_stmt|,
name|d
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|x
expr_stmt|;
do|do
block|{
name|d
operator|=
operator|(
name|s
operator|*
name|s
operator|-
name|x
operator|)
operator|/
operator|(
literal|2
operator|*
name|s
operator|)
expr_stmt|;
name|s
operator|-=
name|d
expr_stmt|;
block|}
do|while
condition|(
name|d
operator|>
literal|.0001
condition|)
do|;
return|return
name|s
return|;
block|}
end_function

end_unit

