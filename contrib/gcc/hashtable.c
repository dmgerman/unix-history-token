begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Hash tables.    Copyright (C) 2000, 2001 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"hashtable.h"
end_include

begin_comment
comment|/* The code below is a specialization of Vladimir Makarov's expandable    hash tables (see libiberty/hashtab.c).  The abstraction penalty was    too high to continue using the generic form.  This code knows    intrinsically how to calculate a hash value, and how to compare an    existing entry with a potential new one.  Also, the ability to    delete members from the table has been removed.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|calc_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ht_expand
name|PARAMS
argument_list|(
operator|(
name|hash_table
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Let particular systems override the size of a chunk.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBSTACK_CHUNK_SIZE
end_ifndef

begin_define
define|#
directive|define
name|OBSTACK_CHUNK_SIZE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Let them override the alloc and free routines too.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBSTACK_CHUNK_ALLOC
end_ifndef

begin_define
define|#
directive|define
name|OBSTACK_CHUNK_ALLOC
value|xmalloc
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OBSTACK_CHUNK_FREE
end_ifndef

begin_define
define|#
directive|define
name|OBSTACK_CHUNK_FREE
value|free
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialize an obstack.  */
end_comment

begin_function
name|void
name|gcc_obstack_init
parameter_list|(
name|obstack
parameter_list|)
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|_obstack_begin
argument_list|(
name|obstack
argument_list|,
name|OBSTACK_CHUNK_SIZE
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|(
operator|*
operator|)
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
operator|)
name|OBSTACK_CHUNK_ALLOC
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
operator|)
name|OBSTACK_CHUNK_FREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculate the hash of the string STR of length LEN.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|calc_hash
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
block|{
name|unsigned
name|int
name|n
init|=
name|len
decl_stmt|;
name|unsigned
name|int
name|r
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|HASHSTEP
parameter_list|(
name|r
parameter_list|,
name|c
parameter_list|)
value|((r) * 67 + ((c) - 113));
while|while
condition|(
name|n
operator|--
condition|)
name|r
operator|=
name|HASHSTEP
argument_list|(
name|r
argument_list|,
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
return|return
name|r
operator|+
name|len
return|;
undef|#
directive|undef
name|HASHSTEP
block|}
end_function

begin_comment
comment|/* Initialize an identifier hashtable.  */
end_comment

begin_function
name|hash_table
modifier|*
name|ht_create
parameter_list|(
name|order
parameter_list|)
name|unsigned
name|int
name|order
decl_stmt|;
block|{
name|unsigned
name|int
name|nslots
init|=
literal|1
operator|<<
name|order
decl_stmt|;
name|hash_table
modifier|*
name|table
decl_stmt|;
name|table
operator|=
operator|(
name|hash_table
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hash_table
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|table
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hash_table
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Strings need no alignment.  */
name|gcc_obstack_init
argument_list|(
operator|&
name|table
operator|->
name|stack
argument_list|)
expr_stmt|;
name|obstack_alignment_mask
argument_list|(
operator|&
name|table
operator|->
name|stack
argument_list|)
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|entries
operator|=
operator|(
name|hashnode
operator|*
operator|)
name|xcalloc
argument_list|(
name|nslots
argument_list|,
sizeof|sizeof
argument_list|(
name|hashnode
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|->
name|nslots
operator|=
name|nslots
expr_stmt|;
return|return
name|table
return|;
block|}
end_function

begin_comment
comment|/* Frees all memory associated with a hash table.  */
end_comment

begin_function
name|void
name|ht_destroy
parameter_list|(
name|table
parameter_list|)
name|hash_table
modifier|*
name|table
decl_stmt|;
block|{
name|obstack_free
argument_list|(
operator|&
name|table
operator|->
name|stack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
operator|->
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the hash entry for the a STR of length LEN.  If that string    already exists in the table, returns the existing entry, and, if    INSERT is CPP_ALLOCED, frees the last obstack object.  If the    identifier hasn't been seen before, and INSERT is CPP_NO_INSERT,    returns NULL.  Otherwise insert and returns a new entry.  A new    string is alloced if INSERT is CPP_ALLOC, otherwise INSERT is    CPP_ALLOCED and the item is assumed to be at the top of the    obstack.  */
end_comment

begin_function
name|hashnode
name|ht_lookup
parameter_list|(
name|table
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|,
name|insert
parameter_list|)
name|hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|enum
name|ht_lookup_option
name|insert
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
init|=
name|calc_hash
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|hash2
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|size_t
name|sizemask
decl_stmt|;
name|hashnode
name|node
decl_stmt|;
name|sizemask
operator|=
name|table
operator|->
name|nslots
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|hash
operator|&
name|sizemask
expr_stmt|;
comment|/* hash2 must be odd, so we're guaranteed to visit every possible      location in the table during rehashing.  */
name|hash2
operator|=
operator|(
operator|(
name|hash
operator|*
literal|17
operator|)
operator|&
name|sizemask
operator|)
operator||
literal|1
expr_stmt|;
name|table
operator|->
name|searches
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|node
operator|=
name|table
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|node
operator|->
name|hash_value
operator|==
name|hash
operator|&&
name|HT_LEN
argument_list|(
name|node
argument_list|)
operator|==
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|HT_STR
argument_list|(
name|node
argument_list|)
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|insert
operator|==
name|HT_ALLOCED
condition|)
comment|/* The string we search for was placed at the end of the 	       obstack.  Release it.  */
name|obstack_free
argument_list|(
operator|&
name|table
operator|->
name|stack
argument_list|,
operator|(
name|PTR
operator|)
name|str
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
name|index
operator|=
operator|(
name|index
operator|+
name|hash2
operator|)
operator|&
name|sizemask
expr_stmt|;
name|table
operator|->
name|collisions
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|insert
operator|==
name|HT_NO_INSERT
condition|)
return|return
name|NULL
return|;
name|node
operator|=
call|(
modifier|*
name|table
operator|->
name|alloc_node
call|)
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|table
operator|->
name|entries
index|[
name|index
index|]
operator|=
name|node
expr_stmt|;
name|HT_LEN
argument_list|(
name|node
argument_list|)
operator|=
name|len
expr_stmt|;
name|node
operator|->
name|hash_value
operator|=
name|hash
expr_stmt|;
if|if
condition|(
name|insert
operator|==
name|HT_ALLOC
condition|)
name|HT_STR
argument_list|(
name|node
argument_list|)
operator|=
name|obstack_copy0
argument_list|(
operator|&
name|table
operator|->
name|stack
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|HT_STR
argument_list|(
name|node
argument_list|)
operator|=
name|str
expr_stmt|;
if|if
condition|(
operator|++
name|table
operator|->
name|nelements
operator|*
literal|4
operator|>=
name|table
operator|->
name|nslots
operator|*
literal|3
condition|)
comment|/* Must expand the string table.  */
name|ht_expand
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Double the size of a hash table, re-hashing existing entries.  */
end_comment

begin_function
specifier|static
name|void
name|ht_expand
parameter_list|(
name|table
parameter_list|)
name|hash_table
modifier|*
name|table
decl_stmt|;
block|{
name|hashnode
modifier|*
name|nentries
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|,
name|sizemask
decl_stmt|;
name|size
operator|=
name|table
operator|->
name|nslots
operator|*
literal|2
expr_stmt|;
name|nentries
operator|=
operator|(
name|hashnode
operator|*
operator|)
name|xcalloc
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|hashnode
argument_list|)
argument_list|)
expr_stmt|;
name|sizemask
operator|=
name|size
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|table
operator|->
name|entries
expr_stmt|;
name|limit
operator|=
name|p
operator|+
name|table
operator|->
name|nslots
expr_stmt|;
do|do
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|unsigned
name|int
name|index
decl_stmt|,
name|hash
decl_stmt|,
name|hash2
decl_stmt|;
name|hash
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|hash_value
expr_stmt|;
name|hash2
operator|=
operator|(
operator|(
name|hash
operator|*
literal|17
operator|)
operator|&
name|sizemask
operator|)
operator||
literal|1
expr_stmt|;
name|index
operator|=
name|hash
operator|&
name|sizemask
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|nentries
index|[
name|index
index|]
condition|)
block|{
name|nentries
index|[
name|index
index|]
operator|=
operator|*
name|p
expr_stmt|;
break|break;
block|}
name|index
operator|=
operator|(
name|index
operator|+
name|hash2
operator|)
operator|&
name|sizemask
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|p
operator|<
name|limit
condition|)
do|;
name|free
argument_list|(
name|table
operator|->
name|entries
argument_list|)
expr_stmt|;
name|table
operator|->
name|entries
operator|=
name|nentries
expr_stmt|;
name|table
operator|->
name|nslots
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For all nodes in TABLE, callback CB with parameters TABLE->PFILE,    the node, and V.  */
end_comment

begin_function
name|void
name|ht_forall
parameter_list|(
name|table
parameter_list|,
name|cb
parameter_list|,
name|v
parameter_list|)
name|hash_table
modifier|*
name|table
decl_stmt|;
name|ht_cb
name|cb
decl_stmt|;
specifier|const
name|PTR
name|v
decl_stmt|;
block|{
name|hashnode
modifier|*
name|p
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
name|p
operator|=
name|table
operator|->
name|entries
expr_stmt|;
name|limit
operator|=
name|p
operator|+
name|table
operator|->
name|nslots
expr_stmt|;
do|do
if|if
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|cb
call|)
argument_list|(
name|table
operator|->
name|pfile
argument_list|,
operator|*
name|p
argument_list|,
name|v
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
do|while
condition|(
operator|++
name|p
operator|<
name|limit
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Dump allocation statistics to stderr.  */
end_comment

begin_function
name|void
name|ht_dump_statistics
parameter_list|(
name|table
parameter_list|)
name|hash_table
modifier|*
name|table
decl_stmt|;
block|{
name|size_t
name|nelts
decl_stmt|,
name|nids
decl_stmt|,
name|overhead
decl_stmt|,
name|headers
decl_stmt|;
name|size_t
name|total_bytes
decl_stmt|,
name|longest
decl_stmt|,
name|sum_of_squares
decl_stmt|;
name|double
name|exp_len
decl_stmt|,
name|exp_len2
decl_stmt|,
name|exp2_len
decl_stmt|;
name|hashnode
modifier|*
name|p
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
define|#
directive|define
name|SCALE
parameter_list|(
name|x
parameter_list|)
value|((unsigned long) ((x)< 1024*10 \ 		  ? (x) \ 		  : ((x)< 1024*1024*10 \ 		     ? (x) / 1024 \ 		     : (x) / (1024*1024))))
define|#
directive|define
name|LABEL
parameter_list|(
name|x
parameter_list|)
value|((x)< 1024*10 ? ' ' : ((x)< 1024*1024*10 ? 'k' : 'M'))
name|total_bytes
operator|=
name|longest
operator|=
name|sum_of_squares
operator|=
name|nids
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|table
operator|->
name|entries
expr_stmt|;
name|limit
operator|=
name|p
operator|+
name|table
operator|->
name|nslots
expr_stmt|;
do|do
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|size_t
name|n
init|=
name|HT_LEN
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
name|total_bytes
operator|+=
name|n
expr_stmt|;
name|sum_of_squares
operator|+=
name|n
operator|*
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|longest
condition|)
name|longest
operator|=
name|n
expr_stmt|;
name|nids
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|p
operator|<
name|limit
condition|)
do|;
name|nelts
operator|=
name|table
operator|->
name|nelements
expr_stmt|;
name|overhead
operator|=
name|obstack_memory_used
argument_list|(
operator|&
name|table
operator|->
name|stack
argument_list|)
operator|-
name|total_bytes
expr_stmt|;
name|headers
operator|=
name|table
operator|->
name|nslots
operator|*
sizeof|sizeof
argument_list|(
name|hashnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nString pool\nentries\t\t%lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|nelts
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"identifiers\t%lu (%.2f%%)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|nids
argument_list|,
name|nids
operator|*
literal|100.0
operator|/
name|nelts
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"slots\t\t%lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|table
operator|->
name|nslots
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bytes\t\t%lu%c (%lu%c overhead)\n"
argument_list|,
name|SCALE
argument_list|(
name|total_bytes
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|total_bytes
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|overhead
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|overhead
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"table size\t%lu%c\n"
argument_list|,
name|SCALE
argument_list|(
name|headers
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|headers
argument_list|)
argument_list|)
expr_stmt|;
name|exp_len
operator|=
operator|(
name|double
operator|)
name|total_bytes
operator|/
operator|(
name|double
operator|)
name|nelts
expr_stmt|;
name|exp2_len
operator|=
name|exp_len
operator|*
name|exp_len
expr_stmt|;
name|exp_len2
operator|=
operator|(
name|double
operator|)
name|sum_of_squares
operator|/
operator|(
name|double
operator|)
name|nelts
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"coll/search\t%.4f\n"
argument_list|,
operator|(
name|double
operator|)
name|table
operator|->
name|collisions
operator|/
operator|(
name|double
operator|)
name|table
operator|->
name|searches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ins/search\t%.4f\n"
argument_list|,
operator|(
name|double
operator|)
name|nelts
operator|/
operator|(
name|double
operator|)
name|table
operator|->
name|searches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"avg. entry\t%.2f bytes (+/- %.2f)\n"
argument_list|,
name|exp_len
argument_list|,
name|approx_sqrt
argument_list|(
name|exp_len2
operator|-
name|exp2_len
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"longest entry\t%lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|longest
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SCALE
undef|#
directive|undef
name|LABEL
block|}
end_function

begin_comment
comment|/* Return the approximate positive square root of a number N.  This is for    statistical reports, not code generation.  */
end_comment

begin_function
name|double
name|approx_sqrt
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|s
decl_stmt|,
name|d
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|x
expr_stmt|;
do|do
block|{
name|d
operator|=
operator|(
name|s
operator|*
name|s
operator|-
name|x
operator|)
operator|/
operator|(
literal|2
operator|*
name|s
operator|)
expr_stmt|;
name|s
operator|-=
name|d
expr_stmt|;
block|}
do|while
condition|(
name|d
operator|>
literal|.0001
condition|)
do|;
return|return
name|s
return|;
block|}
end_function

end_unit

