begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction scheduling pass.  This file computes dependencies between    instructions.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,    and currently maintained by, Jim Wilson (wilson@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"cselib.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_decl_stmt
specifier|static
name|regset
name|reg_pending_sets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regset
name|reg_pending_clobbers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regset
name|reg_pending_uses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following enumeration values tell us what dependencies we    should use to implement the barrier.  We use true-dependencies for    TRUE_BARRIER and anti-dependencies for MOVE_BARRIER.  */
end_comment

begin_enum
enum|enum
name|reg_pending_barrier_mode
block|{
name|NOT_A_BARRIER
init|=
literal|0
block|,
name|MOVE_BARRIER
block|,
name|TRUE_BARRIER
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|reg_pending_barrier_mode
name|reg_pending_barrier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To speed up the test for duplicate dependency links we keep a    record of dependencies created by add_dependence when the average    number of instructions in a basic block is very large.     Studies have shown that there is typically around 5 instructions between    branches for typical C code.  So we can make a guess that the average    basic block is approximately 5 instructions long; we will choose 100X    the average size as a very large basic block.     Each insn has associated bitmaps for its dependencies.  Each bitmap    has enough entries to represent a dependency on any other insn in    the insn chain.  All bitmap for true dependencies cache is    allocated then the rest two ones are also allocated.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap_head
modifier|*
name|true_dependency_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bitmap_head
modifier|*
name|output_dependency_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bitmap_head
modifier|*
name|anti_dependency_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bitmap_head
modifier|*
name|spec_dependency_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cache_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To speed up checking consistency of formed forward insn    dependencies we use the following cache.  Another possible solution    could be switching off checking duplication of insns in forward    dependencies.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_decl_stmt
specifier|static
name|bitmap_head
modifier|*
name|forward_dependency_cache
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|deps_may_trap_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_dependence_list
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|enum
name|reg_note
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_dependence_list_and_free
parameter_list|(
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|int
parameter_list|,
name|enum
name|reg_note
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_all_dependences
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_sched_groups
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flush_pending_lists
parameter_list|(
name|struct
name|deps
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sched_analyze_1
parameter_list|(
name|struct
name|deps
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sched_analyze_2
parameter_list|(
name|struct
name|deps
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sched_analyze_insn
parameter_list|(
name|struct
name|deps
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|sched_get_condition
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|conditions_mutex_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|DEPS_ADJUST_RESULT
name|maybe_add_or_update_back_dep_1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|reg_note
parameter_list|,
name|ds_t
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|DEPS_ADJUST_RESULT
name|add_or_update_back_dep_1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|reg_note
parameter_list|,
name|ds_t
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_back_dep
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|reg_note
parameter_list|,
name|ds_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adjust_add_sorted_back_dep
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adjust_back_add_forw_dep
parameter_list|(
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_forw_dep
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_t
name|estimate_dep_weak
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_function_decl
specifier|static
name|void
name|check_dep_status
parameter_list|(
name|enum
name|reg_note
parameter_list|,
name|ds_t
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if a load of the memory reference MEM can cause a trap.  */
end_comment

begin_function
specifier|static
name|int
name|deps_may_trap_p
parameter_list|(
name|rtx
name|mem
parameter_list|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|addr
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|t
init|=
name|get_reg_known_value
argument_list|(
name|REGNO
argument_list|(
name|addr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
name|addr
operator|=
name|t
expr_stmt|;
block|}
return|return
name|rtx_addr_can_trap_p
argument_list|(
name|addr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the INSN_LIST containing INSN in LIST, or NULL    if LIST does not contain INSN.  */
end_comment

begin_function
name|rtx
name|find_insn_list
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
operator|==
name|insn
condition|)
return|return
name|list
return|;
name|list
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the condition under which INSN is executed.  */
end_comment

begin_function
specifier|static
name|rtx
name|sched_get_condition
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|src
decl_stmt|;
if|if
condition|(
name|pat
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|COND_EXEC
condition|)
return|return
name|COND_EXEC_TEST
argument_list|(
name|pat
argument_list|)
return|;
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
operator|!
name|onlyjump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
name|rtx
name|cond
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|revcode
init|=
name|reversed_comparison_code
argument_list|(
name|cond
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|revcode
operator|==
name|UNKNOWN
condition|)
return|return
literal|0
return|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|revcode
argument_list|,
name|GET_MODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if conditions COND1 and COND2 can never be both true.  */
end_comment

begin_function
specifier|static
name|int
name|conditions_mutex_p
parameter_list|(
name|rtx
name|cond1
parameter_list|,
name|rtx
name|cond2
parameter_list|)
block|{
if|if
condition|(
name|COMPARISON_P
argument_list|(
name|cond1
argument_list|)
operator|&&
name|COMPARISON_P
argument_list|(
name|cond2
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|cond1
argument_list|)
operator|==
name|reversed_comparison_code
argument_list|(
name|cond2
argument_list|,
name|NULL
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|0
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|1
argument_list|)
operator|==
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if insn1 and insn2 can never depend on one another because    the conditions under which they are executed are mutually exclusive.  */
end_comment

begin_function
name|bool
name|sched_insns_conditions_mutex_p
parameter_list|(
name|rtx
name|insn1
parameter_list|,
name|rtx
name|insn2
parameter_list|)
block|{
name|rtx
name|cond1
decl_stmt|,
name|cond2
decl_stmt|;
comment|/* flow.c doesn't handle conditional lifetimes entirely correctly;      calls mess up the conditional lifetimes.  */
if|if
condition|(
operator|!
name|CALL_P
argument_list|(
name|insn1
argument_list|)
operator|&&
operator|!
name|CALL_P
argument_list|(
name|insn2
argument_list|)
condition|)
block|{
name|cond1
operator|=
name|sched_get_condition
argument_list|(
name|insn1
argument_list|)
expr_stmt|;
name|cond2
operator|=
name|sched_get_condition
argument_list|(
name|insn2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond1
operator|&&
name|cond2
operator|&&
name|conditions_mutex_p
argument_list|(
name|cond1
argument_list|,
name|cond2
argument_list|)
comment|/* Make sure first instruction doesn't affect condition of second 	     instruction if switched.  */
operator|&&
operator|!
name|modified_in_p
argument_list|(
name|cond1
argument_list|,
name|insn2
argument_list|)
comment|/* Make sure second instruction doesn't affect condition of first 	     instruction if switched.  */
operator|&&
operator|!
name|modified_in_p
argument_list|(
name|cond2
argument_list|,
name|insn1
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the    LOG_LINKS of INSN, if it is not already there.  DEP_TYPE indicates the    type of dependence that this link represents.  DS, if nonzero,    indicates speculations, through which this dependence can be overcome.    MEM1 and MEM2, if non-null, corresponds to memory locations in case of    data speculation.  The function returns a value indicating if an old entry    has been changed or a new entry has been added to insn's LOG_LINK.    In case of changed entry CHANGED_LINKPP sets to its address.    See also the definition of enum DEPS_ADJUST_RESULT in sched-int.h.      Actual manipulation of dependence data structures is performed in     add_or_update_back_dep_1.  */
end_comment

begin_function
specifier|static
name|enum
name|DEPS_ADJUST_RESULT
name|maybe_add_or_update_back_dep_1
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|elem
parameter_list|,
name|enum
name|reg_note
name|dep_type
parameter_list|,
name|ds_t
name|ds
parameter_list|,
name|rtx
name|mem1
parameter_list|,
name|rtx
name|mem2
parameter_list|,
name|rtx
modifier|*
modifier|*
name|changed_linkpp
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|INSN_P
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't depend an insn on itself.  */
if|if
condition|(
name|insn
operator|==
name|elem
condition|)
block|{
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
condition|)
comment|/* INSN has an internal dependence, which we can't overcome.  */
name|HAS_INTERNAL_DEP
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
return|return
name|add_or_update_back_dep_1
argument_list|(
name|insn
argument_list|,
name|elem
argument_list|,
name|dep_type
argument_list|,
name|ds
argument_list|,
name|mem1
argument_list|,
name|mem2
argument_list|,
name|changed_linkpp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function has the same meaning of parameters and return values    as maybe_add_or_update_back_dep_1.  The only difference between these    two functions is that INSN and ELEM are guaranteed not to be the same    in this one.  */
end_comment

begin_function
specifier|static
name|enum
name|DEPS_ADJUST_RESULT
name|add_or_update_back_dep_1
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|elem
parameter_list|,
name|enum
name|reg_note
name|dep_type
parameter_list|,
name|ds_t
name|ds
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|mem1
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|mem2
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
modifier|*
modifier|*
name|changed_linkpp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bool
name|maybe_present_p
init|=
name|true
decl_stmt|,
name|present_p
init|=
name|false
decl_stmt|;
name|gcc_assert
argument_list|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|INSN_P
argument_list|(
name|elem
argument_list|)
operator|&&
name|insn
operator|!=
name|elem
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|check_dep_status
argument_list|(
name|dep_type
argument_list|,
name|ds
argument_list|,
name|mem1
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we already have a dependency for ELEM, then we do not need to      do anything.  Avoiding the list walk below can cut compile times      dramatically for some code.  */
if|if
condition|(
name|true_dependency_cache
operator|!=
name|NULL
condition|)
block|{
name|enum
name|reg_note
name|present_dep_type
decl_stmt|;
name|gcc_assert
argument_list|(
name|output_dependency_cache
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|anti_dependency_cache
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|current_sched_info
operator|->
name|flags
operator|&
name|USE_DEPS_LIST
operator|)
condition|)
block|{
if|if
condition|(
name|bitmap_bit_p
argument_list|(
operator|&
name|true_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
name|present_dep_type
operator|=
name|REG_DEP_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|bitmap_bit_p
argument_list|(
operator|&
name|output_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
name|present_dep_type
operator|=
name|REG_DEP_OUTPUT
expr_stmt|;
elseif|else
if|if
condition|(
name|bitmap_bit_p
argument_list|(
operator|&
name|anti_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
name|present_dep_type
operator|=
name|REG_DEP_ANTI
expr_stmt|;
else|else
name|maybe_present_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|maybe_present_p
condition|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|dep_type
operator|>=
operator|(
name|int
operator|)
name|present_dep_type
condition|)
return|return
name|DEP_PRESENT
return|;
name|present_p
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|ds_t
name|present_dep_types
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
operator|&
name|true_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
name|present_dep_types
operator||=
name|DEP_TRUE
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
operator|&
name|output_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
name|present_dep_types
operator||=
name|DEP_OUTPUT
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
operator|&
name|anti_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
name|present_dep_types
operator||=
name|DEP_ANTI
expr_stmt|;
if|if
condition|(
name|present_dep_types
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
operator|)
operator|||
operator|!
name|bitmap_bit_p
argument_list|(
operator|&
name|spec_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|present_dep_types
operator||
operator|(
name|ds
operator|&
name|DEP_TYPES
operator|)
operator|)
operator|==
name|present_dep_types
condition|)
comment|/* We already have all these bits.  */
return|return
name|DEP_PRESENT
return|;
block|}
else|else
block|{
comment|/* Only true dependencies can be data speculative and 		     only anti dependencies can be control speculative.  */
name|gcc_assert
argument_list|(
operator|(
name|present_dep_types
operator|&
operator|(
name|DEP_TRUE
operator||
name|DEP_ANTI
operator|)
operator|)
operator|==
name|present_dep_types
argument_list|)
expr_stmt|;
comment|/* if (additional dep is SPECULATIVE) then  		       we should update DEP_STATUS 		     else 		       we should reset existing dep to non-speculative.  */
block|}
name|present_p
operator|=
name|true
expr_stmt|;
block|}
else|else
name|maybe_present_p
operator|=
name|false
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Check that we don't already have this dependence.  */
if|if
condition|(
name|maybe_present_p
condition|)
block|{
name|rtx
modifier|*
name|linkp
decl_stmt|;
for|for
control|(
name|linkp
operator|=
operator|&
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
operator|*
name|linkp
condition|;
name|linkp
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|linkp
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|link
init|=
operator|*
name|linkp
decl_stmt|;
name|gcc_assert
argument_list|(
name|true_dependency_cache
operator|==
literal|0
operator|||
name|present_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|elem
condition|)
block|{
name|enum
name|DEPS_ADJUST_RESULT
name|changed_p
init|=
name|DEP_PRESENT
decl_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|USE_DEPS_LIST
condition|)
block|{
name|ds_t
name|new_status
init|=
name|ds
operator||
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_status
operator|&
name|SPECULATIVE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ds
operator|&
name|SPECULATIVE
operator|)
operator|||
operator|!
operator|(
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|&
name|SPECULATIVE
operator|)
condition|)
comment|/* Then this dep can't be speculative.  */
block|{
name|new_status
operator|&=
operator|~
name|SPECULATIVE
expr_stmt|;
if|if
condition|(
name|true_dependency_cache
operator|&&
operator|(
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|&
name|SPECULATIVE
operator|)
condition|)
name|bitmap_clear_bit
argument_list|(
operator|&
name|spec_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Both are speculative.  Merging probabilities.  */
if|if
condition|(
name|mem1
condition|)
block|{
name|dw_t
name|dw
decl_stmt|;
name|dw
operator|=
name|estimate_dep_weak
argument_list|(
name|mem1
argument_list|,
name|mem2
argument_list|)
expr_stmt|;
name|ds
operator|=
name|set_dep_weak
argument_list|(
name|ds
argument_list|,
name|BEGIN_DATA
argument_list|,
name|dw
argument_list|)
expr_stmt|;
block|}
name|new_status
operator|=
name|ds_merge
argument_list|(
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
block|}
name|ds
operator|=
name|new_status
expr_stmt|;
block|}
comment|/* Clear corresponding cache entry because type of the link                  may have changed.  Keep them if we use_deps_list.  */
if|if
condition|(
name|true_dependency_cache
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|current_sched_info
operator|->
name|flags
operator|&
name|USE_DEPS_LIST
operator|)
condition|)
block|{
name|enum
name|reg_note
name|kind
init|=
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|REG_DEP_OUTPUT
case|:
name|bitmap_clear_bit
argument_list|(
operator|&
name|output_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_DEP_ANTI
case|:
name|bitmap_clear_bit
argument_list|(
operator|&
name|anti_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|current_sched_info
operator|->
name|flags
operator|&
name|USE_DEPS_LIST
operator|)
operator|&&
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|!=
name|ds
condition|)
block|{
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|=
name|ds
expr_stmt|;
name|changed_p
operator|=
name|DEP_CHANGED
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If this is a more restrictive type of dependence than the 		 existing one, then change the existing dependence to this 		 type.  */
if|if
condition|(
operator|(
name|int
operator|)
name|dep_type
operator|<
operator|(
name|int
operator|)
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
condition|)
block|{
name|PUT_REG_NOTE_KIND
argument_list|(
name|link
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
name|changed_p
operator|=
name|DEP_CHANGED
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* If we are adding a dependency to INSN's LOG_LINKs, then                  note that in the bitmap caches of dependency information.  */
if|if
condition|(
name|true_dependency_cache
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|current_sched_info
operator|->
name|flags
operator|&
name|USE_DEPS_LIST
operator|)
condition|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_TRUE
condition|)
name|bitmap_set_bit
argument_list|(
operator|&
name|true_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_OUTPUT
condition|)
name|bitmap_set_bit
argument_list|(
operator|&
name|output_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_ANTI
condition|)
name|bitmap_set_bit
argument_list|(
operator|&
name|anti_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ds
operator|&
name|DEP_TRUE
condition|)
name|bitmap_set_bit
argument_list|(
operator|&
name|true_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|&
name|DEP_OUTPUT
condition|)
name|bitmap_set_bit
argument_list|(
operator|&
name|output_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|&
name|DEP_ANTI
condition|)
name|bitmap_set_bit
argument_list|(
operator|&
name|anti_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note, that dep can become speculative only                           at the moment of creation. Thus, we don't need to  		         check for it here.  */
block|}
block|}
if|if
condition|(
name|changed_linkpp
operator|&&
name|changed_p
operator|==
name|DEP_CHANGED
condition|)
operator|*
name|changed_linkpp
operator|=
name|linkp
expr_stmt|;
endif|#
directive|endif
return|return
name|changed_p
return|;
block|}
block|}
comment|/* We didn't find a dep. It shouldn't be present in the cache.  */
name|gcc_assert
argument_list|(
operator|!
name|present_p
argument_list|)
expr_stmt|;
block|}
comment|/* Might want to check one level of transitivity to save conses.      This check should be done in maybe_add_or_update_back_dep_1.      Since we made it to add_or_update_back_dep_1, we must create      (or update) a link.  */
if|if
condition|(
name|mem1
condition|)
block|{
name|gcc_assert
argument_list|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
argument_list|)
expr_stmt|;
name|ds
operator|=
name|set_dep_weak
argument_list|(
name|ds
argument_list|,
name|BEGIN_DATA
argument_list|,
name|estimate_dep_weak
argument_list|(
name|mem1
argument_list|,
name|mem2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|add_back_dep
argument_list|(
name|insn
argument_list|,
name|elem
argument_list|,
name|dep_type
argument_list|,
name|ds
argument_list|)
expr_stmt|;
return|return
name|DEP_CREATED
return|;
block|}
end_function

begin_comment
comment|/* This function creates a link between INSN and ELEM under any    conditions.  DS describes speculative status of the link.  */
end_comment

begin_function
specifier|static
name|void
name|add_back_dep
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|elem
parameter_list|,
name|enum
name|reg_note
name|dep_type
parameter_list|,
name|ds_t
name|ds
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|INSN_P
argument_list|(
name|elem
argument_list|)
operator|&&
name|insn
operator|!=
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|USE_DEPS_LIST
condition|)
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_DEPS_LIST
argument_list|(
name|elem
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|,
name|ds
argument_list|)
expr_stmt|;
else|else
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_INSN_LIST
argument_list|(
name|elem
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insn dependency, not data dependency.  */
name|PUT_REG_NOTE_KIND
argument_list|(
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|check_dep_status
argument_list|(
name|dep_type
argument_list|,
name|ds
argument_list|,
name|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we are adding a dependency to INSN's LOG_LINKs, then note that      in the bitmap caches of dependency information.  */
if|if
condition|(
name|true_dependency_cache
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|current_sched_info
operator|->
name|flags
operator|&
name|USE_DEPS_LIST
operator|)
condition|)
block|{
if|if
condition|(
name|dep_type
operator|==
name|REG_DEP_TRUE
condition|)
name|bitmap_set_bit
argument_list|(
operator|&
name|true_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dep_type
operator|==
name|REG_DEP_OUTPUT
condition|)
name|bitmap_set_bit
argument_list|(
operator|&
name|output_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dep_type
operator|==
name|REG_DEP_ANTI
condition|)
name|bitmap_set_bit
argument_list|(
operator|&
name|anti_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ds
operator|&
name|DEP_TRUE
condition|)
name|bitmap_set_bit
argument_list|(
operator|&
name|true_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|&
name|DEP_OUTPUT
condition|)
name|bitmap_set_bit
argument_list|(
operator|&
name|output_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|&
name|DEP_ANTI
condition|)
name|bitmap_set_bit
argument_list|(
operator|&
name|anti_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|&
name|SPECULATIVE
condition|)
block|{
name|gcc_assert
argument_list|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
operator|&
name|spec_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* A convenience wrapper to operate on an entire list.  */
end_comment

begin_function
specifier|static
name|void
name|add_dependence_list
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|list
parameter_list|,
name|int
name|uncond
parameter_list|,
name|enum
name|reg_note
name|dep_type
parameter_list|)
block|{
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|uncond
operator|||
operator|!
name|sched_insns_conditions_mutex_p
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similar, but free *LISTP at the same time.  */
end_comment

begin_function
specifier|static
name|void
name|add_dependence_list_and_free
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|listp
parameter_list|,
name|int
name|uncond
parameter_list|,
name|enum
name|reg_note
name|dep_type
parameter_list|)
block|{
name|rtx
name|list
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|list
operator|=
operator|*
name|listp
operator|,
operator|*
name|listp
operator|=
name|NULL
init|;
name|list
condition|;
name|list
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|uncond
operator|||
operator|!
name|sched_insns_conditions_mutex_p
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
name|free_INSN_LIST_node
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear all dependencies for an insn.  */
end_comment

begin_function
specifier|static
name|void
name|delete_all_dependences
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
comment|/* Clear caches, if they exist, as well as free the dependence.  */
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
if|if
condition|(
name|true_dependency_cache
operator|!=
name|NULL
condition|)
block|{
name|bitmap_clear
argument_list|(
operator|&
name|true_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
operator|&
name|output_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
operator|&
name|anti_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
expr_stmt|;
comment|/* We don't have to clear forward_dependency_cache here, 	 because it is formed later.  */
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
condition|)
name|bitmap_clear
argument_list|(
operator|&
name|spec_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|current_sched_info
operator|->
name|flags
operator|&
name|USE_DEPS_LIST
operator|)
condition|)
comment|/* In this case LOG_LINKS are formed from the DEPS_LISTs,        not the INSN_LISTs.  */
name|free_INSN_LIST_list
argument_list|(
operator|&
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|free_DEPS_LIST_list
argument_list|(
operator|&
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* All insns in a scheduling group except the first should only have    dependencies on the previous insn in the group.  So we find the    first instruction in the scheduling group by walking the dependence    chains backwards. Then we add the dependencies for the group to    the previous nonnote insn.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_sched_groups
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|,
name|prev_nonnote
decl_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|i
init|=
name|insn
decl_stmt|;
do|do
block|{
name|i
operator|=
name|prev_nonnote_insn
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|i
condition|)
goto|goto
name|next_link
goto|;
block|}
do|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|i
argument_list|)
condition|)
do|;
if|if
condition|(
operator|!
name|sched_insns_conditions_mutex_p
argument_list|(
name|i
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|i
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|next_link
label|:
empty_stmt|;
block|}
name|delete_all_dependences
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|prev_nonnote
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|==
name|BLOCK_FOR_INSN
argument_list|(
name|prev_nonnote
argument_list|)
operator|&&
operator|!
name|sched_insns_conditions_mutex_p
argument_list|(
name|insn
argument_list|,
name|prev_nonnote
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|prev_nonnote
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process an insn's memory dependencies.  There are four kinds of    dependencies:     (0) read dependence: read follows read    (1) true dependence: read follows write    (2) output dependence: write follows write    (3) anti dependence: write follows read     We are careful to build only dependencies which actually exist, and    use transitivity to avoid building too many links.  */
end_comment

begin_comment
comment|/* Add an INSN and MEM reference pair to a pending INSN_LIST and MEM_LIST.    The MEM is a memory reference contained within INSN, which we are saving    so that we can do memory aliasing on it.  */
end_comment

begin_function
specifier|static
name|void
name|add_insn_mem_dependence
parameter_list|(
name|struct
name|deps
modifier|*
name|deps
parameter_list|,
name|rtx
modifier|*
name|insn_list
parameter_list|,
name|rtx
modifier|*
name|mem_list
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|rtx
name|mem
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
name|link
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
operator|*
name|insn_list
argument_list|)
expr_stmt|;
operator|*
name|insn_list
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|use_cselib
condition|)
block|{
name|mem
operator|=
name|shallow_copy_rtx
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
operator|=
name|cselib_subst_to_values
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|link
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|canon_rtx
argument_list|(
name|mem
argument_list|)
argument_list|,
operator|*
name|mem_list
argument_list|)
expr_stmt|;
operator|*
name|mem_list
operator|=
name|link
expr_stmt|;
name|deps
operator|->
name|pending_lists_length
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a dependency between every memory reference on the pending lists    and INSN, thus flushing the pending lists.  FOR_READ is true if emitting    dependencies for a read operation, similarly with FOR_WRITE.  */
end_comment

begin_function
specifier|static
name|void
name|flush_pending_lists
parameter_list|(
name|struct
name|deps
modifier|*
name|deps
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|for_read
parameter_list|,
name|int
name|for_write
parameter_list|)
block|{
if|if
condition|(
name|for_write
condition|)
block|{
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|deps
operator|->
name|pending_read_insns
argument_list|,
literal|1
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|pending_read_mems
argument_list|)
expr_stmt|;
block|}
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|deps
operator|->
name|pending_write_insns
argument_list|,
literal|1
argument_list|,
name|for_read
condition|?
name|REG_DEP_ANTI
else|:
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|pending_write_mems
argument_list|)
expr_stmt|;
name|deps
operator|->
name|pending_lists_length
operator|=
literal|0
expr_stmt|;
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|deps
operator|->
name|last_pending_memory_flush
argument_list|,
literal|1
argument_list|,
name|for_read
condition|?
name|REG_DEP_ANTI
else|:
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|deps
operator|->
name|last_pending_memory_flush
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|deps
operator|->
name|pending_flush_length
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Analyze a single reference to register (reg:MODE REGNO) in INSN.    The type of the reference is specified by REF and can be SET,    CLOBBER, PRE_DEC, POST_DEC, PRE_INC, POST_INC or USE.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_reg
parameter_list|(
name|struct
name|deps
modifier|*
name|deps
parameter_list|,
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|rtx_code
name|ref
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
comment|/* A hard reg in a wide mode may really be multiple registers.      If so, mark all of them just like the first.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|i
init|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|mode
index|]
decl_stmt|;
if|if
condition|(
name|ref
operator|==
name|SET
condition|)
block|{
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ref
operator|==
name|USE
condition|)
block|{
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_uses
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_clobbers
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ??? Reload sometimes emits USEs and CLOBBERs of pseudos that      it does not reload.  Ignore these as they have served their      purpose already.  */
elseif|else
if|if
condition|(
name|regno
operator|>=
name|deps
operator|->
name|max_reg
condition|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|code
operator|==
name|USE
operator|||
name|code
operator|==
name|CLOBBER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ref
operator|==
name|SET
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|,
name|regno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ref
operator|==
name|USE
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_uses
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_clobbers
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Pseudos that are REG_EQUIV to something may be replaced 	 by that during reloading.  We need only add dependencies for 	the address in the REG_EQUIV note.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|get_reg_known_equiv_p
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|rtx
name|t
init|=
name|get_reg_known_value
argument_list|(
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|t
argument_list|)
condition|)
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Don't let it cross a call after scheduling if it doesn't 	 already cross one.  */
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ref
operator|==
name|USE
condition|)
name|deps
operator|->
name|sched_before_next_call
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|deps
operator|->
name|sched_before_next_call
argument_list|)
expr_stmt|;
else|else
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|deps
operator|->
name|last_function_call
argument_list|,
literal|1
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Analyze a single SET, CLOBBER, PRE_DEC, POST_DEC, PRE_INC or POST_INC    rtx, X, creating all dependencies generated by the write to the    destination of X, and reads of everything mentioned.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_1
parameter_list|(
name|struct
name|deps
modifier|*
name|deps
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|dest
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|sched_analyze_1
argument_list|(
name|deps
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|df_read_modify_subreg_p
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* These both read and modify the result.  We must handle              them as writes to get proper dependencies for following              instructions.  We must handle them as reads to get proper              dependencies from this to previous instructions.              Thus we need to call sched_analyze_2.  */
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
comment|/* The second and third arguments are values read by this insn.  */
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|sched_analyze_reg
argument_list|(
name|deps
argument_list|,
name|regno
argument_list|,
name|mode
argument_list|,
name|code
argument_list|,
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* Treat all writes to a stack register as modifying the TOS.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_STACK_REG
operator|&&
name|regno
operator|<=
name|LAST_STACK_REG
condition|)
block|{
comment|/* Avoid analyzing the same register twice.  */
if|if
condition|(
name|regno
operator|!=
name|FIRST_STACK_REG
condition|)
name|sched_analyze_reg
argument_list|(
name|deps
argument_list|,
name|FIRST_STACK_REG
argument_list|,
name|mode
argument_list|,
name|code
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_reg
argument_list|(
name|deps
argument_list|,
name|FIRST_STACK_REG
argument_list|,
name|mode
argument_list|,
name|USE
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* Writing memory.  */
name|rtx
name|t
init|=
name|dest
decl_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|use_cselib
condition|)
block|{
name|t
operator|=
name|shallow_copy_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cselib_lookup
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|cselib_subst_to_values
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|canon_rtx
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|deps
operator|->
name|pending_lists_length
operator|>
name|MAX_PENDING_LIST_LENGTH
condition|)
block|{
comment|/* Flush all pending reads and writes to prevent the pending lists 	     from getting any larger.  Insn scheduling runs too slowly when 	     these lists get long.  When compiling GCC with itself, 	     this flush occurs 8 times for sparc, and 10 times for m88k using 	     the default value of 32.  */
name|flush_pending_lists
argument_list|(
name|deps
argument_list|,
name|insn
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|pending
decl_stmt|,
name|pending_mem
decl_stmt|;
name|pending
operator|=
name|deps
operator|->
name|pending_read_insns
expr_stmt|;
name|pending_mem
operator|=
name|deps
operator|->
name|pending_read_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
if|if
condition|(
name|anti_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t
argument_list|)
operator|&&
operator|!
name|sched_insns_conditions_mutex_p
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pending
operator|=
name|deps
operator|->
name|pending_write_insns
expr_stmt|;
name|pending_mem
operator|=
name|deps
operator|->
name|pending_write_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
if|if
condition|(
name|output_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t
argument_list|)
operator|&&
operator|!
name|sched_insns_conditions_mutex_p
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|deps
operator|->
name|last_pending_memory_flush
argument_list|,
literal|1
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|add_insn_mem_dependence
argument_list|(
name|deps
argument_list|,
operator|&
name|deps
operator|->
name|pending_write_insns
argument_list|,
operator|&
name|deps
operator|->
name|pending_write_mems
argument_list|,
name|insn
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Analyze reads.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Analyze the uses of memory and registers in rtx X in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_2
parameter_list|(
name|struct
name|deps
modifier|*
name|deps
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
comment|/* Ignore constants.  Note that we must handle CONST_DOUBLE here          because it may have a cc0_rtx in its CONST_DOUBLE_CHAIN field, but          this does not mean that this insn is using cc0.  */
return|return;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
comment|/* User of CC0 depends on immediately preceding insn.  */
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't move CC0 setter to another block (it can set up the         same flag for previous CC0 users which is safe).  */
name|CANT_MOVE
argument_list|(
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|sched_analyze_reg
argument_list|(
name|deps
argument_list|,
name|regno
argument_list|,
name|mode
argument_list|,
name|USE
argument_list|,
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* Treat all reads of a stack register as modifying the TOS.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_STACK_REG
operator|&&
name|regno
operator|<=
name|LAST_STACK_REG
condition|)
block|{
comment|/* Avoid analyzing the same register twice.  */
if|if
condition|(
name|regno
operator|!=
name|FIRST_STACK_REG
condition|)
name|sched_analyze_reg
argument_list|(
name|deps
argument_list|,
name|FIRST_STACK_REG
argument_list|,
name|mode
argument_list|,
name|USE
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_reg
argument_list|(
name|deps
argument_list|,
name|FIRST_STACK_REG
argument_list|,
name|mode
argument_list|,
name|SET
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
case|case
name|MEM
case|:
block|{
comment|/* Reading memory.  */
name|rtx
name|u
decl_stmt|;
name|rtx
name|pending
decl_stmt|,
name|pending_mem
decl_stmt|;
name|rtx
name|t
init|=
name|x
decl_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|use_cselib
condition|)
block|{
name|t
operator|=
name|shallow_copy_rtx
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|cselib_lookup
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|cselib_subst_to_values
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|canon_rtx
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|pending
operator|=
name|deps
operator|->
name|pending_read_insns
expr_stmt|;
name|pending_mem
operator|=
name|deps
operator|->
name|pending_read_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
if|if
condition|(
name|read_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t
argument_list|)
operator|&&
operator|!
name|sched_insns_conditions_mutex_p
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pending
operator|=
name|deps
operator|->
name|pending_write_insns
expr_stmt|;
name|pending_mem
operator|=
name|deps
operator|->
name|pending_write_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
if|if
condition|(
name|true_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|t
argument_list|,
name|rtx_varies_p
argument_list|)
operator|&&
operator|!
name|sched_insns_conditions_mutex_p
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
condition|)
name|maybe_add_or_update_back_dep_1
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_TRUE
argument_list|,
name|BEGIN_DATA
operator||
name|DEP_TRUE
argument_list|,
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_TRUE
argument_list|)
expr_stmt|;
block|}
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|u
operator|=
name|deps
operator|->
name|last_pending_memory_flush
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|!
name|JUMP_P
argument_list|(
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|deps_may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
comment|/* Always add these dependencies to pending_reads, since 	   this insn may be followed by a write.  */
name|add_insn_mem_dependence
argument_list|(
name|deps
argument_list|,
operator|&
name|deps
operator|->
name|pending_read_insns
argument_list|,
operator|&
name|deps
operator|->
name|pending_read_mems
argument_list|,
name|insn
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Take advantage of tail recursion here.  */
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Force pending stores to memory in case a trap handler needs them.  */
case|case
name|TRAP_IF
case|:
name|flush_pending_lists
argument_list|(
name|deps
argument_list|,
name|insn
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_OPERANDS
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|UNSPEC_VOLATILE
case|:
block|{
comment|/* Traditional and volatile asm instructions must be considered to use 	   and clobber all hard registers, all pseudo-registers and all of 	   memory.  So must TRAP_IF and UNSPEC_VOLATILE operations.  	   Consider for instance a volatile asm that changes the fpu rounding 	   mode.  An insn should not be moved across this even if it only uses 	   pseudo-regs because it might give an incorrectly rounded result.  */
if|if
condition|(
name|code
operator|!=
name|ASM_OPERANDS
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
name|reg_pending_barrier
operator|=
name|TRUE_BARRIER
expr_stmt|;
comment|/* For all ASM_OPERANDS, we must traverse the vector of input operands. 	   We can not just fall through here since then we would be confused 	   by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate 	   traditional asms unlike their normal usage.  */
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|j
operator|++
control|)
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
comment|/* These both read and modify the result.  We must handle them as writes          to get proper dependencies for following instructions.  We must handle          them as reads to get proper dependencies from this to previous          instructions.  Thus we need to pass them to both sched_analyze_1          and sched_analyze_2.  We must call sched_analyze_2 first in order          to get the proper antecedent for the read.  */
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_1
argument_list|(
name|deps
argument_list|,
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
case|case
name|POST_MODIFY
case|:
case|case
name|PRE_MODIFY
case|:
comment|/* op0 = op0 + op1 */
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_1
argument_list|(
name|deps
argument_list|,
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
comment|/* Other cases: walk the insn.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Analyze an INSN with pattern X to find all dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_insn
parameter_list|(
name|struct
name|deps
modifier|*
name|deps
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|reg_set_iterator
name|rsi
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|COND_EXEC
condition|)
block|{
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* ??? Should be recording conditions so we reduce the number of 	 false dependencies.  */
name|x
operator|=
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
block|{
name|sched_analyze_1
argument_list|(
name|deps
argument_list|,
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Bare clobber insns are used for letting life analysis, reg-stack 	 and others know that a value is dead.  Depend on the last call 	 instruction so that reg-stack won't get confused.  */
if|if
condition|(
name|code
operator|==
name|CLOBBER
condition|)
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|deps
operator|->
name|last_function_call
argument_list|,
literal|1
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
name|rtx
name|sub
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|COND_EXEC
condition|)
block|{
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|COND_EXEC_TEST
argument_list|(
name|sub
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sub
operator|=
name|COND_EXEC_CODE
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|sched_analyze_1
argument_list|(
name|deps
argument_list|,
name|sub
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|sub
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Mark registers CLOBBERED or used by called function.  */
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_analyze_1
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL
argument_list|)
condition|)
name|reg_pending_barrier
operator|=
name|MOVE_BARRIER
expr_stmt|;
block|}
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|next
decl_stmt|;
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|&&
name|BARRIER_P
argument_list|(
name|next
argument_list|)
condition|)
name|reg_pending_barrier
operator|=
name|TRUE_BARRIER
expr_stmt|;
else|else
block|{
name|rtx
name|pending
decl_stmt|,
name|pending_mem
decl_stmt|;
name|regset_head
name|tmp_uses
decl_stmt|,
name|tmp_sets
decl_stmt|;
name|INIT_REG_SET
argument_list|(
operator|&
name|tmp_uses
argument_list|)
expr_stmt|;
name|INIT_REG_SET
argument_list|(
operator|&
name|tmp_sets
argument_list|)
expr_stmt|;
call|(
modifier|*
name|current_sched_info
operator|->
name|compute_jump_reg_dependencies
call|)
argument_list|(
name|insn
argument_list|,
operator|&
name|deps
operator|->
name|reg_conditional_sets
argument_list|,
operator|&
name|tmp_uses
argument_list|,
operator|&
name|tmp_sets
argument_list|)
expr_stmt|;
comment|/* Make latency of jump equal to 0 by using anti-dependence.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&tmp_uses
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|rsi
argument_list|)
block|{
name|struct
name|deps_reg
modifier|*
name|reg_last
init|=
operator|&
name|deps
operator|->
name|reg_last
index|[
name|i
index|]
decl_stmt|;
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|sets
argument_list|,
literal|0
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|clobbers
argument_list|,
literal|0
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last
operator|->
name|uses_length
operator|++
expr_stmt|;
name|reg_last
operator|->
name|uses
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|uses
argument_list|)
expr_stmt|;
block|}
name|IOR_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|,
operator|&
name|tmp_sets
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
operator|&
name|tmp_uses
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
operator|&
name|tmp_sets
argument_list|)
expr_stmt|;
comment|/* All memory writes and volatile reads must happen before the 	     jump.  Non-volatile reads must happen before the jump iff 	     the result is needed by the above register used mask.  */
name|pending
operator|=
name|deps
operator|->
name|pending_write_insns
expr_stmt|;
name|pending_mem
operator|=
name|deps
operator|->
name|pending_write_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
if|if
condition|(
operator|!
name|sched_insns_conditions_mutex_p
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pending
operator|=
name|deps
operator|->
name|pending_read_insns
expr_stmt|;
name|pending_mem
operator|=
name|deps
operator|->
name|pending_read_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|sched_insns_conditions_mutex_p
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|deps
operator|->
name|last_pending_memory_flush
argument_list|,
literal|1
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this instruction can throw an exception, then moving it changes      where block boundaries fall.  This is mighty confusing elsewhere.      Therefore, prevent such an instruction from being moved.  Same for      non-jump instructions that define block boundaries.      ??? Unclear whether this is still necessary in EBB mode.  If not,      add_branch_dependences should be adjusted for RGN mode instead.  */
if|if
condition|(
operator|(
operator|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
operator|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|control_flow_insn_p
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|reg_pending_barrier
operator|=
name|MOVE_BARRIER
expr_stmt|;
comment|/* Add dependencies if a scheduling barrier was found.  */
if|if
condition|(
name|reg_pending_barrier
condition|)
block|{
comment|/* In the case of barrier the most added dependencies are not          real, so we use anti-dependence here.  */
if|if
condition|(
name|sched_get_condition
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&deps->reg_last_in_use
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|rsi
argument_list|)
block|{
name|struct
name|deps_reg
modifier|*
name|reg_last
init|=
operator|&
name|deps
operator|->
name|reg_last
index|[
name|i
index|]
decl_stmt|;
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|uses
argument_list|,
literal|0
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|sets
argument_list|,
literal|0
argument_list|,
name|reg_pending_barrier
operator|==
name|TRUE_BARRIER
condition|?
name|REG_DEP_TRUE
else|:
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|clobbers
argument_list|,
literal|0
argument_list|,
name|reg_pending_barrier
operator|==
name|TRUE_BARRIER
condition|?
name|REG_DEP_TRUE
else|:
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&deps->reg_last_in_use
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|rsi
argument_list|)
block|{
name|struct
name|deps_reg
modifier|*
name|reg_last
init|=
operator|&
name|deps
operator|->
name|reg_last
index|[
name|i
index|]
decl_stmt|;
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|reg_last
operator|->
name|uses
argument_list|,
literal|0
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|reg_last
operator|->
name|sets
argument_list|,
literal|0
argument_list|,
name|reg_pending_barrier
operator|==
name|TRUE_BARRIER
condition|?
name|REG_DEP_TRUE
else|:
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|reg_last
operator|->
name|clobbers
argument_list|,
literal|0
argument_list|,
name|reg_pending_barrier
operator|==
name|TRUE_BARRIER
condition|?
name|REG_DEP_TRUE
else|:
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last
operator|->
name|uses_length
operator|=
literal|0
expr_stmt|;
name|reg_last
operator|->
name|clobbers_length
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|deps
operator|->
name|max_reg
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|deps_reg
modifier|*
name|reg_last
init|=
operator|&
name|deps
operator|->
name|reg_last
index|[
name|i
index|]
decl_stmt|;
name|reg_last
operator|->
name|sets
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|sets
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_last_in_use
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|flush_pending_lists
argument_list|(
name|deps
argument_list|,
name|insn
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_conditional_sets
argument_list|)
expr_stmt|;
name|reg_pending_barrier
operator|=
name|NOT_A_BARRIER
expr_stmt|;
block|}
else|else
block|{
comment|/* If the current insn is conditional, we can't free any 	 of the lists.  */
if|if
condition|(
name|sched_get_condition
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|reg_pending_uses
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|rsi
argument_list|)
block|{
name|struct
name|deps_reg
modifier|*
name|reg_last
init|=
operator|&
name|deps
operator|->
name|reg_last
index|[
name|i
index|]
decl_stmt|;
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|sets
argument_list|,
literal|0
argument_list|,
name|REG_DEP_TRUE
argument_list|)
expr_stmt|;
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|clobbers
argument_list|,
literal|0
argument_list|,
name|REG_DEP_TRUE
argument_list|)
expr_stmt|;
name|reg_last
operator|->
name|uses
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|uses
argument_list|)
expr_stmt|;
name|reg_last
operator|->
name|uses_length
operator|++
expr_stmt|;
block|}
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|reg_pending_clobbers
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|rsi
argument_list|)
block|{
name|struct
name|deps_reg
modifier|*
name|reg_last
init|=
operator|&
name|deps
operator|->
name|reg_last
index|[
name|i
index|]
decl_stmt|;
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|sets
argument_list|,
literal|0
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|uses
argument_list|,
literal|0
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last
operator|->
name|clobbers
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|clobbers
argument_list|)
expr_stmt|;
name|reg_last
operator|->
name|clobbers_length
operator|++
expr_stmt|;
block|}
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|reg_pending_sets
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|rsi
argument_list|)
block|{
name|struct
name|deps_reg
modifier|*
name|reg_last
init|=
operator|&
name|deps
operator|->
name|reg_last
index|[
name|i
index|]
decl_stmt|;
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|sets
argument_list|,
literal|0
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|clobbers
argument_list|,
literal|0
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|uses
argument_list|,
literal|0
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last
operator|->
name|sets
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|sets
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_conditional_sets
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|reg_pending_uses
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|rsi
argument_list|)
block|{
name|struct
name|deps_reg
modifier|*
name|reg_last
init|=
operator|&
name|deps
operator|->
name|reg_last
index|[
name|i
index|]
decl_stmt|;
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|sets
argument_list|,
literal|0
argument_list|,
name|REG_DEP_TRUE
argument_list|)
expr_stmt|;
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|clobbers
argument_list|,
literal|0
argument_list|,
name|REG_DEP_TRUE
argument_list|)
expr_stmt|;
name|reg_last
operator|->
name|uses_length
operator|++
expr_stmt|;
name|reg_last
operator|->
name|uses
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|uses
argument_list|)
expr_stmt|;
block|}
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|reg_pending_clobbers
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|rsi
argument_list|)
block|{
name|struct
name|deps_reg
modifier|*
name|reg_last
init|=
operator|&
name|deps
operator|->
name|reg_last
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|reg_last
operator|->
name|uses_length
operator|>
name|MAX_PENDING_LIST_LENGTH
operator|||
name|reg_last
operator|->
name|clobbers_length
operator|>
name|MAX_PENDING_LIST_LENGTH
condition|)
block|{
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|reg_last
operator|->
name|sets
argument_list|,
literal|0
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|reg_last
operator|->
name|uses
argument_list|,
literal|0
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|reg_last
operator|->
name|clobbers
argument_list|,
literal|0
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|reg_last
operator|->
name|sets
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|sets
argument_list|)
expr_stmt|;
name|reg_last
operator|->
name|clobbers_length
operator|=
literal|0
expr_stmt|;
name|reg_last
operator|->
name|uses_length
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|sets
argument_list|,
literal|0
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|uses
argument_list|,
literal|0
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
name|reg_last
operator|->
name|clobbers_length
operator|++
expr_stmt|;
name|reg_last
operator|->
name|clobbers
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|clobbers
argument_list|)
expr_stmt|;
block|}
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|reg_pending_sets
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|rsi
argument_list|)
block|{
name|struct
name|deps_reg
modifier|*
name|reg_last
init|=
operator|&
name|deps
operator|->
name|reg_last
index|[
name|i
index|]
decl_stmt|;
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|reg_last
operator|->
name|sets
argument_list|,
literal|0
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|reg_last
operator|->
name|clobbers
argument_list|,
literal|0
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|reg_last
operator|->
name|uses
argument_list|,
literal|0
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last
operator|->
name|sets
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|sets
argument_list|)
expr_stmt|;
name|reg_last
operator|->
name|uses_length
operator|=
literal|0
expr_stmt|;
name|reg_last
operator|->
name|clobbers_length
operator|=
literal|0
expr_stmt|;
name|CLEAR_REGNO_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_conditional_sets
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|IOR_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_last_in_use
argument_list|,
name|reg_pending_uses
argument_list|)
expr_stmt|;
name|IOR_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_last_in_use
argument_list|,
name|reg_pending_clobbers
argument_list|)
expr_stmt|;
name|IOR_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_last_in_use
argument_list|,
name|reg_pending_sets
argument_list|)
expr_stmt|;
block|}
name|CLEAR_REG_SET
argument_list|(
name|reg_pending_uses
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|reg_pending_clobbers
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|)
expr_stmt|;
comment|/* If we are currently in a libcall scheduling group, then mark the      current insn as being in a scheduling group and that it can not      be moved into a different basic block.  */
if|if
condition|(
name|deps
operator|->
name|libcall_block_tail_insn
condition|)
block|{
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CANT_MOVE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If a post-call group is still open, see if it should remain so.      This insn must be a simple move of a hard reg to a pseudo or      vice-versa.       We must avoid moving these insns for correctness on      SMALL_REGISTER_CLASS machines, and for special registers like      PIC_OFFSET_TABLE_REGNUM.  For simplicity, extend this to all      hard regs for all targets.  */
if|if
condition|(
name|deps
operator|->
name|in_post_call_group_p
condition|)
block|{
name|rtx
name|tmp
decl_stmt|,
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|src_regno
decl_stmt|,
name|dest_regno
decl_stmt|;
if|if
condition|(
name|set
operator|==
name|NULL
condition|)
goto|goto
name|end_call_group
goto|;
name|tmp
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|tmp
argument_list|)
condition|)
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
goto|goto
name|end_call_group
goto|;
name|tmp
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|MINUS
operator|)
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|dest_regno
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|src_regno
operator|=
name|STACK_POINTER_REGNUM
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|tmp
argument_list|)
condition|)
name|src_regno
operator|=
name|REGNO
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
goto|goto
name|end_call_group
goto|;
if|if
condition|(
name|src_regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|dest_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|deps
operator|->
name|in_post_call_group_p
operator|==
name|post_call_initial
condition|)
name|deps
operator|->
name|in_post_call_group_p
operator|=
name|post_call
expr_stmt|;
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CANT_MOVE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|end_call_group
label|:
name|deps
operator|->
name|in_post_call_group_p
operator|=
name|not_post_call
expr_stmt|;
block|}
block|}
comment|/* Fixup the dependencies in the sched group.  */
if|if
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
name|fixup_sched_groups
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Analyze every insn between HEAD and TAIL inclusive, creating LOG_LINKS    for every dependency.  */
end_comment

begin_function
name|void
name|sched_analyze
parameter_list|(
name|struct
name|deps
modifier|*
name|deps
parameter_list|,
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|use_cselib
condition|)
name|cselib_init
argument_list|(
name|true
argument_list|)
expr_stmt|;
comment|/* Before reload, if the previous block ended in a call, show that      we are inside a post-call group, so as to keep the lifetimes of      hard registers correct.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
operator|!
name|LABEL_P
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|deps
operator|->
name|in_post_call_group_p
operator|=
name|post_call_initial
expr_stmt|;
block|}
for|for
control|(
name|insn
operator|=
name|head
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|link
decl_stmt|,
name|end_seq
decl_stmt|,
name|r0
decl_stmt|,
name|set
decl_stmt|;
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Clear out the stale LOG_LINKS from flow.  */
name|free_INSN_LIST_list
argument_list|(
operator|&
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make each JUMP_INSN a scheduling barrier for memory              references.  */
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Keep the list a reasonable size.  */
if|if
condition|(
name|deps
operator|->
name|pending_flush_length
operator|++
operator|>
name|MAX_PENDING_LIST_LENGTH
condition|)
name|flush_pending_lists
argument_list|(
name|deps
argument_list|,
name|insn
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
name|deps
operator|->
name|last_pending_memory_flush
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|deps
operator|->
name|last_pending_memory_flush
argument_list|)
expr_stmt|;
block|}
name|sched_analyze_insn
argument_list|(
name|deps
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|CANT_MOVE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Clear out the stale LOG_LINKS from flow.  */
name|free_INSN_LIST_list
argument_list|(
operator|&
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/* This is setjmp.  Assume that all registers, not just 		 hard registers, may be clobbered by this call.  */
name|reg_pending_barrier
operator|=
name|MOVE_BARRIER
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
comment|/* A call may read and modify global register variables.  */
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_uses
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Other call-clobbered hard regs may be clobbered. 		   Since we only have a choice between 'might be clobbered' 		   and 'definitely not clobbered', we must include all 		   partly call-clobbered registers here.  */
elseif|else
if|if
condition|(
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|i
argument_list|,
name|reg_raw_mode
index|[
name|i
index|]
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_clobbers
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* We don't know what set of fixed registers might be used 		   by the function, but it is certain that the stack pointer 		   is among them, but be conservative.  */
elseif|else
if|if
condition|(
name|fixed_regs
index|[
name|i
index|]
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_uses
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* The frame pointer is normally not used by the function 		   itself, but by the debugger.  */
comment|/* ??? MIPS o32 is an exception.  It uses the frame pointer 		   in the macro expansion of jal but does not represent this 		   fact in the call_insn rtl.  */
elseif|else
if|if
condition|(
name|i
operator|==
name|FRAME_POINTER_REGNUM
operator|||
operator|(
name|i
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_uses
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* For each insn which shouldn't cross a call, add a dependence 	     between that insn and this call insn.  */
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|deps
operator|->
name|sched_before_next_call
argument_list|,
literal|1
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|sched_analyze_insn
argument_list|(
name|deps
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* In the absence of interprocedural alias analysis, we must flush 	     all pending reads and writes, and start new dependencies starting 	     from here.  But only flush writes for constant calls (which may 	     be passed a pointer to something we haven't written yet).  */
name|flush_pending_lists
argument_list|(
name|deps
argument_list|,
name|insn
argument_list|,
name|true
argument_list|,
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember the last function call for limiting lifetimes.  */
name|free_INSN_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|last_function_call
argument_list|)
expr_stmt|;
name|deps
operator|->
name|last_function_call
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Before reload, begin a post-call group, so as to keep the 	     lifetimes of hard registers correct.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|deps
operator|->
name|in_post_call_group_p
operator|=
name|post_call
expr_stmt|;
block|}
comment|/* EH_REGION insn notes can not appear until well after we complete 	 scheduling.  */
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
name|gcc_assert
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_EH_REGION_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_EH_REGION_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|use_cselib
condition|)
name|cselib_process_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Now that we have completed handling INSN, check and see if it is 	 a CLOBBER beginning a libcall block.   If it is, record the 	 end of the libcall sequence.  	 We want to schedule libcall blocks as a unit before reload.  While 	 this restricts scheduling, it preserves the meaning of a libcall 	 block.  	 As a side effect, we may get better code due to decreased register 	 pressure as well as less chance of a foreign insn appearing in 	 a libcall block.  */
if|if
condition|(
operator|!
name|reload_completed
comment|/* Note we may have nested libcall sequences.  We only care about 	     the outermost libcall sequence.  */
operator|&&
name|deps
operator|->
name|libcall_block_tail_insn
operator|==
literal|0
comment|/* The sequence must start with a clobber of a register.  */
operator|&&
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
operator|(
name|r0
operator|=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|,
name|REG_P
argument_list|(
name|r0
argument_list|)
operator|)
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
comment|/* The CLOBBER must also have a REG_LIBCALL note attached.  */
operator|&&
operator|(
name|link
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|end_seq
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
comment|/* The insn referenced by the REG_LIBCALL note must be a 	     simple nop copy with the same destination as the register 	     mentioned in the clobber.  */
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|end_seq
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|r0
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|r0
comment|/* And finally the insn referenced by the REG_LIBCALL must 	     also contain a REG_EQUAL note and a REG_RETVAL note.  */
operator|&&
name|find_reg_note
argument_list|(
name|end_seq
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|!=
literal|0
operator|&&
name|find_reg_note
argument_list|(
name|end_seq
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|!=
literal|0
condition|)
name|deps
operator|->
name|libcall_block_tail_insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we have reached the end of a libcall block, then close the 	 block.  */
if|if
condition|(
name|deps
operator|->
name|libcall_block_tail_insn
operator|==
name|insn
condition|)
name|deps
operator|->
name|libcall_block_tail_insn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|tail
condition|)
block|{
if|if
condition|(
name|current_sched_info
operator|->
name|use_cselib
condition|)
name|cselib_finish
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following function adds forward dependence (FROM, TO) with    given DEP_TYPE.  The forward dependence should be not exist before.  */
end_comment

begin_function
name|void
name|add_forw_dep
parameter_list|(
name|rtx
name|to
parameter_list|,
name|rtx
name|link
parameter_list|)
block|{
name|rtx
name|new_link
decl_stmt|,
name|from
decl_stmt|;
name|from
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* If add_dependence is working properly there should never      be notes, deleted insns or duplicates in the backward      links.  Thus we need not check for them here.       However, if we have enabled checking we might as well go      ahead and verify that add_dependence worked properly.  */
name|gcc_assert
argument_list|(
name|INSN_P
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|true_dependency_cache
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|bitmap_bit_p
argument_list|(
operator|&
name|forward_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|from
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
operator|&
name|forward_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|from
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_assert
argument_list|(
operator|!
name|find_insn_list
argument_list|(
name|to
argument_list|,
name|INSN_DEPEND
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|current_sched_info
operator|->
name|flags
operator|&
name|USE_DEPS_LIST
operator|)
condition|)
name|new_link
operator|=
name|alloc_INSN_LIST
argument_list|(
name|to
argument_list|,
name|INSN_DEPEND
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|new_link
operator|=
name|alloc_DEPS_LIST
argument_list|(
name|to
argument_list|,
name|INSN_DEPEND
argument_list|(
name|from
argument_list|)
argument_list|,
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|new_link
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_DEPEND
argument_list|(
name|from
argument_list|)
operator|=
name|new_link
expr_stmt|;
name|INSN_DEP_COUNT
argument_list|(
name|to
argument_list|)
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Examine insns in the range [ HEAD, TAIL ] and Use the backward    dependences from LOG_LINKS to build forward dependences in    INSN_DEPEND.  */
end_comment

begin_function
name|void
name|compute_forward_dependences
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|next_tail
decl_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
condition|)
block|{
name|rtx
name|new
init|=
literal|0
decl_stmt|,
name|link
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|adjust_add_sorted_back_dep
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
block|}
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|add_forw_dep
argument_list|(
name|insn
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize variables for region data dependence analysis.    n_bbs is the number of region blocks.  */
end_comment

begin_function
name|void
name|init_deps
parameter_list|(
name|struct
name|deps
modifier|*
name|deps
parameter_list|)
block|{
name|int
name|max_reg
init|=
operator|(
name|reload_completed
condition|?
name|FIRST_PSEUDO_REGISTER
else|:
name|max_reg_num
argument_list|()
operator|)
decl_stmt|;
name|deps
operator|->
name|max_reg
operator|=
name|max_reg
expr_stmt|;
name|deps
operator|->
name|reg_last
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|deps_reg
argument_list|,
name|max_reg
argument_list|)
expr_stmt|;
name|INIT_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_last_in_use
argument_list|)
expr_stmt|;
name|INIT_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_conditional_sets
argument_list|)
expr_stmt|;
name|deps
operator|->
name|pending_read_insns
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|pending_read_mems
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|pending_write_insns
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|pending_write_mems
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|pending_lists_length
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|pending_flush_length
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|last_pending_memory_flush
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|last_function_call
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|sched_before_next_call
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|in_post_call_group_p
operator|=
name|not_post_call
expr_stmt|;
name|deps
operator|->
name|libcall_block_tail_insn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free insn lists found in DEPS.  */
end_comment

begin_function
name|void
name|free_deps
parameter_list|(
name|struct
name|deps
modifier|*
name|deps
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|reg_set_iterator
name|rsi
decl_stmt|;
name|free_INSN_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|pending_read_insns
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|pending_read_mems
argument_list|)
expr_stmt|;
name|free_INSN_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|pending_write_insns
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|pending_write_mems
argument_list|)
expr_stmt|;
name|free_INSN_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|last_pending_memory_flush
argument_list|)
expr_stmt|;
comment|/* Without the EXECUTE_IF_SET, this loop is executed max_reg * nr_regions      times.  For a testcase with 42000 regs and 8000 small basic blocks,      this loop accounted for nearly 60% (84 sec) of the total -O2 runtime.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&deps->reg_last_in_use
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|rsi
argument_list|)
block|{
name|struct
name|deps_reg
modifier|*
name|reg_last
init|=
operator|&
name|deps
operator|->
name|reg_last
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|reg_last
operator|->
name|uses
condition|)
name|free_INSN_LIST_list
argument_list|(
operator|&
name|reg_last
operator|->
name|uses
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_last
operator|->
name|sets
condition|)
name|free_INSN_LIST_list
argument_list|(
operator|&
name|reg_last
operator|->
name|sets
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_last
operator|->
name|clobbers
condition|)
name|free_INSN_LIST_list
argument_list|(
operator|&
name|reg_last
operator|->
name|clobbers
argument_list|)
expr_stmt|;
block|}
name|CLEAR_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_last_in_use
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_conditional_sets
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|deps
operator|->
name|reg_last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If it is profitable to use them, initialize caches for tracking    dependency information.  LUID is the number of insns to be scheduled,    it is used in the estimate of profitability.  */
end_comment

begin_function
name|void
name|init_dependency_caches
parameter_list|(
name|int
name|luid
parameter_list|)
block|{
comment|/* ?!? We could save some memory by computing a per-region luid mapping      which could reduce both the number of vectors in the cache and the size      of each vector.  Instead we just avoid the cache entirely unless the      average number of instructions in a basic block is very high.  See      the comment before the declaration of true_dependency_cache for      what we consider "very high".  */
if|if
condition|(
name|luid
operator|/
name|n_basic_blocks
operator|>
literal|100
operator|*
literal|5
condition|)
block|{
name|cache_size
operator|=
literal|0
expr_stmt|;
name|extend_dependency_caches
argument_list|(
name|luid
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create or extend (depending on CREATE_P) dependency caches to    size N.  */
end_comment

begin_function
name|void
name|extend_dependency_caches
parameter_list|(
name|int
name|n
parameter_list|,
name|bool
name|create_p
parameter_list|)
block|{
if|if
condition|(
name|create_p
operator|||
name|true_dependency_cache
condition|)
block|{
name|int
name|i
decl_stmt|,
name|luid
init|=
name|cache_size
operator|+
name|n
decl_stmt|;
name|true_dependency_cache
operator|=
name|XRESIZEVEC
argument_list|(
name|bitmap_head
argument_list|,
name|true_dependency_cache
argument_list|,
name|luid
argument_list|)
expr_stmt|;
name|output_dependency_cache
operator|=
name|XRESIZEVEC
argument_list|(
name|bitmap_head
argument_list|,
name|output_dependency_cache
argument_list|,
name|luid
argument_list|)
expr_stmt|;
name|anti_dependency_cache
operator|=
name|XRESIZEVEC
argument_list|(
name|bitmap_head
argument_list|,
name|anti_dependency_cache
argument_list|,
name|luid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|forward_dependency_cache
operator|=
name|XRESIZEVEC
argument_list|(
name|bitmap_head
argument_list|,
name|forward_dependency_cache
argument_list|,
name|luid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
condition|)
name|spec_dependency_cache
operator|=
name|XRESIZEVEC
argument_list|(
name|bitmap_head
argument_list|,
name|spec_dependency_cache
argument_list|,
name|luid
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cache_size
init|;
name|i
operator|<
name|luid
condition|;
name|i
operator|++
control|)
block|{
name|bitmap_initialize
argument_list|(
operator|&
name|true_dependency_cache
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bitmap_initialize
argument_list|(
operator|&
name|output_dependency_cache
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bitmap_initialize
argument_list|(
operator|&
name|anti_dependency_cache
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|bitmap_initialize
argument_list|(
operator|&
name|forward_dependency_cache
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
condition|)
name|bitmap_initialize
argument_list|(
operator|&
name|spec_dependency_cache
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cache_size
operator|=
name|luid
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free the caches allocated in init_dependency_caches.  */
end_comment

begin_function
name|void
name|free_dependency_caches
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|true_dependency_cache
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cache_size
condition|;
name|i
operator|++
control|)
block|{
name|bitmap_clear
argument_list|(
operator|&
name|true_dependency_cache
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
operator|&
name|output_dependency_cache
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
operator|&
name|anti_dependency_cache
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|bitmap_clear
argument_list|(
operator|&
name|forward_dependency_cache
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
condition|)
name|bitmap_clear
argument_list|(
operator|&
name|spec_dependency_cache
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|true_dependency_cache
argument_list|)
expr_stmt|;
name|true_dependency_cache
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|output_dependency_cache
argument_list|)
expr_stmt|;
name|output_dependency_cache
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|anti_dependency_cache
argument_list|)
expr_stmt|;
name|anti_dependency_cache
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|free
argument_list|(
name|forward_dependency_cache
argument_list|)
expr_stmt|;
name|forward_dependency_cache
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
condition|)
block|{
name|free
argument_list|(
name|spec_dependency_cache
argument_list|)
expr_stmt|;
name|spec_dependency_cache
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Initialize some global variables needed by the dependency analysis    code.  */
end_comment

begin_function
name|void
name|init_deps_global
parameter_list|(
name|void
parameter_list|)
block|{
name|reg_pending_sets
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|reg_pending_clobbers
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|reg_pending_uses
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|reg_pending_barrier
operator|=
name|NOT_A_BARRIER
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free everything used by the dependency analysis code.  */
end_comment

begin_function
name|void
name|finish_deps_global
parameter_list|(
name|void
parameter_list|)
block|{
name|FREE_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|reg_pending_clobbers
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|reg_pending_uses
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert LINK into the dependence chain pointed to by LINKP and     maintain the sort order.  */
end_comment

begin_function
specifier|static
name|void
name|adjust_add_sorted_back_dep
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
modifier|*
name|linkp
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
argument_list|)
expr_stmt|;
comment|/* If the insn cannot move speculatively, but the link is speculative,         make it hard dependence.  */
if|if
condition|(
name|HAS_INTERNAL_DEP
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|&
name|SPECULATIVE
operator|)
condition|)
block|{
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|&=
operator|~
name|SPECULATIVE
expr_stmt|;
if|if
condition|(
name|true_dependency_cache
condition|)
name|bitmap_clear_bit
argument_list|(
operator|&
name|spec_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Non-speculative links go at the head of LOG_LINKS, followed by      speculative links.  */
if|if
condition|(
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|&
name|SPECULATIVE
condition|)
while|while
condition|(
operator|*
name|linkp
operator|&&
operator|!
operator|(
name|DEP_STATUS
argument_list|(
operator|*
name|linkp
argument_list|)
operator|&
name|SPECULATIVE
operator|)
condition|)
name|linkp
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|linkp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
operator|*
name|linkp
expr_stmt|;
operator|*
name|linkp
operator|=
name|link
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move the dependence pointed to by LINKP to the back dependencies      of INSN, and also add this dependence to the forward ones.  All LOG_LINKS,    except one pointed to by LINKP, must be sorted.  */
end_comment

begin_function
specifier|static
name|void
name|adjust_back_add_forw_dep
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|linkp
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
name|gcc_assert
argument_list|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
argument_list|)
expr_stmt|;
name|link
operator|=
operator|*
name|linkp
expr_stmt|;
operator|*
name|linkp
operator|=
name|XEXP
argument_list|(
operator|*
name|linkp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|adjust_add_sorted_back_dep
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
operator|&
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|add_forw_dep
argument_list|(
name|insn
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove forward dependence ELEM from the DEPS_LIST of INSN.  */
end_comment

begin_function
specifier|static
name|void
name|delete_forw_dep
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|elem
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|true_dependency_cache
condition|)
name|bitmap_clear_bit
argument_list|(
operator|&
name|forward_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|remove_free_DEPS_LIST_elem
argument_list|(
name|insn
argument_list|,
operator|&
name|INSN_DEPEND
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_DEP_COUNT
argument_list|(
name|insn
argument_list|)
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Estimate the weakness of dependence between MEM1 and MEM2.  */
end_comment

begin_function
specifier|static
name|dw_t
name|estimate_dep_weak
parameter_list|(
name|rtx
name|mem1
parameter_list|,
name|rtx
name|mem2
parameter_list|)
block|{
name|rtx
name|r1
decl_stmt|,
name|r2
decl_stmt|;
if|if
condition|(
name|mem1
operator|==
name|mem2
condition|)
comment|/* MEMs are the same - don't speculate.  */
return|return
name|MIN_DEP_WEAK
return|;
name|r1
operator|=
name|XEXP
argument_list|(
name|mem1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r2
operator|=
name|XEXP
argument_list|(
name|mem2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|==
name|r2
operator|||
operator|(
name|REG_P
argument_list|(
name|r1
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|r2
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|r1
argument_list|)
operator|==
name|REGNO
argument_list|(
name|r2
argument_list|)
operator|)
condition|)
comment|/* Again, MEMs are the same.  */
return|return
name|MIN_DEP_WEAK
return|;
elseif|else
if|if
condition|(
operator|(
name|REG_P
argument_list|(
name|r1
argument_list|)
operator|&&
operator|!
name|REG_P
argument_list|(
name|r2
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|REG_P
argument_list|(
name|r1
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|r2
argument_list|)
operator|)
condition|)
comment|/* Different addressing modes - reason to be more speculative,        than usual.  */
return|return
name|NO_DEP_WEAK
operator|-
operator|(
name|NO_DEP_WEAK
operator|-
name|UNCERTAIN_DEP_WEAK
operator|)
operator|/
literal|2
return|;
else|else
comment|/* We can't say anything about the dependence.  */
return|return
name|UNCERTAIN_DEP_WEAK
return|;
block|}
end_function

begin_comment
comment|/* Add or update backward dependence between INSN and ELEM with type DEP_TYPE.    This function can handle same INSN and ELEM (INSN == ELEM).    It is a convenience wrapper.  */
end_comment

begin_function
name|void
name|add_dependence
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|elem
parameter_list|,
name|enum
name|reg_note
name|dep_type
parameter_list|)
block|{
name|ds_t
name|ds
decl_stmt|;
if|if
condition|(
name|dep_type
operator|==
name|REG_DEP_TRUE
condition|)
name|ds
operator|=
name|DEP_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|dep_type
operator|==
name|REG_DEP_OUTPUT
condition|)
name|ds
operator|=
name|DEP_OUTPUT
expr_stmt|;
elseif|else
if|if
condition|(
name|dep_type
operator|==
name|REG_DEP_ANTI
condition|)
name|ds
operator|=
name|DEP_ANTI
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|maybe_add_or_update_back_dep_1
argument_list|(
name|insn
argument_list|,
name|elem
argument_list|,
name|dep_type
argument_list|,
name|ds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add or update backward dependence between INSN and ELEM    with given type DEP_TYPE and dep_status DS.    This function is a convenience wrapper.  */
end_comment

begin_function
name|enum
name|DEPS_ADJUST_RESULT
name|add_or_update_back_dep
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|elem
parameter_list|,
name|enum
name|reg_note
name|dep_type
parameter_list|,
name|ds_t
name|ds
parameter_list|)
block|{
return|return
name|add_or_update_back_dep_1
argument_list|(
name|insn
argument_list|,
name|elem
argument_list|,
name|dep_type
argument_list|,
name|ds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add or update both backward and forward dependencies between INSN and ELEM    with given type DEP_TYPE and dep_status DS.  */
end_comment

begin_function
name|void
name|add_or_update_back_forw_dep
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|elem
parameter_list|,
name|enum
name|reg_note
name|dep_type
parameter_list|,
name|ds_t
name|ds
parameter_list|)
block|{
name|enum
name|DEPS_ADJUST_RESULT
name|res
decl_stmt|;
name|rtx
modifier|*
name|linkp
decl_stmt|;
name|res
operator|=
name|add_or_update_back_dep_1
argument_list|(
name|insn
argument_list|,
name|elem
argument_list|,
name|dep_type
argument_list|,
name|ds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|linkp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|DEP_CHANGED
operator|||
name|res
operator|==
name|DEP_CREATED
condition|)
block|{
if|if
condition|(
name|res
operator|==
name|DEP_CHANGED
condition|)
name|delete_forw_dep
argument_list|(
name|insn
argument_list|,
name|elem
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|res
operator|==
name|DEP_CREATED
condition|)
name|linkp
operator|=
operator|&
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|adjust_back_add_forw_dep
argument_list|(
name|insn
argument_list|,
name|linkp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add both backward and forward dependencies between INSN and ELEM    with given type DEP_TYPE and dep_status DS.  */
end_comment

begin_function
name|void
name|add_back_forw_dep
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|elem
parameter_list|,
name|enum
name|reg_note
name|dep_type
parameter_list|,
name|ds_t
name|ds
parameter_list|)
block|{
name|add_back_dep
argument_list|(
name|insn
argument_list|,
name|elem
argument_list|,
name|dep_type
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|adjust_back_add_forw_dep
argument_list|(
name|insn
argument_list|,
operator|&
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove both backward and forward dependencies between INSN and ELEM.  */
end_comment

begin_function
name|void
name|delete_back_forw_dep
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|elem
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|true_dependency_cache
operator|!=
name|NULL
condition|)
block|{
name|bitmap_clear_bit
argument_list|(
operator|&
name|true_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
operator|&
name|anti_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
operator|&
name|output_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
operator|&
name|spec_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|remove_free_DEPS_LIST_elem
argument_list|(
name|elem
argument_list|,
operator|&
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|delete_forw_dep
argument_list|(
name|insn
argument_list|,
name|elem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return weakness of speculative type TYPE in the dep_status DS.  */
end_comment

begin_function
name|dw_t
name|get_dep_weak
parameter_list|(
name|ds_t
name|ds
parameter_list|,
name|ds_t
name|type
parameter_list|)
block|{
name|ds
operator|=
name|ds
operator|&
name|type
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BEGIN_DATA
case|:
name|ds
operator|>>=
name|BEGIN_DATA_BITS_OFFSET
expr_stmt|;
break|break;
case|case
name|BE_IN_DATA
case|:
name|ds
operator|>>=
name|BE_IN_DATA_BITS_OFFSET
expr_stmt|;
break|break;
case|case
name|BEGIN_CONTROL
case|:
name|ds
operator|>>=
name|BEGIN_CONTROL_BITS_OFFSET
expr_stmt|;
break|break;
case|case
name|BE_IN_CONTROL
case|:
name|ds
operator|>>=
name|BE_IN_CONTROL_BITS_OFFSET
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|MIN_DEP_WEAK
operator|<=
name|ds
operator|&&
name|ds
operator|<=
name|MAX_DEP_WEAK
argument_list|)
expr_stmt|;
return|return
operator|(
name|dw_t
operator|)
name|ds
return|;
block|}
end_function

begin_comment
comment|/* Return the dep_status, which has the same parameters as DS, except for    speculative type TYPE, that will have weakness DW.  */
end_comment

begin_function
name|ds_t
name|set_dep_weak
parameter_list|(
name|ds_t
name|ds
parameter_list|,
name|ds_t
name|type
parameter_list|,
name|dw_t
name|dw
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|MIN_DEP_WEAK
operator|<=
name|dw
operator|&&
name|dw
operator|<=
name|MAX_DEP_WEAK
argument_list|)
expr_stmt|;
name|ds
operator|&=
operator|~
name|type
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BEGIN_DATA
case|:
name|ds
operator||=
operator|(
operator|(
name|ds_t
operator|)
name|dw
operator|)
operator|<<
name|BEGIN_DATA_BITS_OFFSET
expr_stmt|;
break|break;
case|case
name|BE_IN_DATA
case|:
name|ds
operator||=
operator|(
operator|(
name|ds_t
operator|)
name|dw
operator|)
operator|<<
name|BE_IN_DATA_BITS_OFFSET
expr_stmt|;
break|break;
case|case
name|BEGIN_CONTROL
case|:
name|ds
operator||=
operator|(
operator|(
name|ds_t
operator|)
name|dw
operator|)
operator|<<
name|BEGIN_CONTROL_BITS_OFFSET
expr_stmt|;
break|break;
case|case
name|BE_IN_CONTROL
case|:
name|ds
operator||=
operator|(
operator|(
name|ds_t
operator|)
name|dw
operator|)
operator|<<
name|BE_IN_CONTROL_BITS_OFFSET
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|ds
return|;
block|}
end_function

begin_comment
comment|/* Return the join of two dep_statuses DS1 and DS2.  */
end_comment

begin_function
name|ds_t
name|ds_merge
parameter_list|(
name|ds_t
name|ds1
parameter_list|,
name|ds_t
name|ds2
parameter_list|)
block|{
name|ds_t
name|ds
decl_stmt|,
name|t
decl_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|ds1
operator|&
name|SPECULATIVE
operator|)
operator|&&
operator|(
name|ds2
operator|&
name|SPECULATIVE
operator|)
argument_list|)
expr_stmt|;
name|ds
operator|=
operator|(
name|ds1
operator|&
name|DEP_TYPES
operator|)
operator||
operator|(
name|ds2
operator|&
name|DEP_TYPES
operator|)
expr_stmt|;
name|t
operator|=
name|FIRST_SPEC_TYPE
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|ds1
operator|&
name|t
operator|)
operator|&&
operator|!
operator|(
name|ds2
operator|&
name|t
operator|)
condition|)
name|ds
operator||=
name|ds1
operator|&
name|t
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|ds1
operator|&
name|t
operator|)
operator|&&
operator|(
name|ds2
operator|&
name|t
operator|)
condition|)
name|ds
operator||=
name|ds2
operator|&
name|t
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ds1
operator|&
name|t
operator|)
operator|&&
operator|(
name|ds2
operator|&
name|t
operator|)
condition|)
block|{
name|ds_t
name|dw
decl_stmt|;
name|dw
operator|=
operator|(
operator|(
name|ds_t
operator|)
name|get_dep_weak
argument_list|(
name|ds1
argument_list|,
name|t
argument_list|)
operator|)
operator|*
operator|(
operator|(
name|ds_t
operator|)
name|get_dep_weak
argument_list|(
name|ds2
argument_list|,
name|t
argument_list|)
operator|)
expr_stmt|;
name|dw
operator|/=
name|MAX_DEP_WEAK
expr_stmt|;
if|if
condition|(
name|dw
operator|<
name|MIN_DEP_WEAK
condition|)
name|dw
operator|=
name|MIN_DEP_WEAK
expr_stmt|;
name|ds
operator|=
name|set_dep_weak
argument_list|(
name|ds
argument_list|,
name|t
argument_list|,
operator|(
name|dw_t
operator|)
name|dw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|LAST_SPEC_TYPE
condition|)
break|break;
name|t
operator|<<=
name|SPEC_TYPE_SHIFT
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
return|return
name|ds
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_comment
comment|/* Verify that dependence type and status are consistent.    If RELAXED_P is true, then skip dep_weakness checks.  */
end_comment

begin_function
specifier|static
name|void
name|check_dep_status
parameter_list|(
name|enum
name|reg_note
name|dt
parameter_list|,
name|ds_t
name|ds
parameter_list|,
name|bool
name|relaxed_p
parameter_list|)
block|{
comment|/* Check that dependence type contains the same bits as the status.  */
if|if
condition|(
name|dt
operator|==
name|REG_DEP_TRUE
condition|)
name|gcc_assert
argument_list|(
name|ds
operator|&
name|DEP_TRUE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dt
operator|==
name|REG_DEP_OUTPUT
condition|)
name|gcc_assert
argument_list|(
operator|(
name|ds
operator|&
name|DEP_OUTPUT
operator|)
operator|&&
operator|!
operator|(
name|ds
operator|&
name|DEP_TRUE
operator|)
argument_list|)
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
operator|(
name|dt
operator|==
name|REG_DEP_ANTI
operator|)
operator|&&
operator|(
name|ds
operator|&
name|DEP_ANTI
operator|)
operator|&&
operator|!
operator|(
name|ds
operator|&
operator|(
name|DEP_OUTPUT
operator||
name|DEP_TRUE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* HARD_DEP can not appear in dep_status of a link.  */
name|gcc_assert
argument_list|(
operator|!
operator|(
name|ds
operator|&
name|HARD_DEP
operator|)
argument_list|)
expr_stmt|;
comment|/* Check that dependence status is set correctly when speculation is not      supported.  */
if|if
condition|(
operator|!
operator|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
operator|)
condition|)
name|gcc_assert
argument_list|(
operator|!
operator|(
name|ds
operator|&
name|SPECULATIVE
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ds
operator|&
name|SPECULATIVE
condition|)
block|{
if|if
condition|(
operator|!
name|relaxed_p
condition|)
block|{
name|ds_t
name|type
init|=
name|FIRST_SPEC_TYPE
decl_stmt|;
comment|/* Check that dependence weakness is in proper range.  */
do|do
block|{
if|if
condition|(
name|ds
operator|&
name|type
condition|)
name|get_dep_weak
argument_list|(
name|ds
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|LAST_SPEC_TYPE
condition|)
break|break;
name|type
operator|<<=
name|SPEC_TYPE_SHIFT
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
if|if
condition|(
name|ds
operator|&
name|BEGIN_SPEC
condition|)
block|{
comment|/* Only true dependence can be data speculative.  */
if|if
condition|(
name|ds
operator|&
name|BEGIN_DATA
condition|)
name|gcc_assert
argument_list|(
name|ds
operator|&
name|DEP_TRUE
argument_list|)
expr_stmt|;
comment|/* Control dependencies in the insn scheduler are represented by 	     anti-dependencies, therefore only anti dependence can be 	     control speculative.  */
if|if
condition|(
name|ds
operator|&
name|BEGIN_CONTROL
condition|)
name|gcc_assert
argument_list|(
name|ds
operator|&
name|DEP_ANTI
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Subsequent speculations should resolve true dependencies.  */
name|gcc_assert
argument_list|(
operator|(
name|ds
operator|&
name|DEP_TYPES
operator|)
operator|==
name|DEP_TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* Check that true and anti dependencies can't have other speculative  	 statuses.  */
if|if
condition|(
name|ds
operator|&
name|DEP_TRUE
condition|)
name|gcc_assert
argument_list|(
name|ds
operator|&
operator|(
name|BEGIN_DATA
operator||
name|BE_IN_SPEC
operator|)
argument_list|)
expr_stmt|;
comment|/* An output dependence can't be speculative at all.  */
name|gcc_assert
argument_list|(
operator|!
operator|(
name|ds
operator|&
name|DEP_OUTPUT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|&
name|DEP_ANTI
condition|)
name|gcc_assert
argument_list|(
name|ds
operator|&
name|BEGIN_CONTROL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

